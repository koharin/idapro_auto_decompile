void __noreturn sub_1AE50()
{
  __assert_fail("pfchan->vt == &PortForwarding_channelvt", "portfwd.c", 0x1F9u, "portfwd_raw_setup");
}

void __noreturn sub_1AE73()
{
  __assert_fail("pqb->end.next != &pqb->end || pqb->total_size == 0", "sshcommon.c", 0x5Bu, "pq_unlink_common");
}

void __noreturn sub_1AE96()
{
  __assert_fail("false && \"bad status value in lf_load_keyfile_helper\"", "sshpubk.c", 0x75u, "lf_load_keyfile_helper");
}

void __noreturn sub_1AEB9()
{
  __assert_fail("false && \"bad hash algorithm for RSA PKCS#1\"", "sshrsa.c", 0x2C4u, "rsa_pkcs1_prefix_for_hash");
}

void __noreturn sub_1AEDC()
{
  __assert_fail(
    "blk->used == 0 && \"Should have exactly hit a block boundary\"",
    "sshsh256.c",
    0xB5u,
    "sha256_block_pad");
}

void __noreturn sub_1AEFF()
{
  __assert_fail("blk->used == 0 && \"Should have exactly hit a block boundary\"", "sshsha.c", 0xA6u, "sha1_block_pad");
}

void __noreturn sub_1AF22()
{
  __assert_fail("width <= scc->line_chars_remaining", "stripctrl.c", 0x9Cu, "stripctrl_check_line_limit");
}

void __noreturn sub_1AF45()
{
  __assert_fail("width >= 0", "stripctrl.c", 0xAAu, "stripctrl_locale_put_wc");
}

void __noreturn sub_1AF68()
{
  __assert_fail("width >= 0", "stripctrl.c", 0xC7u, "stripctrl_term_put_wc");
}

void __fastcall __noreturn sub_1AF8B(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r13
  __int64 v7; // r12
  __int64 v8; // rbp
  __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 v12; // [rsp+0h] [rbp-58h]
  unsigned int v13; // [rsp+Ch] [rbp-4Ch]
  __int64 v14; // [rsp+10h] [rbp-48h]
  unsigned int v15; // [rsp+18h] [rbp-40h]

  v6 = *(unsigned int *)(a1 + 512);
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v7 = (unsigned int)sub_9AFB0(*(__int64 **)(a1 + 24));
  v8 = *(_QWORD *)(a1 + 24);
  v9 = (unsigned int)sub_9AFB0(*(__int64 **)(a1 + 16));
  v10 = *(_QWORD *)(a1 + 16);
  v11 = sub_9AFB0(*(__int64 **)(a1 + 8));
  sub_B06C0(
    (__int64)"%s==NULL in terminal.c\n"
             "lineno=%d y=%d w=%d h=%d\n"
             "count(scrollback=%p)=%d\n"
             "count(screen=%p)=%d\n"
             "count(alt=%p)=%d alt_sblines=%d\n"
             "whichtree=%p treeindex=%d\n"
             "commitid=%s\n"
             "\n"
             "Please contact <putty@projects.tartarus.org> and pass on the above information.",
    v12,
    v15,
    a2,
    *(unsigned int *)(a1 + 416),
    *(unsigned int *)(a1 + 412),
    *(_QWORD *)(a1 + 8),
    v11,
    v10,
    v9,
    v8,
    v7,
    v6,
    v14,
    v13,
    "1fd7baa7344bb38d62a024e5dba3a720c67d05cf");
}

void __noreturn sub_1B02F()
{
  __assert_fail("fd >= 0", "unix/uxpoll.c", 0x87u, "pollwrap_get_fd_events_revents");
}

void __noreturn sub_1B052()
{
  __assert_fail("fingerprints[fptype]", "utils.c", 0x45Bu, "ssh2_pick_fingerprint");
}

__int64 __usercall main@<rax>(signed int a1@<edi>, char **a2@<rsi>, char **a3@<rdx>, signed __int64 a4@<r12>)
{
  __int64 v4; // rax
  signed int v5; // ebx
  signed __int64 v6; // rdx
  signed int v7; // ebp
  __int64 *v8; // rbx
  bool v9; // cf
  bool v10; // zf
  char *v11; // rdi
  signed __int64 v12; // rcx
  char *v13; // rsi
  __int64 (__fastcall *v14)(_QWORD *, int); // rsi
  __int64 *v15; // rdi
  _QWORD *v17; // rax
  __int64 v18; // rdx
  char **v19; // [rsp+0h] [rbp-28h]
  unsigned int v20; // [rsp+Ch] [rbp-1Ch]

  v19 = a2;
  v20 = a1;
  setlocale(0, &locale);
  sub_B8650();
  qword_3264D8 = *a2;
  v4 = sub_2F450(a1 - 1, 8uLL, 0LL);
  v5 = a1;
  qword_3264D0 = v4;
  if ( a1 > 1 )
  {
    v6 = 0LL;
    v7 = 1;
    while ( 1 )
    {
      a4 = v6 + 8;
      ++v7;
      *(_QWORD *)(v4 + v6) = sub_BC120(*(char **)((char *)v19 + v6 + 8));
      v5 = v20;
      if ( (signed int)v20 <= v7 )
        break;
      v4 = qword_3264D0;
      v6 = a4;
    }
  }
  gtk_init(&v20, &v19);
  dword_3264C8 = v5 - v20;
  v8 = sub_1ED20();
  sub_9DAC0();
  sub_B9D90(13, 1);
  v9 = v20 < 1;
  v10 = v20 == 1;
  if ( (signed int)v20 <= 1 )
    goto LABEL_22;
  v11 = "---";
  v12 = 3LL;
  v13 = v19[1];
  do
  {
    if ( !v12 )
      break;
    v9 = (unsigned __int8)*v13 < (unsigned __int8)*v11;
    v10 = *v13++ == *v11++;
    --v12;
  }
  while ( v10 );
  if ( (!v9 && !v10) == v9 )
  {
    sub_AA540(v8, v19[1]);
    sub_BD070(v19[1], strlen(v19[1]));
    if ( !sub_31CC0(v8) )
      __assert_fail("!dup_check_launchable || conf_launchable(conf)", "unix/gtkmain.c", 0x276u, "main");
  }
  else
  {
LABEL_22:
    if ( (unsigned __int8)sub_AA900(v20, (signed __int64)v19, 0, v8)
      || (sub_40A60(v8, a4), (unsigned __int8)sub_AA900(v20, (signed __int64)v19, 1u, v8)) )
    {
      exit(1);
    }
    sub_1EA30((__int64)v8);
    if ( dword_F9C60 & 4 && !(unsigned __int8)sub_1EAB0((__int64)v8) )
    {
      v17 = (_QWORD *)sub_2F450(1uLL, 0x10uLL, 0LL);
      v18 = qword_3264C0;
      v14 = sub_AA070;
      *v17 = v8;
      v15 = v8;
      v17[1] = v18;
      sub_B85B0(v8, (__int64)sub_AA070, (__int64)v17);
      goto LABEL_14;
    }
  }
  v14 = (__int64 (__fastcall *)(_QWORD *, int))qword_3264C0;
  v15 = v8;
  sub_B2560(v8, (const char *)qword_3264C0);
LABEL_14:
  gtk_main(v15, v14);
  return 0LL;
}

__int64 (**sub_1B2D0())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))&unk_3260D8;
  if ( &unk_3260D8 != &unk_3260D8 )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}

__int64 sub_1B310()
{
  return 0LL;
}

__int64 (**sub_1B360())(void)
{
  __int64 (**result)(void); // rax

  if ( !byte_326108 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_326008);
    result = sub_1B2D0();
    byte_326108 = 1;
  }
  return result;
}

__int64 sub_1B3A0()
{
  return sub_1B310();
}

char *sub_1B3B0()
{
  return sub_BC120("Agent-forwarding connection closed");
}

unsigned __int64 __fastcall sub_1B3C0(_QWORD *a1)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rbp
  unsigned __int64 v4; // r12
  unsigned int v5; // ecx
  unsigned __int64 v6; // r14
  __int64 v7; // rax
  void **v8; // r12
  char *v9; // rax
  void (__fastcall ***v10)(_QWORD, _QWORD, void *, signed __int64); // rdi
  int v11; // [rsp+14h] [rbp-54h]
  void *v12; // [rsp+18h] [rbp-50h]
  unsigned int v13; // [rsp+24h] [rbp-44h]
  unsigned __int64 v14; // [rsp+28h] [rbp-40h]

  v14 = __readfsqword(0x28u);
  if ( !a1[6] )
  {
    v2 = a1;
    if ( *((_BYTE *)a1 + 56) )
    {
      v3 = a1 + 1;
      while ( 1 )
      {
        v4 = sub_BCD00((__int64)v3);
        if ( v4 <= 3 )
          break;
        sub_BCF10((__int64)v3, (char *)&v13, 4uLL);
        v5 = _byteswap_ulong(v13);
        v6 = v5;
        if ( v5 > (unsigned int)&loc_3FFFC )
        {
          v10 = (void (__fastcall ***)(_QWORD, _QWORD, void *, signed __int64))*a1;
          v2[6] = 0LL;
          (**v10)(v10, 0LL, &unk_BFE30, 5LL);
          (*(void (**)(void))(*(_QWORD *)*v2 + 8LL))();
          return __readfsqword(0x28u) ^ v14;
        }
        if ( v4 - 4 < v5 )
          break;
        sub_BCE20((__int64)v3, 4uLL);
        v7 = sub_BC7E0();
        v8 = (void **)v7;
        v9 = sub_BC510(v7, v6);
        sub_BCFC0((__int64)v3, v9, v6);
        a1[6] = sub_B3E40(v8, &v12, &v11, (__int64)sub_1B580, (__int64)a1);
        sub_BC660(v8);
        if ( a1[6] )
          return __readfsqword(0x28u) ^ v14;
        (**(void (__fastcall ***)(_QWORD, _QWORD))*a1)(*a1, 0LL);
        sub_2F4D0(v12);
      }
      if ( *((_BYTE *)a1 + 57) )
        (*(void (**)(void))(*(_QWORD *)*a1 + 8LL))();
    }
  }
  return __readfsqword(0x28u) ^ v14;
}

unsigned __int64 __fastcall sub_1B580(_QWORD *a1, void *a2, int a3)
{
  _QWORD *v3; // rbx
  void (__fastcall ***v4)(_QWORD, _QWORD, void *, signed __int64); // rdi
  signed __int64 v5; // rcx
  void *v6; // rdx

  v3 = a1;
  v4 = (void (__fastcall ***)(_QWORD, _QWORD, void *, signed __int64))*a1;
  v3[6] = 0LL;
  if ( a2 )
  {
    v5 = a3;
    v6 = a2;
  }
  else
  {
    v5 = 5LL;
    v6 = &unk_BFE30;
  }
  (**v4)(v4, 0LL, v6, v5);
  sub_2F4D0(a2);
  return sub_1B3C0(v3);
}

__int64 (__fastcall **__fastcall sub_1B5D0(__int64 (__fastcall ***a1)(), char a2))()
{
  __int64 (__fastcall **result)(); // rax

  result = &off_323340;
  if ( *a1 != &off_323340 )
    __assert_fail("chan->vt == &agentf_channelvt", "agentf.c", 0xEEu, "agentf_set_input_wanted");
  *((_BYTE *)a1 - 8) = a2;
  if ( a2 )
    result = (__int64 (__fastcall **)())sub_1B3C0(a1 - 8);
  return result;
}

unsigned __int64 __fastcall sub_1B620(__int64 (__fastcall ***a1)())
{
  if ( *a1 != &off_323340 )
    __assert_fail("chan->vt == &agentf_channelvt", "agentf.c", 0xDCu, "agentf_send_eof");
  *((_BYTE *)a1 - 7) = 1;
  return sub_1B3C0(a1 - 8);
}

__int64 __fastcall sub_1B660(__int64 (__fastcall ***a1)(), __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  if ( *a1 != &off_323340 )
    __assert_fail("chan->vt == &agentf_channelvt", "agentf.c", 0xCAu, "agentf_send");
  sub_BCD20((__int64)(a1 - 7), (char *)a3, a4);
  sub_1B3C0(a1 - 8);
  if ( *(a1 - 2) )
    result = sub_BCD00((__int64)(a1 - 7));
  else
    result = 0LL;
  return result;
}

void __fastcall sub_1B6D0(__int64 (__fastcall ***a1)())
{
  __int64 (__fastcall ***v1)(); // rbx
  int *v2; // rdi

  if ( *a1 != &off_323340 )
    __assert_fail("chan->vt == &agentf_channelvt", "agentf.c", 0xBEu, "agentf_free");
  v1 = a1 - 8;
  v2 = (int *)*(a1 - 2);
  if ( v2 )
    sub_B3D10(v2);
  sub_BCCA0((__int64)(v1 + 1));
  sub_2F4D0(v1);
}

signed __int64 __fastcall sub_1B720(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx

  v1 = sub_2F450(1uLL, 0x50uLL, 0LL);
  v2 = v1;
  *(_QWORD *)v1 = a1;
  *(_DWORD *)(v1 + 72) = 0;
  *(_BYTE *)(v1 + 57) = 0;
  *(_QWORD *)(v1 + 64) = &off_323340;
  sub_BCC70((_QWORD *)(v1 + 8));
  *(_QWORD *)(v2 + 48) = 0LL;
  *(_BYTE *)(v2 + 56) = 1;
  return v2 + 64;
}

__int64 __fastcall sub_1B780(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  result = sub_B3E40((_QWORD *)a1, (_QWORD *)a2, (_DWORD *)a3, 0LL, 0LL);
  if ( result )
    __assert_fail("!pending", "aqsync.c", 0x13u, "agent_query_synchronous");
  return result;
}

unsigned __int64 __usercall sub_1B7C0@<rax>(void (__fastcall ***a1)(_QWORD, signed __int64, const char *, __int64)@<rdi>, __int64 a2@<rsi>, __int64 a3@<rdx>, __int64 a4@<rcx>, __int64 a5@<r8>, __int64 a6@<r9>, void (__fastcall ***r13_0)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 r15_0@<r15>, __int64 a7, __int64 a8, unsigned __int8 a9)
{
  char *v11; // rbx
  int v12; // eax
  __int64 v14; // ST00_8
  __int64 v15; // [rsp+0h] [rbp-158h]
  unsigned int v16; // [rsp+Ch] [rbp-14Ch]
  char v17; // [rsp+10h] [rbp-148h]
  unsigned __int64 v18; // [rsp+118h] [rbp-40h]

  v18 = __readfsqword(0x28u);
  if ( (_DWORD)a3 == 1 )
  {
    v14 = a6;
    sub_B60F0(a4, &v17, 256);
    v11 = sub_BC360((__int64)"Failed to connect to %s: %s", &v17, v14, v14);
    goto LABEL_13;
  }
  if ( (unsigned int)a3 < 1 )
  {
    v16 = a5;
    v15 = a4;
    sub_B60F0(a4, &v17, 256);
    if ( sub_B6170(v15) )
      v11 = sub_BC360((__int64)"Connecting to %s port %d", &v17, v16, v15);
    else
      v11 = sub_BC360((__int64)"Connecting to %s", &v17, v15);
LABEL_13:
    if ( !v11 )
      return __readfsqword(0x28u) ^ v18;
    goto LABEL_11;
  }
  if ( (_DWORD)a3 == 2 )
  {
    sub_B60F0(a4, &v17, 256);
    v11 = sub_BC360((__int64)"Connected to %s", &v17);
    goto LABEL_13;
  }
  if ( (_DWORD)a3 == 3 )
  {
    r13_0 = a1;
    v11 = sub_BC360((__int64)"%s\r\n", a6, a3, a4, a5);
    LODWORD(r15_0) = strlen(v11);
    if ( (signed int)r15_0 <= 1 )
      __assert_fail("len >= 2", "be_misc.c", 0x2Bu, "backend_socket_log");
    v12 = sub_1EFD0((__int64 *)a8, 19);
    r15_0 = (signed int)r15_0;
    if ( v12 == 2 )
      v12 = a9;
    if ( !v12 )
      (**a1)(a1, 1LL, v11, r15_0);
    v11[r15_0 - 2] = 0;
LABEL_11:
    sub_2D2C0(a2, v11, (__int64)r13_0, r15_0);
    sub_2F4D0(v11);
  }
  return __readfsqword(0x28u) ^ v18;
}

void __fastcall sub_1B9C0(__int64 a1)
{
  *(_QWORD *)(a1 + 0x2000) = 0LL;
}

void __fastcall sub_1B9D0(void (__fastcall ***a1)(_QWORD, signed __int64, _QWORD, _QWORD, __int64, _QWORD), _QWORD *a2, char *a3, unsigned __int64 a4)
{
  size_t v4; // r15
  _QWORD *v5; // r14
  void (__fastcall ***v6)(_QWORD, signed __int64, _QWORD, _QWORD, __int64, _QWORD); // rbx
  signed __int64 v7; // rax
  _QWORD *v8; // r15
  unsigned __int64 v9; // r12
  _BYTE *v10; // rax
  signed __int64 v11; // r15
  char v12; // al
  signed __int64 v13; // rsi
  char v14; // al
  char *v15; // r12
  char *v16; // rdi
  char *v17; // r15
  unsigned __int64 v18; // [rsp+0h] [rbp-48h]
  char *v19; // [rsp+8h] [rbp-40h]

  v19 = a3;
  v18 = a4;
  if ( a4 )
  {
    v4 = a2[1024];
    v5 = a2;
    if ( v4 > 0x1FFF )
LABEL_34:
      __assert_fail("psb->size < lenof(psb->buf)", "be_misc.c", 0x5Du, "log_proxy_stderr");
    v6 = a1;
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = 0x2000 - v4;
        if ( 0x2000 - v4 > v18 )
          v7 = v18;
        v8 = (_QWORD *)((char *)v5 + v4);
        if ( (unsigned int)v7 >= 8 )
        {
          *v8 = *(_QWORD *)v19;
          *(_QWORD *)((char *)v8 + (unsigned int)v7 - 8) = *(_QWORD *)&v19[(unsigned int)v7 - 8];
          qmemcpy(
            (void *)((unsigned __int64)(v8 + 1) & 0xFFFFFFFFFFFFFFF8LL),
            (const void *)(v19 - ((char *)v8 - ((unsigned __int64)(v8 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
            8LL * (((unsigned int)v7 + (_DWORD)v8 - (((_DWORD)v8 + 8) & 0xFFFFFFF8)) >> 3));
        }
        else if ( v7 & 4 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v19;
          *(_DWORD *)((char *)v8 + (unsigned int)v7 - 4) = *(_DWORD *)&v19[(unsigned int)v7 - 4];
        }
        else if ( (_DWORD)v7 )
        {
          *(_BYTE *)v8 = *v19;
          if ( v7 & 2 )
            *(_WORD *)((char *)v8 + (unsigned int)v7 - 2) = *(_WORD *)&v19[(unsigned int)v7 - 2];
        }
        v19 += v7;
        v18 -= v7;
        v9 = 0LL;
        v4 = v5[1024] + v7;
        v5[1024] = v4;
        while ( v9 < v4 )
        {
          v10 = memchr((char *)v5 + v9, 10, v4 - v9);
          if ( !v10 )
            break;
          v11 = v10 - (_BYTE *)v5;
          if ( v9 < v10 - (_BYTE *)v5 && ((v12 = *(v10 - 1), v13 = v11 - 1, v12 == 10) || v12 == 13) )
          {
            while ( v9 != v13 )
            {
              v14 = *((_BYTE *)v5 + v13 - 1);
              if ( v14 != 10 && v14 != 13 )
                break;
              --v13;
            }
          }
          else
          {
            LODWORD(v13) = v11;
          }
          v15 = sub_BC360((__int64)"proxy: %.*s", (unsigned int)(v13 - v9), (char *)v5 + v9, v18);
          (**v6)(v6, 3LL, 0LL, 0LL, (__int64)v15, 0LL);
          v16 = v15;
          v9 = v11 + 1;
          sub_2F4D0(v16);
          v4 = v5[1024];
          if ( v4 < v9 )
            __assert_fail("pos <= psb->size", "be_misc.c", 0x7Cu, "log_proxy_stderr");
        }
        if ( !v9 )
          break;
        v4 -= v9;
        if ( !v4 )
          goto LABEL_28;
LABEL_32:
        memmove(v5, (char *)v5 + v9, v4);
        v5[1024] = v4;
        if ( !v18 )
          return;
        if ( v4 > 0x1FFF )
          goto LABEL_34;
      }
      if ( v4 == 0x2000 )
      {
        v17 = sub_BC360((__int64)"proxy (partial line): %.*s", 0x2000LL, v5, v18);
        (**v6)(v6, 3LL, 0LL, 0LL, (__int64)v17, 0LL);
        sub_2F4D0(v17);
        v5[1024] = 0LL;
        if ( !v18 )
          return;
        v4 = 0LL;
      }
      else
      {
        if ( v4 )
          goto LABEL_32;
LABEL_28:
        v5[1024] = 0LL;
        if ( !v18 )
          return;
      }
    }
  }
}

__int64 __fastcall sub_1BCB0(__int64 a1)
{
  *(_BYTE *)(a1 + 16) = 0;
  return (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));
}

void __fastcall sub_1BCC0(__int64 a1, __int64 a2)
{
  qword_326118 = a1;
  qword_326110 = a2;
}

void __fastcall sub_1BCD0(__int64 a1)
{
  __int64 v1; // rbp
  _QWORD *v2; // rbx
  __int64 v3; // r12
  __int64 (__fastcall **i)(__int64); // rdi
  __int64 (__fastcall *v5)(__int64); // rdx
  __int64 v6; // rax

  v1 = a1;
  v2 = 0LL;
  v3 = 0LL;
LABEL_2:
  for ( i = (__int64 (__fastcall **)(__int64))qword_326128; i; i = (__int64 (__fastcall **)(__int64))v6 )
  {
    while ( 1 )
    {
      v5 = i[2];
      v6 = (__int64)*i;
      qword_326128 = (__int64)*i;
      if ( v5 == (__int64 (__fastcall *)(__int64))v1 || i[1] == sub_1BCB0 && *((_QWORD *)v5 + 1) == v1 )
      {
        sub_2F4D0(i);
        i = (__int64 (__fastcall **)(__int64))qword_326128;
        goto LABEL_2;
      }
      if ( !v3 )
        break;
      *v2 = i;
      v2 = i;
      i = (__int64 (__fastcall **)(__int64))v6;
      if ( !v6 )
        goto LABEL_7;
    }
    v2 = i;
    v3 = (__int64)i;
  }
LABEL_7:
  qword_326128 = v3;
  qword_326120 = (__int64)v2;
  if ( v2 )
    *v2 = 0LL;
}

_QWORD *__fastcall sub_1BD80(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  void (__fastcall *v3)(__int64, signed __int64); // rdx
  _QWORD *v4; // rdx
  _QWORD *v5; // ST08_8

  result = (_QWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  v3 = (void (__fastcall *)(__int64, signed __int64))qword_326118;
  result[1] = a1;
  result[2] = a2;
  if ( !v3 || qword_326128 || qword_326130 )
  {
    v4 = (_QWORD *)qword_326120;
    if ( !qword_326120 )
    {
LABEL_8:
      qword_326128 = (__int64)result;
      goto LABEL_5;
    }
  }
  else
  {
    v5 = result;
    v3(qword_326110, 24LL);
    v4 = (_QWORD *)qword_326120;
    result = v5;
    if ( !qword_326120 )
      goto LABEL_8;
  }
  *v4 = result;
LABEL_5:
  *result = 0LL;
  qword_326120 = (__int64)result;
  return result;
}

_QWORD *__fastcall sub_1BE20(__int64 a1)
{
  _QWORD *result; // rax

  if ( !*(_BYTE *)(a1 + 16) )
  {
    *(_BYTE *)(a1 + 16) = 1;
    result = sub_1BD80((__int64)sub_1BCB0, a1);
  }
  return result;
}

signed __int64 sub_1BE50()
{
  __int64 v0; // rdx
  __int64 v1; // rax

  v0 = qword_326128;
  if ( !qword_326128 )
    return 0LL;
  v1 = *(_QWORD *)qword_326128;
  qword_326130 = qword_326128;
  qword_326128 = v1;
  if ( !v1 )
    qword_326120 = 0LL;
  (*(void (__fastcall **)(_QWORD))(v0 + 8))(*(_QWORD *)(v0 + 16));
  sub_2F4D0((void *)qword_326130);
  qword_326130 = 0LL;
  return 1LL;
}

bool sub_1BEC0()
{
  bool result; // al

  result = 1;
  if ( !qword_326130 )
    result = qword_326128 != 0;
  return result;
}

_BYTE *__fastcall sub_1BEF0(__int64 a1, __int64 a2)
{
  _BYTE *result; // rax
  signed int v3; // edx
  signed __int64 v4; // rsi
  _BYTE *v5; // rdx

  result = (_BYTE *)*(unsigned int *)(a1 + 8);
  if ( a2 != 0xFFFF )
  {
    if ( (signed int)result > 0 )
    {
      result = (_BYTE *)(*(_QWORD *)a1)++;
      *result = a2;
      --*(_DWORD *)(a1 + 8);
      return result;
    }
LABEL_6:
    *(_DWORD *)(a1 + 28) = 1;
    return result;
  }
  v3 = *(_DWORD *)(a1 + 24);
  if ( (signed int)result < v3 )
    goto LABEL_6;
  if ( v3 > 0 )
  {
    result = *(_BYTE **)(a1 + 16);
    v4 = (signed __int64)&result[v3 - 1 + 1];
    do
    {
      v5 = *(_BYTE **)a1;
      ++result;
      ++*(_QWORD *)a1;
      *v5 = *(result - 1);
      --*(_DWORD *)(a1 + 8);
    }
    while ( result != (_BYTE *)v4 );
  }
  return result;
}

__int64 __fastcall sub_1BF60(_QWORD *a1, int *a2, __int64 a3, int a4, unsigned int a5, __int64 *a6, __int64 a7, int a8)
{
  __int64 v8; // rbp
  int v9; // er14
  __int64 *v10; // r12
  _DWORD *v11; // r13
  __int64 result; // rax
  signed int *v13; // rdx
  int v14; // eax
  int v15; // [rsp+8h] [rbp-80h]
  __int64 v16; // [rsp+18h] [rbp-70h]
  __int64 v17; // [rsp+20h] [rbp-68h]
  int v18; // [rsp+28h] [rbp-60h]
  __int64 v19; // [rsp+30h] [rbp-58h]
  int v20; // [rsp+38h] [rbp-50h]
  int v21; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v22; // [rsp+48h] [rbp-40h]

  v8 = a3;
  v9 = a4;
  v10 = a6;
  v22 = __readfsqword(0x28u);
  v11 = sub_1C4A0(a5);
  v17 = v8;
  v18 = v9;
  v21 = 0;
  v19 = a7;
  v20 = a8;
  if ( v10 )
    v16 = *v10;
  else
    v16 = 0LL;
  result = 0LL;
  v15 = v8;
  if ( *a2 > 0 )
  {
    (*((void (__fastcall **)(_DWORD *, _QWORD, __int64 *, _BYTE *(__fastcall *)(__int64, __int64), __int64 *))v11 + 2))(
      v11,
      *(signed int *)*a1,
      &v16,
      sub_1BEF0,
      &v17);
    while ( !v21 )
    {
      LODWORD(v8) = v17;
      v13 = (signed int *)(*a1 + 4LL);
      v14 = *a2;
      *a1 = v13;
      *a2 = v14 - 1;
      if ( v14 - 1 <= 0 )
        break;
      (*((void (__fastcall **)(_DWORD *, _QWORD, __int64 *, _BYTE *(__fastcall *)(__int64, __int64), __int64 *))v11 + 2))(
        v11,
        *v13,
        &v16,
        sub_1BEF0,
        &v17);
    }
    result = (unsigned int)(v8 - v15);
  }
  return result;
}

__int64 __fastcall sub_1C0C0(unsigned __int8 *a1)
{
  const char *v2; // r13
  __int64 v3; // rbx
  unsigned __int8 *v4; // r12
  unsigned __int8 v5; // r15
  unsigned __int8 v6; // r14
  const __int32_t **v7; // rax
  unsigned int v8; // [rsp+Ch] [rbp-3Ch]

  v8 = sub_1C350(a1);
  if ( !v8 )
  {
    v8 = sub_1CA70(a1);
    if ( !v8 )
    {
      v2 = "<UNKNOWN>";
      v3 = 0LL;
LABEL_5:
      v4 = a1;
      while ( 1 )
      {
        v5 = *v4;
        v6 = *v2;
        if ( !*v4 && !v6 )
          break;
        v7 = __ctype_tolower_loc();
        if ( (*v7)[v6] != (*v7)[v5] )
        {
          if ( !v5 && !v6 )
            break;
          if ( ++v3 == 56 )
            return v8;
          v2 = (&off_31CEA0)[2 * v3];
          goto LABEL_5;
        }
        ++v4;
        ++v2;
      }
      v8 = (unsigned int)(&off_31CEA0)[2 * (signed int)v3 + 1];
    }
  }
  return v8;
}

__int64 __fastcall sub_1C1B0(int a1)
{
  int *v1; // rdx
  int v2; // eax
  int v3; // ecx

  v1 = (int *)((char *)&off_31CEB8 + 4);
  v2 = 0;
  while ( ++v2 != 56 )
  {
    while ( 1 )
    {
      v3 = *v1;
      v1 += 4;
      if ( !v3 )
        break;
      if ( !a1 )
        return LODWORD((&off_31CEA0)[2 * v2 + 1]);
      ++v2;
      --a1;
      if ( v2 == 56 )
        return 0LL;
    }
  }
  return 0LL;
}

__int64 __fastcall sub_1C350(unsigned __int8 *a1)
{
  const char *v1; // r15
  __int64 v2; // rbx
  unsigned __int8 *v3; // r13
  unsigned __int8 v4; // r14
  unsigned __int8 v5; // r12
  const __int32_t **v6; // rax

  v1 = "ISO-8859-1";
  v2 = 0LL;
  while ( 2 )
  {
    v3 = a1;
    while ( 1 )
    {
      v4 = *v3;
      v5 = *v1;
      if ( !*v3 && !v5 )
        return LODWORD((&off_31D580)[2 * (signed int)v2 + 1]);
      v6 = __ctype_tolower_loc();
      if ( (*v6)[v4] != (*v6)[v5] )
        break;
      ++v3;
      ++v1;
    }
    if ( !v4 && !v5 )
      return LODWORD((&off_31D580)[2 * (signed int)v2 + 1]);
    if ( ++v2 != 130 )
    {
      v1 = (&off_31D580)[2 * v2];
      continue;
    }
    break;
  }
  return 0LL;
}

__int64 __fastcall sub_1C420(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64, _QWORD), __int64 a5)
{
  return ((__int64 (__fastcall *)(__int64, _QWORD, __int64))a4)(a5, *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2), a3);
}

__int64 __fastcall sub_1C430(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64, signed __int64), __int64 a5)
{
  __int64 v5; // r10
  int v6; // ebx
  int v7; // edx
  int v8; // eax
  __int64 v9; // r11

  v5 = *(_QWORD *)(a1 + 24);
  v6 = -1;
  v7 = *(_DWORD *)(v5 + 2304);
  do
  {
    while ( 1 )
    {
      if ( v7 <= v6 + 1 )
        return a4(a5, 0xFFFFLL);
      v8 = (v6 + v7) / 2;
      v9 = *(unsigned __int8 *)(v5 + v8 + 2048);
      if ( *(_QWORD *)(v5 + 8 * v9) <= a2 )
        break;
      v7 = (v6 + v7) / 2;
    }
    v6 = (v6 + v7) / 2;
  }
  while ( *(_QWORD *)(v5 + 8 * v9) < a2 );
  return a4(a5, *(unsigned __int8 *)(v5 + v8 + 2048));
}

_DWORD *__fastcall sub_1C4A0(int a1)
{
  void **v1; // rdx
  _DWORD *result; // rax

  v1 = &off_323B08;
  result = &unk_323AE0;
  while ( *result != a1 )
  {
    if ( v1 == &off_323B08 + 54 )
      return 0LL;
    result = *v1;
    ++v1;
  }
  return result;
}

signed __int64 __fastcall sub_1C4E0(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rcx
  signed int v4; // edx
  signed __int64 v5; // rsi
  __int64 v6; // rax

  result = *(unsigned int *)(a1 + 8);
  if ( a2 != 0xFFFF )
  {
    if ( (signed int)result > 0 )
    {
LABEL_3:
      result = *(_QWORD *)a1;
      *(_QWORD *)a1 += 4LL;
      *(_DWORD *)result = a2;
      --*(_DWORD *)(a1 + 8);
      return result;
    }
    goto LABEL_7;
  }
  v3 = *(_QWORD *)(a1 + 16);
  if ( !v3 )
  {
    if ( (signed int)result > 0 )
    {
      LODWORD(a2) = 65533;
      goto LABEL_3;
    }
LABEL_7:
    *(_DWORD *)(a1 + 28) = 1;
    return result;
  }
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 > (signed int)result )
    goto LABEL_7;
  if ( v4 > 0 )
  {
    v5 = *(_QWORD *)a1;
    v6 = 0LL;
    do
    {
      *(_DWORD *)(v5 + v6) = *(_DWORD *)(v3 + v6);
      v6 += 4LL;
      --*(_DWORD *)(a1 + 8);
    }
    while ( v6 != 4LL * (unsigned int)(v4 - 1) + 4 );
    result = v5 + 4LL * (v4 - 1) + 4;
    *(_QWORD *)a1 = result;
  }
  return result;
}

__int64 __fastcall sub_1C570(_QWORD *a1, int *a2, __int64 a3, int a4, int a5, __int64 *a6, __int64 a7, int a8)
{
  __int64 v8; // rbx
  int v9; // er13
  __int64 *v10; // rbp
  _DWORD *v11; // r14
  unsigned __int8 *v12; // rdx
  int v13; // eax
  __int64 v15; // [rsp+8h] [rbp-80h]
  __int64 v16; // [rsp+18h] [rbp-70h]
  __int64 v17; // [rsp+20h] [rbp-68h]
  int v18; // [rsp+28h] [rbp-60h]
  __int64 v19; // [rsp+30h] [rbp-58h]
  int v20; // [rsp+38h] [rbp-50h]
  int v21; // [rsp+3Ch] [rbp-4Ch]
  unsigned __int64 v22; // [rsp+48h] [rbp-40h]

  v8 = a3;
  v9 = a4;
  v10 = a6;
  v22 = __readfsqword(0x28u);
  v11 = sub_1C4A0(a5);
  v17 = v8;
  v18 = v9;
  v21 = 0;
  v19 = a7;
  v20 = a8;
  if ( v10 )
    v16 = *v10;
  else
    v16 = 0LL;
  v15 = v8;
  if ( *a2 <= 0 )
    return 0LL;
  (*((void (__fastcall **)(_DWORD *, _QWORD, __int64 *, signed __int64 (__fastcall *)(__int64, __int64), __int64 *))v11
   + 1))(
    v11,
    *(unsigned __int8 *)*a1,
    &v16,
    sub_1C4E0,
    &v17);
  while ( !v21 )
  {
    if ( v10 )
      *v10 = v16;
    v8 = v17;
    v12 = (unsigned __int8 *)(*a1 + 1LL);
    v13 = *a2;
    *a1 = v12;
    *a2 = v13 - 1;
    if ( v13 - 1 <= 0 )
      break;
    (*((void (__fastcall **)(_DWORD *, _QWORD, __int64 *, signed __int64 (__fastcall *)(__int64, __int64), __int64 *))v11
     + 1))(
      v11,
      *v12,
      &v16,
      sub_1C4E0,
      &v17);
  }
  return (v8 - v15) >> 2;
}

signed __int64 __fastcall sub_1C6B0(__int64 a1, unsigned __int64 a2, signed __int64 *a3, __int64 (__fastcall *a4)(__int64, unsigned __int64), __int64 a5)
{
  __int64 (__fastcall *v5)(__int64, unsigned __int64); // r13
  signed __int64 *v6; // rbp
  __int64 v7; // r12
  signed __int64 v8; // rax
  signed __int64 result; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax

  v5 = a4;
  v6 = a3;
  v7 = a5;
  v8 = *a3;
  if ( (signed __int64)a2 <= 127 )
  {
    if ( v8 )
    {
      a4(a5, 0xFFFFuLL);
      *v6 = 0LL;
    }
    return v5(v7, a2);
  }
  if ( a2 - 254 <= 1 )
  {
    if ( v8 )
    {
      a4(a5, 0xFFFFuLL);
      *v6 = 0LL;
    }
    goto LABEL_17;
  }
  if ( a2 - 128 <= 0x3F )
  {
    if ( v8 )
    {
      v10 = (*a3 & 0xFC000000LL) + 0x4000000;
      a2 = a2 & 0x3F | ((unsigned int)*a3 << 6);
      if ( ((unsigned int)v10 ^ 8 * (_DWORD)v10) & 0xE0000000 )
      {
        result = a2 | v10;
        *a3 = result;
        return result;
      }
      *a3 = 0LL;
      if ( a2 - 55296 > 0x7FF && a2 - 65534 > 1 && a2 > 0x7F )
      {
        v11 = v10 >> 29;
        if ( (a2 > 0x7FF || (signed int)v11 <= 2)
          && (a2 > 0xFFFF || (signed int)v11 <= 3)
          && (a2 > 0x1FFFFF || (signed int)v11 <= 4)
          && (a2 > 0x3FFFFFF || (signed int)v11 <= 5) )
        {
          return v5(v7, a2);
        }
      }
    }
LABEL_17:
    a2 = 0xFFFFLL;
    return v5(v7, a2);
  }
  if ( v8 )
    a4(a5, 0xFFFFuLL);
  result = a2 - 192;
  if ( a2 - 192 <= 0x1F )
  {
    *v6 = a2 & 0x1F | 0x44000000;
  }
  else
  {
    result = a2 - 224;
    if ( a2 - 224 <= 0xF )
    {
      *v6 = a2 & 0xF | 0x64000000;
    }
    else if ( a2 - 240 <= 7 )
    {
      result = 2214592512LL;
      *v6 = a2 & 7 | 0x84000000;
    }
    else if ( a2 - 248 <= 3 )
    {
      result = 2751463424LL;
      *v6 = a2 & 3 | 0xA4000000;
    }
    else
    {
      result = a2 - 252;
      if ( a2 - 252 <= 1 )
      {
        result = 3288334336LL;
        *v6 = a2 & 1 | 0xC4000000;
      }
    }
  }
  return result;
}

__int64 __fastcall sub_1C900(__int64 a1, signed __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64, signed __int64), __int64 a5)
{
  __int64 (__fastcall *v6)(__int64, signed __int64); // r15
  signed __int64 v7; // r12
  __int64 v8; // rbx
  signed __int64 v9; // rbp
  signed __int64 v10; // rsi
  signed __int64 v11; // rax
  signed __int64 v12; // rbp
  signed __int64 v13; // rsi
  signed __int64 v14; // rdx
  signed __int64 v15; // r13
  signed __int64 v16; // rsi
  signed __int64 v17; // rax
  signed __int64 v18; // r14

  if ( (unsigned __int64)(a2 - 65534) <= 1 || (unsigned __int64)(a2 - 55296) <= 0x7FF )
    return ((__int64 (__fastcall *)(__int64, signed __int64, __int64))a4)(a5, 0xFFFFLL, a3);
  if ( a2 <= 127 )
    return ((__int64 (__fastcall *)(__int64, signed __int64, __int64))a4)(a5, a2, a3);
  v6 = a4;
  v7 = a2 & 0x3F;
  LOBYTE(v7) = v7 | 0x80;
  v8 = a5;
  v9 = a2 >> 6;
  if ( a2 > 2047 )
  {
    v12 = (a2 >> 6) & 0x3F;
    v11 = a2 >> 12;
    LOBYTE(v12) = v12 | 0x80;
    if ( a2 > 0xFFFF )
    {
      v14 = a2 >> 18;
      v15 = v11 & 0x3F | 0x80;
      if ( a2 > 0x1FFFFF )
      {
        v17 = a2 >> 24;
        v18 = v14 & 0x3F | 0x80;
        if ( a2 <= 0x3FFFFFF )
        {
          LOBYTE(v17) = BYTE3(a2) | 0xF8;
        }
        else
        {
          a4(a5, (a2 >> 30) & 1 | 0xFC);
          v17 = BYTE3(a2) & 0x3F;
          LOBYTE(v17) = v17 | 0x80;
        }
        v6(v8, v17);
        v16 = v18;
      }
      else
      {
        LOBYTE(v14) = v14 | 0xF0;
        v16 = v14;
      }
      v6(v8, v16);
      v13 = v15;
    }
    else
    {
      LOBYTE(v11) = v11 | 0xE0;
      v13 = v11;
    }
    ((void (__fastcall *)(__int64, signed __int64, __int64))v6)(v8, v13, a3);
    v10 = v12;
  }
  else
  {
    v10 = a2 >> 6;
    LOBYTE(v10) = v9 | 0xC0;
  }
  ((void (__fastcall *)(__int64, signed __int64, __int64))v6)(v8, v10, a3);
  return v6(v8, v7);
}

__int64 __fastcall sub_1CA70(unsigned __int8 *a1)
{
  const char *v1; // r15
  __int64 v2; // rbx
  unsigned __int8 *v3; // r13
  unsigned __int8 v4; // r14
  unsigned __int8 v5; // r12
  const __int32_t **v6; // rax

  v1 = "iso8859-1";
  v2 = 0LL;
  while ( 2 )
  {
    v3 = a1;
    while ( 1 )
    {
      v4 = *v3;
      v5 = *v1;
      if ( !*v3 && !v5 )
        return LODWORD((&off_31DDC0)[2 * (signed int)v2 + 1]);
      v6 = __ctype_tolower_loc();
      if ( (*v6)[v4] != (*v6)[v5] )
        break;
      ++v3;
      ++v1;
    }
    if ( !v4 && !v5 )
      return LODWORD((&off_31DDC0)[2 * (signed int)v2 + 1]);
    if ( ++v2 != 34 )
    {
      v1 = (&off_31DDC0)[2 * v2];
      continue;
    }
    break;
  }
  return 0LL;
}

char *__fastcall sub_1CB40(char *src, char *a2, int a3)
{
  __int64 *v3; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rbp
  signed __int64 v6; // rbp
  char *result; // rax

  v3 = &qword_326160[3 * a3];
  v4 = sub_2F4F0((void *)*v3, (unsigned __int64 *)v3 + 2, 0x10uLL, v3[1], 1uLL, 0);
  v5 = v3[1];
  *v3 = (__int64)v4;
  v4[2 * v5] = sub_BC120(src);
  v6 = *v3 + 16 * v3[1];
  result = sub_BC120(a2);
  *(_QWORD *)(v6 + 8) = result;
  ++v3[1];
  return result;
}

void sub_1CBD0()
{
  char *v0; // rbx
  size_t v1; // rax

  v0 = s;
  if ( s )
  {
    v1 = strlen(s);
    sub_BD070(v0, v1);
    sub_2F4D0(s);
    s = 0LL;
  }
  sub_2F4D0((void *)qword_326160[0]);
  qword_326160[0] = 0LL;
  qword_326170 = 0LL;
  qword_326168 = 0LL;
  sub_2F4D0((void *)qword_326178);
  qword_326178 = 0LL;
  qword_326188 = 0LL;
  qword_326180 = 0LL;
}

signed __int64 __fastcall sub_1CC70(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rdi
  signed __int64 result; // rax
  char *v4; // rbx
  size_t v5; // rax

  if ( !s )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 40) != 1LL )
    return 0xFFFFFFFFLL;
  v1 = *(__int64 **)(a1 + 56);
  v2 = *v1;
  if ( *(_BYTE *)(*v1 + 8) )
    return 0xFFFFFFFFLL;
  result = 0LL;
  if ( !byte_326140 )
  {
    sub_31BF0(v2, s);
    v4 = s;
    v5 = strlen(s);
    sub_BD070(v4, v5);
    sub_2F4D0(s);
    result = 1LL;
    s = 0LL;
    byte_326140 = 1;
  }
  return result;
}

__int64 __usercall sub_1CD30@<rax>(int a1@<edx>, __int64 a2@<rcx>, char *a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r12>)
{
  char *v5; // r14
  __int64 v6; // rbp
  char *v7; // rbx
  bool v8; // cf
  bool v9; // zf
  bool v10; // cf
  bool v11; // zf
  const char *v12; // rdi
  signed __int64 v13; // rcx
  char *v14; // rsi
  char *v15; // rbx
  size_t v16; // rax
  unsigned int v17; // er13
  __int64 result; // rax
  const char *v19; // rdi
  signed __int64 v20; // rcx
  char *v21; // rsi
  void **v22; // r13
  __int64 (__fastcall ***v23)(int, int, __int64); // r15
  bool v24; // cf
  bool v25; // zf
  int v26; // ebx
  char *v27; // rax
  size_t v28; // rax
  char *v29; // rax
  char *v30; // r15
  size_t v31; // rax
  signed __int64 v32; // rdx
  char v33; // al
  char v34; // al
  const char *v35; // rdi
  signed __int64 v36; // rcx
  char *v37; // rsi
  bool v38; // cf
  bool v39; // zf
  const char *v40; // rdi
  signed __int64 v41; // rcx
  char *v42; // rsi
  char v43; // al
  bool v44; // cf
  bool v45; // zf
  bool v46; // cf
  bool v47; // zf
  const char *v48; // rdi
  signed __int64 v49; // rcx
  char *v50; // rsi
  char v51; // al
  bool v52; // cf
  bool v53; // zf
  const char *v54; // rdi
  signed __int64 v55; // rcx
  char *v56; // rsi
  char v57; // al
  bool v58; // cf
  bool v59; // zf
  int v60; // eax
  const char *v61; // rdi
  signed __int64 v62; // rcx
  char *v63; // rsi
  char v64; // al
  bool v65; // cf
  bool v66; // zf
  bool v67; // cf
  bool v68; // zf
  const char *v69; // rdi
  signed __int64 v70; // rcx
  char *v71; // rsi
  char v72; // al
  char *v73; // r15
  bool v74; // cf
  bool v75; // zf
  const char *v76; // rdi
  signed __int64 v77; // rcx
  char *v78; // rsi
  char v79; // al
  bool v80; // cf
  bool v81; // zf
  char *v82; // rdi
  signed __int64 v83; // rcx
  char *v84; // rsi
  char v85; // al
  bool v86; // cf
  bool v87; // zf
  const char *v88; // rdi
  signed __int64 v89; // rcx
  char *v90; // rsi
  char v91; // al
  bool v92; // cf
  bool v93; // zf
  const char *v94; // rdi
  signed __int64 v95; // rcx
  char *v96; // rsi
  char v97; // al
  bool v98; // cf
  bool v99; // zf
  _BYTE *v100; // rax
  char *v101; // r15
  int v102; // eax
  bool v103; // cf
  bool v104; // zf
  const char *v105; // rdi
  signed __int64 v106; // rcx
  char *v107; // rsi
  char v108; // al
  bool v109; // cf
  bool v110; // zf
  FILE *v111; // r13
  FILE *v112; // rdi
  bool v113; // cf
  bool v114; // zf
  const char *v115; // rdi
  signed __int64 v116; // rcx
  char *v117; // rsi
  char v118; // al
  bool v119; // cf
  bool v120; // zf
  int v121; // eax
  bool v122; // cf
  bool v123; // zf
  const char *v124; // rdi
  signed __int64 v125; // rcx
  char *v126; // rsi
  char v127; // al
  bool v128; // cf
  bool v129; // zf
  const char *v130; // rdi
  signed __int64 v131; // rcx
  char *v132; // rsi
  char v133; // al
  bool v134; // cf
  bool v135; // zf
  const char *v136; // rdi
  signed __int64 v137; // rcx
  char *v138; // rsi
  const char *v139; // rdi
  signed __int64 v140; // rcx
  char *v141; // rsi
  char v142; // al
  bool v143; // cf
  bool v144; // zf
  const char *v145; // rdi
  signed __int64 v146; // rcx
  char *v147; // rsi
  _BYTE *v148; // r15
  _BYTE *v149; // r13
  _BYTE *v150; // rax
  _BYTE *v151; // rdx
  const char *v152; // rdi
  signed __int64 v153; // rcx
  char *v154; // rsi
  char v155; // al
  const char *v156; // rdi
  signed __int64 v157; // rcx
  char *v158; // rsi
  char v159; // al
  char *v160; // r15
  char *v161; // r13
  char *v162; // rdi
  const char *v163; // rdi
  signed __int64 v164; // rcx
  char *v165; // rsi
  int v166; // eax
  void **v167; // r13
  const char *i; // r15
  char *v169; // rax
  int v170; // eax
  const char *v171; // rdi
  signed __int64 v172; // rcx
  char *v173; // rsi
  int v174; // eax
  int v175; // esi
  void **v176; // r15
  void **v177; // r15
  unsigned int v178; // eax
  char *s1; // [rsp+0h] [rbp-1058h]
  char **v180; // [rsp+8h] [rbp-1050h]
  signed int v181; // [rsp+8h] [rbp-1050h]
  char ptr; // [rsp+10h] [rbp-1048h]
  unsigned __int64 v183; // [rsp+1018h] [rbp-40h]

  v5 = a3;
  v6 = a2;
  LODWORD(v7) = a1;
  v183 = __readfsqword(0x28u);
  v8 = (unsigned __int8)*a3 < 0x2Du;
  v9 = *a3 == 45;
  if ( *a3 != 45 )
  {
    if ( a1 >= 0 )
    {
      if ( !byte_326144 )
      {
        v10 = 0;
        v11 = 1;
        v12 = "telnet:";
        v13 = 7LL;
        v14 = v5;
        do
        {
          if ( !v13 )
            break;
          v10 = (unsigned __int8)*v14 < *v12;
          v11 = *v14++ == *v12++;
          --v13;
        }
        while ( v11 );
        if ( (!v10 && !v11) != v10 )
        {
          a5 = 0xFFFFFFFFLL;
          LODWORD(v7) = 0;
          s1 = 0LL;
          v28 = strspn(v5, " \t");
          v29 = sub_BC120(&v5[v28]);
          v30 = v29;
          v31 = strlen(v29);
          if ( v31 )
          {
            v32 = v31 - 1;
            v33 = v30[v31 - 1];
            if ( v33 == 32 || v33 == 9 )
            {
              do
              {
                v30[v32] = 0;
                if ( !v32 )
                  break;
                v34 = v30[--v32];
              }
              while ( v34 == 32 || v34 == 9 );
            }
          }
          byte_326144 = 1;
          sub_1F890((_QWORD *)v6, 0, v30);
          sub_2F4D0(v30);
          sub_2F4D0(0LL);
          goto LABEL_40;
        }
        v15 = v5 + 7;
        if ( v5[7] == 47 && v5[8] == 47 )
          v15 = v5 + 9;
        sub_1F760((_QWORD *)v6, 2, 1);
        v16 = sub_BC050(v15, ":/");
        a5 = (__int64)&v15[v16];
        v7 = sub_BC360((__int64)"%.*s", (unsigned int)v16, v15);
        sub_1F890((_QWORD *)v6, 0, v7);
        sub_2F4D0(v7);
        v9 = *(_BYTE *)a5 == 58;
        byte_326144 = 1;
        if ( v9 )
        {
          v17 = 1;
          v60 = strtol((const char *)(a5 + 1), 0LL, 10);
          sub_1F760((_QWORD *)v6, 1, v60);
          byte_326143 = 1;
        }
        else
        {
          sub_1F760((_QWORD *)v6, 1, -1);
          v17 = 1;
        }
        goto LABEL_13;
      }
      LODWORD(v7) = 64;
      if ( !byte_326143 )
      {
        v7 = sub_BC120(a3);
        v6 = (unsigned int)sub_1CD30(1, v6, "-P", (__int64)v7, a5);
        sub_2F4D0(v7);
        if ( (_DWORD)v6 != 2 )
          __assert_fail("retd == 2", "cmdline.c", 0x184u, "cmdline_process_param");
        byte_326143 = 1;
        v17 = 1;
        goto LABEL_13;
      }
    }
    v17 = 0;
    goto LABEL_13;
  }
  v19 = "-load";
  a5 = a4;
  v20 = 6LL;
  v21 = v5;
  do
  {
    if ( !v20 )
      break;
    v8 = (unsigned __int8)*v21 < *v19;
    v9 = *v21++ == *v19++;
    --v20;
  }
  while ( v9 );
  if ( (!v8 && !v9) != v8 )
  {
    v22 = &off_31EC80;
    v23 = &off_323408;
    s1 = v5 + 1;
    v24 = 0;
    v25 = &off_31EC80 == 0LL;
    if ( &off_31EC80 )
    {
      while ( strcmp(s1, (const char *)v22[17]) )
      {
        ++v23;
        v22 = (void **)*(v23 - 1);
        v24 = 0;
        v25 = v22 == 0LL;
        if ( !v22 )
          goto LABEL_41;
      }
      if ( (signed int)v7 < 0 )
        goto LABEL_40;
      if ( !(dword_F9C60 & 2) )
      {
        if ( (_DWORD)v7 )
          goto LABEL_144;
        v26 = *((_DWORD *)v22 + 38);
        sub_3CF60(*((_DWORD *)v22 + 38));
        sub_1F760((_QWORD *)v6, 2, v26);
        LODWORD(v7) = *((_DWORD *)v22 + 39);
        if ( (_DWORD)v7 )
        {
          sub_3CF70((int)v7);
          sub_1F760((_QWORD *)v6, 1, (int)v7);
        }
        if ( *((_DWORD *)v22 + 38) != 5 )
          goto LABEL_40;
        v17 = 1;
        v27 = (char *)sub_1F170((__int64 *)v6, 0);
        sub_1F890((_QWORD *)v6, 61, v27);
        goto LABEL_13;
      }
    }
    else
    {
LABEL_41:
      v35 = "-v";
      v36 = 3LL;
      v37 = v5;
      do
      {
        if ( !v36 )
          break;
        v24 = (unsigned __int8)*v37 < *v35;
        v25 = *v37++ == *v35++;
        --v36;
      }
      while ( v25 );
      if ( (!v24 && !v25) != v24 )
      {
        v38 = 0;
        v39 = 1;
        v17 = 0;
LABEL_46:
        v40 = "-l";
        v41 = 3LL;
        v42 = v5;
        do
        {
          if ( !v41 )
            break;
          v38 = (unsigned __int8)*v42 < *v40;
          v39 = *v42++ == *v40++;
          --v41;
        }
        while ( v39 );
        v43 = (!v38 && !v39) - v38;
        v44 = 0;
        v45 = v43 == 0;
        if ( v43 )
        {
          v61 = "-loghost";
          v62 = 9LL;
          v63 = v5;
          do
          {
            if ( !v62 )
              break;
            v44 = (unsigned __int8)*v63 < *v61;
            v45 = *v63++ == *v61++;
            --v62;
          }
          while ( v45 );
          v64 = (!v44 && !v45) - v44;
          v65 = 0;
          v66 = v64 == 0;
          if ( v64 )
          {
            v152 = "-hostkey";
            v153 = 9LL;
            v154 = v5;
            do
            {
              if ( !v153 )
                break;
              v65 = (unsigned __int8)*v154 < *v152;
              v66 = *v154++ == *v152++;
              --v153;
            }
            while ( v66 );
            v155 = (!v65 && !v66) - v65;
            v58 = 0;
            v59 = v155 == 0;
            if ( !v155 )
            {
              if ( !a5 )
                goto LABEL_183;
              if ( (signed int)v7 < 0 )
                goto LABEL_21;
              goto LABEL_61;
            }
LABEL_146:
            v139 = "-L";
            v140 = 3LL;
            v141 = v5;
            do
            {
              if ( !v140 )
                break;
              v58 = (unsigned __int8)*v141 < *v139;
              v59 = *v141++ == *v139++;
              --v140;
            }
            while ( v59 );
            v142 = (!v58 && !v59) - v58;
            v80 = 0;
            v81 = v142 == 0;
            if ( !v142 )
            {
LABEL_150:
              if ( !a5 )
                goto LABEL_183;
              if ( (signed int)v7 < 0 )
                goto LABEL_21;
              if ( dword_F9C60 & 3 )
LABEL_169:
                sub_AA7D0((__int64)"option \"%s\" not available in this tool", v5, s1);
              v143 = 0;
              v144 = (_DWORD)v7 == 0;
              if ( (_DWORD)v7 )
                goto LABEL_62;
              goto LABEL_154;
            }
LABEL_90:
            v82 = "-R";
            v83 = 3LL;
            v84 = v5;
            do
            {
              if ( !v83 )
                break;
              v80 = (unsigned __int8)*v84 < (unsigned __int8)*v82;
              v81 = *v84++ == *v82++;
              --v83;
            }
            while ( v81 );
            v85 = (!v80 && !v81) - v80;
            v86 = 0;
            v87 = v85 == 0;
            if ( v85 )
            {
              v88 = "-D";
              v89 = 3LL;
              v90 = v5;
              do
              {
                if ( !v89 )
                  break;
                v86 = (unsigned __int8)*v90 < *v88;
                v87 = *v90++ == *v88++;
                --v89;
              }
              while ( v87 );
              v91 = (!v86 && !v87) - v86;
              v92 = 0;
              v93 = v91 == 0;
              if ( v91 )
                goto LABEL_98;
            }
            goto LABEL_150;
          }
          if ( !a5 )
            goto LABEL_183;
          if ( (signed int)v7 < 0 )
            goto LABEL_21;
          if ( (_DWORD)v7 )
            goto LABEL_62;
        }
        else
        {
          if ( !a5 )
            goto LABEL_183;
          if ( (signed int)v7 < 0 )
            goto LABEL_21;
          if ( (_DWORD)v7 )
            goto LABEL_62;
          sub_1F890((_QWORD *)v6, 56, (char *)a5);
          v48 = "-loghost";
          v49 = 9LL;
          v50 = v5;
          do
          {
            if ( !v49 )
              break;
            v46 = (unsigned __int8)*v50 < *v48;
            v47 = *v50++ == *v48++;
            --v49;
          }
          while ( v47 );
          v51 = (!v46 && !v47) - v46;
          v52 = 0;
          v53 = v51 == 0;
          if ( v51 )
          {
            v54 = "-hostkey";
            v55 = 9LL;
            v56 = v5;
            do
            {
              if ( !v55 )
                break;
              v52 = (unsigned __int8)*v56 < *v54;
              v53 = *v56++ == *v54++;
              --v55;
            }
            while ( v53 );
            v57 = (!v52 && !v53) - v52;
            v58 = 0;
            v59 = v57 == 0;
            if ( !v57 )
            {
LABEL_61:
              if ( (_DWORD)v7 )
                goto LABEL_62;
              goto LABEL_84;
            }
            goto LABEL_145;
          }
        }
        sub_1F890((_QWORD *)v6, 9, (char *)a5);
        v69 = "-hostkey";
        v70 = 9LL;
        v71 = v5;
        do
        {
          if ( !v70 )
            break;
          v67 = (unsigned __int8)*v71 < *v69;
          v68 = *v71++ == *v69++;
          --v70;
        }
        while ( v68 );
        v72 = (!v67 && !v68) - v67;
        v58 = 0;
        v59 = v72 == 0;
        if ( !v72 )
        {
LABEL_84:
          v73 = sub_BC120((char *)a5);
          if ( !(unsigned __int8)sub_31D30(v73) )
            sub_AA7D0((__int64)"'%s' is not a valid format for a manual host key specification", a5, s1);
          sub_1F940((_QWORD *)v6, 192, v73, &locale);
          sub_2F4D0(v73);
          v76 = "-L";
          v77 = 3LL;
          v78 = v5;
          do
          {
            if ( !v77 )
              break;
            v74 = (unsigned __int8)*v78 < *v76;
            v75 = *v78++ == *v76++;
            --v77;
          }
          while ( v75 );
          v79 = (!v74 && !v75) - v74;
          v80 = 0;
          v81 = v79 == 0;
          if ( !v79 )
          {
            v143 = 0;
            v144 = 1;
LABEL_154:
            v145 = "-D";
            v146 = 3LL;
            v147 = v5;
            do
            {
              if ( !v146 )
                break;
              v143 = (unsigned __int8)*v147 < *v145;
              v144 = *v147++ == *v145++;
              --v146;
            }
            while ( v144 );
            if ( (!v143 && !v144) == v143 )
            {
              v160 = sub_BC360((__int64)"L%s", a5, s1);
              v161 = sub_BC120("D");
            }
            else
            {
              LOBYTE(s1) = v5[1];
              v148 = sub_BC080((_BYTE *)a5, 58);
              v149 = v148;
              if ( !v148 )
                sub_AA7D0((__int64)"-%c expects at least two colons in its argument", (unsigned int)(char)s1, s1);
              while ( 1 )
              {
                v150 = sub_BC080(v148 + 1, 58);
                v151 = v148;
                v148 = v150;
                if ( !v150 )
                  break;
                v149 = v151;
              }
              v160 = sub_BC360((__int64)"%c%.*s", (unsigned int)(char)s1, &v149[-a5], a5, s1);
              v161 = sub_BC120(v149 + 1);
            }
            sub_1F940((_QWORD *)v6, 174, v160, v161);
            sub_2F4D0(v160);
            v162 = v161;
            v17 = 2;
            sub_2F4D0(v162);
LABEL_98:
            v94 = "-nc";
            v95 = 4LL;
            v96 = v5;
            do
            {
              if ( !v95 )
                break;
              v92 = (unsigned __int8)*v96 < *v94;
              v93 = *v96++ == *v94++;
              --v95;
            }
            while ( v93 );
            v97 = (!v92 && !v93) - v92;
            v98 = 0;
            v99 = v97 == 0;
            if ( v97 )
            {
              v156 = "-m";
              v157 = 3LL;
              v158 = v5;
              do
              {
                if ( !v157 )
                  break;
                v98 = (unsigned __int8)*v158 < *v156;
                v99 = *v158++ == *v156++;
                --v157;
              }
              while ( v99 );
              v159 = (!v98 && !v99) - v98;
              v113 = 0;
              v114 = v159 == 0;
              if ( v159 )
              {
LABEL_115:
                v115 = "-P";
                v116 = 3LL;
                v117 = v5;
                do
                {
                  if ( !v116 )
                    break;
                  v113 = (unsigned __int8)*v117 < *v115;
                  v114 = *v117++ == *v115++;
                  --v116;
                }
                while ( v114 );
                v118 = (!v113 && !v114) - v113;
                v119 = 0;
                v120 = v118 == 0;
                if ( !v118 )
                {
                  if ( !a5 )
                    goto LABEL_183;
                  if ( (signed int)v7 < 0 )
                    goto LABEL_21;
                  if ( (_DWORD)v7 )
                    goto LABEL_243;
                  goto LABEL_122;
                }
                v163 = "-pw";
                v164 = 4LL;
                v165 = v5;
                do
                {
                  if ( !v164 )
                    break;
                  v119 = (unsigned __int8)*v165 < *v163;
                  v120 = *v165++ == *v163++;
                  --v164;
                }
                while ( v120 );
                if ( (!v119 && !v120) != v119 )
                {
                  v166 = strcmp(v5, "-agent");
                  v134 = 0;
                  v135 = v166 == 0;
                  if ( !v166 )
                  {
LABEL_189:
                    if ( (signed int)v7 < 0 )
                      goto LABEL_40;
                    goto LABEL_190;
                  }
LABEL_133:
                  v136 = "-pagent";
                  v137 = 8LL;
                  v138 = v5;
                  do
                  {
                    if ( !v137 )
                      break;
                    v134 = (unsigned __int8)*v138 < *v136;
                    v135 = *v138++ == *v136++;
                    --v137;
                  }
                  while ( v135 );
                  if ( (!v134 && !v135) != v134 && strcmp(v5, "-pageant") )
                  {
LABEL_138:
                    if ( !strcmp(v5, "-noagent") || !strcmp(v5, "-nopagent") )
                      goto LABEL_250;
                    goto LABEL_140;
                  }
                  goto LABEL_189;
                }
                if ( !a5 )
                  goto LABEL_183;
                if ( (signed int)v7 < 0 )
                  goto LABEL_21;
                goto LABEL_242;
              }
              v17 = -2;
              if ( !a5 )
                goto LABEL_13;
              v17 = 2;
              if ( (signed int)v7 < 0 )
                goto LABEL_13;
              if ( dword_F9C60 & 3 )
                sub_AA7D0((__int64)"option \"%s\" not available in this tool", v5, s1);
              if ( (_DWORD)v7 )
              {
                sub_1CB40(v5, (char *)a5, 0);
                goto LABEL_13;
              }
            }
            else
            {
              if ( !a5 )
                goto LABEL_183;
              if ( (signed int)v7 < 0 )
                goto LABEL_21;
              if ( (_DWORD)v7 )
                goto LABEL_62;
              v100 = sub_BC080((_BYTE *)a5, 58);
              if ( !v100 )
                sub_AA7D0((__int64)"-nc expects argument of form 'host:port'", 58LL, s1);
              v101 = sub_BC360((__int64)"%.*s", &v100[-a5], a5, v100);
              sub_1F890((_QWORD *)v6, 50, v101);
              v102 = strtol(s1 + 1, 0LL, 10);
              sub_1F760((_QWORD *)v6, 51, v102);
              sub_2F4D0(v101);
              v105 = "-m";
              v106 = 3LL;
              v107 = v5;
              do
              {
                if ( !v106 )
                  break;
                v103 = (unsigned __int8)*v107 < *v105;
                v104 = *v107++ == *v105++;
                --v106;
              }
              while ( v104 );
              v108 = (!v103 && !v104) - v103;
              v109 = 0;
              v110 = v108 == 0;
              if ( v108 )
              {
                v171 = "-P";
                v172 = 3LL;
                v173 = v5;
                do
                {
                  if ( !v172 )
                    break;
                  v109 = (unsigned __int8)*v173 < *v171;
                  v110 = *v173++ == *v171++;
                  --v172;
                }
                while ( v110 );
                if ( (!v109 && !v110) == v109 )
                {
LABEL_122:
                  v121 = strtol((const char *)a5, 0LL, 10);
                  sub_1F760((_QWORD *)v6, 1, v121);
                  v124 = "-pw";
                  v125 = 4LL;
                  v126 = v5;
                  do
                  {
                    if ( !v125 )
                      break;
                    v122 = (unsigned __int8)*v126 < *v124;
                    v123 = *v126++ == *v124++;
                    --v125;
                  }
                  while ( v123 );
                  v127 = (!v122 && !v123) - v122;
                  v128 = 0;
                  v129 = v127 == 0;
                  if ( !v127 )
                    goto LABEL_126;
                  v130 = "-agent";
                  v131 = 7LL;
                  v132 = v5;
                  do
                  {
                    if ( !v131 )
                      break;
                    v128 = (unsigned __int8)*v132 < *v130;
                    v129 = *v132++ == *v130++;
                    --v131;
                  }
                  while ( v129 );
                  v133 = (!v128 && !v129) - v128;
                  v134 = 0;
                  v135 = v133 == 0;
                  if ( !v133 )
                    goto LABEL_191;
LABEL_132:
                  v17 = 2;
                  goto LABEL_133;
                }
                if ( strcmp(v5, "-pw") )
                {
                  v174 = strcmp(v5, "-agent");
                  v134 = 0;
                  v135 = v174 == 0;
                  if ( !v174 )
                  {
LABEL_190:
                    if ( (_DWORD)v7 )
                      goto LABEL_144;
                    goto LABEL_191;
                  }
                  goto LABEL_132;
                }
LABEL_242:
                if ( (_DWORD)v7 )
                  goto LABEL_243;
LABEL_126:
                if ( (unsigned int)sub_1EFD0((__int64 *)v6, 2) != 3 )
                  sub_AA7D0((__int64)"the -pw option can only be used with the SSH protocol", 2LL, s1);
                s = sub_BC120((char *)a5);
                sub_BD070((void *)a5, strlen((const char *)a5));
                if ( strcmp(v5, "-agent") && strcmp(v5, "-pagent") )
                {
                  if ( strcmp(v5, "-pageant") )
                  {
                    v17 = 2;
                    goto LABEL_138;
                  }
                  goto LABEL_190;
                }
LABEL_191:
                sub_1F6D0((_QWORD *)v6, 29, 1);
                if ( !strcmp(v5, "-noagent") )
                  goto LABEL_192;
                if ( !strcmp(v5, "-nopagent") )
                  goto LABEL_251;
                v17 = 1;
LABEL_140:
                if ( !strcmp(v5, "-nopageant") )
                  goto LABEL_250;
                if ( !strcmp(v5, "-no-trivial-auth") )
                {
                  if ( (signed int)v7 >= 0 )
                  {
                    if ( !(_DWORD)v7 )
                      goto LABEL_270;
                    goto LABEL_144;
                  }
                }
                else
                {
                  if ( strcmp(v5, "-share") )
                    goto LABEL_195;
                  if ( (signed int)v7 >= 0 )
                    goto LABEL_262;
                }
                goto LABEL_40;
              }
            }
            v111 = fopen((const char *)a5, "r");
            if ( !v111 )
              sub_AA7D0((__int64)"unable to open command file \"%s\"", a5, s1);
            v180 = (char **)sub_BC640();
            s1 = (char *)(v180 + 3);
            while ( fread(&ptr, 1uLL, 0x1000uLL, v111) )
              sub_2EC20((__int64 (**)(void))s1);
            v112 = v111;
            v17 = 2;
            fclose(v112);
            sub_1F890((_QWORD *)v6, 20, *v180);
            sub_1F890((_QWORD *)v6, 21, &locale);
            sub_1F6D0((_QWORD *)v6, 22, 1);
            sub_BC660((void **)v180);
            goto LABEL_115;
          }
          v17 = 2;
          goto LABEL_90;
        }
LABEL_145:
        v17 = 2;
        goto LABEL_146;
      }
      if ( (signed int)v7 < 0 )
        goto LABEL_40;
      v38 = 0;
      v39 = (dword_F9C60 & 0x80u) == 0;
      if ( (dword_F9C60 & 0x80u) == 0 )
      {
        byte_326142 = 1;
        v17 = 1;
        goto LABEL_46;
      }
    }
    sub_AA7D0((__int64)"option \"%s\" not available in this tool", v5, s1);
  }
  if ( !a5 )
    goto LABEL_183;
  if ( a1 < 0 )
    goto LABEL_21;
  v17 = 2;
  sub_40A60((__int64 *)v6, a5);
  byte_326141 = 1;
LABEL_13:
  while ( 1 )
  {
    result = v17;
    if ( __readfsqword(0x28u) == v183 )
      return result;
LABEL_250:
    if ( (signed int)v7 < 0 )
      goto LABEL_40;
LABEL_251:
    if ( (_DWORD)v7 )
      goto LABEL_144;
LABEL_192:
    sub_1F6D0((_QWORD *)v6, 29, 0);
    if ( !strcmp(v5, "-no-trivial-auth") )
    {
LABEL_270:
      sub_1F6D0((_QWORD *)v6, 37, 1);
      if ( strcmp(v5, "-share") )
      {
        if ( strcmp(v5, "-noshare") )
        {
          v17 = 1;
LABEL_273:
          if ( strcmp(v5, "-A") )
            goto LABEL_266;
          if ( (signed int)v7 < 0 )
            goto LABEL_40;
LABEL_275:
          if ( (_DWORD)v7 )
            goto LABEL_144;
          goto LABEL_199;
        }
        goto LABEL_197;
      }
    }
    else
    {
      if ( strcmp(v5, "-share") )
      {
        v17 = 1;
LABEL_195:
        if ( strcmp(v5, "-noshare") )
          goto LABEL_273;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_197:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_198;
      }
LABEL_262:
      if ( (_DWORD)v7 )
        goto LABEL_144;
    }
    sub_1F6D0((_QWORD *)v6, 189, 1);
    if ( strcmp(v5, "-noshare") )
    {
      if ( strcmp(v5, "-A") )
      {
        v17 = 1;
LABEL_266:
        if ( strcmp(v5, "-a") )
          goto LABEL_280;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_268:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_200;
      }
      goto LABEL_275;
    }
LABEL_198:
    sub_1F6D0((_QWORD *)v6, 189, 0);
    if ( strcmp(v5, "-A") )
    {
      if ( strcmp(v5, "-a") )
      {
        v17 = 1;
LABEL_280:
        if ( strcmp(v5, "-X") )
          goto LABEL_287;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_282:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_201;
      }
      goto LABEL_268;
    }
LABEL_199:
    sub_1F6D0((_QWORD *)v6, 30, 1);
    if ( strcmp(v5, "-a") )
    {
      if ( strcmp(v5, "-X") )
      {
        v17 = 1;
LABEL_287:
        if ( strcmp(v5, "-x") )
          goto LABEL_333;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_289:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_202;
      }
      goto LABEL_282;
    }
LABEL_200:
    sub_1F6D0((_QWORD *)v6, 30, 0);
    if ( strcmp(v5, "-X") )
    {
      if ( strcmp(v5, "-x") )
      {
        v17 = 1;
LABEL_333:
        if ( strcmp(v5, "-t") )
          goto LABEL_327;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_335:
        if ( (_DWORD)v7 )
          goto LABEL_330;
        goto LABEL_203;
      }
      goto LABEL_289;
    }
LABEL_201:
    sub_1F6D0((_QWORD *)v6, 168, 1);
    if ( strcmp(v5, "-x") )
    {
      if ( strcmp(v5, "-t") )
      {
        v17 = 1;
LABEL_327:
        if ( strcmp(v5, "-T") )
          goto LABEL_316;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_329:
        if ( (_DWORD)v7 )
          goto LABEL_330;
        goto LABEL_204;
      }
      goto LABEL_335;
    }
LABEL_202:
    sub_1F6D0((_QWORD *)v6, 168, 0);
    if ( strcmp(v5, "-t") )
    {
      if ( strcmp(v5, "-T") )
      {
        v17 = 1;
LABEL_316:
        if ( strcmp(v5, "-N") )
          goto LABEL_310;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_318:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_205;
      }
      goto LABEL_329;
    }
LABEL_203:
    sub_1F6D0((_QWORD *)v6, 22, 0);
    if ( strcmp(v5, "-T") )
    {
      if ( strcmp(v5, "-N") )
      {
        v17 = 1;
LABEL_310:
        if ( strcmp(v5, "-C") )
          goto LABEL_304;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_312:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_206;
      }
      goto LABEL_318;
    }
LABEL_204:
    sub_1F6D0((_QWORD *)v6, 22, 1);
    if ( strcmp(v5, "-N") )
    {
      if ( strcmp(v5, "-C") )
      {
        v17 = 1;
LABEL_304:
        if ( strcmp(v5, "-1") )
          goto LABEL_322;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_306:
        if ( (_DWORD)v7 )
          goto LABEL_144;
        goto LABEL_207;
      }
      goto LABEL_312;
    }
LABEL_205:
    sub_1F6D0((_QWORD *)v6, 49, 1);
    if ( strcmp(v5, "-C") )
    {
      if ( strcmp(v5, "-1") )
      {
        v17 = 1;
LABEL_322:
        if ( strcmp(v5, "-2") )
          goto LABEL_210;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
LABEL_300:
        if ( (_DWORD)v7 )
          goto LABEL_144;
LABEL_208:
        sub_1F760((_QWORD *)v6, 34, 3);
        goto LABEL_209;
      }
      goto LABEL_306;
    }
LABEL_206:
    sub_1F6D0((_QWORD *)v6, 23, 1);
    if ( strcmp(v5, "-1") )
    {
      if ( strcmp(v5, "-2") )
        goto LABEL_209;
      goto LABEL_300;
    }
LABEL_207:
    sub_1F760((_QWORD *)v6, 34, 0);
    if ( !strcmp(v5, "-2") )
      goto LABEL_208;
LABEL_209:
    v17 = 1;
LABEL_210:
    if ( !strcmp(v5, "-i") )
    {
      if ( !a5 )
        goto LABEL_183;
      if ( (signed int)v7 < 0 )
        goto LABEL_21;
      if ( dword_F9C60 & 2 )
        goto LABEL_169;
      if ( (_DWORD)v7 )
        goto LABEL_62;
      v167 = (void **)sub_B4DD0((char *)a5);
      sub_1FAC0((_QWORD *)v6, 33, (__int64)v167);
      sub_B4E60(v167);
      if ( !strcmp(v5, "-4") || !strcmp(v5, "-ipv4") )
        goto LABEL_216;
      if ( strcmp(v5, "-6") )
      {
        v17 = 2;
        if ( strcmp(v5, "-ipv6") )
          goto LABEL_219;
      }
LABEL_217:
      sub_1F760((_QWORD *)v6, 3, 2);
LABEL_218:
      v17 = 1;
LABEL_219:
      if ( !strcmp(v5, "-sercfg") )
      {
        if ( !a5 )
          goto LABEL_183;
        if ( (signed int)v7 < 0 )
          goto LABEL_21;
        if ( (_DWORD)v7 )
        {
LABEL_243:
          sub_1CB40(v5, (char *)a5, 1);
          v17 = 2;
        }
        else
        {
          if ( (unsigned int)sub_1EFD0((__int64 *)v6, 2) != 5 )
            sub_AA7D0((__int64)"the -sercfg option can only be used with the serial protocol", 2LL, s1);
          for ( i = (const char *)a5; *i; i += v181 + (signed int)s1 )
          {
            v169 = strchr(i, 44);
            if ( v169 )
            {
              v181 = 1;
              LODWORD(s1) = (_DWORD)v169 - (_DWORD)i;
              i[(signed int)v169 - (signed int)i] = 0;
            }
            else
            {
              v181 = 0;
              LODWORD(s1) = strlen(i);
            }
            if ( (_DWORD)s1 == 1 )
            {
              v175 = *i;
              if ( *i == 82 )
              {
                sub_1F760((_QWORD *)v6, 66, 2);
              }
              else if ( *i <= 82 )
              {
                if ( (char)v175 > 57 )
                {
                  if ( (_BYTE)v175 == 68 )
                  {
                    sub_1F760((_QWORD *)v6, 66, 3);
                  }
                  else
                  {
                    if ( (_BYTE)v175 != 78 )
LABEL_372:
                      sub_AA7D0((__int64)"Unrecognised suboption \"-sercfg %c\"", s1);
                    sub_1F760((_QWORD *)v6, 66, 0);
                  }
                }
                else if ( (char)v175 >= 53 )
                {
                  sub_1F760((_QWORD *)v6, 63, v175 - 48);
                }
                else
                {
                  if ( (unsigned __int8)(*i - 49) > 1u )
                    goto LABEL_372;
                  sub_1F760((_QWORD *)v6, 64, 2 * v175 - 96);
                }
              }
              else if ( (_BYTE)v175 == 109 )
              {
                sub_1F760((_QWORD *)v6, 65, 3);
              }
              else if ( (char)v175 <= 109 )
              {
                if ( (_BYTE)v175 == 88 )
                {
                  sub_1F760((_QWORD *)v6, 66, 1);
                }
                else
                {
                  if ( (_BYTE)v175 != 101 )
                    goto LABEL_372;
                  sub_1F760((_QWORD *)v6, 65, 2);
                }
              }
              else if ( (_BYTE)v175 == 111 )
              {
                sub_1F760((_QWORD *)v6, 65, 1);
              }
              else if ( (char)v175 < 111 )
              {
                sub_1F760((_QWORD *)v6, 65, 0);
              }
              else
              {
                if ( (_BYTE)v175 != 115 )
                  goto LABEL_372;
                sub_1F760((_QWORD *)v6, 65, 4);
              }
            }
            else if ( (_DWORD)s1 == 3 && !strncmp(i, "1.5", 3uLL) )
            {
              sub_1F760((_QWORD *)v6, 64, 3);
            }
            else
            {
              v170 = strtol(i, 0LL, 10);
              if ( !v170 )
                sub_AA7D0((__int64)"Unrecognised suboption \"-sercfg %s\"", i, s1);
              sub_1F760((_QWORD *)v6, 62, v170);
            }
          }
          if ( !strcmp(v5, "-sessionlog") )
            goto LABEL_341;
          if ( !strcmp(v5, "-sshlog") )
            goto LABEL_355;
          v17 = 2;
LABEL_364:
          if ( !strcmp(v5, "-sshrawlog") )
            goto LABEL_365;
          if ( strcmp(v5, "-logoverwrite") )
            goto LABEL_359;
          if ( (signed int)v7 < 0 )
            goto LABEL_40;
LABEL_370:
          if ( (_DWORD)v7 )
            goto LABEL_144;
LABEL_343:
          sub_1F760((_QWORD *)v6, 129, 1);
          if ( !strcmp(v5, "-logappend") )
            goto LABEL_344;
LABEL_345:
          v17 = 1;
LABEL_346:
          if ( !strcmp(v5, "-proxycmd") )
          {
            if ( !a5 )
              goto LABEL_183;
            if ( (signed int)v7 < 0 )
              goto LABEL_21;
            if ( dword_F9C60 & 2 )
              goto LABEL_169;
            if ( (_DWORD)v7 )
            {
LABEL_62:
              sub_1CB40(v5, (char *)a5, 0);
              goto LABEL_21;
            }
            sub_1F760((_QWORD *)v6, 13, 5);
            sub_1F890((_QWORD *)v6, 18, (char *)a5);
            v17 = 2;
          }
        }
      }
      else if ( !strcmp(v5, "-sessionlog") )
      {
        if ( !a5 )
          goto LABEL_183;
        if ( (signed int)v7 < 0 )
          goto LABEL_21;
        if ( (_DWORD)v7 )
          goto LABEL_62;
LABEL_341:
        v176 = (void **)sub_B4DD0((char *)a5);
        sub_1FAC0((_QWORD *)v6, 127, (__int64)v176);
        sub_1F760((_QWORD *)v6, 128, 2);
        sub_B4E60(v176);
        if ( !strcmp(v5, "-sshlog") )
          goto LABEL_342;
        if ( !strcmp(v5, "-sshrawlog") )
        {
LABEL_355:
          if ( (_DWORD)v7 )
            goto LABEL_62;
LABEL_342:
          v177 = (void **)sub_B4DD0((char *)a5);
          sub_1FAC0((_QWORD *)v6, 127, (__int64)v177);
          v178 = strcmp(v5, "-sshlog");
          sub_1F760((_QWORD *)v6, 128, 4 - (v178 < 1));
          sub_B4E60(v177);
          if ( !strcmp(v5, "-logoverwrite") )
            goto LABEL_343;
          if ( strcmp(v5, "-logappend") )
          {
            v17 = 2;
            goto LABEL_346;
          }
          goto LABEL_361;
        }
        if ( !strcmp(v5, "-logoverwrite") )
          goto LABEL_370;
        v17 = 2;
LABEL_359:
        if ( strcmp(v5, "-logappend") )
          goto LABEL_346;
        if ( (signed int)v7 < 0 )
        {
LABEL_40:
          v17 = 1;
        }
        else
        {
LABEL_361:
          if ( !(_DWORD)v7 )
          {
LABEL_344:
            sub_1F760((_QWORD *)v6, 129, 0);
            goto LABEL_345;
          }
LABEL_144:
          sub_1CB40(v5, (char *)a5, 0);
          v17 = 1;
        }
      }
      else
      {
        if ( strcmp(v5, "-sshlog") )
          goto LABEL_364;
LABEL_365:
        if ( a5 )
        {
          if ( (signed int)v7 >= 0 )
            goto LABEL_355;
LABEL_21:
          v17 = 2;
        }
        else
        {
LABEL_183:
          v17 = -2;
        }
      }
    }
    else
    {
      if ( !strcmp(v5, "-4") || !strcmp(v5, "-ipv4") )
      {
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
        if ( !(_DWORD)v7 )
        {
LABEL_216:
          sub_1F760((_QWORD *)v6, 3, 1);
          if ( strcmp(v5, "-6") && strcmp(v5, "-ipv6") )
            goto LABEL_218;
          goto LABEL_217;
        }
      }
      else
      {
        if ( strcmp(v5, "-6") && strcmp(v5, "-ipv6") )
          goto LABEL_219;
        if ( (signed int)v7 < 0 )
          goto LABEL_40;
        if ( !(_DWORD)v7 )
          goto LABEL_217;
      }
LABEL_330:
      sub_1CB40(v5, (char *)a5, 1);
      v17 = 1;
    }
  }
}

void __fastcall sub_1EA30(__int64 a1)
{
  __int64 *v1; // rbx
  unsigned __int64 v2; // rbp
  __int64 v3; // r12

  v1 = qword_326160;
  do
  {
    v2 = 0LL;
    if ( v1[1] )
    {
      do
      {
        v3 = 16 * v2++;
        sub_1CD30(0, a1, *(char **)(v3 + *v1), *(_QWORD *)(v3 + *v1 + 8), v3);
        sub_2F4D0(*(void **)(*v1 + v3));
        sub_2F4D0(*(void **)(*v1 + v3 + 8));
      }
      while ( v1[1] > v2 );
    }
    v1[1] = 0LL;
    v1 += 3;
  }
  while ( v1 != &qword_326160[6] );
}

char __fastcall sub_1EAB0(__int64 a1)
{
  char result; // al

  if ( !(dword_F9C60 & 4) )
    __assert_fail("cmdline_tooltype & TOOLTYPE_HOST_ARG", "cmdline.c", 0x36Au, "cmdline_host_ok");
  result = sub_31CC0((__int64 *)a1);
  if ( result )
  {
    result = byte_326144;
    if ( !byte_326144 )
      result = byte_326141;
  }
  return result;
}

void __fastcall sub_1EB00(signed int *a1)
{
  __int64 v1; // rax
  int v2; // eax

  v1 = *a1;
  if ( dword_DFDE0[v1] != 3 )
  {
    v2 = dword_DFAA0[v1];
    if ( v2 != 3 )
      goto LABEL_3;
LABEL_8:
    sub_2F4D0(*((void **)a1 + 2));
    sub_2F4D0(a1);
    return;
  }
  sub_2F4D0(*((void **)a1 + 1));
  v2 = dword_DFAA0[*a1];
  if ( v2 == 3 )
    goto LABEL_8;
LABEL_3:
  if ( v2 == 4 )
  {
    sub_B4E60(*((void ***)a1 + 2));
    sub_2F4D0(a1);
  }
  else
  {
    if ( v2 == 5 )
      sub_B5230(*((void ***)a1 + 2));
    sub_2F4D0(a1);
  }
}

signed int *__fastcall sub_1EBA0(_QWORD *a1)
{
  signed int *result; // rax

  while ( 1 )
  {
    result = (signed int *)sub_9B400((__int64 *)*a1, 0);
    if ( !result )
      break;
    sub_1EB00(result);
  }
  return result;
}

int __fastcall sub_1EBD0(const char **a1, const char **a2)
{
  __int64 v2; // rax
  int v3; // eax
  int result; // eax
  signed int v5; // eax

  v2 = *(signed int *)a1;
  if ( (signed int)v2 < *(_DWORD *)a2 )
    return -1;
  if ( (signed int)v2 > *(_DWORD *)a2 )
    return 1;
  v3 = dword_DFDE0[v2];
  if ( v3 == 2 )
  {
    v5 = *((_DWORD *)a2 + 2);
    if ( *((_DWORD *)a1 + 2) >= v5 )
      return *((_DWORD *)a1 + 2) > v5;
    return -1;
  }
  if ( v3 == 3 )
    result = strcmp(a1[1], a2[1]);
  else
    result = 0;
  return result;
}

int __fastcall sub_1EC40(const char **a1, const char **a2)
{
  __int64 v2; // rax
  int v3; // eax
  int result; // eax
  signed int v5; // eax

  v2 = *(signed int *)a1;
  if ( (signed int)v2 < *(_DWORD *)a2 )
    return -1;
  if ( (signed int)v2 > *(_DWORD *)a2 )
    return 1;
  v3 = dword_DFDE0[v2];
  if ( v3 == 2 )
  {
    v5 = *((_DWORD *)a2 + 2);
    if ( *((_DWORD *)a1 + 2) >= v5 )
      return *((_DWORD *)a1 + 2) > v5;
    return -1;
  }
  if ( v3 == 3 )
    result = strcmp(a1[1], a2[1]);
  else
    result = 0;
  return result;
}

signed int *__fastcall sub_1ECB0(_QWORD *a1, __int64 a2)
{
  signed int *result; // rax
  signed int *v3; // rbp

  result = (signed int *)sub_9AFD0((__int64 *)*a1, a2);
  if ( result )
  {
    v3 = result;
    if ( (signed int *)a2 != result )
    {
      sub_9B440((__int64 *)*a1, (__int64)result);
      sub_1EB00(v3);
      result = (signed int *)sub_9AFD0((__int64 *)*a1, a2);
      if ( (signed int *)a2 != result )
        __assert_fail(aOldentry, "conf.c", 0xECu, "conf_insert");
    }
  }
  return result;
}

_QWORD *sub_1ED20()
{
  _QWORD *v0; // rbx

  v0 = (_QWORD *)sub_2F450(1uLL, 8uLL, 0LL);
  *v0 = sub_9AF60((__int64)sub_1EBD0);
  return v0;
}

void __fastcall sub_1ED50(_QWORD *a1)
{
  sub_1EBA0(a1);
  sub_9AF90((_QWORD **)*a1);
  sub_2F4D0(a1);
}

char **__fastcall sub_1ED70(_QWORD *a1, _QWORD *a2)
{
  signed int v2; // ebx
  __int64 **v3; // r13
  char **result; // rax
  char **v5; // r15
  __int64 v6; // rsi
  __int64 v7; // rax
  int v8; // eax
  __int64 v9; // rax

  v2 = 0;
  v3 = (__int64 **)a2;
  sub_1EBA0(a1);
  while ( 1 )
  {
    result = (char **)sub_9B010(*v3, v2);
    v5 = result;
    if ( !result )
      return result;
    v6 = sub_2F450(1uLL, 0x18uLL, 0LL);
    v7 = *(signed int *)v5;
    *(_DWORD *)v6 = v7;
    v8 = dword_DFDE0[v7];
    if ( v8 == 2 )
    {
      *(_DWORD *)(v6 + 8) = *((_DWORD *)v5 + 2);
    }
    else if ( v8 == 3 )
    {
      *(_QWORD *)(v6 + 8) = sub_BC120(v5[1]);
    }
    v9 = (unsigned int)dword_DFAA0[*(signed int *)v5];
    switch ( (signed __int64)*(signed int *)v5 )
    {
      case 0LL:
      case 9LL:
      case 10LL:
      case 14LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 20LL:
      case 21LL:
      case 28LL:
      case 50LL:
      case 52LL:
      case 53LL:
      case 54LL:
      case 55LL:
      case 56LL:
      case 58LL:
      case 61LL:
      case 67LL:
      case 103LL:
      case 137LL:
      case 138LL:
      case 160LL:
      case 161LL:
      case 162LL:
      case 164LL:
      case 169LL:
      case 174LL:
      case 192LL:
      case 202LL:
      case 262LL:
      case 263LL:
      case 382LL:
      case 400LL:
        *(_QWORD *)(v6 + 16) = sub_BC120(v5[2]);
        break;
      case 1LL:
      case 2LL:
      case 3LL:
      case 4LL:
      case 6LL:
      case 11LL:
      case 13LL:
      case 15LL:
      case 19LL:
      case 24LL:
      case 25LL:
      case 27LL:
      case 32LL:
      case 34LL:
      case 44LL:
      case 45LL:
      case 51LL:
      case 62LL:
      case 63LL:
      case 64LL:
      case 65LL:
      case 66LL:
      case 68LL:
      case 73LL:
      case 83LL:
      case 92LL:
      case 93LL:
      case 104LL:
      case 108LL:
      case 110LL:
      case 111LL:
      case 113LL:
      case 114LL:
      case 115LL:
      case 119LL:
      case 123LL:
      case 124LL:
      case 126LL:
      case 128LL:
      case 129LL:
      case 136LL:
      case 146LL:
      case 147LL:
      case 148LL:
      case 155LL:
      case 157LL:
      case 158LL:
      case 159LL:
      case 163LL:
      case 170LL:
      case 175LL:
      case 176LL:
      case 177LL:
      case 178LL:
      case 179LL:
      case 180LL:
      case 181LL:
      case 182LL:
      case 183LL:
      case 184LL:
      case 185LL:
      case 186LL:
      case 187LL:
      case 200LL:
      case 232LL:
      case 233LL:
      case 240LL:
      case 253LL:
      case 355LL:
      case 363LL:
        *(_DWORD *)(v6 + 16) = *((_DWORD *)v5 + 4);
        break;
      case 5LL:
      case 7LL:
      case 8LL:
      case 12LL:
      case 22LL:
      case 23LL:
      case 26LL:
      case 29LL:
      case 30LL:
      case 31LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 38LL:
      case 39LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
      case 47LL:
      case 48LL:
      case 49LL:
      case 57LL:
      case 59LL:
      case 60LL:
      case 69LL:
      case 70LL:
      case 71LL:
      case 72LL:
      case 74LL:
      case 75LL:
      case 76LL:
      case 77LL:
      case 78LL:
      case 79LL:
      case 80LL:
      case 81LL:
      case 82LL:
      case 84LL:
      case 85LL:
      case 86LL:
      case 87LL:
      case 88LL:
      case 89LL:
      case 90LL:
      case 91LL:
      case 94LL:
      case 95LL:
      case 96LL:
      case 97LL:
      case 98LL:
      case 99LL:
      case 100LL:
      case 101LL:
      case 102LL:
      case 105LL:
      case 106LL:
      case 107LL:
      case 109LL:
      case 112LL:
      case 117LL:
      case 118LL:
      case 120LL:
      case 121LL:
      case 122LL:
      case 130LL:
      case 131LL:
      case 132LL:
      case 133LL:
      case 134LL:
      case 135LL:
      case 139LL:
      case 140LL:
      case 141LL:
      case 142LL:
      case 143LL:
      case 144LL:
      case 145LL:
      case 149LL:
      case 150LL:
      case 151LL:
      case 152LL:
      case 153LL:
      case 154LL:
      case 156LL:
      case 165LL:
      case 166LL:
      case 167LL:
      case 168LL:
      case 172LL:
      case 173LL:
      case 188LL:
      case 189LL:
      case 190LL:
      case 191LL:
      case 193LL:
      case 194LL:
      case 195LL:
      case 196LL:
      case 201LL:
        *(_BYTE *)(v6 + 16) = *((_BYTE *)v5 + 16);
        break;
      case 33LL:
      case 46LL:
      case 116LL:
      case 127LL:
      case 171LL:
        *(_QWORD *)(v6 + 16) = sub_B4E10((char **)v5[2]);
        break;
      case 125LL:
      case 197LL:
      case 198LL:
      case 199LL:
        *(_QWORD *)(v6 + 16) = sub_B5220((char **)v5[2]);
        break;
      default:
        break;
    }
    ++v2;
    sub_9AFD0((__int64 *)*a1, v6);
  }
}

_QWORD *__fastcall sub_1EED0(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = sub_1ED20();
  sub_1ED70(v1, a1);
  return v1;
}

__int64 __fastcall sub_1EF00(__int64 *a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x10Eu, "conf_get_bool");
  if ( dword_DFAA0[a2] != 1 )
    __assert_fail("valuetypes[primary] == TYPE_BOOL", "conf.c", 0x10Fu, "conf_get_bool");
  v2 = (__int64 *)*a1;
  v5 = a2;
  v3 = sub_9B3D0(v2, (__int64)&v5, 0LL);
  if ( !v3 || (result = *(unsigned __int8 *)(v3 + 16), __readfsqword(0x28u) != v6) )
    __assert_fail("entry", "conf.c", 0x112u, "conf_get_bool");
  return result;
}

__int64 __fastcall sub_1EFD0(__int64 *a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x11Bu, "conf_get_int");
  if ( dword_DFAA0[a2] != 2 )
    __assert_fail("valuetypes[primary] == TYPE_INT", "conf.c", 0x11Cu, "conf_get_int");
  v2 = (__int64 *)*a1;
  v5 = a2;
  v3 = sub_9B3D0(v2, (__int64)&v5, 0LL);
  if ( !v3 || (result = *(unsigned int *)(v3 + 16), __readfsqword(0x28u) != v6) )
    __assert_fail("entry", "conf.c", 0x11Fu, "conf_get_int");
  return result;
}

__int64 __fastcall sub_1F0A0(__int64 *a1, int a2, int a3)
{
  __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 result; // rax
  int v6; // [rsp+0h] [rbp-28h]
  int v7; // [rsp+8h] [rbp-20h]
  unsigned __int64 v8; // [rsp+18h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] != 2 )
    __assert_fail("subkeytypes[primary] == TYPE_INT", "conf.c", 0x128u, "conf_get_int_int");
  if ( dword_DFAA0[a2] != 2 )
    __assert_fail("valuetypes[primary] == TYPE_INT", "conf.c", 0x129u, "conf_get_int_int");
  v3 = (__int64 *)*a1;
  v6 = a2;
  v7 = a3;
  v4 = sub_9B3D0(v3, (__int64)&v6, 0LL);
  if ( !v4 || (result = *(unsigned int *)(v4 + 16), __readfsqword(0x28u) != v8) )
    __assert_fail("entry", "conf.c", 0x12Du, "conf_get_int_int");
  return result;
}

__int64 __fastcall sub_1F170(__int64 *a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x136u, "conf_get_str");
  if ( dword_DFAA0[a2] != 3 )
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x137u, "conf_get_str");
  v2 = (__int64 *)*a1;
  v5 = a2;
  v3 = sub_9B3D0(v2, (__int64)&v5, 0LL);
  if ( !v3 || (result = *(_QWORD *)(v3 + 16), __readfsqword(0x28u) != v6) )
    __assert_fail("entry", "conf.c", 0x13Au, "conf_get_str");
  return result;
}

__int64 __fastcall sub_1F240(__int64 *a1, int a2, __int64 a3)
{
  __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 result; // rax
  int v6; // [rsp+0h] [rbp-28h]
  __int64 v7; // [rsp+8h] [rbp-20h]
  unsigned __int64 v8; // [rsp+18h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] != 3 )
    __assert_fail("subkeytypes[primary] == TYPE_STR", "conf.c", 0x143u, "conf_get_str_str_opt");
  if ( dword_DFAA0[a2] != 3 )
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x144u, "conf_get_str_str_opt");
  v3 = (__int64 *)*a1;
  v6 = a2;
  v7 = a3;
  v4 = sub_9B3D0(v3, (__int64)&v6, 0LL);
  if ( v4 )
    result = *(_QWORD *)(v4 + 16);
  else
    result = 0LL;
  return result;
}

__int64 __fastcall sub_1F2F0(__int64 *a1, int a2, __int64 a3)
{
  __int64 result; // rax

  result = sub_1F240(a1, a2, a3);
  if ( !result )
    __assert_fail("ret", "conf.c", 0x14Eu, "conf_get_str_str");
  return result;
}

__int64 __fastcall sub_1F330(__int64 *a1, int a2, char *a3, _QWORD *a4)
{
  _QWORD *v4; // rbp
  __int64 *v5; // rdi
  __int64 v6; // rax
  __int64 result; // rax
  int v8; // [rsp+0h] [rbp-38h]
  char *v9; // [rsp+8h] [rbp-30h]
  unsigned __int64 v10; // [rsp+18h] [rbp-20h]

  v4 = a4;
  v10 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] != 3 )
    __assert_fail("subkeytypes[primary] == TYPE_STR", "conf.c", 0x158u, "conf_get_str_strs");
  if ( dword_DFAA0[a2] != 3
    || ((v8 = a2, v5 = (__int64 *)*a1, !a3) ? (v9 = &locale,
                                               v6 = sub_9B3E0(
                                                      v5,
                                                      (__int64)&v8,
                                                      (__int64 (__fastcall *)(__int64))sub_1EC40,
                                                      4)) : (v9 = a3, v6 = sub_9B3E0(v5, (__int64)&v8, 0LL, 3)),
        !v6 || *(_DWORD *)v6 != a2 ? (result = 0LL) : (*v4 = *(_QWORD *)(v6 + 8), result = *(_QWORD *)(v6 + 16)),
        __readfsqword(0x28u) != v10) )
  {
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x159u, "conf_get_str_strs");
  }
  return result;
}

__int64 __fastcall sub_1F430(_QWORD *a1, int a2, int a3)
{
  int v3; // ebp
  __int64 **v4; // r12
  __int64 *v5; // rdi
  _DWORD *v6; // rax
  __int64 v7; // rax
  __int64 result; // rax
  int v9; // [rsp+Ch] [rbp-3Ch]
  int v10; // [rsp+10h] [rbp-38h]
  char *v11; // [rsp+18h] [rbp-30h]
  unsigned __int64 v12; // [rsp+28h] [rbp-20h]

  v3 = a3;
  v12 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] != 3 )
    __assert_fail("subkeytypes[primary] == TYPE_STR", "conf.c", 0x16Eu, "conf_get_str_nthstrkey");
  if ( dword_DFAA0[a2] != 3 )
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x16Fu, "conf_get_str_nthstrkey");
  v4 = (__int64 **)a1;
  v5 = (__int64 *)*a1;
  v10 = a2;
  v11 = &locale;
  v6 = (_DWORD *)sub_9B220(v5, (__int64)&v10, (__int64 (__fastcall *)(__int64))sub_1EC40, 4, &v9);
  if ( v6 && *v6 == a2 && (v7 = sub_9B010(*v4, v3 + v9)) != 0 && *(_DWORD *)v7 == a2 )
    result = *(_QWORD *)(v7 + 8);
  else
    result = 0LL;
  return result;
}

__int64 __fastcall sub_1F530(__int64 *a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x181u, "conf_get_filename");
  if ( dword_DFAA0[a2] != 4 )
    __assert_fail("valuetypes[primary] == TYPE_FILENAME", "conf.c", 0x182u, "conf_get_filename");
  v2 = (__int64 *)*a1;
  v5 = a2;
  v3 = sub_9B3D0(v2, (__int64)&v5, 0LL);
  if ( !v3 || (result = *(_QWORD *)(v3 + 16), __readfsqword(0x28u) != v6) )
    __assert_fail("entry", "conf.c", 0x185u, "conf_get_filename");
  return result;
}

__int64 __fastcall sub_1F600(__int64 *a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  int v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x18Eu, "conf_get_fontspec");
  if ( dword_DFAA0[a2] != 5 )
    __assert_fail("valuetypes[primary] == TYPE_FONT", "conf.c", 0x18Fu, "conf_get_fontspec");
  v2 = (__int64 *)*a1;
  v5 = a2;
  v3 = sub_9B3D0(v2, (__int64)&v5, 0LL);
  if ( !v3 || (result = *(_QWORD *)(v3 + 16), __readfsqword(0x28u) != v6) )
    __assert_fail("entry", "conf.c", 0x192u, "conf_get_fontspec");
  return result;
}

signed int *__fastcall sub_1F6D0(_QWORD *a1, int a2, char a3)
{
  char v3; // r12
  __int64 v4; // rax

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x19Au, "conf_set_bool");
  if ( dword_DFAA0[a2] != 1 )
    __assert_fail("valuetypes[primary] == TYPE_BOOL", "conf.c", 0x19Bu, "conf_set_bool");
  *(_DWORD *)v4 = a2;
  *(_BYTE *)(v4 + 16) = v3;
  return sub_1ECB0(a1, v4);
}

signed int *__fastcall sub_1F760(_QWORD *a1, int a2, int a3)
{
  int v3; // er12
  _DWORD *v4; // rax

  v3 = a3;
  v4 = (_DWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x1A5u, "conf_set_int");
  if ( dword_DFAA0[a2] != 2 )
    __assert_fail("valuetypes[primary] == TYPE_INT", "conf.c", 0x1A6u, "conf_set_int");
  *v4 = a2;
  v4[4] = v3;
  return sub_1ECB0(a1, (__int64)v4);
}

signed int *__fastcall sub_1F7F0(_QWORD *a1, int a2, int a3, int a4)
{
  int v4; // er12
  int v5; // er13
  _DWORD *v6; // rax

  v4 = a3;
  v5 = a4;
  v6 = (_DWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] != 2 )
    __assert_fail("subkeytypes[primary] == TYPE_INT", "conf.c", 0x1B1u, "conf_set_int_int");
  if ( dword_DFAA0[a2] != 2 )
    __assert_fail("valuetypes[primary] == TYPE_INT", "conf.c", 0x1B2u, "conf_set_int_int");
  *v6 = a2;
  v6[2] = v4;
  v6[4] = v5;
  return sub_1ECB0(a1, (__int64)v6);
}

signed int *__fastcall sub_1F890(_QWORD *a1, int a2, char *a3)
{
  char *v3; // r13
  __int64 v4; // rbx

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x1BDu, "conf_set_str");
  if ( dword_DFAA0[a2] != 3 )
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x1BEu, "conf_set_str");
  *(_DWORD *)v4 = a2;
  *(_QWORD *)(v4 + 16) = sub_BC120(v3);
  return sub_1ECB0(a1, v4);
}

signed int *__fastcall sub_1F940(_QWORD *a1, int a2, char *a3, char *a4)
{
  char *v4; // r14
  char *v5; // r13
  __int64 v6; // rbx

  v4 = a3;
  v5 = a4;
  v6 = sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] != 3 )
    __assert_fail("subkeytypes[primary] == TYPE_STR", "conf.c", 0x1C9u, "conf_set_str_str");
  if ( dword_DFAA0[a2] != 3 )
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x1CAu, "conf_set_str_str");
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 8) = sub_BC120(v4);
  *(_QWORD *)(v6 + 16) = sub_BC120(v5);
  return sub_1ECB0(a1, v6);
}

unsigned __int64 __fastcall sub_1F9F0(_QWORD *a1, int a2, __int64 a3)
{
  __int64 **v3; // rbp
  __int64 *v4; // rdi
  __int64 v5; // rax
  signed int *v6; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v8; // rt1
  int v9; // [rsp+0h] [rbp-38h]
  __int64 v10; // [rsp+8h] [rbp-30h]
  unsigned __int64 v11; // [rsp+18h] [rbp-20h]

  v11 = __readfsqword(0x28u);
  if ( dword_DFDE0[a2] != 3 )
    __assert_fail("subkeytypes[primary] == TYPE_STR", "conf.c", 0x1D6u, "conf_del_str_str");
  if ( dword_DFAA0[a2] != 3 )
    goto LABEL_11;
  v3 = (__int64 **)a1;
  v4 = (__int64 *)*a1;
  v9 = a2;
  v10 = a3;
  v5 = sub_9B3D0(v4, (__int64)&v9, 0LL);
  v6 = (signed int *)v5;
  if ( v5 )
  {
    sub_9B440(*v3, v5);
    sub_1EB00(v6);
  }
  v8 = __readfsqword(0x28u);
  result = v8 ^ v11;
  if ( v8 != v11 )
LABEL_11:
    __assert_fail("valuetypes[primary] == TYPE_STR", "conf.c", 0x1D7u, "conf_del_str_str");
  return result;
}

signed int *__fastcall sub_1FAC0(_QWORD *a1, int a2, __int64 a3)
{
  char **v3; // r13
  __int64 v4; // rbx

  v3 = (char **)a3;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x1E5u, "conf_set_filename");
  if ( dword_DFAA0[a2] != 4 )
    __assert_fail("valuetypes[primary] == TYPE_FILENAME", "conf.c", 0x1E6u, "conf_set_filename");
  *(_DWORD *)v4 = a2;
  *(_QWORD *)(v4 + 16) = sub_B4E10(v3);
  return sub_1ECB0(a1, v4);
}

signed int *__fastcall sub_1FB70(_QWORD *a1, int a2, __int64 a3)
{
  char **v3; // r13
  __int64 v4; // rbx

  v3 = (char **)a3;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  if ( dword_DFDE0[a2] )
    __assert_fail("subkeytypes[primary] == TYPE_NONE", "conf.c", 0x1F0u, "conf_set_fontspec");
  if ( dword_DFAA0[a2] != 5 )
    __assert_fail("valuetypes[primary] == TYPE_FONT", "conf.c", 0x1F1u, "conf_set_fontspec");
  *(_DWORD *)v4 = a2;
  *(_QWORD *)(v4 + 16) = sub_B5220(v3);
  return sub_1ECB0(a1, v4);
}

unsigned __int64 __fastcall sub_1FC20(__int64 a1, _QWORD *a2)
{
  signed int i; // ebx
  int *v3; // rax
  const char **v4; // r15
  __int64 v5; // rdx
  int v6; // ecx

  for ( i = 0; ; ++i )
  {
    v3 = (int *)sub_9B010((__int64 *)*a2, i);
    v4 = (const char **)v3;
    if ( !v3 )
      break;
    sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), *v3);
    v5 = *(signed int *)v4;
    v6 = dword_DFDE0[v5];
    if ( v6 == 2 )
    {
      sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), *((_DWORD *)v4 + 2));
      v5 = *(signed int *)v4;
    }
    else if ( v6 == 3 )
    {
      sub_2EF90(*(__int64 (__fastcall ***)(_QWORD, const char *, size_t))(a1 + 8), v4[1]);
      v5 = *(signed int *)v4;
    }
    switch ( v5 )
    {
      case 0LL:
      case 9LL:
      case 10LL:
      case 14LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 20LL:
      case 21LL:
      case 28LL:
      case 50LL:
      case 52LL:
      case 53LL:
      case 54LL:
      case 55LL:
      case 56LL:
      case 58LL:
      case 61LL:
      case 67LL:
      case 103LL:
      case 137LL:
      case 138LL:
      case 160LL:
      case 161LL:
      case 162LL:
      case 164LL:
      case 169LL:
      case 174LL:
      case 192LL:
      case 202LL:
      case 262LL:
      case 263LL:
      case 382LL:
      case 400LL:
        sub_2EF90(*(__int64 (__fastcall ***)(_QWORD, const char *, size_t))(a1 + 8), v4[2]);
        break;
      case 1LL:
      case 2LL:
      case 3LL:
      case 4LL:
      case 6LL:
      case 11LL:
      case 13LL:
      case 15LL:
      case 19LL:
      case 24LL:
      case 25LL:
      case 27LL:
      case 32LL:
      case 34LL:
      case 44LL:
      case 45LL:
      case 51LL:
      case 62LL:
      case 63LL:
      case 64LL:
      case 65LL:
      case 66LL:
      case 68LL:
      case 73LL:
      case 83LL:
      case 92LL:
      case 93LL:
      case 104LL:
      case 108LL:
      case 110LL:
      case 111LL:
      case 113LL:
      case 114LL:
      case 115LL:
      case 119LL:
      case 123LL:
      case 124LL:
      case 126LL:
      case 128LL:
      case 129LL:
      case 136LL:
      case 146LL:
      case 147LL:
      case 148LL:
      case 155LL:
      case 157LL:
      case 158LL:
      case 159LL:
      case 163LL:
      case 170LL:
      case 175LL:
      case 176LL:
      case 177LL:
      case 178LL:
      case 179LL:
      case 180LL:
      case 181LL:
      case 182LL:
      case 183LL:
      case 184LL:
      case 185LL:
      case 186LL:
      case 187LL:
      case 200LL:
      case 232LL:
      case 233LL:
      case 240LL:
      case 253LL:
      case 355LL:
      case 363LL:
        sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), *((_DWORD *)v4 + 4));
        break;
      case 5LL:
      case 7LL:
      case 8LL:
      case 12LL:
      case 22LL:
      case 23LL:
      case 26LL:
      case 29LL:
      case 30LL:
      case 31LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 38LL:
      case 39LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
      case 47LL:
      case 48LL:
      case 49LL:
      case 57LL:
      case 59LL:
      case 60LL:
      case 69LL:
      case 70LL:
      case 71LL:
      case 72LL:
      case 74LL:
      case 75LL:
      case 76LL:
      case 77LL:
      case 78LL:
      case 79LL:
      case 80LL:
      case 81LL:
      case 82LL:
      case 84LL:
      case 85LL:
      case 86LL:
      case 87LL:
      case 88LL:
      case 89LL:
      case 90LL:
      case 91LL:
      case 94LL:
      case 95LL:
      case 96LL:
      case 97LL:
      case 98LL:
      case 99LL:
      case 100LL:
      case 101LL:
      case 102LL:
      case 105LL:
      case 106LL:
      case 107LL:
      case 109LL:
      case 112LL:
      case 117LL:
      case 118LL:
      case 120LL:
      case 121LL:
      case 122LL:
      case 130LL:
      case 131LL:
      case 132LL:
      case 133LL:
      case 134LL:
      case 135LL:
      case 139LL:
      case 140LL:
      case 141LL:
      case 142LL:
      case 143LL:
      case 144LL:
      case 145LL:
      case 149LL:
      case 150LL:
      case 151LL:
      case 152LL:
      case 153LL:
      case 154LL:
      case 156LL:
      case 165LL:
      case 166LL:
      case 167LL:
      case 168LL:
      case 172LL:
      case 173LL:
      case 188LL:
      case 189LL:
      case 190LL:
      case 191LL:
      case 193LL:
      case 194LL:
      case 195LL:
      case 196LL:
      case 201LL:
        sub_2ED00(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), *((_BYTE *)v4 + 16));
        break;
      case 33LL:
      case 46LL:
      case 116LL:
      case 127LL:
      case 171LL:
        sub_B4E80(a1, (const char **)v4[2]);
        break;
      case 125LL:
      case 197LL:
      case 198LL:
      case 199LL:
        sub_B5250(a1, (const char **)v4[2]);
        break;
      default:
        continue;
    }
  }
  return sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), -1);
}

signed __int64 __fastcall sub_1FD50(_QWORD *a1, __int64 a2)
{
  unsigned int v2; // ebx
  signed int *v3; // r15
  __int64 v4; // rax
  int v5; // edx
  char *v6; // rax
  char *v8; // rax

  while ( 1 )
  {
    v2 = sub_2F150(*(_QWORD *)(a2 + 32));
    if ( *(_DWORD *)(*(_QWORD *)(a2 + 32) + 24LL) )
      return 0LL;
    if ( v2 == -1 )
      return 1LL;
    if ( v2 > 0xCA )
      return 0LL;
    v3 = (signed int *)sub_2F450(1uLL, 0x18uLL, 0LL);
    v4 = (signed int)v2;
    *v3 = v2;
    v5 = dword_DFDE0[v2];
    if ( v5 == 2 )
    {
      v3[2] = sub_2F150(*(_QWORD *)(a2 + 32));
      v4 = *v3;
    }
    else if ( v5 == 3 )
    {
      v6 = sub_2F240(*(_QWORD *)(a2 + 32));
      *((_QWORD *)v3 + 1) = sub_BC120(v6);
      v4 = *v3;
    }
    switch ( v4 )
    {
      case 0LL:
      case 9LL:
      case 10LL:
      case 14LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 20LL:
      case 21LL:
      case 28LL:
      case 50LL:
      case 52LL:
      case 53LL:
      case 54LL:
      case 55LL:
      case 56LL:
      case 58LL:
      case 61LL:
      case 67LL:
      case 103LL:
      case 137LL:
      case 138LL:
      case 160LL:
      case 161LL:
      case 162LL:
      case 164LL:
      case 169LL:
      case 174LL:
      case 192LL:
      case 202LL:
      case 262LL:
      case 263LL:
      case 382LL:
      case 400LL:
        v8 = sub_2F240(*(_QWORD *)(a2 + 32));
        *((_QWORD *)v3 + 2) = sub_BC120(v8);
        break;
      case 1LL:
      case 2LL:
      case 3LL:
      case 4LL:
      case 6LL:
      case 11LL:
      case 13LL:
      case 15LL:
      case 19LL:
      case 24LL:
      case 25LL:
      case 27LL:
      case 32LL:
      case 34LL:
      case 44LL:
      case 45LL:
      case 51LL:
      case 62LL:
      case 63LL:
      case 64LL:
      case 65LL:
      case 66LL:
      case 68LL:
      case 73LL:
      case 83LL:
      case 92LL:
      case 93LL:
      case 104LL:
      case 108LL:
      case 110LL:
      case 111LL:
      case 113LL:
      case 114LL:
      case 115LL:
      case 119LL:
      case 123LL:
      case 124LL:
      case 126LL:
      case 128LL:
      case 129LL:
      case 136LL:
      case 146LL:
      case 147LL:
      case 148LL:
      case 155LL:
      case 157LL:
      case 158LL:
      case 159LL:
      case 163LL:
      case 170LL:
      case 175LL:
      case 176LL:
      case 177LL:
      case 178LL:
      case 179LL:
      case 180LL:
      case 181LL:
      case 182LL:
      case 183LL:
      case 184LL:
      case 185LL:
      case 186LL:
      case 187LL:
      case 200LL:
      case 232LL:
      case 233LL:
      case 240LL:
      case 253LL:
      case 355LL:
      case 363LL:
        v3[4] = sub_2F150(*(_QWORD *)(a2 + 32));
        break;
      case 5LL:
      case 7LL:
      case 8LL:
      case 12LL:
      case 22LL:
      case 23LL:
      case 26LL:
      case 29LL:
      case 30LL:
      case 31LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 38LL:
      case 39LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
      case 47LL:
      case 48LL:
      case 49LL:
      case 57LL:
      case 59LL:
      case 60LL:
      case 69LL:
      case 70LL:
      case 71LL:
      case 72LL:
      case 74LL:
      case 75LL:
      case 76LL:
      case 77LL:
      case 78LL:
      case 79LL:
      case 80LL:
      case 81LL:
      case 82LL:
      case 84LL:
      case 85LL:
      case 86LL:
      case 87LL:
      case 88LL:
      case 89LL:
      case 90LL:
      case 91LL:
      case 94LL:
      case 95LL:
      case 96LL:
      case 97LL:
      case 98LL:
      case 99LL:
      case 100LL:
      case 101LL:
      case 102LL:
      case 105LL:
      case 106LL:
      case 107LL:
      case 109LL:
      case 112LL:
      case 117LL:
      case 118LL:
      case 120LL:
      case 121LL:
      case 122LL:
      case 130LL:
      case 131LL:
      case 132LL:
      case 133LL:
      case 134LL:
      case 135LL:
      case 139LL:
      case 140LL:
      case 141LL:
      case 142LL:
      case 143LL:
      case 144LL:
      case 145LL:
      case 149LL:
      case 150LL:
      case 151LL:
      case 152LL:
      case 153LL:
      case 154LL:
      case 156LL:
      case 165LL:
      case 166LL:
      case 167LL:
      case 168LL:
      case 172LL:
      case 173LL:
      case 188LL:
      case 189LL:
      case 190LL:
      case 191LL:
      case 193LL:
      case 194LL:
      case 195LL:
      case 196LL:
      case 201LL:
        *((_BYTE *)v3 + 16) = sub_2F0C0(*(_QWORD *)(a2 + 32));
        break;
      case 33LL:
      case 46LL:
      case 116LL:
      case 127LL:
      case 171LL:
        *((_QWORD *)v3 + 2) = sub_B4E90(a2);
        if ( *(_DWORD *)(*(_QWORD *)(a2 + 32) + 24LL) )
          goto LABEL_12;
        goto LABEL_10;
      case 125LL:
      case 197LL:
      case 198LL:
      case 199LL:
        *((_QWORD *)v3 + 2) = sub_B5260(a2);
        break;
      default:
        break;
    }
    if ( *(_DWORD *)(*(_QWORD *)(a2 + 32) + 24LL) )
    {
LABEL_12:
      sub_1EB00(v3);
      return 0LL;
    }
LABEL_10:
    sub_1ECB0(a1, (__int64)v3);
  }
}

void __fastcall sub_1FF00(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  char v4; // bp
  int v5; // ebx
  __int64 *v6; // r13
  char v7; // al
  bool v8; // al

  v4 = 0;
  v5 = *(_DWORD *)(a1 + 32);
  v6 = a3;
  if ( v5 & 0x40000000 )
  {
    v5 &= 0xBFFFFFFF;
    v4 = 1;
  }
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v8 = sub_9EF50(a1, a2);
      sub_1F6D0(v6, v5, v8 ^ v4);
    }
  }
  else
  {
    v7 = sub_1EF00(a3, v5);
    sub_9EED0(a1, a2, (unsigned __int8)(v7 ^ v4));
  }
}

unsigned __int64 __fastcall sub_1FF90(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebp
  int v6; // er14
  const char *v8; // rax
  char *v9; // rbx
  double v10; // xmm0_8
  char *v11; // rax
  char *v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // r8
  int v15; // eax
  __int64 v16; // [rsp+0h] [rbp-88h]
  unsigned __int64 v17; // [rsp+58h] [rbp-30h]

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 72);
  v6 = *(_DWORD *)(a1 + 32);
  v17 = __readfsqword(0x28u);
  if ( v5 <= 0 )
  {
    if ( v5 )
    {
      if ( a4 )
      {
        if ( a4 == 2 )
        {
          v8 = (const char *)sub_9F0C0(a1, a2);
          v9 = (char *)v8;
          if ( v5 == -1 )
          {
            v15 = strtol(v8, 0LL, 10);
            sub_1F760(v4, v6, v15);
          }
          else
          {
            v10 = strtod(v8, 0LL);
            sub_1F760(v4, v6, (signed int)(v10 * (double)-v5));
          }
          sub_2F4D0(v9);
        }
      }
      else
      {
        v13 = sub_1EFD0(a3, v6);
        if ( v5 == -1 )
          __sprintf_chk(&v16, 1LL, 80LL, "%d", v13);
        else
          __sprintf_chk(&v16, 1LL, 80LL, "%g", v14);
        sub_9EFD0(a1, a2, (char *)&v16);
      }
    }
  }
  else if ( a4 )
  {
    if ( a4 == 2 )
    {
      v12 = (char *)sub_9F0C0(a1, a2);
      sub_1F890(v4, v6, v12);
      sub_2F4D0(v12);
    }
  }
  else
  {
    v11 = (char *)sub_1F170(a3, v6);
    sub_9EFD0(a1, a2, v11);
  }
  return __readfsqword(0x28u) ^ v17;
}

void __fastcall sub_20150(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // rbp
  int v5; // er12
  char **v6; // rax
  void **v7; // rbx

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 32);
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v7 = (void **)sub_9FF20(a1, a2);
      sub_1FAC0(v4, v5, (__int64)v7);
      sub_B4E60(v7);
    }
  }
  else
  {
    v6 = (char **)sub_1F530(a3, v5);
    sub_9FE60(a1, a2, v6);
  }
}

void __fastcall sub_201D0(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // rbp
  int v5; // er12
  char **v6; // rax
  void **v7; // rbx

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 32);
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v7 = (void **)sub_A0080(a1, a2);
      sub_1FB70(v4, v5, (__int64)v7);
      sub_B5230(v7);
    }
  }
  else
  {
    v6 = (char **)sub_1F600(a3, v5);
    sub_9FFC0(a1, a2, v6);
  }
}

void __fastcall sub_20250(__int64 a1)
{
  sub_40A70(a1 + 56, 0LL);
  sub_2F4D0(*(void **)(a1 + 88));
  sub_2F4D0((void *)a1);
}

void __fastcall sub_20280(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  int v4; // er15
  __int64 *v5; // r14
  char **v6; // rbp
  int v7; // ST04_4
  char **v8; // rbx
  int v9; // er9
  unsigned int v10; // ecx
  char **v11; // rax
  const char *v12; // rdx
  char **v13; // ST08_8
  int v14; // ST04_4
  unsigned int v15; // eax
  unsigned int v16; // edx
  int v17; // edx
  signed int v18; // eax
  int v19; // [rsp+0h] [rbp-48h]

  v4 = a4;
  v5 = a3;
  if ( !a4 )
  {
    v6 = &off_31E1C0;
    v7 = *(_DWORD *)(a1 + 32);
    v8 = &off_31E1C0;
    v19 = sub_1EFD0(a3, 66);
    nullsub_37();
    sub_9F1A0(a1, a2);
    v9 = v7;
    v10 = 0;
    v11 = &off_31E1C0 + 8;
    if ( _bittest(&v9, 0) )
      goto LABEL_7;
    while ( 1 )
    {
      v8 += 2;
      if ( v8 == v11 )
        break;
      while ( 1 )
      {
        v10 = *((_DWORD *)v8 + 2);
        if ( !_bittest(&v9, v10) )
          break;
LABEL_7:
        v12 = *v8;
        v13 = v11;
        v14 = v9;
        v8 += 2;
        sub_9F340(a1, (__int64)a2, v12, v10);
        v11 = v13;
        v9 = v14;
        if ( v8 == v13 )
          goto LABEL_8;
      }
    }
LABEL_8:
    v15 = 0;
    v16 = 0;
    if ( !_bittest(&v9, 0) )
      goto LABEL_11;
    while ( v19 != v15 )
    {
      ++v16;
LABEL_11:
      v6 += 2;
      if ( v8 == v6 )
      {
LABEL_14:
        sub_9FB80(a1, a2, 0);
        goto LABEL_15;
      }
      while ( 1 )
      {
        v15 = *((_DWORD *)v6 + 2);
        if ( _bittest(&v9, v15) )
          break;
        v6 += 2;
        if ( v8 == v6 )
          goto LABEL_14;
      }
    }
    sub_9FB80(a1, a2, v16);
    v4 = v19;
LABEL_15:
    nullsub_38();
    v17 = v4;
    goto LABEL_16;
  }
  if ( a4 == 3 )
  {
    v18 = sub_9F660(a1, a2);
    v17 = 0;
    if ( v18 >= 0 )
      v17 = sub_9F530(a1, a2, v18);
LABEL_16:
    sub_1F760(v5, 66, v17);
  }
}

void __fastcall sub_203F0(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  int v4; // er13
  int v5; // er14
  char **v6; // r15
  char **v7; // rbx
  char **v8; // r9
  unsigned int i; // ecx
  const char *v10; // rdx
  char **v11; // ST10_8
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // edx
  signed int v15; // eax
  __int64 *v16; // [rsp+8h] [rbp-50h]
  int v17; // [rsp+1Ch] [rbp-3Ch]

  v4 = a4;
  v16 = a3;
  if ( a4 )
  {
    if ( a4 == 3 )
    {
      v15 = sub_9F660(a1, a2);
      v14 = 0;
      if ( v15 >= 0 )
        v14 = sub_9F530(a1, a2, v15);
      goto LABEL_17;
    }
    return;
  }
  v5 = *(_DWORD *)(a1 + 32);
  v6 = &off_31E160;
  v17 = sub_1EFD0(a3, 65);
  nullsub_37();
  v7 = &off_31E160;
  sub_9F1A0(a1, a2);
  v8 = &off_31E160 + 10;
  for ( i = 0; !_bittest(&v5, i); i = *((_DWORD *)v7 + 2) )
  {
    v7 += 2;
    if ( v7 == v8 )
      goto LABEL_9;
LABEL_6:
    ;
  }
  v10 = *v7;
  v11 = v8;
  v7 += 2;
  sub_9F340(a1, (__int64)a2, v10, i);
  v8 = v11;
  if ( v7 != v11 )
    goto LABEL_6;
LABEL_9:
  v12 = 0;
  v13 = 0;
  while ( 1 )
  {
    if ( !_bittest(&v5, v12) )
      goto LABEL_14;
    if ( v17 == v12 )
      break;
    ++v13;
LABEL_14:
    v6 += 2;
    if ( v7 == v6 )
    {
      sub_9FB80(a1, a2, 0);
      goto LABEL_16;
    }
    v12 = *((_DWORD *)v6 + 2);
  }
  sub_9FB80(a1, a2, v13);
  v4 = v17;
LABEL_16:
  nullsub_38();
  v14 = v4;
LABEL_17:
  sub_1F760(v16, 65, v14);
}

void __fastcall sub_20540(__int64 a1, __int64 **a2, __int64 *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 *v12; // r12
  __int64 **v13; // rbp
  __int64 v14; // rbx
  int v15; // er14
  int v16; // er13
  int v17; // er14
  bool v18; // cf
  bool v19; // zf
  __int64 v20; // rax
  const char *v21; // rdi
  _BYTE *v22; // rsi
  signed __int64 v23; // rcx
  char *v24; // rbx
  signed __int64 v25; // rax
  bool v26; // cf
  bool v27; // zf
  const char *v28; // rdi
  signed __int64 v29; // rcx
  char *v30; // rsi
  char v31; // al
  bool v32; // cf
  bool v33; // zf
  const char *v34; // rdi
  signed __int64 v35; // rcx
  char *v36; // rsi
  bool v37; // cf
  bool v38; // zf
  char *v39; // rax
  double v40; // xmm4_8
  double v41; // xmm5_8
  const char *v42; // rdi
  signed __int64 v43; // rcx
  char *v44; // rsi
  char v45; // dl
  bool v46; // cf
  bool v47; // zf
  const char *v48; // rdi
  signed __int64 v49; // rcx
  char *v50; // rsi
  char v51; // dl
  bool v52; // cf
  bool v53; // zf
  const char *v54; // rdi
  signed __int64 v55; // rcx
  char *v56; // rsi
  char *v57; // r12

  v12 = a3;
  v13 = a2;
  v14 = a1;
  v15 = *(_DWORD *)(a1 + 32);
  v16 = *(_DWORD *)(a1 + 72);
  if ( a4 )
  {
    if ( (unsigned int)(a4 - 2) > 1 )
      return;
    v20 = sub_9F0C0(a1, a2);
    v21 = "No action";
    v22 = (_BYTE *)v20;
    v23 = 10LL;
    v24 = (char *)v20;
    do
    {
      if ( !v23 )
        break;
      v18 = *v22 < (const unsigned __int8)*v21;
      v19 = *v22++ == *v21++;
      --v23;
    }
    while ( v19 );
    v25 = (char)((!v18 && !v19) - v18);
    v26 = 0;
    v27 = (_DWORD)v25 == 0;
    if ( (_DWORD)v25 )
    {
      v28 = "PRIMARY";
      v29 = 8LL;
      v30 = v24;
      do
      {
        if ( !v29 )
          break;
        v26 = (unsigned __int8)*v30 < *v28;
        v27 = *v30++ == *v28++;
        --v29;
      }
      while ( v27 );
      v31 = (!v26 && !v27) - v26;
      v32 = 0;
      v33 = v31 == 0;
      if ( v31 )
      {
        v34 = "CLIPBOARD";
        v35 = 10LL;
        v36 = v24;
        do
        {
          if ( !v35 )
            break;
          v32 = (unsigned __int8)*v36 < *v34;
          v33 = *v36++ == *v34++;
          --v35;
        }
        while ( v33 );
        if ( (!v32 && !v33) != v32 )
        {
          sub_1F760(v12, v15, 3);
          v24 += *v24 == 61;
          sub_1F890(v12, v16, v24);
LABEL_23:
          sub_2F4D0(v24);
          return;
        }
        v25 = 2LL;
      }
      else
      {
        v25 = 1LL;
      }
    }
    sub_1F760(v12, v15, (int)(&off_31DFE0)[2 * v25 + 1]);
    sub_1F890(v12, v16, &locale);
    goto LABEL_23;
  }
  v17 = sub_1EFD0(a3, v15);
  nullsub_37();
  sub_9F1A0(a1, a2);
  sub_9F520(a1, (__int64)a2, "No action");
  sub_9F520(a1, (__int64)a2, "PRIMARY");
  sub_9F520(a1, (__int64)a2, "CLIPBOARD");
  if ( v17 == 3 )
  {
    v39 = (char *)sub_1F170(v12, v16);
    v42 = "No action";
    v43 = 10LL;
    v44 = v39;
    do
    {
      if ( !v43 )
        break;
      v37 = (unsigned __int8)*v44 < *v42;
      v38 = *v44++ == *v42++;
      --v43;
    }
    while ( v38 );
    v45 = (!v37 && !v38) - v37;
    v46 = 0;
    v47 = v45 == 0;
    if ( !v45 )
      goto LABEL_46;
    v48 = "PRIMARY";
    v49 = 8LL;
    v50 = v39;
    do
    {
      if ( !v49 )
        break;
      v46 = (unsigned __int8)*v50 < *v48;
      v47 = *v50++ == *v48++;
      --v49;
    }
    while ( v47 );
    v51 = (!v46 && !v47) - v46;
    v52 = 0;
    v53 = v51 == 0;
    if ( !v51 )
      goto LABEL_46;
    v54 = "CLIPBOARD";
    v55 = 10LL;
    v56 = v39;
    do
    {
      if ( !v55 )
        break;
      v52 = (unsigned __int8)*v56 < *v54;
      v53 = *v56++ == *v54++;
      --v55;
    }
    while ( v53 );
    if ( (!v52 && !v53) != v52 && *v39 != 61 )
    {
      sub_9EFD0(v14, v13, v39);
    }
    else
    {
LABEL_46:
      v57 = sub_BC160("=", a5, a6, a7, a8, v40, v41, a11, a12, v39, 0LL);
      sub_9EFD0(v14, v13, v57);
      sub_2F4D0(v57);
    }
  }
  else
  {
    sub_9EFD0(a1, a2, "No action");
    if ( v17 )
    {
      if ( v17 == 1 )
      {
        sub_9EFD0(a1, a2, "PRIMARY");
      }
      else if ( v17 == 2 )
      {
        sub_9EFD0(a1, a2, "CLIPBOARD");
      }
    }
    else
    {
      sub_9EFD0(a1, a2, "No action");
    }
  }
  nullsub_38();
}

void __fastcall sub_20810(__int64 a1, __int64 **a2, __int64 *a3, unsigned int a4)
{
  __int64 *v4; // r14
  __int64 **v5; // r13
  unsigned int v6; // er12
  int v7; // er15
  __int64 v8; // rbp
  bool v9; // zf
  signed int v10; // eax
  int v11; // er12
  int v12; // eax
  _DWORD *v13; // rsi
  __int64 v14; // rcx
  signed __int64 v15; // rax
  signed __int64 v16; // rcx
  int v17; // eax
  void **v18; // rbx
  void **v19; // rax
  void **v20; // r12
  signed __int64 v21; // r14
  void **v22; // r12
  unsigned int v23; // edx
  signed int v24; // eax
  signed int v25; // [rsp+Ch] [rbp-3Ch]

  v4 = a3;
  v5 = a2;
  v6 = a4;
  v7 = sub_1EFD0(a3, 2);
  v8 = *(_QWORD *)(a1 + 32);
  if ( v6 )
  {
    if ( *(_BYTE *)(v8 + 32) )
      return;
    if ( v6 == 2 )
    {
      if ( *(_QWORD *)(v8 + 16) != a1 )
        return;
      v17 = sub_9EDD0(a1, a2);
      if ( v17 < 0 || *(_DWORD *)(a1 + 64) <= v17 )
        __assert_fail("button >= 0 && button < ctrl->radio.nbuttons", "config.c", 0x169u, "config_protocols_handler");
      v11 = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 8LL * v17);
      if ( v11 == -1 )
      {
        v24 = sub_9F660(*(_QWORD *)(v8 + 24), a2);
        if ( v24 < 0 )
          return;
        v11 = sub_9F530(*(_QWORD *)(v8 + 24), a2, v24);
      }
    }
    else
    {
      if ( v6 != 3 )
        return;
      if ( *(_QWORD *)(v8 + 24) != a1 )
        return;
      v10 = sub_9F660(a1, a2);
      if ( v10 < 0 )
        return;
      v11 = sub_9F530(a1, a2, v10);
      sub_9ED20(*(_QWORD *)(v8 + 16), a2, *(_DWORD *)(*(_QWORD *)(v8 + 16) + 64LL) - 1);
    }
    if ( v11 != v7 )
    {
      sub_1F760(v4, 2, v11);
      v18 = sub_3CFD0(v7);
      v19 = sub_3CFD0(v11);
      v20 = v19;
      if ( !v18 )
        __assert_fail("cvt", "config.c", 0x18Eu, "config_protocols_handler");
      if ( !v19 )
        __assert_fail("nvt", "config.c", 0x18Fu, "config_protocols_handler");
      if ( *((_DWORD *)v18 + 39) == (unsigned int)sub_1EFD0(v4, 1) )
        sub_1F760(v4, 1, *((_DWORD *)v20 + 39));
      sub_A0280(*(_QWORD *)v8, (__int64)a2);
      sub_A0280(*(_QWORD *)(v8 + 8), (__int64)a2);
    }
  }
  else
  {
    v9 = *(_QWORD *)(v8 + 16) == a1;
    *(_BYTE *)(v8 + 32) = 1;
    if ( v9 )
    {
      v12 = *(_DWORD *)(a1 + 64);
      if ( v12 > 0 )
      {
        v13 = *(_DWORD **)(a1 + 88);
        if ( v7 == *v13 || (v6 = v12 - 1, v12 == 1) )
        {
LABEL_20:
          sub_9ED20(a1, v5, v6);
        }
        else
        {
          v14 = (unsigned int)(v12 - 2);
          v15 = 1LL;
          v16 = v14 + 2;
          while ( v15 != v6 + 1LL )
          {
            if ( v13[2 * v15] == v7 )
            {
              v6 = v15;
              goto LABEL_20;
            }
            if ( ++v15 == v16 )
              goto LABEL_20;
          }
        }
      }
    }
    else if ( *(_QWORD *)(v8 + 24) == a1 )
    {
      nullsub_37();
      sub_9F1A0(a1, a2);
      v21 = 2LL;
      v25 = -1;
      do
      {
        v22 = (&off_323400)[v21];
        if ( !v22 )
          break;
        sub_9F340(a1, (__int64)a2, (const char *)v22[18], *((_DWORD *)v22 + 38));
        if ( *((_DWORD *)v22 + 38) == v7 )
          v25 = v21 - qword_BFEE8;
        ++v21;
      }
      while ( v21 != 7 );
      v23 = v25;
      if ( v25 <= 0 )
        v23 = 0;
      sub_9FB80(a1, a2, v23);
      nullsub_38();
    }
    *(_BYTE *)(v8 + 32) = 0;
  }
}

__int64 __fastcall sub_20B70(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 v4; // r15
  __int64 *v5; // rbp
  __int64 *v6; // r12
  __int64 result; // rax
  unsigned __int64 v8; // rt1
  signed int v9; // eax
  __int64 v10; // rdi
  signed int v11; // er13
  unsigned int v12; // eax
  char v13; // r14
  void *v14; // r15
  char *v15; // r14
  __int64 v16; // rdi
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // rax
  _BYTE *v20; // rbp
  int v21; // edx
  char *i; // rax
  char v23; // cl
  const char *v24; // rdx
  signed __int64 v25; // rax
  char *v26; // r13
  char *v27; // [rsp+8h] [rbp-60h]
  char *v28; // [rsp+18h] [rbp-50h]
  __int16 v29; // [rsp+25h] [rbp-43h]
  char v30; // [rsp+27h] [rbp-41h]
  unsigned __int64 v31; // [rsp+28h] [rbp-40h]

  v4 = a1;
  v5 = a3;
  v6 = *(__int64 **)(a1 + 32);
  v31 = __readfsqword(0x28u);
  switch ( a4 )
  {
    case 0:
      if ( v6[3] == a1 )
      {
        nullsub_37();
        sub_9F1A0(a1, a2);
        for ( i = (char *)sub_1F330(v5, 54, 0LL, &v28); i; i = (char *)sub_1F330(v5, 54, v28, &v28) )
        {
          v23 = *i;
          v24 = "(auto)";
          if ( *i != 65 )
          {
            v24 = "(don't send)";
            v25 = (signed __int64)(i + 1);
            if ( v23 != 78 )
              v24 = (const char *)v25;
          }
          v26 = sub_BC360((__int64)"%s\t%s", v28, v24);
          sub_9F520(a1, (__int64)a2, v26);
          sub_2F4D0(v26);
        }
        nullsub_38();
      }
      else if ( *v6 == a1 )
      {
        sub_9ED20(a1, a2, 0);
      }
      goto LABEL_5;
    case 3:
      v16 = v6[3];
      if ( v16 != v4 )
        goto LABEL_5;
      v17 = sub_9F660(v16, a2);
      if ( v17 < 0 )
        goto LABEL_5;
      v18 = sub_1F430(v5, 54, v17);
      v19 = sub_1F2F0(v5, 54, v18);
      v20 = (_BYTE *)v19;
      if ( !v19 )
        __assert_fail("val != NULL", "config.c", 0x45Du, "ttymodes_handler");
      sub_9EFD0(v6[1], a2, (char *)(v19 + 1));
      v21 = 0;
      if ( *v20 != 65 )
        v21 = (*v20 != 78) + 1;
LABEL_21:
      sub_9ED20(*v6, a2, v21);
      goto LABEL_5;
    case 2:
      if ( v6[1] != a1 )
        goto LABEL_5;
      v21 = 2;
      goto LABEL_21;
  }
  if ( a4 == 1 && v6[2] == a1 )
  {
    v9 = sub_9F660(v6[3], a2);
    v10 = *v6;
    v11 = v9;
    v30 = 86;
    v29 = 20033;
    v12 = sub_9EDD0(v10, a2);
    if ( v12 > 2 )
LABEL_32:
      __assert_fail("button >= 0 && button < lenof(types)", "config.c", 0x473u, "ttymodes_handler");
    v13 = *((_BYTE *)&v29 + (signed int)v12);
    if ( v11 < 0 )
    {
      sub_A0250();
    }
    else
    {
      v27 = (char *)sub_1F430(v5, 54, v11);
      if ( v13 == 86 )
        v14 = (void *)sub_9F0C0(v6[1], a2);
      else
        v14 = sub_BC120(&locale);
      v15 = sub_BC360((__int64)"%c%s", (unsigned int)v13, v14);
      sub_2F4D0(v14);
      sub_1F940(v5, 54, v27, v15);
      sub_2F4D0(v15);
      sub_A0280(v6[3], (__int64)a2);
      sub_9FB80(v6[3], a2, v11);
    }
  }
LABEL_5:
  v8 = __readfsqword(0x28u);
  result = v8 ^ v31;
  if ( v8 != v31 )
    goto LABEL_32;
  return result;
}

unsigned __int64 __fastcall sub_20E90(__int64 a1, __int64 a2, __int64 *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // r14
  __int64 *v13; // r12
  __int64 **v14; // rbx
  _QWORD *v15; // r15
  int v17; // eax
  char *v18; // rax
  __int64 v19; // rbp
  char *v20; // r14
  char *v21; // rax
  char *v22; // r13
  int v23; // edx
  char *v24; // rdi
  bool v25; // cf
  bool v26; // zf
  char *v27; // rsi
  signed __int64 v28; // rcx
  char *v29; // r14
  int v30; // esi
  char *v31; // rax
  __int64 v32; // rax
  bool v33; // cf
  bool i; // zf
  char *v35; // rax
  char *v36; // rbp
  char *v37; // rax
  signed __int64 v38; // rcx
  _BYTE *v39; // rsi
  char *v40; // rdi
  char *v41; // r13
  int v42; // eax
  int v43; // eax
  __int64 v44; // rdi
  _BYTE *v45; // rbp
  char *v46; // r14
  double v47; // xmm4_8
  double v48; // xmm5_8
  char *v49; // r13
  char *v50; // rax
  char v51; // [rsp+8h] [rbp-50h]
  char *v52; // [rsp+8h] [rbp-50h]
  char *v53; // [rsp+10h] [rbp-48h]
  unsigned __int64 v54; // [rsp+18h] [rbp-40h]

  v12 = a1;
  v13 = a3;
  v14 = (__int64 **)a2;
  v15 = *(_QWORD **)(a1 + 32);
  v54 = __readfsqword(0x28u);
  if ( !a4 )
  {
    if ( v15[2] == a1 )
    {
      nullsub_37();
      sub_9F1A0(a1, (__int64 **)a2);
      v32 = sub_1F330(v13, 174, 0LL, &v53);
      v33 = 0;
      for ( i = v32 == 0; v32; i = v32 == 0 )
      {
        v38 = 2LL;
        v39 = (_BYTE *)v32;
        v40 = "D";
        do
        {
          if ( !v38 )
            break;
          v33 = *v39 < (unsigned __int8)*v40;
          i = *v39++ == *v40++;
          --v38;
        }
        while ( i );
        if ( (!v33 && !i) == v33 )
        {
          v35 = sub_BC360((__int64)&off_E028C);
          v36 = v35;
          v37 = strchr(v35, 76);
          if ( v37 )
            *v37 = 68;
        }
        else
        {
          v36 = sub_BC360((__int64)"%s\t%s", v53, v32);
        }
        sub_9F520(v12, (__int64)v14, v36);
        sub_2F4D0(v36);
        v32 = sub_1F330(v13, 174, v53, &v53);
        v33 = 0;
      }
      nullsub_38();
    }
    else if ( v15[5] == a1 || v15[6] == a1 )
    {
      sub_9ED20(a1, (__int64 **)a2, 0);
    }
    return __readfsqword(0x28u) ^ v54;
  }
  if ( a4 != 1 )
    return __readfsqword(0x28u) ^ v54;
  if ( *v15 == a1 )
  {
    v41 = "4";
    v42 = sub_9EDD0(v15[6], (__int64 **)a2);
    if ( v42 != 1 )
    {
      v41 = &locale;
      if ( v42 == 2 )
        v41 = "6";
    }
    v43 = sub_9EDD0(v15[5], (__int64 **)a2);
    v44 = v15[3];
    if ( v43 )
    {
      if ( v43 != 1 )
      {
        v45 = (_BYTE *)sub_9F0C0(v44, (__int64 **)a2);
        if ( *v45 )
        {
          v46 = sub_BC120("D");
          v52 = "L";
LABEL_39:
          v49 = sub_BC160(v41, a5, a6, a7, a8, v47, v48, a11, a12, v52, v45, 0LL);
          sub_2F4D0(v45);
          if ( sub_1F240(v13, 174, (__int64)v49) )
            sub_A1E90(a2, "Specified forwarding already exists");
          else
            sub_1F940(v13, 174, v49, v46);
          sub_2F4D0(v49);
          sub_2F4D0(v46);
          sub_A0280(v15[2], a2);
          return __readfsqword(0x28u) ^ v54;
        }
        goto LABEL_48;
      }
      v52 = "R";
    }
    else
    {
      v52 = "L";
    }
    v45 = (_BYTE *)sub_9F0C0(v44, (__int64 **)a2);
    if ( *v45 )
    {
      v50 = (char *)sub_9F0C0(v15[4], (__int64 **)a2);
      v46 = v50;
      if ( !*v50 || !sub_BC080(v50, 58) )
      {
        sub_A1E90(a2, "You need to specify a destination address\nin the form \"host.name:port\"");
        sub_2F4D0(v45);
        sub_2F4D0(v46);
        return __readfsqword(0x28u) ^ v54;
      }
      goto LABEL_39;
    }
LABEL_48:
    sub_A1E90(a2, "You need to specify a source port number");
    sub_2F4D0(v45);
    return __readfsqword(0x28u) ^ v54;
  }
  if ( v15[1] == a1 )
  {
    v17 = sub_9F660(v15[2], (__int64 **)a2);
    if ( v17 < 0 )
    {
      sub_A0250();
    }
    else
    {
      v18 = (char *)sub_1F430(v13, 174, v17);
      v19 = (__int64)v18;
      if ( v18 )
      {
        v20 = v18 + 1;
        v21 = strchr("A46", *v18);
        if ( v21 )
        {
          v22 = (char *)(v19 + 2);
          v23 = (_DWORD)v21 - (unsigned __int64)"A46";
        }
        else
        {
          v22 = (char *)(v19 + 1);
          v23 = 0;
          v20 = (char *)v19;
        }
        sub_9ED20(v15[6], (__int64 **)a2, v23);
        v51 = *v20;
        v24 = "D";
        v27 = (char *)sub_1F2F0(v13, 174, v19);
        v28 = 2LL;
        v29 = v27;
        do
        {
          if ( !v28 )
            break;
          v25 = (unsigned __int8)*v27 < (unsigned __int8)*v24;
          v26 = *v27++ == *v24++;
          --v28;
        }
        while ( v26 );
        if ( (!v25 && !v26) == v25 )
        {
          v30 = 68;
          v29 = &locale;
        }
        else
        {
          v30 = v51;
        }
        v31 = strchr("LRD", v30);
        sub_9ED20(v15[5], v14, v31 - "LRD");
        sub_9EFD0(v15[3], v14, v22);
        sub_9EFD0(v15[4], v14, v29);
        sub_1F9F0(v13, 174, v19);
      }
    }
    sub_A0280(v15[2], (__int64)v14);
  }
  return __readfsqword(0x28u) ^ v54;
}

unsigned __int64 __fastcall sub_212F0(__int64 a1, __int64 **a2, __int64 *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 *v12; // r13
  __int64 *v13; // r12
  int v15; // eax
  __int64 v16; // rax
  char *v17; // rbx
  char *v18; // r14
  __int64 i; // rax
  char *v20; // r15
  char *v21; // rax
  char *v22; // rbx
  char *v23; // rax
  char *v24; // r14
  double v25; // xmm4_8
  double v26; // xmm5_8
  char *v27; // r13
  char *v28; // [rsp+0h] [rbp-48h]
  unsigned __int64 v29; // [rsp+8h] [rbp-40h]

  v12 = a3;
  v13 = *(__int64 **)(a1 + 32);
  v29 = __readfsqword(0x28u);
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      if ( v13[2] == a1 )
      {
        v21 = (char *)sub_9F0C0(*v13, a2);
        v22 = v21;
        if ( *v21 )
        {
          v23 = (char *)sub_9F0C0(v13[1], a2);
          v24 = v23;
          if ( *v23 )
          {
            sub_1F940(v12, 55, v22, v23);
            v27 = sub_BC160(v22, a5, a6, a7, a8, v25, v26, a11, a12, "\t", v24, 0LL);
            sub_9EFD0(*v13, a2, &locale);
            sub_9EFD0(v13[1], a2, &locale);
            sub_2F4D0(v27);
            sub_2F4D0(v22);
            sub_2F4D0(v24);
            sub_A0280(v13[4], (__int64)a2);
          }
          else
          {
            sub_2F4D0(v22);
            sub_2F4D0(v24);
            sub_A0250();
          }
        }
        else
        {
          sub_2F4D0(v21);
          sub_A0250();
        }
      }
      else if ( v13[3] == a1 )
      {
        v15 = sub_9F660(v13[4], a2);
        if ( v15 < 0 )
        {
          sub_A0250();
        }
        else
        {
          v16 = sub_1F430(v12, 55, v15);
          v17 = (char *)v16;
          if ( v16 )
          {
            v18 = (char *)sub_1F2F0(v12, 55, v16);
            sub_9EFD0(*v13, a2, v17);
            sub_9EFD0(v13[1], a2, v18);
            sub_1F9F0(v12, 55, (__int64)v17);
          }
        }
        sub_A0280(v13[4], (__int64)a2);
      }
    }
  }
  else if ( v13[4] == a1 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    for ( i = sub_1F330(v12, 55, 0LL, &v28); i; i = sub_1F330(v12, 55, v28, &v28) )
    {
      v20 = sub_BC360((__int64)"%s\t%s", v28, i);
      sub_9F520(a1, (__int64)a2, v20);
      sub_2F4D0(v20);
    }
    nullsub_38();
  }
  return __readfsqword(0x28u) ^ v29;
}

unsigned __int64 __fastcall sub_21570(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  _QWORD *v5; // r12
  int v7; // eax
  char *v8; // rax
  __int64 v9; // rbx
  char *i; // rdx
  char *v11; // rax
  char *v12; // rbx
  const char *v13; // [rsp+0h] [rbp-38h]
  unsigned __int64 v14; // [rsp+8h] [rbp-30h]

  v4 = a3;
  v5 = *(_QWORD **)(a1 + 32);
  v14 = __readfsqword(0x28u);
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      if ( *v5 == a1 )
      {
        v11 = (char *)sub_9F0C0(v5[3], a2);
        v12 = v11;
        if ( *v11 )
        {
          if ( (unsigned __int8)sub_31D30(v11) )
          {
            if ( sub_1F240(v4, 192, (__int64)v12) )
              sub_A1E90((__int64)a2, "Specified host key is already listed");
            else
              sub_1F940(v4, 192, v12, &locale);
          }
          else
          {
            sub_A1E90((__int64)a2, "Host key is not in a valid format");
          }
          sub_2F4D0(v12);
          sub_A0280(v5[2], (__int64)a2);
        }
        else
        {
          sub_A1E90((__int64)a2, "You need to specify a host key or fingerprint");
          sub_2F4D0(v12);
        }
      }
      else if ( v5[1] == a1 )
      {
        v7 = sub_9F660(v5[2], a2);
        if ( v7 < 0 )
        {
          sub_A0250();
        }
        else
        {
          v8 = (char *)sub_1F430(v4, 192, v7);
          v9 = (__int64)v8;
          if ( v8 )
          {
            sub_9EFD0(v5[3], a2, v8);
            sub_1F9F0(v4, 192, v9);
          }
        }
        sub_A0280(v5[2], (__int64)a2);
      }
    }
  }
  else if ( v5[2] == a1 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    for ( i = 0LL; sub_1F330(v4, 192, i, &v13); i = (char *)v13 )
      sub_9F520(a1, (__int64)a2, v13);
    nullsub_38();
  }
  return __readfsqword(0x28u) ^ v14;
}

unsigned __int64 __fastcall sub_21770(__int64 a1, __int64 a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  __int64 *v6; // rbx
  int v7; // er14
  int v8; // eax
  int v9; // ebp
  char **v10; // rbx
  const char *v11; // rdx
  int v12; // eax
  int v13; // er13
  signed int v14; // er15
  signed int v15; // er14
  signed int v16; // eax
  char *v17; // r15
  int v18; // er14
  int v19; // eax
  int v20; // ecx
  unsigned int v21; // [rsp+4h] [rbp-74h]
  unsigned int v22; // [rsp+8h] [rbp-70h]
  unsigned int v23; // [rsp+Ch] [rbp-6Ch]
  char v24; // [rsp+10h] [rbp-68h]
  unsigned __int64 v25; // [rsp+38h] [rbp-40h]

  v4 = *(__int64 **)(a1 + 32);
  v25 = __readfsqword(0x28u);
  if ( !a4 )
  {
    if ( *v4 != a1 )
      return __readfsqword(0x28u) ^ v25;
    v10 = off_31E208;
    nullsub_37();
    sub_9F1A0(a1, (__int64 **)a2);
    v11 = "Default Foreground";
    while ( 1 )
    {
      sub_9F520(a1, a2, v11);
      if ( v10 == &off_31E208[21] )
        break;
      v11 = *v10;
      ++v10;
    }
    nullsub_38();
LABEL_19:
    sub_9EFD0(v4[1], (__int64 **)a2, &locale);
    sub_9EFD0(v4[2], (__int64 **)a2, &locale);
    sub_9EFD0(v4[3], (__int64 **)a2, &locale);
    return __readfsqword(0x28u) ^ v25;
  }
  v6 = a3;
  switch ( a4 )
  {
    case 3:
      if ( *v4 != a1 )
        return __readfsqword(0x28u) ^ v25;
      v8 = sub_9F660(a1, (__int64 **)a2);
      if ( v8 < 0 )
        goto LABEL_19;
      v9 = 3 * v8;
      v21 = sub_1F0A0(v6, 147, 3 * v8);
      v22 = sub_1F0A0(v6, 147, v9 + 1);
      v23 = sub_1F0A0(v6, 147, v9 + 2);
LABEL_11:
      __sprintf_chk(&v24, 1LL, 40LL, "%d", v21);
      sub_9EFD0(v4[1], (__int64 **)a2, &v24);
      __sprintf_chk(&v24, 1LL, 40LL, "%d", v22);
      sub_9EFD0(v4[2], (__int64 **)a2, &v24);
      __sprintf_chk(&v24, 1LL, 40LL, "%d", v23);
      sub_9EFD0(v4[3], (__int64 **)a2, &v24);
      return __readfsqword(0x28u) ^ v25;
    case 2:
      if ( v4[1] == a1 || v4[2] == a1 || v4[3] == a1 )
      {
        v17 = (char *)sub_9F0C0(a1, (__int64 **)a2);
        v18 = strtol(v17, 0LL, 10);
        sub_2F4D0(v17);
        v19 = sub_9F660(*v4, (__int64 **)a2);
        if ( v19 >= 0 )
        {
          v20 = 0;
          if ( v18 >= 0 )
            v20 = v18;
          if ( v20 > 255 )
            v20 = 255;
          if ( v4[1] == a1 )
          {
            sub_1F7F0(v6, 147, 3 * v19, v20);
          }
          else if ( v4[2] == a1 )
          {
            sub_1F7F0(v6, 147, 3 * v19 + 1, v20);
          }
          else if ( v4[3] == a1 )
          {
            sub_1F7F0(v6, 147, 3 * v19 + 2, v20);
          }
        }
      }
      break;
    case 1:
      if ( v4[4] == a1 )
      {
        v12 = sub_9F660(*v4, (__int64 **)a2);
        if ( v12 < 0 )
        {
          sub_A0250();
        }
        else
        {
          v13 = 3 * v12;
          v14 = sub_1F0A0(v6, 147, 3 * v12 + 2);
          v15 = sub_1F0A0(v6, 147, v13 + 1);
          v16 = sub_1F0A0(v6, 147, v13);
          sub_A03D0((__int64 *)a1, (__int64 **)a2, v16, v15, v14);
        }
      }
      break;
    default:
      if ( a4 == 4 && v4[4] == a1 )
      {
        v7 = sub_9F660(*v4, (__int64 **)a2);
        if ( (unsigned __int8)sub_A0560(a1, (unsigned __int8 *)a2, &v21, &v22, &v23) )
        {
          sub_1F7F0(v6, 147, 3 * v7, v21);
          sub_1F7F0(v6, 147, 3 * v7 + 1, v22);
          sub_1F7F0(v6, 147, 3 * v7 + 2, v23);
          goto LABEL_11;
        }
      }
      break;
  }
  return __readfsqword(0x28u) ^ v25;
}

unsigned __int64 __fastcall sub_21B40(__int64 a1, __int64 **a2, __int64 *a3, unsigned int a4)
{
  __int64 *v4; // r14
  unsigned int v5; // ebx
  __int64 *v6; // rbp
  const char *v8; // rbx
  char *v9; // rdi
  int v10; // er13
  unsigned int v11; // ebx
  __int64 v12; // [rsp+0h] [rbp-98h]
  unsigned __int64 v13; // [rsp+68h] [rbp-30h]

  v4 = a3;
  v5 = a4;
  v6 = *(__int64 **)(a1 + 32);
  v13 = __readfsqword(0x28u);
  if ( a4 )
  {
    if ( a4 == 1 && v6[2] == a1 )
    {
      v8 = (const char *)sub_9F0C0(v6[1], a2);
      v9 = (char *)v8;
      v10 = strtol(v8, 0LL, 10);
      v11 = 0;
      sub_2F4D0(v9);
      do
      {
        if ( (unsigned __int8)sub_9F810(*v6, a2, v11) )
          sub_1F7F0(v4, 155, v11, v10);
        ++v11;
      }
      while ( v11 != 128 );
      sub_A0280(*v6, (__int64)a2);
    }
  }
  else if ( *v6 == a1 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    sub_1F0A0(v4, 155, 0);
    while ( 1 )
    {
      __sprintf_chk(&v12, 1LL, 100LL, "%d\t(0x%02X)\t%c\t%d", v5++);
      sub_9F520(a1, (__int64)a2, (const char *)&v12);
      if ( v5 == 128 )
        break;
      sub_1F0A0(v4, 155, v5);
    }
    nullsub_38();
  }
  return __readfsqword(0x28u) ^ v13;
}

signed __int64 __fastcall sub_21CD0(_QWORD *a1, __int64 a2, __int64 a3, bool *a4)
{
  __int64 *v4; // r15
  bool *v5; // r14
  _QWORD *v6; // rbx
  __int64 **v7; // r12
  signed int v8; // eax
  bool v9; // cf
  bool v10; // zf
  unsigned int v11; // er13
  const char *v12; // rdi
  signed __int64 v13; // rcx
  _BYTE *v14; // rsi
  char v15; // bp
  char *v16; // rdi
  signed __int64 result; // rax
  __int64 v18; // [rsp+8h] [rbp-40h]

  v4 = (__int64 *)a3;
  v5 = a4;
  v6 = a1;
  v7 = (__int64 **)a2;
  v8 = sub_9F660(a1[1], (__int64 **)a2);
  v9 = 0;
  v10 = v8 == 0;
  if ( v8 < 0 )
  {
    sub_A0250();
    result = 0LL;
  }
  else
  {
    v11 = v8;
    v12 = "Default Settings";
    v13 = 17LL;
    v18 = v8;
    v14 = *(_BYTE **)(v6[8] + 8LL * v8);
    do
    {
      if ( !v13 )
        break;
      v9 = *v14 < (const unsigned __int8)*v12;
      v10 = *v14++ == *v12++;
      --v13;
    }
    while ( v10 );
    v15 = (!v9 && !v10) - v9;
    sub_40A20(v4, (unsigned int)v7);
    sub_2F4D0((void *)v6[11]);
    v16 = &locale;
    if ( v15 )
      v16 = *(char **)(v6[8] + 8 * v18);
    v6[11] = sub_BC120(v16);
    *v5 = v15 != 0;
    sub_A0280(0LL, (__int64)v7);
    sub_9FB80(v6[1], v7, v11);
    result = 1LL;
  }
  return result;
}

__int64 __usercall sub_21DC0@<rax>(__int64 a1@<rdx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 **a4@<rsi>, __int64 a5@<r14>)
{
  __int64 v5; // r13
  __int64 v6; // rbp
  int v7; // er12
  __int64 v8; // rbx
  __int64 result; // rax
  unsigned __int64 v10; // rt1
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 v13; // rax
  const char *v14; // r12
  int v15; // er15
  int v16; // eax
  const char *v17; // rdx
  char *v18; // rdi
  int v19; // eax
  bool v20; // cf
  bool v21; // zf
  __int64 v22; // r12
  const char *v23; // rdi
  signed __int64 v24; // rcx
  _BYTE *v25; // rsi
  int v26; // ebp
  char *v27; // rdi
  char *v28; // rax
  char *v29; // rbp
  int v30; // eax
  int v31; // [rsp+Ch] [rbp-4Ch]
  char v32; // [rsp+16h] [rbp-42h]
  char v33; // [rsp+17h] [rbp-41h]
  unsigned __int64 v34; // [rsp+18h] [rbp-40h]

  v5 = (__int64)a4;
  v6 = a3;
  v7 = a2;
  v8 = *(_QWORD *)(a3 + 32);
  v34 = __readfsqword(0x28u);
  if ( !a2 )
  {
    if ( *(_QWORD *)v8 == a3 )
    {
      sub_9EFD0(a3, a4, *(char **)(v8 + 88));
    }
    else if ( *(_QWORD *)(v8 + 8) == a3 )
    {
      nullsub_37();
      sub_9F1A0(a3, a4);
      if ( *(_DWORD *)(v8 + 56) > 0 )
      {
        a5 = 0LL;
        do
        {
          ++v7;
          v17 = *(const char **)(*(_QWORD *)(v8 + 64) + a5);
          a5 += 8LL;
          sub_9F520(a3, (__int64)a4, v17);
        }
        while ( *(_DWORD *)(v8 + 56) > v7 );
      }
      nullsub_38();
    }
    goto LABEL_4;
  }
  if ( a2 == 2 )
  {
    if ( *(_QWORD *)v8 == a3 )
    {
      a5 = 0xFFFFFFFFLL;
      sub_2F4D0(*(void **)(v8 + 88));
      v14 = (const char *)sub_9F0C0(a3, a4);
      *(_QWORD *)(v8 + 88) = v14;
      v31 = *(_DWORD *)(v8 + 56);
      v15 = *(_DWORD *)(v8 + 56);
      while ( v15 - (signed int)a5 > 1 )
      {
        v6 = ((signed int)a5 + v15) / 2;
        v16 = strcmp(v14, *(const char **)(*(_QWORD *)(v8 + 64) + 8LL * (signed int)v6));
        if ( v16 > 0 )
          a5 = (unsigned int)v6;
        if ( v16 <= 0 )
          v15 = v6;
      }
      sub_9FB80(*(_QWORD *)(v8 + 8), a4, v15 - (v15 == v31));
    }
    goto LABEL_4;
  }
  if ( a2 != 1 )
    goto LABEL_4;
  v21 = *(_BYTE *)(v8 + 80) == 0;
  a5 = a1;
  v32 = 0;
  if ( v21 )
  {
    v11 = *(_QWORD *)(v8 + 8);
    if ( v11 == v6 )
      goto LABEL_48;
    v12 = *(_QWORD *)(v8 + 16);
    if ( v12 )
    {
      if ( v12 != v6 )
      {
        if ( v6 != *(_QWORD *)(v8 + 24) )
        {
LABEL_13:
          v13 = *(_QWORD *)(v8 + 32);
          if ( v13 )
          {
            if ( v13 != v6 )
            {
              if ( v6 == *(_QWORD *)(v8 + 40) )
              {
LABEL_16:
                if ( sub_9ED00(v6, (__int64)a4) == *(_QWORD *)(v8 + 8)
                  && !sub_31CC0((__int64 *)a5)
                  && sub_A1FD0(*(_QWORD *)(v8 + 8), (__int64)a4) )
                {
                  v6 = (__int64)sub_1ED20();
                  v33 = 0;
                  if ( (unsigned __int8)sub_21CD0((_QWORD *)v8, (__int64)a4, v6, (bool *)&v33)
                    && v33
                    && sub_31CC0((__int64 *)v6) )
                  {
                    goto LABEL_64;
                  }
                  sub_A0250();
                  goto LABEL_63;
                }
                if ( !sub_31CC0((__int64 *)a5) )
                  goto LABEL_18;
LABEL_52:
                sub_A0270((__int64)a4, 1);
                goto LABEL_4;
              }
              goto LABEL_34;
            }
            v30 = sub_9F660(v11, a4);
            if ( v30 > 0 )
            {
              v6 = v8 + 56;
              sub_BAB40(*(const char **)(*(_QWORD *)(v8 + 64) + 8LL * v30));
              sub_40A70(v8 + 56, 0LL);
              sub_40A70(v8 + 56, 1LL);
              sub_A0280(*(_QWORD *)(v8 + 8), (__int64)a4);
              goto LABEL_4;
            }
LABEL_18:
            sub_A0250();
            goto LABEL_4;
          }
          if ( *(_QWORD *)(v8 + 40) == v6 )
            goto LABEL_16;
LABEL_34:
          if ( *(_QWORD *)(v8 + 48) == v6 )
            sub_A0270((__int64)a4, 0);
          goto LABEL_4;
        }
        goto LABEL_37;
      }
LABEL_48:
      if ( !(unsigned __int8)sub_21CD0((_QWORD *)v8, (__int64)a4, a1, (bool *)&v32)
        || !v32
        || *(_QWORD *)(v8 + 8) != v6
        || !sub_31CC0((__int64 *)a5) )
      {
        goto LABEL_4;
      }
      goto LABEL_52;
    }
    if ( *(_QWORD *)(v8 + 24) != v6 )
      goto LABEL_13;
  }
  else if ( a3 != *(_QWORD *)(v8 + 24) )
  {
    if ( a3 == *(_QWORD *)(v8 + 40) )
      goto LABEL_52;
    goto LABEL_34;
  }
LABEL_37:
  v18 = *(char **)(v8 + 88);
  if ( !*v18 )
  {
    v19 = sub_9F660(*(_QWORD *)(v8 + 8), a4);
    v20 = 0;
    v21 = v19 == 0;
    if ( v19 < 0 )
      goto LABEL_18;
    v22 = v19;
    v23 = "Default Settings";
    v24 = 17LL;
    v25 = *(_BYTE **)(*(_QWORD *)(v8 + 64) + 8LL * v19);
    do
    {
      if ( !v24 )
        break;
      v20 = *v25 < (const unsigned __int8)*v23;
      v21 = *v25++ == *v23++;
      --v24;
    }
    while ( v21 );
    v26 = (char)((!v20 && !v21) - v20);
    sub_2F4D0(*(void **)(v8 + 88));
    v27 = &locale;
    if ( v26 )
      v27 = *(char **)(*(_QWORD *)(v8 + 64) + 8 * v22);
    v18 = sub_BC120(v27);
    *(_QWORD *)(v8 + 88) = v18;
  }
  v28 = (char *)sub_3EA30((__int64)v18, (__int64 *)a5);
  v29 = v28;
  if ( v28 )
  {
    sub_A1E90(v5, v28);
    sub_2F4D0(v29);
  }
  v6 = v8 + 56;
  sub_40A70(v8 + 56, 0LL);
  sub_40A70(v8 + 56, 1LL);
  sub_A0280(*(_QWORD *)v8, v5);
  sub_A0280(*(_QWORD *)(v8 + 8), v5);
LABEL_4:
  while ( 1 )
  {
    v10 = __readfsqword(0x28u);
    result = v10 ^ v34;
    if ( v10 == v34 )
      break;
LABEL_64:
    sub_1ED70((_QWORD *)a5, (_QWORD *)v6);
    sub_A0270(v5, 1);
LABEL_63:
    sub_1ED50((_QWORD *)v6);
  }
  return result;
}

void __fastcall sub_22230(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r12
  __int64 **v5; // rbp
  __int64 v6; // rbx
  int v7; // eax
  int v8; // edx
  _DWORD *v9; // rdi
  int v10; // ecx
  signed __int64 v11; // rsi
  signed __int64 v12; // rdx
  int v13; // eax

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !a4 )
  {
    v7 = sub_1EFD0(a3, *(_DWORD *)(a1 + 32));
    v8 = *(_DWORD *)(a1 + 64);
    if ( v8 > 0 )
    {
      v9 = *(_DWORD **)(a1 + 88);
      v10 = 0;
      if ( v7 == *v9 )
      {
LABEL_10:
        sub_9ED20(v6, v5, v10);
        return;
      }
      v11 = 1LL;
      v12 = (unsigned int)(v8 - 1) + 1LL;
      while ( 1 )
      {
        v10 = v11;
        if ( v12 == v11 )
          break;
        if ( v9[2 * ++v11 - 2] == v7 )
          goto LABEL_10;
      }
    }
    __assert_fail("button < ctrl->radio.nbuttons", "config.c", 0x24u, "conf_radiobutton_handler");
  }
  if ( a4 == 2 )
  {
    v13 = sub_9EDD0(a1, a2);
    if ( v13 < 0 || v13 >= *(_DWORD *)(a1 + 64) )
      __assert_fail("button >= 0 && button < ctrl->radio.nbuttons", "config.c", 0x28u, "conf_radiobutton_handler");
    sub_1F760(v4, *(_DWORD *)(a1 + 32), *(_DWORD *)(*(_QWORD *)(a1 + 88) + 8LL * v13));
  }
}

void __fastcall sub_22330(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // rbp
  __int64 v5; // rbx
  int v6; // eax
  int v7; // er8
  _DWORD *v8; // rdi
  signed __int64 v9; // rcx
  int v10; // edx
  int v11; // eax

  v4 = a3;
  v5 = a1;
  if ( !a4 )
  {
    v6 = sub_1EFD0(a3, 128);
    v7 = *(_DWORD *)(a1 + 64);
    if ( v7 <= 0 )
    {
      v10 = 0;
    }
    else
    {
      v8 = *(_DWORD **)(a1 + 88);
      if ( v6 == *v8 )
        goto LABEL_11;
      v9 = 1LL;
      while ( 1 )
      {
        v10 = v9;
        if ( v9 == (unsigned int)(v7 - 1) + 1LL )
          break;
        if ( v8[2 * ++v9 - 2] == v6 )
          goto LABEL_12;
      }
    }
    if ( v7 != v10 )
    {
LABEL_12:
      sub_9ED20(v5, a2, v10);
      return;
    }
    sub_1F760(v4, 128, 0);
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  if ( a4 == 2 )
  {
    v11 = sub_9EDD0(a1, a2);
    if ( v11 < 0 || v11 >= *(_DWORD *)(a1 + 64) )
      __assert_fail("button >= 0 && button < ctrl->radio.nbuttons", "config.c", 0x1C0u, "loggingbuttons_handler");
    sub_1F760(v4, 128, *(_DWORD *)(*(_QWORD *)(a1 + 88) + 8LL * v11));
  }
}

void __fastcall sub_22420(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r12
  __int64 **v5; // rbp
  __int64 v6; // rbx
  unsigned __int8 v7; // al
  int v8; // edx
  _DWORD *v9; // rdi
  int v10; // ecx
  signed __int64 v11; // rsi
  signed __int64 v12; // rdx
  int v13; // eax

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( !a4 )
  {
    v7 = sub_1EF00(a3, *(_DWORD *)(a1 + 32));
    v8 = *(_DWORD *)(a1 + 64);
    if ( v8 > 0 )
    {
      v9 = *(_DWORD **)(a1 + 88);
      v10 = 0;
      if ( v7 == *v9 )
      {
LABEL_10:
        sub_9ED20(v6, v5, v10);
        return;
      }
      v11 = 1LL;
      v12 = (unsigned int)(v8 - 1) + 1LL;
      while ( 1 )
      {
        v10 = v11;
        if ( v12 == v11 )
          break;
        if ( v9[2 * ++v11 - 2] == v7 )
          goto LABEL_10;
      }
    }
    __assert_fail("button < ctrl->radio.nbuttons", "config.c", 0x3Fu, "conf_radiobutton_bool_handler");
  }
  if ( a4 == 2 )
  {
    v13 = sub_9EDD0(a1, a2);
    if ( v13 < 0 || v13 >= *(_DWORD *)(a1 + 64) )
      __assert_fail("button >= 0 && button < ctrl->radio.nbuttons", "config.c", 0x43u, "conf_radiobutton_bool_handler");
    sub_1F6D0(v4, *(_DWORD *)(a1 + 32), *(_DWORD *)(*(_QWORD *)(a1 + 88) + 8LL * v13) != 0);
  }
}

void __fastcall sub_22530(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // rbp
  char v5; // al
  int v6; // edx
  int v7; // eax
  char v8; // dl

  v4 = a3;
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v7 = sub_9EDD0(a1, a2);
      if ( v7 < 0 || v7 >= *(_DWORD *)(a1 + 64) )
        __assert_fail("button >= 0 && button < ctrl->radio.nbuttons", "config.c", 0x1D9u, "numeric_keypad_handler");
      if ( v7 == 2 )
      {
        sub_1F6D0(v4, 85, 0);
        v8 = 1;
      }
      else
      {
        sub_1F6D0(v4, 85, v7 != 0);
        v8 = 0;
      }
      sub_1F6D0(v4, 86, v8);
    }
  }
  else
  {
    v5 = sub_1EF00(a3, 86);
    v6 = 2;
    if ( !v5 )
      v6 = (unsigned __int8)sub_1EF00(v4, 85);
    if ( *(_DWORD *)(a1 + 64) <= v6 )
      __assert_fail("button < ctrl->radio.nbuttons", "config.c", 0x1D5u, "numeric_keypad_handler");
    sub_9ED20(a1, a2, v6);
  }
}

void __fastcall sub_22630(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r12
  int v5; // er12
  signed int v6; // eax
  int v7; // edx

  v4 = a3;
  if ( a4 )
  {
    if ( a4 == 3 )
    {
      v6 = sub_9F660(a1, a2);
      v7 = 2;
      if ( v6 >= 0 )
        v7 = sub_9F530(a1, a2, v6);
      sub_1F760(v4, *(_DWORD *)(a1 + 32), v7);
    }
  }
  else
  {
    v5 = sub_1EFD0(a3, *(_DWORD *)(a1 + 32));
    nullsub_37();
    sub_9F1A0(a1, a2);
    sub_9F340(a1, (__int64)a2, "Auto", 2u);
    sub_9F340(a1, (__int64)a2, "Off", 1u);
    sub_9F340(a1, (__int64)a2, "On", 0);
    switch ( v5 )
    {
      case 1:
        sub_9FB80(a1, a2, 1u);
        break;
      case 2:
        sub_9FB80(a1, a2, 0);
        break;
      case 0:
        sub_9FB80(a1, a2, 2u);
        break;
    }
    nullsub_38();
  }
}

void __fastcall sub_22750(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r14
  int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // edx
  signed int v9; // eax

  v4 = a3;
  v5 = a4;
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v6 = 0;
      do
      {
        v7 = sub_9F530(a1, a2, v6);
        v8 = v6++;
        sub_1F7F0(v4, 45, v8, v7);
      }
      while ( v6 != 4 );
    }
  }
  else
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    do
    {
      v9 = sub_1F0A0(v4, 45, v5);
      if ( v9 >= 4 || v9 < 0 )
        __assert_fail("id >= 0 && id < ngsslibs", "config.c", 0x21Du, "gsslist_handler");
      ++v5;
      sub_9F340(a1, (__int64)a2, off_3228E0[v9], v9);
    }
    while ( v5 != 4 );
    nullsub_38();
  }
}

void __fastcall sub_22870(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // edx
  unsigned int v9; // eax
  const char *v10; // rdx
  signed __int64 v11; // rdx

  v4 = a3;
  v5 = a4;
  if ( !a4 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    while ( 1 )
    {
      v9 = sub_1F0A0(v4, 32, v5);
      switch ( v9 )
      {
        case 6u:
          v10 = "ChaCha20 (SSH-2 only)";
          break;
        case 1u:
          v11 = 1LL;
LABEL_18:
          v10 = off_31E0E0[2 * v11];
          break;
        case 2u:
          v11 = 2LL;
          goto LABEL_18;
        case 4u:
          v11 = 3LL;
          goto LABEL_18;
        case 3u:
          v11 = 4LL;
          goto LABEL_18;
        case 5u:
          v11 = 5LL;
          goto LABEL_18;
        default:
          v10 = 0LL;
          if ( !v9 )
          {
            v11 = 6LL;
            goto LABEL_18;
          }
          break;
      }
      ++v5;
      sub_9F340(a1, (__int64)a2, v10, v9);
      if ( v5 == 7 )
      {
        nullsub_38();
        return;
      }
    }
  }
  if ( a4 == 2 )
  {
    v6 = 0;
    do
    {
      v7 = sub_9F530(a1, a2, v6);
      v8 = v6++;
      sub_1F7F0(v4, 32, v8, v7);
    }
    while ( v6 != 7 );
  }
}

void __fastcall sub_229F0(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // edx
  unsigned int v9; // eax
  const char *v10; // rdx
  signed __int64 v11; // rdx

  v4 = a3;
  v5 = a4;
  if ( !a4 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    while ( 1 )
    {
      v9 = sub_1F0A0(v4, 25, v5);
      switch ( v9 )
      {
        case 4u:
          v10 = "Ed25519";
          break;
        case 5u:
          v11 = 1LL;
LABEL_17:
          v10 = off_31E080[2 * v11];
          break;
        case 3u:
          v11 = 2LL;
          goto LABEL_17;
        case 2u:
          v11 = 3LL;
          goto LABEL_17;
        case 1u:
          v11 = 4LL;
          goto LABEL_17;
        default:
          v10 = 0LL;
          if ( !v9 )
          {
            v11 = 5LL;
            goto LABEL_17;
          }
          break;
      }
      ++v5;
      sub_9F340(a1, (__int64)a2, v10, v9);
      if ( v5 == 6 )
      {
        nullsub_38();
        return;
      }
    }
  }
  if ( a4 == 2 )
  {
    v6 = 0;
    do
    {
      v7 = sub_9F530(a1, a2, v6);
      v8 = v6++;
      sub_1F7F0(v4, 25, v8, v7);
    }
    while ( v6 != 6 );
  }
}

void __fastcall sub_22B50(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // edx
  unsigned int v9; // eax
  const char *v10; // rdx
  signed __int64 v11; // rdx

  v4 = a3;
  v5 = a4;
  if ( !a4 )
  {
    nullsub_37();
    sub_9F1A0(a1, a2);
    while ( 1 )
    {
      v9 = sub_1F0A0(v4, 24, v5);
      switch ( v9 )
      {
        case 1u:
          v10 = "Diffie-Hellman group 1";
          break;
        case 2u:
          v11 = 1LL;
LABEL_17:
          v10 = off_31E020[2 * v11];
          break;
        case 3u:
          v11 = 2LL;
          goto LABEL_17;
        case 4u:
          v11 = 3LL;
          goto LABEL_17;
        case 5u:
          v11 = 4LL;
          goto LABEL_17;
        default:
          v10 = 0LL;
          if ( !v9 )
          {
            v11 = 5LL;
            goto LABEL_17;
          }
          break;
      }
      ++v5;
      sub_9F340(a1, (__int64)a2, v10, v9);
      if ( v5 == 6 )
      {
        nullsub_38();
        return;
      }
    }
  }
  if ( a4 == 2 )
  {
    v6 = 0;
    do
    {
      v7 = sub_9F530(a1, a2, v6);
      v8 = v6++;
      sub_1F7F0(v4, 24, v8, v7);
    }
    while ( v6 != 6 );
  }
}

void __fastcall sub_22CB0(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebx
  unsigned __int8 *v6; // rax
  int v7; // eax
  char *v8; // r14
  const char *v9; // rax
  unsigned __int8 *v10; // rax
  unsigned __int8 *v11; // rbx
  int v12; // eax
  char *v13; // rax

  v4 = a3;
  v5 = a4;
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v10 = (unsigned __int8 *)sub_9F0C0(a1, a2);
      v11 = v10;
      v12 = sub_BBA50(v10);
      v13 = (char *)sub_BB9F0(v12);
      sub_1F890(v4, 164, v13);
      sub_2F4D0(v11);
    }
  }
  else
  {
    nullsub_37();
    v6 = (unsigned __int8 *)sub_1F170(v4, 164);
    v7 = sub_BBA50(v6);
    v8 = (char *)sub_BB9F0(v7);
    sub_9F1A0(a1, a2);
    while ( 1 )
    {
      v9 = sub_BBA10(v5);
      if ( !v9 )
        break;
      ++v5;
      sub_9F520(a1, (__int64)a2, v9);
    }
    sub_9EFD0(a1, a2, v8);
    sub_1F890(v4, 164, v8);
    nullsub_38();
  }
}

unsigned __int64 __fastcall sub_22DB0(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 *v4; // r13
  int v5; // ebx
  char *v7; // rax
  bool v8; // cf
  bool v9; // zf
  char *v10; // rax
  const char *v11; // rdi
  char *v12; // rsi
  signed __int64 v13; // rcx
  char *v14; // rbx
  const char *v15; // rax
  int v16; // [rsp+4h] [rbp-34h]
  unsigned __int64 v17; // [rsp+8h] [rbp-30h]

  v4 = a3;
  v5 = a4;
  v17 = __readfsqword(0x28u);
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v10 = (char *)sub_9F0C0(a1, a2);
      v11 = "None (printing disabled)";
      v12 = v10;
      v13 = 25LL;
      v14 = v10;
      do
      {
        if ( !v13 )
          break;
        v8 = (unsigned __int8)*v12 < *v11;
        v9 = *v12++ == *v11++;
        --v13;
      }
      while ( v9 );
      if ( (!v8 && !v9) == v8 )
        *v10 = 0;
      sub_1F890(v4, 138, v10);
      sub_2F4D0(v14);
    }
  }
  else
  {
    nullsub_37();
    if ( *(_BYTE *)(a1 + 65) )
    {
      sub_9F1A0(a1, a2);
      sub_9F520(a1, (__int64)a2, "None (printing disabled)");
      sub_B81F0(&v16);
      if ( v16 > 0 )
      {
        do
        {
          ++v5;
          v15 = (const char *)sub_B8200();
          sub_9F520(a1, (__int64)a2, v15);
        }
        while ( v5 < v16 );
      }
      nullsub_42();
    }
    v7 = (char *)sub_1F170(v4, 138);
    if ( !v7 )
      v7 = "None (printing disabled)";
    sub_9EFD0(a1, a2, v7);
    nullsub_38();
  }
  return __readfsqword(0x28u) ^ v17;
}

unsigned __int64 __fastcall sub_22F10(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 **v4; // r12
  __int64 *v5; // rbx
  int v7; // esi
  unsigned int v8; // eax
  char *v9; // rbp
  int v10; // er12
  char v11; // [rsp+0h] [rbp-78h]
  unsigned __int64 v12; // [rsp+58h] [rbp-20h]

  v4 = a2;
  v5 = a3;
  v12 = __readfsqword(0x28u);
  if ( !a4 )
  {
    if ( (unsigned int)sub_1EFD0(a3, 2) == 5 )
    {
      sub_9FD80(a1, a2, (__int64)"Speed");
      v7 = 62;
    }
    else
    {
      sub_9FD80(a1, a2, (__int64)"Port");
      if ( !(unsigned int)sub_1EFD0(v5, 1) )
      {
        v11 = 0;
LABEL_7:
        sub_9EFD0(a1, v4, &v11);
        return __readfsqword(0x28u) ^ v12;
      }
      v7 = 1;
    }
    v8 = sub_1EFD0(v5, v7);
    __sprintf_chk(&v11, 1LL, 80LL, "%d", v8);
    goto LABEL_7;
  }
  if ( a4 == 2 )
  {
    v9 = (char *)sub_9F0C0(a1, a2);
    v10 = strtol(v9, 0LL, 10);
    sub_2F4D0(v9);
    if ( (unsigned int)sub_1EFD0(v5, 2) == 5 )
      sub_1F760(v5, 62, v10);
    else
      sub_1F760(v5, 1, v10);
  }
  return __readfsqword(0x28u) ^ v12;
}

void __fastcall sub_23070(__int64 a1, __int64 **a2, __int64 *a3, int a4)
{
  __int64 **v4; // r12
  __int64 *v5; // rbx
  int v6; // esi
  char *v7; // rax
  char *v8; // rbp

  v4 = a2;
  v5 = a3;
  if ( a4 )
  {
    if ( a4 == 2 )
    {
      v8 = (char *)sub_9F0C0(a1, a2);
      if ( (unsigned int)sub_1EFD0(v5, 2) == 5 )
        sub_1F890(v5, 61, v8);
      else
        sub_1F890(v5, 0, v8);
      sub_2F4D0(v8);
    }
  }
  else
  {
    if ( (unsigned int)sub_1EFD0(a3, 2) == 5 )
    {
      sub_9FD80(a1, a2, (__int64)"Serial line");
      v6 = 61;
    }
    else
    {
      sub_9FD80(a1, a2, (__int64)"Host Name (or IP address)");
      v6 = 0;
    }
    v7 = (char *)sub_1F170(v5, v6);
    sub_9EFD0(a1, v4, v7);
  }
}

__int64 __fastcall sub_23140(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  unsigned int v5; // er14
  __int64 v6; // r12
  __int64 v7; // r13
  __int64 v8; // rax
  __int64 v9; // ST00_8

  v5 = a4;
  v6 = a3;
  v7 = sub_28760(a5);
  v8 = sub_28760(v5);
  sub_28DD0(a1, (char *)a2, 0, 60, v6, (__int64)sub_20540, v8, v7);
  return v9;
}

void **__fastcall sub_231A0(__int64 a1, bool a2, unsigned int a3, int a4)
{
  bool v4; // r15
  unsigned __int64 *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rbp
  __int64 v8; // r12
  __int64 v9; // r13
  __int64 v10; // rax
  char *v11; // rsi
  signed int v12; // edx
  __int64 v13; // rax
  __int64 v14; // r13
  __int64 v15; // rax
  __int64 v16; // rax
  char *v17; // r12
  char *v18; // rcx
  __int64 v19; // r12
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // r14
  __int64 v23; // r13
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  char v29; // ST80_1
  __int64 v30; // r8
  __int64 v31; // r9
  char v32; // ST80_1
  __int64 v33; // r13
  __int64 v34; // rax
  __int64 v35; // rax
  int v36; // ST94_4
  __int64 v37; // r13
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // rcx
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // ST98_8
  __int64 v44; // r12
  __int64 v45; // rax
  __int64 v46; // rbp
  bool v47; // cl
  __int64 v48; // r14
  __int64 v49; // rax
  __int64 v50; // r12
  __int64 v51; // rax
  __int64 v52; // rax
  __int64 v53; // r12
  __int64 v54; // rax
  __int64 v55; // r12
  __int64 v56; // rax
  __int64 v57; // r12
  __int64 v58; // rax
  __int64 v59; // rbp
  __int64 v60; // r12
  __int64 v61; // rax
  __int64 v62; // r12
  __int64 v63; // rax
  __int64 v64; // r12
  __int64 v65; // rax
  __int64 v66; // r12
  __int64 v67; // rax
  __int64 v68; // r12
  __int64 v69; // rax
  __int64 v70; // r12
  __int64 v71; // rax
  __int64 v72; // r13
  __int64 v73; // r12
  __int64 v74; // rax
  __int64 v75; // rbp
  __int64 v76; // STA0_8
  __int64 v77; // rax
  __int64 v78; // STA0_8
  __int64 v79; // rax
  __int64 v80; // rbp
  __int64 v81; // r14
  __int64 v82; // r13
  __int64 v83; // rax
  __int64 v84; // rbp
  __int64 v85; // r13
  __int64 v86; // rax
  __int64 v87; // r13
  __int64 v88; // rax
  __int64 v89; // r13
  __int64 v90; // rax
  __int64 v91; // rbp
  __int64 v92; // STA0_8
  __int64 v93; // rax
  __int64 v94; // STA0_8
  __int64 v95; // rax
  __int64 v96; // STA0_8
  __int64 v97; // r14
  __int64 v98; // rax
  __int64 v99; // rbp
  __int64 v100; // r14
  __int64 v101; // rax
  __int64 v102; // STA0_8
  __int64 v103; // r14
  __int64 v104; // rax
  __int64 v105; // STA0_8
  __int64 v106; // r14
  __int64 v107; // rax
  __int64 v108; // rax
  __int64 v109; // STA0_8
  __int64 v110; // r14
  __int64 v111; // rax
  __int64 v112; // rbp
  __int64 v113; // r14
  __int64 v114; // rax
  __int64 v115; // r14
  __int64 v116; // rax
  __int64 v117; // r14
  __int64 v118; // rax
  __int64 v119; // r14
  __int64 v120; // rax
  __int64 v121; // r14
  __int64 v122; // rax
  __int64 v123; // r14
  __int64 v124; // rax
  __int64 v125; // r14
  __int64 v126; // rax
  __int64 v127; // r14
  __int64 v128; // rax
  __int64 v129; // r14
  __int64 v130; // rax
  __int64 v131; // r14
  __int64 v132; // rax
  __int64 v133; // r14
  __int64 v134; // rax
  __int64 v135; // r14
  __int64 v136; // rax
  char *v137; // rbp
  void **v138; // rax
  __int64 v139; // rbp
  __int64 v140; // STA0_8
  __int64 v141; // r14
  __int64 v142; // rax
  __int64 v143; // r14
  __int64 v144; // rax
  __int64 v145; // r14
  __int64 v146; // rax
  __int64 v147; // r14
  __int64 v148; // rax
  __int64 v149; // r14
  __int64 v150; // rax
  char *v151; // rbp
  __int64 v152; // rbp
  __int64 v153; // r14
  __int64 v154; // rax
  __int64 v155; // r14
  __int64 v156; // rax
  __int64 v157; // rbp
  __int64 v158; // r14
  __int64 v159; // rax
  __int64 v160; // rbp
  __int64 v161; // r14
  __int64 v162; // rax
  __int64 v163; // STA0_8
  __int64 v164; // rbp
  __int64 v165; // r14
  __int64 v166; // rax
  char *v167; // rbp
  __int64 v168; // rbp
  __int64 v169; // STA0_8
  __int64 v170; // r14
  __int64 v171; // rax
  __int64 v172; // r14
  __int64 v173; // rax
  __int64 v174; // rbp
  __int64 v175; // r14
  __int64 v176; // rax
  __int64 v177; // STA0_8
  __int64 v178; // rbp
  __int64 v179; // r14
  __int64 v180; // rax
  __int64 v181; // rbp
  __int64 v182; // r14
  __int64 v183; // rax
  char *v184; // r14
  __int64 v185; // rbp
  __int64 v186; // r14
  __int64 v187; // rax
  __int64 v188; // r14
  __int64 v189; // rax
  __int64 v190; // r14
  __int64 v191; // rax
  __int64 v192; // rbp
  __int64 v193; // r14
  __int64 v194; // rax
  __int64 v195; // r14
  __int64 v196; // rax
  __int64 v197; // rbp
  __int64 v198; // r13
  __int64 v199; // rax
  __int64 v200; // rax
  __int64 v201; // rax
  __int64 v202; // rax
  __int64 v203; // rbp
  __int64 v204; // r13
  __int64 v205; // rax
  __int64 v206; // r13
  _QWORD *v207; // rbp
  __int64 v208; // r14
  __int64 v209; // rax
  __int64 v210; // rax
  __int64 v211; // rax
  __int64 v212; // r8
  __int64 v213; // r9
  __int64 v214; // STA0_8
  __int64 v215; // r14
  __int64 v216; // rax
  __int64 v217; // rax
  __int64 v218; // r14
  __int64 v219; // rax
  __int64 v220; // rax
  __int64 v221; // rcx
  __int64 v222; // r8
  __int64 v223; // r9
  char v224; // ST80_1
  __int64 v225; // rbp
  __int64 v226; // r13
  __int64 v227; // rax
  __int64 v228; // r13
  __int64 v229; // rax
  __int64 v230; // r13
  __int64 v231; // rax
  __int64 v232; // r13
  __int64 v233; // rax
  char *v234; // rbp
  __int64 v235; // r13
  __int64 v236; // rax
  __int64 v237; // r8
  __int64 v238; // r9
  char v239; // ST90_1
  _QWORD *v240; // rbp
  __int64 v241; // r14
  __int64 v242; // rax
  __int64 v243; // rax
  __int64 v244; // rax
  __int64 v245; // STA0_8
  __int64 v246; // r14
  __int64 v247; // rax
  __int64 v248; // rax
  __int64 v249; // STA0_8
  __int64 v250; // r14
  __int64 v251; // rax
  __int64 v252; // rax
  __int64 v253; // STA0_8
  __int64 v254; // r14
  __int64 v255; // rax
  __int64 v256; // rax
  __int64 v257; // r14
  __int64 v258; // rax
  __int64 v259; // rax
  __int64 v260; // rcx
  __int64 v261; // r8
  __int64 v262; // r9
  char v263; // ST80_1
  void **result; // rax
  __int64 v265; // rbp
  __int64 v266; // r14
  __int64 v267; // rax
  __int64 v268; // rbp
  __int64 v269; // r12
  __int64 v270; // rax
  __int64 v271; // r12
  __int64 v272; // rax
  __int64 v273; // r12
  __int64 v274; // rax
  __int64 v275; // r12
  __int64 v276; // rax
  __int64 v277; // rbp
  __int64 v278; // r13
  __int64 v279; // r12
  __int64 v280; // rax
  __int64 v281; // rbx
  __int64 v282; // r12
  __int64 v283; // rbp
  __int64 v284; // rax
  __int64 v285; // rbp
  __int64 v286; // rax
  __int64 v287; // rbp
  __int64 v288; // rax
  __int64 v289; // rbp
  __int64 v290; // rax
  __int64 v291; // ST98_8
  __int64 v292; // rbp
  __int64 v293; // r14
  __int64 v294; // rax
  __int64 v295; // rbp
  __int64 v296; // r14
  __int64 v297; // rax
  __int64 v298; // rbp
  __int64 v299; // r14
  __int64 v300; // rax
  __int64 v301; // rbp
  __int64 v302; // r14
  __int64 v303; // rax
  __int64 v304; // rax
  __int64 v305; // r14
  __int64 v306; // rax
  __int64 v307; // r14
  __int64 v308; // rax
  __int64 v309; // ST98_8
  __int64 v310; // r14
  __int64 v311; // rax
  __int64 v312; // rbp
  __int64 v313; // r13
  __int64 v314; // rax
  __int64 v315; // r13
  __int64 v316; // rax
  __int64 v317; // rbp
  __int64 v318; // r14
  __int64 v319; // r13
  __int64 v320; // rax
  __int64 v321; // r14
  __int64 v322; // r13
  __int64 v323; // rax
  __int64 v324; // r14
  __int64 v325; // r13
  __int64 v326; // rax
  __int64 v327; // rax
  __int64 v328; // rbp
  __int64 v329; // r13
  __int64 v330; // rax
  __int64 v331; // r13
  __int64 v332; // rax
  __int64 v333; // rbp
  __int64 v334; // r13
  __int64 v335; // rax
  __int64 v336; // r13
  __int64 v337; // rax
  __int64 v338; // r13
  __int64 v339; // rbp
  __int64 v340; // rax
  __int64 v341; // rbp
  __int64 v342; // rax
  __int64 v343; // r9
  __int64 v344; // rax
  __int64 *v345; // rbp
  __int64 v346; // r14
  __int64 v347; // rax
  __int64 v348; // rax
  __int64 v349; // r14
  __int64 v350; // rax
  __int64 v351; // r14
  __int64 v352; // rax
  __int64 v353; // rsi
  __int64 v354; // rax
  __int64 v355; // r14
  __int64 v356; // rax
  __int64 v357; // rax
  __int64 v358; // ST98_8
  __int64 v359; // r14
  __int64 v360; // rax
  __int64 v361; // rax
  __int64 v362; // ST98_8
  __int64 v363; // r14
  __int64 v364; // rax
  __int64 v365; // r14
  __int64 v366; // rax
  __int64 v367; // r14
  __int64 v368; // rax
  __int64 v369; // rax
  __int64 v370; // rsi
  __int64 v371; // rcx
  __int64 v372; // r8
  __int64 v373; // r9
  char v374; // ST90_1
  __int64 v375; // rbp
  __int64 v376; // r12
  __int64 v377; // rax
  __int64 v378; // r12
  __int64 v379; // rax
  __int64 v380; // r12
  __int64 v381; // rax
  __int64 v382; // r12
  __int64 v383; // rax
  __int64 v384; // r12
  __int64 v385; // rax
  __int64 v386; // rbp
  __int64 v387; // r12
  __int64 v388; // rax
  __int64 v389; // r12
  __int64 v390; // rax
  __int64 v391; // r12
  __int64 v392; // rax
  __int64 v393; // r12
  __int64 v394; // rax
  __int64 v395; // r12
  __int64 v396; // rax
  __int64 v397; // r12
  __int64 v398; // rax
  __int64 v399; // r12
  __int64 v400; // rax
  __int64 v401; // r12
  __int64 v402; // rax
  void **v403; // r12
  __int64 v404; // rbp
  __int64 v405; // r14
  __int64 v406; // r13
  __int64 v407; // rax
  __int64 v408; // rbp
  __int64 v409; // r14
  __int64 v410; // r13
  __int64 v411; // rax
  __int64 v412; // r14
  __int64 v413; // r13
  __int64 v414; // rax
  __int64 v415; // r14
  __int64 v416; // r13
  __int64 v417; // rax
  __int64 v418; // r13
  __int64 v419; // rax
  __int64 v420; // r12
  __int64 v421; // rax
  __int64 v422; // rbp
  __int64 v423; // r12
  __int64 v424; // rax
  __int64 v425; // r12
  __int64 v426; // rax
  __int64 v427; // rbp
  __int64 v428; // r14
  __int64 v429; // r13
  __int64 v430; // rax
  __int64 v431; // rbp
  __int64 v432; // r13
  __int64 v433; // rax
  __int64 v434; // r13
  __int64 v435; // rax
  __int64 v436; // STA0_8
  __int64 v437; // r13
  __int64 v438; // rax
  char *v439; // rbp
  __int64 v440; // STA0_8
  __int64 v441; // r13
  __int64 v442; // r14
  __int64 v443; // rax
  __int64 v444; // r13
  __int64 v445; // r14
  __int64 v446; // rbp
  __int64 v447; // rax
  __int64 v448; // rax
  char *v449; // rsi
  void *v450; // r14
  char *v451; // rbp
  __int64 v452; // r14
  __int64 v453; // rax
  __int64 v454; // rbp
  __int64 v455; // r14
  __int64 v456; // r13
  __int64 v457; // rax
  __int64 v458; // r14
  __int64 v459; // r13
  __int64 v460; // rax
  __int64 v461; // r13
  __int64 v462; // r8
  __int64 v463; // r9
  _QWORD *v464; // rbp
  __int64 v465; // STA0_8
  __int64 v466; // r14
  __int64 v467; // rax
  __int64 v468; // rax
  __int64 v469; // STA0_8
  __int64 v470; // r14
  __int64 v471; // rax
  __int64 v472; // rax
  __int64 v473; // r14
  __int64 v474; // rax
  __int64 v475; // rax
  __int64 v476; // r14
  __int64 v477; // rax
  __int64 v478; // rax
  __int64 v479; // rcx
  __int64 v480; // r8
  __int64 v481; // r9
  char v482; // ST90_1
  __int64 v483; // r14
  __int64 v484; // rax
  __int64 v485; // rax
  __int64 v486; // rax
  __int64 v487; // rbp
  __int64 v488; // r13
  __int64 v489; // rax
  __int64 v490; // r8
  __int64 v491; // r9
  __int64 v492; // r14
  __int64 v493; // r13
  __int64 v494; // rax
  __int64 v495; // r14
  __int64 v496; // r13
  __int64 v497; // rax
  __int64 v498; // rcx
  __int64 v499; // r8
  __int64 v500; // r9
  char v501; // ST90_1
  __int64 v502; // r14
  __int64 v503; // r13
  __int64 v504; // rax
  __int64 v505; // r13
  __int64 v506; // rax
  __int64 v507; // STA0_8
  __int64 v508; // rax
  __int64 v509; // STA8_8
  __int64 v510; // STA0_8
  __int64 v511; // rax
  __int64 v512; // STA8_8
  __int64 v513; // STA0_8
  __int64 v514; // rax
  __int64 v515; // STA8_8
  __int64 v516; // STA0_8
  __int64 v517; // rax
  __int64 v518; // STA0_8
  __int64 v519; // rax
  __int64 v520; // rbp
  __int64 v521; // r8
  __int64 v522; // r9
  __int64 v523; // rax
  _QWORD *v524; // r13
  __int64 v525; // r14
  __int64 v526; // rax
  __int64 v527; // rax
  __int64 v528; // r14
  __int64 v529; // rax
  __int64 v530; // rax
  __int64 v531; // rsi
  __int64 v532; // ST98_8
  __int64 v533; // r14
  __int64 v534; // rax
  __int64 v535; // rax
  __int64 v536; // r14
  __int64 v537; // rax
  __int64 v538; // rax
  __int64 v539; // rcx
  __int64 v540; // r8
  __int64 v541; // r9
  char v542; // ST80_1
  __int64 v543; // rbp
  __int64 v544; // r13
  __int64 v545; // rax
  __int64 v546; // r13
  __int64 v547; // rax
  __int64 v548; // rbp
  __int64 v549; // r13
  __int64 v550; // rax
  __int64 v551; // r13
  __int64 v552; // rax
  __int64 v553; // r13
  __int64 v554; // rax
  __int64 v555; // rbp
  __int64 v556; // r13
  __int64 v557; // rax
  __int64 v558; // r13
  __int64 v559; // rax
  __int64 v560; // r13
  __int64 v561; // rax
  __int64 v562; // rbp
  __int64 v563; // r13
  __int64 v564; // rax
  __int64 v565; // r13
  __int64 v566; // rax
  __int64 v567; // r13
  __int64 v568; // rax
  __int64 v569; // rbp
  __int64 v570; // r13
  __int64 v571; // rax
  __int64 v572; // r13
  __int64 v573; // rax
  __int64 v574; // r13
  __int64 v575; // rax
  __int64 v576; // rbp
  __int64 v577; // r13
  __int64 v578; // rax
  __int64 v579; // r13
  __int64 *v580; // rbp
  __int64 v581; // rax
  __int64 v582; // r14
  __int64 v583; // rax
  __int64 v584; // rax
  __int64 v585; // rax
  __int64 v586; // r8
  __int64 v587; // r9
  char v588; // ST90_1
  __int64 v589; // rax
  __int64 v590; // r14
  __int64 v591; // rax
  __int64 v592; // rax
  __int64 v593; // rcx
  __int64 v594; // r8
  __int64 v595; // r9
  char v596; // ST90_1
  __int64 v597; // r8
  __int64 v598; // r9
  char v599; // ST90_1
  __int64 v600; // r14
  __int64 v601; // rax
  __int64 v602; // rax
  __int64 v603; // ST98_8
  __int64 v604; // r14
  __int64 v605; // rax
  __int64 v606; // rax
  __int64 v607; // rdx
  __int64 v608; // rsi
  __int64 v609; // rbp
  __int64 v610; // r13
  __int64 v611; // rax
  __int64 v612; // r14
  __int64 v613; // r13
  __int64 v614; // rax
  __int64 v615; // r13
  __int64 v616; // rax
  __int64 v617; // rax
  _QWORD *v618; // r14
  __int64 v619; // r8
  __int64 v620; // r9
  __int64 v621; // r13
  __int64 v622; // r12
  __int64 v623; // rax
  __int64 v624; // rax
  __int64 v625; // r13
  __int64 v626; // r12
  __int64 v627; // rax
  __int64 v628; // rax
  __int64 v629; // rcx
  __int64 v630; // r8
  __int64 v631; // r9
  char v632; // ST90_1
  __int64 v633; // rax
  __int64 v634; // r8
  __int64 v635; // r9
  char v636; // ST90_1
  __int64 v637; // r12
  __int64 v638; // rax
  __int64 v639; // rax
  void *v640; // rdi
  __int64 v641; // r13
  void *v642; // rax
  void *v643; // rdi
  void *v644; // rax
  void *v645; // rdi
  void *v646; // rax
  void ***v647; // r12
  void **v648; // rbx
  char **v649; // rbp
  unsigned int v650; // ecx
  char *v651; // rax
  __int64 v652; // rax
  char **v653; // r12
  __int64 v654; // r12
  __int64 v655; // rax
  __int64 v656; // rax
  __int64 v657; // rdx
  __int64 v658; // rcx
  __int64 v659; // r8
  __int64 v660; // r9
  char v661; // ST80_1
  __int64 v662; // r13
  __int64 v663; // rax
  __int64 v664; // rax
  __int64 v665; // r13
  __int64 v666; // rax
  __int64 v667; // rax
  __int64 v668; // r13
  __int64 v669; // rax
  __int64 v670; // rax
  __int64 v671; // rcx
  __int64 v672; // r8
  __int64 v673; // r9
  __int64 v674; // STA0_8
  __int64 v675; // r12
  __int64 v676; // rax
  __int64 v677; // rbp
  __int64 v678; // r8
  __int64 v679; // r9
  __int64 v680; // STA0_8
  __int64 v681; // r14
  __int64 v682; // rax
  __int64 v683; // STA0_8
  __int64 v684; // r14
  __int64 v685; // rax
  __int64 v686; // rcx
  __int64 v687; // r8
  __int64 v688; // r9
  char v689; // ST90_1
  __int64 v690; // rbp
  __int64 v691; // rax
  __int64 v692; // r14
  __int64 v693; // rax
  __int64 v694; // r13
  __int64 v695; // rax
  char v696; // [rsp+10h] [rbp-78h]
  char v697; // [rsp+10h] [rbp-78h]
  char v698; // [rsp+10h] [rbp-78h]
  char v699; // [rsp+10h] [rbp-78h]
  int v700; // [rsp+14h] [rbp-74h]
  int v701; // [rsp+14h] [rbp-74h]
  bool v702; // [rsp+18h] [rbp-70h]
  __int64 v703; // [rsp+18h] [rbp-70h]
  __int64 v704; // [rsp+20h] [rbp-68h]
  __int64 v705; // [rsp+28h] [rbp-60h]
  unsigned __int64 *v706; // [rsp+30h] [rbp-58h]
  bool v707; // [rsp+4Ah] [rbp-3Eh]
  bool v708; // [rsp+4Bh] [rbp-3Dh]
  int v709; // [rsp+4Ch] [rbp-3Ch]

  v4 = a2;
  v5 = (unsigned __int64 *)a1;
  v709 = a4;
  v6 = (_QWORD *)sub_28B80(a1, 96LL, (__int64)sub_20250);
  v7 = (__int64)v6;
  *v6 = 0LL;
  v6[11] = 0LL;
  memset(
    (void *)((unsigned __int64)(v6 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v6 - (((_DWORD)v6 + 8) & 0xFFFFFFF8) + 96) >> 3));
  v6[11] = sub_BC120(&locale);
  *(_BYTE *)(v7 + 80) = a2;
  v8 = sub_28A10((unsigned __int64 *)a1, &locale, &locale, &locale);
  sub_28C10(v8, 5, 20LL, 20LL, 20LL, 20LL, 20);
  v9 = sub_28770(v7);
  v10 = sub_28770(0LL);
  v11 = "Apply";
  v12 = (unsigned __int8)v4 < 1u ? 111 : 97;
  if ( !v4 )
    v11 = "Open";
  v13 = sub_290C0(v8, v11, v12, v10, (__int64)sub_21DC0, v9);
  *(_QWORD *)(v7 + 40) = v13;
  *(_BYTE *)(v13 + 57) = 1;
  *(_DWORD *)(v13 + 20) = 3;
  v14 = sub_28770(v7);
  v15 = sub_28770(0LL);
  v16 = sub_290C0(v8, "Cancel", 99, v15, (__int64)sub_21DC0, v14);
  *(_QWORD *)(v7 + 48) = v16;
  *(_BYTE *)(v16 + 58) = 1;
  *(_DWORD *)(v16 + 20) = 4;
  v17 = sub_BC360((__int64)"Basic options for your %s session", "PuTTY");
  sub_28930((unsigned __int64 *)a1, "Session", v17);
  sub_2F4D0(v17);
  v18 = "Save the current session settings";
  v707 = !v4;
  if ( !v4 )
  {
    v617 = sub_28C00(a1, 40LL);
    *(_QWORD *)(v617 + 32) = 0LL;
    v704 = v617;
    v618 = (_QWORD *)v617;
    *(_OWORD *)v617 = 0LL;
    *(_OWORD *)(v617 + 16) = 0LL;
    v703 = sub_28A10((unsigned __int64 *)a1, "Session", "hostport", "Specify the destination you want to connect to");
    sub_28C10(v703, 2, 75LL, 25LL, v619, v620, v696);
    v621 = sub_28760(0);
    v622 = sub_28760(0);
    v623 = sub_28770(0LL);
    v624 = sub_28D60(v703, "Host Name (or IP address)", 110, 100, v623, (__int64)sub_23070, v622, v621);
    *(_DWORD *)(v624 + 20) = 0;
    *v618 = v624;
    v625 = sub_28760(0);
    v626 = sub_28760(0);
    v627 = sub_28770(0LL);
    v628 = sub_28D60(v703, "Port", 112, 100, v627, (__int64)sub_22F10, v626, v625);
    *(_DWORD *)(v628 + 20) = 1;
    v618[1] = v628;
    sub_28C10(v703, 1, 100LL, v629, v630, v631, v632);
    v633 = sub_28770(0LL);
    sub_29350(v703, "Connection type:", v633);
    sub_28C10(v703, 2, 62LL, 38LL, v634, v635, v636);
    v637 = sub_28770((__int64)v618);
    v638 = sub_28770(0LL);
    v639 = sub_28E40(v703, 0LL, 0, 3, v638, (__int64)sub_20810, v637, 0);
    v640 = *(void **)(v639 + 72);
    v641 = v639;
    *(_DWORD *)(v639 + 20) = 0;
    v618[2] = v639;
    v642 = sub_2F490(v640, 7uLL, 8uLL);
    v643 = *(void **)(v641 + 80);
    *(_QWORD *)(v641 + 72) = v642;
    v644 = sub_2F490(v643, 7uLL, 1uLL);
    v645 = *(void **)(v641 + 88);
    *(_QWORD *)(v641 + 80) = v644;
    v646 = sub_2F490(v645, 7uLL, 8uLL);
    LODWORD(v637) = *(_DWORD *)(v641 + 64);
    *(_QWORD *)(v641 + 88) = v646;
    if ( (_DWORD)v637 )
      __assert_fail("c->radio.nbuttons == 0", "config.c", 0x6DFu, "setup_config_box");
    v647 = &off_323400;
    v705 = v7;
    v706 = v5;
    do
    {
      v648 = *v647;
      if ( !*v647 )
        __assert_fail("backends[i]", "config.c", 0x6E3u, "setup_config_box");
      v649 = (char **)(*(_QWORD *)(v641 + 72) + 8LL * *(signed int *)(v641 + 64));
      v651 = sub_BC120((char *)v648[18]);
      v650 = *((_DWORD *)v648 + 38);
      *v649 = v651;
      LOBYTE(v651) = 115;
      if ( v650 != 3 )
      {
        LOBYTE(v651) = 114;
        if ( v650 != 5 )
          LODWORD(v651) = v650 < 1 ? 0x77 : 0;
      }
      ++v647;
      *(_BYTE *)(*(_QWORD *)(v641 + 80) + *(signed int *)(v641 + 64)) = (_BYTE)v651;
      *(_QWORD *)(*(_QWORD *)(v641 + 88) + 8LL * *(signed int *)(v641 + 64)) = sub_28760(*((_DWORD *)v648 + 38));
      LODWORD(v652) = *(_DWORD *)(v641 + 64) + 1;
      *(_DWORD *)(v641 + 64) = v652;
    }
    while ( &off_323400 + 2 != v647 );
    v652 = (signed int)v652;
    v7 = v705;
    v5 = v706;
    if ( !(&off_323400)[(signed int)v652] )
      __assert_fail("backends[c->radio.nbuttons]", "config.c", 0x6F0u, "setup_config_box");
    v653 = (char **)(*(_QWORD *)(v641 + 72) + 8 * v652);
    *v653 = sub_BC120("Other:");
    *(_BYTE *)(*(_QWORD *)(v641 + 80) + *(signed int *)(v641 + 64)) = 116;
    *(_QWORD *)(*(_QWORD *)(v641 + 88) + 8LL * (signed int)(*(_DWORD *)(v641 + 64))++) = sub_28760(0xFFFFFFFF);
    v654 = sub_28770(v704);
    v655 = sub_28770(0LL);
    v656 = sub_29180(v703, 0LL, 0, 100, v655, (__int64)sub_20810, v654);
    v657 = *(_QWORD *)(v704 + 16);
    *(_QWORD *)(v704 + 24) = v656;
    *(_DWORD *)(v656 + 20) = 1;
    *(_QWORD *)(v656 + 48) = v657;
    sub_28C10(v703, 1, 100LL, v658, v659, v660, v661);
    v18 = "Load, save or delete a stored session";
  }
  v19 = sub_28A10(v5, "Session", "savedsessions", v18);
  sub_28C10(v19, 2, 75LL, 25LL, v20, v21, v696);
  sub_40A70(v7 + 56, 1LL);
  v22 = sub_28770(0LL);
  v23 = sub_28770(v7);
  v24 = sub_28770(0LL);
  v25 = sub_28D60(v19, "Saved Sessions", 101, 100, v24, (__int64)sub_21DC0, v23, v22);
  *(_QWORD *)v7 = v25;
  *(_DWORD *)(v25 + 20) = 0;
  sub_28C10(v19, 1, 100LL, v26, v27, v28, v29);
  sub_28C10(v19, 2, 75LL, 25LL, v30, v31, v32);
  v33 = sub_28770(v7);
  v34 = sub_28770(0LL);
  v35 = sub_29110(v19, 0LL, 0, v34, (__int64)sub_21DC0, v33);
  *(_QWORD *)(v7 + 8) = v35;
  *(_DWORD *)(v35 + 20) = 0;
  *(_DWORD *)(v35 + 60) = 7;
  v702 = v36 == 3;
  if ( v4 )
  {
    *(_QWORD *)(v7 + 16) = 0LL;
    v37 = sub_28770(v7);
    v38 = sub_28770(0LL);
    v39 = sub_290C0(v19, "Save", 118, v38, (__int64)sub_21DC0, v37);
    *(_QWORD *)(v7 + 24) = v39;
    *(_DWORD *)(v39 + 20) = 1;
    *(_QWORD *)(v7 + 32) = 0LL;
    sub_28C10(v19, 1, 100LL, v40, v41, v42, v697);
    v43 = sub_28A10(v5, "Session", "otheropts", 0LL);
    sub_28760(2u);
    sub_28760(1u);
    sub_28760(0);
    v44 = sub_28760(4u);
    v45 = sub_28770(0LL);
    sub_28E40(v43, "Close window on exit:", 120, 4, v45, (__int64)sub_22230, v44, (unsigned __int64)"Always");
    sub_28930(v5, "Session/Logging", "Options controlling session logging");
    v46 = sub_28A10(v5, "Session/Logging", "main", 0LL);
    v47 = 0;
    if ( v700 == 3 )
      v47 = v4;
    v708 = v47;
    v702 = v47;
  }
  else
  {
    v662 = sub_28770(v7);
    v663 = sub_28770(0LL);
    v664 = sub_290C0(v19, "Load", 108, v663, (__int64)sub_21DC0, v662);
    *(_QWORD *)(v7 + 16) = v664;
    *(_DWORD *)(v664 + 20) = 1;
    v665 = sub_28770(v7);
    v666 = sub_28770(0LL);
    v667 = sub_290C0(v19, "Save", 118, v666, (__int64)sub_21DC0, v665);
    *(_QWORD *)(v7 + 24) = v667;
    *(_DWORD *)(v667 + 20) = 1;
    v668 = sub_28770(v7);
    v669 = sub_28770(0LL);
    v670 = sub_290C0(v19, "Delete", 100, v669, (__int64)sub_21DC0, v668);
    *(_QWORD *)(v7 + 32) = v670;
    *(_DWORD *)(v670 + 20) = 1;
    sub_28C10(v19, 1, 100LL, v671, v672, v673, v697);
    v674 = sub_28A10(v5, "Session", "otheropts", 0LL);
    sub_28760(2u);
    sub_28760(1u);
    sub_28760(0);
    v675 = sub_28760(4u);
    v676 = sub_28770(0LL);
    sub_28E40(v674, "Close window on exit:", 120, 4, v676, (__int64)sub_22230, v675, (unsigned __int64)"Always");
    sub_28930(v5, "Session/Logging", "Options controlling session logging");
    v46 = sub_28A10(v5, "Session/Logging", "main", 0LL);
    sub_3CFD0(3);
    v708 = 0;
  }
  sub_28760(4u);
  sub_28760(3u);
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v48 = sub_28760(0x80u);
  v49 = sub_28770(0LL);
  sub_28E40(v46, "Session logging:", 0, 2, v49, (__int64)sub_22330, v48, (unsigned __int64)"None");
  v50 = sub_28760(0x7Fu);
  v51 = sub_28770(0LL);
  sub_29270(v46, "Log file name:", 102, 0LL, 1, (char *)&unk_E04D7, v51, (__int64)sub_20150, v50);
  v52 = sub_28770(0LL);
  sub_29350(
    v46,
    "(Log file name can contain &Y, &M, &D for date, &T for time, &H for host name, and &P for port number)",
    v52);
  sub_28760(0xFFFFFFFF);
  sub_28760(0);
  sub_28760(1u);
  v53 = sub_28760(0x81u);
  v54 = sub_28770(0LL);
  sub_28E40(
    v46,
    "What to do if the log file already exists:",
    101,
    1,
    v54,
    (__int64)sub_22230,
    v53,
    (unsigned __int64)"Always overwrite it");
  v55 = sub_28760(0x82u);
  v56 = sub_28770(0LL);
  sub_29380(v46, "Flush log file frequently", 117, v56, (__int64)sub_1FF00, v55);
  v57 = sub_28760(0x83u);
  v58 = sub_28770(0LL);
  sub_29380(v46, "Include header", 105, v58, (__int64)sub_1FF00, v57);
  if ( v708 || !v4 && sub_3CFD0(3) )
  {
    v422 = sub_28A10(v5, "Session/Logging", "ssh", "Options specific to SSH packet logging");
    v423 = sub_28760(0x84u);
    v424 = sub_28770(0LL);
    sub_29380(v422, "Omit known password fields", 107, v424, (__int64)sub_1FF00, v423);
    v425 = sub_28760(0x85u);
    v426 = sub_28770(0LL);
    sub_29380(v422, (char *)&unk_E0577, 100, v426, (__int64)sub_1FF00, v425);
  }
  sub_28930(v5, "Terminal", "Options controlling the terminal emulation");
  v59 = sub_28A10(v5, "Terminal", "general", "Set various terminal options");
  v60 = sub_28760(0x6Au);
  v61 = sub_28770(0LL);
  sub_29380(v59, "Auto wrap mode initially on", 119, v61, (__int64)sub_1FF00, v60);
  v62 = sub_28760(0x69u);
  v63 = sub_28770(0LL);
  sub_29380(v59, "DEC Origin Mode initially on", 100, v63, (__int64)sub_1FF00, v62);
  v64 = sub_28760(0x6Bu);
  v65 = sub_28770(0LL);
  sub_29380(v59, "Implicit CR in every LF", 114, v65, (__int64)sub_1FF00, v64);
  v66 = sub_28760(0xC9u);
  v67 = sub_28770(0LL);
  sub_29380(v59, "Implicit LF in every CR", 102, v67, (__int64)sub_1FF00, v66);
  v68 = sub_28760(0x78u);
  v69 = sub_28770(0LL);
  sub_29380(v59, "Use background colour to erase screen", 101, v69, (__int64)sub_1FF00, v68);
  v70 = sub_28760(0x79u);
  v71 = sub_28770(0LL);
  sub_29380(v59, "Enable blinking text", 110, v71, (__int64)sub_1FF00, v70);
  v72 = sub_28760(1u);
  v73 = sub_28760(0x89u);
  v74 = sub_28770(0LL);
  sub_28D60(v59, "Answerback to ^E:", 115, 100, v74, (__int64)sub_1FF90, v73, v72);
  v75 = sub_28A10(v5, "Terminal", "ldisc", "Line discipline options");
  sub_28760(1u);
  sub_28760(0);
  sub_28760(2u);
  v76 = sub_28760(0x5Cu);
  v77 = sub_28770(0LL);
  sub_28E40(v75, "Local echo:", 108, 3, v77, (__int64)sub_22230, v76, (unsigned __int64)"Auto");
  sub_28760(1u);
  sub_28760(0);
  sub_28760(2u);
  v78 = sub_28760(0x5Du);
  v79 = sub_28770(0LL);
  sub_28E40(v75, "Local line editing:", 116, 3, v79, (__int64)sub_22230, v78, (unsigned __int64)"Auto");
  v80 = sub_28A10(v5, "Terminal", "printing", "Remote-controlled printing");
  v81 = sub_28770(0LL);
  v82 = sub_28770(0LL);
  v83 = sub_28770(0LL);
  sub_28DD0(v80, "Printer to send ANSI printer output to:", 112, 100, v83, (__int64)sub_22DB0, v82, v81);
  sub_28930(v5, "Terminal/Keyboard", "Options controlling the effects of keys");
  v84 = sub_28A10(v5, "Terminal/Keyboard", "mappings", "Change the sequences sent by:");
  sub_28760(1u);
  sub_28760(0);
  v85 = sub_28760(0x47u);
  v86 = sub_28770(0LL);
  sub_28E40(v84, "The Backspace key", 98, 2, v86, (__int64)sub_22420, v85, (unsigned __int64)"Control-H");
  sub_28760(1u);
  sub_28760(0);
  v87 = sub_28760(0x48u);
  v88 = sub_28770(0LL);
  sub_28E40(v84, "The Home and End keys", 101, 2, v88, (__int64)sub_22420, v87, (unsigned __int64)"Standard");
  sub_28760(5u);
  sub_28760(4u);
  sub_28760(3u);
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v89 = sub_28760(0x49u);
  v90 = sub_28770(0LL);
  sub_28E40(v84, "The Function keys and keypad", 102, 3, v90, (__int64)sub_22230, v89, (unsigned __int64)"ESC[n~");
  v91 = sub_28A10(v5, "Terminal/Keyboard", "appkeypad", "Application keypad settings:");
  sub_28760(1u);
  sub_28760(0);
  v92 = sub_28760(0x54u);
  v93 = sub_28770(0LL);
  sub_28E40(v91, "Initial state of cursor keys:", 114, 3, v93, (__int64)sub_22420, v92, (unsigned __int64)"Normal");
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v94 = sub_28770(0LL);
  v95 = sub_28770(0LL);
  sub_28E40(v91, "Initial state of numeric keypad:", 110, 3, v95, (__int64)sub_22530, v94, (unsigned __int64)"Normal");
  sub_28930(v5, "Terminal/Bell", "Options controlling the terminal bell");
  v96 = sub_28A10(v5, "Terminal/Bell", "style", "Set the style of bell");
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v97 = sub_28760(0x6Eu);
  v98 = sub_28770(0LL);
  sub_28E40(
    v96,
    "Action to happen when a bell occurs:",
    98,
    1,
    v98,
    (__int64)sub_22230,
    v97,
    (unsigned __int64)"None (bell disabled)");
  v99 = sub_28A10(v5, "Terminal/Bell", "overload", "Control the bell overload behaviour");
  v100 = sub_28760(0x70u);
  v101 = sub_28770(0LL);
  sub_29380(v99, "Bell is temporarily disabled when over-used", 100, v101, (__int64)sub_1FF00, v100);
  v102 = sub_28760(0xFFFFFFFF);
  v103 = sub_28760(0x71u);
  v104 = sub_28770(0LL);
  sub_28D60(v99, "Over-use means this many bells...", 109, 20, v104, (__int64)sub_1FF90, v103, v102);
  v105 = sub_28760(0xFFFFFC18);
  v106 = sub_28760(0x72u);
  v107 = sub_28770(0LL);
  sub_28D60(v99, "... in this many seconds", 116, 20, v107, (__int64)sub_1FF90, v106, v105);
  v108 = sub_28770(0LL);
  sub_29350(v99, "The bell is re-enabled after a few seconds of silence.", v108);
  v109 = sub_28760(0xFFFFFC18);
  v110 = sub_28760(0x73u);
  v111 = sub_28770(0LL);
  sub_28D60(v99, "Seconds of silence required", 115, 20, v111, (__int64)sub_1FF90, v110, v109);
  sub_28930(v5, "Terminal/Features", "Enabling and disabling advanced terminal features");
  v112 = sub_28A10(v5, "Terminal/Features", "main", 0LL);
  v113 = sub_28760(0x4Au);
  v114 = sub_28770(0LL);
  sub_29380(v112, "Disable application cursor keys mode", 117, v114, (__int64)sub_1FF00, v113);
  v115 = sub_28760(0x4Bu);
  v116 = sub_28770(0LL);
  sub_29380(v112, "Disable application keypad mode", 107, v116, (__int64)sub_1FF00, v115);
  v117 = sub_28760(0x4Cu);
  v118 = sub_28770(0LL);
  sub_29380(v112, "Disable xterm-style mouse reporting", 120, v118, (__int64)sub_1FF00, v117);
  v119 = sub_28760(0x4Du);
  v120 = sub_28770(0LL);
  sub_29380(v112, "Disable remote-controlled terminal resizing", 115, v120, (__int64)sub_1FF00, v119);
  v121 = sub_28760(0x4Eu);
  v122 = sub_28770(0LL);
  sub_29380(v112, "Disable switching to alternate terminal screen", 119, v122, (__int64)sub_1FF00, v121);
  v123 = sub_28760(0x4Fu);
  v124 = sub_28770(0LL);
  sub_29380(v112, "Disable remote-controlled window title changing", 116, v124, (__int64)sub_1FF00, v123);
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v125 = sub_28760(0x53u);
  v126 = sub_28770(0LL);
  sub_28E40(
    v112,
    "Response to remote title query (SECURITY):",
    113,
    3,
    v126,
    (__int64)sub_22230,
    v125,
    (unsigned __int64)"None");
  v127 = sub_28760(0x50u);
  v128 = sub_28770(0LL);
  sub_29380(v112, "Disable remote-controlled clearing of scrollback", 101, v128, (__int64)sub_1FF00, v127);
  v129 = sub_28760(0x51u);
  v130 = sub_28770(0LL);
  sub_29380(v112, "Disable destructive backspace on server sending ^?", 98, v130, (__int64)sub_1FF00, v129);
  v131 = sub_28760(0x52u);
  v132 = sub_28770(0LL);
  sub_29380(v112, "Disable remote-controlled character set configuration", 114, v132, (__int64)sub_1FF00, v131);
  v133 = sub_28760(0x8Bu);
  v134 = sub_28770(0LL);
  sub_29380(v112, "Disable Arabic text shaping", 108, v134, (__int64)sub_1FF00, v133);
  v135 = sub_28760(0x8Cu);
  v136 = sub_28770(0LL);
  sub_29380(v112, "Disable bidirectional text display", 100, v136, (__int64)sub_1FF00, v135);
  v137 = sub_BC360((__int64)"Options controlling %s's window", "PuTTY");
  sub_28930(v5, "Window", v137);
  sub_2F4D0(v137);
  v138 = sub_3CFD0(v700);
  if ( !v138 || !((_BYTE)v138[20] & 1) || !v4 )
  {
    v677 = sub_28A10(v5, "Window", "size", "Set the size of the window");
    sub_28C10(v677, 2, 50LL, 50LL, v678, v679, v698);
    v680 = sub_28760(0xFFFFFFFF);
    v681 = sub_28760(0x7Bu);
    v682 = sub_28770(0LL);
    *(_DWORD *)(sub_28D60(v677, "Columns", 109, 100, v682, (__int64)sub_1FF90, v681, v680) + 20) = 0;
    v683 = sub_28760(0xFFFFFFFF);
    v684 = sub_28760(0x7Cu);
    v685 = sub_28770(0LL);
    *(_DWORD *)(sub_28D60(v677, "Rows", 114, 100, v685, (__int64)sub_1FF90, v684, v683) + 20) = 1;
    sub_28C10(v677, 1, 100LL, v686, v687, v688, v689);
  }
  v139 = sub_28A10(v5, "Window", "scrollback", "Control the scrollback in the window");
  v140 = sub_28760(0xFFFFFFFF);
  v141 = sub_28760(0x68u);
  v142 = sub_28770(0LL);
  sub_28D60(v139, (char *)&unk_E08E6, 115, 50, v142, (__int64)sub_1FF90, v141, v140);
  v143 = sub_28760(0x75u);
  v144 = sub_28770(0LL);
  sub_29380(v139, "Display scrollbar", 100, v144, (__int64)sub_1FF00, v143);
  v145 = sub_28760(0x60u);
  v146 = sub_28770(0LL);
  sub_29380(v139, "Reset scrollback on keypress", 107, v146, (__int64)sub_1FF00, v145);
  v147 = sub_28760(0x61u);
  v148 = sub_28770(0LL);
  sub_29380(v139, "Reset scrollback on display activity", 112, v148, (__int64)sub_1FF00, v147);
  v149 = sub_28760(0x62u);
  v150 = sub_28770(0LL);
  sub_29380(v139, "Push erased text into scrollback", 101, v150, (__int64)sub_1FF00, v149);
  v151 = sub_BC360((__int64)"Configure the appearance of %s's window", "PuTTY");
  sub_28930(v5, "Window/Appearance", v151);
  sub_2F4D0(v151);
  v152 = sub_28A10(v5, "Window/Appearance", "cursor", "Adjust the use of the cursor");
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v153 = sub_28760(0x6Cu);
  v154 = sub_28770(0LL);
  sub_28E40(v152, "Cursor appearance:", 0, 3, v154, (__int64)sub_22230, v153, (unsigned __int64)"Block");
  v155 = sub_28760(0x6Du);
  v156 = sub_28770(0LL);
  sub_29380(v152, "Cursor blinks", 98, v156, (__int64)sub_1FF00, v155);
  v157 = sub_28A10(v5, "Window/Appearance", "font", "Font settings");
  v158 = sub_28760(0x7Du);
  v159 = sub_28770(0LL);
  sub_292F0(v157, "Font used in the terminal window", 110, v159, (__int64)sub_201D0, v158);
  v160 = sub_28A10(v5, "Window/Appearance", "mouse", "Adjust the use of the mouse pointer");
  v161 = sub_28760(0x86u);
  v162 = sub_28770(0LL);
  sub_29380(v160, "Hide mouse pointer when typing in window", 112, v162, (__int64)sub_1FF00, v161);
  v163 = sub_28A10(v5, "Window/Appearance", "border", "Adjust the window border");
  v164 = sub_28760(0xFFFFFFFF);
  v165 = sub_28760(0x88u);
  v166 = sub_28770(0LL);
  sub_28D60(v163, "Gap between text and window edge:", 101, 20, v166, (__int64)sub_1FF90, v165, v164);
  v167 = sub_BC360((__int64)"Configure the behaviour of %s's window", "PuTTY");
  sub_28930(v5, "Window/Behaviour", v167);
  sub_2F4D0(v167);
  v168 = sub_28A10(v5, "Window/Behaviour", "title", "Adjust the behaviour of the window title");
  v169 = sub_28760(1u);
  v170 = sub_28760(0x67u);
  v171 = sub_28770(0LL);
  sub_28D60(v168, "Window title:", 116, 100, v171, (__int64)sub_1FF90, v170, v169);
  v172 = sub_28760(0x4000007Au);
  v173 = sub_28770(0LL);
  sub_29380(v168, "Separate window and icon titles", 105, v173, (__int64)sub_1FF00, v172);
  v174 = sub_28A10(v5, "Window/Behaviour", "main", 0LL);
  v175 = sub_28760(5u);
  v176 = sub_28770(0LL);
  sub_29380(v174, "Warn before closing window", 119, v176, (__int64)sub_1FF00, v175);
  sub_28930(v5, "Window/Translation", "Options controlling character set translation");
  v177 = sub_28A10(v5, "Window/Translation", "trans", "Character set translation");
  v178 = sub_28770(0LL);
  v179 = sub_28770(0LL);
  v180 = sub_28770(0LL);
  sub_28DD0(v177, "Remote character set:", 114, 100, v180, (__int64)sub_22CB0, v179, v178);
  v181 = sub_28A10(v5, "Window/Translation", "tweaks", 0LL);
  v182 = sub_28760(0xA5u);
  v183 = sub_28770(0LL);
  sub_29380(v181, "Treat CJK ambiguous characters as wide", 119, v183, (__int64)sub_1FF00, v182);
  v184 = sub_BC360((__int64)"Adjust how %s handles line drawing characters", "PuTTY");
  v185 = sub_28A10(v5, "Window/Translation", "linedraw", v184);
  sub_2F4D0(v184);
  sub_28760(3u);
  sub_28760(4u);
  v186 = sub_28760(0xA3u);
  v187 = sub_28770(0LL);
  sub_28E40(
    v185,
    "Handling of line drawing characters:",
    0,
    1,
    v187,
    (__int64)sub_22230,
    v186,
    (unsigned __int64)"Use Unicode line drawing code points");
  v188 = sub_28760(0x97u);
  v189 = sub_28770(0LL);
  sub_29380(v185, "Copy and paste line drawing characters as lqqqk", 100, v189, (__int64)sub_1FF00, v188);
  v190 = sub_28760(0x98u);
  v191 = sub_28770(0LL);
  sub_29380(v185, "Enable VT100 line drawing even in UTF-8 mode", 56, v191, (__int64)sub_1FF00, v190);
  sub_28930(v5, "Window/Selection", "Options controlling copy and paste");
  v192 = sub_28A10(v5, "Window/Selection", "mouse", (char *)&unk_E0A59);
  v193 = sub_28760(0x9Au);
  v194 = sub_28770(0LL);
  sub_29380(v192, "Shift overrides application's use of mouse", 112, v194, (__int64)sub_1FF00, v193);
  sub_28760(1u);
  sub_28760(0);
  v195 = sub_28760(0x95u);
  v196 = sub_28770(0LL);
  sub_28E40(
    v192,
    "Default selection mode (Alt+drag does the other one):",
    0,
    2,
    v196,
    (__int64)sub_22420,
    v195,
    (unsigned __int64)"Normal");
  v197 = sub_28A10(v5, "Window/Selection", "clipboards", "Assign copy/paste actions to clipboards");
  v198 = sub_28760(0x9Cu);
  v199 = sub_28770(0LL);
  sub_29380(v197, "Auto-copy selected text to CLIPBOARD", 0, v199, (__int64)sub_1FF00, v198);
  v200 = sub_28770(0LL);
  sub_23140(v197, (__int64)"Mouse paste action:", v200, 0x9Du, 0xA0u);
  v201 = sub_28770(0LL);
  sub_23140(v197, (__int64)"{Ctrl,Shift} + Ins:", v201, 0x9Eu, 0xA1u);
  v202 = sub_28770(0LL);
  sub_23140(v197, (__int64)"Ctrl + Shift + {C,V}:", v202, 0x9Fu, 0xA2u);
  v203 = sub_28A10(v5, "Window/Selection", "paste", "Control pasting of text from clipboard to terminal");
  v204 = sub_28760(0x96u);
  v205 = sub_28770(0LL);
  sub_29380(v203, "Permit control characters in pasted text", 0, v205, (__int64)sub_1FF00, v204);
  sub_28930(v5, "Window/Selection/Copy", "Options controlling copying from terminal to clipboard");
  v206 = sub_28A10(v5, "Window/Selection/Copy", "charclass", "Classes of character that group together");
  v207 = (_QWORD *)sub_28C00((__int64)v5, 24LL);
  v208 = sub_28770((__int64)v207);
  v209 = sub_28770(0LL);
  v210 = sub_29110(v206, "Character classes:", 101, v209, (__int64)sub_21B40, v208);
  *v207 = v210;
  *(_DWORD *)(v210 + 68) = 1;
  *(_DWORD *)(v210 + 76) = 4;
  *(_QWORD *)(v210 + 80) = sub_2F450(4uLL, 4uLL, 0LL);
  v211 = *v207;
  **(_DWORD **)(*v207 + 80LL) = 15;
  *(_DWORD *)(*(_QWORD *)(v211 + 80) + 4LL) = 25;
  *(_DWORD *)(*(_QWORD *)(v211 + 80) + 8LL) = 20;
  *(_DWORD *)(*(_QWORD *)(v211 + 80) + 12LL) = 40;
  sub_28C10(v206, 2, 67LL, 33LL, v212, v213, v698);
  v214 = sub_28770(0LL);
  v215 = sub_28770((__int64)v207);
  v216 = sub_28770(0LL);
  v217 = sub_28D60(v206, "Set to class", 116, 50, v216, (__int64)sub_21B40, v215, v214);
  v207[1] = v217;
  *(_DWORD *)(v217 + 20) = 0;
  v218 = sub_28770((__int64)v207);
  v219 = sub_28770(0LL);
  v220 = sub_290C0(v206, "Set", 115, v219, (__int64)sub_21B40, v218);
  v207[2] = v220;
  *(_DWORD *)(v220 + 20) = 1;
  sub_28C10(v206, 1, 100LL, v221, v222, v223, v224);
  sub_28930(v5, "Window/Colours", "Options controlling use of colours");
  v225 = sub_28A10(v5, "Window/Colours", "general", "General options for colour usage");
  v226 = sub_28760(0x8Du);
  v227 = sub_28770(0LL);
  sub_29380(v225, "Allow terminal to specify ANSI colours", 105, v227, (__int64)sub_1FF00, v226);
  v228 = sub_28760(0x8Eu);
  v229 = sub_28770(0LL);
  sub_29380(v225, "Allow terminal to use xterm 256-colour mode", 50, v229, (__int64)sub_1FF00, v228);
  v230 = sub_28760(0x8Fu);
  v231 = sub_28770(0LL);
  sub_29380(v225, "Allow terminal to use 24-bit colours", 52, v231, (__int64)sub_1FF00, v230);
  sub_28760(3u);
  sub_28760(2u);
  sub_28760(1u);
  v232 = sub_28760(0x92u);
  v233 = sub_28770(0LL);
  sub_28E40(
    v225,
    "Indicate bolded text by changing:",
    98,
    3,
    v233,
    (__int64)sub_22230,
    v232,
    (unsigned __int64)"The font");
  v234 = sub_BC360((__int64)"Adjust the precise colours %s displays", "PuTTY");
  v235 = sub_28A10(v5, "Window/Colours", "adjust", v234);
  sub_2F4D0(v234);
  v236 = sub_28770(0LL);
  sub_29350(v235, "Select a colour from the list, and then click the Modify button to change its appearance.", v236);
  sub_28C10(v235, 2, 67LL, 33LL, v237, v238, v239);
  v240 = (_QWORD *)sub_28C00((__int64)v5, 40LL);
  v241 = sub_28770((__int64)v240);
  v242 = sub_28770(0LL);
  v243 = sub_29110(v235, "Select a colour to adjust:", 117, v242, (__int64)sub_21770, v241);
  *v240 = v243;
  *(_DWORD *)(v243 + 20) = 0;
  *(_DWORD *)(v243 + 60) = 7;
  v244 = sub_28770(0LL);
  *(_DWORD *)(sub_29350(v235, "RGB value:", v244) + 20) = 1;
  v245 = sub_28770(0LL);
  v246 = sub_28770((__int64)v240);
  v247 = sub_28770(0LL);
  v248 = sub_28D60(v235, "Red", 114, 50, v247, (__int64)sub_21770, v246, v245);
  v240[1] = v248;
  *(_DWORD *)(v248 + 20) = 1;
  v249 = sub_28770(0LL);
  v250 = sub_28770((__int64)v240);
  v251 = sub_28770(0LL);
  v252 = sub_28D60(v235, "Green", 110, 50, v251, (__int64)sub_21770, v250, v249);
  v240[2] = v252;
  *(_DWORD *)(v252 + 20) = 1;
  v253 = sub_28770(0LL);
  v254 = sub_28770((__int64)v240);
  v255 = sub_28770(0LL);
  v256 = sub_28D60(v235, "Blue", 101, 50, v255, (__int64)sub_21770, v254, v253);
  v240[3] = v256;
  *(_DWORD *)(v256 + 20) = 1;
  v257 = sub_28770((__int64)v240);
  v258 = sub_28770(0LL);
  v259 = sub_290C0(v235, "Modify", 109, v258, (__int64)sub_21770, v257);
  v240[4] = v259;
  *(_DWORD *)(v259 + 20) = 1;
  sub_28C10(v235, 1, 100LL, v260, v261, v262, v263);
  if ( v701 >= 0 )
  {
    sub_28930(v5, "Connection", "Options controlling the connection");
    v427 = sub_28A10(v5, "Connection", "keepalive", "Sending of null packets to keep session active");
    v428 = sub_28760(0xFFFFFFFF);
    v429 = sub_28760(6u);
    v430 = sub_28770(0LL);
    sub_28D60(v427, "Seconds between keepalives (0 to turn off)", 107, 20, v430, (__int64)sub_1FF90, v429, v428);
    if ( v4 )
      goto LABEL_15;
    v431 = sub_28A10(v5, "Connection", "tcp", "Low-level TCP connection options");
    v432 = sub_28760(7u);
    v433 = sub_28770(0LL);
    sub_29380(v431, "Disable Nagle's algorithm (TCP_NODELAY option)", 110, v433, (__int64)sub_1FF00, v432);
    v434 = sub_28760(8u);
    v435 = sub_28770(0LL);
    sub_29380(v431, "Enable TCP keepalives (SO_KEEPALIVE option)", 112, v435, (__int64)sub_1FF00, v434);
    v436 = sub_28A10(v5, "Connection", "ipversion", "Internet protocol version");
    sub_28760(2u);
    sub_28760(1u);
    sub_28760(0);
    v437 = sub_28760(3u);
    v438 = sub_28770(0LL);
    v439 = "Logical name of remote host:";
    sub_28E40(v436, 0LL, 0, 3, v438, (__int64)sub_22230, v437, (unsigned __int64)"Auto");
    if ( sub_3CFD0(3) )
      v439 = "Logical name of remote host (e.g. for SSH key lookup):";
    v440 = sub_28A10(v5, "Connection", "identity", (char *)&unk_E0BB6);
    v441 = sub_28760(1u);
    v442 = sub_28760(9u);
    v443 = sub_28770(0LL);
    sub_28D60(v440, v439, 109, 100, v443, (__int64)sub_1FF90, v442, v441);
    sub_28930(v5, "Connection/Data", (char *)&unk_E0BDB);
    v444 = sub_28A10(v5, "Connection/Data", "login", "Login details");
    v445 = sub_28760(1u);
    v446 = sub_28760(0x38u);
    v447 = sub_28770(0LL);
    sub_28D60(v444, "Auto-login username", 117, 50, v447, (__int64)sub_1FF90, v446, v445);
    v448 = sub_B4EC0();
    v449 = &locale;
    v450 = (void *)v448;
    if ( v448 )
      v449 = (char *)v448;
    v451 = sub_BC360((__int64)&unk_E0C28, v449);
    sub_2F4D0(v450);
    sub_28760(1u);
    sub_28760(0);
    v452 = sub_28760(0x39u);
    v453 = sub_28770(0LL);
    sub_28E40(
      v444,
      "When username is not specified:",
      110,
      4,
      v453,
      (__int64)sub_22420,
      v452,
      (unsigned __int64)"Prompt");
    sub_2F4D0(v451);
    v454 = sub_28A10(v5, "Connection/Data", "term", "Terminal details");
    v455 = sub_28760(1u);
    v456 = sub_28760(0x34u);
    v457 = sub_28770(0LL);
    sub_28D60(v454, "Terminal-type string", 116, 50, v457, (__int64)sub_1FF90, v456, v455);
    v458 = sub_28760(1u);
    v459 = sub_28760(0x35u);
    v460 = sub_28770(0LL);
    sub_28D60(v454, "Terminal speeds", 115, 50, v460, (__int64)sub_1FF90, v459, v458);
    v461 = sub_28A10(v5, "Connection/Data", "env", "Environment variables");
    sub_28C10(v461, 2, 80LL, 20LL, v462, v463, v699);
    v464 = (_QWORD *)sub_28C00((__int64)v5, 40LL);
    v465 = sub_28770(0LL);
    v466 = sub_28770((__int64)v464);
    v467 = sub_28770(0LL);
    v468 = sub_28D60(v461, "Variable", 118, 60, v467, (__int64)sub_212F0, v466, v465);
    *v464 = v468;
    *(_DWORD *)(v468 + 20) = 0;
    v469 = sub_28770(0LL);
    v470 = sub_28770((__int64)v464);
    v471 = sub_28770(0LL);
    v472 = sub_28D60(v461, "Value", 108, 60, v471, (__int64)sub_212F0, v470, v469);
    v464[1] = v472;
    *(_DWORD *)(v472 + 20) = 0;
    v473 = sub_28770((__int64)v464);
    v474 = sub_28770(0LL);
    v475 = sub_290C0(v461, "Add", 100, v474, (__int64)sub_212F0, v473);
    v464[2] = v475;
    *(_DWORD *)(v475 + 20) = 1;
    v476 = sub_28770((__int64)v464);
    v477 = sub_28770(0LL);
    v478 = sub_290C0(v461, "Remove", 114, v477, (__int64)sub_212F0, v476);
    v464[3] = v478;
    *(_DWORD *)(v478 + 20) = 1;
    sub_28C10(v461, 1, 100LL, v479, v480, v481, v482);
    v483 = sub_28770((__int64)v464);
    v484 = sub_28770(0LL);
    v485 = sub_29110(v461, 0LL, 0, v484, (__int64)sub_212F0, v483);
    v464[4] = v485;
    *(_DWORD *)(v485 + 60) = 3;
    *(_DWORD *)(v485 + 76) = 2;
    *(_QWORD *)(v485 + 80) = sub_2F450(2uLL, 4uLL, 0LL);
    v486 = v464[4];
    **(_DWORD **)(v486 + 80) = 30;
    *(_DWORD *)(*(_QWORD *)(v486 + 80) + 4LL) = 70;
  }
  else if ( v4 )
  {
    goto LABEL_15;
  }
  sub_28930(v5, "Connection/Proxy", "Options controlling proxy usage");
  v487 = sub_28A10(v5, "Connection/Proxy", "basics", 0LL);
  sub_28760(4u);
  sub_28760(3u);
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v488 = sub_28760(0xDu);
  v489 = sub_28770(0LL);
  sub_28E40(v487, "Proxy type:", 116, 3, v489, (__int64)sub_22230, v488, (unsigned __int64)"None");
  sub_28C10(v487, 2, 80LL, 20LL, v490, v491, v699);
  v492 = sub_28760(1u);
  v493 = sub_28760(0xEu);
  v494 = sub_28770(0LL);
  *(_DWORD *)(sub_28D60(v487, "Proxy hostname", 121, 100, v494, (__int64)sub_1FF90, v493, v492) + 20) = 0;
  v495 = sub_28760(0xFFFFFFFF);
  v496 = sub_28760(0xFu);
  v497 = sub_28770(0LL);
  *(_DWORD *)(sub_28D60(v487, "Port", 112, 100, v497, (__int64)sub_1FF90, v496, v495) + 20) = 1;
  sub_28C10(v487, 1, 100LL, v498, v499, v500, v501);
  v502 = sub_28760(1u);
  v503 = sub_28760(0xAu);
  v504 = sub_28770(0LL);
  sub_28D60(v487, "Exclude Hosts/IPs", 101, 100, v504, (__int64)sub_1FF90, v503, v502);
  v505 = sub_28760(0xCu);
  v506 = sub_28770(0LL);
  sub_29380(v487, "Consider proxying local host connections", 120, v506, (__int64)sub_1FF00, v505);
  sub_28760(0);
  sub_28760(2u);
  sub_28760(1u);
  v507 = sub_28760(0xBu);
  v508 = sub_28770(0LL);
  sub_28E40(v487, "Do DNS name lookup at proxy end:", 100, 3, v508, (__int64)sub_22230, v507, (unsigned __int64)"No");
  v509 = sub_28760(1u);
  v510 = sub_28760(0x10u);
  v511 = sub_28770(0LL);
  sub_28D60(v487, "Username", 117, 60, v511, (__int64)sub_1FF90, v510, v509);
  v512 = sub_28760(1u);
  v513 = sub_28760(0x11u);
  v514 = sub_28770(0LL);
  *(_BYTE *)(sub_28D60(v487, "Password", 119, 60, v514, (__int64)sub_1FF90, v513, v512) + 64) = 1;
  v515 = sub_28760(1u);
  v516 = sub_28760(0x12u);
  v517 = sub_28770(0LL);
  sub_28D60(v487, "Telnet command", 109, 100, v517, (__int64)sub_1FF90, v516, v515);
  sub_28760(2u);
  sub_28760(0);
  sub_28760(1u);
  v518 = sub_28760(0x13u);
  v519 = sub_28770(0LL);
  sub_28E40(
    v487,
    "Print proxy diagnostics in the terminal window",
    114,
    5,
    v519,
    (__int64)sub_22230,
    v518,
    (unsigned __int64)"No");
LABEL_15:
  if ( (!sub_3CFD0(3) || !v707 && !v702) && (!sub_3CFD0(4) || v701 != 4 && !v707) )
    goto LABEL_21;
  sub_28930(v5, "Connection/SSH", "Options controlling SSH connections");
  if ( !v4 )
  {
    v291 = sub_28A10(v5, "Connection/SSH", "data", (char *)&unk_E0BDB);
    v292 = sub_28760(1u);
    v293 = sub_28760(0x14u);
    v294 = sub_28770(0LL);
    sub_28D60(v291, "Remote command:", 114, 100, v294, (__int64)sub_1FF90, v293, v292);
    v295 = sub_28A10(v5, "Connection/SSH", "protocol", "Protocol options");
    v296 = sub_28760(0x31u);
    v297 = sub_28770(0LL);
    sub_29380(v295, "Don't start a shell or command at all", 110, v297, (__int64)sub_1FF00, v296);
    v298 = sub_28A10(v5, "Connection/SSH", "protocol", "Protocol options");
    v299 = sub_28760(0x17u);
    v300 = sub_28770(0LL);
    sub_29380(v298, "Enable compression", 101, v300, (__int64)sub_1FF00, v299);
    v301 = sub_28A10(v5, "Connection/SSH", "sharing", "Sharing an SSH connection between PuTTY tools");
    v302 = sub_28760(0xBDu);
    v303 = sub_28770(0LL);
    sub_29380(v301, "Share SSH connections if possible", 115, v303, (__int64)sub_1FF00, v302);
    v304 = sub_28770(0LL);
    sub_29350(v301, "Permitted roles in a shared connection:", v304);
    v305 = sub_28760(0xBEu);
    v306 = sub_28770(0LL);
    sub_29380(v301, "Upstream (connecting to the real server)", 117, v306, (__int64)sub_1FF00, v305);
    v307 = sub_28760(0xBFu);
    v308 = sub_28770(0LL);
    sub_29380(v301, "Downstream (connecting to the upstream PuTTY)", 100, v308, (__int64)sub_1FF00, v307);
    v309 = sub_28A10(v5, "Connection/SSH", "protocol", "Protocol options");
    sub_28760(0);
    sub_28760(3u);
    v310 = sub_28760(0x22u);
    v311 = sub_28770(0LL);
    sub_28E40(v309, "SSH protocol version:", 0, 2, v311, (__int64)sub_22230, v310, (unsigned __int64)"2");
    if ( !((v709 + 1) & 0xFFFFFFFD) )
    {
LABEL_56:
      v520 = sub_28A10(v5, "Connection/SSH/Host keys", "hostkeys", "Manually configure host keys for this connection");
      sub_28C10(v520, 2, 75LL, 25LL, v521, v522, v699);
      v523 = sub_28770(0LL);
      *(_DWORD *)(sub_29350(v520, "Host keys or fingerprints to accept:", v523) + 20) = 0;
      v524 = (_QWORD *)sub_28C00((__int64)v5, 32LL);
      v525 = sub_28770((__int64)v524);
      v526 = sub_28770(0LL);
      v527 = sub_290C0(v520, "Remove", 114, v526, (__int64)sub_21570, v525);
      v524[1] = v527;
      *(_DWORD *)(v527 + 20) = 1;
      *(_BYTE *)(v527 + 16) = 1;
      v528 = sub_28770((__int64)v524);
      v529 = sub_28770(0LL);
      v530 = sub_29110(v520, 0LL, 0, v529, (__int64)sub_21570, v528);
      v531 = v524[1];
      v524[2] = v530;
      *(_DWORD *)(v530 + 60) = 2;
      *(_BYTE *)(v530 + 88) = 0;
      sub_29330(v520, v531);
      v532 = sub_28770(0LL);
      v533 = sub_28770((__int64)v524);
      v534 = sub_28770(0LL);
      v535 = sub_28D60(v520, "Key", 107, 80, v534, (__int64)sub_21570, v533, v532);
      v524[3] = v535;
      *(_DWORD *)(v535 + 20) = 0;
      v536 = sub_28770((__int64)v524);
      v537 = sub_28770(0LL);
      v538 = sub_290C0(v520, "Add key", 121, v537, (__int64)sub_21570, v536);
      *v524 = v538;
      *(_DWORD *)(v538 + 20) = 1;
      sub_28C10(v520, 1, 100LL, v539, v540, v541, v542);
      sub_28930(v5, (char *)&unk_E0DE7, "Options controlling SSH encryption");
      v543 = sub_28A10(v5, (char *)&unk_E0DE7, "encryption", "Encryption options");
      v544 = sub_28770(0LL);
      v545 = sub_28770(0LL);
      *(_DWORD *)(sub_29200(v543, "Encryption cipher selection policy:", 115, v545, (__int64)sub_22870, v544) + 60) = 6;
      v546 = sub_28760(0x23u);
      v547 = sub_28770(0LL);
      sub_29380(v543, "Enable legacy use of single-DES in SSH-2", 105, v547, (__int64)sub_1FF00, v546);
      sub_28930(v5, "Connection/SSH/Auth", "Options controlling SSH authentication");
      v548 = sub_28A10(v5, "Connection/SSH/Auth", "main", 0LL);
      v549 = sub_28760(0x26u);
      v550 = sub_28770(0LL);
      sub_29380(v548, "Display pre-authentication banner (SSH-2 only)", 100, v550, (__int64)sub_1FF00, v549);
      v551 = sub_28760(0x24u);
      v552 = sub_28770(0LL);
      sub_29380(v548, "Bypass authentication entirely (SSH-2 only)", 98, v552, (__int64)sub_1FF00, v551);
      v553 = sub_28760(0x25u);
      v554 = sub_28770(0LL);
      sub_29380(v548, "Disconnect if authentication succeeds trivially", 110, v554, (__int64)sub_1FF00, v553);
      v555 = sub_28A10(v5, "Connection/SSH/Auth", "methods", "Authentication methods");
      v556 = sub_28760(0x1Du);
      v557 = sub_28770(0LL);
      sub_29380(v555, "Attempt authentication using Pageant", 112, v557, (__int64)sub_1FF00, v556);
      v558 = sub_28760(0x27u);
      v559 = sub_28770(0LL);
      sub_29380(v555, "Attempt TIS or CryptoCard auth (SSH-1)", 109, v559, (__int64)sub_1FF00, v558);
      v560 = sub_28760(0x28u);
      v561 = sub_28770(0LL);
      sub_29380(v555, "Attempt \"keyboard-interactive\" auth (SSH-2)", 105, v561, (__int64)sub_1FF00, v560);
      v562 = sub_28A10(v5, "Connection/SSH/Auth", "params", "Authentication parameters");
      v563 = sub_28760(0x1Eu);
      v564 = sub_28770(0LL);
      sub_29380(v562, "Allow agent forwarding", 102, v564, (__int64)sub_1FF00, v563);
      v565 = sub_28760(0x1Fu);
      v566 = sub_28770(0LL);
      sub_29380(v562, "Allow attempted changes of username in SSH-2", 0, v566, (__int64)sub_1FF00, v565);
      v567 = sub_28760(0x21u);
      v568 = sub_28770(0LL);
      sub_29270(
        v562,
        "Private key file for authentication:",
        107,
        0LL,
        0,
        "Select private key file",
        v568,
        (__int64)sub_20150,
        v567);
      sub_28930(v5, "Connection/SSH/Auth/GSSAPI", "Options controlling GSSAPI authentication");
      v569 = sub_28A10(v5, "Connection/SSH/Auth/GSSAPI", "gssapi", 0LL);
      v570 = sub_28760(0x29u);
      v571 = sub_28770(0LL);
      sub_29380(v569, "Attempt GSSAPI authentication (SSH-2 only)", 116, v571, (__int64)sub_1FF00, v570);
      v572 = sub_28760(0x2Au);
      v573 = sub_28770(0LL);
      sub_29380(v569, "Attempt GSSAPI key exchange (SSH-2 only)", 107, v573, (__int64)sub_1FF00, v572);
      v574 = sub_28760(0x2Bu);
      v575 = sub_28770(0LL);
      sub_29380(v569, "Allow GSSAPI credential delegation", 108, v575, (__int64)sub_1FF00, v574);
      v692 = sub_28770(0LL);
      v693 = sub_28770(0LL);
      *(_DWORD *)(sub_29200(v569, "Preference order for GSSAPI libraries:", 112, v693, (__int64)sub_22750, v692) + 60) = 4;
      v694 = sub_28760(0x2Eu);
      v695 = sub_28770(0LL);
      sub_29270(
        v569,
        "User-supplied GSSAPI library path:",
        115,
        0LL,
        0,
        "Select library file",
        v695,
        (__int64)sub_20150,
        v694);
      sub_28930(v5, "Connection/SSH/TTY", "Remote terminal settings");
      v576 = sub_28A10(v5, "Connection/SSH/TTY", "sshtty", 0LL);
      v577 = sub_28760(0x16u);
      v578 = sub_28770(0LL);
      sub_29380(v576, "Don't allocate a pseudo-terminal", 112, v578, (__int64)sub_1FF00, v577);
      v579 = sub_28A10(v5, "Connection/SSH/TTY", "ttymodes", "Terminal modes");
      v580 = (__int64 *)sub_28C00((__int64)v5, 32LL);
      v581 = sub_28770(0LL);
      sub_29350(v579, "Terminal modes to send:", v581);
      v582 = sub_28770((__int64)v580);
      v583 = sub_28770(0LL);
      v584 = sub_29110(v579, 0LL, 0, v583, (__int64)sub_20B70, v582);
      v580[3] = v584;
      *(_DWORD *)(v584 + 60) = 8;
      *(_DWORD *)(v584 + 76) = 2;
      *(_QWORD *)(v584 + 80) = sub_2F450(2uLL, 4uLL, 0LL);
      v585 = v580[3];
      **(_DWORD **)(v585 + 80) = 40;
      *(_DWORD *)(*(_QWORD *)(v585 + 80) + 4LL) = 60;
      sub_28C10(v579, 2, 75LL, 25LL, v586, v587, v588);
      v589 = sub_28770(0LL);
      *(_DWORD *)(sub_29350(v579, "For selected mode, send:", v589) + 20) = 0;
      v590 = sub_28770((__int64)v580);
      v591 = sub_28770(0LL);
      v592 = sub_290C0(v579, "Set", 115, v591, (__int64)sub_20B70, v590);
      v580[2] = v592;
      *(_DWORD *)(v592 + 20) = 1;
      *(_BYTE *)(v592 + 16) = 1;
      sub_28C10(v579, 1, 100LL, v593, v594, v595, v596);
      sub_28C10(v579, 2, 75LL, 25LL, v597, v598, v599);
      sub_28770(0LL);
      sub_28770(0LL);
      sub_28770(0LL);
      v600 = sub_28770((__int64)v580);
      v601 = sub_28770(0LL);
      v602 = sub_28E40(v579, 0LL, 0, 3, v601, (__int64)sub_20B70, v600, (unsigned __int64)"Auto");
      *v580 = v602;
      *(_DWORD *)(v602 + 20) = 0;
      v603 = sub_28770(0LL);
      v604 = sub_28770((__int64)v580);
      v605 = sub_28770(0LL);
      v606 = sub_28D60(v579, 0LL, 0, 100, v605, (__int64)sub_20B70, v604, v603);
      v607 = *v580;
      v608 = v580[2];
      v580[1] = v606;
      *(_DWORD *)(v606 + 20) = 1;
      *(_QWORD *)(v606 + 48) = v607;
      sub_29330(v579, v608);
      sub_28930(v5, "Connection/SSH/X11", "Options controlling SSH X11 forwarding");
      v609 = sub_28A10(v5, "Connection/SSH/X11", "x11", (char *)&unk_E1233);
      v610 = sub_28760(0xA8u);
      v611 = sub_28770(0LL);
      sub_29380(v609, (char *)&unk_E122C, 101, v611, (__int64)sub_1FF00, v610);
      v612 = sub_28760(1u);
      v613 = sub_28760(0xA9u);
      v614 = sub_28770(0LL);
      sub_28D60(v609, "X display location", 120, 50, v614, (__int64)sub_1FF90, v613, v612);
      sub_28760(2u);
      sub_28760(1u);
      v615 = sub_28760(0xAAu);
      v616 = sub_28770(0LL);
      sub_28E40(
        v609,
        "Remote X11 authentication protocol",
        117,
        2,
        v616,
        (__int64)sub_22230,
        v615,
        (unsigned __int64)"MIT-Magic-Cookie-1");
      goto LABEL_42;
    }
LABEL_40:
    sub_28930(v5, "Connection/SSH/Kex", "Options controlling SSH key exchange");
    v312 = sub_28A10(v5, "Connection/SSH/Kex", "main", "Key exchange algorithm options");
    v313 = sub_28770(0LL);
    v314 = sub_28770(0LL);
    *(_DWORD *)(sub_29200(v312, "Algorithm selection policy:", 115, v314, (__int64)sub_22B50, v313) + 60) = 6;
    v315 = sub_28760(0x2Au);
    v316 = sub_28770(0LL);
    sub_29380(v312, "Attempt GSSAPI key exchange", 107, v316, (__int64)sub_1FF00, v315);
    v317 = sub_28A10(v5, "Connection/SSH/Kex", "repeat", "Options controlling key re-exchange");
    v318 = sub_28760(0xFFFFFFFF);
    v319 = sub_28760(0x1Bu);
    v320 = sub_28770(0LL);
    sub_28D60(v317, "Max minutes before rekey (0 for no limit)", 116, 20, v320, (__int64)sub_1FF90, v319, v318);
    v321 = sub_28760(0xFFFFFFFF);
    v322 = sub_28760(0x2Cu);
    v323 = sub_28770(0LL);
    sub_28D60(v317, "Minutes between GSS checks (0 for never)", 0, 20, v323, (__int64)sub_1FF90, v322, v321);
    v324 = sub_28760(0x10u);
    v325 = sub_28760(0x1Cu);
    v326 = sub_28770(0LL);
    sub_28D60(v317, "Max data before rekey (0 for no limit)", 120, 20, v326, (__int64)sub_1FF90, v325, v324);
    v327 = sub_28770(0LL);
    sub_29350(v317, "(Use 1M for 1 megabyte, 1G for 1 gigabyte etc)", v327);
    sub_28930(v5, "Connection/SSH/Host keys", "Options controlling SSH host keys");
    v328 = sub_28A10(v5, "Connection/SSH/Host keys", "main", "Host key algorithm preference");
    v329 = sub_28770(0LL);
    v330 = sub_28770(0LL);
    *(_DWORD *)(sub_29200(v328, "Algorithm selection policy:", 115, v330, (__int64)sub_229F0, v329) + 60) = 5;
    v331 = sub_28760(0x1Au);
    v332 = sub_28770(0LL);
    sub_29380(v328, "Prefer algorithms for which a host key is known", 112, v332, (__int64)sub_1FF00, v331);
    if ( v4 )
    {
      sub_28930(v5, (char *)&unk_E0DE7, "Options controlling SSH encryption");
      v333 = sub_28A10(v5, (char *)&unk_E0DE7, "encryption", "Encryption options");
      v334 = sub_28770(0LL);
      v335 = sub_28770(0LL);
      *(_DWORD *)(sub_29200(v333, "Encryption cipher selection policy:", 115, v335, (__int64)sub_22870, v334) + 60) = 6;
      v336 = sub_28760(0x23u);
      v337 = sub_28770(0LL);
      sub_29380(v333, "Enable legacy use of single-DES in SSH-2", 105, v337, (__int64)sub_1FF00, v336);
      goto LABEL_42;
    }
    goto LABEL_56;
  }
  if ( (v709 + 1) & 0xFFFFFFFD )
  {
    v265 = sub_28A10(v5, "Connection/SSH", "protocol", "Protocol options");
    v266 = sub_28760(0x17u);
    v267 = sub_28770(0LL);
    sub_29380(v265, "Enable compression", 101, v267, (__int64)sub_1FF00, v266);
    goto LABEL_40;
  }
  v690 = sub_28A10(v5, "Connection/SSH", "disclaimer", 0LL);
  v691 = sub_28770(0LL);
  sub_29350(
    v690,
    "Nothing on this panel may be reconfigured in mid-session; it is only here so that sub-panels of it can exist without"
    " looking strange.",
    v691);
LABEL_42:
  sub_28930(v5, "Connection/SSH/Tunnels", "Options controlling SSH port forwarding");
  v338 = sub_28A10(v5, "Connection/SSH/Tunnels", "portfwd", "Port forwarding");
  v339 = sub_28760(0xACu);
  v340 = sub_28770(0LL);
  sub_29380(v338, "Local ports accept connections from other hosts", 116, v340, (__int64)sub_1FF00, v339);
  v341 = sub_28760(0xADu);
  v342 = sub_28770(0LL);
  sub_29380(v338, "Remote ports do the same (SSH-2 only)", 112, v342, (__int64)sub_1FF00, v341);
  sub_28C10(v338, 3, 55LL, 20LL, 25LL, v343, v699);
  v344 = sub_28770(0LL);
  *(_DWORD *)(sub_29350(v338, "Forwarded ports:", v344) + 20) = (_DWORD)&stru_10000;
  v345 = (__int64 *)sub_28C00((__int64)v5, 56LL);
  v346 = sub_28770((__int64)v345);
  v347 = sub_28770(0LL);
  v348 = sub_290C0(v338, "Remove", 114, v347, (__int64)sub_20E90, v346);
  v345[1] = v348;
  *(_DWORD *)(v348 + 20) = 2;
  *(_BYTE *)(v348 + 16) = 1;
  v349 = sub_28770((__int64)v345);
  v350 = sub_28770(0LL);
  v351 = sub_29110(v338, 0LL, 0, v350, (__int64)sub_20E90, v349);
  v345[2] = v351;
  *(_DWORD *)(v351 + 60) = 3;
  *(_DWORD *)(v351 + 76) = 2;
  *(_QWORD *)(v351 + 80) = sub_2F450(2uLL, 4uLL, 0LL);
  v352 = v345[2];
  v353 = v345[1];
  **(_DWORD **)(v352 + 80) = 20;
  *(_DWORD *)(*(_QWORD *)(v352 + 80) + 4LL) = 80;
  sub_29330(v338, v353);
  v354 = sub_28770(0LL);
  sub_29350(v338, "Add new forwarded port:", v354);
  v355 = sub_28770((__int64)v345);
  v356 = sub_28770(0LL);
  v357 = sub_290C0(v338, "Add", 100, v356, (__int64)sub_20E90, v355);
  *v345 = v357;
  *(_DWORD *)(v357 + 20) = 2;
  *(_BYTE *)(v357 + 16) = 1;
  v358 = sub_28770(0LL);
  v359 = sub_28770((__int64)v345);
  v360 = sub_28770(0LL);
  v361 = sub_28D60(v338, (char *)&unk_E0F12, 115, 40, v360, (__int64)sub_20E90, v359, v358);
  v345[3] = v361;
  *(_DWORD *)(v361 + 20) = 0;
  v362 = sub_28770(0LL);
  v363 = sub_28770((__int64)v345);
  v364 = sub_28770(0LL);
  v345[4] = sub_28D60(v338, "Destination", 105, 67, v364, (__int64)sub_20E90, v363, v362);
  sub_28770(0LL);
  sub_28770(0LL);
  sub_28770(0LL);
  v365 = sub_28770((__int64)v345);
  v366 = sub_28770(0LL);
  v345[5] = sub_28E40(v338, 0LL, 0, 3, v366, (__int64)sub_20E90, v365, (unsigned __int64)"Local");
  sub_28760(2u);
  sub_28760(1u);
  sub_28760(0);
  v367 = sub_28770((__int64)v345);
  v368 = sub_28770(0LL);
  v369 = sub_28E40(v338, 0LL, 0, 3, v368, (__int64)sub_20E90, v367, (unsigned __int64)"Auto");
  v370 = *v345;
  v345[6] = v369;
  sub_29330(v338, v370);
  sub_28C10(v338, 1, 100LL, v371, v372, v373, v374);
  if ( !v4 )
  {
    sub_28930(v5, "Connection/SSH/Bugs", "Workarounds for SSH server bugs");
    v375 = sub_28A10(v5, "Connection/SSH/Bugs", "main", "Detection of known bugs in SSH servers");
    v376 = sub_28760(0xB8u);
    v377 = sub_28770(0LL);
    sub_29180(v375, "Chokes on SSH-2 ignore messages", 50, 20, v377, (__int64)sub_22630, v376);
    v378 = sub_28760(0xB6u);
    v379 = sub_28770(0LL);
    sub_29180(v375, "Handles SSH-2 key re-exchange badly", 107, 20, v379, (__int64)sub_22630, v378);
    v380 = sub_28760(0xBAu);
    v381 = sub_28770(0LL);
    sub_29180(v375, "Chokes on PuTTY's SSH-2 'winadj' requests", 106, 20, v381, (__int64)sub_22630, v380);
    v382 = sub_28760(0xBBu);
    v383 = sub_28770(0LL);
    sub_29180(v375, "Replies to requests on closed channels", 113, 20, v383, (__int64)sub_22630, v382);
    v384 = sub_28760(0xB7u);
    v385 = sub_28770(0LL);
    sub_29180(v375, "Ignores SSH-2 maximum packet size", 120, 20, v385, (__int64)sub_22630, v384);
    sub_28930(v5, "Connection/SSH/More bugs", "Further workarounds for SSH server bugs");
    v386 = sub_28A10(v5, "Connection/SSH/More bugs", "main", "Detection of known bugs in SSH servers");
    v387 = sub_28760(0xB4u);
    v388 = sub_28770(0LL);
    sub_29180(v386, "Requires padding on SSH-2 RSA signatures", 112, 20, v388, (__int64)sub_22630, v387);
    v389 = sub_28760(0xB9u);
    v390 = sub_28770(0LL);
    sub_29180(v386, "Only supports pre-RFC4419 SSH-2 DH GEX", 100, 20, v390, (__int64)sub_22630, v389);
    v391 = sub_28760(0xB2u);
    v392 = sub_28770(0LL);
    sub_29180(v386, "Miscomputes SSH-2 HMAC keys", 109, 20, v392, (__int64)sub_22630, v391);
    v393 = sub_28760(0xB5u);
    v394 = sub_28770(0LL);
    sub_29180(v386, "Misuses the session ID in SSH-2 PK auth", 110, 20, v394, (__int64)sub_22630, v393);
    v395 = sub_28760(0xB3u);
    v396 = sub_28770(0LL);
    sub_29180(v386, "Miscomputes SSH-2 encryption keys", 101, 20, v396, (__int64)sub_22630, v395);
    v397 = sub_28760(0xAFu);
    v398 = sub_28770(0LL);
    sub_29180(v386, "Chokes on SSH-1 ignore messages", 105, 20, v398, (__int64)sub_22630, v397);
    v399 = sub_28760(0xB0u);
    v400 = sub_28770(0LL);
    sub_29180(v386, "Refuses all SSH-1 password camouflage", 115, 20, v400, (__int64)sub_22630, v399);
    v401 = sub_28760(0xB1u);
    v402 = sub_28770(0LL);
    sub_29180(v386, "Chokes on SSH-1 RSA authentication", 114, 20, v402, (__int64)sub_22630, v401);
    if ( !sub_3CFD0(5) )
      goto LABEL_24;
    v403 = sub_3CFD0(5);
    sub_28930(v5, "Connection/Serial", "Options controlling local serial lines");
LABEL_45:
    v404 = sub_28A10(v5, "Connection/Serial", "serline", "Select a serial line");
    v405 = sub_28760(1u);
    v406 = sub_28760(0x3Du);
    v407 = sub_28770(0LL);
    sub_28D60(v404, "Serial line to connect to", 108, 40, v407, (__int64)sub_1FF90, v406, v405);
LABEL_46:
    v408 = sub_28A10(v5, "Connection/Serial", "sercfg", "Configure the serial line");
    v409 = sub_28760(0xFFFFFFFF);
    v410 = sub_28760(0x3Eu);
    v411 = sub_28770(0LL);
    sub_28D60(v408, "Speed (baud)", 115, 40, v411, (__int64)sub_1FF90, v410, v409);
    v412 = sub_28760(0xFFFFFFFF);
    v413 = sub_28760(0x3Fu);
    v414 = sub_28770(0LL);
    sub_28D60(v408, "Data bits", 98, 40, v414, (__int64)sub_1FF90, v413, v412);
    v415 = sub_28760(0xFFFFFFFE);
    v416 = sub_28760(0x40u);
    v417 = sub_28770(0LL);
    sub_28D60(v408, "Stop bits", 116, 40, v417, (__int64)sub_1FF90, v416, v415);
    v418 = sub_28760(*((_DWORD *)v403 + 41));
    v419 = sub_28770(0LL);
    sub_29180(v408, "Parity", 112, 40, v419, (__int64)sub_203F0, v418);
    v420 = sub_28760(*((_DWORD *)v403 + 42));
    v421 = sub_28770(0LL);
    sub_29180(v408, "Flow control", 102, 40, v421, (__int64)sub_20280, v420);
    goto LABEL_24;
  }
LABEL_21:
  if ( sub_3CFD0(5) && (v701 == 5 || v707) )
  {
    v403 = sub_3CFD0(5);
    sub_28930(v5, "Connection/Serial", "Options controlling local serial lines");
    if ( v4 )
      goto LABEL_46;
    goto LABEL_45;
  }
LABEL_24:
  if ( sub_3CFD0(1) )
  {
    if ( v701 != 1 && !v707 )
    {
      sub_3CFD0(2);
      return sub_3CFD0(6);
    }
    sub_28930(v5, (char *)&unk_E1019, "Options controlling Telnet connections");
    v268 = sub_28A10(v5, (char *)&unk_E1019, "protocol", "Telnet protocol adjustments");
    if ( !v4 )
    {
      sub_28760(1u);
      sub_28760(0);
      v269 = sub_28760(0x3Bu);
      v270 = sub_28770(0LL);
      sub_28E40(
        v268,
        "Handling of OLD_ENVIRON ambiguity:",
        0,
        2,
        v270,
        (__int64)sub_22420,
        v269,
        (unsigned __int64)"BSD (commonplace)");
      sub_28760(0);
      sub_28760(1u);
      v271 = sub_28760(0x3Cu);
      v272 = sub_28770(0LL);
      sub_28E40(v268, "Telnet negotiation mode:", 116, 2, v272, (__int64)sub_22420, v271, (unsigned __int64)"Passive");
    }
    v273 = sub_28760(0x57u);
    v274 = sub_28770(0LL);
    sub_29380(v268, "Keyboard sends Telnet special commands", 107, v274, (__int64)sub_1FF00, v273);
    v275 = sub_28760(0x58u);
    v276 = sub_28770(0LL);
    sub_29380(v268, "Return key sends Telnet New Line instead of ^M", 109, v276, (__int64)sub_1FF00, v275);
  }
  if ( sub_3CFD0(2) )
  {
    if ( v4 )
      return sub_3CFD0(6);
    sub_28930(v5, "Connection/Rlogin", "Options controlling Rlogin connections");
    v277 = sub_28A10(v5, "Connection/Rlogin", "data", (char *)&unk_E0BDB);
    v278 = sub_28760(1u);
    v279 = sub_28760(0x3Au);
    v280 = sub_28770(0LL);
    sub_28D60(v277, "Local username:", 108, 50, v280, (__int64)sub_1FF90, v279, v278);
    result = sub_3CFD0(6);
    if ( result )
      goto LABEL_38;
  }
  else
  {
    result = sub_3CFD0(6);
    if ( result && !v4 )
    {
LABEL_38:
      sub_28930(v5, (char *)&unk_E10BF, "Options controlling SUPDUP connections");
      v281 = sub_28A10(v5, (char *)&unk_E10BF, "main", 0LL);
      v282 = sub_28760(1u);
      v283 = sub_28760(0x43u);
      v284 = sub_28770(0LL);
      sub_28D60(v281, "Location string", 108, 70, v284, (__int64)sub_1FF90, v283, v282);
      sub_28760(2u);
      sub_28760(1u);
      sub_28760(0);
      v285 = sub_28760(0x44u);
      v286 = sub_28770(0LL);
      sub_28E40(v281, "Extended ASCII Character set:", 101, 4, v286, (__int64)sub_22230, v285, (unsigned __int64)"None");
      v287 = sub_28760(0x45u);
      v288 = sub_28770(0LL);
      sub_29380(v281, "**MORE** processing", 109, v288, (__int64)sub_1FF00, v287);
      v289 = sub_28760(0x46u);
      v290 = sub_28770(0LL);
      return (void **)sub_29380(v281, "Terminal scrolling", 115, v290, (__int64)sub_1FF00, v289);
    }
  }
  return result;
}

__int64 __fastcall sub_28250(__int64 a1)
{
  return sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8), 3);
}

signed __int64 __fastcall sub_28260(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  int i; // eax
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  int v6; // eax
  int v7; // edx
  __int64 *v8; // rdi
  const char *v9; // rax
  __int64 v10; // r15
  __int64 v11; // ST08_8
  __int64 v12; // rax
  int v14; // [rsp+10h] [rbp-168h]
  int v15; // [rsp+14h] [rbp-164h]
  unsigned __int8 v16; // [rsp+30h] [rbp-148h]
  unsigned __int8 v17; // [rsp+31h] [rbp-147h]
  unsigned __int64 v18; // [rsp+138h] [rbp-40h]

  v1 = a1 + 120;
  v2 = a1;
  v18 = __readfsqword(0x28u);
  for ( i = *(_DWORD *)(a1 + 240); ; i = *(_DWORD *)(v2 + 240) )
  {
LABEL_2:
    if ( !i )
      goto LABEL_14;
    if ( *(_DWORD *)(v2 + 244) >= i )
      return 0LL;
    if ( *(_DWORD *)(v2 + 248) == -1 )
      break;
LABEL_5:
    v4 = sub_BCD00(v1);
    v5 = *(signed int *)(v2 + 252);
    if ( v4 < v5 )
      return 1LL;
    sub_BCF10(v1, (char *)&v16, v5);
    sub_BCE20(v1, *(signed int *)(v2 + 252));
    v6 = *(_DWORD *)(v2 + 248);
    if ( v6 == 3 )
    {
      v8 = *(__int64 **)(v2 + 232);
      v14 = 268697857;
      v9 = (const char *)sub_1F170(v8, 17);
      v10 = (__int64)v9;
      v11 = *(signed int *)(v2 + 252);
      v12 = strlen(v9);
      sub_5E580((__int64 (__fastcall **)(_QWORD, _QWORD))off_320D80, v10, v12, (__int64)&v16, v11, (__int64)&v15);
      (*(void (__fastcall **)(_QWORD, int *, signed __int64))(**(_QWORD **)(v2 + 8) + 16LL))(
        *(_QWORD *)(v2 + 8),
        &v14,
        20LL);
      v7 = *(_DWORD *)(v2 + 164);
      goto LABEL_10;
    }
    if ( v6 == 17 )
    {
      if ( v16 != -123 )
      {
        (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
          *(_QWORD *)(v2 + 16),
          "Proxy error: Server chose CHAP of other than HMAC-MD5 but we didn't offer it!",
          8000LL,
          0LL);
        return 1LL;
      }
LABEL_9:
      v7 = *(_DWORD *)(v2 + 164);
LABEL_10:
      ++*(_DWORD *)(v2 + 244);
      i = *(_DWORD *)(v2 + 240);
      *(_DWORD *)(v2 + 248) = -1;
      goto LABEL_11;
    }
    if ( v6 )
      goto LABEL_9;
    if ( v16 )
    {
      (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
        *(_QWORD *)(v2 + 16),
        "Proxy error: SOCKS proxy refused CHAP authentication",
        8000LL,
        0LL);
      return 1LL;
    }
    *(_DWORD *)(v2 + 164) = 2;
    *(_DWORD *)(v2 + 248) = -1;
    ++*(_DWORD *)(v2 + 244);
  }
  while ( 1 )
  {
LABEL_14:
    if ( (unsigned __int64)sub_BCD00(v1) <= 1 )
      return 1LL;
    sub_BCF10(v1, (char *)&v16, 2uLL);
    sub_BCE20(v1, 2uLL);
    if ( *(_DWORD *)(v2 + 240) )
    {
      if ( *(_DWORD *)(v2 + 248) == -1 )
      {
        *(_DWORD *)(v2 + 248) = v16;
        *(_DWORD *)(v2 + 252) = v17;
      }
      goto LABEL_5;
    }
    if ( v16 != 1 )
    {
      (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
        *(_QWORD *)(v2 + 16),
        "Proxy error: SOCKS proxy wants a different CHAP version",
        8000LL,
        0LL);
      return 1LL;
    }
    i = v17;
    if ( !v17 )
      break;
    *(_DWORD *)(v2 + 240) = v17;
    v7 = *(_DWORD *)(v2 + 164);
LABEL_11:
    if ( v7 != 8 || *(_DWORD *)(v2 + 244) < i )
      goto LABEL_2;
    *(_QWORD *)(v2 + 240) = 0LL;
    *(_DWORD *)(v2 + 252) = 0;
  }
  (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
    *(_QWORD *)(v2 + 16),
    "Proxy error: SOCKS proxy won't negotiate CHAP with us",
    8000LL,
    0LL);
  return 1LL;
}

signed __int64 __fastcall sub_28570(__int64 a1)
{
  __int64 v1; // rbp
  __int64 *v2; // rdi
  const char *v3; // r12
  _BYTE *v4; // rax
  signed int v5; // ebx
  signed int v6; // eax
  int v8; // [rsp+0h] [rbp-238h]
  __int16 v9; // [rsp+4h] [rbp-234h]
  char v10; // [rsp+6h] [rbp-232h]
  char v11; // [rsp+7h] [rbp-231h]
  unsigned __int64 v12; // [rsp+208h] [rbp-30h]

  v1 = a1;
  v2 = *(__int64 **)(a1 + 232);
  v12 = __readfsqword(0x28u);
  v3 = (const char *)sub_1F170(v2, 16);
  v4 = (_BYTE *)sub_1F170(*(__int64 **)(v1 + 232), 17);
  if ( *v3 || *v4 )
  {
    v8 = 17891841;
    v9 = 645;
    v5 = 1;
    v6 = strlen(v3);
    if ( v6 > 0 )
      v5 = v6;
    if ( v5 > 255 )
      v5 = 255;
    v10 = v5;
    __memcpy_chk(&v11, v3, v5, 507LL);
    (*(void (__fastcall **)(_QWORD, int *, _QWORD))(**(_QWORD **)(v1 + 8) + 16LL))(*(_QWORD *)(v1 + 8), &v8, v5 + 7);
    *(_QWORD *)(v1 + 240) = 0LL;
    *(_DWORD *)(v1 + 164) = 8;
    *(_QWORD *)(v1 + 248) = 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v1 + 16) + 8LL))(
      *(_QWORD *)(v1 + 16),
      "Proxy error: Server chose CHAP authentication but we didn't offer it!",
      8000LL,
      0LL);
  }
  return 1LL;
}

void __fastcall sub_286A0(void *a1)
{
  sub_2F4D0(a1);
}

__int64 __fastcall sub_286B0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // r13
  __int64 v7; // r12
  __int64 v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rdx

  v5 = a3;
  v6 = a4;
  v7 = a5;
  v8 = sub_2F450(1uLL, 0x60uLL, 0LL);
  v9 = sub_2F4F0(*(void **)(a1 + 48), (unsigned __int64 *)(a1 + 40), 8uLL, *(_QWORD *)(a1 + 32), 1uLL, 0);
  v10 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = v9;
  *(_QWORD *)(a1 + 32) = v10 + 1;
  v9[v10] = v8;
  LODWORD(v9) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)v8 = a2;
  *(_BYTE *)(v8 + 16) = 0;
  *(_QWORD *)(v8 + 40) = v5;
  *(_QWORD *)(v8 + 24) = v6;
  *(_QWORD *)(v8 + 32) = v7;
  *(_QWORD *)(v8 + 8) = 0LL;
  *(_QWORD *)(v8 + 48) = 0LL;
  *(_DWORD *)(v8 + 20) = ((_DWORD)v9 - 1) << 16;
  return v8;
}

__int64 __fastcall sub_28760(unsigned int a1)
{
  return a1;
}

__int64 __fastcall sub_28770(__int64 a1)
{
  return a1;
}

signed __int64 __fastcall sub_28780(char *a1)
{
  char v1; // dl
  signed __int64 result; // rax

  v1 = *a1;
  for ( result = 1LL; *a1; v1 = *a1 )
  {
    ++a1;
    result = (v1 == 47) + (unsigned int)result;
  }
  return result;
}

signed __int64 __fastcall sub_287C0(char *a1, char *a2)
{
  signed __int64 result; // rax
  char v3; // dl
  char v4; // cl

  result = 0LL;
  while ( 1 )
  {
    v3 = *a1;
    v4 = *a2;
    if ( !*a1 )
      break;
    if ( v3 == 47 && (v4 == 47 || !v4) )
      goto LABEL_4;
LABEL_5:
    if ( v4 != v3 )
      return result;
    ++a1;
    ++a2;
  }
  if ( v4 )
  {
    if ( v4 != 47 )
      return result;
LABEL_4:
    result = (unsigned int)(result + 1);
    goto LABEL_5;
  }
  return 0x7FFFFFFFLL;
}

__int64 __fastcall sub_28810(_QWORD *a1, char *a2)
{
  char *v2; // r10
  __int64 v3; // rbp
  signed __int64 v4; // r8
  unsigned int v5; // ebx
  int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r11
  int v9; // er9

  if ( *a1 )
  {
    v2 = a2;
    v3 = a1[2];
    v4 = 0LL;
    while ( 1 )
    {
      v5 = v4;
      v6 = sub_287C0(v2, **(char ***)(v3 + 8 * v4));
      if ( v6 < v9 || v6 == 0x7FFFFFFF )
        break;
      v4 = v7 + 1;
      if ( v8 == v4 )
        return (unsigned int)v8;
    }
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

_QWORD *sub_28870()
{
  _QWORD *result; // rax

  result = (_QWORD *)sub_2F450(1uLL, 0x38uLL, 0LL);
  result[1] = 0LL;
  *result = 0LL;
  result[2] = 0LL;
  result[4] = 0LL;
  result[3] = 0LL;
  result[5] = 0LL;
  result[6] = 0LL;
  return result;
}

__int64 __fastcall sub_28930(unsigned __int64 *a1, char *a2, char *a3)
{
  char *v3; // r14
  unsigned __int64 *v4; // rbp
  __int64 v5; // rbx
  int v6; // er12
  char *v7; // rax
  unsigned __int64 v8; // rcx
  void *v9; // rdi
  char *v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  signed __int64 v13; // r12
  __int64 result; // rax

  v3 = a3;
  v4 = a1;
  v5 = sub_2F450(1uLL, 0x38uLL, 0LL);
  v6 = sub_28810(a1, a2);
  *(_QWORD *)v5 = sub_BC120(a2);
  *(_QWORD *)(v5 + 8) = 0LL;
  v7 = sub_BC120(v3);
  v8 = *a1;
  v9 = (void *)a1[2];
  *(_QWORD *)(v5 + 16) = v7;
  *(_QWORD *)(v5 + 40) = 0LL;
  *(_QWORD *)(v5 + 32) = 0LL;
  *(_DWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 48) = 0LL;
  v10 = (char *)sub_2F4F0(v9, v4 + 1, 8uLL, v8, 1uLL, 0);
  v11 = *v4;
  v12 = v6;
  v4[2] = (unsigned __int64)v10;
  v13 = 8LL * v6;
  if ( v12 < v11 )
  {
    memmove(&v10[v13 + 8], &v10[v13], 8 * (v11 - v12));
    v10 = (char *)v4[2];
    v11 = *v4;
  }
  *(_QWORD *)&v10[v13] = v5;
  result = v5;
  *v4 = v11 + 1;
  return result;
}

__int64 __fastcall sub_28A10(unsigned __int64 *a1, char *a2, char *a3, char *a4)
{
  unsigned __int64 *v4; // r14
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // r15
  signed __int64 v7; // r12
  const char *v8; // rdi
  __int64 v9; // rbx
  char *v10; // rax
  void *v11; // rdi
  unsigned __int64 v12; // rcx
  char *v13; // rax
  unsigned __int64 v14; // rdx
  unsigned __int64 v16; // [rsp+8h] [rbp-50h]
  char *s2; // [rsp+10h] [rbp-48h]
  char *src; // [rsp+18h] [rbp-40h]

  v4 = a1;
  s2 = a3;
  src = a4;
  v5 = (signed int)sub_28810(a1, a2);
  v16 = *a1;
  if ( v5 >= *a1 )
  {
LABEL_13:
    v7 = 8 * v5;
  }
  else
  {
    v6 = a1[2];
    v7 = 8 * v5;
    while ( 1 )
    {
      v9 = *(_QWORD *)(v6 + v7);
      if ( strcmp(*(const char **)v9, a2) )
        break;
      v8 = *(const char **)(v9 + 8);
      if ( v8 && !strcmp(v8, s2) )
        return v9;
      ++v5;
      v7 += 8LL;
      if ( v5 >= v16 )
        goto LABEL_13;
    }
  }
  v9 = sub_2F450(1uLL, 0x38uLL, 0LL);
  *(_QWORD *)v9 = sub_BC120(a2);
  *(_QWORD *)(v9 + 8) = sub_BC120(s2);
  v10 = 0LL;
  if ( src )
    v10 = sub_BC120(src);
  v11 = (void *)v4[2];
  v12 = *v4;
  *(_QWORD *)(v9 + 16) = v10;
  *(_DWORD *)(v9 + 24) = 1;
  *(_QWORD *)(v9 + 40) = 0LL;
  *(_QWORD *)(v9 + 32) = 0LL;
  *(_QWORD *)(v9 + 48) = 0LL;
  v13 = (char *)sub_2F4F0(v11, v4 + 1, 8uLL, v12, 1uLL, 0);
  v14 = *v4;
  v4[2] = (unsigned __int64)v13;
  if ( v14 > v5 )
  {
    memmove(&v13[8 * v5 + 8], &v13[v7], 8 * (v14 - v5));
    v13 = (char *)v4[2];
    v14 = *v4;
  }
  *(_QWORD *)&v13[v7] = v9;
  *v4 = v14 + 1;
  return v9;
}

__int64 __fastcall sub_28B80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  __int64 v5; // rbp
  void *v6; // rax
  size_t v7; // rsi
  void *v8; // rdi
  void *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rax

  v3 = a3;
  v4 = a1;
  v5 = sub_2F450(a2, 1uLL, 0LL);
  v6 = sub_2F4F0(*(void **)(v4 + 40), (unsigned __int64 *)(v4 + 32), 8uLL, *(_QWORD *)(v4 + 24), 1uLL, 0);
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(void **)(a1 + 48);
  *(_QWORD *)(v4 + 40) = v6;
  v9 = sub_2F490(v8, v7, 8uLL);
  v10 = *(_QWORD *)(v4 + 40);
  *(_QWORD *)(v4 + 48) = v9;
  v11 = *(_QWORD *)(v4 + 24);
  *(_QWORD *)(v10 + 8 * v11) = v5;
  *(_QWORD *)(*(_QWORD *)(v4 + 48) + 8 * v11) = v3;
  *(_QWORD *)(v4 + 24) = v11 + 1;
  return v5;
}

__int64 __fastcall sub_28C00(__int64 a1, __int64 a2)
{
  return sub_28B80(a1, a2, (__int64)sub_286A0);
}

__int64 __fastcall sub_28C10(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  int v7; // ebp
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 result; // rax
  char *v11; // r8
  unsigned int v12; // esi
  __int64 v13; // rax
  _DWORD *v14; // rdx
  __int64 v15; // rcx
  char *v16; // rcx
  unsigned __int64 v17; // [rsp+18h] [rbp-50h]
  char v18[16]; // [rsp+20h] [rbp-48h]
  __int64 v19; // [rsp+30h] [rbp-38h]
  __int64 v20; // [rsp+38h] [rbp-30h]
  __int64 v21; // [rsp+40h] [rbp-28h]
  __int64 v22; // [rsp+48h] [rbp-20h]

  v7 = a2;
  v19 = a3;
  v20 = a4;
  v21 = a5;
  v17 = __readfsqword(0x28u);
  v22 = a6;
  v8 = sub_286B0(a1, 6, 0LL, 0LL, 0LL);
  v9 = v8;
  if ( *(_DWORD *)(a1 + 24) != 1 )
  {
    if ( a2 != 1 )
      goto LABEL_14;
    *(_DWORD *)(v8 + 56) = 1;
    *(_DWORD *)(a1 + 24) = 1;
    goto LABEL_4;
  }
  *(_DWORD *)(v8 + 56) = a2;
  *(_DWORD *)(a1 + 24) = a2;
  if ( a2 == 1 )
  {
LABEL_4:
    *(_QWORD *)(v8 + 64) = 0LL;
    goto LABEL_5;
  }
  *(_QWORD *)(v8 + 64) = sub_2F450(a2, 4uLL, 0LL);
  if ( a2 > 0 )
  {
    v11 = &a7;
    v12 = 16;
    v13 = 0LL;
    do
    {
      v14 = (_DWORD *)(v13 + *(_QWORD *)(v9 + 64));
      if ( v12 > 0x2F )
      {
        v16 = v11;
        v11 += 8;
      }
      else
      {
        v15 = v12;
        v12 += 8;
        v16 = &v18[v15];
      }
      v13 += 4LL;
      *v14 = *(_DWORD *)v16;
    }
    while ( v13 != 4LL * (unsigned int)(v7 - 1) + 4 );
  }
LABEL_5:
  result = v9;
  if ( __readfsqword(0x28u) != v17 )
LABEL_14:
    __assert_fail("s->ncolumns == 1 || ncolumns == 1", "dialog.c", 0xE8u, "ctrl_columns");
  return result;
}

__int64 __fastcall sub_28D60(__int64 a1, char *a2, char a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  char v8; // r13
  int v9; // er12
  __int64 v10; // rbx
  char *v11; // rax

  v8 = a3;
  v9 = a4;
  v10 = sub_286B0(a1, 1, a5, a6, a7);
  v11 = 0LL;
  if ( a2 )
    v11 = sub_BC120(a2);
  *(_QWORD *)(v10 + 8) = v11;
  *(_BYTE *)(v10 + 56) = v8;
  *(_DWORD *)(v10 + 60) = v9;
  *(_BYTE *)(v10 + 64) = 0;
  *(_BYTE *)(v10 + 65) = 0;
  *(_QWORD *)(v10 + 72) = a8;
  return v10;
}

__int64 __fastcall sub_28DD0(__int64 a1, char *a2, char a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  char v8; // r13
  int v9; // er12
  __int64 v10; // rbx
  char *v11; // rax

  v8 = a3;
  v9 = a4;
  v10 = sub_286B0(a1, 1, a5, a6, a7);
  v11 = 0LL;
  if ( a2 )
    v11 = sub_BC120(a2);
  *(_QWORD *)(v10 + 8) = v11;
  *(_BYTE *)(v10 + 56) = v8;
  *(_DWORD *)(v10 + 60) = v9;
  *(_BYTE *)(v10 + 64) = 0;
  *(_BYTE *)(v10 + 65) = 1;
  *(_QWORD *)(v10 + 72) = a8;
  return v10;
}

__int64 __fastcall sub_28E40(__int64 a1, char *a2, char a3, int a4, __int64 a5, __int64 a6, __int64 a7, char a8)
{
  char v8; // r13
  int v9; // er12
  __int64 v10; // rbx
  char *v11; // rax
  char *v12; // rbp
  unsigned int v13; // eax
  char *v14; // rdx
  char *v15; // rdi
  __int64 v16; // rcx
  signed __int64 v17; // r8
  bool v18; // zf
  __int64 v19; // rax
  __int64 v20; // r12
  char **v21; // rax
  char **v22; // r13
  unsigned int v23; // eax
  char *v24; // rcx
  char *v25; // rdx
  __int64 result; // rax
  __int64 v27; // rax
  unsigned int v28; // [rsp+0h] [rbp-78h]
  char *v29; // [rsp+8h] [rbp-70h]
  unsigned __int64 v30; // [rsp+18h] [rbp-60h]
  char v31[88]; // [rsp+20h] [rbp-58h]

  v8 = a3;
  v9 = a4;
  v30 = __readfsqword(0x28u);
  v10 = sub_286B0(a1, 2, a5, a6, a7);
  v11 = 0LL;
  if ( a2 )
    v11 = sub_BC120(a2);
  v12 = &a8;
  *(_QWORD *)(v10 + 8) = v11;
  *(_BYTE *)(v10 + 56) = v8;
  *(_DWORD *)(v10 + 60) = v9;
  v13 = 48;
  v14 = &a8;
  LODWORD(v15) = 0;
  while ( 1 )
  {
    if ( v13 > 0x2F )
    {
      v17 = (signed __int64)(v14 + 8);
    }
    else
    {
      v16 = v13;
      v17 = (signed __int64)v14;
      v13 += 8;
      v14 = &v31[v16];
    }
    if ( !*(_QWORD *)v14 )
      break;
    if ( !*(_BYTE *)(v10 + 56) )
    {
      if ( v13 > 0x2F )
      {
        v17 += 8LL;
        goto LABEL_35;
      }
      v13 += 8;
    }
    if ( v13 <= 0x2F )
    {
      v13 += 8;
      goto LABEL_12;
    }
LABEL_35:
    v17 += 8LL;
LABEL_12:
    LODWORD(v15) = (_DWORD)v15 + 1;
    v14 = (char *)v17;
  }
  do
  {
    v18 = *(_BYTE *)(v10 + 56) == 0;
    *(_DWORD *)(v10 + 64) = (_DWORD)v15;
    v15 = (char *)(signed int)v15;
    if ( v18 )
    {
      v27 = sub_2F450((unsigned __int64)v15, 1uLL, 0LL);
      v15 = (char *)*(signed int *)(v10 + 64);
      *(_QWORD *)(v10 + 80) = v27;
    }
    else
    {
      *(_QWORD *)(v10 + 80) = 0LL;
    }
    v19 = sub_2F450((unsigned __int64)v15, 8uLL, 0LL);
    v15 = (char *)*(signed int *)(v10 + 64);
    *(_QWORD *)(v10 + 72) = v19;
    *(_QWORD *)(v10 + 88) = sub_2F450((unsigned __int64)v15, 8uLL, 0LL);
    v28 = 48;
    v29 = v12;
    if ( *(_DWORD *)(v10 + 64) > 0 )
    {
      v20 = 0LL;
      do
      {
        if ( v28 > 0x2F )
        {
          v21 = (char **)v29;
          v29 += 8;
        }
        else
        {
          v21 = (char **)&v31[v28];
          v28 += 8;
        }
        v15 = *v21;
        v22 = (char **)(8 * v20 + *(_QWORD *)(v10 + 72));
        *v22 = sub_BC120(*v21);
        v23 = v28;
        if ( !*(_BYTE *)(v10 + 56) )
        {
          if ( v28 > 0x2F )
          {
            v24 = v29;
            v29 += 8;
          }
          else
          {
            v24 = &v31[v28];
            v23 = v28 + 8;
            v28 += 8;
          }
          *(_BYTE *)(*(_QWORD *)(v10 + 80) + v20) = *(_DWORD *)v24;
        }
        v12 = (char *)(*(_QWORD *)(v10 + 88) + 8 * v20);
        if ( v23 > 0x2F )
        {
          v25 = v29;
          v29 += 8;
        }
        else
        {
          v25 = &v31[v23];
          v28 = v23 + 8;
        }
        *(_QWORD *)v12 = *(_QWORD *)v25;
        ++v20;
      }
      while ( *(_DWORD *)(v10 + 64) > (signed int)v20 );
    }
    result = v10;
  }
  while ( __readfsqword(0x28u) != v30 );
  return result;
}

__int64 __fastcall sub_290C0(__int64 a1, char *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // r12
  __int64 v7; // rbx
  char *v8; // rax
  __int64 result; // rax

  v6 = a3;
  v7 = sub_286B0(a1, 4, a4, a5, a6);
  v8 = 0LL;
  if ( a2 )
    v8 = sub_BC120(a2);
  *(_QWORD *)(v7 + 8) = v8;
  *(_BYTE *)(v7 + 56) = v6;
  result = v7;
  *(_BYTE *)(v7 + 57) = 0;
  *(_BYTE *)(v7 + 58) = 0;
  return result;
}

__int64 __fastcall sub_29110(__int64 a1, char *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // r12
  __int64 v7; // rbx
  char *v8; // rax
  __int64 result; // rax

  v6 = a3;
  v7 = sub_286B0(a1, 5, a4, a5, a6);
  v8 = 0LL;
  if ( a2 )
    v8 = sub_BC120(a2);
  *(_QWORD *)(v7 + 8) = v8;
  *(_BYTE *)(v7 + 56) = v6;
  *(_QWORD *)(v7 + 68) = 429496729600LL;
  *(_DWORD *)(v7 + 60) = 5;
  result = v7;
  *(_BYTE *)(v7 + 64) = 0;
  *(_QWORD *)(v7 + 76) = 0LL;
  *(_DWORD *)(v7 + 84) = 0;
  *(_BYTE *)(v7 + 88) = 1;
  return result;
}

__int64 __fastcall sub_29180(__int64 a1, char *a2, char a3, int a4, __int64 a5, __int64 a6, __int64 a7)
{
  char v7; // r13
  int v8; // er12
  __int64 v9; // rbx
  char *v10; // rax
  __int64 result; // rax

  v7 = a3;
  v8 = a4;
  v9 = sub_286B0(a1, 5, a5, a6, a7);
  v10 = 0LL;
  if ( a2 )
    v10 = sub_BC120(a2);
  *(_QWORD *)(v9 + 8) = v10;
  *(_BYTE *)(v9 + 56) = v7;
  result = v9;
  *(_DWORD *)(v9 + 60) = 0;
  *(_BYTE *)(v9 + 64) = 0;
  *(_DWORD *)(v9 + 68) = 0;
  *(_DWORD *)(v9 + 72) = v8;
  *(_DWORD *)(v9 + 76) = 0;
  *(_QWORD *)(v9 + 80) = 0LL;
  *(_BYTE *)(v9 + 88) = 0;
  return result;
}

__int64 __fastcall sub_29200(__int64 a1, char *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // r12
  __int64 v7; // rbx
  char *v8; // rax
  __int64 result; // rax

  v6 = a3;
  v7 = sub_286B0(a1, 5, a4, a5, a6);
  v8 = 0LL;
  if ( a2 )
    v8 = sub_BC120(a2);
  *(_QWORD *)(v7 + 8) = v8;
  *(_BYTE *)(v7 + 56) = v6;
  *(_QWORD *)(v7 + 68) = 429496729600LL;
  *(_DWORD *)(v7 + 60) = 5;
  result = v7;
  *(_BYTE *)(v7 + 64) = 1;
  *(_QWORD *)(v7 + 76) = 0LL;
  *(_DWORD *)(v7 + 84) = 0;
  *(_BYTE *)(v7 + 88) = 0;
  return result;
}

__int64 __fastcall sub_29270(__int64 a1, char *a2, char a3, __int64 a4, char a5, char *a6, __int64 a7, __int64 a8, __int64 a9)
{
  char v9; // r14
  __int64 v10; // r13
  char v11; // r12
  char *v12; // rbp
  __int64 v13; // rbx
  char *v14; // rax

  v9 = a3;
  v10 = a4;
  v11 = a5;
  v12 = a6;
  v13 = sub_286B0(a1, 7, a7, a8, a9);
  v14 = 0LL;
  if ( a2 )
    v14 = sub_BC120(a2);
  *(_BYTE *)(v13 + 56) = v9;
  *(_QWORD *)(v13 + 64) = v10;
  *(_BYTE *)(v13 + 72) = v11;
  *(_QWORD *)(v13 + 8) = v14;
  *(_QWORD *)(v13 + 80) = sub_BC120(v12);
  return v13;
}

__int64 __fastcall sub_292F0(__int64 a1, char *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // r12
  __int64 v7; // rbx
  char *v8; // rax

  v6 = a3;
  v7 = sub_286B0(a1, 8, a4, a5, a6);
  v8 = 0LL;
  if ( a2 )
    v8 = sub_BC120(a2);
  *(_QWORD *)(v7 + 8) = v8;
  *(_BYTE *)(v7 + 56) = v6;
  return v7;
}

__int64 __fastcall sub_29330(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_286B0(a1, 9, 0LL, 0LL, 0LL);
  *(_QWORD *)(result + 56) = a2;
  return result;
}

__int64 __fastcall sub_29350(__int64 a1, char *a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = sub_286B0(a1, 0, a3, 0LL, 0LL);
  *(_QWORD *)(v3 + 8) = sub_BC120(a2);
  return v3;
}

__int64 __fastcall sub_29380(__int64 a1, char *a2, char a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // r12
  __int64 v7; // rbx
  char *v8; // rax

  v6 = a3;
  v7 = sub_286B0(a1, 3, a4, a5, a6);
  v8 = 0LL;
  if ( a2 )
    v8 = sub_BC120(a2);
  *(_QWORD *)(v7 + 8) = v8;
  *(_BYTE *)(v7 + 56) = v6;
  return v7;
}

void __fastcall sub_293C0(__int64 a1)
{
  __int64 v1; // rbx
  signed int v2; // eax
  __int64 v3; // r12
  int v4; // ebp
  void *v5; // rdi

  v1 = a1;
  sub_2F4D0(*(void **)(a1 + 8));
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 5 )
    goto LABEL_5;
  if ( v2 <= 5 )
  {
    if ( v2 != 2 )
      goto LABEL_6;
    if ( *(_DWORD *)(a1 + 64) > 0 )
    {
      v3 = 0LL;
      v4 = 0;
      do
      {
        ++v4;
        v5 = *(void **)(*(_QWORD *)(v1 + 72) + v3);
        v3 += 8LL;
        sub_2F4D0(v5);
      }
      while ( *(_DWORD *)(v1 + 64) > v4 );
    }
    sub_2F4D0(*(void **)(v1 + 72));
    sub_2F4D0(*(void **)(v1 + 80));
    sub_2F4D0(*(void **)(v1 + 88));
    sub_2F4D0((void *)v1);
  }
  else
  {
    if ( v2 != 6 )
    {
      if ( v2 != 7 )
      {
LABEL_6:
        sub_2F4D0((void *)a1);
        return;
      }
LABEL_5:
      sub_2F4D0(*(void **)(a1 + 80));
      goto LABEL_6;
    }
    sub_2F4D0(*(void **)(a1 + 64));
    sub_2F4D0((void *)a1);
  }
}

void __fastcall sub_29470(_QWORD *a1)
{
  _QWORD *v1; // rbp
  unsigned __int64 v2; // rbx
  __int64 v3; // rdi

  v1 = a1;
  sub_2F4D0((void *)*a1);
  sub_2F4D0((void *)a1[1]);
  sub_2F4D0((void *)a1[2]);
  if ( a1[4] )
  {
    v2 = 0LL;
    do
    {
      v3 = *(_QWORD *)(v1[6] + 8 * v2++);
      sub_293C0(v3);
    }
    while ( v1[4] > v2 );
  }
  sub_2F4D0((void *)v1[6]);
  sub_2F4D0(v1);
}

void __fastcall sub_294D0(unsigned __int64 *a1)
{
  unsigned __int64 *v1; // rbx
  unsigned __int64 v2; // rbp
  _QWORD *v3; // rdi
  unsigned __int64 v4; // rbp

  v1 = a1;
  if ( *a1 )
  {
    v2 = 0LL;
    do
    {
      v3 = *(_QWORD **)(v1[2] + 8 * v2++);
      sub_29470(v3);
    }
    while ( *v1 > v2 );
  }
  if ( v1[3] )
  {
    v4 = 0LL;
    do
    {
      (*(void (__fastcall **)(_QWORD))(v1[6] + 8 * v4))(*(_QWORD *)(v1[5] + 8 * v4));
      ++v4;
    }
    while ( v1[3] > v4 );
  }
  sub_2F4D0((void *)v1[2]);
  sub_2F4D0((void *)v1[5]);
  sub_2F4D0((void *)v1[6]);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_29560(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // r12
  _QWORD *v5; // rax
  __int64 v6; // rdi
  _QWORD *v7; // rbx
  __int64 v8; // rax

  v3 = a1;
  v4 = a3;
  v5 = (_QWORD *)sub_2F450(1uLL, 0x20uLL, 0LL);
  v6 = *(_QWORD *)(a1 + 8);
  v5[3] = v3;
  v7 = v5;
  *v5 = a2;
  v5[1] = v4;
  v5[2] = 0LL;
  v8 = sub_353D0(v6);
  v7[2] = sub_334C0(v8);
  return v7;
}

_QWORD *__fastcall sub_295C0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // r13
  __int64 v4; // rbp
  _QWORD *v5; // rax
  __int64 v6; // rdi
  _QWORD *v7; // rbx
  unsigned __int64 *v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rax

  v3 = (unsigned __int64 *)a3;
  v4 = a1;
  v5 = (_QWORD *)sub_2F450(1uLL, 0x28uLL, 0LL);
  v6 = *(_QWORD *)(a1 + 8);
  v5[4] = v4;
  *v5 = a2;
  v7 = v5;
  v5[1] = v3;
  v5[3] = 0LL;
  v5[2] = 0LL;
  v8 = sub_35380(v6, (unsigned __int64 *)a2, v3);
  v9 = *(_QWORD *)(v4 + 8);
  v7[3] = v8;
  v10 = sub_353D0(v9);
  v7[2] = sub_334C0(v10);
  return v7;
}

void __fastcall sub_29640(_QWORD *a1, _QWORD *a2, unsigned int a3)
{
  _QWORD *v3; // r12
  char v4; // bl

  v3 = a1;
  v4 = a3;
  sub_33240((__int64 *)*a1, (unsigned __int64 *)*a1, (unsigned __int64 *)*a2, a3);
  sub_33240((__int64 *)v3[1], (unsigned __int64 *)v3[1], (unsigned __int64 *)a2[1], v4);
  sub_33240((__int64 *)v3[2], (unsigned __int64 *)v3[2], (unsigned __int64 *)a2[2], v4);
}

void __fastcall sub_29690(_QWORD *a1, _QWORD *a2, unsigned int a3)
{
  __int64 **v3; // r12
  char v4; // bl

  v3 = (__int64 **)a1;
  v4 = a3;
  sub_33240((__int64 *)*a1, (unsigned __int64 *)*a1, (unsigned __int64 *)*a2, a3);
  sub_33240(v3[1], (unsigned __int64 *)v3[1], (unsigned __int64 *)a2[1], v4);
  sub_33240(v3[2], (unsigned __int64 *)v3[2], (unsigned __int64 *)a2[2], v4);
  sub_33240(v3[3], (unsigned __int64 *)v3[3], (unsigned __int64 *)a2[3], v4);
}

void __fastcall sub_296F0(_QWORD *a1, _QWORD *a2, char a3)
{
  char v3; // bl

  v3 = a3;
  sub_332B0((__int64 *)*a1, (_QWORD *)*a2, a3);
  sub_332B0((__int64 *)a1[1], (_QWORD *)a2[1], v3);
  sub_332B0((__int64 *)a1[2], (_QWORD *)a2[2], v3);
}

void __fastcall sub_29730(_QWORD *a1, _QWORD *a2, char a3)
{
  char v3; // bl

  v3 = a3;
  sub_332B0((__int64 *)*a1, (_QWORD *)*a2, a3);
  sub_332B0((__int64 *)a1[1], (_QWORD *)a2[1], v3);
  sub_332B0((__int64 *)a1[2], (_QWORD *)a2[2], v3);
  sub_332B0((__int64 *)a1[3], (_QWORD *)a2[3], v3);
}

_QWORD *__fastcall sub_29780(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 *v5; // r13
  unsigned __int64 *v6; // r12
  _QWORD *v7; // rbx
  __int64 **v8; // rax
  unsigned __int64 *v9; // rax
  __int64 v10; // rdi

  v4 = a1;
  v5 = (unsigned __int64 *)a3;
  v6 = (unsigned __int64 *)a4;
  v7 = (_QWORD *)sub_2F450(1uLL, 0x28uLL, 0LL);
  *v7 = sub_334C0(a1);
  v8 = sub_36310((__int64 *)a1);
  v7[1] = v8;
  v9 = sub_36450((__int64)v8, (unsigned __int64 *)a2);
  v10 = v7[1];
  v7[3] = v9;
  v7[4] = sub_36450(v10, v5);
  if ( v6 )
    v7[2] = sub_369B0(v4, v6);
  else
    v7[2] = 0LL;
  return v7;
}

void __fastcall sub_29820(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD **v2; // rdi

  v1 = a1;
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[3]);
  sub_330F0((_QWORD *)a1[4]);
  sub_35210((_QWORD **)a1[1]);
  v2 = (_QWORD **)a1[2];
  if ( v2 )
    sub_36A90(v2);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_29860(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // rbp
  unsigned __int64 *v4; // rax

  v3 = sub_36450(*(_QWORD *)(a1 + 8), (unsigned __int64 *)a3);
  v4 = sub_36450(*(_QWORD *)(a1 + 8), (unsigned __int64 *)a2);
  return sub_29560(a1, (__int64)v4, (__int64)v3);
}

_QWORD *__fastcall sub_298A0(_QWORD *a1)
{
  _QWORD *v1; // rbp
  _QWORD *v2; // rax
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  __int64 v5; // rbp

  v1 = a1;
  v2 = (_QWORD *)sub_2F450(1uLL, 0x20uLL, 0LL);
  v3 = (_QWORD *)*a1;
  v2[3] = v1;
  v4 = v2;
  v2[2] = 0LL;
  v2[1] = 0LL;
  *v2 = 0LL;
  v5 = sub_330E0(v3);
  *v4 = sub_33090(v5);
  v4[1] = sub_33090(v5);
  v4[2] = sub_33090(v5);
  return v4;
}

__int64 __fastcall sub_29920(_QWORD *a1, _QWORD *a2)
{
  sub_331D0((unsigned __int64 *)*a1, (unsigned __int64 *)*a2);
  sub_331D0((unsigned __int64 *)a1[1], (unsigned __int64 *)a2[1]);
  return sub_331D0((unsigned __int64 *)a1[2], (unsigned __int64 *)a2[2]);
}

__int64 *__fastcall sub_29960(_QWORD *a1)
{
  _QWORD *v1; // rbp
  __int64 v2; // r12
  _QWORD *v3; // rax
  __int64 v4; // rdi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rdi
  _QWORD *v8; // rax
  __int64 v9; // rdi

  v1 = a1;
  v2 = a1[3];
  v3 = (_QWORD *)sub_2F450(1uLL, 0x20uLL, 0LL);
  *v3 = 0LL;
  v4 = *a1;
  v5 = v3;
  v3[3] = v2;
  v3[2] = 0LL;
  v3[1] = 0LL;
  v6 = sub_334C0(v4);
  v7 = v1[1];
  *v5 = v6;
  v8 = sub_334C0(v7);
  v9 = v1[2];
  v5[1] = v8;
  v5[2] = sub_334C0(v9);
  return v5;
}

void __fastcall sub_299D0(_QWORD *a1)
{
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[1]);
  sub_330F0((_QWORD *)a1[2]);
  sub_BD070(a1, 0x20uLL);
  sub_2F4D0(a1);
}

_QWORD *__fastcall sub_29A10(_QWORD *a1, __int64 a2, unsigned __int8 a3)
{
  _QWORD *v3; // rbx
  unsigned __int64 *v4; // r13
  unsigned __int64 *v5; // r15
  __int64 *v6; // r14
  unsigned __int64 *v7; // rbp
  __int64 *v8; // r12
  unsigned __int64 *v9; // rbp
  unsigned __int64 *v10; // r14
  char v11; // r12
  _QWORD *result; // rax
  unsigned __int8 v13; // [rsp+Ch] [rbp-4Ch]
  int v14; // [rsp+14h] [rbp-44h]
  unsigned __int64 v15; // [rsp+18h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  v13 = a3;
  if ( !a1[2] )
    goto LABEL_10;
  v3 = a1;
  v4 = sub_36450(a1[1], (unsigned __int64 *)a2);
  v5 = sub_35380(a1[1], v4, v4);
  v6 = sub_36770((__int64 **)v3[1], v5, (unsigned __int64 *)v3[3]);
  v7 = sub_35380(a1[1], (unsigned __int64 *)v6, v4);
  v8 = sub_36770((__int64 **)v3[1], v7, (unsigned __int64 *)v3[4]);
  sub_330F0(v5);
  sub_330F0(v6);
  sub_330F0(v7);
  v9 = sub_36AE0(a1[2], (unsigned __int64 *)v8, &v14);
  sub_330F0(v8);
  if ( v14 )
  {
    v10 = sub_35490(a1[1], v9);
    v11 = sub_33500(v10, 0LL);
    sub_338D0((__int64 *)v10, (_QWORD *)*a1, v9);
    sub_33240((__int64 *)v9, v9, v10, (v11 ^ v13) & 1);
    sub_330F0(v10);
    result = sub_29560((__int64)a1, (__int64)v4, (__int64)v9);
  }
  else
  {
    sub_330F0(v4);
    sub_330F0(v9);
    result = 0LL;
  }
  if ( __readfsqword(0x28u) != v15 )
LABEL_10:
    __assert_fail("wc->sc", "ecc.c", 0x90u, "ecc_weierstrass_point_new_from_x");
  return result;
}

__int64 **__fastcall sub_29B90(_QWORD *a1, _QWORD *a2)
{
  __int64 *v2; // rbp
  unsigned __int64 **v3; // r15
  __int64 **v4; // rax
  __int64 v5; // r13
  __int64 **v6; // rbx
  unsigned __int64 *v7; // rsi
  unsigned __int64 *v8; // r12
  unsigned __int64 *v9; // ST30_8
  unsigned __int64 *v10; // rbp
  unsigned __int64 *v11; // ST38_8
  unsigned __int64 *v12; // ST20_8
  unsigned __int64 *v13; // rax
  unsigned __int64 *v14; // r15
  __int64 *v15; // r15
  unsigned __int64 *v16; // r13
  unsigned __int64 *v17; // rbp
  unsigned __int64 *v18; // r14
  __int64 *v19; // rax
  __int64 *v20; // ST58_8
  unsigned __int64 *v21; // rax
  unsigned __int64 *v22; // ST50_8
  __int64 *v23; // rax
  __int64 v24; // rdi
  unsigned __int64 *v25; // ST48_8
  __int64 *v26; // ST38_8
  unsigned __int64 *v27; // r12
  unsigned __int64 *v28; // rax
  unsigned __int64 *v29; // ST30_8
  __int64 *v30; // rax
  __int64 v31; // rdi
  unsigned __int64 *v33; // [rsp+8h] [rbp-90h]
  unsigned __int64 *v34; // [rsp+10h] [rbp-88h]
  unsigned __int64 *v35; // [rsp+18h] [rbp-80h]
  __int64 *v36; // [rsp+20h] [rbp-78h]
  __int64 *v37; // [rsp+28h] [rbp-70h]
  unsigned __int64 *v38; // [rsp+40h] [rbp-58h]

  v2 = (__int64 *)a2[3];
  if ( v2 != (__int64 *)a1[3] )
    __assert_fail("Q->wc == wc", "ecc.c", 0x12Bu, "ecc_weierstrass_add");
  v3 = (unsigned __int64 **)a2;
  v4 = (__int64 **)sub_2F450(1uLL, 0x20uLL, 0LL);
  v4[3] = v2;
  v5 = a1[3];
  v6 = v4;
  v4[2] = 0LL;
  v7 = (unsigned __int64 *)a1[2];
  v4[1] = 0LL;
  *v4 = 0LL;
  v8 = sub_35380(*(_QWORD *)(v5 + 8), v7, v7);
  v9 = sub_35380(*(_QWORD *)(v5 + 8), v8, (unsigned __int64 *)a1[2]);
  v10 = sub_35380(*(_QWORD *)(v5 + 8), v3[2], v3[2]);
  v11 = sub_35380(*(_QWORD *)(v5 + 8), v10, v3[2]);
  v33 = sub_35380(*(_QWORD *)(v5 + 8), (unsigned __int64 *)*a1, v10);
  v34 = sub_35380(*(_QWORD *)(v5 + 8), (unsigned __int64 *)a1[1], v11);
  v35 = sub_35380(*(_QWORD *)(v5 + 8), *v3, v8);
  v12 = sub_35380(*(_QWORD *)(v5 + 8), v3[1], v9);
  v13 = sub_35380(*(_QWORD *)(v5 + 8), (unsigned __int64 *)a1[2], v3[2]);
  v14 = v12;
  v38 = v13;
  v36 = sub_36800(*(__int64 ***)(v5 + 8), v12, v34);
  v37 = sub_36800(*(__int64 ***)(v5 + 8), v35, v33);
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v14);
  if ( (unsigned int)sub_341A0(v36, 0LL) )
    __assert_fail("!mp_eq_integer(lambda_n, 0)", "ecc.c", 0x137u, "ecc_weierstrass_add");
  v15 = v6[3];
  v16 = sub_35380(v15[1], (unsigned __int64 *)v36, (unsigned __int64 *)v36);
  v17 = sub_35380(v15[1], (unsigned __int64 *)v37, (unsigned __int64 *)v37);
  v18 = sub_35380(v15[1], (unsigned __int64 *)v37, v17);
  v19 = sub_36770((__int64 **)v15[1], v33, v35);
  v20 = v19;
  v21 = sub_35380(v15[1], v17, (unsigned __int64 *)v19);
  v22 = v21;
  v23 = sub_36800((__int64 **)v15[1], v16, v21);
  v24 = v15[1];
  *v6 = v23;
  v25 = sub_35380(v24, v17, v33);
  v26 = sub_36800((__int64 **)v15[1], v25, (unsigned __int64 *)*v6);
  v27 = sub_35380(v15[1], (unsigned __int64 *)v36, (unsigned __int64 *)v26);
  v28 = sub_35380(v15[1], v18, v34);
  v29 = v28;
  v30 = sub_36800((__int64 **)v15[1], v27, v28);
  v31 = v15[1];
  v6[1] = v30;
  v6[2] = (__int64 *)sub_35380(v31, v38, (unsigned __int64 *)v37);
  sub_330F0(v16);
  sub_330F0(v17);
  sub_330F0(v18);
  sub_330F0(v20);
  sub_330F0(v26);
  sub_330F0(v22);
  sub_330F0(v27);
  sub_330F0(v25);
  sub_330F0(v29);
  sub_330F0(v33);
  sub_330F0(v34);
  sub_330F0(v35);
  sub_330F0(v38);
  sub_330F0(v36);
  sub_330F0(v37);
  return v6;
}

__int64 **__fastcall sub_29F10(_QWORD *a1)
{
  _QWORD *v1; // r13
  __int64 *v2; // rbp
  __int64 **v3; // rax
  unsigned __int64 *v4; // rsi
  __int64 **v5; // rbx
  __int64 v6; // rbp
  unsigned __int64 *v7; // r15
  __int64 *v8; // ST18_8
  __int64 *v9; // r14
  unsigned __int64 *v10; // ST10_8
  unsigned __int64 *v11; // ST08_8
  unsigned __int64 *v12; // r12
  __int64 *v13; // ST00_8
  __int64 *v14; // rbp
  __int64 *v15; // r12
  unsigned __int64 *v16; // r14
  unsigned __int64 *v17; // r15
  unsigned __int64 *v18; // ST18_8
  unsigned __int64 *v19; // ST08_8
  unsigned __int64 *v20; // r13
  unsigned __int64 *v21; // ST10_8
  __int64 *v22; // rax
  __int64 *v23; // ST38_8
  unsigned __int64 *v24; // rax
  unsigned __int64 *v25; // ST30_8
  __int64 *v26; // rax
  __int64 v27; // rdi
  unsigned __int64 *v28; // ST28_8
  __int64 *v29; // ST20_8
  unsigned __int64 *v30; // r14
  unsigned __int64 *v31; // rax
  unsigned __int64 *v32; // r15
  __int64 *v33; // rax
  __int64 v34; // rdi

  v1 = a1;
  v2 = (__int64 *)a1[3];
  v3 = (__int64 **)sub_2F450(1uLL, 0x20uLL, 0LL);
  *v3 = 0LL;
  v4 = (unsigned __int64 *)*a1;
  v5 = v3;
  v3[3] = v2;
  v6 = a1[3];
  v3[2] = 0LL;
  v3[1] = 0LL;
  v7 = sub_35380(*(_QWORD *)(v6 + 8), v4, v4);
  v8 = sub_36770(*(__int64 ***)(v6 + 8), v7, v7);
  v9 = sub_36770(*(__int64 ***)(v6 + 8), v8, v7);
  v10 = sub_35380(*(_QWORD *)(v6 + 8), (unsigned __int64 *)v1[2], (unsigned __int64 *)v1[2]);
  v11 = sub_35380(*(_QWORD *)(v6 + 8), v10, v10);
  v12 = sub_35380(*(_QWORD *)(v6 + 8), *(unsigned __int64 **)(v6 + 24), v11);
  v13 = sub_36770(*(__int64 ***)(v6 + 8), v9, v12);
  v14 = sub_36770(*(__int64 ***)(v6 + 8), (_QWORD *)v1[1], (unsigned __int64 *)v1[1]);
  sub_330F0(v7);
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v12);
  v15 = v5[3];
  v16 = (unsigned __int64 *)*a1;
  v17 = (unsigned __int64 *)a1[1];
  v18 = (unsigned __int64 *)a1[2];
  v19 = sub_35380(v15[1], (unsigned __int64 *)v13, (unsigned __int64 *)v13);
  v20 = sub_35380(v15[1], (unsigned __int64 *)v14, (unsigned __int64 *)v14);
  v21 = sub_35380(v15[1], (unsigned __int64 *)v14, v20);
  v22 = sub_36770((__int64 **)v15[1], v16, v16);
  v23 = v22;
  v24 = sub_35380(v15[1], v20, (unsigned __int64 *)v22);
  v25 = v24;
  v26 = sub_36800((__int64 **)v15[1], v19, v24);
  v27 = v15[1];
  *v5 = v26;
  v28 = sub_35380(v27, v20, v16);
  v29 = sub_36800((__int64 **)v15[1], v28, (unsigned __int64 *)*v5);
  v30 = sub_35380(v15[1], (unsigned __int64 *)v13, (unsigned __int64 *)v29);
  v31 = sub_35380(v15[1], v21, v17);
  v32 = v31;
  v33 = sub_36800((__int64 **)v15[1], v30, v31);
  v34 = v15[1];
  v5[1] = v33;
  v5[2] = (__int64 *)sub_35380(v34, v18, (unsigned __int64 *)v14);
  sub_330F0(v19);
  sub_330F0(v20);
  sub_330F0(v21);
  sub_330F0(v23);
  sub_330F0(v29);
  sub_330F0(v25);
  sub_330F0(v30);
  sub_330F0(v28);
  sub_330F0(v32);
  sub_330F0(v13);
  sub_330F0(v14);
  return v5;
}

__int64 **__fastcall sub_2A1D0(_QWORD *a1, _QWORD *a2)
{
  __int64 *v2; // rbp
  unsigned __int64 **v3; // r15
  unsigned __int64 **v4; // r12
  __int64 **v5; // rax
  __int64 v6; // r14
  __int64 **v7; // rbx
  unsigned __int64 *v8; // rsi
  unsigned __int64 *v9; // r13
  unsigned __int64 *v10; // ST30_8
  unsigned __int64 *v11; // rbp
  unsigned __int64 *v12; // ST38_8
  unsigned __int64 *v13; // ST10_8
  unsigned __int64 *v14; // ST18_8
  unsigned __int64 *v15; // ST20_8
  unsigned __int64 *v16; // ST40_8
  unsigned __int64 *v17; // ST58_8
  __int64 *v18; // ST08_8
  __int64 *v19; // ST28_8
  __int64 v20; // rbp
  unsigned __int64 *v21; // r13
  __int64 *v22; // ST60_8
  __int64 *v23; // ST30_8
  unsigned __int64 *v24; // r14
  unsigned __int64 *v25; // ST40_8
  unsigned __int64 *v26; // ST38_8
  __int64 *v27; // ST48_8
  __int64 *v28; // ST50_8
  __int64 *v29; // r14
  __int64 *v30; // r13
  unsigned __int64 *v31; // ST30_8
  unsigned __int64 *v32; // rbp
  unsigned __int64 *v33; // ST38_8
  __int64 *v34; // rax
  __int64 *v35; // ST78_8
  unsigned __int64 *v36; // rax
  unsigned __int64 *v37; // ST70_8
  __int64 *v38; // rax
  __int64 v39; // rdi
  unsigned __int64 *v40; // ST68_8
  __int64 *v41; // ST60_8
  unsigned __int64 *v42; // ST40_8
  unsigned __int64 *v43; // rax
  unsigned __int64 *v44; // r14
  __int64 *v45; // rax
  __int64 v46; // rdi

  v2 = (__int64 *)a2[3];
  if ( v2 != (__int64 *)a1[3] )
    __assert_fail("Q->wc == wc", "ecc.c", 0x180u, "ecc_weierstrass_add_general");
  v3 = (unsigned __int64 **)a1;
  v4 = (unsigned __int64 **)a2;
  v5 = (__int64 **)sub_2F450(1uLL, 0x20uLL, 0LL);
  v5[3] = v2;
  v6 = a1[3];
  v7 = v5;
  v5[2] = 0LL;
  v8 = (unsigned __int64 *)a1[2];
  v5[1] = 0LL;
  *v5 = 0LL;
  v9 = sub_35380(*(_QWORD *)(v6 + 8), v8, v8);
  v10 = sub_35380(*(_QWORD *)(v6 + 8), v9, (unsigned __int64 *)a1[2]);
  v11 = sub_35380(*(_QWORD *)(v6 + 8), v4[2], v4[2]);
  v12 = sub_35380(*(_QWORD *)(v6 + 8), v11, v4[2]);
  v13 = sub_35380(*(_QWORD *)(v6 + 8), (unsigned __int64 *)*a1, v11);
  v14 = sub_35380(*(_QWORD *)(v6 + 8), (unsigned __int64 *)a1[1], v12);
  v15 = sub_35380(*(_QWORD *)(v6 + 8), *v4, v9);
  v16 = sub_35380(*(_QWORD *)(v6 + 8), v4[1], v10);
  v17 = sub_35380(*(_QWORD *)(v6 + 8), (unsigned __int64 *)a1[2], v4[2]);
  v18 = sub_36800(*(__int64 ***)(v6 + 8), v16, v14);
  v19 = sub_36800(*(__int64 ***)(v6 + 8), v15, v13);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v12);
  sub_330F0(v16);
  v20 = a1[3];
  v21 = sub_35380(*(_QWORD *)(v20 + 8), *v3, *v3);
  v22 = sub_36770(*(__int64 ***)(v20 + 8), v21, v21);
  v23 = sub_36770(*(__int64 ***)(v20 + 8), v22, v21);
  v24 = sub_35380(*(_QWORD *)(v20 + 8), v3[2], v3[2]);
  v25 = sub_35380(*(_QWORD *)(v20 + 8), v24, v24);
  v26 = sub_35380(*(_QWORD *)(v20 + 8), *(unsigned __int64 **)(v20 + 24), v25);
  v27 = sub_36770(*(__int64 ***)(v20 + 8), v23, v26);
  v28 = sub_36770(*(__int64 ***)(v20 + 8), v3[1], v3[1]);
  sub_330F0(v21);
  sub_330F0(v22);
  sub_330F0(v23);
  sub_330F0(v24);
  sub_330F0(v25);
  sub_330F0(v26);
  LOBYTE(v20) = sub_341A0(v19, 0LL);
  LOBYTE(v20) = sub_341A0(v18, 0LL) & v20;
  v29 = v19;
  sub_33240(v18, (unsigned __int64 *)v18, (unsigned __int64 *)v27, v20);
  sub_33240(v29, (unsigned __int64 *)v29, (unsigned __int64 *)v28, v20);
  v30 = v7[3];
  v31 = sub_35380(v30[1], (unsigned __int64 *)v18, (unsigned __int64 *)v18);
  v32 = sub_35380(v30[1], (unsigned __int64 *)v29, (unsigned __int64 *)v29);
  v33 = sub_35380(v30[1], (unsigned __int64 *)v19, v32);
  v34 = sub_36770((__int64 **)v30[1], v13, v15);
  v35 = v34;
  v36 = sub_35380(v30[1], v32, (unsigned __int64 *)v34);
  v37 = v36;
  v38 = sub_36800((__int64 **)v30[1], v31, v36);
  v39 = v30[1];
  *v7 = v38;
  v40 = sub_35380(v39, v32, v13);
  v41 = sub_36800((__int64 **)v30[1], v40, (unsigned __int64 *)*v7);
  v42 = sub_35380(v30[1], (unsigned __int64 *)v18, (unsigned __int64 *)v41);
  v43 = sub_35380(v30[1], v33, v14);
  v44 = v43;
  v45 = sub_36800((__int64 **)v30[1], v42, v43);
  v46 = v30[1];
  v7[1] = v45;
  v7[2] = (__int64 *)sub_35380(v46, v17, (unsigned __int64 *)v19);
  sub_330F0(v31);
  sub_330F0(v32);
  sub_330F0(v33);
  sub_330F0(v35);
  sub_330F0(v41);
  sub_330F0(v37);
  sub_330F0(v42);
  sub_330F0(v40);
  sub_330F0(v44);
  LOBYTE(v32) = sub_341A0((signed __int64 *)v3[2], 0LL);
  sub_33240(*v7, (unsigned __int64 *)*v7, *v4, (char)v32);
  sub_33240(v7[1], (unsigned __int64 *)v7[1], v4[1], (char)v32);
  sub_33240(v7[2], (unsigned __int64 *)v7[2], v4[2], (char)v32);
  LOBYTE(v32) = sub_341A0((signed __int64 *)v4[2], 0LL);
  sub_33240(*v7, (unsigned __int64 *)*v7, *v3, (char)v32);
  sub_33240(v7[1], (unsigned __int64 *)v7[1], v3[1], (char)v32);
  sub_33240(v7[2], (unsigned __int64 *)v7[2], v3[2], (char)v32);
  LOBYTE(v32) = sub_341A0(v7[2], 0LL);
  sub_33350(*v7, (char)v32);
  sub_33350(v7[1], (char)v32);
  sub_330F0(v13);
  sub_330F0(v14);
  sub_330F0(v15);
  sub_330F0(v17);
  sub_330F0(v18);
  sub_330F0(v19);
  sub_330F0(v27);
  sub_330F0(v28);
  return v7;
}

__int64 **__fastcall sub_2A720(_QWORD *a1, __int64 a2)
{
  __int64 **v2; // rax
  __int64 **v3; // r15
  __int64 *v4; // rbp
  __int64 *v5; // r14
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned int v8; // er15
  unsigned __int64 v9; // ST00_8
  int v10; // ebx
  __int64 **v11; // r13
  __int64 **v12; // r12
  __int64 *v13; // rdi
  unsigned int v14; // edx
  __int64 **v16; // [rsp+8h] [rbp-50h]
  _QWORD *v17; // [rsp+10h] [rbp-48h]

  v17 = a1;
  v2 = sub_29F10(a1);
  v3 = v2;
  v16 = v2;
  v4 = sub_29960(a1);
  v5 = sub_29960(v3);
  v6 = sub_330E0((_QWORD *)a2);
  if ( v6 )
  {
    v7 = v6 - 1;
    v8 = 1;
    do
    {
      v9 = v7;
      v10 = sub_33500((unsigned __int64 *)a2, v7);
      v11 = sub_29B90(v4, v5);
      sub_296F0(v4, v5, v10);
      v12 = sub_29F10(v4);
      sub_299D0(v4);
      v13 = v5;
      v4 = (__int64 *)v12;
      v5 = (__int64 *)v11;
      sub_299D0(v13);
      sub_296F0(v12, v11, v10);
      sub_29640(v12, v17, v8);
      v14 = v8;
      v8 &= ~v10;
      sub_29640(v11, v16, v14);
      v7 = v9 - 1;
    }
    while ( v9 );
  }
  else
  {
    v11 = (__int64 **)v5;
    v12 = (__int64 **)v4;
  }
  sub_299D0(v16);
  sub_299D0(v11);
  return v12;
}

unsigned __int64 __fastcall sub_2A850(__int64 a1)
{
  return sub_341A0(*(signed __int64 **)(a1 + 16), 0LL);
}

void __fastcall sub_2A860(_QWORD *a1, __int64 *a2, __int64 *a3)
{
  unsigned __int64 **v3; // r13
  __int64 *v4; // r14
  __int64 v5; // rbx
  unsigned __int64 *v6; // rbp
  unsigned __int64 *v7; // r12
  unsigned __int64 *v8; // ST08_8

  v3 = (unsigned __int64 **)a1;
  v4 = a3;
  v5 = a1[3];
  v6 = sub_35600(*(_QWORD *)(v5 + 8), (unsigned __int64 *)a1[2]);
  v7 = sub_35380(*(_QWORD *)(v5 + 8), v6, v6);
  v8 = sub_35380(*(_QWORD *)(v5 + 8), v7, v6);
  sub_35260(*(_QWORD *)(v5 + 8), *v3, *v3, v7);
  sub_35260(*(_QWORD *)(v5 + 8), v3[1], v3[1], v8);
  sub_35260(*(_QWORD *)(v5 + 8), v3[2], v3[2], v6);
  sub_330F0(v6);
  sub_330F0(v7);
  sub_330F0(v8);
  if ( a2 )
    *a2 = (__int64)sub_35490(*(_QWORD *)(v5 + 8), (_QWORD *)*a1);
  if ( v4 )
    *v4 = (__int64)sub_35490(*(_QWORD *)(v5 + 8), (_QWORD *)a1[1]);
}

__int64 __fastcall sub_2A940(_QWORD *a1)
{
  unsigned __int64 **v1; // rbp
  __int64 v2; // rbx
  unsigned __int64 *v3; // r15
  unsigned __int64 *v4; // ST28_8
  unsigned __int64 *v5; // r14
  unsigned __int64 *v6; // r12
  unsigned __int64 *v7; // r13
  unsigned __int64 *v8; // ST20_8
  unsigned __int64 *v9; // ST18_8
  __int64 *v10; // rbp
  unsigned __int64 *v11; // ST10_8
  unsigned __int64 *v12; // ST08_8
  __int64 *v13; // rbx
  unsigned int v14; // ST04_4

  v1 = (unsigned __int64 **)a1;
  v2 = a1[3];
  v3 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)a1[1], (unsigned __int64 *)a1[1]);
  v4 = sub_35380(*(_QWORD *)(v2 + 8), *v1, *v1);
  v5 = sub_35380(*(_QWORD *)(v2 + 8), v4, (unsigned __int64 *)*a1);
  v6 = sub_35380(*(_QWORD *)(v2 + 8), v1[2], v1[2]);
  v7 = sub_35380(*(_QWORD *)(v2 + 8), v6, v6);
  v8 = sub_35380(*(_QWORD *)(v2 + 8), *(unsigned __int64 **)(v2 + 24), v7);
  v9 = sub_35380(*(_QWORD *)(v2 + 8), v8, (unsigned __int64 *)*a1);
  v10 = sub_36770(*(__int64 ***)(v2 + 8), v5, v9);
  v11 = sub_35380(*(_QWORD *)(v2 + 8), v6, v7);
  v12 = sub_35380(*(_QWORD *)(v2 + 8), *(unsigned __int64 **)(v2 + 32), v11);
  v13 = sub_36770(*(__int64 ***)(v2 + 8), v10, v12);
  v14 = sub_34130(v3, (unsigned __int64 *)v13);
  sub_330F0(v3);
  sub_330F0(v4);
  sub_330F0(v5);
  sub_330F0(v6);
  sub_330F0(v7);
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v12);
  sub_330F0(v13);
  return v14;
}

_QWORD *__fastcall sub_2AAC0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // r13
  __int64 v4; // rbx
  __int64 **v5; // rax
  unsigned __int64 *v6; // rax
  __int64 v7; // rdi
  unsigned __int64 *v8; // r14
  unsigned __int64 *v9; // r13
  __int64 *v10; // rbp
  unsigned __int64 *v11; // r12

  v3 = (unsigned __int64 *)a3;
  v4 = sub_2F450(1uLL, 0x28uLL, 0LL);
  *(_QWORD *)v4 = sub_334C0(a1);
  v5 = sub_36310((__int64 *)a1);
  *(_QWORD *)(v4 + 8) = v5;
  v6 = sub_36450((__int64)v5, (unsigned __int64 *)a2);
  v7 = *(_QWORD *)(v4 + 8);
  *(_QWORD *)(v4 + 16) = v6;
  *(_QWORD *)(v4 + 24) = sub_36450(v7, v3);
  v8 = sub_330A0(4LL);
  v9 = sub_355D0(v8, *(__int64 **)v4);
  v10 = sub_334C0(a2);
  sub_33A80(v10, (unsigned __int64 *)v10, 2uLL);
  v11 = sub_362D0((unsigned __int64 *)v10, v9, *(__int64 **)v4);
  *(_QWORD *)(v4 + 32) = sub_36450(*(_QWORD *)(v4 + 8), v11);
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  return (_QWORD *)v4;
}

void __fastcall sub_2ABA0(_QWORD *a1)
{
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[2]);
  sub_330F0((_QWORD *)a1[3]);
  sub_330F0((_QWORD *)a1[4]);
  sub_35210((_QWORD **)a1[1]);
  sub_2F4D0(a1);
}

unsigned __int64 **__fastcall sub_2ABE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  unsigned __int64 **v3; // rax
  __int64 v4; // rdi
  unsigned __int64 **v5; // rbx
  unsigned __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rax

  v2 = a1;
  v3 = (unsigned __int64 **)sub_2F450(1uLL, 0x18uLL, 0LL);
  v4 = *(_QWORD *)(a1 + 8);
  v3[2] = (unsigned __int64 *)v2;
  v3[1] = 0LL;
  *v3 = 0LL;
  v5 = v3;
  v6 = sub_36450(v4, (unsigned __int64 *)a2);
  v7 = *(_QWORD *)(v2 + 8);
  *v5 = v6;
  v8 = sub_353D0(v7);
  v5[1] = sub_334C0(v8);
  return v5;
}

__int64 __fastcall sub_2AC40(_QWORD *a1, _QWORD *a2)
{
  sub_331D0((unsigned __int64 *)*a1, (unsigned __int64 *)*a2);
  return sub_331D0((unsigned __int64 *)a1[1], (unsigned __int64 *)a2[1]);
}

__int64 *__fastcall sub_2AC70(_QWORD *a1)
{
  _QWORD *v1; // rbp
  __int64 v2; // r12
  _QWORD *v3; // rax
  __int64 v4; // rdi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rdi

  v1 = a1;
  v2 = a1[2];
  v3 = (_QWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  *v3 = 0LL;
  v4 = *a1;
  v5 = v3;
  v3[2] = v2;
  v3[1] = 0LL;
  v6 = sub_334C0(v4);
  v7 = v1[1];
  *v5 = v6;
  v5[1] = sub_334C0(v7);
  return v5;
}

void __fastcall sub_2ACD0(_QWORD *a1)
{
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[1]);
  sub_BD070(a1, 0x18uLL);
  sub_2F4D0(a1);
}

unsigned __int64 **__fastcall sub_2AD00(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // r12
  unsigned __int64 **v4; // r15
  unsigned __int64 **v5; // rbp
  unsigned __int64 **v6; // rbx
  unsigned __int64 **v7; // rax
  __int64 **v8; // rdi
  unsigned __int64 **v9; // r14
  unsigned __int64 *v10; // rdx
  unsigned __int64 *v11; // rsi
  __int64 *v12; // r13
  __int64 *v13; // rbp
  __int64 *v14; // ST08_8
  __int64 *v15; // ST18_8
  __int64 *v16; // ST38_8
  unsigned __int64 *v17; // r13
  __int64 *v18; // ST20_8
  unsigned __int64 *v19; // rbx
  __int64 *v20; // rbp
  unsigned __int64 *v21; // ST28_8
  __int64 *v22; // rbx
  unsigned __int64 *v23; // ST10_8
  unsigned __int64 *v24; // ST30_8

  v3 = a2[2];
  if ( v3 != a1[2] )
    __assert_fail("Q->mc == mc", "ecc.c", 0x296u, "ecc_montgomery_diff_add");
  v4 = (unsigned __int64 **)a3;
  if ( v3 != a3[2] )
    __assert_fail(aPminus, "ecc.c", 0x297u, "ecc_montgomery_diff_add");
  v5 = (unsigned __int64 **)a1;
  v6 = (unsigned __int64 **)a2;
  v7 = (unsigned __int64 **)sub_2F450(1uLL, 0x18uLL, 0LL);
  v8 = *(__int64 ***)(v3 + 8);
  v7[1] = 0LL;
  v9 = v7;
  v10 = v5[1];
  *v7 = 0LL;
  v11 = *v5;
  v7[2] = (unsigned __int64 *)v3;
  v12 = sub_36800(v8, v11, v10);
  v13 = sub_36770(*(__int64 ***)(v3 + 8), *v5, v5[1]);
  v14 = sub_36800(*(__int64 ***)(v3 + 8), *v6, v6[1]);
  v15 = v12;
  v16 = sub_36770(*(__int64 ***)(v3 + 8), *v6, v6[1]);
  v17 = sub_35380(*(_QWORD *)(v3 + 8), (unsigned __int64 *)v12, (unsigned __int64 *)v16);
  v18 = v13;
  v19 = sub_35380(*(_QWORD *)(v3 + 8), (unsigned __int64 *)v13, (unsigned __int64 *)v14);
  v20 = sub_36770(*(__int64 ***)(v3 + 8), v17, v19);
  v21 = v19;
  v22 = sub_36800(*(__int64 ***)(v3 + 8), v17, v19);
  v23 = sub_35380(*(_QWORD *)(v3 + 8), (unsigned __int64 *)v20, (unsigned __int64 *)v20);
  v24 = sub_35380(*(_QWORD *)(v3 + 8), (unsigned __int64 *)v22, (unsigned __int64 *)v22);
  *v9 = sub_35380(*(_QWORD *)(v3 + 8), v23, v4[1]);
  v9[1] = sub_35380(*(_QWORD *)(v3 + 8), v24, *v4);
  sub_330F0(v15);
  sub_330F0(v18);
  sub_330F0(v14);
  sub_330F0(v16);
  sub_330F0(v17);
  sub_330F0(v21);
  sub_330F0(v20);
  sub_330F0(v22);
  sub_330F0(v23);
  sub_330F0(v24);
  return v9;
}

unsigned __int64 **__fastcall sub_2AF20(__int64 *a1)
{
  __int64 *v1; // rbp
  __int64 v2; // rbx
  unsigned __int64 **v3; // rax
  unsigned __int64 **v4; // r12
  unsigned __int64 *v5; // rdx
  __int64 **v6; // rdi
  unsigned __int64 *v7; // rsi
  __int64 *v8; // r15
  __int64 *v9; // r14
  unsigned __int64 *v10; // r13
  unsigned __int64 *v11; // rax
  unsigned __int64 *v12; // ST28_8
  unsigned __int64 *v13; // rax
  unsigned __int64 *v14; // rdx
  unsigned __int64 *v15; // ST20_8
  __int64 *v16; // ST18_8
  __int64 *v17; // rbp
  unsigned __int64 *v18; // ST10_8
  __int64 *v19; // ST08_8

  v1 = a1;
  v2 = a1[2];
  v3 = (unsigned __int64 **)sub_2F450(1uLL, 0x18uLL, 0LL);
  v3[1] = 0LL;
  *v3 = 0LL;
  v4 = v3;
  v5 = (unsigned __int64 *)a1[1];
  v6 = *(__int64 ***)(v2 + 8);
  v7 = (unsigned __int64 *)*v1;
  v3[2] = (unsigned __int64 *)v2;
  v8 = sub_36800(v6, v7, v5);
  v9 = sub_36770(*(__int64 ***)(v2 + 8), (_QWORD *)*v1, (unsigned __int64 *)v1[1]);
  v10 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v8, (unsigned __int64 *)v8);
  v11 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v9, (unsigned __int64 *)v9);
  v12 = v11;
  v13 = sub_35380(*(_QWORD *)(v2 + 8), v10, v11);
  v14 = (unsigned __int64 *)v1[1];
  *v4 = v13;
  v15 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)*v1, v14);
  v16 = sub_36770(*(__int64 ***)(v2 + 8), v15, v15);
  v17 = sub_36770(*(__int64 ***)(v2 + 8), v16, (unsigned __int64 *)v16);
  v18 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v17, *(unsigned __int64 **)(v2 + 32));
  v19 = sub_36770(*(__int64 ***)(v2 + 8), v10, v18);
  v4[1] = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v17, (unsigned __int64 *)v19);
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v12);
  sub_330F0(v15);
  sub_330F0(v16);
  sub_330F0(v17);
  sub_330F0(v18);
  sub_330F0(v19);
  return v4;
}

__int64 **__fastcall sub_2B0B0(__int64 *a1, __int64 a2)
{
  unsigned __int64 **v2; // rax
  unsigned __int64 **v3; // r14
  __int64 *v4; // r13
  __int64 *v5; // r15
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  signed int v8; // er14
  unsigned __int64 v9; // ST08_8
  int v10; // ebx
  __int64 **v11; // r12
  __int64 **v12; // rbp
  char v13; // cl
  unsigned __int64 **v15; // [rsp+10h] [rbp-48h]

  v2 = sub_2AF20(a1);
  v3 = v2;
  v15 = v2;
  v4 = sub_2AC70(a1);
  v5 = sub_2AC70(v3);
  v6 = sub_330E0((_QWORD *)a2);
  if ( v6 )
  {
    v7 = v6 - 1;
    v8 = 1;
    do
    {
      v9 = v7;
      v10 = sub_33500((unsigned __int64 *)a2, v7);
      v11 = (__int64 **)sub_2AD00(v4, v5, a1);
      sub_332B0((__int64 *)*v4, (_QWORD *)*v5, v10);
      sub_332B0((__int64 *)v4[1], (_QWORD *)v5[1], v10);
      v12 = (__int64 **)sub_2AF20(v4);
      sub_2ACD0(v4);
      v4 = (__int64 *)v12;
      sub_2ACD0(v5);
      sub_332B0(*v12, *v11, v10);
      sub_332B0(v12[1], v11[1], v10);
      sub_33240(*v12, (unsigned __int64 *)*v12, (unsigned __int64 *)*a1, v8);
      sub_33240(v12[1], (unsigned __int64 *)v12[1], (unsigned __int64 *)a1[1], v8);
      sub_33240(*v11, (unsigned __int64 *)*v11, *v15, v8);
      v13 = v8;
      v8 &= ~v10;
      v5 = (__int64 *)v11;
      sub_33240(v11[1], (unsigned __int64 *)v11[1], v15[1], v13);
      v7 = v9 - 1;
    }
    while ( v9 );
  }
  else
  {
    v11 = (__int64 **)v5;
    v12 = (__int64 **)v4;
  }
  sub_2ACD0(v15);
  sub_2ACD0(v11);
  return v12;
}

void __fastcall sub_2B230(_QWORD *a1, __int64 *a2)
{
  unsigned __int64 **v2; // rbx
  __int64 v3; // rbp
  unsigned __int64 *v4; // r12

  v2 = (unsigned __int64 **)a1;
  v3 = a1[2];
  v4 = sub_35600(*(_QWORD *)(v3 + 8), (unsigned __int64 *)a1[1]);
  sub_35260(*(_QWORD *)(v3 + 8), *v2, *v2, v4);
  sub_35260(*(_QWORD *)(v3 + 8), v2[1], v2[1], v4);
  sub_330F0(v4);
  if ( a2 )
    *a2 = (__int64)sub_35490(*(_QWORD *)(v3 + 8), (_QWORD *)*a1);
}

unsigned __int64 __fastcall sub_2B2B0(__int64 a1)
{
  return sub_341A0(*(signed __int64 **)(a1 + 8), 0LL);
}

_QWORD *__fastcall sub_2B2C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  unsigned __int64 *v5; // r13
  unsigned __int64 *v6; // r12
  _QWORD *v7; // rbx
  __int64 **v8; // rax
  unsigned __int64 *v9; // rax
  __int64 v10; // rdi

  v4 = a1;
  v5 = (unsigned __int64 *)a3;
  v6 = (unsigned __int64 *)a4;
  v7 = (_QWORD *)sub_2F450(1uLL, 0x28uLL, 0LL);
  *v7 = sub_334C0(a1);
  v8 = sub_36310((__int64 *)a1);
  v7[1] = v8;
  v9 = sub_36450((__int64)v8, (unsigned __int64 *)a2);
  v10 = v7[1];
  v7[3] = v9;
  v7[4] = sub_36450(v10, v5);
  if ( v6 )
    v7[2] = sub_369B0(v4, v6);
  else
    v7[2] = 0LL;
  return v7;
}

void __fastcall sub_2B360(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD **v2; // rdi

  v1 = a1;
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[3]);
  sub_330F0((_QWORD *)a1[4]);
  sub_35210((_QWORD **)a1[1]);
  v2 = (_QWORD **)a1[2];
  if ( v2 )
    sub_36A90(v2);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_2B3A0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // rbp
  unsigned __int64 *v4; // rax

  v3 = sub_36450(*(_QWORD *)(a1 + 8), (unsigned __int64 *)a3);
  v4 = sub_36450(*(_QWORD *)(a1 + 8), (unsigned __int64 *)a2);
  return sub_295C0(a1, (__int64)v4, (__int64)v3);
}

__int64 __fastcall sub_2B3E0(_QWORD *a1, _QWORD *a2)
{
  sub_331D0((unsigned __int64 *)*a1, (unsigned __int64 *)*a2);
  sub_331D0((unsigned __int64 *)a1[1], (unsigned __int64 *)a2[1]);
  sub_331D0((unsigned __int64 *)a1[2], (unsigned __int64 *)a2[2]);
  return sub_331D0((unsigned __int64 *)a1[3], (unsigned __int64 *)a2[3]);
}

__int64 *__fastcall sub_2B430(_QWORD *a1)
{
  _QWORD *v1; // rbp
  __int64 v2; // r12
  _QWORD *v3; // rax
  __int64 v4; // rdi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rdi
  _QWORD *v8; // rax
  __int64 v9; // rdi
  _QWORD *v10; // rax
  __int64 v11; // rdi

  v1 = a1;
  v2 = a1[4];
  v3 = (_QWORD *)sub_2F450(1uLL, 0x28uLL, 0LL);
  *v3 = 0LL;
  v4 = *a1;
  v5 = v3;
  v3[4] = v2;
  v3[3] = 0LL;
  v3[2] = 0LL;
  v3[1] = 0LL;
  v6 = sub_334C0(v4);
  v7 = v1[1];
  *v5 = v6;
  v8 = sub_334C0(v7);
  v9 = v1[2];
  v5[1] = v8;
  v10 = sub_334C0(v9);
  v11 = v1[3];
  v5[2] = v10;
  v5[3] = sub_334C0(v11);
  return v5;
}

void __fastcall sub_2B4B0(_QWORD *a1)
{
  sub_330F0((_QWORD *)*a1);
  sub_330F0((_QWORD *)a1[1]);
  sub_330F0((_QWORD *)a1[2]);
  sub_330F0((_QWORD *)a1[3]);
  sub_BD070(a1, 0x28uLL);
  sub_2F4D0(a1);
}

_QWORD *__fastcall sub_2B4F0(_QWORD *a1, __int64 a2, unsigned __int8 a3)
{
  _QWORD *v3; // r14
  unsigned __int64 *v4; // rbp
  unsigned __int64 *v5; // r12
  unsigned __int64 *v6; // ST10_8
  __int64 *v7; // r15
  unsigned __int64 *v8; // rax
  __int64 *v9; // r13
  unsigned __int64 *v10; // ST08_8
  unsigned __int64 *v11; // ST00_8
  unsigned __int64 *v12; // rbx
  unsigned __int64 *v13; // r13
  char v14; // r12
  _QWORD *result; // rax
  unsigned __int8 v16; // [rsp+1Ch] [rbp-4Ch]
  int v17; // [rsp+24h] [rbp-44h]
  unsigned __int64 v18; // [rsp+28h] [rbp-40h]

  v18 = __readfsqword(0x28u);
  v16 = a3;
  if ( !a1[2] )
    goto LABEL_10;
  v3 = a1;
  v4 = sub_36450(a1[1], (unsigned __int64 *)a2);
  v5 = sub_35380(a1[1], v4, v4);
  v6 = sub_35380(v3[1], (unsigned __int64 *)v3[3], v5);
  v7 = sub_36800((__int64 **)v3[1], v6, (unsigned __int64 *)v3[4]);
  v8 = (unsigned __int64 *)sub_353D0(a1[1]);
  v9 = sub_36800((__int64 **)a1[1], v5, v8);
  v10 = sub_35600(a1[1], (unsigned __int64 *)v7);
  v11 = sub_35380(a1[1], (unsigned __int64 *)v9, v10);
  v12 = sub_36AE0(a1[2], v11, &v17);
  sub_330F0(v5);
  sub_330F0(v6);
  sub_330F0(v7);
  sub_330F0(v9);
  sub_330F0(v10);
  sub_330F0(v11);
  if ( v17 )
  {
    v13 = sub_35490(a1[1], v12);
    v14 = sub_33500(v13, 0LL);
    sub_338D0((__int64 *)v13, (_QWORD *)*a1, v12);
    sub_33240((__int64 *)v12, v12, v13, (v14 ^ v16) & 1);
    sub_330F0(v13);
    result = sub_295C0((__int64)a1, (__int64)v12, (__int64)v4);
  }
  else
  {
    sub_330F0(v12);
    sub_330F0(v4);
    result = 0LL;
  }
  if ( __readfsqword(0x28u) != v18 )
LABEL_10:
    __assert_fail("ec->sc", "ecc.c", 0x3BEu, "ecc_edwards_point_new_from_y");
  return result;
}

unsigned __int64 **__fastcall sub_2B6C0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r13
  unsigned __int64 **v3; // rbp
  _QWORD *v4; // rbx
  unsigned __int64 **v5; // rax
  __int64 v6; // rdi
  unsigned __int64 **v7; // r12
  unsigned __int64 *v8; // rdx
  unsigned __int64 *v9; // rsi
  unsigned __int64 *v10; // r15
  unsigned __int64 *v11; // r14
  unsigned __int64 *v12; // ST10_8
  unsigned __int64 *v13; // ST00_8
  __int64 *v14; // ST18_8
  __int64 *v15; // rbx
  unsigned __int64 *v16; // ST20_8
  unsigned __int64 *v17; // rbp
  __int64 *v18; // ST30_8
  unsigned __int64 *v19; // ST40_8
  __int64 *v20; // ST48_8
  __int64 *v21; // ST28_8
  unsigned __int64 *v22; // ST38_8
  __int64 *v23; // ST08_8
  __int64 *v24; // rbp
  __int64 *v25; // rbx
  unsigned __int64 *v26; // rax
  __int64 v27; // rdi
  unsigned __int64 *v28; // rax
  __int64 v29; // rdi
  unsigned __int64 *v30; // rax
  __int64 v31; // rdi

  v2 = a2[4];
  if ( v2 != *(_QWORD *)(a1 + 32) )
    __assert_fail("Q->ec == ec", "ecc.c", 0x403u, "ecc_edwards_add");
  v3 = (unsigned __int64 **)a1;
  v4 = a2;
  v5 = (unsigned __int64 **)sub_2F450(1uLL, 0x28uLL, 0LL);
  v6 = *(_QWORD *)(v2 + 8);
  *v5 = 0LL;
  v7 = v5;
  v8 = (unsigned __int64 *)*a2;
  v9 = *v3;
  v5[4] = (unsigned __int64 *)v2;
  v5[3] = 0LL;
  v5[2] = 0LL;
  v5[1] = 0LL;
  v10 = sub_35380(v6, v9, v8);
  v11 = sub_35380(*(_QWORD *)(v2 + 8), v3[1], (unsigned __int64 *)v4[1]);
  v12 = sub_35380(*(_QWORD *)(v2 + 8), v3[3], (unsigned __int64 *)v4[3]);
  v13 = sub_35380(*(_QWORD *)(v2 + 8), v3[2], (unsigned __int64 *)v4[2]);
  v14 = sub_36770(*(__int64 ***)(v2 + 8), *v3, v3[1]);
  v15 = sub_36770(*(__int64 ***)(v2 + 8), (_QWORD *)*v4, (unsigned __int64 *)v4[1]);
  v16 = sub_35380(*(_QWORD *)(v2 + 8), *(unsigned __int64 **)(v2 + 32), v10);
  v17 = sub_35380(*(_QWORD *)(v2 + 8), *(unsigned __int64 **)(v2 + 24), v12);
  v18 = v15;
  v19 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v14, (unsigned __int64 *)v15);
  v20 = sub_36770(*(__int64 ***)(v2 + 8), v10, v11);
  v21 = sub_36800(*(__int64 ***)(v2 + 8), v19, (unsigned __int64 *)v20);
  v22 = v17;
  v23 = sub_36800(*(__int64 ***)(v2 + 8), v13, v17);
  v24 = sub_36770(*(__int64 ***)(v2 + 8), v13, v17);
  v25 = sub_36800(*(__int64 ***)(v2 + 8), v11, v16);
  v26 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)v21, (unsigned __int64 *)v23);
  v27 = *(_QWORD *)(v2 + 8);
  *v7 = v26;
  v28 = sub_35380(v27, (unsigned __int64 *)v23, (unsigned __int64 *)v24);
  v29 = *(_QWORD *)(v2 + 8);
  v7[2] = v28;
  v30 = sub_35380(v29, (unsigned __int64 *)v24, (unsigned __int64 *)v25);
  v31 = *(_QWORD *)(v2 + 8);
  v7[1] = v30;
  v7[3] = sub_35380(v31, (unsigned __int64 *)v25, (unsigned __int64 *)v21);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v12);
  sub_330F0(v13);
  sub_330F0(v14);
  sub_330F0(v18);
  sub_330F0(v16);
  sub_330F0(v22);
  sub_330F0(v19);
  sub_330F0(v20);
  sub_330F0(v21);
  sub_330F0(v23);
  sub_330F0(v24);
  sub_330F0(v25);
  return v7;
}

unsigned __int64 **__fastcall sub_2B960(_QWORD *a1, __int64 a2)
{
  unsigned __int64 **v2; // rax
  unsigned __int64 **v3; // r15
  __int64 *v4; // rbx
  __int64 *v5; // r14
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned int v8; // er15
  unsigned __int64 v9; // ST00_8
  int v10; // ebp
  unsigned __int64 **v11; // r13
  unsigned __int64 **v12; // r12
  __int64 *v13; // rdi
  unsigned int v14; // edx
  unsigned __int64 **v16; // [rsp+8h] [rbp-50h]
  _QWORD *v17; // [rsp+10h] [rbp-48h]

  v17 = a1;
  v2 = sub_2B6C0((__int64)a1, a1);
  v3 = v2;
  v16 = v2;
  v4 = sub_2B430(a1);
  v5 = sub_2B430(v3);
  v6 = sub_330E0((_QWORD *)a2);
  if ( v6 )
  {
    v7 = v6 - 1;
    v8 = 1;
    do
    {
      v9 = v7;
      v10 = sub_33500((unsigned __int64 *)a2, v7);
      v11 = sub_2B6C0((__int64)v4, v5);
      sub_29730(v4, v5, v10);
      v12 = sub_2B6C0((__int64)v4, v4);
      sub_2B4B0(v4);
      v13 = v5;
      v4 = (__int64 *)v12;
      v5 = (__int64 *)v11;
      sub_2B4B0(v13);
      sub_29730(v12, v11, v10);
      sub_29690(v12, v17, v8);
      v14 = v8;
      v8 &= ~v10;
      sub_29690(v11, v16, v14);
      v7 = v9 - 1;
    }
    while ( v9 );
  }
  else
  {
    v11 = (unsigned __int64 **)v5;
    v12 = (unsigned __int64 **)v4;
  }
  sub_2B4B0(v16);
  sub_2B4B0(v11);
  return v12;
}

__int64 __fastcall sub_2BA90(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // r12
  __int64 v3; // r13
  unsigned __int64 *v4; // r14
  unsigned __int64 *v5; // ST08_8
  unsigned __int64 *v6; // r15
  unsigned __int64 *v7; // r14
  __int64 v8; // r13
  unsigned __int64 *v9; // r14
  unsigned __int64 *v10; // r15
  unsigned __int64 *v11; // r12
  unsigned __int64 *v12; // rbp
  int v13; // ebx

  v2 = a2[4];
  if ( v2 != a1[4] )
    __assert_fail("Q->ec == ec", "ecc.c", 0x47Fu, "ecc_edwards_eq");
  v3 = *(_QWORD *)(v2 + 8);
  v4 = (unsigned __int64 *)a1[2];
  v5 = (unsigned __int64 *)*a2;
  v6 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)*a1, (unsigned __int64 *)a2[2]);
  v7 = sub_35380(v3, v5, v4);
  LODWORD(v5) = sub_34130(v6, v7);
  sub_330F0(v6);
  sub_330F0(v7);
  v8 = *(_QWORD *)(v2 + 8);
  v9 = (unsigned __int64 *)a2[1];
  v10 = (unsigned __int64 *)a1[2];
  v11 = sub_35380(*(_QWORD *)(v2 + 8), (unsigned __int64 *)a1[1], (unsigned __int64 *)a2[2]);
  v12 = sub_35380(v8, v9, v10);
  v13 = sub_34130(v11, v12);
  sub_330F0(v11);
  sub_330F0(v12);
  return v13 & (unsigned int)v5;
}

__int64 __fastcall sub_2BB90(_QWORD *a1, __int64 *a2, __int64 *a3)
{
  __int64 *v3; // r13
  __int64 v4; // rbp
  unsigned __int64 **v5; // rbx
  unsigned __int64 *v6; // r12
  __int64 result; // rax

  v3 = a3;
  v4 = a1[4];
  v5 = (unsigned __int64 **)a1;
  v6 = sub_35600(*(_QWORD *)(v4 + 8), (unsigned __int64 *)a1[2]);
  sub_35260(*(_QWORD *)(v4 + 8), *v5, *v5, v6);
  sub_35260(*(_QWORD *)(v4 + 8), v5[1], v5[1], v6);
  sub_35260(*(_QWORD *)(v4 + 8), v5[2], v5[2], v6);
  sub_330F0(v6);
  result = sub_35260(*(_QWORD *)(v4 + 8), v5[3], *v5, v5[1]);
  if ( a2 )
  {
    result = (__int64)sub_35490(*(_QWORD *)(v4 + 8), (_QWORD *)*a1);
    *a2 = result;
  }
  if ( v3 )
  {
    result = (__int64)sub_35490(*(_QWORD *)(v4 + 8), (_QWORD *)a1[1]);
    *v3 = result;
  }
  return result;
}

__int64 __fastcall sub_2BC40(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 - 8);
  if ( a2 )
    *(_QWORD *)(a1 - 8) = a2;
  return result;
}

__int64 __fastcall sub_2BC50(__int64 a1)
{
  return *(_QWORD *)(a1 - 16);
}

__int64 sub_2BC60()
{
  return 0LL;
}

void __fastcall sub_2BC70(__int64 a1)
{
  sub_2F4D0(*(void **)(a1 - 16));
  sub_2F4D0((void *)(a1 - 16));
}

_QWORD *__fastcall sub_2BC90(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _QWORD *result; // rax

  v2 = (_QWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  v2[1] = a1;
  *v2 = a2;
  result = v2 + 2;
  *result = off_31E2C0;
  return result;
}

_QWORD *sub_2BCD0(__int64 a1, __int64 a2, ...)
{
  char *v2; // rbx
  _QWORD *v3; // rax
  _QWORD *result; // rax
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v6; // [rsp+18h] [rbp-D0h]

  va_start(va, a2);
  v6 = __readfsqword(0x28u);
  v2 = sub_BC310(a2, (const __m128i *)va);
  v3 = (_QWORD *)sub_2F450(1uLL, 0x18uLL, 0LL);
  v3[1] = a1;
  *v3 = v2;
  result = v3 + 2;
  *result = off_31E2C0;
  return result;
}

unsigned __int64 __fastcall sub_2BDC0(_BYTE **a1, unsigned __int8 a2)
{
  unsigned __int8 v3; // al
  char v4; // al
  _BYTE *v5; // rdi
  int v6; // edx
  unsigned __int8 v7; // [rsp+Ch] [rbp-2Ch]
  char v8; // [rsp+13h] [rbp-25h]
  char v9; // [rsp+14h] [rbp-24h]
  unsigned __int64 v10; // [rsp+18h] [rbp-20h]

  v10 = __readfsqword(0x28u);
  v7 = a2;
  if ( (unsigned __int8)(a2 - 32) <= 0x5Eu )
    goto LABEL_2;
  if ( (*a1)[305] )
  {
    v3 = a2;
  }
  else
  {
    v6 = *(_DWORD *)(*((_QWORD *)*a1 + 544) + 16LL);
    if ( a2 > 0x9Fu && v6 != 55 )
      goto LABEL_2;
    v3 = a2;
    if ( v6 != 55 )
    {
      if ( (a2 & 0x80u) != 0 )
      {
        __sprintf_chk(&v8, 1LL, 5LL, "<%02X>", a2);
        (**(void (__fastcall ***)(_BYTE *, _QWORD, char *, signed __int64))a1[2])(a1[2], 0LL, &v8, 4LL);
        return __readfsqword(0x28u) ^ v10;
      }
      goto LABEL_7;
    }
  }
  if ( (v3 & 0x80u) != 0 )
  {
LABEL_2:
    (**(void (__fastcall ***)(_BYTE *, _QWORD, char *, signed __int64))a1[2])(a1[2], 0LL, (char *)&v7, 1LL);
    return __readfsqword(0x28u) ^ v10;
  }
LABEL_7:
  v4 = a2 + 64;
  v5 = a1[2];
  v8 = 94;
  if ( a2 == 127 )
    v4 = 63;
  v9 = v4;
  (**(void (__fastcall ***)(_BYTE *, _QWORD, char *, signed __int64))v5)(v5, 0LL, &v8, 2LL);
  return __readfsqword(0x28u) ^ v10;
}

char __fastcall sub_2BED0(__int64 a1, unsigned __int8 a2)
{
  char result; // al

  result = 1;
  if ( (unsigned __int8)(a2 - 32) > 0x5Eu )
  {
    if ( a2 > 0x9Fu )
    {
      if ( !*(_BYTE *)(*(_QWORD *)a1 + 305LL) && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 4352LL) + 16LL) != 55 )
        return result;
      return a2 > 0xBFu;
    }
    result = 2;
    if ( (a2 & 0x80u) != 0 )
    {
      result = 0;
      if ( !*(_BYTE *)(*(_QWORD *)a1 + 305LL) )
      {
        if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 4352LL) + 16LL) != 55 )
          return 4;
        return a2 > 0xBFu;
      }
    }
  }
  return result;
}

__int64 __fastcall sub_2BF40(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 24) = sub_1EF00(a2, 87);
  *(_BYTE *)(a1 + 25) = sub_1EF00(a2, 88);
  *(_DWORD *)(a1 + 28) = sub_1EFD0(a2, 2);
  *(_DWORD *)(a1 + 32) = sub_1EFD0(a2, 92);
  result = sub_1EFD0(a2, 93);
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

__int64 __fastcall sub_2BFB0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 v7; // rbx

  v4 = a4;
  v5 = a3;
  v6 = sub_2F450(1uLL, 0x48uLL, 0LL);
  *(_QWORD *)(v6 + 40) = 0LL;
  *(_QWORD *)(v6 + 48) = 0LL;
  *(_QWORD *)(v6 + 56) = 0LL;
  *(_BYTE *)(v6 + 64) = 0;
  *(_QWORD *)(v6 + 8) = v5;
  *(_QWORD *)v6 = a2;
  v7 = v6;
  *(_QWORD *)(v6 + 16) = v4;
  sub_2BF40(v6, a1);
  if ( a2 )
    *(_QWORD *)(a2 + 4328) = v7;
  if ( v5 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 96LL))(v5, v7);
  return v7;
}

void __fastcall sub_2C040(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  void *v3; // rdi

  v1 = a1;
  if ( *a1 )
    *(_QWORD *)(*a1 + 4328LL) = 0LL;
  v2 = a1[1];
  if ( v2 )
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 96LL))(v2, 0LL);
  v3 = (void *)v1[5];
  if ( v3 )
    sub_2F4D0(v3);
  sub_2F4D0(v1);
}

__int64 __fastcall sub_2C080(__int64 a1)
{
  __int64 v1; // rbp
  int v2; // eax
  int v3; // eax
  signed __int64 v4; // rsi

  LODWORD(v1) = 1;
  v2 = *(_DWORD *)(a1 + 36);
  if ( v2 )
  {
    LODWORD(v1) = 0;
    if ( v2 == 2 )
      v1 = (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 88LL))(*(_QWORD *)(a1 + 8), 0LL);
  }
  v3 = *(_DWORD *)(a1 + 32);
  v4 = 1LL;
  if ( v3 )
  {
    v4 = 0LL;
    if ( v3 == 2 )
      v4 = (*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(a1 + 8) + 88LL))(
             *(_QWORD *)(a1 + 8),
             1LL);
  }
  return (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(**(_QWORD **)(a1 + 16) + 96LL))(
           *(_QWORD *)(a1 + 16),
           v4,
           (unsigned int)v1);
}

char __fastcall sub_2C0F0(__int64 a1, const char *a2, unsigned int a3, char a4)
{
  __int64 v4; // r15
  __int64 v5; // rdi
  const char *v6; // rbp
  __int64 v7; // r13
  signed int v8; // er14
  _BYTE *v9; // rax
  int v10; // ebx
  unsigned __int64 v11; // rcx
  char *v12; // rdi
  char v13; // r11
  char v14; // ST0F_1
  __int64 v15; // rdx
  __int64 *v16; // rdi
  __int64 v17; // rax
  signed __int64 v18; // r13
  signed __int64 v19; // rbx
  const unsigned __int16 **v20; // rax
  __int64 v21; // rcx
  unsigned __int64 v22; // rbx
  unsigned __int8 v23; // si
  int v24; // eax
  int v25; // ebx
  bool v26; // zf
  int v27; // edx
  __int64 *v28; // rdi
  __int64 v29; // rax
  __int64 (__fastcall *v30)(__int64 *, const char *, signed __int64); // rax
  signed __int64 v31; // rdx
  int v32; // eax
  signed __int64 v33; // rcx
  _BYTE *v34; // r8
  _BYTE *v35; // rdx
  int v36; // eax
  int v37; // ebx
  signed __int64 v38; // rcx
  int v39; // ebx
  signed __int64 v40; // rcx
  int v41; // eax
  int v42; // eax
  int v43; // er13
  __int64 *v44; // rdi
  __int64 v45; // rax
  int v46; // edx
  unsigned __int8 v47; // al
  signed __int64 v48; // r8
  __int64 v49; // rdx
  __int64 v50; // rax
  char v51; // dl
  __int64 (__fastcall *v52)(__int64 *, signed __int64, _QWORD); // rax
  signed __int64 v53; // rsi
  int v54; // eax
  unsigned __int64 v55; // r8
  int v56; // ebx
  const char *v58; // [rsp+0h] [rbp-48h]
  char v59; // [rsp+Eh] [rbp-3Ah]

  v4 = a1;
  v5 = *(_QWORD *)a1;
  v59 = a4;
  if ( !v5 )
    __assert_fail("ldisc->term", "ldisc.c", 0x84u, "ldisc_send");
  v6 = a2;
  v7 = a3;
  if ( a4 )
    sub_99470(v5);
  v8 = 0;
  if ( (signed int)v7 < 0 )
  {
    v8 = 256;
    v7 = (unsigned int)strlen(a2);
  }
  LODWORD(v9) = *(_DWORD *)(v4 + 36);
  if ( !(_DWORD)v9
    || (_DWORD)v9 == 2
    && (LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 8) + 88LL))(
                       *(_QWORD *)(v4 + 8),
                       0LL),
        (_BYTE)v9) )
  {
    LOBYTE(v9) = (_BYTE)a2 + v7;
    v58 = &a2[v7];
    while ( 1 )
    {
LABEL_10:
      if ( v6 == v58 )
        return (char)v9;
      while ( 1 )
      {
        ++v6;
        LOBYTE(v9) = *(_BYTE *)(v4 + 64);
        v10 = v8 + *((unsigned __int8 *)v6 - 1);
        if ( v59 != 1 && v10 == 13 )
          break;
        if ( (_BYTE)v9 )
          goto LABEL_51;
        if ( v10 == 22 )
        {
          *(_BYTE *)(v4 + 64) = 1;
          goto LABEL_10;
        }
        if ( v10 > 22 )
        {
          if ( v10 != 28 )
          {
            if ( v10 > 28 )
            {
              if ( v10 == 269 )
              {
                v44 = *(__int64 **)(v4 + 8);
                v11 = *(_QWORD *)(v4 + 48);
                v45 = *v44;
                goto LABEL_95;
              }
              if ( v10 == 383 || v10 == 264 )
              {
                if ( *(_QWORD *)(v4 + 48) )
                {
                  v32 = *(_DWORD *)(v4 + 32);
                  if ( !v32 )
                    goto LABEL_72;
LABEL_65:
                  if ( v32 == 2
                    && (*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                         *(_QWORD *)(v4 + 8),
                         1LL) )
                  {
LABEL_72:
                    while ( 1 )
                    {
                      LOBYTE(v36) = sub_2BED0(v4, *(_BYTE *)(*(_QWORD *)(v4 + 48) - 1LL + *(_QWORD *)(v4 + 40)));
                      v37 = v36 - 1;
                      if ( v36 )
                        break;
LABEL_68:
                      v35 = *(_BYTE **)v4;
                      *(_QWORD *)(v4 + 48) = v33;
                      LOBYTE(v9) = *v34;
                      if ( !v35[305] && *(_DWORD *)(*((_QWORD *)v35 + 544) + 16LL) != 55 )
                        goto LABEL_10;
                      LOBYTE(v9) = (_BYTE)v9 + -128;
                      if ( (unsigned __int8)v9 > 0x3Fu )
                        goto LABEL_10;
                      v32 = *(_DWORD *)(v4 + 32);
                      if ( v32 )
                        goto LABEL_65;
                    }
                    do
                    {
                      --v37;
                      (***(void (__fastcall ****)(_QWORD, _QWORD, void *__ptr32 *, signed __int64))(v4 + 16))(
                        *(_QWORD *)(v4 + 16),
                        0LL,
                        &off_E337C,
                        3LL);
                    }
                    while ( v37 != -1 );
                  }
                  v33 = *(_QWORD *)(v4 + 48) - 1LL;
                  v34 = (_BYTE *)(v33 + *(_QWORD *)(v4 + 40));
                  goto LABEL_68;
                }
                goto LABEL_10;
              }
              goto LABEL_51;
            }
            if ( v10 == 23 )
            {
              v18 = *(_QWORD *)(v4 + 48);
              while ( 1 )
              {
                if ( !v18 )
                  goto LABEL_10;
                LODWORD(v9) = *(_DWORD *)(v4 + 32);
                if ( (_DWORD)v9 )
                {
                  if ( (_DWORD)v9 != 2 )
                  {
                    v19 = v18--;
                    goto LABEL_39;
                  }
                  LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                                 *(_QWORD *)(v4 + 8),
                                 1LL);
                  if ( !(_BYTE)v9 )
                    goto LABEL_38;
                  v18 = *(_QWORD *)(v4 + 48);
                }
                LOBYTE(v9) = sub_2BED0(v4, *(_BYTE *)(*(_QWORD *)(v4 + 40) + v18 - 1));
                v39 = (_DWORD)v9 - 1;
                if ( (_DWORD)v9 )
                {
                  do
                  {
                    --v39;
                    LOBYTE(v9) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, void *__ptr32 *, signed __int64))(v4 + 16))(
                                   *(_QWORD *)(v4 + 16),
                                   0LL,
                                   &off_E337C,
                                   3LL);
                  }
                  while ( v39 != -1 );
LABEL_38:
                  v19 = *(_QWORD *)(v4 + 48);
                  v18 = v19 - 1;
                  goto LABEL_39;
                }
                v19 = v18;
                v18 = v38;
LABEL_39:
                *(_QWORD *)(v4 + 48) = v18;
                if ( v18 )
                {
                  v20 = __ctype_b_loc();
                  v21 = *(_QWORD *)(v4 + 40);
                  v9 = *v20;
                  if ( !(v9[2 * *(unsigned __int8 *)(v21 + v19 - 2) + 1] & 0x20)
                    || v9[2 * *(unsigned __int8 *)(v21 + v18) + 1] & 0x20 )
                  {
                    continue;
                  }
                }
                goto LABEL_10;
              }
            }
            if ( v10 != 26 )
              goto LABEL_51;
          }
LABEL_81:
          if ( !*(_QWORD *)(v4 + 48) )
          {
LABEL_91:
            LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(**(_QWORD **)(v4 + 8) + 48LL))(
                           *(_QWORD *)(v4 + 8),
                           7LL,
                           0LL);
            if ( *(_BYTE *)(v4 + 24) )
            {
              switch ( v10 )
              {
                case 3:
                  LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(**(_QWORD **)(v4 + 8) + 48LL))(
                                 *(_QWORD *)(v4 + 8),
                                 11LL,
                                 0LL);
                  break;
                case 26:
                  LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(**(_QWORD **)(v4 + 8) + 48LL))(
                                 *(_QWORD *)(v4 + 8),
                                 12LL,
                                 0LL);
                  break;
                case 28:
                  LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(**(_QWORD **)(v4 + 8) + 48LL))(
                                 *(_QWORD *)(v4 + 8),
                                 9LL,
                                 0LL);
                  break;
              }
              goto LABEL_10;
            }
            goto LABEL_51;
          }
          while ( 1 )
          {
            v41 = *(_DWORD *)(v4 + 32);
            if ( !v41
              || v41 == 2
              && (*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                   *(_QWORD *)(v4 + 8),
                   1LL) )
            {
              LOBYTE(v42) = sub_2BED0(v4, *(_BYTE *)(*(_QWORD *)(v4 + 40) + *(_QWORD *)(v4 + 48) - 1LL));
              v43 = v42 - 1;
              if ( !v42 )
                goto LABEL_86;
              do
              {
                --v43;
                (***(void (__fastcall ****)(_QWORD, _QWORD, void *__ptr32 *, signed __int64))(v4 + 16))(
                  *(_QWORD *)(v4 + 16),
                  0LL,
                  &off_E337C,
                  3LL);
              }
              while ( v43 != -1 );
            }
            v40 = *(_QWORD *)(v4 + 48) - 1LL;
LABEL_86:
            *(_QWORD *)(v4 + 48) = v40;
            if ( !v40 )
              goto LABEL_91;
          }
        }
        if ( v10 != 10 )
        {
          if ( v10 > 10 )
          {
            if ( v10 == 18 )
            {
              LODWORD(v9) = *(_DWORD *)(v4 + 32);
              if ( !(_DWORD)v9
                || (_DWORD)v9 == 2
                && (LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                                   *(_QWORD *)(v4 + 8),
                                   1LL),
                    (_BYTE)v9) )
              {
                v22 = 0LL;
                LOBYTE(v9) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, const char *, signed __int64))(v4 + 16))(
                               *(_QWORD *)(v4 + 16),
                               0LL,
                               "^R\r\n",
                               4LL);
                if ( *(_QWORD *)(v4 + 48) )
                {
                  do
                  {
                    v23 = *(_BYTE *)(*(_QWORD *)(v4 + 40) + v22++);
                    LOBYTE(v9) = sub_2BDC0((_BYTE **)v4, v23);
                  }
                  while ( *(_QWORD *)(v4 + 48) > v22 );
                }
              }
              goto LABEL_10;
            }
            if ( v10 != 21 )
              goto LABEL_51;
          }
          else if ( v10 != 3 )
          {
            if ( v10 == 4 )
            {
              v16 = *(__int64 **)(v4 + 8);
              v17 = *v16;
              if ( *(_QWORD *)(v4 + 48) )
              {
                LOBYTE(v9) = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(v17 + 24))(v16, *(_QWORD *)(v4 + 40));
                *(_QWORD *)(v4 + 48) = 0LL;
              }
              else
              {
                LOBYTE(v9) = (*(__int64 (__fastcall **)(__int64 *, signed __int64))(v17 + 48))(v16, 1LL);
              }
              goto LABEL_10;
            }
LABEL_51:
            v11 = *(_QWORD *)(v4 + 48);
            v12 = *(char **)(v4 + 40);
            v13 = v10;
            goto LABEL_15;
          }
          goto LABEL_81;
        }
        v11 = *(_QWORD *)(v4 + 48);
        v12 = *(char **)(v4 + 40);
        if ( *(_DWORD *)(v4 + 28) || !v11 )
        {
          v13 = 10;
        }
        else
        {
          v47 = v12[v11 - 1];
          v48 = v11 - 1;
          v13 = 10;
          if ( v47 == 13 )
          {
            v49 = *(unsigned int *)(v4 + 32);
            if ( (_DWORD)v49 )
            {
              v44 = *(__int64 **)(v4 + 8);
              --v11;
              v45 = *v44;
              if ( (_DWORD)v49 != 2 )
              {
LABEL_109:
                *(_QWORD *)(v4 + 48) = v11;
                goto LABEL_95;
              }
              v26 = (*(unsigned __int8 (__fastcall **)(__int64 *, signed __int64, __int64, unsigned __int64, signed __int64))(v45 + 88))(
                      v44,
                      1LL,
                      v49,
                      v11,
                      v48) == 0;
              v50 = *(_QWORD *)(v4 + 48);
              if ( v26 )
              {
LABEL_108:
                v44 = *(__int64 **)(v4 + 8);
                v11 = v50 - 1;
                v45 = *v44;
                goto LABEL_109;
              }
              v47 = *(_BYTE *)(*(_QWORD *)(v4 + 40) + v50 - 1);
            }
            LOBYTE(v54) = sub_2BED0(v4, v47);
            v56 = v54 - 1;
            if ( !v54 )
            {
              v44 = *(__int64 **)(v4 + 8);
              v11 = v55;
              v45 = *v44;
              goto LABEL_109;
            }
            do
            {
              --v56;
              (***(void (__fastcall ****)(_QWORD, _QWORD, void *__ptr32 *, signed __int64))(v4 + 16))(
                *(_QWORD *)(v4 + 16),
                0LL,
                &off_E337C,
                3LL);
            }
            while ( v56 != -1 );
            v50 = *(_QWORD *)(v4 + 48);
            goto LABEL_108;
          }
        }
LABEL_15:
        v14 = v13;
        v9 = sub_2F4F0(v12, (unsigned __int64 *)(v4 + 56), 1uLL, v11, 1uLL, 0);
        v15 = *(_QWORD *)(v4 + 48);
        *(_QWORD *)(v4 + 40) = v9;
        *(_QWORD *)(v4 + 48) = v15 + 1;
        v9[v15] = v14;
        LODWORD(v9) = *(_DWORD *)(v4 + 32);
        if ( !(_DWORD)v9
          || (_DWORD)v9 == 2
          && (LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                             *(_QWORD *)(v4 + 8),
                             1LL),
              (_BYTE)v9) )
        {
          LOBYTE(v9) = sub_2BDC0((_BYTE **)v4, v10);
        }
        *(_BYTE *)(v4 + 64) = 0;
        if ( v6 == v58 )
          return (char)v9;
      }
      v11 = *(_QWORD *)(v4 + 48);
      if ( (_BYTE)v9 )
      {
        v12 = *(char **)(v4 + 40);
        v13 = 13;
        LOBYTE(v10) = 13;
        goto LABEL_15;
      }
      v44 = *(__int64 **)(v4 + 8);
      v45 = *v44;
LABEL_95:
      if ( v11 )
      {
        (*(void (__fastcall **)(__int64 *, _QWORD, unsigned __int64))(v45 + 24))(v44, *(_QWORD *)(v4 + 40), v11);
        v44 = *(__int64 **)(v4 + 8);
        v45 = *v44;
      }
      v46 = *(_DWORD *)(v4 + 28);
      if ( v46 )
      {
        if ( v46 == 1 && *(_BYTE *)(v4 + 25) )
          (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(v45 + 48))(v44, 14LL, 0LL);
        else
          (*(void (__fastcall **)(__int64 *, const char *, signed __int64))(v45 + 24))(v44, "\r", 1LL);
      }
      else
      {
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(v45 + 24))(v44, "\r\n", 2LL);
      }
      LODWORD(v9) = *(_DWORD *)(v4 + 32);
      if ( !(_DWORD)v9
        || (_DWORD)v9 == 2
        && (LOBYTE(v9) = (*(__int64 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 8) + 88LL))(
                           *(_QWORD *)(v4 + 8),
                           1LL),
            (_BYTE)v9) )
      {
        LOBYTE(v9) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, char *, signed __int64))(v4 + 16))(
                       *(_QWORD *)(v4 + 16),
                       0LL,
                       "\r\n",
                       2LL);
      }
      *(_QWORD *)(v4 + 48) = 0LL;
    }
  }
  if ( *(_QWORD *)(v4 + 48) )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v4 + 8) + 24LL))(*(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 40));
    v9 = *(_BYTE **)(v4 + 48);
    if ( v9 )
    {
      do
      {
        LOBYTE(v24) = sub_2BED0(v4, v9[*(_QWORD *)(v4 + 40) - 1]);
        v25 = v24 - 1;
        if ( v24 )
        {
          do
          {
            --v25;
            (***(void (__fastcall ****)(_QWORD, _QWORD, void *__ptr32 *, signed __int64))(v4 + 16))(
              *(_QWORD *)(v4 + 16),
              0LL,
              &off_E337C,
              3LL);
          }
          while ( v25 != -1 );
        }
        v9 = (_BYTE *)(*(_QWORD *)(v4 + 48) - 1LL);
        v26 = *(_QWORD *)(v4 + 48) == 1LL;
        *(_QWORD *)(v4 + 48) = v9;
      }
      while ( !v26 );
    }
  }
  if ( (signed int)v7 > 0 )
  {
    v27 = *(_DWORD *)(v4 + 32);
    if ( v27 )
    {
      v28 = *(__int64 **)(v4 + 8);
      v29 = *v28;
      if ( v27 != 2 )
        goto LABEL_60;
      if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, signed __int64))(v29 + 88))(v28, 1LL) )
      {
        v28 = *(__int64 **)(v4 + 8);
        v29 = *v28;
        goto LABEL_60;
      }
    }
    (***(void (__fastcall ****)(_QWORD, _QWORD, const char *, _QWORD))(v4 + 16))(
      *(_QWORD *)(v4 + 16),
      0LL,
      a2,
      (signed int)v7);
    v28 = *(__int64 **)(v4 + 8);
    v29 = *v28;
LABEL_60:
    if ( v8 && *(_DWORD *)(v4 + 28) == 1 && (_DWORD)v7 == 1 )
    {
      v51 = *a2;
      if ( *a2 != 13 )
      {
        if ( v51 > 13 )
        {
          if ( v51 == 26 )
          {
            if ( *(_BYTE *)(v4 + 24) )
            {
              v52 = *(__int64 (__fastcall **)(__int64 *, signed __int64, _QWORD))(v29 + 48);
              v53 = 12LL;
              goto LABEL_137;
            }
          }
          else if ( v51 == 127 )
          {
LABEL_135:
            if ( *(_BYTE *)(v4 + 24) )
            {
              v52 = *(__int64 (__fastcall **)(__int64 *, signed __int64, _QWORD))(v29 + 48);
              v53 = 6LL;
LABEL_137:
              LOBYTE(v9) = v52(v28, v53, 0LL);
              return (char)v9;
            }
            goto LABEL_147;
          }
        }
        else
        {
          if ( v51 == 3 )
          {
            if ( *(_BYTE *)(v4 + 24) )
            {
              v52 = *(__int64 (__fastcall **)(__int64 *, signed __int64, _QWORD))(v29 + 48);
              v53 = 11LL;
              goto LABEL_137;
            }
            goto LABEL_147;
          }
          if ( v51 == 8 )
            goto LABEL_135;
        }
LABEL_147:
        v30 = *(__int64 (__fastcall **)(__int64 *, const char *, signed __int64))(v29 + 24);
        v31 = 1LL;
        goto LABEL_62;
      }
      if ( *(_BYTE *)(v4 + 25) )
      {
        v52 = *(__int64 (__fastcall **)(__int64 *, signed __int64, _QWORD))(v29 + 48);
        v53 = 14LL;
        goto LABEL_137;
      }
      v30 = *(__int64 (__fastcall **)(__int64 *, const char *, signed __int64))(v29 + 24);
      v31 = 1LL;
      a2 = "\r";
    }
    else
    {
      v30 = *(__int64 (__fastcall **)(__int64 *, const char *, signed __int64))(v29 + 24);
      v31 = (signed int)v7;
    }
LABEL_62:
    LOBYTE(v9) = v30(v28, a2, v31);
  }
  return (char)v9;
}

int __fastcall sub_2CA10(__int64 a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 8) == 2 )
    result = fflush(*(FILE **)a1);
  return result;
}

int __fastcall sub_2CA30(__int64 a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 80);
  if ( result > 0 )
    result = sub_2CA10(a1);
  return result;
}

void __usercall sub_2CA50(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<r15>)
{
  __int64 v6; // r15
  void **v7; // rdi
  __m128i v8; // xmm0
  __int64 v9; // rbx
  char *v10; // r14
  char v11; // si
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // r13
  char v13; // r12
  int v14; // ebx
  char *v15; // rbp
  char v16; // al
  const char **v17; // rbx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  char **v21; // [rsp+0h] [rbp-110h]
  unsigned __int8 v22; // [rsp+1Bh] [rbp-F5h]
  unsigned int v23; // [rsp+1Ch] [rbp-F4h]
  char *v24; // [rsp+20h] [rbp-F0h]
  __int128 v25; // [rsp+28h] [rbp-E8h]
  __int128 v26; // [rsp+38h] [rbp-D8h]
  __int128 v27; // [rsp+48h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-B8h]
  __m128i v29; // [rsp+68h] [rbp-A8h]
  __m128i v30; // [rsp+78h] [rbp-98h]
  __m128i v31; // [rsp+88h] [rbp-88h]
  __int64 v32; // [rsp+98h] [rbp-78h]
  char v33; // [rsp+A8h] [rbp-68h]
  unsigned __int8 v34; // [rsp+A9h] [rbp-67h]
  unsigned __int64 v35; // [rsp+D0h] [rbp-40h]
  __int64 v36; // [rsp+E0h] [rbp-30h]
  __int64 v37; // [rsp+E8h] [rbp-28h]
  __int64 v38; // [rsp+F0h] [rbp-20h]
  __int64 v39; // [rsp+F8h] [rbp-18h]
  __int64 v40; // [rsp+108h] [rbp-8h]

  if ( !*(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 80) )
  {
    v40 = a6;
    v6 = a3;
    v39 = a5;
    v38 = a4;
    v37 = a2;
    v36 = a1;
    v35 = __readfsqword(0x28u);
    sub_99BB0((__m128i *)&v25);
    v7 = *(void ***)(a3 + 56);
    v29 = _mm_loadu_si128((const __m128i *)&v25);
    v8 = _mm_loadu_si128((const __m128i *)&v26);
    v32 = v28;
    v30 = v8;
    v31 = _mm_loadu_si128((const __m128i *)&v27);
    if ( v7 )
      sub_B4E60(v7);
    v23 = sub_1EFD0(*(__int64 **)(v6 + 72), 1);
    v24 = (char *)sub_1F170(*(__int64 **)(v6 + 72), 0);
    v9 = sub_1F530(*(__int64 **)(v6 + 72), 127);
    v21 = (char **)sub_BC640();
    v10 = (char *)sub_B4E20(v9);
    v11 = *v10;
    v12 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v21 + 3);
    while ( 2 )
    {
      if ( !v11 )
        break;
LABEL_8:
      if ( v11 != 38 )
      {
        v33 = v11;
        ++v10;
        v13 = 0;
        v14 = 0;
        v15 = &v33;
        goto LABEL_12;
      }
      v22 = v10[1];
      if ( v10[1] )
      {
        v11 = v10[1];
        switch ( (*__ctype_tolower_loc())[v22] )
        {
          case 0x64:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%d", (const struct tm *)&v29);
            break;
          case 0x68:
            v15 = v24;
            v20 = strlen(v24);
            break;
          case 0x6D:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%m", (const struct tm *)&v29);
            break;
          case 0x70:
            v15 = &v33;
            v20 = __sprintf_chk(&v33, 1LL, 32LL, "%d", v23);
            goto LABEL_31;
          case 0x74:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%H%M%S", (const struct tm *)&v29);
            break;
          case 0x79:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%Y", (const struct tm *)&v29);
            break;
          default:
            v33 = 38;
            if ( v22 == 38 )
            {
              v10 += 2;
              v14 = 0;
              v13 = 1;
            }
            else
            {
              v34 = v22;
              v10 += 2;
              v11 = 38;
              v13 = 1;
              v14 = 1;
            }
            v15 = &v33;
            goto LABEL_12;
        }
        if ( v20 <= 0 )
        {
          v11 = v10[2];
          v10 += 2;
          continue;
        }
LABEL_31:
        v10 += 2;
        v14 = v20 - 1;
        v11 = *v15;
        v13 = 1;
        while ( 1 )
        {
LABEL_12:
          ++v15;
          if ( v13 )
          {
            v16 = sub_B4EB0(v11);
            sub_2ECE0(v12, v16);
            if ( !v14 )
            {
LABEL_14:
              v11 = *v10;
              if ( !*v10 )
                goto LABEL_15;
              goto LABEL_8;
            }
          }
          else
          {
            sub_2ECE0(v12, v11);
            if ( !v14 )
              goto LABEL_14;
          }
          v11 = *v15;
          --v14;
        }
      }
      break;
    }
LABEL_15:
    v17 = (const char **)sub_B4DD0(*v21);
    sub_BC660((void **)v21);
    *(_QWORD *)(v6 + 56) = v17;
    if ( !(unsigned __int8)sub_B5480(v17) )
      goto LABEL_40;
    v18 = sub_1EFD0(*(__int64 **)(v6 + 72), 129);
    if ( v18 == -1 )
    {
      v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64 (__usercall *)@<rax>(__int64@<rdi>, int@<esi>, __int64@<r13>, __int64@<r15>), __int64))(**(_QWORD **)(v6 + 64) + 8LL))(
              *(_QWORD *)(v6 + 64),
              *(_QWORD *)(v6 + 56),
              sub_2CC70,
              v6);
      if ( v19 < 0 )
      {
        *(_DWORD *)(v6 + 8) = 1;
        return;
      }
      goto LABEL_23;
    }
    v19 = 1;
    if ( v18 == 1 )
LABEL_40:
      v19 = 2;
LABEL_23:
    sub_2CC70(v6, v19, (__int64)v12, v6);
  }
}

void __usercall sub_2CA50(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<r15>)
{
  __int64 v6; // r15
  void **v7; // rdi
  __m128i v8; // xmm0
  __int64 v9; // rbx
  char *v10; // r14
  char v11; // si
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // r13
  char v13; // r12
  int v14; // ebx
  char *v15; // rbp
  char v16; // al
  const char **v17; // rbx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  char **v21; // [rsp+0h] [rbp-110h]
  unsigned __int8 v22; // [rsp+1Bh] [rbp-F5h]
  unsigned int v23; // [rsp+1Ch] [rbp-F4h]
  char *v24; // [rsp+20h] [rbp-F0h]
  __int128 v25; // [rsp+28h] [rbp-E8h]
  __int128 v26; // [rsp+38h] [rbp-D8h]
  __int128 v27; // [rsp+48h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-B8h]
  __m128i v29; // [rsp+68h] [rbp-A8h]
  __m128i v30; // [rsp+78h] [rbp-98h]
  __m128i v31; // [rsp+88h] [rbp-88h]
  __int64 v32; // [rsp+98h] [rbp-78h]
  char v33; // [rsp+A8h] [rbp-68h]
  unsigned __int8 v34; // [rsp+A9h] [rbp-67h]
  unsigned __int64 v35; // [rsp+D0h] [rbp-40h]
  __int64 v36; // [rsp+E0h] [rbp-30h]
  __int64 v37; // [rsp+E8h] [rbp-28h]
  __int64 v38; // [rsp+F0h] [rbp-20h]
  __int64 v39; // [rsp+F8h] [rbp-18h]
  __int64 v40; // [rsp+108h] [rbp-8h]

  if ( !*(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 80) )
  {
    v40 = a6;
    v6 = a3;
    v39 = a5;
    v38 = a4;
    v37 = a2;
    v36 = a1;
    v35 = __readfsqword(0x28u);
    sub_99BB0((__m128i *)&v25);
    v7 = *(void ***)(a3 + 56);
    v29 = _mm_loadu_si128((const __m128i *)&v25);
    v8 = _mm_loadu_si128((const __m128i *)&v26);
    v32 = v28;
    v30 = v8;
    v31 = _mm_loadu_si128((const __m128i *)&v27);
    if ( v7 )
      sub_B4E60(v7);
    v23 = sub_1EFD0(*(__int64 **)(v6 + 72), 1);
    v24 = (char *)sub_1F170(*(__int64 **)(v6 + 72), 0);
    v9 = sub_1F530(*(__int64 **)(v6 + 72), 127);
    v21 = (char **)sub_BC640();
    v10 = (char *)sub_B4E20(v9);
    v11 = *v10;
    v12 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v21 + 3);
    while ( 2 )
    {
      if ( !v11 )
        break;
LABEL_8:
      if ( v11 != 38 )
      {
        v33 = v11;
        ++v10;
        v13 = 0;
        v14 = 0;
        v15 = &v33;
        goto LABEL_12;
      }
      v22 = v10[1];
      if ( v10[1] )
      {
        v11 = v10[1];
        switch ( (*__ctype_tolower_loc())[v22] )
        {
          case 0x64:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%d", (const struct tm *)&v29);
            break;
          case 0x68:
            v15 = v24;
            v20 = strlen(v24);
            break;
          case 0x6D:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%m", (const struct tm *)&v29);
            break;
          case 0x70:
            v15 = &v33;
            v20 = __sprintf_chk(&v33, 1LL, 32LL, "%d", v23);
            goto LABEL_31;
          case 0x74:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%H%M%S", (const struct tm *)&v29);
            break;
          case 0x79:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%Y", (const struct tm *)&v29);
            break;
          default:
            v33 = 38;
            if ( v22 == 38 )
            {
              v10 += 2;
              v14 = 0;
              v13 = 1;
            }
            else
            {
              v34 = v22;
              v10 += 2;
              v11 = 38;
              v13 = 1;
              v14 = 1;
            }
            v15 = &v33;
            goto LABEL_12;
        }
        if ( v20 <= 0 )
        {
          v11 = v10[2];
          v10 += 2;
          continue;
        }
LABEL_31:
        v10 += 2;
        v14 = v20 - 1;
        v11 = *v15;
        v13 = 1;
        while ( 1 )
        {
LABEL_12:
          ++v15;
          if ( v13 )
          {
            v16 = sub_B4EB0(v11);
            sub_2ECE0(v12, v16);
            if ( !v14 )
            {
LABEL_14:
              v11 = *v10;
              if ( !*v10 )
                goto LABEL_15;
              goto LABEL_8;
            }
          }
          else
          {
            sub_2ECE0(v12, v11);
            if ( !v14 )
              goto LABEL_14;
          }
          v11 = *v15;
          --v14;
        }
      }
      break;
    }
LABEL_15:
    v17 = (const char **)sub_B4DD0(*v21);
    sub_BC660((void **)v21);
    *(_QWORD *)(v6 + 56) = v17;
    if ( !(unsigned __int8)sub_B5480(v17) )
      goto LABEL_40;
    v18 = sub_1EFD0(*(__int64 **)(v6 + 72), 129);
    if ( v18 == -1 )
    {
      v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64 (__usercall *)@<rax>(__int64@<rdi>, int@<esi>, __int64@<r13>, __int64@<r15>), __int64))(**(_QWORD **)(v6 + 64) + 8LL))(
              *(_QWORD *)(v6 + 64),
              *(_QWORD *)(v6 + 56),
              sub_2CC70,
              v6);
      if ( v19 < 0 )
      {
        *(_DWORD *)(v6 + 8) = 1;
        return;
      }
      goto LABEL_23;
    }
    v19 = 1;
    if ( v18 == 1 )
LABEL_40:
      v19 = 2;
LABEL_23:
    sub_2CC70(v6, v19, (__int64)v12, v6);
  }
}

void __usercall sub_2CA50(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<r15>)
{
  __int64 v6; // r15
  void **v7; // rdi
  __m128i v8; // xmm0
  __int64 v9; // rbx
  char *v10; // r14
  char v11; // si
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // r13
  char v13; // r12
  int v14; // ebx
  char *v15; // rbp
  char v16; // al
  const char **v17; // rbx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  char **v21; // [rsp+0h] [rbp-110h]
  unsigned __int8 v22; // [rsp+1Bh] [rbp-F5h]
  unsigned int v23; // [rsp+1Ch] [rbp-F4h]
  char *v24; // [rsp+20h] [rbp-F0h]
  __int128 v25; // [rsp+28h] [rbp-E8h]
  __int128 v26; // [rsp+38h] [rbp-D8h]
  __int128 v27; // [rsp+48h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-B8h]
  __m128i v29; // [rsp+68h] [rbp-A8h]
  __m128i v30; // [rsp+78h] [rbp-98h]
  __m128i v31; // [rsp+88h] [rbp-88h]
  __int64 v32; // [rsp+98h] [rbp-78h]
  char v33; // [rsp+A8h] [rbp-68h]
  unsigned __int8 v34; // [rsp+A9h] [rbp-67h]
  unsigned __int64 v35; // [rsp+D0h] [rbp-40h]
  __int64 v36; // [rsp+E0h] [rbp-30h]
  __int64 v37; // [rsp+E8h] [rbp-28h]
  __int64 v38; // [rsp+F0h] [rbp-20h]
  __int64 v39; // [rsp+F8h] [rbp-18h]
  __int64 v40; // [rsp+108h] [rbp-8h]

  if ( !*(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 80) )
  {
    v40 = a6;
    v6 = a3;
    v39 = a5;
    v38 = a4;
    v37 = a2;
    v36 = a1;
    v35 = __readfsqword(0x28u);
    sub_99BB0((__m128i *)&v25);
    v7 = *(void ***)(a3 + 56);
    v29 = _mm_loadu_si128((const __m128i *)&v25);
    v8 = _mm_loadu_si128((const __m128i *)&v26);
    v32 = v28;
    v30 = v8;
    v31 = _mm_loadu_si128((const __m128i *)&v27);
    if ( v7 )
      sub_B4E60(v7);
    v23 = sub_1EFD0(*(__int64 **)(v6 + 72), 1);
    v24 = (char *)sub_1F170(*(__int64 **)(v6 + 72), 0);
    v9 = sub_1F530(*(__int64 **)(v6 + 72), 127);
    v21 = (char **)sub_BC640();
    v10 = (char *)sub_B4E20(v9);
    v11 = *v10;
    v12 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v21 + 3);
    while ( 2 )
    {
      if ( !v11 )
        break;
LABEL_8:
      if ( v11 != 38 )
      {
        v33 = v11;
        ++v10;
        v13 = 0;
        v14 = 0;
        v15 = &v33;
        goto LABEL_12;
      }
      v22 = v10[1];
      if ( v10[1] )
      {
        v11 = v10[1];
        switch ( (*__ctype_tolower_loc())[v22] )
        {
          case 0x64:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%d", (const struct tm *)&v29);
            break;
          case 0x68:
            v15 = v24;
            v20 = strlen(v24);
            break;
          case 0x6D:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%m", (const struct tm *)&v29);
            break;
          case 0x70:
            v15 = &v33;
            v20 = __sprintf_chk(&v33, 1LL, 32LL, "%d", v23);
            goto LABEL_31;
          case 0x74:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%H%M%S", (const struct tm *)&v29);
            break;
          case 0x79:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%Y", (const struct tm *)&v29);
            break;
          default:
            v33 = 38;
            if ( v22 == 38 )
            {
              v10 += 2;
              v14 = 0;
              v13 = 1;
            }
            else
            {
              v34 = v22;
              v10 += 2;
              v11 = 38;
              v13 = 1;
              v14 = 1;
            }
            v15 = &v33;
            goto LABEL_12;
        }
        if ( v20 <= 0 )
        {
          v11 = v10[2];
          v10 += 2;
          continue;
        }
LABEL_31:
        v10 += 2;
        v14 = v20 - 1;
        v11 = *v15;
        v13 = 1;
        while ( 1 )
        {
LABEL_12:
          ++v15;
          if ( v13 )
          {
            v16 = sub_B4EB0(v11);
            sub_2ECE0(v12, v16);
            if ( !v14 )
            {
LABEL_14:
              v11 = *v10;
              if ( !*v10 )
                goto LABEL_15;
              goto LABEL_8;
            }
          }
          else
          {
            sub_2ECE0(v12, v11);
            if ( !v14 )
              goto LABEL_14;
          }
          v11 = *v15;
          --v14;
        }
      }
      break;
    }
LABEL_15:
    v17 = (const char **)sub_B4DD0(*v21);
    sub_BC660((void **)v21);
    *(_QWORD *)(v6 + 56) = v17;
    if ( !(unsigned __int8)sub_B5480(v17) )
      goto LABEL_40;
    v18 = sub_1EFD0(*(__int64 **)(v6 + 72), 129);
    if ( v18 == -1 )
    {
      v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64 (__usercall *)@<rax>(__int64@<rdi>, int@<esi>, __int64@<r13>, __int64@<r15>), __int64))(**(_QWORD **)(v6 + 64) + 8LL))(
              *(_QWORD *)(v6 + 64),
              *(_QWORD *)(v6 + 56),
              sub_2CC70,
              v6);
      if ( v19 < 0 )
      {
        *(_DWORD *)(v6 + 8) = 1;
        return;
      }
      goto LABEL_23;
    }
    v19 = 1;
    if ( v18 == 1 )
LABEL_40:
      v19 = 2;
LABEL_23:
    sub_2CC70(v6, v19, (__int64)v12, v6);
  }
}

void __usercall sub_2CA50(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<r15>)
{
  __int64 v6; // r15
  void **v7; // rdi
  __m128i v8; // xmm0
  __int64 v9; // rbx
  char *v10; // r14
  char v11; // si
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // r13
  char v13; // r12
  int v14; // ebx
  char *v15; // rbp
  char v16; // al
  const char **v17; // rbx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  char **v21; // [rsp+0h] [rbp-110h]
  unsigned __int8 v22; // [rsp+1Bh] [rbp-F5h]
  unsigned int v23; // [rsp+1Ch] [rbp-F4h]
  char *v24; // [rsp+20h] [rbp-F0h]
  __int128 v25; // [rsp+28h] [rbp-E8h]
  __int128 v26; // [rsp+38h] [rbp-D8h]
  __int128 v27; // [rsp+48h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-B8h]
  __m128i v29; // [rsp+68h] [rbp-A8h]
  __m128i v30; // [rsp+78h] [rbp-98h]
  __m128i v31; // [rsp+88h] [rbp-88h]
  __int64 v32; // [rsp+98h] [rbp-78h]
  char v33; // [rsp+A8h] [rbp-68h]
  unsigned __int8 v34; // [rsp+A9h] [rbp-67h]
  unsigned __int64 v35; // [rsp+D0h] [rbp-40h]
  __int64 v36; // [rsp+E0h] [rbp-30h]
  __int64 v37; // [rsp+E8h] [rbp-28h]
  __int64 v38; // [rsp+F0h] [rbp-20h]
  __int64 v39; // [rsp+F8h] [rbp-18h]
  __int64 v40; // [rsp+108h] [rbp-8h]

  if ( !*(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 80) )
  {
    v40 = a6;
    v6 = a3;
    v39 = a5;
    v38 = a4;
    v37 = a2;
    v36 = a1;
    v35 = __readfsqword(0x28u);
    sub_99BB0((__m128i *)&v25);
    v7 = *(void ***)(a3 + 56);
    v29 = _mm_loadu_si128((const __m128i *)&v25);
    v8 = _mm_loadu_si128((const __m128i *)&v26);
    v32 = v28;
    v30 = v8;
    v31 = _mm_loadu_si128((const __m128i *)&v27);
    if ( v7 )
      sub_B4E60(v7);
    v23 = sub_1EFD0(*(__int64 **)(v6 + 72), 1);
    v24 = (char *)sub_1F170(*(__int64 **)(v6 + 72), 0);
    v9 = sub_1F530(*(__int64 **)(v6 + 72), 127);
    v21 = (char **)sub_BC640();
    v10 = (char *)sub_B4E20(v9);
    v11 = *v10;
    v12 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v21 + 3);
    while ( 2 )
    {
      if ( !v11 )
        break;
LABEL_8:
      if ( v11 != 38 )
      {
        v33 = v11;
        ++v10;
        v13 = 0;
        v14 = 0;
        v15 = &v33;
        goto LABEL_12;
      }
      v22 = v10[1];
      if ( v10[1] )
      {
        v11 = v10[1];
        switch ( (*__ctype_tolower_loc())[v22] )
        {
          case 0x64:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%d", (const struct tm *)&v29);
            break;
          case 0x68:
            v15 = v24;
            v20 = strlen(v24);
            break;
          case 0x6D:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%m", (const struct tm *)&v29);
            break;
          case 0x70:
            v15 = &v33;
            v20 = __sprintf_chk(&v33, 1LL, 32LL, "%d", v23);
            goto LABEL_31;
          case 0x74:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%H%M%S", (const struct tm *)&v29);
            break;
          case 0x79:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%Y", (const struct tm *)&v29);
            break;
          default:
            v33 = 38;
            if ( v22 == 38 )
            {
              v10 += 2;
              v14 = 0;
              v13 = 1;
            }
            else
            {
              v34 = v22;
              v10 += 2;
              v11 = 38;
              v13 = 1;
              v14 = 1;
            }
            v15 = &v33;
            goto LABEL_12;
        }
        if ( v20 <= 0 )
        {
          v11 = v10[2];
          v10 += 2;
          continue;
        }
LABEL_31:
        v10 += 2;
        v14 = v20 - 1;
        v11 = *v15;
        v13 = 1;
        while ( 1 )
        {
LABEL_12:
          ++v15;
          if ( v13 )
          {
            v16 = sub_B4EB0(v11);
            sub_2ECE0(v12, v16);
            if ( !v14 )
            {
LABEL_14:
              v11 = *v10;
              if ( !*v10 )
                goto LABEL_15;
              goto LABEL_8;
            }
          }
          else
          {
            sub_2ECE0(v12, v11);
            if ( !v14 )
              goto LABEL_14;
          }
          v11 = *v15;
          --v14;
        }
      }
      break;
    }
LABEL_15:
    v17 = (const char **)sub_B4DD0(*v21);
    sub_BC660((void **)v21);
    *(_QWORD *)(v6 + 56) = v17;
    if ( !(unsigned __int8)sub_B5480(v17) )
      goto LABEL_40;
    v18 = sub_1EFD0(*(__int64 **)(v6 + 72), 129);
    if ( v18 == -1 )
    {
      v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64 (__usercall *)@<rax>(__int64@<rdi>, int@<esi>, __int64@<r13>, __int64@<r15>), __int64))(**(_QWORD **)(v6 + 64) + 8LL))(
              *(_QWORD *)(v6 + 64),
              *(_QWORD *)(v6 + 56),
              sub_2CC70,
              v6);
      if ( v19 < 0 )
      {
        *(_DWORD *)(v6 + 8) = 1;
        return;
      }
      goto LABEL_23;
    }
    v19 = 1;
    if ( v18 == 1 )
LABEL_40:
      v19 = 2;
LABEL_23:
    sub_2CC70(v6, v19, (__int64)v12, v6);
  }
}

void __usercall sub_2CA70(__int64 a1@<rdx>, __int64 a2@<rdi>, const void *a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  int v5; // eax
  __int64 v6; // rbx
  unsigned __int64 v7; // rbp
  FILE *v8; // rdi
  void (__fastcall ***v9)(_QWORD, const char *); // rdi

  v5 = *(_DWORD *)(a2 + 8);
  v6 = a2;
  v7 = a1;
  if ( v5 )
  {
    if ( v5 != 1 )
      goto LABEL_3;
LABEL_6:
    sub_BCD20(a2 + 16, (char *)a3, v7);
    return;
  }
  sub_2CA50(a2, a1, a2, (__int64)a3, a4, a5);
  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 == 1 )
    goto LABEL_6;
LABEL_3:
  if ( v5 == 2 )
  {
    if ( !*(_QWORD *)a2 )
      __assert_fail("ctx->lgfp", "logging.c", 0x2Fu, "logwrite");
    if ( fwrite(a3, 1uLL, v7, *(FILE **)a2) < v7 )
    {
      v8 = *(FILE **)a2;
      if ( *(_QWORD *)v6 )
      {
        fclose(v8);
        *(_QWORD *)v6 = 0LL;
      }
      v9 = *(void (__fastcall ****)(_QWORD, const char *))(v6 + 64);
      *(_DWORD *)(v6 + 8) = 3;
      (**v9)(v9, "Disabled writing session log due to error while writing");
    }
  }
}

unsigned __int64 __usercall sub_2CB30@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rax
  char *v5; // rbx
  __int64 v6; // rax
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v9; // [rsp+18h] [rbp-D0h]

  va_start(va, a4);
  v9 = __readfsqword(0x28u);
  v4 = sub_BC310(a2, (const __m128i *)va);
  v5 = v4;
  v6 = strlen(v4);
  sub_2CA70(v6, a1, v5, a3, a4);
  sub_2F4D0(v5);
  return __readfsqword(0x28u) ^ v9;
}

__int64 __usercall sub_2CC10@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  if ( (unsigned int)(*(_DWORD *)(a1 + 80) - 3) <= 1 )
  {
    sub_2CB30(a1, (__int64)&unk_E33A7, a3, a4);
    if ( *(_DWORD *)(a1 + 80) > 0 )
      sub_2CA10(a1);
  }
  return (***(__int64 (__fastcall ****)(_QWORD, __int64))(a1 + 64))(*(_QWORD *)(a1 + 64), a2);
}

unsigned __int64 __usercall sub_2CC70@<rax>(__int64 a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r15>, __int64 a5@<rbx>)
{
  int v5; // er12
  __int64 v6; // rbp
  char v7; // bl
  __int64 v8; // rax
  int v9; // esi
  char *v10; // rdx
  const char *v11; // rsi
  char *v12; // r12
  const void *v13; // rax
  __int64 v14; // rdx
  unsigned __int64 v15; // r12
  bool v17; // zf
  const char *v18; // rsi
  const char **v19; // rdi
  FILE *v20; // rax
  __int64 *v21; // rdi
  __m128i v22; // xmm0
  __int128 v23; // [rsp+0h] [rbp-1A8h]
  __int128 v24; // [rsp+10h] [rbp-198h]
  __int128 v25; // [rsp+20h] [rbp-188h]
  const char *v26; // [rsp+30h] [rbp-178h]
  struct tm tp; // [rsp+40h] [rbp-168h]
  char s; // [rsp+80h] [rbp-128h]
  unsigned __int64 v29; // [rsp+188h] [rbp-20h]

  v5 = a2;
  v6 = a1;
  v29 = __readfsqword(0x28u);
  if ( a2 )
  {
    v17 = a2 == 1;
    v18 = "wb";
    v19 = *(const char ***)(a1 + 56);
    if ( v17 )
      v18 = "ab";
    v20 = sub_B5170(0, a5, v19, v18);
    *(_QWORD *)v6 = v20;
    if ( v20 )
    {
      v21 = *(__int64 **)(v6 + 72);
      *(_DWORD *)(v6 + 8) = 2;
      v7 = sub_1EF00(v21, 131);
      if ( v7 )
      {
        sub_99BB0((__m128i *)&v23);
        *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v23);
        v22 = _mm_loadu_si128((const __m128i *)&v24);
        tp.tm_zone = v26;
        *(__m128i *)&tp.tm_mon = v22;
        *(__m128i *)&tp.tm_isdst = _mm_loadu_si128((const __m128i *)&v25);
        strftime(&s, 0x18uLL, "%Y.%m.%d %H:%M:%S", &tp);
        v7 = 0;
        sub_2CB30(v6, (__int64)"=~=~=~=~=~=~=~=~=~=~=~= PuTTY log %s =~=~=~=~=~=~=~=~=~=~=~=\r\n", a3, a4);
      }
    }
    else
    {
      *(_DWORD *)(v6 + 8) = 3;
      v7 = 1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 3;
    v7 = 0;
  }
  v8 = sub_B4E20(*(_QWORD *)(v6 + 56));
  v9 = *(_DWORD *)(v6 + 80);
  v10 = "ASCII";
  if ( v9 != 1 )
  {
    v10 = "raw";
    if ( v9 != 2 )
    {
      v10 = "SSH packets";
      if ( v9 != 3 )
      {
        v10 = "unknown";
        if ( v9 == 4 )
          v10 = "SSH raw data";
      }
    }
  }
  if ( *(_DWORD *)(v6 + 8) == 3 )
  {
    v11 = "Error writing";
    if ( !v5 )
      v11 = "Disabled writing";
  }
  else
  {
    v11 = "Writing new";
    if ( v5 == 1 )
      v11 = "Appending";
  }
  v12 = sub_BC360((__int64)"%s session log (%s mode) to file: %s", v11, v10, v8);
  (***(void (__fastcall ****)(_QWORD, char *))(v6 + 64))(*(_QWORD *)(v6 + 64), v12);
  if ( v7 )
    (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v6 + 64) + 16LL))(*(_QWORD *)(v6 + 64), v12);
  sub_2F4D0(v12);
  if ( *(_DWORD *)(v6 + 8) == 1 )
    __assert_fail("ctx->state != L_OPENING", "logging.c", 0x8Au, "logfopen_callback");
  while ( sub_BCD00(v6 + 16) )
  {
    v13 = (const void *)sub_BCF00(v6 + 16);
    v15 = v14;
    sub_2CA70(v14, v6, v13, a3, a4);
    sub_BCE20(v6 + 16, v15);
  }
  if ( *(_DWORD *)(v6 + 80) > 0 )
    sub_2CA10(v6);
  return __readfsqword(0x28u) ^ v29;
}

int __fastcall sub_2D250(FILE **a1)
{
  FILE **v1; // rbx
  FILE *v2; // rdi
  int result; // eax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    result = fclose(v2);
    *v1 = 0LL;
  }
  *((_DWORD *)v1 + 2) = 0;
  return result;
}

void __usercall sub_2D280(int a1@<edx>, __int64 a2@<rdi>, char a3@<sil>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  int v5; // eax
  char v6; // [rsp+Ch] [rbp-Ch]

  v5 = *(_DWORD *)(a2 + 80);
  v6 = a3;
  if ( v5 == a1 && v5 > 0 )
    sub_2CA70(1LL, a2, &v6, a4, a5);
}

void __usercall sub_2D2C0(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  char *v4; // rax
  char *v5; // rbx
  char *v6; // rsi
  char *v7; // rdx
  char v8; // cl

  if ( a1 )
  {
    if ( strchr(a2, 10) || strchr(a2, 13) )
    {
      v4 = sub_BC120(a2);
      v5 = v4;
      v6 = v4;
      v7 = v4;
      while ( 1 )
      {
        v8 = *v7;
        if ( !*v7 )
          break;
        while ( 1 )
        {
          ++v6;
          if ( v8 == 13 || v8 == 10 )
            break;
          ++v7;
          *(v6 - 1) = v8;
          v8 = *v7;
          if ( !*v7 )
            goto LABEL_8;
        }
        do
        {
          do
            ++v7;
          while ( *v7 == 13 );
        }
        while ( *v7 == 10 );
        *(v6 - 1) = 32;
      }
LABEL_8:
      *v6 = 0;
      sub_2CC10(a1, (__int64)v4, a3, a4);
      sub_2F4D0(v5);
    }
    else
    {
      sub_2CC10(a1, (__int64)a2, a3, a4);
    }
  }
}

void __usercall sub_2D3A0(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  sub_2D2C0(a1, a2, a3, a4);
  sub_2F4D0(a2);
}

void __usercall sub_2D3C0(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  char *v5; // rbx

  v5 = sub_BC310(a3, (const __m128i *)a1);
  sub_2D2C0(a2, v5, a4, a5);
  sub_2F4D0(v5);
}

unsigned __int64 __usercall sub_2D3F0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v6; // [rsp+18h] [rbp-C0h]

  va_start(va, a4);
  v6 = __readfsqword(0x28u);
  sub_2D3C0((__int64)va, a1, a2, a3, a4);
  return __readfsqword(0x28u) ^ v6;
}

unsigned __int64 __usercall sub_2D4B0@<rax>(__int64 a1@<rcx>, __int64 a2@<rdi>, unsigned int a3@<esi>, __int64 a4@<r8>, unsigned __int64 a5@<r9>, __int64 a6@<r15>, __int64 a7, __int64 a8, __int64 *a9, int a10, __int64 a11)
{
  int v11; // eax
  __int64 v13; // rdx
  __int64 v14; // r13
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rbp
  int v17; // er14
  signed int *v18; // rsi
  signed int *v19; // rax
  unsigned __int64 v20; // rcx
  bool v21; // r8
  __int64 v22; // r15
  bool v23; // r8
  bool v24; // r8
  unsigned __int64 v25; // r9
  signed __int64 v26; // r14
  signed __int64 v27; // ST40_8
  int v28; // ST34_4
  char *v29; // rax
  bool v30; // ST34_1
  __m128i v31; // xmm0
  unsigned __int64 v32; // [rsp+8h] [rbp-210h]
  __int64 v33; // [rsp+48h] [rbp-1D0h]
  __int128 v34; // [rsp+50h] [rbp-1C8h]
  __int128 v35; // [rsp+60h] [rbp-1B8h]
  __int128 v36; // [rsp+70h] [rbp-1A8h]
  const char *v37; // [rsp+80h] [rbp-198h]
  struct tm tp; // [rsp+90h] [rbp-188h]
  char v39; // [rsp+CBh] [rbp-14Dh]
  char v40; // [rsp+CCh] [rbp-14Ch]
  char v41; // [rsp+CDh] [rbp-14Bh]
  char s[61]; // [rsp+D0h] [rbp-148h]
  char v43[203]; // [rsp+10Dh] [rbp-10Bh]
  unsigned __int64 v44; // [rsp+1D8h] [rbp-40h]

  v33 = a4;
  v32 = a5;
  v44 = __readfsqword(0x28u);
  v11 = *(_DWORD *)(a2 + 80);
  if ( v11 == 4 )
  {
    if ( !a1 )
    {
      sub_99BB0((__m128i *)&v34);
      *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v34);
      v31 = _mm_loadu_si128((const __m128i *)&v35);
      tp.tm_zone = v37;
      *(__m128i *)&tp.tm_mon = v31;
      *(__m128i *)&tp.tm_isdst = _mm_loadu_si128((const __m128i *)&v36);
      strftime(s, 0x18uLL, "%Y-%m-%d %H:%M:%S", &tp);
      sub_2CB30(a2, (__int64)"%s raw data at %s\r\n", a3, a6);
      if ( !v32 )
        goto LABEL_34;
      goto LABEL_10;
    }
  }
  else if ( !a1 || v11 != 3 )
  {
    return __readfsqword(0x28u) ^ v44;
  }
  sub_2CB30(a2, (__int64)"%s packet ", a3, a2);
  if ( a9 )
  {
    v13 = *a9;
    sub_2CB30(a2, (__int64)"#0x%lx, ", a3, a2);
  }
  sub_2CB30(a2, (__int64)"type %d / 0x%02x (%s)", a3, a2);
  if ( a10 )
  {
    sub_2CB30(a2, (__int64)" on behalf of downstream #%u", a3, a2);
    if ( a11 )
      sub_2CB30(a2, (__int64)" (%s)", a3, a2);
  }
  sub_2CB30(a2, (__int64)"\r\n", a3, a2);
  if ( v32 )
  {
LABEL_10:
    v14 = 0LL;
    v15 = 0LL;
    v16 = 0LL;
    v17 = 0;
    while ( 1 )
    {
      if ( (signed int)a7 > v15 )
      {
        v18 = (signed int *)(a8 + 12 * v15);
        v19 = v18 + 3;
        v20 = *v18;
        if ( (signed int)v20 + v18[1] <= v16 )
        {
          while ( ++v15 != (signed int)a7 )
          {
            v20 = *v19;
            v18 = v19;
            v19 += 3;
            if ( (signed int)v20 + v18[1] > v16 )
              goto LABEL_39;
          }
        }
        else
        {
LABEL_39:
          if ( v20 <= v16 )
          {
            v22 = (unsigned int)v18[2];
            v21 = (_DWORD)v22 != 2;
            goto LABEL_17;
          }
        }
      }
      v21 = 1;
      v22 = 0LL;
LABEL_17:
      v23 = v14 != 0 && v21;
      if ( v23 )
      {
        v30 = v23;
        v14 = 0LL;
        sub_2CB30(a2, (__int64)"  (%zu byte%s omitted)\r\n", 0LL, v22);
        v24 = v30;
      }
      else
      {
        v24 = v14 == 0;
      }
      if ( !v17 && v24 )
        __sprintf_chk(s, 1LL, 128LL, "  %08zx%*s\r\n", v16 & 0xFFFFFFFFFFFFFFF0LL);
      if ( (_DWORD)v22 == 2 )
      {
        ++v14;
      }
      else
      {
        v25 = v16 & 0xF;
        v26 = 3 * v25 + 13;
        if ( (_DWORD)v22 == 1 )
        {
          s[3 * v25 + 12] = 88;
          v22 = 88LL;
          s[v26] = 88;
          *(_WORD *)&v39 = 22616;
          v41 = 0;
        }
        else
        {
          v27 = 3 * v25 + 12;
          v22 = *(unsigned __int8 *)(v33 + v16);
          v28 = *(unsigned __int8 *)(v33 + v16);
          __sprintf_chk(&v39, 1LL, 5LL, "%02x", v22);
          v25 = v16 & 0xF;
          s[v27] = v39;
          s[v26] = v40;
          if ( (unsigned int)(v28 - 32) > 0x5E )
            v22 = 46LL;
        }
        v43[v25] = v22;
        v17 = (v16 & 0xF) + 1;
      }
      if ( !(++v16 & 0xF) || v32 == v16 || v14 )
      {
        if ( v17 )
        {
          v29 = &s[v17 + 61];
          *(_WORD *)v29 = 2573;
          v29[2] = 0;
          v17 = 0;
          sub_2CA70(strlen(s), a2, s, v14, v22);
        }
      }
      else
      {
        v14 = 0LL;
      }
      if ( v32 <= v16 )
      {
        if ( v14 )
          sub_2CB30(a2, (__int64)"  (%zu byte%s omitted)\r\n", v14, v22);
        break;
      }
    }
  }
LABEL_34:
  if ( *(_DWORD *)(a2 + 80) > 0 )
    sub_2CA10(a2);
  return __readfsqword(0x28u) ^ v44;
}

__int64 __fastcall sub_2D9F0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 *v4; // rax

  v2 = sub_2F450(1uLL, 0x58uLL, 0LL);
  v3 = v2;
  *(_QWORD *)(v2 + 64) = a1;
  *(_QWORD *)v2 = 0LL;
  *(_DWORD *)(v2 + 8) = 0;
  v4 = sub_1EED0(a2);
  *(_QWORD *)(v3 + 72) = v4;
  *(_DWORD *)(v3 + 80) = sub_1EFD0(v4, 128);
  *(_QWORD *)(v3 + 56) = 0LL;
  sub_BCC70((_QWORD *)(v3 + 16));
  return v3;
}

void __fastcall sub_2DA60(FILE **a1)
{
  FILE **v1; // rbx
  FILE *v2; // rdi
  void **v3; // rdi

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    fclose(v2);
    *v1 = 0LL;
  }
  *((_DWORD *)v1 + 2) = 0;
  sub_BCCA0((__int64)(v1 + 2));
  v3 = (void **)v1[7];
  if ( v3 )
    sub_B4E60(v3);
  sub_1ED50(v1[9]);
  sub_2F4D0(v1);
}

__int64 __fastcall sub_2DAB0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128i a16, __m128i a17, __m128i a18, __int64 a7, const __m128i a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a19, __int64 a20, char a21, __int64 a22, __int64 a23, __int64 a24, __int64 a25, unsigned __int64 a26, char a27, __int64 a28, __int64 a29, __int64 a30, __int64 a31, unsigned __int64 a32)
{
  void **v32; // rdi
  __m128i v33; // xmm0
  __int64 v34; // rbx
  char v35; // si
  __int64 v36; // rbx
  const char **v37; // r12
  const char **v38; // rax
  FILE *v39; // rdi
  _QWORD *v40; // rdi
  __int64 *v41; // rax
  __int64 result; // rax
  int v43; // edx
  int v44; // er12
  __int64 *v45; // rax
  int retaddr_4; // [rsp+1Ch] [rbp+4h]

  v36 = a1;
  v37 = (const char **)sub_1F530(a2, 127);
  v38 = (const char **)sub_1F530(*(__int64 **)(a1 + 72), 127);
  if ( sub_B4E30(v38, v37) && (v44 = sub_1EFD0(*(__int64 **)(a1 + 72), 128), v44 == (unsigned int)sub_1EFD0(a2, 128)) )
  {
    sub_1ED50(*(_QWORD **)(a1 + 72));
    v45 = sub_1EED0(a2);
    *(_QWORD *)(a1 + 72) = v45;
    result = sub_1EFD0(v45, 128);
    *(_DWORD *)(a1 + 80) = result;
  }
  else
  {
    v39 = *(FILE **)a1;
    if ( *(_QWORD *)v36 )
    {
      fclose(v39);
      *(_QWORD *)v36 = 0LL;
    }
    v40 = *(_QWORD **)(v36 + 72);
    *(_DWORD *)(v36 + 8) = 0;
    sub_1ED50(v40);
    v41 = sub_1EED0(a2);
    *(_QWORD *)(v36 + 72) = v41;
    result = sub_1EFD0(v41, 128);
    v43 = *(_DWORD *)(v36 + 8);
    *(_DWORD *)(v36 + 80) = result;
    if ( !v43 && (_DWORD)result )
    {
      a32 = __readfsqword(0x28u);
      sub_99BB0((__m128i *)&a8);
      v32 = *(void ***)(v36 + 56);
      *(__m128i *)&a19 = _mm_loadu_si128(&a8);
      v33 = _mm_loadu_si128((const __m128i *)&a10);
      a25 = a14;
      *(__m128i *)&a21 = v33;
      *(__m128i *)&a23 = _mm_loadu_si128((const __m128i *)&a12);
      if ( v32 )
        sub_B4E60(v32);
      retaddr_4 = sub_1EFD0(*(__int64 **)(v36 + 72), 1);
      sub_1F170(*(__int64 **)(v36 + 72), 0);
      v34 = sub_1F530(*(__int64 **)(v36 + 72), 127);
      sub_BC640();
      v35 = *(_BYTE *)sub_B4E20(v34);
      JUMPOUT(v35, 0, &loc_2D02D);
      JUMPOUT(v35, 38, &loc_2D098);
      a27 = v35;
      JUMPOUT(&loc_2D003);
    }
  }
  return result;
}

void __usercall sub_2CA50(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<r15>)
{
  __int64 v6; // r15
  void **v7; // rdi
  __m128i v8; // xmm0
  __int64 v9; // rbx
  char *v10; // r14
  char v11; // si
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // r13
  char v13; // r12
  int v14; // ebx
  char *v15; // rbp
  char v16; // al
  const char **v17; // rbx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  char **v21; // [rsp+0h] [rbp-110h]
  unsigned __int8 v22; // [rsp+1Bh] [rbp-F5h]
  unsigned int v23; // [rsp+1Ch] [rbp-F4h]
  char *v24; // [rsp+20h] [rbp-F0h]
  __int128 v25; // [rsp+28h] [rbp-E8h]
  __int128 v26; // [rsp+38h] [rbp-D8h]
  __int128 v27; // [rsp+48h] [rbp-C8h]
  __int64 v28; // [rsp+58h] [rbp-B8h]
  __m128i v29; // [rsp+68h] [rbp-A8h]
  __m128i v30; // [rsp+78h] [rbp-98h]
  __m128i v31; // [rsp+88h] [rbp-88h]
  __int64 v32; // [rsp+98h] [rbp-78h]
  char v33; // [rsp+A8h] [rbp-68h]
  unsigned __int8 v34; // [rsp+A9h] [rbp-67h]
  unsigned __int64 v35; // [rsp+D0h] [rbp-40h]
  __int64 v36; // [rsp+E0h] [rbp-30h]
  __int64 v37; // [rsp+E8h] [rbp-28h]
  __int64 v38; // [rsp+F0h] [rbp-20h]
  __int64 v39; // [rsp+F8h] [rbp-18h]
  __int64 v40; // [rsp+108h] [rbp-8h]

  if ( !*(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 80) )
  {
    v40 = a6;
    v6 = a3;
    v39 = a5;
    v38 = a4;
    v37 = a2;
    v36 = a1;
    v35 = __readfsqword(0x28u);
    sub_99BB0((__m128i *)&v25);
    v7 = *(void ***)(a3 + 56);
    v29 = _mm_loadu_si128((const __m128i *)&v25);
    v8 = _mm_loadu_si128((const __m128i *)&v26);
    v32 = v28;
    v30 = v8;
    v31 = _mm_loadu_si128((const __m128i *)&v27);
    if ( v7 )
      sub_B4E60(v7);
    v23 = sub_1EFD0(*(__int64 **)(v6 + 72), 1);
    v24 = (char *)sub_1F170(*(__int64 **)(v6 + 72), 0);
    v9 = sub_1F530(*(__int64 **)(v6 + 72), 127);
    v21 = (char **)sub_BC640();
    v10 = (char *)sub_B4E20(v9);
    v11 = *v10;
    v12 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v21 + 3);
    while ( 2 )
    {
      if ( !v11 )
        break;
LABEL_8:
      if ( v11 != 38 )
      {
        v33 = v11;
        ++v10;
        v13 = 0;
        v14 = 0;
        v15 = &v33;
        goto LABEL_12;
      }
      v22 = v10[1];
      if ( v10[1] )
      {
        v11 = v10[1];
        switch ( (*__ctype_tolower_loc())[v22] )
        {
          case 0x64:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%d", (const struct tm *)&v29);
            break;
          case 0x68:
            v15 = v24;
            v20 = strlen(v24);
            break;
          case 0x6D:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%m", (const struct tm *)&v29);
            break;
          case 0x70:
            v15 = &v33;
            v20 = __sprintf_chk(&v33, 1LL, 32LL, "%d", v23);
            goto LABEL_31;
          case 0x74:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%H%M%S", (const struct tm *)&v29);
            break;
          case 0x79:
            v15 = &v33;
            v20 = strftime(&v33, 0x20uLL, "%Y", (const struct tm *)&v29);
            break;
          default:
            v33 = 38;
            if ( v22 == 38 )
            {
              v10 += 2;
              v14 = 0;
              v13 = 1;
            }
            else
            {
              v34 = v22;
              v10 += 2;
              v11 = 38;
              v13 = 1;
              v14 = 1;
            }
            v15 = &v33;
            goto LABEL_12;
        }
        if ( v20 <= 0 )
        {
          v11 = v10[2];
          v10 += 2;
          continue;
        }
LABEL_31:
        v10 += 2;
        v14 = v20 - 1;
        v11 = *v15;
        v13 = 1;
        while ( 1 )
        {
LABEL_12:
          ++v15;
          if ( v13 )
          {
            v16 = sub_B4EB0(v11);
            sub_2ECE0(v12, v16);
            if ( !v14 )
            {
LABEL_14:
              v11 = *v10;
              if ( !*v10 )
                goto LABEL_15;
              goto LABEL_8;
            }
          }
          else
          {
            sub_2ECE0(v12, v11);
            if ( !v14 )
              goto LABEL_14;
          }
          v11 = *v15;
          --v14;
        }
      }
      break;
    }
LABEL_15:
    v17 = (const char **)sub_B4DD0(*v21);
    sub_BC660((void **)v21);
    *(_QWORD *)(v6 + 56) = v17;
    if ( !(unsigned __int8)sub_B5480(v17) )
      goto LABEL_40;
    v18 = sub_1EFD0(*(__int64 **)(v6 + 72), 129);
    if ( v18 == -1 )
    {
      v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64 (__usercall *)@<rax>(__int64@<rdi>, int@<esi>, __int64@<r13>, __int64@<r15>, __int64@<rbx>), __int64))(**(_QWORD **)(v6 + 64) + 8LL))(
              *(_QWORD *)(v6 + 64),
              *(_QWORD *)(v6 + 56),
              sub_2CC70,
              v6);
      if ( v19 < 0 )
      {
        *(_DWORD *)(v6 + 8) = 1;
        return;
      }
      goto LABEL_23;
    }
    v19 = 1;
    if ( v18 == 1 )
LABEL_40:
      v19 = 2;
LABEL_23:
    sub_2CC70(v6, v19, (__int64)v12, v6, (__int64)v17);
  }
}

__int64 __fastcall sub_2DBA0(__int64 *a1)
{
  __int64 **v1; // rbx
  __int64 v2; // rbp
  char v3; // al
  __int64 v4; // rdi
  bool v5; // zf
  __int64 v6; // rax
  __int64 result; // rax

  v1 = (__int64 **)a1;
  v2 = sub_1F170((__int64 *)a1[1], 21);
  v3 = sub_1EF00((__int64 *)a1[1], 48);
  v4 = *a1;
  v5 = v3 == 0;
  v6 = **v1;
  if ( v5 )
    result = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64))(v6 + 120))(v4, 1LL, v2);
  else
    result = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64))(v6 + 128))(v4, 1LL, v2);
  *((_BYTE *)v1 + 41) = 1;
  return result;
}

__int64 (__fastcall **__usercall sub_2DC10@<rax>(__int64 (__fastcall ***a1)()@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>))()
{
  __int64 (__fastcall **result)(); // rax
  __int64 (__fastcall ***v4)(); // rbx
  __int64 v5; // rbp
  char *v6; // rax
  __int64 v7; // rdi

  result = off_323CC0;
  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x163u, "mainchan_send_eof");
  v4 = a1;
  v5 = (__int64)*(a1 - 7);
  if ( !*((_BYTE *)a1 - 15) )
  {
    result = (__int64 (__fastcall **)())(*(__int64 (**)(void))(**(_QWORD **)(v5 + 80) + 8LL))();
    if ( (_BYTE)result || *((_BYTE *)a1 - 14) )
    {
      (*((void (**)(void))**(a1 - 9) + 1))();
      v6 = sub_BC360((__int64)"Sent EOF message");
      sub_2D3A0(*(_QWORD *)(v5 + 72), v6, a2, a3);
      v7 = (__int64)*(a1 - 6);
      *((_BYTE *)v4 - 15) = 1;
      result = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(v7 + 8) + 176LL))(
                                            v7,
                                            0LL);
    }
  }
  return result;
}

void __fastcall sub_2DCB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  char *v5; // rbx
  __int64 v6; // r15
  char *v7; // rbp
  char *v8; // r12
  __int64 v9; // r13
  unsigned int v10; // eax
  char *v11; // rax

  v5 = " (core dumped)";
  v6 = a4;
  v7 = " (";
  v8 = ")";
  v9 = *(_QWORD *)(a1 + 16);
  if ( !(_BYTE)a3 )
    v5 = &locale;
  if ( !a5 )
  {
    v7 = &locale;
    v8 = &locale;
  }
  v10 = sub_BC2F0(a5);
  v11 = sub_BC360((__int64)"Session exited on %s%s%s%.*s%s", a2, v5, v7, v10, v6, v8);
  sub_2D3A0(*(_QWORD *)(v9 + 72), v11, v9, v6);
}

char *sub_2DD40()
{
  return sub_BC120("Main session channel closed");
}

__int64 __fastcall sub_2DD50(__int64 (__fastcall ***a1)(), unsigned __int8 a2)
{
  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x178u, "mainchan_set_input_wanted");
  return (*((__int64 (__fastcall **)(_QWORD, _QWORD))(*(a1 - 6))[1] + 22))(*(a1 - 6), a2);
}

__int64 __fastcall sub_2DDA0(__int64 (__fastcall ***a1)(), unsigned __int8 a2)
{
  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x15Cu, "mainchan_send");
  return (**(__int64 (__fastcall ***)(__int64 (__fastcall *)(), _QWORD))(*(a1 - 7))[10])((*(a1 - 7))[10], a2);
}

signed __int64 __usercall sub_2DDE0@<rax>(__int64 (__fastcall ***a1)()@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>, unsigned int a4@<esi>)
{
  __int64 v4; // rbp
  char *v5; // rax

  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x18Bu, "mainchan_rcvd_exit_status");
  v4 = (__int64)*(a1 - 7);
  sub_42900(*(_QWORD *)(v4 + 88), a4);
  v5 = sub_BC360((__int64)"Session sent command exit status %d", a4);
  sub_2D3A0(*(_QWORD *)(v4 + 72), v5, a2, a3);
  return 1LL;
}

signed __int64 __fastcall sub_2DE50(__int64 (__fastcall ***a1)(), __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5)
{
  unsigned __int8 v5; // bp
  __int64 v6; // r13
  __int64 v7; // ST08_8
  char *v8; // r12

  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x1C7u, "mainchan_rcvd_exit_signal_numeric");
  v5 = a3;
  v6 = a4;
  v7 = a5;
  sub_42900((__int64)(*(a1 - 7))[11], a2 + 128);
  v8 = sub_BC360((__int64)"signal %d", (unsigned int)a2);
  sub_2DCB0((__int64)(a1 - 9), (__int64)v8, v5, v6, v7);
  sub_2F4D0(v8);
  return 1LL;
}

signed __int64 __fastcall sub_2DEF0(__int64 (__fastcall ***a1)(), __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r15
  __int64 v7; // r12
  unsigned __int8 v8; // bp
  __int64 v9; // r14
  unsigned int v10; // eax
  char *v11; // r13

  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x1A4u, "mainchan_rcvd_exit_signal");
  v6 = a3;
  v7 = a6;
  v8 = a4;
  v9 = a5;
  sub_42900((__int64)(*(a1 - 7))[11], 128);
  v10 = sub_BC2F0(v6);
  v11 = sub_BC360((__int64)"unrecognised signal \"%.*s\"", v10, a2);
  sub_2DCB0((__int64)(a1 - 9), (__int64)v11, v8, v9, v7);
  sub_2F4D0(v11);
  return 1LL;
}

unsigned __int64 __fastcall sub_2DFA0(__int64 (__fastcall ***a1)(), __int64 a2)
{
  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x152u, "mainchan_open_failure");
  return sub_42780((__int64)(*(a1 - 7))[11], (__int64)"Server refused to open main channel: %s", a2);
}

void __fastcall sub_2DFF0(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0x74u, "mainchan_free");
  sub_1ED50(*(a1 - 8));
  sub_2F4D0(a1 - 9);
}

__int64 __fastcall sub_2E040(__int64 a1, __int64 a2, __int64 *a3, int a4, int a5, char a6, _QWORD *a7)
{
  __int64 *v7; // rbp
  int v8; // er14
  int v9; // er13
  __int64 v10; // r12
  __int64 *v11; // rax
  __int64 v12; // rax
  __int64 v14; // rbp
  unsigned int v15; // eax
  char v16; // [rsp+Ch] [rbp-3Ch]

  v7 = a3;
  v8 = a4;
  v9 = a5;
  v16 = a6;
  if ( (unsigned __int8)sub_1EF00(a3, 49) )
    return 0LL;
  v10 = sub_2F450(1uLL, 0x58uLL, 0LL);
  *(_QWORD *)v10 = 0LL;
  *(_QWORD *)(v10 + 80) = 0LL;
  memset(
    (void *)((v10 + 8) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v10 - (((_DWORD)v10 + 8) & 0xFFFFFFF8) + 88) >> 3));
  *(_QWORD *)(v10 + 16) = a1;
  *(_QWORD *)(v10 + 24) = a2;
  v11 = sub_1EED0(v7);
  *(_QWORD *)(v10 + 8) = v11;
  *(_DWORD *)(v10 + 60) = v8;
  *(_DWORD *)(v10 + 64) = v9;
  *(_QWORD *)v10 = 0LL;
  *(_DWORD *)(v10 + 80) = 0;
  *(_BYTE *)(v10 + 36) = v16;
  *(_QWORD *)(v10 + 72) = off_323CC0;
  if ( *(_BYTE *)sub_1F170(v11, 50) )
  {
    v14 = sub_1F170(*(__int64 **)(v10 + 8), 50);
    v15 = sub_1EFD0(*(__int64 **)(v10 + 8), 51);
    v12 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, const char *, _QWORD, __int64))(*(_QWORD *)(a2 + 8) + 16LL))(
            a2,
            v14,
            v15,
            "main channel",
            0LL,
            v10 + 72);
    *(_DWORD *)(v10 + 32) = 1;
  }
  else
  {
    v12 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a2 + 8) + 24LL))(a2, v10 + 72);
    *(_DWORD *)(v10 + 32) = 0;
  }
  *(_QWORD *)v10 = v12;
  if ( a7 )
    *a7 = *(_QWORD *)v10;
  return v10;
}

__int64 __fastcall sub_2E1B0(__int64 a1, void (__fastcall *a2)(__int64, const char *, signed __int64, _QWORD), __int64 a3)
{
  __int64 v3; // rbp

  v3 = a3;
  a2(a3, "Break", 0LL, 0LL);
  a2(v3, "SIGINT (Interrupt)", 17LL, 0LL);
  a2(v3, "SIGTERM (Terminate)", 18LL, 0LL);
  a2(v3, "SIGKILL (Kill)", 19LL, 0LL);
  a2(v3, "SIGQUIT (Quit)", 20LL, 0LL);
  a2(v3, "SIGHUP (Hangup)", 21LL, 0LL);
  a2(v3, "More signals", 31LL, 0LL);
  a2(v3, "SIGABRT", 22LL, 0LL);
  a2(v3, "SIGALRM", 23LL, 0LL);
  a2(v3, "SIGFPE", 24LL, 0LL);
  a2(v3, "SIGILL", 25LL, 0LL);
  a2(v3, "SIGPIPE", 26LL, 0LL);
  a2(v3, "SIGSEGV", 27LL, 0LL);
  a2(v3, "SIGUSR1", 28LL, 0LL);
  a2(v3, "SIGUSR2", 29LL, 0LL);
  return ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64, _QWORD))a2)(v3, 0LL, 32LL, 0LL);
}

void __usercall sub_2E2F0(_QWORD *a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  char *v4; // rbp
  __int64 v5; // r12
  char *v6; // rax

  switch ( (_DWORD)a2 )
  {
    case 1:
      if ( *((_BYTE *)a1 + 59) )
      {
        if ( !*((_BYTE *)a1 + 57) )
        {
          (*(void (**)(void))(*(_QWORD *)*a1 + 8LL))();
          *((_BYTE *)a1 + 57) = 1;
        }
      }
      else
      {
        *((_BYTE *)a1 + 56) = 1;
      }
      break;
    case 0:
      (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(*(_QWORD *)*a1 + 136LL))(*a1, a2, 0LL);
      return;
    case 0x11:
      v4 = "INT";
      goto LABEL_22;
    case 0x12:
      v4 = "TERM";
      goto LABEL_22;
    case 0x13:
      v4 = "KILL";
      goto LABEL_22;
    case 0x14:
      v4 = "QUIT";
      goto LABEL_22;
    case 0x15:
      v4 = "HUP";
      goto LABEL_22;
    case 0x16:
      v4 = "ABRT";
      goto LABEL_22;
    case 0x17:
      v4 = "ALRM";
      goto LABEL_22;
    case 0x18:
      v4 = "FPE";
      goto LABEL_22;
    case 0x19:
      v4 = "ILL";
      goto LABEL_22;
    case 0x1A:
      v4 = "PIPE";
      goto LABEL_22;
    case 0x1B:
      v4 = "SEGV";
      goto LABEL_22;
    case 0x1C:
      v4 = "USR1";
      goto LABEL_22;
    default:
      v4 = "USR2";
      if ( (_DWORD)a2 == 29 )
      {
LABEL_22:
        v5 = a1[2];
        (*(void (__fastcall **)(_QWORD, _QWORD, char *))(*(_QWORD *)*a1 + 144LL))(*a1, 0LL, v4);
        v6 = sub_BC360((__int64)"Sent signal SIG%s", v4);
        sub_2D3A0(*(_QWORD *)(v5 + 72), v6, a3, a4);
        return;
      }
      break;
  }
}

_QWORD *__usercall sub_2E4A0@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  *(_BYTE *)(a1 + 59) = 1;
  (*(void (__fastcall **)(_QWORD, signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + 176LL))(
    *(_QWORD *)(a1 + 24),
    1LL);
  (*(void (**)(void))(**(_QWORD **)(a1 + 16) + 40LL))();
  if ( *(_BYTE *)(a1 + 56) )
  {
    *(_BYTE *)(a1 + 56) = 0;
    sub_2E2F0((_QWORD *)a1, 1LL, a2, a3);
  }
  sub_428E0(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 88LL));
  return sub_1BE20(*(_QWORD *)(a1 + 16) + 32LL);
}

void __usercall sub_2E500(__int64 (__fastcall ***a1)()@<rdi>, char a2@<sil>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbp
  char *v5; // rsi
  const char *v6; // rdi
  char *v7; // rax
  char *v8; // rax
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  const char *v13; // rdi
  char *v14; // rsi
  char *v15; // rax
  __int64 *v16; // r12
  __int64 (__fastcall *v17)(); // rdi
  char *v18; // rsi
  char *v19; // rax
  char *v20; // rax
  __int64 v21; // rax
  char *v22; // rsi
  char *v23; // rax
  char *v24; // rax

  if ( *a1 != off_323CC0 )
    __assert_fail("chan->vt == &mainchan_channelvt", "mainchan.c", 0xDAu, "mainchan_request_response");
  v4 = (__int64)*(a1 - 7);
  if ( *((_BYTE *)a1 - 35) )
  {
    *((_BYTE *)a1 - 35) = 0;
    if ( a2 )
    {
      v5 = sub_BC360((__int64)"X11 forwarding enabled");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v5, a3, a4);
      (*((void (__fastcall **)(_QWORD, char *))(*(a1 - 6))[1] + 21))(*(a1 - 6), v5);
      return;
    }
    v6 = "X11 forwarding refused";
    goto LABEL_8;
  }
  if ( *((_BYTE *)a1 - 34) )
  {
    *((_BYTE *)a1 - 34) = 0;
    v6 = "Agent forwarding refused";
    if ( a2 )
      v6 = "Agent forwarding enabled";
    goto LABEL_8;
  }
  if ( *((_BYTE *)a1 - 33) )
  {
    *((_BYTE *)a1 - 33) = 0;
    if ( a2 )
    {
      v8 = sub_BC360((__int64)"Allocated pty");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v8, a3, a4);
      *((_BYTE *)a1 - 14) = 1;
    }
    else
    {
      v18 = sub_BC360((__int64)"Server refused to allocate pty");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v18, a3, a4);
      v19 = sub_BC360((__int64)"Server refused to allocate pty\r\n", v18);
      sub_62710(v4, v19);
      (*((void (__fastcall **)(_QWORD, signed __int64, signed __int64))(*(a1 - 6))[1] + 20))(*(a1 - 6), 1LL, 1LL);
      (*((void (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(a1 - 6))[1] + 20))(*(a1 - 6), 0LL, 1LL);
    }
    return;
  }
  v9 = *((_DWORD *)a1 - 6);
  v10 = *((_DWORD *)a1 - 7);
  if ( v9 >= v10 )
  {
    v16 = (__int64 *)(a1 - 9);
    if ( *((_BYTE *)a1 - 32) )
    {
      *((_BYTE *)a1 - 32) = 0;
      if ( !a2 )
      {
        if ( *(_BYTE *)sub_1F170((__int64 *)*(a1 - 8), 21) )
        {
          v20 = sub_BC360((__int64)"Primary command failed; attempting fallback", 21LL);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v20, a3, a4);
          sub_2DBA0(v16);
          return;
        }
        v17 = (*(a1 - 7))[11];
LABEL_26:
        sub_42500((__int64)v17, (__int64)"Server refused to start a shell/command", a3, a4);
        return;
      }
      v23 = sub_BC360((__int64)"Started a shell/command");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v23, a3, a4);
    }
    else
    {
      if ( !*((_BYTE *)a1 - 31) )
        return;
      *((_BYTE *)a1 - 31) = 0;
      if ( !a2 )
      {
        v17 = *(__int64 (__fastcall **)())(v4 + 88);
        goto LABEL_26;
      }
      v24 = sub_BC360((__int64)"Started a shell/command");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v24, a3, a4);
      sub_42920((__int64)(*(a1 - 7))[11]);
    }
    sub_2E4A0((__int64)v16, a3, a4);
    return;
  }
  v11 = v9 + 1;
  *((_DWORD *)a1 - 6) = v9 + 1;
  if ( !a2 )
  {
    v21 = sub_1F430(*(a1 - 8), 55, v9);
    v22 = sub_BC360((__int64)"Server refused to set environment variable %s", v21);
    sub_2D3A0(*(_QWORD *)(v4 + 72), v22, a3, a4);
    ++*((_DWORD *)a1 - 5);
    v11 = *((_DWORD *)a1 - 6);
    v10 = *((_DWORD *)a1 - 7);
  }
  if ( v10 == v11 )
  {
    v12 = *((_DWORD *)a1 - 5);
    v6 = "All environment variables successfully set";
    if ( !v12 )
    {
LABEL_8:
      v7 = sub_BC360((__int64)v6);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v7, a3, a4);
      return;
    }
    v13 = "Server refused to set all environment variables\r\n";
    if ( v12 == v10 )
    {
      v14 = sub_BC360((__int64)"All environment variables refused");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v14, a3, a4);
      v13 = "Server refused to set environment variables\r\n";
    }
    v15 = sub_BC360((__int64)v13);
    sub_62710(v4, v15);
  }
}

unsigned __int64 __usercall sub_2E810@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 *v3; // r12
  __int64 v4; // rbx
  __int64 v5; // rbp
  char *v6; // rsi
  char *v8; // rsi
  __int64 i; // rax
  _BYTE *v10; // rbp
  char v11; // al
  __int64 *v12; // rdi
  bool v13; // zf
  __int64 v14; // rax
  char *v15; // rax
  __int64 *v16; // r14
  char *v17; // rax
  __int64 v18; // r14
  unsigned int v19; // eax
  __int64 v20; // rax
  void *v21; // [rsp+0h] [rbp-38h]
  unsigned __int64 v22; // [rsp+8h] [rbp-30h]

  v3 = (__int64 *)(a1 - 72);
  v4 = a1;
  v5 = *(_QWORD *)(a1 - 56);
  v22 = __readfsqword(0x28u);
  (*(void (**)(void))(**(_QWORD **)(v5 + 80) + 40LL))();
  v6 = sub_BC360((__int64)&unk_E37C2);
  sub_2D3A0(*(_QWORD *)(v5 + 72), v6, a2, a3);
  if ( *(_BYTE *)(a1 - 36) )
    (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 - 72) + 160LL))(*(_QWORD *)(a1 - 72), v6);
  if ( *(_DWORD *)(a1 - 40) )
  {
    (*(void (__fastcall **)(_QWORD, signed __int64, signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 - 48) + 8LL) + 160LL))(
      *(_QWORD *)(a1 - 48),
      1LL,
      1LL);
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(*(_QWORD *)(a1 - 48) + 8LL) + 160LL))(
      *(_QWORD *)(a1 - 48),
      0LL,
      1LL);
    sub_2E4A0((__int64)v3, a2, a3);
  }
  else
  {
    v8 = (char *)&qword_A8;
    if ( (unsigned __int8)sub_1EF00(*(__int64 **)(a1 - 64), 168) )
    {
      v16 = *(__int64 **)(a1 - 64);
      v17 = (char *)sub_1F170(*(__int64 **)(a1 - 64), 169);
      v18 = sub_BE520(v17, v16, (char **)&v21);
      if ( v18 )
      {
        v19 = sub_1EFD0(*(__int64 **)(a1 - 64), 170);
        v20 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(a1 - 48) + 8LL) + 48LL))(
                *(_QWORD *)(a1 - 48),
                v19,
                v18);
        v8 = (_BYTE *)(&n + 1);
        (*(void (__fastcall **)(_QWORD, signed __int64, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 72) + 80LL))(
          *(_QWORD *)(a1 - 72),
          1LL,
          *(_QWORD *)(v20 + 24),
          *(_QWORD *)(v20 + 32),
          *(unsigned int *)(v18 + 20),
          0LL);
        *(_BYTE *)(a1 - 35) = 1;
      }
      else
      {
        v8 = sub_BC360((__int64)"X11 forwarding not enabled: unable to initialise X display: %s", v21);
        sub_2D3A0(*(_QWORD *)(v5 + 72), v8, (__int64)&v21, a3);
        sub_2F4D0(v21);
      }
    }
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(*(_QWORD *)(*(_QWORD *)(a1 - 48) + 8LL) + 112LL))(
           *(_QWORD *)(a1 - 48),
           v8) )
    {
      (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(a1 - 72) + 88LL))(*(_QWORD *)(a1 - 72), 1LL);
      *(_BYTE *)(a1 - 34) = 1;
    }
    if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(a1 - 64), 22) )
    {
      (*(void (__fastcall **)(_QWORD, signed __int64, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 72) + 96LL))(
        *(_QWORD *)(a1 - 72),
        1LL,
        *(_QWORD *)(a1 - 64),
        *(unsigned int *)(a1 - 12),
        *(unsigned int *)(a1 - 8));
      *(_BYTE *)(a1 - 33) = 1;
    }
    for ( i = sub_1F330(*(__int64 **)(a1 - 64), 55, 0LL, &v21);
          i;
          i = sub_1F330(*(__int64 **)(a1 - 64), 55, (char *)v21, &v21) )
    {
      (*(void (__fastcall **)(_QWORD, signed __int64, void *, __int64))(**(_QWORD **)(a1 - 72) + 104LL))(
        *(_QWORD *)(a1 - 72),
        1LL,
        v21,
        i);
      ++*(_DWORD *)(a1 - 28);
    }
    if ( *(_DWORD *)(a1 - 28) )
    {
      v15 = sub_BC360((__int64)"Sent %d environment variables");
      sub_2D3A0(*(_QWORD *)(v5 + 72), v15, (__int64)&v21, a3);
    }
    v10 = (_BYTE *)sub_1F170(*(__int64 **)(a1 - 64), 20);
    v11 = sub_1EF00(*(__int64 **)(a1 - 64), 47);
    v12 = *(__int64 **)(a1 - 72);
    v13 = v11 == 0;
    v14 = *v12;
    if ( v13 )
    {
      if ( *v10 )
        (*(void (__fastcall **)(__int64 *, signed __int64, _BYTE *))(v14 + 120))(v12, 1LL, v10);
      else
        (*(void (__fastcall **)(__int64 *, signed __int64))(v14 + 112))(v12, 1LL);
    }
    else if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, signed __int64, _BYTE *))(v14 + 128))(v12, 1LL, v10) )
    {
      sub_2DBA0(v3);
      return __readfsqword(0x28u) ^ v22;
    }
    *(_BYTE *)(v4 - 32) = 1;
  }
  return __readfsqword(0x28u) ^ v22;
}

size_t __fastcall sub_2EB10(__int64 a1, const void *a2, size_t a3)
{
  return fwrite(a2, 1uLL, a3, *(FILE **)(a1 - 8));
}

void __fastcall sub_2EB30(__int64 a1, char *a2, size_t a3)
{
  sub_BCD20(*(_QWORD *)(a1 - 8), a2, a3);
}

signed __int64 __fastcall sub_2EB40(__int64 a1, unsigned __int64 a2)
{
  signed __int64 result; // rax

  result = 1LL;
  if ( *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) < a2 )
  {
    *(_DWORD *)(a1 + 24) = 1;
    result = 0LL;
  }
  return result;
}

__int64 __fastcall sub_2EC20(__int64 (**a1)(void))
{
  return (*a1)();
}

__int64 __fastcall sub_2EC30(__int64 (**a1)(void))
{
  return (*a1)();
}

unsigned __int64 __fastcall sub_2EC40(void (__fastcall **a1)(_QWORD, __int64 *, signed __int64), unsigned __int64 a2, unsigned __int8 a3)
{
  signed __int64 v3; // rcx
  unsigned __int128 v4; // ax
  unsigned __int64 v5; // rbx
  signed __int64 v6; // rbp
  __int64 v8; // [rsp+0h] [rbp-48h]
  __int64 v9; // [rsp+8h] [rbp-40h]
  unsigned __int64 v10; // [rsp+18h] [rbp-30h]

  v10 = __readfsqword(0x28u);
  v3 = 72340172838076673LL * a3;
  v4 = 0x101010101010101LL * (unsigned __int128)a3;
  v8 = v4;
  v9 = v3 + *((_QWORD *)&v4 + 1);
  if ( a2 )
  {
    v5 = a2;
    do
    {
      v6 = 16LL;
      if ( v5 <= 0x10 )
        v6 = v5;
      (*a1)(a1, &v8, v6);
      v5 -= v6;
    }
    while ( v5 );
  }
  return __readfsqword(0x28u) ^ v10;
}

__int64 __fastcall sub_2ECE0(__int64 (__fastcall **a1)(_QWORD, char *, signed __int64), char a2)
{
  char v3; // [rsp+Ch] [rbp-Ch]

  v3 = a2;
  return (*a1)(a1, &v3, 1LL);
}

unsigned __int64 __fastcall sub_2ED00(void (__fastcall **a1)(_QWORD, char *, signed __int64, _QWORD), char a2)
{
  char v3; // [rsp+7h] [rbp-11h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  v3 = a2;
  (*a1)(a1, &v3, 1LL, 0LL);
  return __readfsqword(0x28u) ^ v4;
}

unsigned __int64 __fastcall sub_2ED40(void (__fastcall **a1)(_QWORD, char *, signed __int64, _QWORD), __int16 a2)
{
  char v3; // [rsp+6h] [rbp-12h]
  char v4; // [rsp+7h] [rbp-11h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v4 = a2;
  v5 = __readfsqword(0x28u);
  v3 = HIBYTE(a2);
  (*a1)(a1, &v3, 2LL, 0LL);
  return __readfsqword(0x28u) ^ v5;
}

unsigned __int64 __fastcall sub_2ED90(void (__fastcall **a1)(_QWORD, char *, signed __int64, _QWORD), int a2)
{
  char v3; // [rsp+4h] [rbp-14h]
  char v4; // [rsp+5h] [rbp-13h]
  char v5; // [rsp+6h] [rbp-12h]
  char v6; // [rsp+7h] [rbp-11h]
  unsigned __int64 v7; // [rsp+8h] [rbp-10h]

  v5 = BYTE1(a2);
  v6 = a2;
  v3 = HIBYTE(a2);
  v7 = __readfsqword(0x28u);
  v4 = BYTE2(a2);
  (*a1)(a1, &v3, 4LL, 0LL);
  return __readfsqword(0x28u) ^ v7;
}

unsigned __int64 __fastcall sub_2EDF0(void (__fastcall **a1)(_QWORD, char *, signed __int64, _QWORD), __int64 a2)
{
  char v3; // [rsp+0h] [rbp-18h]
  char v4; // [rsp+1h] [rbp-17h]
  char v5; // [rsp+2h] [rbp-16h]
  char v6; // [rsp+3h] [rbp-15h]
  char v7; // [rsp+4h] [rbp-14h]
  char v8; // [rsp+5h] [rbp-13h]
  char v9; // [rsp+6h] [rbp-12h]
  char v10; // [rsp+7h] [rbp-11h]
  unsigned __int64 v11; // [rsp+8h] [rbp-10h]

  v9 = BYTE1(a2);
  v10 = a2;
  v8 = BYTE2(a2);
  v7 = BYTE3(a2);
  v6 = BYTE4(a2);
  v5 = BYTE5(a2);
  v3 = HIBYTE(a2);
  v11 = __readfsqword(0x28u);
  v4 = BYTE6(a2);
  (*a1)(a1, &v3, 8LL, 0LL);
  return __readfsqword(0x28u) ^ v11;
}

unsigned __int64 __fastcall sub_2EE80(void (__fastcall **a1)(_QWORD, char *, signed __int64), char *a2, unsigned __int64 a3)
{
  signed __int64 v3; // rbx
  char v5; // [rsp+4h] [rbp-24h]
  char v6; // [rsp+5h] [rbp-23h]
  char v7; // [rsp+6h] [rbp-22h]
  char v8; // [rsp+7h] [rbp-21h]
  unsigned __int64 v9; // [rsp+8h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( a3 >> 31 > 1 )
    __assert_fail("(len >> 31) < 2", "marshal.c", 0x41u, "BinarySink_put_string");
  v3 = a3;
  v7 = BYTE1(a3);
  v8 = a3;
  v6 = BYTE2(a3);
  v5 = BYTE3(a3);
  (*a1)(a1, &v5, 4LL);
  (*a1)(a1, a2, v3);
  return __readfsqword(0x28u) ^ v9;
}

unsigned __int64 __fastcall sub_2EF30(void (__fastcall **a1)(_QWORD, char *, signed __int64), char *a2, unsigned __int64 a3)
{
  return sub_2EE80(a1, a2, a3);
}

unsigned __int64 __fastcall sub_2EF40(void (__fastcall **a1)(_QWORD, char *, signed __int64), char *a2)
{
  unsigned __int64 v2; // rax

  v2 = strlen(a2);
  return sub_2EE80(a1, a2, v2);
}

void __fastcall sub_2EF70(void (__fastcall **a1)(_QWORD, char *, signed __int64), __int64 a2)
{
  sub_2EE80(a1, *(char **)a2, *(_QWORD *)(a2 + 16));
  sub_BC660((void **)a2);
}

__int64 __fastcall sub_2EF90(__int64 (__fastcall **a1)(_QWORD, const char *, size_t), const char *a2)
{
  size_t v2; // rax

  v2 = strlen(a2);
  return (*a1)(a1, a2, v2 + 1);
}

signed __int64 __fastcall sub_2EFC0(void (__fastcall **a1)(_QWORD, char *, signed __int64), const char *a2)
{
  size_t v2; // rax
  size_t v3; // rbp
  char v5; // [rsp+7h] [rbp-21h]
  unsigned __int64 v6; // [rsp+8h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v2 = strlen(a2);
  if ( v2 > 0xFF )
    return 0LL;
  v3 = v2;
  v5 = v2;
  (*a1)(a1, &v5, 1LL);
  (*a1)(a1, (char *)a2, v3);
  return 1LL;
}

char *__fastcall sub_2F040(__int64 a1, unsigned __int64 a2)
{
  char *result; // rax
  __int64 v3; // rdx

  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, a2) )
    return &locale;
  v3 = *(_QWORD *)(a1 + 8);
  result = (char *)(v3 + *(_QWORD *)a1);
  *(_QWORD *)(a1 + 8) = v3 + a2;
  return result;
}

__int64 __fastcall sub_2F080(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx

  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, 1uLL) )
    return 0LL;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  return *(unsigned __int8 *)(v3 + v2);
}

bool __fastcall sub_2F0C0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx

  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, 1uLL) )
    return 0;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  return *(_BYTE *)(v3 + v2) != 0;
}

__int64 __fastcall sub_2F100(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int8 *v3; // rdx
  bool v4; // zf

  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, 2uLL) )
    return 0LL;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = (unsigned __int8 *)(v2 + *(_QWORD *)a1);
  *(_QWORD *)(a1 + 8) = v2 + 2;
  v4 = ((*v3 << 8) | v3[1]) == 0;
  return _byteswap_ushort(*(_WORD *)v3);
}

__int64 __fastcall sub_2F150(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx

  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, 4uLL) )
    return 0LL;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = v2 + 4;
  return _byteswap_ulong(*(_DWORD *)(v3 + v2));
}

char *__fastcall sub_2F1D0(__int64 a1)
{
  char *result; // rax
  __int64 v2; // rax
  __int64 v3; // rdx
  unsigned __int32 v4; // edx
  __int64 v5; // r8
  __int64 v6; // rdx

  if ( *(_DWORD *)(a1 + 24) )
    return &locale;
  if ( !(unsigned __int8)sub_2EB40(a1, 4uLL) )
    return &locale;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = v2 + 4;
  v4 = _byteswap_ulong(*(_DWORD *)(v3 + v2));
  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, v4) )
    return &locale;
  v6 = *(_QWORD *)(a1 + 8);
  result = (char *)(v6 + *(_QWORD *)a1);
  *(_QWORD *)(a1 + 8) = v6 + v5;
  return result;
}

char *__fastcall sub_2F240(__int64 a1)
{
  char *v1; // rbp
  __int64 v2; // r12
  _BYTE *v3; // rax

  v1 = &locale;
  if ( *(_DWORD *)(a1 + 24) )
    return v1;
  v2 = *(_QWORD *)(a1 + 8);
  v1 = (char *)(v2 + *(_QWORD *)a1);
  v3 = memchr((const void *)(v2 + *(_QWORD *)a1), 0, *(_QWORD *)(a1 + 16) - v2);
  if ( v3 )
  {
    *(_QWORD *)(a1 + 8) = v3 - v1 + v2 + 1;
    return v1;
  }
  *(_DWORD *)(a1 + 24) = 1;
  return &locale;
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

void __fastcall sub_2F2C0(__int64 a1)
{
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  retaddr = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  JUMPOUT(*(_DWORD *)(a1 + 24), 0, &loc_2EBC1);
  JUMPOUT(&loc_2EC13);
}

__int64 __fastcall sub_2F2B0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  int v3; // eax
  __int64 v4; // rdx
  __int64 v6; // [rsp+0h] [rbp-40h]

  v6 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 24) )
  {
    while ( (unsigned __int8)sub_2EB40(a1, 1uLL) )
    {
      v2 = *(_QWORD *)(a1 + 8);
      if ( (strchr(a2, *(char *)(*(_QWORD *)a1 + v2)) != 0LL) == 1 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v2 + 1;
        if ( !v3 )
          continue;
      }
      return v6;
    }
    v4 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  }
  return v6;
}

unsigned __int64 __fastcall sub_2F2D0(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // r13
  unsigned __int64 v3; // r12
  signed __int64 v4; // r14
  char *v5; // rax
  signed __int64 v6; // rdx
  char v8; // al

  v1 = *a1;
  v2 = a1[1];
  v3 = *a1 + v2;
  if ( !*((_DWORD *)a1 + 6) )
  {
    v4 = a1[2];
    v5 = (char *)memchr((const void *)(*a1 + v2), 10, v4 - v2);
    if ( v5 )
      v4 = (signed __int64)&v5[v2 - v3 + 1];
    a1[1] = v4;
    v6 = v1 + v4;
    if ( v1 + v4 > v3 && *(_BYTE *)(v6 - 1) == 10 && v6 - 1 > v3 )
      v8 = *(_BYTE *)(v6 - 2);
  }
  return v3;
}

char *__fastcall sub_2F370(__int64 a1)
{
  char *result; // rax
  __int64 v2; // rax
  __int64 v3; // rsi
  __int64 v4; // r8
  __int64 v5; // rdx

  if ( *(_DWORD *)(a1 + 24) )
    return &locale;
  if ( !(unsigned __int8)sub_2EB40(a1, 1uLL) )
    return &locale;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = v2 + 1;
  if ( *(_DWORD *)(a1 + 24) || !(unsigned __int8)sub_2EB40(a1, *(unsigned __int8 *)(v3 + v2)) )
    return &locale;
  v5 = *(_QWORD *)(a1 + 8);
  result = (char *)(v5 + *(_QWORD *)a1);
  *(_QWORD *)(a1 + 8) = v5 + v4;
  return result;
}

unsigned __int64 __fastcall sub_2F3E0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax

  result = *(_QWORD *)(a1 + 16);
  if ( result >= a2 )
  {
    *(_QWORD *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 24) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 24) = 1;
  }
  return result;
}

_QWORD *__fastcall sub_2F410(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  *a1 = a2;
  a1[1] = sub_2EB10;
  result = a1 + 1;
  a1[2] = a1 + 1;
  return result;
}

_QWORD *__fastcall sub_2F430(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  *a1 = a2;
  a1[1] = sub_2EB30;
  result = a1 + 1;
  a1[2] = a1 + 1;
  return result;
}

void *__fastcall sub_2F450(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  size_t v4; // rdi
  void *result; // rax

  v3 = a2 * a1;
  if ( !is_mul_ok(a2, a1) || ~a3 < v3 )
    goto LABEL_9;
  v4 = a3 + v3;
  if ( !(a3 + v3) )
    v4 = 1LL;
  result = malloc(v4);
  if ( !result )
LABEL_9:
    sub_32270();
  return result;
}

void *__fastcall sub_2F490(void *a1, size_t a2, unsigned __int64 a3)
{
  size_t v3; // rsi
  void *result; // rax

  if ( 0x7FFFFFFF / a3 < a2 || ((v3 = a3 * a2, !a1) ? (result = malloc(v3)) : (result = realloc(a1, v3)), !result) )
    sub_32270();
  return result;
}

void __fastcall sub_2F4D0(void *a1)
{
  if ( a1 )
    free(a1);
}

void *__fastcall sub_2F4F0(void *ptr, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, char a6)
{
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r14
  void *v9; // r13
  unsigned __int64 v10; // rcx
  void *v11; // r15
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  void *v16; // rax
  size_t v17; // rbp

  if ( !a3 )
    __assert_fail("eltsize > 0", "memory.c", 0x58u, "safegrowarray");
  v6 = a3;
  v7 = 0xFFFFFFFFFFFFFFFFLL / a3;
  v8 = *a2;
  v9 = ptr;
  if ( 0xFFFFFFFFFFFFFFFFLL / a3 < *a2 )
    __assert_fail("oldsize <= maxsize", "memory.c", 0x5Eu, "safegrowarray");
  if ( v7 < a4 )
    __assert_fail("oldlen <= maxsize", "memory.c", 0x5Fu, "safegrowarray");
  if ( v7 - a4 < a5 )
    __assert_fail("extralen <= maxsize - oldlen", "memory.c", 0x60u, "safegrowarray");
  v10 = a5 + a4;
  v11 = ptr;
  if ( v10 >= v8 )
  {
    v12 = v10 - v8;
    if ( v8 >> 4 >= v12 )
      v12 = v8 >> 4;
    v13 = 0x100 / a3;
    if ( 0x100 / a3 < v12 )
      v13 = v12;
    v14 = 0xFFFFFFFFFFFFFFFFLL / a3 - v8;
    if ( v14 > v13 )
      v14 = v13;
    if ( a6 )
    {
      v16 = sub_2F450(v14 + v8, a3, 0LL);
      v11 = v16;
      if ( v8 )
      {
        v17 = v8 * v6;
        memcpy(v16, v9, v17);
        sub_BD070(v9, v17);
        free(v9);
      }
    }
    else
    {
      v11 = sub_2F490(v9, v14 + v8, a3);
    }
    *a2 = v14 + v8;
  }
  return v11;
}

bool __fastcall sub_2F670(int a1)
{
  int v1; // edx
  int v2; // esi
  char *v3; // rcx

  v1 = 618;
  v2 = -1;
  do
  {
    while ( 1 )
    {
      if ( v1 - v2 <= 1 )
        return 0;
      v3 = (char *)&unk_E4860 + 12 * ((v1 + v2) / 2);
      if ( a1 >= *(_DWORD *)v3 )
        break;
      v1 = (v1 + v2) / 2;
    }
    v2 = (v1 + v2) / 2;
  }
  while ( a1 > *((_DWORD *)v3 + 1) );
  return ((1 << v3[8]) & 0x78) != 0;
}

signed __int64 __fastcall sub_2F6D0(__int64 a1, __int64 a2, int a3)
{
  signed __int64 v3; // rax
  int v4; // er8
  int v5; // er9
  __int64 v6; // rcx
  char v7; // r10
  __int64 v8; // r10
  signed int v9; // ebx
  int v10; // er10
  signed int v11; // er9
  __int64 v12; // rcx
  int v13; // ecx
  signed int v14; // er9
  __int64 v15; // rcx
  char v16; // cl
  unsigned int v18; // er9
  bool v19; // r9
  __int64 v20; // rcx
  int v21; // ecx
  unsigned int v22; // ebp

  if ( a3 > 0 )
  {
    v3 = -8LL;
    v4 = 0;
    while ( 1 )
    {
      ++v4;
      *(_QWORD *)(a2 + v3 + 8) = *(_QWORD *)(a1 + v3 + 8);
      *(_DWORD *)(a2 + v3 + 16) = *(_DWORD *)(a1 + v3 + 16);
      v5 = *(_DWORD *)(a1 + v3 + 12);
      v6 = (unsigned int)(v5 - 1569);
      if ( (unsigned int)v6 > 0xB1 )
        goto LABEL_14;
      v7 = *((_BYTE *)&unk_E6560 + 8 * v6);
      if ( v7 == 1 )
      {
        v14 = *((_DWORD *)&unk_E6560 + 2 * v6 + 1);
        if ( a3 > v4 )
        {
          v15 = (unsigned int)(*(_DWORD *)(a1 + v3 + 24) - 1569);
          if ( (unsigned int)v15 <= 0xB1 )
          {
            v16 = *((_BYTE *)&unk_E6560 + 8 * v15);
            if ( !(v16 & 0xFD) || v16 == 4 )
            {
              *(_DWORD *)(a2 + v3 + 12) = v14 + 1;
              goto LABEL_15;
            }
          }
        }
        goto LABEL_35;
      }
      if ( v7 != 2 )
        goto LABEL_14;
      if ( a3 <= v4 || (v8 = (unsigned int)(*(_DWORD *)(a1 + v3 + 24) - 1569), (unsigned int)v8 > 0xB1) )
      {
        if ( v5 == 1604 && v4 != 1 )
        {
          v18 = *(_DWORD *)(a1 + v3);
          if ( v18 == 1571 )
          {
            v9 = 3;
            v19 = 0;
LABEL_45:
            if ( v9 == 4 || v19 )
              *(_DWORD *)(a2 + v3 + 12) = 65272;
            else
              *(_DWORD *)(a2 + v3 + 12) = 65271;
            goto LABEL_64;
          }
          if ( v18 <= 0x623 )
          {
            if ( v18 == 1570 )
            {
              v9 = 3;
              v19 = 0;
LABEL_61:
              if ( v9 == 4 || v19 )
                *(_DWORD *)(a2 + v3 + 12) = 65270;
              else
                *(_DWORD *)(a2 + v3 + 12) = 65269;
              goto LABEL_64;
            }
          }
          else
          {
            if ( v18 == 1573 )
            {
              v9 = 3;
              v19 = 0;
LABEL_56:
              if ( v9 == 4 || v19 )
                *(_DWORD *)(a2 + v3 + 12) = 65274;
              else
                *(_DWORD *)(a2 + v3 + 12) = 65273;
              goto LABEL_64;
            }
            if ( v18 == 1575 )
            {
              v9 = 3;
              v19 = 0;
LABEL_29:
              if ( v9 == 4 || v19 )
                *(_DWORD *)(a2 + v3 + 12) = 65276;
              else
                *(_DWORD *)(a2 + v3 + 12) = 65275;
LABEL_64:
              *(_DWORD *)(a2 + v3) = 32;
              goto LABEL_14;
            }
          }
        }
      }
      else
      {
        v9 = *((char *)&unk_E6560 + 8 * v8);
        v10 = (char)(*((_BYTE *)&unk_E6560 + 8 * v8) & 0xFD);
        if ( v5 == 1604 )
        {
          v19 = v10 == 0;
          if ( v4 == 1 )
          {
            v11 = 65245;
            if ( v10 && v9 != 4 )
            {
              v14 = 65245;
LABEL_35:
              *(_DWORD *)(a2 + v3 + 12) = v14;
              goto LABEL_14;
            }
            goto LABEL_37;
          }
          v22 = *(_DWORD *)(a1 + v3);
          if ( v22 == 1571 )
            goto LABEL_45;
          if ( v22 <= 0x623 )
          {
            if ( v22 == 1570 )
              goto LABEL_61;
          }
          else
          {
            if ( v22 == 1573 )
              goto LABEL_56;
            if ( v22 == 1575 )
              goto LABEL_29;
          }
        }
        if ( !v10 || v9 == 4 )
        {
          v11 = *((_DWORD *)&unk_E6560 + 2 * v6 + 1);
          if ( v4 != 1 )
          {
            v12 = (unsigned int)(*(_DWORD *)(a1 + v3) - 1569);
            if ( (unsigned int)v12 <= 0xB1 )
            {
              v13 = *((char *)&unk_E6560 + 8 * v12);
              if ( (unsigned int)(v13 - 1) <= 1 || (_BYTE)v13 == 4 )
              {
                *(_DWORD *)(a2 + v3 + 12) = v11 + 3;
                goto LABEL_14;
              }
            }
          }
LABEL_37:
          *(_DWORD *)(a2 + v3 + 12) = v11 + 1;
          goto LABEL_14;
        }
      }
      v14 = *((_DWORD *)&unk_E6560 + 2 * v6 + 1);
      if ( v4 == 1 )
        goto LABEL_35;
      v20 = (unsigned int)(*(_DWORD *)(a1 + v3) - 1569);
      if ( (unsigned int)v20 > 0xB1 )
        goto LABEL_35;
      v21 = *((char *)&unk_E6560 + 8 * v20);
      if ( (unsigned int)(v21 - 1) > 1 && (_BYTE)v21 != 4 )
        goto LABEL_35;
      *(_DWORD *)(a2 + v3 + 12) = v14 + 2;
LABEL_14:
      if ( a3 <= v4 )
        return 1LL;
LABEL_15:
      v3 += 12LL;
    }
  }
  return 1LL;
}

signed __int64 __fastcall sub_2FA50(__int64 a1, signed int a2)
{
  int *v2; // r9
  __int64 v3; // r13
  int v4; // er11
  int v5; // edx
  int v6; // er8
  char *v7; // rcx
  signed int v9; // ebx
  __int64 v10; // rbp
  char *v11; // r15
  int *v12; // rdi
  _BYTE *v13; // r14
  int v14; // er9
  int v15; // ecx
  int v16; // esi
  _DWORD *v17; // rdx
  __int64 v18; // rax
  unsigned int v19; // er10
  int *v20; // r8
  __int64 v21; // rdi
  char v22; // r11
  signed __int64 v23; // rbx
  int v24; // esi
  int v25; // edx
  int v26; // ecx
  _DWORD *v27; // r9
  int v28; // edx
  int v29; // ebx
  _BYTE *v30; // rax
  char *v31; // rdi
  char *v32; // rsi
  char *v33; // rax
  char *v34; // rdx
  char v35; // al
  signed __int64 v36; // rcx
  int v37; // eax
  signed __int64 v38; // rax
  char v39; // al
  char v40; // cl
  char v41; // al
  char v42; // al
  char *v43; // rax
  char *v44; // rax
  char v45; // dl
  __int64 v46; // rax
  char v47; // dl
  char *v48; // rcx
  char v49; // di
  __int64 v50; // rax
  unsigned __int8 v51; // cl
  signed __int64 v52; // rdx
  __int64 v53; // rcx
  signed __int64 v54; // rsi
  char v55; // al
  signed __int64 v56; // rdx
  int v57; // esi
  signed int v58; // eax
  int v59; // edi
  char *v60; // rdx
  char v61; // cl
  __int64 i; // rcx
  int v63; // er13
  char v64; // r9
  char *v65; // rax
  char *v66; // rax
  __int64 v67; // rax
  __int64 v68; // rax
  char v69; // dl
  char v70; // cl
  __int64 v71; // rax
  char v72; // dl
  char v73; // cl
  int v74; // edi
  int *v75; // r8
  int v76; // er10
  int v77; // ecx
  int v78; // esi
  char *v79; // rdx
  int *v80; // r9
  __int64 v81; // r11
  int v82; // esi
  int v83; // edx
  int v84; // ecx
  _DWORD *v85; // rdi
  char *v86; // r15
  __int64 v87; // rcx
  signed __int64 v88; // rax
  unsigned int v89; // edx
  int v90; // er12
  int v91; // ecx
  unsigned __int8 *v92; // rax
  int v93; // eax
  int *v94; // r8
  int v95; // edi
  int v96; // edx
  int v97; // ecx
  char *v98; // r15
  int v99; // edx
  int v100; // ecx
  int v101; // esi
  char *v102; // r8
  int v103; // edx
  int v104; // ecx
  char *v105; // r8
  unsigned __int8 v106; // al
  __int64 v107; // rdx
  unsigned __int8 k; // cl
  int v109; // er9
  int v110; // er15
  signed int v111; // edi
  __int64 v112; // rax
  __int64 v113; // rcx
  int v114; // edx
  __int64 v115; // r8
  int v116; // eax
  int v117; // ecx
  __int64 v118; // rax
  int v119; // edx
  int v120; // esi
  signed __int64 v121; // rdx
  _QWORD *v122; // rax
  __int64 v123; // rdi
  __int16 v124; // r8
  __int16 v125; // r10
  int v126; // er13
  int v127; // er12
  int v128; // edx
  unsigned __int8 *v129; // rax
  signed __int64 v130; // rdx
  __int64 j; // rcx
  char v132; // r9
  char *v133; // rax
  char v134; // r11
  char v135; // dl
  char v136; // al
  __int64 v137; // [rsp+0h] [rbp-78h]
  int v138; // [rsp+0h] [rbp-78h]
  __int64 v139; // [rsp+8h] [rbp-70h]
  char v140; // [rsp+8h] [rbp-70h]
  int v141; // [rsp+8h] [rbp-70h]
  __int64 v142; // [rsp+10h] [rbp-68h]
  int v143; // [rsp+18h] [rbp-60h]
  signed int v144; // [rsp+18h] [rbp-60h]
  unsigned __int8 v145; // [rsp+1Fh] [rbp-59h]
  __int64 v146; // [rsp+20h] [rbp-58h]
  char *v147; // [rsp+20h] [rbp-58h]
  signed int v148; // [rsp+28h] [rbp-50h]
  signed __int64 v149; // [rsp+28h] [rbp-50h]

  if ( a2 <= 0 )
    return 0LL;
  v2 = (int *)(a1 + 4);
  v143 = a2 - 1;
  v139 = (unsigned int)(a2 - 1);
  v137 = a1 + 4;
  v142 = a1 + 16;
  v3 = a1 + 16 + 12 * v139;
LABEL_3:
  v4 = *v2;
  v5 = 618;
  v6 = -1;
  do
  {
    while ( 1 )
    {
      if ( v5 - v6 <= 1 )
      {
LABEL_7:
        v2 += 3;
        if ( v2 == (int *)v3 )
          return 0LL;
        goto LABEL_3;
      }
      v7 = (char *)&unk_E4860 + 12 * ((v5 + v6) / 2);
      if ( v4 >= *(_DWORD *)v7 )
        break;
      v5 = (v5 + v6) / 2;
    }
    v6 = (v5 + v6) / 2;
  }
  while ( v4 > *((_DWORD *)v7 + 1) );
  if ( (unsigned int)(unsigned __int8)v7[8] - 3 > 1 )
    goto LABEL_7;
  v9 = a2;
  v10 = a1;
  v146 = a2;
  v11 = (char *)sub_2F450(a2, 1uLL, 0LL);
  v12 = (int *)(a1 + 4);
  v13 = sub_2F450(a2, 1uLL, 0LL);
  while ( 2 )
  {
    v14 = *v12;
    v15 = 618;
    v16 = -1;
    do
    {
      while ( 1 )
      {
        if ( v15 - v16 <= 1 )
          goto LABEL_16;
        v17 = (_DWORD *)((char *)&unk_E4860 + 12 * ((v15 + v16) / 2));
        if ( v14 >= *v17 )
          break;
        v15 = (v15 + v16) / 2;
      }
      v16 = (v15 + v16) / 2;
    }
    while ( v14 > v17[1] );
    v37 = v17[2];
    if ( (unsigned int)(unsigned __int8)v37 - 3 <= 1 )
    {
      v145 = 1;
      break;
    }
    v145 = v17[2];
    if ( (_BYTE)v37 )
    {
LABEL_16:
      v12 += 3;
      if ( v12 != (int *)v3 )
        continue;
      v145 = 0;
    }
    break;
  }
  v18 = v139;
  v19 = v145;
  v20 = (int *)v137;
  v148 = v9;
  v21 = 0LL;
  v140 = 0;
  v22 = 18;
  v23 = v18 + 1;
  do
  {
    v24 = *v20;
    v25 = 618;
    v26 = -1;
    do
    {
      while ( 1 )
      {
        if ( v25 - v26 <= 1 )
        {
          LOBYTE(v28) = 18;
LABEL_24:
          v13[v21] = v19;
          if ( v22 != 18 )
            LOBYTE(v28) = v22;
          goto LABEL_26;
        }
        v27 = (_DWORD *)((char *)&unk_E4860 + 12 * ((v25 + v26) / 2));
        if ( v24 >= *v27 )
          break;
        v25 = (v25 + v26) / 2;
      }
      v26 = (v25 + v26) / 2;
    }
    while ( v24 > v27[1] );
    v28 = v27[2];
    switch ( (unsigned __int8)v27[2] )
    {
      case 1u:
        v19 = (v19 + 2) & 0xFFFFFFFE;
        v42 = v19;
        if ( v22 != 18 )
        {
          v42 = v19 | 0x40;
          if ( v22 != 3 )
          {
            v42 = v19 | 0x80;
            if ( v22 )
              v42 = v19;
          }
        }
        v13[v21] = v42;
        v22 = 18;
        goto LABEL_26;
      case 2u:
        v140 = 1;
        LOBYTE(v28) = 0;
        v19 = (v19 + 2) & 0xFFFFFFFE;
        v22 = 0;
        v13[v21] = v19;
        goto LABEL_26;
      case 5u:
        v39 = v19 + 1;
        v19 = (v19 + 1) | 1;
        v40 = v19;
        if ( v22 != 18 )
        {
          if ( v22 == 3 )
          {
            v40 = v39 | 0x41;
          }
          else
          {
            v41 = v39 | 0x81;
            if ( v22 )
              v41 = v19;
            v40 = v41;
          }
        }
        v13[v21] = v40;
        v22 = 18;
        goto LABEL_26;
      case 6u:
        v140 = 1;
        LOBYTE(v28) = 3;
        v19 = (v19 + 1) | 1;
        v22 = 3;
        v13[v21] = v19;
        goto LABEL_26;
      case 7u:
        if ( !(_DWORD)v21 )
          goto LABEL_61;
        v38 = (signed __int64)&v13[v21 - 2];
        break;
      case 0x10u:
      case 0x11u:
        v13[v21] = v19;
        LOBYTE(v28) = v22;
        goto LABEL_26;
      default:
        goto LABEL_24;
    }
    do
    {
      if ( (_BYTE *)v38 == &v13[v21 - 2 - (unsigned int)(v21 - 1)] )
      {
LABEL_61:
        v19 = v145;
        v22 = 18;
        goto LABEL_62;
      }
      --v38;
    }
    while ( v13[v21 - 1] == *(_BYTE *)(v38 + 1) );
    v134 = v19;
    v19 &= 0x3Fu;
    v22 = v134 & 0xC0;
LABEL_62:
    v13[v21] = v19;
LABEL_26:
    v11[v21++] = v28;
    v20 += 3;
  }
  while ( v21 != v23 );
  v29 = v148;
  if ( v140 )
  {
    v30 = v13;
    do
      *v30++ &= 0x3Fu;
    while ( v30 != &v13[v21] );
  }
  v31 = &v11[v21];
  v32 = v11;
  do
  {
    if ( (unsigned __int8)*v32 <= 7u && (1LL << *v32) & 0xE6 )
      *v32 = 14;
    ++v32;
  }
  while ( v32 != v31 );
  if ( *v11 == 13 )
    *v11 = v145;
  if ( v148 != 1 )
  {
    v33 = v11 + 1;
    do
    {
      if ( *v33 == 13 )
        *v33 = *(v33 - 1);
      ++v33;
    }
    while ( v33 != &v11[v148 - 2 + 2] );
  }
  v34 = v11;
  do
  {
    v35 = *v34;
    if ( *v34 == 8 )
    {
      v36 = (signed __int64)(v34 - 1);
      while ( v35 != 3 && v35 && (char *)v36 != v11 - 1 )
      {
        v35 = *(_BYTE *)(--v36 + 1);
        if ( v35 == 4 )
        {
          *v34 = 11;
          break;
        }
      }
    }
    ++v34;
  }
  while ( v34 != v32 );
  v43 = v11;
  do
  {
    if ( *v43 == 4 )
      *v43 = 3;
    ++v43;
  }
  while ( v43 != v34 );
  if ( v143 > 1 )
  {
    v44 = v11;
    do
    {
      v45 = v44[1];
      if ( v45 == 9 )
      {
        if ( *v44 == 8 )
          goto LABEL_86;
      }
      else if ( v45 == 12 )
      {
        if ( *v44 != 8 )
        {
          if ( *v44 == 11 && v44[2] == 11 )
            v44[1] = 11;
          goto LABEL_83;
        }
LABEL_86:
        if ( v44[2] == 8 )
          v44[1] = 8;
        goto LABEL_83;
      }
LABEL_83:
      ++v44;
    }
    while ( v44 != &v11[v148 - 3 + 1] );
  }
  v46 = 0LL;
  do
  {
    while ( 1 )
    {
      if ( v11[v46] == 10 )
      {
        if ( v46 && v11[v46 - 1] == 8 )
          break;
        if ( v143 > (signed int)v46 )
        {
          v47 = v11[v46 + 1];
          if ( v47 == 8 )
            break;
          if ( v47 == 10 )
          {
            v48 = &v11[v46 + 1];
            do
            {
              v49 = *v48;
              if ( v48 == &v11[v46 + 1 + (unsigned int)(v148 - 2 - v46)] )
                break;
              ++v48;
            }
            while ( v49 == 10 );
            if ( v49 == 8 )
              break;
          }
        }
      }
      if ( v148 <= (signed int)++v46 )
        goto LABEL_105;
    }
    v11[v46++] = 8;
  }
  while ( v148 > (signed int)v46 );
LABEL_105:
  v50 = 0LL;
  do
  {
    v51 = v11[v50];
    if ( v51 <= 0xCu )
    {
      v52 = 1LL << v51;
      if ( v52 & 0x1600 )
        v11[v50] = 18;
    }
    ++v50;
  }
  while ( v148 > (signed int)v50 );
  v53 = 0LL;
  v54 = (signed __int64)(v11 - 1);
  do
  {
    v55 = v11[v53];
    if ( v55 == 8 )
    {
      v56 = v54 + v53;
      while ( (unsigned __int8)(v55 - 3) > 1u && v54 != v56 )
      {
        v55 = *(_BYTE *)(--v56 + 1);
        if ( !v55 )
        {
          v11[v53] = 0;
          break;
        }
      }
    }
    ++v53;
  }
  while ( v148 > (signed int)v53 );
  if ( v148 == 1 )
  {
    if ( v143 <= 1 )
      goto LABEL_140;
  }
  else
  {
    if ( *v11 == 18 )
    {
      v136 = v11[1];
      if ( (v11[1] & 0xF7) == 3 || v136 == 8 )
      {
        *v11 = 3;
      }
      else if ( !v136 )
      {
        *v11 = 0;
      }
    }
    if ( v143 <= 1 )
    {
LABEL_139:
      v66 = &v11[v146 - 1];
      if ( *v66 == 18 )
      {
        v135 = v11[v146 - 2];
        if ( (v11[v146 - 2] & 0xF7) == 3 || v135 == 8 )
        {
          *v66 = 3;
        }
        else if ( !v135 )
        {
          *v66 = 0;
        }
      }
      goto LABEL_140;
    }
  }
  v57 = v148 - 2;
  v58 = 1;
  v149 = (signed __int64)(v11 + 1);
  do
  {
    v59 = v58 + 1;
    v60 = &v11[v58];
    if ( *v60 != 18 )
      goto LABEL_122;
    v61 = v11[v58 - 1];
    if ( v61 )
    {
      if ( (v61 & 0xF7) == 3 || v61 == 8 )
      {
        v59 = v58 + 1;
        if ( v143 > v58 )
        {
          for ( i = v59; ; ++i )
          {
            v63 = i;
            v64 = v11[i];
            if ( v59 + (unsigned __int64)(unsigned int)(v57 - v58) == i || v64 != 18 )
              break;
          }
          if ( ((v64 & 0xF7) == 3 || v64 == 8) && (signed int)i > v58 )
          {
            v65 = (char *)(v149 + v58 + (unsigned int)(i + ~v58));
            do
              *v60++ = 3;
            while ( v65 != v60 );
LABEL_137:
            v59 = v63 + 1;
            goto LABEL_122;
          }
        }
      }
    }
    else if ( v143 > v58 )
    {
      for ( j = v59; ; ++j )
      {
        v63 = j;
        v132 = v11[j];
        if ( v59 + (unsigned __int64)(unsigned int)(v57 - v58) == j || v132 != 18 )
          break;
      }
      if ( !v132 && (signed int)j > v58 )
      {
        v133 = (char *)(v149 + v58 + (unsigned int)(j + ~v58));
        do
          *v60++ = 0;
        while ( v133 != v60 );
        goto LABEL_137;
      }
    }
LABEL_122:
    v58 = v59;
  }
  while ( v59 < v143 );
  if ( v29 != 1 )
    goto LABEL_139;
LABEL_140:
  v67 = 0LL;
  do
  {
    if ( v11[v67] == 18 )
      v11[v67] = -(v13[v67] & 1) & 3;
    ++v67;
  }
  while ( v29 > (signed int)v67 );
  v68 = 0LL;
  while ( 2 )
  {
    while ( 2 )
    {
      v69 = v13[v68];
      if ( v69 & 1 )
      {
LABEL_147:
        if ( v29 <= (signed int)++v68 )
          goto LABEL_151;
        continue;
      }
      break;
    }
    v70 = v11[v68];
    if ( v70 != 3 )
    {
      if ( v70 == 11 || v70 == 8 )
        v13[v68] = v69 + 2;
      goto LABEL_147;
    }
    v13[v68++] = v69 + 1;
    if ( v29 > (signed int)v68 )
      continue;
    break;
  }
LABEL_151:
  v71 = 0LL;
  do
  {
    v72 = v13[v71];
    if ( v72 & 1 )
    {
      v73 = v11[v71];
      if ( !(v73 & 0xF7) || v73 == 11 )
        v13[v71] = v72 + 1;
    }
    ++v71;
  }
  while ( v29 > (signed int)v71 );
  v74 = v143;
  if ( v143 )
  {
    v75 = (int *)(v10 + 12LL * v143 + 4);
    while ( 2 )
    {
      v76 = *v75;
      v77 = 618;
      v78 = -1;
      do
      {
        while ( 1 )
        {
          if ( v77 - v78 <= 1 )
            goto LABEL_163;
          v79 = (char *)&unk_E4860 + 12 * ((v77 + v78) / 2);
          if ( v76 >= *(_DWORD *)v79 )
            break;
          v77 = (v77 + v78) / 2;
        }
        v78 = (v77 + v78) / 2;
      }
      while ( v76 > *((_DWORD *)v79 + 1) );
      if ( v79[8] != 17 )
      {
LABEL_163:
        if ( v74 >= v143 )
          goto LABEL_164;
        break;
      }
      v75 -= 3;
      if ( --v74 )
        continue;
      break;
    }
    v91 = v74 + 1;
    if ( v29 > v74 + 1 )
    {
      v92 = &v13[v91];
      do
        *v92++ = v145;
      while ( v92 != &v13[v91 + 1 + v29 - 2 - v74] );
    }
  }
LABEL_164:
  v80 = (int *)v137;
  v81 = 0LL;
  v147 = v11;
  do
  {
    v82 = *v80;
    v83 = 618;
    v84 = -1;
    while ( v83 - v84 > 1 )
    {
      v85 = (_DWORD *)((char *)&unk_E4860 + 12 * ((v83 + v84) / 2));
      if ( v82 >= *v85 )
      {
        v84 = (v83 + v84) / 2;
        if ( v82 <= v85[1] )
        {
          v93 = v85[2];
          if ( (_BYTE)v93 == 17 )
          {
            if ( v29 <= (signed int)v81 )
            {
              v95 = v81;
            }
            else
            {
              v94 = (int *)(v142 + 12 * v81);
              v95 = v81;
LABEL_193:
              v96 = 618;
              v97 = -1;
              while ( v96 - v97 > 1 )
              {
                v98 = (char *)&unk_E4860 + 12 * ((v96 + v97) / 2);
                if ( v82 >= *(_DWORD *)v98 )
                {
                  v97 = (v96 + v97) / 2;
                  if ( v82 <= *((_DWORD *)v98 + 1) )
                  {
                    if ( v98[8] != 17 )
                      break;
                    if ( v29 != ++v95 )
                    {
                      v82 = *v94;
                      v94 += 3;
                      goto LABEL_193;
                    }
                    v95 = v29;
                    goto LABEL_259;
                  }
                }
                else
                {
                  v96 = (v96 + v97) / 2;
                }
              }
            }
            if ( v29 == v95 )
            {
LABEL_259:
              v128 = v95 - 1;
              if ( v95 - 1 >= (signed int)v81 )
              {
                v129 = &v13[v128];
                v130 = (signed __int64)&v13[v128 - 1 - (v95 + ~(_DWORD)v81)];
                do
                  *v129-- = v145;
                while ( (unsigned __int8 *)v130 != v129 );
              }
            }
            else
            {
              v99 = 618;
              v100 = -1;
              v101 = *(_DWORD *)(v10 + 12LL * v95 + 4);
              while ( v99 - v100 > 1 )
              {
                v102 = (char *)&unk_E4860 + 12 * ((v99 + v100) / 2);
                if ( v101 >= *(_DWORD *)v102 )
                {
                  v100 = (v99 + v100) / 2;
                  if ( v101 <= *((_DWORD *)v102 + 1) )
                  {
                    if ( v102[8] == 15 )
                      goto LABEL_259;
                    break;
                  }
                }
                else
                {
                  v99 = (v99 + v100) / 2;
                }
              }
              v103 = 618;
              v104 = -1;
              while ( v103 - v104 > 1 )
              {
                v105 = (char *)&unk_E4860 + 12 * ((v103 + v104) / 2);
                if ( v101 >= *(_DWORD *)v105 )
                {
                  v104 = (v103 + v104) / 2;
                  if ( v101 <= *((_DWORD *)v105 + 1) )
                  {
                    if ( v105[8] == 16 )
                      goto LABEL_259;
                    goto LABEL_169;
                  }
                }
                else
                {
                  v103 = (v103 + v104) / 2;
                }
              }
            }
          }
          else if ( (unsigned __int8)(v93 - 15) <= 1u )
          {
            v13[v81] = v145;
          }
          break;
        }
      }
      else
      {
        v83 = (v83 + v84) / 2;
      }
    }
LABEL_169:
    ++v81;
    v80 += 3;
  }
  while ( v29 > (signed int)v81 );
  v86 = v147;
  v87 = 0LL;
  do
  {
    if ( v13[v87] & 1 )
    {
      v88 = 12 * v87;
      v89 = *(_DWORD *)(v10 + 12 * v87 + 4);
      v90 = *(_DWORD *)(v10 + 12 * v87 + 4) & 0xFF00;
      if ( v90 )
      {
        switch ( v90 )
        {
          case 8192:
            if ( v89 == 8262 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 8261;
            }
            else if ( v89 <= 0x2046 )
            {
              switch ( v89 )
              {
                case 0x203Au:
                  *(_DWORD *)(v10 + v88 + 4) = 8249;
                  break;
                case 0x2045u:
                  *(_DWORD *)(v10 + v88 + 4) = 8262;
                  break;
                case 0x2039u:
                  *(_DWORD *)(v10 + v88 + 4) = 8250;
                  break;
              }
            }
            else if ( v89 == 8318 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 8317;
            }
            else if ( v89 <= 0x207E )
            {
              if ( v89 == 8317 )
                *(_DWORD *)(v10 + v88 + 4) = 8318;
            }
            else if ( v89 == 8333 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 8334;
            }
            else if ( v89 == 8334 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 8333;
            }
            break;
          case 8704:
            switch ( v89 )
            {
              case 0x2208u:
                *(_DWORD *)(v10 + v88 + 4) = 8715;
                break;
              case 0x2209u:
                *(_DWORD *)(v10 + v88 + 4) = 8716;
                break;
              case 0x220Au:
                *(_DWORD *)(v10 + v88 + 4) = 8717;
                break;
              case 0x220Bu:
                *(_DWORD *)(v10 + v88 + 4) = 8712;
                break;
              case 0x220Cu:
                *(_DWORD *)(v10 + v88 + 4) = 8713;
                break;
              case 0x220Du:
                *(_DWORD *)(v10 + v88 + 4) = 8714;
                break;
              case 0x2215u:
                *(_DWORD *)(v10 + v88 + 4) = 10741;
                break;
              case 0x223Cu:
                *(_DWORD *)(v10 + v88 + 4) = 8765;
                break;
              case 0x223Du:
                *(_DWORD *)(v10 + v88 + 4) = 8764;
                break;
              case 0x2243u:
                *(_DWORD *)(v10 + v88 + 4) = 8909;
                break;
              case 0x2252u:
                *(_DWORD *)(v10 + v88 + 4) = 8787;
                break;
              case 0x2253u:
                *(_DWORD *)(v10 + v88 + 4) = 8786;
                break;
              case 0x2254u:
                *(_DWORD *)(v10 + v88 + 4) = 8789;
                break;
              case 0x2255u:
                *(_DWORD *)(v10 + v88 + 4) = 8788;
                break;
              case 0x2264u:
                *(_DWORD *)(v10 + v88 + 4) = 8805;
                break;
              case 0x2265u:
                *(_DWORD *)(v10 + v88 + 4) = 8804;
                break;
              case 0x2266u:
                *(_DWORD *)(v10 + v88 + 4) = 8807;
                break;
              case 0x2267u:
                *(_DWORD *)(v10 + v88 + 4) = 8806;
                break;
              case 0x2268u:
                *(_DWORD *)(v10 + v88 + 4) = 8809;
                break;
              case 0x2269u:
                *(_DWORD *)(v10 + v88 + 4) = 8808;
                break;
              case 0x226Au:
                *(_DWORD *)(v10 + v88 + 4) = 8811;
                break;
              case 0x226Bu:
                *(_DWORD *)(v10 + v88 + 4) = 8810;
                break;
              case 0x226Eu:
                *(_DWORD *)(v10 + v88 + 4) = 8815;
                break;
              case 0x226Fu:
                *(_DWORD *)(v10 + v88 + 4) = 8814;
                break;
              case 0x2270u:
                *(_DWORD *)(v10 + v88 + 4) = 8817;
                break;
              case 0x2271u:
                *(_DWORD *)(v10 + v88 + 4) = 8816;
                break;
              case 0x2272u:
                *(_DWORD *)(v10 + v88 + 4) = 8819;
                break;
              case 0x2273u:
                *(_DWORD *)(v10 + v88 + 4) = 8818;
                break;
              case 0x2274u:
                *(_DWORD *)(v10 + v88 + 4) = 8821;
                break;
              case 0x2275u:
                *(_DWORD *)(v10 + v88 + 4) = 8820;
                break;
              case 0x2276u:
                *(_DWORD *)(v10 + v88 + 4) = 8823;
                break;
              case 0x2277u:
                *(_DWORD *)(v10 + v88 + 4) = 8822;
                break;
              case 0x2278u:
                *(_DWORD *)(v10 + v88 + 4) = 8825;
                break;
              case 0x2279u:
                *(_DWORD *)(v10 + v88 + 4) = 8824;
                break;
              case 0x227Au:
                *(_DWORD *)(v10 + v88 + 4) = 8827;
                break;
              case 0x227Bu:
                *(_DWORD *)(v10 + v88 + 4) = 8826;
                break;
              case 0x227Cu:
                *(_DWORD *)(v10 + v88 + 4) = 8829;
                break;
              case 0x227Du:
                *(_DWORD *)(v10 + v88 + 4) = 8828;
                break;
              case 0x227Eu:
                *(_DWORD *)(v10 + v88 + 4) = 8831;
                break;
              case 0x227Fu:
                *(_DWORD *)(v10 + v88 + 4) = 8830;
                break;
              case 0x2280u:
                *(_DWORD *)(v10 + v88 + 4) = 8833;
                break;
              case 0x2281u:
                *(_DWORD *)(v10 + v88 + 4) = 8832;
                break;
              case 0x2282u:
                *(_DWORD *)(v10 + v88 + 4) = 8835;
                break;
              case 0x2283u:
                *(_DWORD *)(v10 + v88 + 4) = 8834;
                break;
              case 0x2284u:
                *(_DWORD *)(v10 + v88 + 4) = 8837;
                break;
              case 0x2285u:
                *(_DWORD *)(v10 + v88 + 4) = 8836;
                break;
              case 0x2286u:
                *(_DWORD *)(v10 + v88 + 4) = 8839;
                break;
              case 0x2287u:
                *(_DWORD *)(v10 + v88 + 4) = 8838;
                break;
              case 0x2288u:
                *(_DWORD *)(v10 + v88 + 4) = 8841;
                break;
              case 0x2289u:
                *(_DWORD *)(v10 + v88 + 4) = 8840;
                break;
              case 0x228Au:
                *(_DWORD *)(v10 + v88 + 4) = 8843;
                break;
              case 0x228Bu:
                *(_DWORD *)(v10 + v88 + 4) = 8842;
                break;
              case 0x228Fu:
                *(_DWORD *)(v10 + v88 + 4) = 8848;
                break;
              case 0x2290u:
                *(_DWORD *)(v10 + v88 + 4) = 8847;
                break;
              case 0x2291u:
                *(_DWORD *)(v10 + v88 + 4) = 8850;
                break;
              case 0x2292u:
                *(_DWORD *)(v10 + v88 + 4) = 8849;
                break;
              case 0x2298u:
                *(_DWORD *)(v10 + v88 + 4) = 10680;
                break;
              case 0x22A2u:
                *(_DWORD *)(v10 + v88 + 4) = 8867;
                break;
              case 0x22A3u:
                *(_DWORD *)(v10 + v88 + 4) = 8866;
                break;
              case 0x22A6u:
                *(_DWORD *)(v10 + v88 + 4) = 10974;
                break;
              case 0x22A8u:
                *(_DWORD *)(v10 + v88 + 4) = 10980;
                break;
              case 0x22A9u:
                *(_DWORD *)(v10 + v88 + 4) = 10979;
                break;
              case 0x22ABu:
                *(_DWORD *)(v10 + v88 + 4) = 10981;
                break;
              case 0x22B0u:
                *(_DWORD *)(v10 + v88 + 4) = 8881;
                break;
              case 0x22B1u:
                *(_DWORD *)(v10 + v88 + 4) = 8880;
                break;
              case 0x22B2u:
                *(_DWORD *)(v10 + v88 + 4) = 8883;
                break;
              case 0x22B3u:
                *(_DWORD *)(v10 + v88 + 4) = 8882;
                break;
              case 0x22B4u:
                *(_DWORD *)(v10 + v88 + 4) = 8885;
                break;
              case 0x22B5u:
                *(_DWORD *)(v10 + v88 + 4) = 8884;
                break;
              case 0x22B6u:
                *(_DWORD *)(v10 + v88 + 4) = 8887;
                break;
              case 0x22B7u:
                *(_DWORD *)(v10 + v88 + 4) = 8886;
                break;
              case 0x22C9u:
                *(_DWORD *)(v10 + v88 + 4) = 8906;
                break;
              case 0x22CAu:
                *(_DWORD *)(v10 + v88 + 4) = 8905;
                break;
              case 0x22CBu:
                *(_DWORD *)(v10 + v88 + 4) = 8908;
                break;
              case 0x22CCu:
                *(_DWORD *)(v10 + v88 + 4) = 8907;
                break;
              case 0x22CDu:
                *(_DWORD *)(v10 + v88 + 4) = 8771;
                break;
              case 0x22D0u:
                *(_DWORD *)(v10 + v88 + 4) = 8913;
                break;
              case 0x22D1u:
                *(_DWORD *)(v10 + v88 + 4) = 8912;
                break;
              case 0x22D6u:
                *(_DWORD *)(v10 + v88 + 4) = 8919;
                break;
              case 0x22D7u:
                *(_DWORD *)(v10 + v88 + 4) = 8918;
                break;
              case 0x22D8u:
                *(_DWORD *)(v10 + v88 + 4) = 8921;
                break;
              case 0x22D9u:
                *(_DWORD *)(v10 + v88 + 4) = 8920;
                break;
              case 0x22DAu:
                *(_DWORD *)(v10 + v88 + 4) = 8923;
                break;
              case 0x22DBu:
                *(_DWORD *)(v10 + v88 + 4) = 8922;
                break;
              case 0x22DCu:
                *(_DWORD *)(v10 + v88 + 4) = 8925;
                break;
              case 0x22DDu:
                *(_DWORD *)(v10 + v88 + 4) = 8924;
                break;
              case 0x22DEu:
                *(_DWORD *)(v10 + v88 + 4) = 8927;
                break;
              case 0x22DFu:
                *(_DWORD *)(v10 + v88 + 4) = 8926;
                break;
              case 0x22E0u:
                *(_DWORD *)(v10 + v88 + 4) = 8929;
                break;
              case 0x22E1u:
                *(_DWORD *)(v10 + v88 + 4) = 8928;
                break;
              case 0x22E2u:
                *(_DWORD *)(v10 + v88 + 4) = 8931;
                break;
              case 0x22E3u:
                *(_DWORD *)(v10 + v88 + 4) = 8930;
                break;
              case 0x22E4u:
                *(_DWORD *)(v10 + v88 + 4) = 8933;
                break;
              case 0x22E5u:
                *(_DWORD *)(v10 + v88 + 4) = 8932;
                break;
              case 0x22E6u:
                *(_DWORD *)(v10 + v88 + 4) = 8935;
                break;
              case 0x22E7u:
                *(_DWORD *)(v10 + v88 + 4) = 8934;
                break;
              case 0x22E8u:
                *(_DWORD *)(v10 + v88 + 4) = 8937;
                break;
              case 0x22E9u:
                *(_DWORD *)(v10 + v88 + 4) = 8936;
                break;
              case 0x22EAu:
                *(_DWORD *)(v10 + v88 + 4) = 8939;
                break;
              case 0x22EBu:
                *(_DWORD *)(v10 + v88 + 4) = 8938;
                break;
              case 0x22ECu:
                *(_DWORD *)(v10 + v88 + 4) = 8941;
                break;
              case 0x22EDu:
                *(_DWORD *)(v10 + v88 + 4) = 8940;
                break;
              case 0x22F0u:
                *(_DWORD *)(v10 + v88 + 4) = 8945;
                break;
              case 0x22F1u:
                *(_DWORD *)(v10 + v88 + 4) = 8944;
                break;
              case 0x22F2u:
                *(_DWORD *)(v10 + v88 + 4) = 8954;
                break;
              case 0x22F3u:
                *(_DWORD *)(v10 + v88 + 4) = 8955;
                break;
              case 0x22F4u:
                *(_DWORD *)(v10 + v88 + 4) = 8956;
                break;
              case 0x22F6u:
                *(_DWORD *)(v10 + v88 + 4) = 8957;
                break;
              case 0x22F7u:
                *(_DWORD *)(v10 + v88 + 4) = 8958;
                break;
              case 0x22FAu:
                *(_DWORD *)(v10 + v88 + 4) = 8946;
                break;
              case 0x22FBu:
                *(_DWORD *)(v10 + v88 + 4) = 8947;
                break;
              case 0x22FCu:
                *(_DWORD *)(v10 + v88 + 4) = 8948;
                break;
              case 0x22FDu:
                *(_DWORD *)(v10 + v88 + 4) = 8950;
                break;
              case 0x22FEu:
                *(_DWORD *)(v10 + v88 + 4) = 8951;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 8960:
            switch ( v89 )
            {
              case 0x2308u:
                *(_DWORD *)(v10 + v88 + 4) = 8969;
                break;
              case 0x2309u:
                *(_DWORD *)(v10 + v88 + 4) = 8968;
                break;
              case 0x230Au:
                *(_DWORD *)(v10 + v88 + 4) = 8971;
                break;
              case 0x230Bu:
                *(_DWORD *)(v10 + v88 + 4) = 8970;
                break;
              case 0x2329u:
                *(_DWORD *)(v10 + v88 + 4) = 9002;
                break;
              case 0x232Au:
                *(_DWORD *)(v10 + v88 + 4) = 9001;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 9984:
            switch ( v89 )
            {
              case 0x2768u:
                *(_DWORD *)(v10 + v88 + 4) = 10089;
                break;
              case 0x2769u:
                *(_DWORD *)(v10 + v88 + 4) = 10088;
                break;
              case 0x276Au:
                *(_DWORD *)(v10 + v88 + 4) = 10091;
                break;
              case 0x276Bu:
                *(_DWORD *)(v10 + v88 + 4) = 10090;
                break;
              case 0x276Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10093;
                break;
              case 0x276Du:
                *(_DWORD *)(v10 + v88 + 4) = 10092;
                break;
              case 0x276Eu:
                *(_DWORD *)(v10 + v88 + 4) = 10095;
                break;
              case 0x276Fu:
                *(_DWORD *)(v10 + v88 + 4) = 10094;
                break;
              case 0x2770u:
                *(_DWORD *)(v10 + v88 + 4) = 10097;
                break;
              case 0x2771u:
                *(_DWORD *)(v10 + v88 + 4) = 10096;
                break;
              case 0x2772u:
                *(_DWORD *)(v10 + v88 + 4) = 10099;
                break;
              case 0x2773u:
                *(_DWORD *)(v10 + v88 + 4) = 10098;
                break;
              case 0x2774u:
                *(_DWORD *)(v10 + v88 + 4) = 10101;
                break;
              case 0x2775u:
                *(_DWORD *)(v10 + v88 + 4) = 10100;
                break;
              case 0x27D5u:
                *(_DWORD *)(v10 + v88 + 4) = 10198;
                break;
              case 0x27D6u:
                *(_DWORD *)(v10 + v88 + 4) = 10197;
                break;
              case 0x27DDu:
                *(_DWORD *)(v10 + v88 + 4) = 10206;
                break;
              case 0x27DEu:
                *(_DWORD *)(v10 + v88 + 4) = 10205;
                break;
              case 0x27E2u:
                *(_DWORD *)(v10 + v88 + 4) = 10211;
                break;
              case 0x27E3u:
                *(_DWORD *)(v10 + v88 + 4) = 10210;
                break;
              case 0x27E4u:
                *(_DWORD *)(v10 + v88 + 4) = 10213;
                break;
              case 0x27E5u:
                *(_DWORD *)(v10 + v88 + 4) = 10212;
                break;
              case 0x27E6u:
                *(_DWORD *)(v10 + v88 + 4) = 10215;
                break;
              case 0x27E7u:
                *(_DWORD *)(v10 + v88 + 4) = 10214;
                break;
              case 0x27E8u:
                *(_DWORD *)(v10 + v88 + 4) = 10217;
                break;
              case 0x27E9u:
                *(_DWORD *)(v10 + v88 + 4) = 10216;
                break;
              case 0x27EAu:
                *(_DWORD *)(v10 + v88 + 4) = 10219;
                break;
              case 0x27EBu:
                *(_DWORD *)(v10 + v88 + 4) = 10218;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 10496:
            switch ( v89 )
            {
              case 0x2983u:
                *(_DWORD *)(v10 + v88 + 4) = 10628;
                break;
              case 0x2984u:
                *(_DWORD *)(v10 + v88 + 4) = 10627;
                break;
              case 0x2985u:
                *(_DWORD *)(v10 + v88 + 4) = 10630;
                break;
              case 0x2986u:
                *(_DWORD *)(v10 + v88 + 4) = 10629;
                break;
              case 0x2987u:
                *(_DWORD *)(v10 + v88 + 4) = 10632;
                break;
              case 0x2988u:
                *(_DWORD *)(v10 + v88 + 4) = 10631;
                break;
              case 0x2989u:
                *(_DWORD *)(v10 + v88 + 4) = 10634;
                break;
              case 0x298Au:
                *(_DWORD *)(v10 + v88 + 4) = 10633;
                break;
              case 0x298Bu:
                *(_DWORD *)(v10 + v88 + 4) = 10636;
                break;
              case 0x298Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10635;
                break;
              case 0x298Du:
                *(_DWORD *)(v10 + v88 + 4) = 10640;
                break;
              case 0x298Eu:
                *(_DWORD *)(v10 + v88 + 4) = 10639;
                break;
              case 0x298Fu:
                *(_DWORD *)(v10 + v88 + 4) = 10638;
                break;
              case 0x2990u:
                *(_DWORD *)(v10 + v88 + 4) = 10637;
                break;
              case 0x2991u:
                *(_DWORD *)(v10 + v88 + 4) = 10642;
                break;
              case 0x2992u:
                *(_DWORD *)(v10 + v88 + 4) = 10641;
                break;
              case 0x2993u:
                *(_DWORD *)(v10 + v88 + 4) = 10644;
                break;
              case 0x2994u:
                *(_DWORD *)(v10 + v88 + 4) = 10643;
                break;
              case 0x2995u:
                *(_DWORD *)(v10 + v88 + 4) = 10646;
                break;
              case 0x2996u:
                *(_DWORD *)(v10 + v88 + 4) = 10645;
                break;
              case 0x2997u:
                *(_DWORD *)(v10 + v88 + 4) = 10648;
                break;
              case 0x2998u:
                *(_DWORD *)(v10 + v88 + 4) = 10647;
                break;
              case 0x29B8u:
                *(_DWORD *)(v10 + v88 + 4) = 8856;
                break;
              case 0x29C0u:
                *(_DWORD *)(v10 + v88 + 4) = 10689;
                break;
              case 0x29C1u:
                *(_DWORD *)(v10 + v88 + 4) = 10688;
                break;
              case 0x29C4u:
                *(_DWORD *)(v10 + v88 + 4) = 10693;
                break;
              case 0x29C5u:
                *(_DWORD *)(v10 + v88 + 4) = 10692;
                break;
              case 0x29CFu:
                *(_DWORD *)(v10 + v88 + 4) = 10704;
                break;
              case 0x29D0u:
                *(_DWORD *)(v10 + v88 + 4) = 10703;
                break;
              case 0x29D1u:
                *(_DWORD *)(v10 + v88 + 4) = 10706;
                break;
              case 0x29D2u:
                *(_DWORD *)(v10 + v88 + 4) = 10705;
                break;
              case 0x29D4u:
                *(_DWORD *)(v10 + v88 + 4) = 10709;
                break;
              case 0x29D5u:
                *(_DWORD *)(v10 + v88 + 4) = 10708;
                break;
              case 0x29D8u:
                *(_DWORD *)(v10 + v88 + 4) = 10713;
                break;
              case 0x29D9u:
                *(_DWORD *)(v10 + v88 + 4) = 10712;
                break;
              case 0x29DAu:
                *(_DWORD *)(v10 + v88 + 4) = 10715;
                break;
              case 0x29DBu:
                *(_DWORD *)(v10 + v88 + 4) = 10714;
                break;
              case 0x29F5u:
                *(_DWORD *)(v10 + v88 + 4) = 8725;
                break;
              case 0x29F8u:
                *(_DWORD *)(v10 + v88 + 4) = 10745;
                break;
              case 0x29F9u:
                *(_DWORD *)(v10 + v88 + 4) = 10744;
                break;
              case 0x29FCu:
                *(_DWORD *)(v10 + v88 + 4) = 10749;
                break;
              case 0x29FDu:
                *(_DWORD *)(v10 + v88 + 4) = 10748;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 10752:
            switch ( v89 )
            {
              case 0x2A2Bu:
                *(_DWORD *)(v10 + v88 + 4) = 10796;
                break;
              case 0x2A2Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10795;
                break;
              case 0x2A2Du:
                *(_DWORD *)(v10 + v88 + 4) = 10796;
                break;
              case 0x2A2Eu:
                *(_DWORD *)(v10 + v88 + 4) = 10797;
                break;
              case 0x2A34u:
                *(_DWORD *)(v10 + v88 + 4) = 10805;
                break;
              case 0x2A35u:
                *(_DWORD *)(v10 + v88 + 4) = 10804;
                break;
              case 0x2A3Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10813;
                break;
              case 0x2A3Du:
                *(_DWORD *)(v10 + v88 + 4) = 10812;
                break;
              case 0x2A64u:
                *(_DWORD *)(v10 + v88 + 4) = 10853;
                break;
              case 0x2A65u:
                *(_DWORD *)(v10 + v88 + 4) = 10852;
                break;
              case 0x2A79u:
                *(_DWORD *)(v10 + v88 + 4) = 10874;
                break;
              case 0x2A7Au:
                *(_DWORD *)(v10 + v88 + 4) = 10873;
                break;
              case 0x2A7Du:
                *(_DWORD *)(v10 + v88 + 4) = 10878;
                break;
              case 0x2A7Eu:
                *(_DWORD *)(v10 + v88 + 4) = 10877;
                break;
              case 0x2A7Fu:
                *(_DWORD *)(v10 + v88 + 4) = 10880;
                break;
              case 0x2A80u:
                *(_DWORD *)(v10 + v88 + 4) = 10879;
                break;
              case 0x2A81u:
                *(_DWORD *)(v10 + v88 + 4) = 10882;
                break;
              case 0x2A82u:
                *(_DWORD *)(v10 + v88 + 4) = 10881;
                break;
              case 0x2A83u:
                *(_DWORD *)(v10 + v88 + 4) = 10884;
                break;
              case 0x2A84u:
                *(_DWORD *)(v10 + v88 + 4) = 10883;
                break;
              case 0x2A8Bu:
                *(_DWORD *)(v10 + v88 + 4) = 10892;
                break;
              case 0x2A8Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10891;
                break;
              case 0x2A91u:
                *(_DWORD *)(v10 + v88 + 4) = 10898;
                break;
              case 0x2A92u:
                *(_DWORD *)(v10 + v88 + 4) = 10897;
                break;
              case 0x2A93u:
                *(_DWORD *)(v10 + v88 + 4) = 10900;
                break;
              case 0x2A94u:
                *(_DWORD *)(v10 + v88 + 4) = 10899;
                break;
              case 0x2A95u:
                *(_DWORD *)(v10 + v88 + 4) = 10902;
                break;
              case 0x2A96u:
                *(_DWORD *)(v10 + v88 + 4) = 10901;
                break;
              case 0x2A97u:
                *(_DWORD *)(v10 + v88 + 4) = 10904;
                break;
              case 0x2A98u:
                *(_DWORD *)(v10 + v88 + 4) = 10903;
                break;
              case 0x2A99u:
                *(_DWORD *)(v10 + v88 + 4) = 10906;
                break;
              case 0x2A9Au:
                *(_DWORD *)(v10 + v88 + 4) = 10905;
                break;
              case 0x2A9Bu:
                *(_DWORD *)(v10 + v88 + 4) = 10908;
                break;
              case 0x2A9Cu:
                *(_DWORD *)(v10 + v88 + 4) = 10907;
                break;
              case 0x2AA1u:
                *(_DWORD *)(v10 + v88 + 4) = 10914;
                break;
              case 0x2AA2u:
                *(_DWORD *)(v10 + v88 + 4) = 10913;
                break;
              case 0x2AA6u:
                *(_DWORD *)(v10 + v88 + 4) = 10919;
                break;
              case 0x2AA7u:
                *(_DWORD *)(v10 + v88 + 4) = 10918;
                break;
              case 0x2AA8u:
                *(_DWORD *)(v10 + v88 + 4) = 10921;
                break;
              case 0x2AA9u:
                *(_DWORD *)(v10 + v88 + 4) = 10920;
                break;
              case 0x2AAAu:
                *(_DWORD *)(v10 + v88 + 4) = 10923;
                break;
              case 0x2AABu:
                *(_DWORD *)(v10 + v88 + 4) = 10922;
                break;
              case 0x2AACu:
                *(_DWORD *)(v10 + v88 + 4) = 10925;
                break;
              case 0x2AADu:
                *(_DWORD *)(v10 + v88 + 4) = 10924;
                break;
              case 0x2AAFu:
                *(_DWORD *)(v10 + v88 + 4) = 10928;
                break;
              case 0x2AB0u:
                *(_DWORD *)(v10 + v88 + 4) = 10927;
                break;
              case 0x2AB3u:
                *(_DWORD *)(v10 + v88 + 4) = 10932;
                break;
              case 0x2AB4u:
                *(_DWORD *)(v10 + v88 + 4) = 10931;
                break;
              case 0x2ABBu:
                *(_DWORD *)(v10 + v88 + 4) = 10940;
                break;
              case 0x2ABCu:
                *(_DWORD *)(v10 + v88 + 4) = 10939;
                break;
              case 0x2ABDu:
                *(_DWORD *)(v10 + v88 + 4) = 10942;
                break;
              case 0x2ABEu:
                *(_DWORD *)(v10 + v88 + 4) = 10941;
                break;
              case 0x2ABFu:
                *(_DWORD *)(v10 + v88 + 4) = 10944;
                break;
              case 0x2AC0u:
                *(_DWORD *)(v10 + v88 + 4) = 10943;
                break;
              case 0x2AC1u:
                *(_DWORD *)(v10 + v88 + 4) = 10946;
                break;
              case 0x2AC2u:
                *(_DWORD *)(v10 + v88 + 4) = 10945;
                break;
              case 0x2AC3u:
                *(_DWORD *)(v10 + v88 + 4) = 10948;
                break;
              case 0x2AC4u:
                *(_DWORD *)(v10 + v88 + 4) = 10947;
                break;
              case 0x2AC5u:
                *(_DWORD *)(v10 + v88 + 4) = 10950;
                break;
              case 0x2AC6u:
                *(_DWORD *)(v10 + v88 + 4) = 10949;
                break;
              case 0x2ACDu:
                *(_DWORD *)(v10 + v88 + 4) = 10958;
                break;
              case 0x2ACEu:
                *(_DWORD *)(v10 + v88 + 4) = 10957;
                break;
              case 0x2ACFu:
                *(_DWORD *)(v10 + v88 + 4) = 10960;
                break;
              case 0x2AD0u:
                *(_DWORD *)(v10 + v88 + 4) = 10959;
                break;
              case 0x2AD1u:
                *(_DWORD *)(v10 + v88 + 4) = 10962;
                break;
              case 0x2AD2u:
                *(_DWORD *)(v10 + v88 + 4) = 10961;
                break;
              case 0x2AD3u:
                *(_DWORD *)(v10 + v88 + 4) = 10964;
                break;
              case 0x2AD4u:
                *(_DWORD *)(v10 + v88 + 4) = 10963;
                break;
              case 0x2AD5u:
                *(_DWORD *)(v10 + v88 + 4) = 10966;
                break;
              case 0x2AD6u:
                *(_DWORD *)(v10 + v88 + 4) = 10965;
                break;
              case 0x2ADEu:
                *(_DWORD *)(v10 + v88 + 4) = 8870;
                break;
              case 0x2AE3u:
                *(_DWORD *)(v10 + v88 + 4) = 8873;
                break;
              case 0x2AE4u:
                *(_DWORD *)(v10 + v88 + 4) = 8872;
                break;
              case 0x2AE5u:
                *(_DWORD *)(v10 + v88 + 4) = 8875;
                break;
              case 0x2AECu:
                *(_DWORD *)(v10 + v88 + 4) = 10989;
                break;
              case 0x2AEDu:
                *(_DWORD *)(v10 + v88 + 4) = 10988;
                break;
              case 0x2AF7u:
                *(_DWORD *)(v10 + v88 + 4) = 11000;
                break;
              case 0x2AF8u:
                *(_DWORD *)(v10 + v88 + 4) = 10999;
                break;
              case 0x2AF9u:
                *(_DWORD *)(v10 + v88 + 4) = 11002;
                break;
              case 0x2AFAu:
                *(_DWORD *)(v10 + v88 + 4) = 11001;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 12288:
            switch ( v89 )
            {
              case 0x3008u:
                *(_DWORD *)(v10 + v88 + 4) = 12297;
                break;
              case 0x3009u:
                *(_DWORD *)(v10 + v88 + 4) = 12296;
                break;
              case 0x300Au:
                *(_DWORD *)(v10 + v88 + 4) = 12299;
                break;
              case 0x300Bu:
                *(_DWORD *)(v10 + v88 + 4) = 12298;
                break;
              case 0x300Cu:
                *(_DWORD *)(v10 + v88 + 4) = 12301;
                break;
              case 0x300Du:
                *(_DWORD *)(v10 + v88 + 4) = 12300;
                break;
              case 0x300Eu:
                *(_DWORD *)(v10 + v88 + 4) = 12303;
                break;
              case 0x300Fu:
                *(_DWORD *)(v10 + v88 + 4) = 12302;
                break;
              case 0x3010u:
                *(_DWORD *)(v10 + v88 + 4) = 12305;
                break;
              case 0x3011u:
                *(_DWORD *)(v10 + v88 + 4) = 12304;
                break;
              case 0x3014u:
                *(_DWORD *)(v10 + v88 + 4) = 12309;
                break;
              case 0x3015u:
                *(_DWORD *)(v10 + v88 + 4) = 12308;
                break;
              case 0x3016u:
                *(_DWORD *)(v10 + v88 + 4) = 12311;
                break;
              case 0x3017u:
                *(_DWORD *)(v10 + v88 + 4) = 12310;
                break;
              case 0x3018u:
                *(_DWORD *)(v10 + v88 + 4) = 12313;
                break;
              case 0x3019u:
                *(_DWORD *)(v10 + v88 + 4) = 12312;
                break;
              case 0x301Au:
                *(_DWORD *)(v10 + v88 + 4) = 12315;
                break;
              case 0x301Bu:
                *(_DWORD *)(v10 + v88 + 4) = 12314;
                break;
              default:
                goto LABEL_171;
            }
            break;
          case 65280:
            if ( v89 == 65341 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 65339;
            }
            else if ( v89 <= 0xFF3D )
            {
              if ( v89 == 65308 )
              {
                *(_DWORD *)(v10 + v88 + 4) = 65310;
              }
              else if ( v89 > 0xFF1C )
              {
                if ( v89 == 65310 )
                {
                  *(_DWORD *)(v10 + v88 + 4) = 65308;
                }
                else if ( v89 == 65339 )
                {
                  *(_DWORD *)(v10 + v88 + 4) = 65341;
                }
              }
              else if ( v89 == 65288 )
              {
                *(_DWORD *)(v10 + v88 + 4) = 65289;
              }
              else if ( v89 == 65289 )
              {
                *(_DWORD *)(v10 + v88 + 4) = 65288;
              }
            }
            else if ( v89 == 65375 )
            {
              *(_DWORD *)(v10 + v88 + 4) = 65376;
            }
            else if ( v89 <= 0xFF5F )
            {
              if ( v89 == 65371 )
              {
                *(_DWORD *)(v10 + v88 + 4) = 65373;
              }
              else if ( v89 == 65373 )
              {
                *(_DWORD *)(v10 + v88 + 4) = 65371;
              }
            }
            else
            {
              switch ( v89 )
              {
                case 0xFF62u:
                  *(_DWORD *)(v10 + v88 + 4) = 65379;
                  break;
                case 0xFF63u:
                  *(_DWORD *)(v10 + v88 + 4) = 65378;
                  break;
                case 0xFF60u:
                  *(_DWORD *)(v10 + v88 + 4) = 65375;
                  break;
              }
            }
            break;
        }
      }
      else if ( v89 == 91 )
      {
        *(_DWORD *)(v10 + v88 + 4) = 93;
      }
      else if ( v89 <= 0x5B )
      {
        if ( v89 == 41 )
        {
          *(_DWORD *)(v10 + v88 + 4) = 40;
        }
        else if ( v89 <= 0x29 )
        {
          if ( v89 == 40 )
            *(_DWORD *)(v10 + v88 + 4) = 41;
        }
        else if ( v89 == 60 )
        {
          *(_DWORD *)(v10 + v88 + 4) = 62;
        }
        else if ( v89 == 62 )
        {
          *(_DWORD *)(v10 + v88 + 4) = 60;
        }
      }
      else if ( v89 == 125 )
      {
        *(_DWORD *)(v10 + v88 + 4) = 123;
      }
      else if ( v89 <= 0x7D )
      {
        if ( v89 == 93 )
        {
          *(_DWORD *)(v10 + v88 + 4) = 91;
        }
        else if ( v89 == 123 )
        {
          *(_DWORD *)(v10 + v88 + 4) = 125;
        }
      }
      else if ( v89 == 171 )
      {
        *(_DWORD *)(v10 + v88 + 4) = 187;
      }
      else if ( v89 == 187 )
      {
        *(_DWORD *)(v10 + v88 + 4) = 171;
      }
    }
LABEL_171:
    ++v87;
  }
  while ( v29 > (signed int)v87 );
  v106 = *v13;
  v107 = 0LL;
  for ( k = *v13; ; k = v13[v107] )
  {
    if ( v106 < k )
      v106 = k;
    if ( v29 <= (signed int)++v107 )
      break;
  }
  if ( v106 )
  {
    v109 = v106;
    v110 = v143;
    v138 = v106 - 1;
    v141 = v138 - (unsigned __int8)(v106 - 1);
LABEL_218:
    v111 = 0;
    do
    {
      if ( v111 >= v29 )
        goto LABEL_224;
      if ( v109 != (unsigned __int8)v13[v111] )
      {
        v112 = v111 + 1;
        v113 = v112 + (unsigned int)(v110 - v111);
        while ( 1 )
        {
          v115 = (signed int)v112;
          if ( v113 == v112 )
            break;
          v114 = (unsigned __int8)v13[v112++];
          if ( v109 == v114 )
            goto LABEL_227;
        }
LABEL_224:
        v116 = v138;
        v109 = v138;
        if ( v141 == v138 )
          goto LABEL_239;
LABEL_225:
        v138 = v116 - 1;
        goto LABEL_218;
      }
      v115 = v111;
LABEL_227:
      v117 = v115 + 1;
      v118 = (signed int)v115 + 1;
      do
      {
        v111 = v118;
        if ( v29 <= (signed int)v118 )
          break;
        v119 = (unsigned __int8)v13[v118++];
      }
      while ( v109 <= v119 );
      v120 = v111 - 1;
      if ( v111 - 1 > (signed int)v115 )
      {
        v144 = v111;
        v121 = v10 + 12LL * v120;
        v122 = (_QWORD *)(v10 + 12 * v115);
        while ( 1 )
        {
          v123 = *v122;
          v124 = *(_WORD *)(v121 + 10);
          --v120;
          v125 = *(_WORD *)(v121 + 8);
          v126 = *(_DWORD *)v121;
          v122 = (_QWORD *)((char *)v122 + 12);
          v127 = *(_DWORD *)(v121 + 4);
          v121 -= 12LL;
          *(_QWORD *)(v121 + 12) = v123;
          *(_DWORD *)(v121 + 20) = *((_DWORD *)v122 - 1);
          *((_WORD *)v122 - 1) = v124;
          LODWORD(v115) = v117;
          *((_DWORD *)v122 - 3) = v126;
          *((_DWORD *)v122 - 2) = v127;
          *((_WORD *)v122 - 2) = v125;
          if ( v120 <= v117 )
            break;
          ++v117;
        }
        v111 = v144;
      }
      if ( (signed int)v115 < v111 )
        LODWORD(v115) = v111;
    }
    while ( v29 > (signed int)v115 );
    v116 = v138;
    v109 = v138;
    if ( v141 != v138 )
      goto LABEL_225;
LABEL_239:
    v86 = v147;
  }
  sub_2F4D0(v86);
  sub_2F4D0(v13);
  return 3LL;
}

unsigned __int64 sub_31A30(__int64 a1, __int64 a2, ...)
{
  char *v2; // rbx
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v5; // [rsp+18h] [rbp-D0h]

  va_start(va, a2);
  v5 = __readfsqword(0x28u);
  v2 = sub_BC310(a2, (const __m128i *)va);
  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 32LL))(a1, v2);
  sub_2F4D0(v2);
  return __readfsqword(0x28u) ^ v5;
}

_QWORD *sub_31B10()
{
  _QWORD *result; // rax

  result = sub_2F450(1uLL, 0x48uLL, 0LL);
  result[7] = 0LL;
  result[6] = 0LL;
  result[5] = 0LL;
  result[8] = 0LL;
  *(_BYTE *)result = 1;
  result[3] = 0LL;
  result[1] = 0LL;
  *((_BYTE *)result + 32) = 0;
  *((_BYTE *)result + 16) = 0;
  return result;
}

_QWORD *__fastcall sub_31B70(_QWORD *a1, __int64 a2, char a3)
{
  char v3; // r12
  _QWORD *v4; // rbx
  _BYTE *v5; // rax
  _BYTE *v6; // rbp
  signed __int64 v7; // rax
  unsigned __int64 v8; // rcx
  void *v9; // rdi
  _QWORD *result; // rax
  __int64 v11; // rdx

  v3 = a3;
  v4 = a1;
  v5 = sub_2F450(1uLL, 0x18uLL, 0LL);
  *(_QWORD *)v5 = a2;
  v5[8] = v3;
  v6 = v5;
  v7 = sub_BC650();
  v8 = a1[5];
  v9 = (void *)a1[7];
  *((_QWORD *)v6 + 2) = v7;
  result = sub_2F4F0(v9, v4 + 6, 8uLL, v8, 1uLL, 0);
  v11 = v4[5];
  v4[7] = result;
  v4[5] = v11 + 1;
  result[v11] = v6;
  return result;
}

__int64 __fastcall sub_31BF0(__int64 a1, const char *a2)
{
  sub_BC590(*(__int64 **)(a1 + 16), 0LL);
  strlen(a2);
  return sub_2EC30((__int64 (**)(void))(*(_QWORD *)(a1 + 16) + 24LL));
}

__int64 __fastcall sub_31C30(__int64 a1)
{
  return **(_QWORD **)(a1 + 16);
}

char *__fastcall sub_31C40(__int64 a1)
{
  return sub_BC120(**(char ***)(a1 + 16));
}

void __fastcall sub_31C50(__int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rbp

  if ( *(_QWORD *)(a1 + 40) )
  {
    v1 = 0LL;
    do
    {
      v2 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v1++);
      sub_BC660(*(void ***)(v2 + 16));
      sub_2F4D0(*(void **)v2);
      sub_2F4D0((void *)v2);
    }
    while ( *(_QWORD *)(a1 + 40) > v1 );
  }
  sub_2F4D0(*(void **)(a1 + 56));
  sub_2F4D0(*(void **)(a1 + 8));
  sub_2F4D0(*(void **)(a1 + 24));
  sub_2F4D0((void *)a1);
}

bool __fastcall sub_31CC0(__int64 *a1)
{
  bool result; // al

  if ( (unsigned int)sub_1EFD0(a1, 2) == 5 )
    result = *(_BYTE *)sub_1F170(a1, 61) != 0;
  else
    result = *(_BYTE *)sub_1F170(a1, 0) != 0;
  return result;
}

__int64 __fastcall sub_31D00(__int64 *a1)
{
  __int64 result; // rax

  if ( (unsigned int)sub_1EFD0(a1, 2) == 5 )
    result = sub_1F170(a1, 61);
  else
    result = sub_1F170(a1, 0);
  return result;
}

__int64 __fastcall sub_31D30(void *dest)
{
  char *v1; // rbp
  size_t v2; // rax
  __int64 v3; // rbx
  unsigned int v4; // eax
  unsigned int v5; // er15
  bool v6; // al
  const char *v7; // rcx
  const char *v8; // r15
  char v9; // al
  char *v10; // rcx
  char *i; // rdx
  size_t v12; // rax
  unsigned int v13; // ecx
  signed int v14; // eax
  size_t v15; // rsi
  const char *v17; // rax
  const char *v18; // rax
  const __int32_t **v19; // rax
  __int64 v20; // rdx
  unsigned __int32 v21; // [rsp+Ch] [rbp-4Ch]
  unsigned int v22; // [rsp+12h] [rbp-46h]
  unsigned __int64 v23; // [rsp+18h] [rbp-40h]

  v1 = (char *)dest;
  v23 = __readfsqword(0x28u);
  while ( 1 )
  {
    v2 = strspn(v1, " \t");
    v3 = (__int64)&v1[v2];
    if ( !v1[v2] )
      return 0;
    v1 = (char *)(v3 + strcspn(&v1[v2], " \t"));
    if ( *v1 )
      *v1++ = 0;
    LOBYTE(v4) = sub_BD3A0((char *)v3, "SHA256:");
    v5 = v4;
    if ( (_BYTE)v4
      && strlen((const char *)(v3 + 7)) == 43
      && !*(_BYTE *)(v3
                   + strspn((const char *)(v3 + 7), "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/")
                   + 7) )
    {
      return v5;
    }
    v6 = sub_BD3A0((char *)v3, "MD5:");
    v7 = (const char *)(v3 + 4);
    if ( !v6 )
      v7 = (const char *)v3;
    v8 = v7;
    if ( strlen(v7) == 47 && !v8[strspn(v8, "0123456789abcdefABCDEF:")] )
    {
      v17 = v8;
      while ( *v17 != 58 && v17[1] != 58 )
      {
        v17 += 3;
        if ( v8 + 48 == v17 )
        {
          v18 = v8 + 2;
          while ( *v18 == 58 )
          {
            v18 += 3;
            if ( v18 == v8 + 47 )
            {
              v19 = __ctype_tolower_loc();
              v20 = 0LL;
              do
              {
                *((_BYTE *)dest + v20) = (*v19)[v8[v20]];
                ++v20;
              }
              while ( v20 != 47 );
              *((_BYTE *)dest + 47) = 0;
              return 1;
            }
          }
          break;
        }
      }
    }
    v9 = *(_BYTE *)v3;
    v10 = (char *)v3;
    for ( i = (char *)v3; *i; v9 = *i )
    {
      if ( v9 != 10 && v9 != 13 )
        *v10++ = v9;
      ++i;
    }
    *v10 = 0;
    v12 = strlen((const char *)v3);
    LOBYTE(v13) = v12 > 8 && (v12 & 3) == 0;
    v5 = v13;
    if ( (_BYTE)v13 )
    {
      if ( !*(_BYTE *)(v3 + strspn(
                              (const char *)v3,
                              "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/=")) )
      {
        v14 = sub_BCB10(v3, &v22);
        if ( v14 > 2 && (signed int)((unsigned __int64)sub_BCB10(v3 + 4, (_BYTE *)&v22 + v14) + v14) > 3 )
        {
          v21 = _byteswap_ulong(v22);
          if ( v21 <= 0x40 )
          {
            v15 = strlen((const char *)v3);
            if ( v15 >= (v21 + 6) / 3 )
            {
              memcpy(dest, (const void *)v3, v15 + 1);
              return v5;
            }
          }
        }
      }
    }
  }
}

__int64 __fastcall sub_31FE0(__int64 a1, __int64 a2)
{
  __int64 *v2; // rbx
  __int64 v3; // rax
  void *v4; // r12

  v2 = (__int64 *)sub_BC640();
  sub_BC720((__int64)v2, (__int64)"Build platform: %d-bit %s", 64LL, "Unix (GTK + X11)");
  sub_BC720((__int64)v2, (__int64)"%sCompiler: gcc %s", a1, "7.5.0");
  v3 = sub_AB800();
  if ( v3 )
  {
    v4 = (void *)v3;
    sub_BC720((__int64)v2, (__int64)"%sCompiled against GTK version %s", a1, v3);
    sub_2F4D0(v4);
  }
  sub_BC720((__int64)v2, (__int64)"%sSource commit: %s", a1, "1fd7baa7344bb38d62a024e5dba3a720c67d05cf");
  return sub_BC6B0(v2);
}

void nullsub_1()
{
  ;
}

void nullsub_2()
{
  ;
}

void nullsub_3()
{
  ;
}

void nullsub_4()
{
  ;
}

void nullsub_5()
{
  ;
}

signed __int64 sub_321E0()
{
  return 1LL;
}

signed __int64 sub_32200()
{
  return 1LL;
}

signed __int64 sub_32230()
{
  return 1LL;
}

void __fastcall sub_32240(void **a1)
{
  if ( a1 )
  {
    sub_2F4D0(a1[1]);
    sub_2F4D0(a1[5]);
    sub_2F4D0(a1);
  }
}

void __noreturn sub_32270()
{
  sub_B06C0((__int64)"Out of memory");
}

void __fastcall sub_32350(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  signed __int64 v3; // rcx
  char v4; // al
  signed __int64 v5; // r8
  char v6; // cl
  signed __int64 v7; // r10
  int v8; // er11
  _BYTE *v9; // rax
  signed __int64 v10; // r10
  int v11; // er9
  int v12; // er8

  if ( a3 )
  {
    v3 = a3 - 1;
    do
    {
      v4 = *(_BYTE *)(a1 + v3);
      v5 = v3-- ^ a3;
      a3 ^= v5 & ~(((unsigned __int8)(v4 ^ 0x30) - 1LL) >> 63);
    }
    while ( v3 != -1 );
  }
  if ( a2 )
  {
    v6 = 0;
    do
    {
      v7 = 1LL << v6;
      v8 = -((a3 >> v6) & 1);
      if ( a2 > 1LL << v6 )
      {
        v9 = (_BYTE *)(a1 + v7);
        v10 = -v7;
        do
        {
          v11 = (unsigned __int8)v9[v10];
          v12 = v8 & (v11 ^ (unsigned __int8)*v9);
          v9[v10] = v8 & (v11 ^ *v9) ^ v11;
          *v9++ ^= v12;
        }
        while ( (_BYTE *)(a1 + a2) != v9 );
      }
      ++v6;
    }
    while ( a2 >> v6 );
  }
}

unsigned __int64 __fastcall sub_32400(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4, __int64 a5, __int64 a6, unsigned __int64 a7)
{
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r15
  _QWORD *v9; // rbp
  unsigned __int64 v10; // r13
  __int64 v11; // rsi
  unsigned __int128 v12; // ax
  unsigned __int64 v14; // [rsp+0h] [rbp-68h]
  unsigned __int64 v15; // [rsp+8h] [rbp-60h]
  __int64 v16; // [rsp+10h] [rbp-58h]

  if ( !a2 )
    return a7;
  v7 = 0LL;
  v8 = a7;
  v16 = a2;
  v9 = a3;
  v15 = *a3;
  v14 = *a4;
  do
  {
    if ( v15 > v7 )
      v10 = *(_QWORD *)(v9[1] + 8 * v7);
    else
      v10 = 0LL;
    v11 = a6;
    if ( v14 > v7 )
      v11 = a6 ^ *(_QWORD *)(a4[1] + 8 * v7) & a5;
    v12 = (unsigned __int64)v11 + v10 + (unsigned __int128)v8;
    v8 = *((_QWORD *)&v12 + 1);
    if ( a1 )
      *(_QWORD *)(a1 + 8 * v7) = v12;
    ++v7;
  }
  while ( v16 != v7 );
  return v8;
}

void __fastcall sub_324D0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r14
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  unsigned int v9; // edi
  __int128 v10; // cx
  signed __int64 v11; // kr00_8
  signed __int64 v12; // r13
  __int64 v13; // [rsp+10h] [rbp-48h]
  unsigned __int64 v14; // [rsp+18h] [rbp-40h]

  v4 = *a1;
  if ( *a1 )
  {
    v5 = 0LL;
    v6 = 0LL;
    v7 = a1[1];
    v8 = *a2;
    v9 = 0;
    v14 = a4;
    v13 = v7;
    do
    {
      v9 |= ((unsigned __int64)-(signed __int64)(((unsigned int)v5 ^ (unsigned int)v14) & 1 | ((v5 ^ v14) >> 1)) >> 63) ^ 1;
      v12 = a3 & -(signed __int64)v9;
      a3 &= v9 - 1LL;
      if ( v8 > v5 )
        v10 = *(unsigned __int64 *)(a2[1] + 8 * v5);
      else
        v10 = 0uLL;
      v11 = v6 + v12;
      v6 = (v10 + v6 + (unsigned __int128)(unsigned __int64)v12) >> 64;
      *(_QWORD *)(v13 + 8 * v5++) = v10 + v11;
    }
    while ( v5 != v4 );
  }
}

signed __int64 __fastcall sub_325A0(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rbx
  _QWORD *v4; // rax
  char v5; // cl
  unsigned __int64 v6; // rdx
  __int64 v7; // rax
  int v8; // ebp
  signed __int64 result; // rax
  signed int v10; // er10
  signed __int64 v11; // r8
  unsigned __int64 v12; // r12
  unsigned __int64 *i; // rdx
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // [rsp+0h] [rbp-48h]

  v2 = *a1;
  v16 = a2 & 0x3F;
  if ( *a1 )
  {
    v3 = a1[1];
    v4 = (_QWORD *)a1[1];
    do
    {
      *v4 &= ((v2 - (a2 >> 6)) >> 63) - 1;
      ++v4;
    }
    while ( v4 != (_QWORD *)(v3 + 8 * v2) );
    v5 = 0;
    do
    {
      v6 = 1LL << v5;
      do
      {
        v7 = 0LL;
        if ( v2 > v6 )
          v7 = *(_QWORD *)(v3 + 8 * v6);
        *(_QWORD *)(v3 + (-8LL << v5) + 8 * v6) ^= -(signed __int64)((a2 >> 6 >> v5) & 1) & (*(_QWORD *)(v3 + (-8LL << v5) + 8 * v6) ^ v7);
        ++v6;
      }
      while ( v2 + (1LL << v5) != v6 );
      ++v5;
    }
    while ( v2 >> v5 );
  }
  v8 = 0;
  result = 8 * v2 - 8;
  do
  {
    v10 = 1 << v8;
    v11 = -(signed __int64)((v16 >> v8) & 1);
    if ( v2 )
    {
      v12 = a1[1];
      for ( i = (unsigned __int64 *)a1[1]; ; *(i - 1) = v14 ^ v11 & (v14 ^ ((*i << (64 - (1 << v8))) | v15)) )
      {
        v14 = *i;
        ++i;
        v15 = v14 >> v10;
        if ( (unsigned __int64 *)(8 * v2 + v12) == i )
          break;
      }
      result = (v14 ^ v15) & v11 ^ v14;
      *(_QWORD *)(v12 + 8 * v2 - 8) = result;
    }
    ++v8;
  }
  while ( v8 != 6 );
  return result;
}

unsigned __int64 __fastcall sub_32720(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbp
  unsigned __int64 v3; // r11
  __int64 v4; // rsi
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // r12
  unsigned __int64 result; // rax
  signed __int64 v8; // rdx
  unsigned __int64 v9; // rbx
  _QWORD *v10; // rax
  char v11; // cl
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rdx

  v2 = a2;
  v3 = *a1;
  v4 = a2 & 0x3F;
  v5 = v2 >> 6;
  v6 = ((unsigned __int64)(64 - v4) >> 6) - 1;
  result = v6 & (64 - v4);
  v8 = ((*a1 - v5) >> 63) - 1;
  if ( *a1 )
  {
    v9 = a1[1];
    v10 = (_QWORD *)a1[1];
    do
    {
      *v10 &= v8;
      ++v10;
    }
    while ( (_QWORD *)(v9 + 8 * v3) != v10 );
    v11 = 0;
    do
    {
      v12 = v3 - 1 - (1LL << v11);
      do
      {
        v13 = 0LL;
        if ( v3 > v12 )
          v13 = *(_QWORD *)(v9 + 8 * v12);
        *(_QWORD *)(v9 + (8LL << v11) + 8 * v12) ^= -(signed __int64)((v5 >> v11) & 1) & (*(_QWORD *)(v9 + (8LL << v11) + 8 * v12) ^ v13);
        --v12;
      }
      while ( ~(1LL << v11) != v12 );
      ++v11;
    }
    while ( v3 >> v11 );
    result = v3 - 2;
    do
    {
      v14 = *(_QWORD *)(v9 + 8 * result + 8) << v4;
      if ( v3 > result )
        v14 |= v6 & (*(_QWORD *)(v9 + 8 * result) >> ((unsigned __int8)v6 & (unsigned __int8)(64 - v4)));
      *(_QWORD *)(v9 + 8 * result-- + 8) = v14;
    }
    while ( result != -2LL );
  }
  return result;
}

unsigned __int64 __fastcall sub_328F0(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rdx

  v2 = *a1;
  if ( *a1 < a2 )
    __assert_fail("len <= pool->nw", "mpint.c", 0x2AFu, "mp_alloc_from_scratch");
  v3 = a1[1];
  if ( v2 - a2 <= v2 )
    v2 -= a2;
  *a1 = v2;
  a1[1] = v3 + 8 * a2;
  return a2;
}

unsigned __int64 __usercall sub_32940@<rax>(unsigned __int64 *a1@<rdx>, unsigned __int64 a2@<rcx>, unsigned __int64 *a3@<rdi>, unsigned __int64 *a4@<rsi>, __int64 a5@<r8>, __int64 a6@<r10>)
{
  unsigned __int64 *v6; // r15
  unsigned __int64 *v7; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rax
  unsigned __int64 *v10; // rbx
  unsigned __int64 v11; // ST28_8
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rdx
  __int64 v14; // r10
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rcx
  _QWORD *v18; // r15
  unsigned __int64 v19; // rbp
  unsigned __int64 v20; // rsi
  unsigned __int64 i; // rbx
  _QWORD *v22; // rcx
  unsigned __int64 *v23; // r8
  unsigned __int64 v24; // rdi
  unsigned __int64 v25; // r10
  unsigned __int128 v26; // ax
  unsigned __int128 v27; // ax
  unsigned __int128 v28; // ax
  __int64 v30; // rsi
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // r13
  __int64 v33; // r9
  unsigned __int64 v34; // rbp
  unsigned __int64 v35; // rdx
  unsigned __int64 v36; // rdi
  signed __int64 v37; // rdx
  signed __int64 v38; // rsi
  unsigned __int64 v39; // rdi
  unsigned __int64 v40; // rdx
  __int64 v41; // rdx
  __int64 v42; // r10
  unsigned __int64 v43; // rsi
  __int128 v44; // ax
  __int64 v45; // r10
  __int64 v46; // r10
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // r13
  __int64 v49; // rdx
  __int128 v50; // ax
  __int128 v51; // ax
  __int64 v52; // r10
  _QWORD *v53; // [rsp+28h] [rbp-130h]
  __int64 v54; // [rsp+38h] [rbp-120h]
  unsigned __int64 v55; // [rsp+40h] [rbp-118h]
  __int64 v56; // [rsp+48h] [rbp-110h]
  unsigned __int64 v57; // [rsp+50h] [rbp-108h]
  unsigned __int64 v58; // [rsp+58h] [rbp-100h]
  unsigned __int64 v59; // [rsp+60h] [rbp-F8h]
  __int64 v60; // [rsp+68h] [rbp-F0h]
  __int64 v61; // [rsp+70h] [rbp-E8h]
  _QWORD *v62; // [rsp+78h] [rbp-E0h]
  __int64 v63; // [rsp+80h] [rbp-D8h]
  unsigned __int64 v64; // [rsp+88h] [rbp-D0h]
  unsigned __int64 v65; // [rsp+90h] [rbp-C8h]
  _QWORD *v66; // [rsp+98h] [rbp-C0h]
  unsigned __int64 v67; // [rsp+A0h] [rbp-B8h]
  __int64 v68; // [rsp+A8h] [rbp-B0h]
  __int64 v69; // [rsp+B0h] [rbp-A8h]
  unsigned __int64 v70; // [rsp+B8h] [rbp-A0h]
  unsigned __int64 v71; // [rsp+C0h] [rbp-98h]
  _QWORD *v72; // [rsp+C8h] [rbp-90h]
  __int64 v73; // [rsp+D0h] [rbp-88h]
  _QWORD *v74; // [rsp+D8h] [rbp-80h]
  __int64 v75; // [rsp+E0h] [rbp-78h]
  __int64 v76; // [rsp+E8h] [rbp-70h]
  __int128 v77; // [rsp+F0h] [rbp-68h]
  __int128 v78; // [rsp+100h] [rbp-58h]
  unsigned __int64 v79; // [rsp+118h] [rbp-40h]

  v6 = a1;
  v7 = a4;
  v8 = *a3;
  v79 = __readfsqword(0x28u);
  v9 = *v7;
  if ( *a1 >= *v7 )
    v9 = *a1;
  v59 = a2;
  v60 = a5;
  if ( v9 > v8 )
    v9 = v8;
  v57 = 2 * v9;
  if ( a2 < 6 * v9 )
    __assert_fail("scratch.nw >= mp_mul_scratchspace_unary(inlen)", "mpint.c", 0x3EBu, "mp_mul_internal");
  v10 = a3;
  v56 = a6;
  v11 = v9;
  sub_BD070((void *)a3[1], 8 * v8);
  v12 = v11;
  v13 = *v7;
  v14 = v56;
  if ( v11 <= 0x17 )
  {
    v15 = *v6;
    v17 = *v10;
    v47 = v6[1];
    v18 = (_QWORD *)v10[1];
    v55 = v47;
    v53 = (_QWORD *)v7[1];
  }
  else
  {
    v15 = *v6;
    v16 = v6[1];
    v17 = *v10;
    v18 = (_QWORD *)v10[1];
    v55 = v16;
    v53 = (_QWORD *)v7[1];
    if ( v13 && v15 )
    {
      v30 = v15;
      v31 = v12 >> 1;
      v58 = v12;
      v32 = v12 - (v12 >> 1);
      v70 = v10[1];
      v33 = v32;
      v34 = 2 * v32;
      if ( v13 <= v32 )
        v33 = v13;
      v62 = v53;
      if ( v32 <= v15 )
        v30 = v12 - (v12 >> 1);
      v35 = v13 - v33;
      v64 = v55;
      v63 = v30;
      v61 = v33;
      if ( v35 > v31 )
        v35 = v12 >> 1;
      v36 = v15 - v30;
      v65 = v35;
      if ( v36 > v31 )
        v36 = v12 >> 1;
      v66 = &v53[v33];
      v37 = v55 + 8 * v30;
      v38 = v17;
      if ( v34 <= v17 )
        v38 = 2 * v32;
      v67 = v36;
      v39 = v17;
      v68 = v37;
      if ( v32 <= v17 )
        v39 = v12 - (v12 >> 1);
      v40 = v17 - v39;
      v69 = v38;
      if ( v17 - v39 > v17 )
        v40 = v17;
      v71 = v40;
      v72 = &v18[v39];
      v41 = v17 - v38;
      if ( v17 - v38 > v17 )
        v41 = v17;
      v73 = v41;
      v74 = &v18[v38];
      sub_32940((unsigned __int64 *)&v63, v59, (unsigned __int64 *)&v69, (unsigned __int64 *)&v61, v60, v56);
      sub_32940(&v67, v59, (unsigned __int64 *)&v73, &v65, v60, v42);
      if ( *v10 >= v57 )
      {
        v48 = v32 + 1;
        v75 = sub_328F0(&v59, v48);
        v76 = v49;
        *(_QWORD *)&v50 = sub_328F0(&v59, v48);
        v77 = v50;
        sub_32400(v76, v75, &v61, &v65, -1LL, 0LL, 0LL);
        sub_32400(*((__int64 *)&v77 + 1), v77, &v63, &v67, -1LL, 0LL, 0LL);
        *(_QWORD *)&v51 = sub_328F0(&v59, v34 + 1);
        v78 = v51;
        sub_32940((unsigned __int64 *)&v77, v59, (unsigned __int64 *)&v78, (unsigned __int64 *)&v75, v60, v52);
        sub_32400(*((__int64 *)&v78 + 1), v78, &v78, (unsigned __int64 *)&v69, -1LL, -1LL, 1uLL);
        sub_32400(*((__int64 *)&v78 + 1), v78, &v78, (unsigned __int64 *)&v73, -1LL, -1LL, 1uLL);
        sub_32400((__int64)v72, v71, &v71, (unsigned __int64 *)&v78, -1LL, 0LL, 0LL);
      }
      else
      {
        v43 = v58;
        if ( v71 <= v58 )
          v43 = v71;
        *(_QWORD *)&v44 = sub_328F0(&v59, v43);
        v78 = v44;
        sub_32940(&v67, v59, (unsigned __int64 *)&v78, (unsigned __int64 *)&v61, v60, v45);
        sub_32400((__int64)v72, v71, &v71, (unsigned __int64 *)&v78, -1LL, 0LL, 0LL);
        sub_32940((unsigned __int64 *)&v63, v59, (unsigned __int64 *)&v78, &v65, v60, v46);
        sub_32400((__int64)v72, v71, &v71, (unsigned __int64 *)&v78, -1LL, 0LL, 0LL);
      }
      return __readfsqword(0x28u) ^ v79;
    }
  }
  v19 = (unsigned __int64)&v18[v17];
  v20 = (unsigned __int64)&v53[v13];
  for ( i = v55 + 8 * v15; v20 > (unsigned __int64)v53 && v19 > (unsigned __int64)v18; ++v18 )
  {
    v22 = v18;
    if ( v19 <= (unsigned __int64)v18 || i <= v55 )
    {
      v24 = 0LL;
    }
    else
    {
      v54 = v14;
      v23 = (unsigned __int64 *)v55;
      v24 = 0LL;
      v25 = *v53;
      do
      {
        v26 = 0uLL;
        if ( i > (unsigned __int64)v23 )
          v26 = *v23 * (unsigned __int128)v25;
        v27 = (unsigned __int64)*v22 + (unsigned __int128)v24 + v26;
        ++v23;
        *v22 = v27;
        ++v22;
        v24 = *((_QWORD *)&v27 + 1);
      }
      while ( i > (unsigned __int64)v23 && v19 > (unsigned __int64)v22 );
      v14 = v54;
    }
    while ( v19 > (unsigned __int64)v22 )
    {
      v14 = 0LL;
      v28 = v24 + (unsigned __int128)(unsigned __int64)*v22;
      *v22 += v24;
      ++v22;
      v24 = *((_QWORD *)&v28 + 1);
    }
    ++v53;
  }
  return __readfsqword(0x28u) ^ v79;
}

_QWORD *__fastcall sub_32F60(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_2F450(1uLL, 0x10uLL, 8 * a1);
  if ( !a1 )
    __assert_fail("nw", "mpint.c", 0x44u, "mp_make_sized");
  v2 = v1;
  *v1 = a1;
  v1[1] = v1 + 2;
  sub_BD070(v1 + 2, 8 * a1);
  return v2;
}

_QWORD *__fastcall sub_32FD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  __int64 v5; // rdi
  __int64 v6; // r12
  __int64 v7; // rbx
  _QWORD *result; // rax
  __int64 v9; // r11
  unsigned __int8 *v10; // rdi
  __int64 v11; // r8
  __int64 v12; // r9
  char v13; // cl
  unsigned __int64 v14; // r10

  v4 = a1;
  v5 = (unsigned __int64)(a2 + 7) >> 3;
  v6 = a3;
  v7 = a4;
  if ( !v5 )
    v5 = 1LL;
  result = sub_32F60(v5);
  if ( a2 )
  {
    v9 = result[1];
    v10 = (unsigned __int8 *)(v7 + v4);
    v11 = 0LL;
    do
    {
      v12 = *v10;
      v13 = v11 & 7;
      v14 = v11++ & 0xFFFFFFFFFFFFFFF8LL;
      v10 += v6;
      *(_QWORD *)(v9 + v14) |= v12 << 8 * v13;
    }
    while ( v11 != a2 );
  }
  return result;
}

_QWORD *__fastcall sub_33050(__int64 a1, const void *a2)
{
  _QWORD *v2; // rbx

  v2 = sub_32F60(a1);
  memcpy((void *)v2[1], a2, 8LL * *v2);
  return v2;
}

_QWORD *__fastcall sub_33090(__int64 a1)
{
  return sub_32F60((unsigned __int64)(a1 + 63) >> 6);
}

_QWORD *__fastcall sub_330A0(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // rdx
  signed __int64 v3; // rcx

  result = sub_32F60(1LL);
  if ( *result )
  {
    v2 = (_QWORD *)result[1];
    v3 = (signed __int64)&v2[*result];
    do
    {
      *v2 = a1;
      ++v2;
    }
    while ( v2 != (_QWORD *)v3 );
  }
  return result;
}

__int64 __fastcall sub_330E0(_QWORD *a1)
{
  return *a1 << 6;
}

void __fastcall sub_330F0(_QWORD *a1)
{
  sub_BD070((void *)a1[1], 8LL * *a1);
  sub_BD070(a1, 0x10uLL);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_331D0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r12
  unsigned __int64 v3; // rbx
  bool v4; // cf
  bool v5; // zf
  void *v6; // rdi

  v2 = a1;
  v3 = *a1;
  v4 = *a2 < *a1;
  v5 = *a2 == *a1;
  v6 = (void *)a1[1];
  if ( v4 || v5 )
    v3 = *a2;
  memmove(v6, (const void *)a2[1], 8 * v3);
  return sub_BD070((void *)(8 * v3 + v2[1]), 8 * (*v2 - v3));
}

void __fastcall sub_33240(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, char a4)
{
  __int64 v4; // rbp
  signed __int64 v5; // rcx
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rax
  __int64 v9; // r10
  __int64 v10; // r8
  __int64 v11; // rdi

  v4 = *a1;
  v5 = -(signed __int64)(a4 & 1);
  if ( *a1 )
  {
    v6 = *a2;
    v7 = *a3;
    v8 = 0LL;
    v9 = a1[1];
    do
    {
      v10 = 0LL;
      if ( v6 > v8 )
        v10 = *(_QWORD *)(a2[1] + 8 * v8);
      v11 = v10;
      if ( v7 > v8 )
        v11 = v10 ^ *(_QWORD *)(a3[1] + 8 * v8);
      *(_QWORD *)(v9 + 8 * v8++) = v10 ^ v5 & v11;
    }
    while ( v8 != v4 );
  }
}

void __fastcall sub_332B0(__int64 *a1, _QWORD *a2, char a3)
{
  __int64 v3; // rcx
  __int64 *v4; // rax
  _QWORD *v5; // rdx
  signed __int64 v6; // r8
  __int64 v7; // rsi
  signed __int64 v8; // rcx
  signed __int64 v9; // [rsp+8h] [rbp-10h]

  v3 = *a1;
  if ( *a1 != *a2 )
    __assert_fail("x0->nw == x1->nw", "mpint.c", 0x9Au, "mp_cond_swap");
  v9 = -(signed __int64)(a3 & 1);
  if ( v3 )
  {
    v4 = (__int64 *)a1[1];
    v5 = (_QWORD *)a2[1];
    v6 = (signed __int64)&v4[v3];
    do
    {
      v7 = *v4;
      ++v4;
      v8 = v9 & (v7 ^ *v5);
      *(v4 - 1) = v8 ^ v7;
      *v5 ^= v8;
      ++v5;
    }
    while ( v4 != (__int64 *)v6 );
  }
}

void __fastcall sub_33350(_QWORD *a1, char a2)
{
  signed __int64 v2; // rsi
  _QWORD *v3; // rax
  signed __int64 v4; // rdx

  v2 = (a2 & 1) - 1LL;
  if ( *a1 )
  {
    v3 = (_QWORD *)a1[1];
    v4 = (signed __int64)&v3[*a1];
    do
    {
      *v3 &= v2;
      ++v3;
    }
    while ( v3 != (_QWORD *)v4 );
  }
}

_QWORD *__fastcall sub_33380(__int64 a1, __int64 a2)
{
  return sub_32FD0(a1, a2, 1LL, 0LL);
}

_QWORD *__fastcall sub_33390(__int64 a1, __int64 a2)
{
  return sub_32FD0(a1, a2, -1LL, a2 - 1);
}

_QWORD *__fastcall sub_333A0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rdi
  _QWORD *result; // rax
  __int64 v5; // r9
  char *v6; // r8
  unsigned __int64 v7; // rdi
  __int64 v8; // r11
  char v9; // cl
  char v10; // dl
  unsigned __int64 v11; // r11
  char v12; // cl

  if ( a2 > 0x3FFFFFFFFFFFFFFFLL )
    __assert_fail("hex.len <= (~(size_t)0) / 4", "mpint.c", 0xFAu, "mp_from_hex_pl");
  v2 = a1;
  v3 = (4 * a2 + 63) >> 6;
  if ( !v3 )
    v3 = 1LL;
  result = sub_32F60(v3);
  if ( a2 )
  {
    v5 = result[1];
    v6 = (char *)(v2 + a2 - 1);
    v7 = 0LL;
    do
    {
      v8 = *v6--;
      v9 = (v8 - 48) ^ ((v8 - 48) ^ (v8 - 87)) & ~(unsigned __int8)(((102 - v8) | (v8 - 97)) >> 63);
      v10 = v9 ^ (v9 ^ (v8 - 55)) & ~(unsigned __int8)(((70 - v8) | (v8 - 65)) >> 63);
      v11 = v7 >> 4;
      v12 = v7++ & 0xF;
      *(_QWORD *)(v5 + 8 * v11) |= (unsigned __int64)(v10 & 0xF) << 4 * v12;
    }
    while ( v7 != a2 );
  }
  return result;
}

_QWORD *__fastcall sub_334A0(const char *a1)
{
  unsigned __int64 v1; // rax

  v1 = strlen(a1);
  return sub_333A0((__int64)a1, v1);
}

_QWORD *__fastcall sub_334C0(__int64 a1)
{
  return sub_33050(*(_QWORD *)a1, *(const void **)(a1 + 8));
}

__int64 __fastcall sub_334D0(unsigned __int64 *a1, unsigned __int64 a2)
{
  __int64 result; // rax

  result = 0LL;
  if ( a2 >> 3 < *a1 )
    result = *(_QWORD *)(a1[1] + (a2 & 0xFFFFFFFFFFFFFFF8LL)) >> 8 * ((unsigned __int8)a2 & 7u);
  return result;
}

signed __int64 __fastcall sub_33500(unsigned __int64 *a1, unsigned __int64 a2)
{
  signed __int64 result; // rax

  result = 0LL;
  if ( a2 >> 6 < *a1 )
    result = (*(_QWORD *)(a1[1] + 8 * (a2 >> 6)) >> a2) & 1LL;
  return result;
}

unsigned __int64 __fastcall sub_33550(unsigned __int64 *a1, unsigned __int64 a2, char a3)
{
  char v3; // cl
  unsigned __int64 *v4; // rsi
  unsigned __int64 result; // rax

  if ( *a1 <= a2 >> 6 )
    __assert_fail("word < x->nw", "mpint.c", 0x134u, "mp_set_bit");
  v3 = a2 & 0x3F;
  v4 = (unsigned __int64 *)(a1[1] + 8 * (a2 >> 6));
  result = ((unsigned __int64)(a3 & 1) << v3) | *v4 & __ROL8__(-2LL, v3);
  *v4 = result;
  return result;
}

signed __int64 __fastcall sub_335B0(__int64 *a1)
{
  __int64 v1; // r9
  unsigned __int64 v2; // rsi
  __int64 v3; // r10
  __int64 v4; // rcx
  signed __int64 v5; // rdi
  signed __int64 v6; // rax
  __int64 v7; // rdx
  signed __int64 v8; // rax
  signed int v9; // er8
  unsigned __int64 v10; // rcx
  __int64 v11; // r9
  signed __int64 v12; // rdx
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rdx

  v1 = *a1;
  if ( *a1 )
  {
    v2 = -1LL;
    v3 = a1[1];
    v4 = 0LL;
    v5 = -1LL;
    do
    {
      v6 = -(*(_QWORD *)(v3 + 8 * v4) & 1LL | (*(_QWORD *)(v3 + 8 * v4) >> 1)) >> 63;
      v2 ^= v6 & (v2 ^ *(_QWORD *)(v3 + 8 * v4));
      v7 = v4++;
      v5 ^= (v5 ^ v7) & v6;
    }
    while ( v1 != v4 );
    v8 = (v5 << 6) + 1;
  }
  else
  {
    v8 = -63LL;
    v2 = -1LL;
  }
  v9 = 6;
  v10 = 32LL;
  v11 = 0LL;
  do
  {
    v12 = -(signed __int64)(v2 >> v10) >> 63;
    v13 = v12 & (v2 ^ (v2 >> v10));
    v14 = v10 & v12;
    v10 >>= 1;
    v2 ^= v13;
    v11 += v14;
    --v9;
  }
  while ( v9 );
  return v11 + v8;
}

__int64 __fastcall sub_33660(_QWORD *a1)
{
  _QWORD *v1; // r12
  signed __int64 v2; // rbx
  _BYTE *v3; // rax
  __int64 v4; // r14
  unsigned __int64 v5; // rdx
  char *v6; // rsi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r8
  char v9; // cl
  signed __int64 v10; // rdi

  v1 = a1;
  v2 = 16LL * *a1;
  v3 = sub_2F450(v2 + 1, 1uLL, 0LL);
  v4 = (__int64)v3;
  v3[v2] = 0;
  v5 = v2 - 1;
  if ( v2 )
  {
    v6 = &v3[v5];
    v7 = 0LL;
    do
    {
      v8 = v7 >> 4;
      v9 = v7++ & 0xF;
      --v6;
      v10 = (*(_QWORD *)(v1[1] + 8 * v8) >> 4 * v9) & 0xFLL;
      v6[1] = v10 + (-(((unsigned __int8)v10 + 6) >> 4) & 0x27) + 48;
    }
    while ( v2 != v7 );
  }
  sub_32350(v4, v2 + 1, v5);
  return v4;
}

__int64 __fastcall sub_33660(_QWORD *a1)
{
  _QWORD *v1; // r12
  signed __int64 v2; // rbx
  _BYTE *v3; // rax
  __int64 v4; // r14
  unsigned __int64 v5; // rdx
  char *v6; // rsi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r8
  char v9; // cl
  signed __int64 v10; // rdi

  v1 = a1;
  v2 = 16LL * *a1;
  v3 = sub_2F450(v2 + 1, 1uLL, 0LL);
  v4 = (__int64)v3;
  v3[v2] = 0;
  v5 = v2 - 1;
  if ( v2 )
  {
    v6 = &v3[v5];
    v7 = 0LL;
    do
    {
      v8 = v7 >> 4;
      v9 = v7++ & 0xF;
      --v6;
      v10 = (*(_QWORD *)(v1[1] + 8 * v8) >> 4 * v9) & 0xFLL;
      v6[1] = v10 + (-(((unsigned __int8)v10 + 6) >> 4) & 0x27) + 48;
    }
    while ( v2 != v7 );
  }
  sub_32350(v4, v2 + 1, v5);
  return v4;
}

unsigned __int64 __fastcall sub_33680(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rbp
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r13
  unsigned __int64 v5; // rbx
  unsigned __int64 result; // rax
  __int64 v7; // rsi

  v2 = a2;
  v3 = sub_335B0(a2);
  v4 = (v3 + 7) >> 3;
  if ( v3 > 0xFFFF )
    __assert_fail("bits < 0x10000", "mpint.c", 0x24Eu, "BinarySink_put_mp_ssh1");
  v5 = v4 - 1;
  result = sub_2ED40(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), v3);
  if ( v4 )
  {
    do
    {
      LOBYTE(v7) = 0;
      if ( v5 >> 3 < *v2 )
        v7 = *(_QWORD *)(v2[1] + (v5 & 0xFFFFFFFFFFFFFFF8LL)) >> 8 * ((unsigned __int8)v5 & 7u);
      --v5;
      result = sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8), v7);
    }
    while ( v5 != -1LL );
  }
  return result;
}

unsigned __int64 __fastcall sub_33730(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rbp
  unsigned __int64 v3; // r13
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rbx
  __int64 v6; // rsi

  v2 = a2;
  v3 = (unsigned __int64)(sub_335B0(a2) + 8) >> 3;
  result = sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), v3);
  if ( v3 )
  {
    v5 = v3 - 1;
    do
    {
      LOBYTE(v6) = 0;
      if ( v5 >> 3 < *v2 )
        v6 = *(_QWORD *)(v2[1] + (v5 & 0xFFFFFFFFFFFFFFF8LL)) >> 8 * ((unsigned __int8)v5 & 7u);
      --v5;
      result = sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8), v6);
    }
    while ( v5 != -1LL );
  }
  return result;
}

_QWORD *__fastcall sub_337C0(__int64 a1)
{
  unsigned int v1; // eax
  unsigned __int64 v2; // rbp
  char *v3; // rax
  __int64 v4; // rdx
  __int64 *v5; // rax
  _QWORD *v6; // r11

  v1 = sub_2F100(*(_QWORD *)(a1 + 32));
  v2 = v1;
  v3 = sub_2F040(*(_QWORD *)(a1 + 32), (v1 + 7) >> 3);
  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24LL) )
  {
    v5 = sub_32FD0((__int64)v3, v4, -1LL, v4 - 1);
    if ( sub_335B0(v5) <= v2 )
      return v6;
    *(_DWORD *)(a1 + 24) = 2;
    sub_330F0(v6);
  }
  return sub_330A0(0LL);
}

_QWORD *__fastcall sub_33840(__int64 a1)
{
  char *v1; // rax
  unsigned __int64 v2; // rdx

  v1 = sub_2F1D0(*(_QWORD *)(a1 + 32));
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24LL) )
    return sub_330A0(0LL);
  if ( v2 && (*v1 < 0 || !*v1 && (v2 <= 1 || v1[1] >= 0)) )
  {
    *(_DWORD *)(a1 + 24) = 2;
    return sub_330A0(0LL);
  }
  return sub_32FD0((__int64)v1, v2, -1LL, v2 - 1);
}

unsigned __int64 __fastcall sub_338A0(__int64 *a1, _QWORD *a2, unsigned __int64 *a3)
{
  return sub_32400(a1[1], *a1, a2, a3, -1LL, 0LL, 0LL);
}

unsigned __int64 __fastcall sub_338D0(__int64 *a1, _QWORD *a2, unsigned __int64 *a3)
{
  return sub_32400(a1[1], *a1, a2, a3, -1LL, -1LL, 1uLL);
}

void __fastcall sub_33A80(__int64 *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // r8
  __int64 v4; // rdi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // r11
  unsigned __int128 v9; // kr00_16

  v3 = *a1;
  v4 = a1[1];
  if ( v3 )
  {
    v5 = 0LL;
    v6 = 0LL;
    v7 = *a2;
    do
    {
      if ( v7 > v5 )
        v8 = *(_QWORD *)(a2[1] + 8 * v5);
      else
        v8 = 0LL;
      v9 = v8 + v6 + (unsigned __int128)a3;
      v6 = *((_QWORD *)&v9 + 1);
      if ( v4 )
        *(_QWORD *)(v4 + 8 * v5) = v9;
      ++v5;
      a3 = 0LL;
    }
    while ( v3 != v5 );
  }
}

void __fastcall sub_33B10(__int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 v3; // r8
  __int64 v4; // rdi
  unsigned __int64 v5; // rax
  signed __int64 v6; // r15
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // r11
  unsigned __int128 v9; // kr00_16

  v3 = *a1;
  v4 = a1[1];
  if ( v3 )
  {
    v5 = 0LL;
    v6 = 1LL;
    v7 = *a2;
    do
    {
      if ( v7 > v5 )
        v8 = *(_QWORD *)(a2[1] + 8 * v5);
      else
        v8 = 0LL;
      v9 = v8 + (unsigned __int64)v6 + (unsigned __int128)(unsigned __int64)~a3;
      v6 = *((_QWORD *)&v9 + 1);
      if ( v4 )
        *(_QWORD *)(v4 + 8 * v5) = v9;
      ++v5;
      a3 = 0LL;
    }
    while ( v3 != v5 );
  }
}

void __fastcall sub_33BA0(__int64 *a1, unsigned __int64 *a2, unsigned __int16 a3)
{
  __int64 v3; // r8
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // rbp
  __int64 v8; // rbx
  unsigned __int64 v9; // r10
  __int64 v10; // rdx

  v3 = *a1;
  if ( *a1 )
  {
    v4 = 0LL;
    v5 = 0LL;
    v6 = a3;
    v7 = *a2;
    v8 = a1[1];
    do
    {
      v9 = 0LL;
      v10 = v5;
      if ( v7 > v4 )
      {
        v9 = (*(unsigned __int64 *)(a2[1] + 8 * v4) * (unsigned __int128)v6 + v5) >> 64;
        v10 = *(_QWORD *)(a2[1] + 8 * v4) * v6 + v5;
      }
      *(_QWORD *)(v8 + 8 * v4++) = v10;
      v5 = v9;
    }
    while ( v4 != v3 );
    if ( v9 )
      __assert_fail("!carry", "mpint.c", 0x354u, "mp_mul_integer_into");
  }
}

__int64 *__usercall sub_33C30@<rax>(char *a1@<rdi>, unsigned __int64 a2@<rsi>, unsigned __int64 a3@<r9>, __int64 a4@<r10>, unsigned __int64 a5@<r11>)
{
  __int64 *v5; // rax
  __int64 *v6; // rbp
  unsigned __int64 v7; // r9
  __int64 v8; // r10
  unsigned __int64 v9; // r11
  char *v10; // rbp
  __int64 *v11; // r15
  __int64 v12; // rsi
  unsigned __int64 v13; // rcx
  signed __int64 v14; // rdi
  _QWORD *v15; // rdx
  unsigned __int64 v16; // rax
  unsigned __int128 v17; // cx
  unsigned __int64 v19; // [rsp+0h] [rbp-78h]
  __int64 v20; // [rsp+8h] [rbp-70h]
  unsigned __int64 v21; // [rsp+10h] [rbp-68h]
  unsigned __int64 v22; // [rsp+10h] [rbp-68h]
  __int64 v23; // [rsp+18h] [rbp-60h]
  signed __int64 v24; // [rsp+20h] [rbp-58h]
  char *v25; // [rsp+28h] [rbp-50h]
  unsigned __int64 v26; // [rsp+30h] [rbp-48h]

  if ( a2 > 0x14E5E0A72F05396LL )
    __assert_fail("decimal.len < (~(size_t)0) / 196", "mpint.c", 0xDBu, "mp_from_decimal_pl");
  v26 = a5;
  v21 = a3;
  v23 = a4;
  v5 = sub_32F60(((unsigned __int64)(0x8AD8F2FBA9386823LL * (unsigned __int128)(196 * a2) >> 64) >> 11) + 1);
  v6 = v5;
  if ( a2 )
  {
    v7 = v21;
    v8 = v23;
    v9 = v26;
    v25 = &a1[a2];
    v24 = (signed __int64)&a1[a2 - 1];
    v10 = a1;
    v11 = v5;
    do
    {
      v12 = v11[1];
      v13 = *v10 - 48;
      if ( *v11 )
      {
        v14 = v12 + 8 * *v11;
        v15 = (_QWORD *)v11[1];
        v16 = 0LL;
        do
        {
          v8 = 0LL;
          v7 = v13;
          v9 = v16;
          v17 = (unsigned __int64)*v15 + v16 + (unsigned __int128)v13;
          v16 = *((_QWORD *)&v17 + 1);
          if ( v12 )
            *v15 = v17;
          ++v15;
          v13 = 0LL;
        }
        while ( v15 != (_QWORD *)v14 );
      }
      v22 = v9;
      v19 = v7;
      v20 = v8;
      if ( (char *)v24 == v10 )
        break;
      sub_33BA0(v11, (unsigned __int64 *)v11, 0xAu);
      ++v10;
      v7 = v19;
      v8 = v20;
      v9 = v22;
    }
    while ( v25 != v10 );
    v6 = v11;
  }
  return v6;
}

__int64 *__fastcall sub_33DB0(char *a1)
{
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // r9
  __int64 v3; // r10
  unsigned __int64 v4; // r11

  v1 = strlen(a1);
  return sub_33C30(a1, v1, v2, v3, v4);
}

unsigned __int64 __fastcall sub_33DD0(__int64 *a1, _QWORD *a2, unsigned __int64 *a3, char a4)
{
  return sub_32400(a1[1], *a1, a2, a3, -(signed __int64)(a4 & 1), 0LL, 0LL);
}

unsigned __int64 __fastcall sub_33E00(__int64 *a1, _QWORD *a2, unsigned __int64 *a3, char a4)
{
  return sub_32400(a1[1], *a1, a2, a3, -(signed __int64)(a4 & 1), -(signed __int64)(a4 & 1), a4 & 1);
}

signed __int64 __fastcall sub_33E30(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // r15
  signed __int64 result; // rax
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // r11
  signed __int64 v6; // r13

  v2 = *a1;
  if ( *a2 >= *a1 )
    v2 = *a2;
  if ( !v2 )
    return 1LL;
  result = 1LL;
  v4 = 0LL;
  do
  {
    if ( *a1 > v4 )
      v5 = *(_QWORD *)(a1[1] + 8 * v4);
    else
      v5 = 0LL;
    v6 = -1LL;
    if ( *a2 > v4 )
      v6 = ~*(_QWORD *)(a2[1] + 8 * v4);
    ++v4;
    result = ((unsigned __int64)v6 + v5 + (unsigned __int128)(unsigned __int64)result) >> 64;
  }
  while ( v4 != v2 );
  return result;
}

__int64 __fastcall sub_33ED0(__int64 a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  _QWORD *v4; // rbp
  __int64 v5; // rax
  __int64 v6; // rdx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  unsigned __int64 *v10; // rdx
  __int64 v11; // r10
  __int128 v12; // ax
  unsigned __int64 *v13; // rsi
  __int64 v14; // r10
  unsigned __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rbp
  __int64 v18; // r12
  unsigned __int64 *v19; // rcx
  char v20; // al
  unsigned __int64 *v21; // rcx
  unsigned __int128 v23; // [rsp+0h] [rbp-88h]
  __int64 v24; // [rsp+10h] [rbp-78h]
  __int64 v25; // [rsp+18h] [rbp-70h]
  unsigned __int64 v26; // [rsp+20h] [rbp-68h]
  __int64 v27; // [rsp+28h] [rbp-60h]
  __int128 v28; // [rsp+30h] [rbp-58h]
  __int64 v29; // [rsp+40h] [rbp-48h]
  __int64 v30; // [rsp+48h] [rbp-40h]
  unsigned __int64 v31; // [rsp+58h] [rbp-30h]

  v4 = a2;
  v31 = __readfsqword(0x28u);
  v5 = *a2;
  if ( *(_QWORD *)(a1 + 8) <= *a2 )
    v5 = *(_QWORD *)(a1 + 8);
  v23 = __PAIR__(a4, a3);
  v6 = a2[1];
  v7 = *(_QWORD *)(a1 + 16);
  v24 = v5;
  v25 = v6;
  v8 = sub_328F0((unsigned __int64 *)&v23, v7);
  v27 = v9;
  v10 = *(unsigned __int64 **)(a1 + 32);
  v26 = v8;
  sub_32940(v10, v23, &v26, (unsigned __int64 *)&v24, *((__int64 *)&v23 + 1), v11);
  *(_QWORD *)&v12 = sub_328F0((unsigned __int64 *)&v23, *(_QWORD *)(a1 + 24));
  v13 = *(unsigned __int64 **)a1;
  v28 = v12;
  sub_32940(&v26, v23, (unsigned __int64 *)&v28, v13, *((__int64 *)&v23 + 1), v14);
  sub_32400(*((__int64 *)&v28 + 1), v28, v4, (unsigned __int64 *)&v28, -1LL, 0LL, 0LL);
  v15 = *(_QWORD *)(a1 + 16);
  v16 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v28 <= v15 )
    v16 = v28;
  v17 = v28 - v15;
  if ( (unsigned __int64)v28 - v15 > (signed __int64)v28 - v16 )
    v17 = v28 - v16;
  v29 = v17;
  v18 = *((_QWORD *)&v28 + 1) + 8 * v16;
  v19 = *(unsigned __int64 **)a1;
  v30 = v18;
  v20 = sub_33E30((unsigned __int64 *)&v29, v19);
  sub_32400(v18, v17, &v29, v21, -(signed __int64)(v20 & 1), -(signed __int64)(v20 & 1), v20 & 1);
  return v29;
}

unsigned __int64 __fastcall sub_34040(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // rdx
  __int64 v4; // [rsp+0h] [rbp-38h]
  __int64 v5; // [rsp+8h] [rbp-30h]
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v4 = sub_33ED0(a1, a2, **(_QWORD **)(a1 + 64), *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL));
  v5 = v2;
  sub_331D0(a2, (unsigned __int64 *)&v4);
  sub_BD070(*(void **)(*(_QWORD *)(a1 + 64) + 8LL), 8LL * **(_QWORD **)(a1 + 64));
  return __readfsqword(0x28u) ^ v6;
}

signed __int64 __fastcall sub_340C0(signed __int64 *a1, __int64 a2)
{
  signed __int64 v2; // r8
  signed __int64 *v3; // rbp
  unsigned __int64 v4; // r13
  signed __int64 result; // rax
  unsigned __int64 v6; // rdx
  __int64 v7; // r11
  signed __int64 v8; // rdi

  v2 = 1LL;
  v3 = a1;
  v4 = *a1;
  result = 1LL;
  if ( *a1 )
    v2 = *a1;
  v6 = 0LL;
  do
  {
    if ( v4 <= v6 )
      v7 = 0LL;
    else
      v7 = *(_QWORD *)(v3[1] + 8 * v6);
    v8 = __CFADD__(v7, result + ~a2) + (((unsigned __int64)result + (unsigned __int128)(unsigned __int64)~a2) >> 64);
    ++v6;
    a2 = 0LL;
    result = v8;
  }
  while ( v2 != v6 );
  return result;
}

unsigned __int64 __fastcall sub_34130(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // r10
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx

  v2 = *a1;
  if ( *a2 >= *a1 )
    v2 = *a2;
  if ( !v2 )
    return 1LL;
  v3 = 0LL;
  v4 = 0LL;
  do
  {
    v5 = 0LL;
    if ( *a1 > v3 )
      v5 = *(_QWORD *)(a1[1] + 8 * v3);
    if ( *a2 > v3 )
      v5 ^= *(_QWORD *)(a2[1] + 8 * v3);
    ++v3;
    v4 |= v5;
  }
  while ( v2 != v3 );
  return ((unsigned __int64)-(signed __int64)(v4 & 1 | (v4 >> 1)) >> 63) ^ 1;
}

unsigned __int64 __fastcall sub_341A0(signed __int64 *a1, __int64 a2)
{
  signed __int64 v2; // r8
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx

  v2 = 1LL;
  if ( *a1 )
    v2 = *a1;
  v3 = 0LL;
  v4 = 0LL;
  do
  {
    if ( *a1 > v3 )
      a2 ^= *(_QWORD *)(a1[1] + 8 * v3);
    ++v3;
    v4 |= a2;
    a2 = 0LL;
  }
  while ( v2 != v3 );
  return ((unsigned __int64)-(signed __int64)(v4 & 1 | (v4 >> 1)) >> 63) ^ 1;
}

__int64 __fastcall sub_341F0(_QWORD *a1, unsigned __int64 *a2)
{
  _QWORD *v2; // rbp
  unsigned __int64 v3; // rdi
  __int64 *v4; // rax
  __int64 v5; // r11

  v2 = a1;
  v3 = *a1;
  if ( *a2 >= v3 )
    v3 = *a2;
  v4 = sub_32F60(v3 + 1);
  sub_32400(v4[1], *v4, v2, a2, -1LL, 0LL, 0LL);
  return v5;
}

__int64 __fastcall sub_34240(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rbp
  unsigned __int64 v3; // rdi
  __int64 *v4; // rax
  __int64 v5; // r11

  v2 = a1;
  v3 = *a1;
  if ( *a2 >= v3 )
    v3 = *a2;
  v4 = sub_32F60(v3);
  sub_32400(v4[1], *v4, v2, a2, -1LL, -1LL, 1uLL);
  return v5;
}

void __fastcall sub_34290(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbp
  unsigned __int64 v4; // rax
  unsigned __int64 *v5; // rbx
  __int64 v6; // r10

  v3 = a3;
  v4 = *a2;
  if ( *a3 >= *a2 )
    v4 = *a3;
  if ( v4 > *a1 )
    v4 = *a1;
  v5 = sub_32F60(6 * v4);
  sub_32940(v3, *v5, a1, a2, v5[1], v6);
  sub_330F0(v5);
}

unsigned __int64 *__fastcall sub_342F0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rbx

  v2 = sub_32F60(*a1 + *a2);
  sub_34290(v2, a1, a2);
  return v2;
}

unsigned __int64 __fastcall sub_34320(__int64 *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // r9
  unsigned __int64 v4; // r10
  __int64 v5; // rdx
  signed __int64 v6; // r8
  signed __int64 v7; // r13
  unsigned __int64 result; // rax
  _QWORD *v9; // r11
  unsigned __int64 v10; // r12
  __int64 v11; // rbx

  v3 = *a1;
  v4 = a3 >> 6;
  v5 = a3 & 0x3F;
  v6 = 8 * *a1 - 8;
  v7 = -8LL * v4;
  while ( 1 )
  {
    result = v3 - 1;
    if ( !v3 )
      return result;
    v9 = (_QWORD *)(v6 + a1[1]);
    if ( v4 > result )
    {
      *v9 = 0LL;
      goto LABEL_3;
    }
    v10 = *a2;
    v11 = 0LL;
    if ( result - v4 < *a2 )
      v11 = *(_QWORD *)(v7 + a2[1] + v6);
    if ( v5 )
    {
      v11 <<= v5;
      *v9 = v11;
      if ( v4 >= result )
        goto LABEL_3;
      if ( v10 > v3 - 2 - v4 )
        v11 |= *(_QWORD *)(v6 + v7 + a2[1] - 8) >> (64 - (unsigned __int8)v5);
    }
    *v9 = v11;
LABEL_3:
    v6 -= 8LL;
    --v3;
  }
}

unsigned __int64 __fastcall sub_343E0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rbp
  signed __int64 v6; // r8
  __int64 v7; // rbx
  signed __int64 v8; // r9
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rdi

  result = a3 >> 6;
  v4 = a3 & 0x3F;
  if ( *a1 )
  {
    v5 = *a2;
    v6 = 8 * result;
    v7 = result + *a1;
    v8 = a1[1] - 8 * result;
    do
    {
      while ( 1 )
      {
        v9 = 0LL;
        if ( v5 > result )
          v9 = *(_QWORD *)(a2[1] + v6);
        if ( v4 )
          break;
        ++result;
        *(_QWORD *)(v8 + v6) = v9;
        v6 += 8LL;
        if ( result == v7 )
          return result;
      }
      ++result;
      v10 = v9 >> v4;
      *(_QWORD *)(v8 + v6) = v10;
      if ( result < v5 )
        v10 |= *(_QWORD *)(a2[1] + v6 + 8) << (64 - (unsigned __int8)v4);
      *(_QWORD *)(v8 + v6) = v10;
      v6 += 8LL;
    }
    while ( result != v7 );
  }
  return result;
}

_BYTE *__fastcall sub_34480(__int64 a1)
{
  __int64 *v1; // rbx
  unsigned __int64 *v2; // rbp
  unsigned __int64 *v3; // rax
  unsigned __int64 *v4; // r12
  _QWORD *v5; // rsi
  signed __int64 v6; // rcx
  _QWORD *v7; // rax
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  signed __int64 v10; // r14
  signed __int64 v11; // r15
  _BYTE *v12; // r13
  _QWORD *v13; // r10
  signed int v14; // edx
  unsigned int v15; // edi
  unsigned int v16; // esi
  signed __int64 v17; // r11
  int v18; // ecx
  __int64 v19; // rax
  int v20; // esi
  unsigned int v21; // esi
  char v22; // al
  __int64 v23; // rdx

  v1 = sub_33050(*(_QWORD *)a1, *(const void **)(a1 + 8));
  v2 = sub_32F60(*v1);
  v3 = sub_32F60(*v1);
  v4 = v3;
  v5 = (_QWORD *)v3[1];
  if ( *v3 )
  {
    v6 = (signed __int64)&v5[*v3];
    v7 = (_QWORD *)v3[1];
    do
    {
      *v7 = -3689348814741910324LL;
      ++v7;
    }
    while ( (_QWORD *)v6 != v7 );
  }
  v8 = *v1;
  ++*v5;
  if ( v8 > 0x70381C0E07037LL )
    __assert_fail("x->nw < (~(size_t)1) / (146 * BIGNUM_INT_BITS)", "mpint.c", 0x1D4u, "mp_get_decimal");
  v9 = 0xE40655826010E41LL * (unsigned __int128)(9344 * v8) >> 64;
  v10 = (v9 + ((9344 * v8 - v9) >> 1)) >> 8;
  if ( !v10 )
    v10 = 1LL;
  v11 = v10;
  v12 = sub_2F450(v10 + 2, 1uLL, 0LL);
  v12[v10 + 1] = 0;
  do
  {
    if ( *v1 )
    {
      v13 = (_QWORD *)v1[1];
      v14 = 1;
      v15 = 0;
      v16 = 0;
      v17 = (signed __int64)&v13[*v1];
      do
      {
        v18 = 0;
        do
        {
          v19 = *v13 >> v18;
          v18 += 8;
          v16 += v14 * (unsigned __int8)v19;
          LODWORD(v19) = 255 * v14;
          v14 = 6;
          v15 += v19;
        }
        while ( v18 != 64 );
        if ( v15 > 0xFFFFD02F )
        {
          v15 = (unsigned __int16)v15 + 393210;
          v16 = (unsigned __int16)v16 + 6 * (v16 >> 16);
        }
        ++v13;
        v14 = 6;
      }
      while ( (_QWORD *)v17 != v13 );
      v20 = v16 - 10 * (429496729 * (unsigned __int64)v16 >> 32);
      v21 = v20 - 10 * ((unsigned int)(v20 + 6) >> 4);
      if ( v21 > 9 )
        __assert_fail("low_digit < 10", "mpint.c", 0x208u, "mp_get_decimal");
      v22 = v21 + 48;
      v23 = v21;
    }
    else
    {
      v23 = 0LL;
      v22 = 48;
    }
    v12[v11] = v22;
    sub_33B10(v1, (unsigned __int64 *)v1, v23);
    --v11;
    sub_343E0(v2, (unsigned __int64 *)v1, 1uLL);
    sub_34290((unsigned __int64 *)v1, v2, v4);
  }
  while ( v11 != -1 );
  sub_330F0(v1);
  sub_330F0(v2);
  sub_330F0(v4);
  sub_32350((__int64)v12, v10 + 2, v10);
  return v12;
}

void __fastcall sub_346C0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 *a3, unsigned __int64 *a4, unsigned __int64 *a5)
{
  unsigned __int64 *v5; // r14
  unsigned __int64 *v6; // r13
  unsigned __int64 v7; // rbp
  unsigned __int64 *v8; // rbx
  unsigned __int64 *v9; // r12
  unsigned __int64 *v10; // r13
  unsigned __int64 v11; // r15
  __int64 v12; // r14
  unsigned __int64 *v13; // r13
  char v14; // r10
  unsigned int v15; // ebp
  char v16; // bl
  unsigned __int64 v17; // rsi
  signed __int64 v18; // rax
  signed __int64 v19; // rax
  signed __int64 v20; // r10
  unsigned __int64 v21; // r15
  __int64 v22; // r12
  unsigned __int64 v23; // rax
  signed __int64 v24; // r14
  signed __int64 v25; // ST20_8
  __int64 v26; // r11
  _QWORD *v27; // r11
  __int64 *v28; // r11
  unsigned __int64 *v29; // [rsp+10h] [rbp-78h]
  unsigned __int64 v30; // [rsp+18h] [rbp-70h]
  unsigned __int64 *v31; // [rsp+18h] [rbp-70h]
  __int64 *v32; // [rsp+20h] [rbp-68h]
  unsigned __int64 *v33; // [rsp+28h] [rbp-60h]
  unsigned __int64 *v34; // [rsp+38h] [rbp-50h]
  int v35; // [rsp+38h] [rbp-50h]
  __int64 *v36; // [rsp+40h] [rbp-48h]
  unsigned __int64 *v37; // [rsp+48h] [rbp-40h]

  v5 = a5;
  v6 = a4;
  v7 = 1LL;
  if ( *a4 )
    v7 = *a4;
  v32 = a3;
  v37 = a2;
  if ( v7 < *a5 )
    v7 = *a5;
  v8 = sub_32F60(v7);
  v9 = sub_32F60(v7);
  sub_331D0(v8, v6);
  sub_331D0(v9, v5);
  v33 = sub_32F60(v7 + 1);
  v10 = sub_32F60(v7 + 1);
  v36 = sub_32F60(v7);
  v30 = v7 << 7;
  v29 = sub_32F60(((v7 << 8) + 63) >> 6);
  if ( v7 << 7 )
  {
    v34 = v10;
    v11 = 1LL;
    v12 = 0LL;
    v13 = v8;
    do
    {
      v14 = sub_33E30(v9, v13);
      v15 = *(_DWORD *)v9[1] & *(unsigned __int64 *)v13[1] & 1;
      v16 = *(_BYTE *)v13[1] & 1 ^ v15 & (*(_BYTE *)v13[1] & 1 ^ v14);
      sub_332B0((__int64 *)v13, v9, v16);
      sub_32400(v13[1], *v13, v13, v9, -(signed __int64)v15, -(signed __int64)v15, v15);
      sub_343E0(v13, v13, 1uLL);
      v17 = 2 * v12++;
      sub_33550(v29, v17, v15);
      sub_33550(v29, v11, v16);
      v11 += 2LL;
    }
    while ( v30 != v12 );
    v8 = v13;
    v10 = v34;
  }
  if ( v32 )
    sub_32400(v32[1], *v32, v8, v9, -1LL, 0LL, 0LL);
  if ( a1 || v37 )
  {
    v18 = 0LL;
    if ( *v8 )
      v18 = *(_QWORD *)v8[1] & 1LL;
    *(_QWORD *)v33[1] = v18;
    v19 = 0LL;
    if ( *v9 )
      v19 = *(_QWORD *)v9[1] & 1LL;
    *(_QWORD *)v10[1] = v19;
    sub_331D0(v8, v33);
    sub_331D0(v9, v10);
    v35 = *(_DWORD *)v9[1];
    v20 = v30 - 1;
    if ( v30 )
    {
      v21 = 2 * v30 - 1;
      v31 = v9;
      do
      {
        v22 = 0LL;
        v23 = (v21 - 1) >> 6;
        if ( v23 < *v29 )
          v22 = -((*(_QWORD *)(v29[1] + 8 * v23) >> (2 * v20 & 0x3F)) & 1LL);
        LOBYTE(v24) = 0;
        if ( v21 >> 6 < *v29 )
        {
          v24 = (*(_QWORD *)(v29[1] + 8 * (v21 >> 6)) >> v21) & 1LL;
          LOBYTE(v35) = v24 ^ v35;
        }
        v25 = v20;
        v21 -= 2LL;
        sub_32400(v33[1], *v33, v33, v31, -(*(_QWORD *)v33[1] & 1LL), 0LL, 0LL);
        sub_32400(v10[1], *v10, v10, v8, v26, 0LL, 0LL);
        sub_343E0(v33, v33, 1uLL);
        sub_32400(v10[1], *v10, v10, v33, v22, 0LL, 0LL);
        sub_34320((__int64 *)v8, v8, 1uLL);
        sub_32400(v8[1], *v8, v8, v31, v22, 0LL, 0LL);
        sub_332B0((__int64 *)v8, v27, v24);
        sub_332B0((__int64 *)v33, v10, v24);
        v20 = v25 - 1;
      }
      while ( v25 );
      v9 = v31;
    }
    sub_32400(v36[1], *v36, v9, v33, -1LL, -1LL, 1uLL);
    sub_33240(v28, (unsigned __int64 *)v28, (unsigned __int64 *)v36, v35);
    sub_32400(v36[1], *v36, v8, v10, -1LL, -1LL, 1uLL);
    sub_33240((__int64 *)v10, v10, (unsigned __int64 *)v36, v35);
    if ( !a1 || (sub_331D0(a1, v33), v37) )
      sub_331D0(v37, v10);
  }
  sub_330F0(v8);
  sub_330F0(v9);
  sub_330F0(v33);
  sub_330F0(v10);
  sub_330F0(v36);
  sub_330F0(v29);
}

_QWORD *__fastcall sub_34B90(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 *v2; // rbp
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rbx

  v2 = a1;
  v3 = *a1;
  v4 = a2 >> 6;
  if ( a2 >> 6 > v3 )
    v4 = v3;
  v5 = v3 - v4;
  if ( !v5 )
    v5 = 1LL;
  v6 = sub_32F60(v5);
  sub_343E0(v6, v2, a2);
  return v6;
}

unsigned __int64 *__fastcall sub_34BE0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 *v2; // rbx

  v2 = sub_33050(*(_QWORD *)a1, *(const void **)(a1 + 8));
  sub_325A0(v2, a2);
  return v2;
}

signed __int64 __fastcall sub_34C10(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp

  v3 = a3;
  sub_331D0(a1, a2);
  return sub_325A0(a1, v3);
}

unsigned __int64 __fastcall sub_34C40(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp

  v3 = a3;
  sub_331D0(a1, a2);
  return sub_32720(a1, v3);
}

signed __int64 __fastcall sub_34C70(unsigned __int64 *a1, unsigned __int64 a2)
{
  signed __int64 result; // rax
  signed __int64 v3; // rdx
  unsigned __int64 v4; // rsi
  signed __int64 v5; // rcx

  result = a2 >> 6;
  v3 = (1LL << a2) - 1;
  if ( a2 >> 6 < *a1 )
  {
    v4 = a1[1];
    result = v4 + 8 * result;
    v5 = v4 + 8 * *a1;
    do
    {
      *(_QWORD *)result &= v3;
      result += 8LL;
      v3 = 0LL;
    }
    while ( result != v5 );
  }
  return result;
}

unsigned __int64 *__fastcall sub_34CB0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 *v3; // r13
  signed __int64 v4; // rdx
  unsigned __int64 v5; // rbp
  const __m128i *v6; // rax
  unsigned __int64 v7; // rax
  __int64 v8; // rdx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rbp
  __int128 v12; // ax
  signed __int64 v13; // r15
  _QWORD *v14; // rax
  _QWORD *v15; // rcx
  signed __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  __int64 v18; // rax
  unsigned __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // r10
  unsigned __int64 v22; // rax
  __int64 v23; // rdx
  __int128 v24; // ax
  __int64 v25; // r10
  _QWORD *v26; // rax
  _QWORD *v27; // rcx
  signed __int64 v28; // rdx
  unsigned __int64 v29; // rax
  unsigned __int64 *v30; // r11
  __int128 v31; // ax
  __int64 v32; // r10
  _QWORD *v33; // rax
  _QWORD *v34; // rdx
  unsigned __int64 v35; // rdx
  unsigned __int64 v36; // rsi
  unsigned __int64 v37; // rax
  signed __int64 v38; // rdx
  unsigned __int64 v39; // rsi
  _QWORD *v40; // rax
  signed __int64 v41; // rcx
  unsigned __int64 *result; // rax
  unsigned __int64 *v43; // [rsp+10h] [rbp-158h]
  __int64 v44; // [rsp+18h] [rbp-150h]
  unsigned __int64 v45; // [rsp+30h] [rbp-138h]
  unsigned __int64 v46; // [rsp+38h] [rbp-130h]
  unsigned __int64 v47; // [rsp+70h] [rbp-F8h]
  __int64 *v48; // [rsp+78h] [rbp-F0h]
  __m128i v49; // [rsp+80h] [rbp-E8h]
  __m128i v50; // [rsp+90h] [rbp-D8h]
  __int128 v51; // [rsp+A0h] [rbp-C8h]
  unsigned __int64 v52; // [rsp+B0h] [rbp-B8h]
  __int64 v53; // [rsp+B8h] [rbp-B0h]
  unsigned __int64 v54; // [rsp+C0h] [rbp-A8h]
  __int64 v55; // [rsp+C8h] [rbp-A0h]
  unsigned __int64 v56; // [rsp+D0h] [rbp-98h]
  __int64 v57; // [rsp+D8h] [rbp-90h]
  __int128 v58; // [rsp+E0h] [rbp-88h]
  __int64 v59; // [rsp+F0h] [rbp-78h]
  __int64 v60; // [rsp+F8h] [rbp-70h]
  __int128 v61; // [rsp+100h] [rbp-68h]
  unsigned __int64 v62; // [rsp+110h] [rbp-58h]
  unsigned __int64 v63; // [rsp+118h] [rbp-50h]
  unsigned __int64 v64; // [rsp+128h] [rbp-40h]

  v47 = a2;
  v64 = __readfsqword(0x28u);
  if ( !*(_QWORD *)a1 )
    __assert_fail("x->nw > 0", "mpint.c", 0x4FEu, "mp_invert_mod_2to");
  if ( !(**(_BYTE **)(a1 + 8) & 1) )
    __assert_fail("x->w[0] & 1", "mpint.c", 0x4FFu, "mp_invert_mod_2to");
  if ( !a2 )
    goto LABEL_38;
  v2 = (a2 + 63) >> 6;
  if ( !v2 )
    v2 = 1LL;
  v3 = sub_32F60(v2);
  v4 = v2;
  if ( 2 * v2 <= v2 )
    v4 = 2 * v2;
  v5 = 6 * v4;
  v6 = (const __m128i *)sub_32F60(6 * v4 + 6 * v2);
  v48 = (__int64 *)v6;
  v49 = _mm_loadu_si128(v6);
  v7 = sub_328F0((unsigned __int64 *)&v49, v5);
  *(_QWORD *)v3[1] = 1LL;
  if ( a2 > 1 )
  {
    v9 = 1LL;
    v44 = v8;
    v45 = v7;
    v43 = (unsigned __int64 *)&v59;
    do
    {
      v10 = (v9 + 63) >> 6;
      v11 = v9 >> 6;
      v46 = (2 * v9 + 63) >> 6;
      v50 = _mm_load_si128(&v49);
      *(_QWORD *)&v12 = sub_328F0((unsigned __int64 *)&v50, v10);
      v51 = v12;
      sub_331D0((unsigned __int64 *)&v51, (unsigned __int64 *)a1);
      v13 = (1LL << v9) - 1;
      if ( v9 >> 6 < (unsigned __int64)v51 )
      {
        v14 = (_QWORD *)(*((_QWORD *)&v51 + 1) + 8 * v11);
        v15 = (_QWORD *)(*((_QWORD *)&v51 + 1) + 8 * v51);
        v16 = (1LL << v9) - 1;
        do
        {
          *v14 &= v16;
          ++v14;
          v16 = 0LL;
        }
        while ( v14 != v15 );
      }
      v17 = (v9 + 63) >> 6;
      if ( *v3 <= v10 )
        v17 = *v3;
      v18 = v3[1];
      v52 = v17;
      v53 = v18;
      v19 = sub_328F0((unsigned __int64 *)&v50, v46);
      v55 = v20;
      v54 = v19;
      sub_32940(&v52, v45, &v54, (unsigned __int64 *)&v51, v44, v21);
      v22 = sub_328F0((unsigned __int64 *)&v50, (v9 + 63) >> 6);
      v57 = v23;
      v56 = v22;
      sub_343E0(&v56, &v54, v9);
      *(_QWORD *)&v24 = sub_328F0((unsigned __int64 *)&v50, (v9 + 63) >> 6);
      v58 = v24;
      sub_343E0(&v58, (unsigned __int64 *)a1, v9);
      if ( v11 < (unsigned __int64)v58 )
      {
        v26 = (_QWORD *)(*((_QWORD *)&v58 + 1) + 8 * v11);
        v27 = (_QWORD *)(*((_QWORD *)&v58 + 1) + 8 * v58);
        v28 = (1LL << v9) - 1;
        do
        {
          *v26 &= v28;
          ++v26;
          v28 = 0LL;
        }
        while ( v27 != v26 );
      }
      v29 = (v9 + 63) >> 6;
      if ( v54 <= v10 )
        v29 = v54;
      v59 = v29;
      v60 = v55;
      sub_32940((unsigned __int64 *)&v58, v45, v43, &v52, v44, v25);
      sub_32400(v60, v59, v43, &v56, -1LL, 0LL, 0LL);
      v43 = v30;
      v62 = 0LL;
      sub_32400(v60, v59, &v62, v30, -1LL, -1LL, 1uLL);
      *(_QWORD *)&v31 = sub_328F0((unsigned __int64 *)&v50, (v9 + 63) >> 6);
      v61 = v31;
      sub_32940(v43, v45, (unsigned __int64 *)&v61, &v52, v44, v32);
      if ( v11 < (unsigned __int64)v61 )
      {
        v33 = (_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * v11);
        v34 = (_QWORD *)(*((_QWORD *)&v61 + 1) + 8 * v61);
        do
        {
          *v33 &= v13;
          ++v33;
          v13 = 0LL;
        }
        while ( v34 != v33 );
      }
      sub_34320((__int64 *)&v56, (unsigned __int64 *)&v61, v9 & 0x3F);
      v35 = v9 >> 6;
      if ( *v3 <= v11 )
        v35 = *v3;
      v36 = *v3 - v35;
      if ( v46 - v11 <= v36 )
        v36 = v46 - v11;
      v37 = v3[1];
      v62 = v36;
      v9 *= 2LL;
      v63 = v37 + 8 * v35;
      sub_32400(v37 + 8 * v35, v36, &v62, &v56, -1LL, 0LL, 0LL);
    }
    while ( v47 > v9 );
  }
  v38 = (1LL << v47) - 1;
  if ( *v3 > v47 >> 6 )
  {
    v39 = v3[1];
    v40 = (_QWORD *)(v39 + 8 * (v47 >> 6));
    v41 = v39 + 8 * *v3;
    do
    {
      *v40 &= v38;
      ++v40;
      v38 = 0LL;
    }
    while ( (_QWORD *)v41 != v40 );
  }
  sub_330F0(v48);
  result = v3;
  if ( __readfsqword(0x28u) != v64 )
LABEL_38:
    __assert_fail("p > 0", "mpint.c", 0x500u, "mp_invert_mod_2to");
  return result;
}

void __fastcall sub_35210(_QWORD **a1)
{
  sub_330F0(*a1);
  sub_330F0(a1[5]);
  sub_330F0(a1[6]);
  sub_330F0(a1[7]);
  sub_330F0(a1[4]);
  sub_330F0(a1[8]);
  sub_BD070(a1, 0x48uLL);
  sub_2F4D0(a1);
}

unsigned __int64 __fastcall sub_35260(__int64 a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // r13
  unsigned __int64 v5; // rsi
  unsigned __int64 *v6; // r12
  unsigned __int64 *v7; // rbp
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v12; // rt1
  __m128i v13; // [rsp+0h] [rbp-68h]
  unsigned __int64 v14; // [rsp+10h] [rbp-58h]
  __int64 v15; // [rsp+18h] [rbp-50h]
  __int64 v16; // [rsp+20h] [rbp-48h]
  __int64 v17; // [rsp+28h] [rbp-40h]
  unsigned __int64 v18; // [rsp+38h] [rbp-30h]

  v4 = a2;
  v5 = *(_QWORD *)(a1 + 16);
  v18 = __readfsqword(0x28u);
  if ( *a3 > v5 )
    __assert_fail("x->nw <= mc->rw", "mpint.c", 0x5B8u, "monty_mul_into");
  v6 = a4;
  if ( v5 < *a4 )
    goto LABEL_9;
  v7 = a3;
  v13 = _mm_loadu_si128((const __m128i *)*(_QWORD *)(a1 + 64));
  v8 = sub_328F0((unsigned __int64 *)&v13, 2 * v5);
  v15 = v9;
  v14 = v8;
  sub_34290(&v14, v7, v6);
  v16 = sub_33ED0(a1, &v14, v13.m128i_u64[0], v13.m128i_u64[1]);
  v17 = v10;
  sub_331D0(v4, (unsigned __int64 *)&v16);
  sub_BD070(*(void **)(*(_QWORD *)(a1 + 64) + 8LL), 8LL * **(_QWORD **)(a1 + 64));
  v12 = __readfsqword(0x28u);
  result = v12 ^ v18;
  if ( v12 != v18 )
LABEL_9:
    __assert_fail("y->nw <= mc->rw", "mpint.c", 0x5B9u, "monty_mul_into");
  return result;
}

unsigned __int64 *__fastcall sub_35380(__int64 a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r13
  unsigned __int64 *v4; // rbx

  v3 = a3;
  v4 = sub_32F60(*(_QWORD *)(a1 + 16));
  sub_35260(a1, v4, a2, v3);
  return v4;
}

__int64 __fastcall sub_353D0(__int64 a1)
{
  return *(_QWORD *)(a1 + 40);
}

unsigned __int64 __fastcall sub_353E0(__int64 a1, unsigned __int64 *a2, _QWORD *a3)
{
  __int64 v3; // rdx
  __int64 v5; // [rsp+0h] [rbp-38h]
  __int64 v6; // [rsp+8h] [rbp-30h]
  unsigned __int64 v7; // [rsp+18h] [rbp-20h]

  v7 = __readfsqword(0x28u);
  if ( *a3 > (unsigned __int64)(2LL * *(_QWORD *)(a1 + 16)) )
    __assert_fail("x->nw <= 2*mc->rw", "mpint.c", 0x5F5u, "monty_export_into");
  v5 = sub_33ED0(a1, a3, **(_QWORD **)(a1 + 64), *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8LL));
  v6 = v3;
  sub_331D0(a2, (unsigned __int64 *)&v5);
  sub_BD070(*(void **)(*(_QWORD *)(a1 + 64) + 8LL), 8LL * **(_QWORD **)(a1 + 64));
  return __readfsqword(0x28u) ^ v7;
}

unsigned __int64 *__fastcall sub_35490(__int64 a1, _QWORD *a2)
{
  unsigned __int64 *v2; // rbx

  v2 = sub_32F60(*(_QWORD *)(a1 + 16));
  sub_353E0(a1, v2, a2);
  return v2;
}

unsigned __int64 *__fastcall sub_354C0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r14
  unsigned __int64 v4; // rbp
  unsigned __int64 *v5; // r12
  unsigned __int64 *v6; // r13
  unsigned __int64 *i; // rbx
  char v8; // cl

  v3 = a3;
  v4 = 0LL;
  v5 = sub_33050(*(_QWORD *)a2, *(const void **)(a2 + 8));
  v6 = sub_33050(**(_QWORD **)(a1 + 40), *(const void **)(*(_QWORD *)(a1 + 40) + 8LL));
  for ( i = sub_32F60(2LL * *(_QWORD *)(a1 + 16)); ; sub_331D0(v5, i) )
  {
    sub_34290(i, v6, v5);
    sub_34040(a1, i);
    v8 = 0;
    if ( v4 >> 6 < *v3 )
      v8 = (*(_QWORD *)(v3[1] + 8 * (v4 >> 6)) >> v4) & 1;
    sub_33240((__int64 *)v6, v6, i, v8);
    if ( *v3 << 6 <= ++v4 )
      break;
    sub_34290(i, v5, v5);
    sub_34040(a1, i);
  }
  sub_330F0(v5);
  sub_330F0(i);
  sub_BD070(*(void **)(*(_QWORD *)(a1 + 64) + 8LL), 8LL * **(_QWORD **)(a1 + 64));
  return v6;
}

unsigned __int64 *__fastcall sub_355D0(unsigned __int64 *a1, __int64 *a2)
{
  unsigned __int64 *v2; // rbx

  v2 = sub_32F60(*a2);
  sub_346C0(v2, 0LL, 0LL, a1, (unsigned __int64 *)a2);
  return v2;
}

unsigned __int64 *__fastcall sub_35600(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rax
  unsigned __int64 *v3; // r13
  unsigned __int64 *v4; // r12
  unsigned __int64 *v5; // rbp

  v2 = sub_355D0(a2, *(__int64 **)a1);
  v3 = *(unsigned __int64 **)(a1 + 56);
  v4 = v2;
  v5 = sub_32F60(*(_QWORD *)(a1 + 16));
  sub_35260(a1, v5, v4, v3);
  sub_330F0(v4);
  return v5;
}

void __fastcall sub_35660(unsigned __int64 *a1, __int64 a2, __int64 *a3, unsigned __int64 *a4, unsigned __int64 *a5)
{
  __int64 *v5; // r15
  unsigned __int64 *v6; // rbp
  unsigned __int64 v7; // rdi
  __int64 *v8; // rax
  __int64 v9; // rdi
  __int64 *v10; // r11
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // r8
  __int64 *v13; // rdx
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  signed __int64 v16; // r8
  __int64 v17; // rax
  __int64 v18; // rdi
  unsigned __int64 v19; // r12
  _QWORD *v20; // r11
  unsigned __int64 *v21; // rbp
  unsigned __int64 *v22; // rbx
  unsigned __int64 *v23; // [rsp+0h] [rbp-58h]
  unsigned __int64 *v24; // [rsp+8h] [rbp-50h]

  v5 = a3;
  v6 = a1;
  v7 = *a1;
  if ( *(_QWORD *)a2 >= v7 )
    v7 = *(_QWORD *)a2;
  v23 = a4;
  v24 = a5;
  v8 = sub_32F60(v7);
  v9 = *v8;
  v10 = v8;
  if ( *v8 )
  {
    v11 = *v6;
    v12 = *(_QWORD *)a2;
    v13 = (__int64 *)v8[1];
    v14 = 0LL;
    do
    {
      v15 = 0LL;
      if ( v11 > v14 )
        v15 = *(_QWORD *)(v6[1] + 8 * v14);
      if ( v12 > v14 )
        v15 |= *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v14);
      v13[v14++] = v15;
    }
    while ( v14 != v9 );
    v16 = (signed __int64)&v13[v14];
    do
    {
      v17 = *v13;
      v18 = -*v13;
      ++v13;
      *(v13 - 1) = v18 & v17;
    }
    while ( v13 != (__int64 *)v16 );
  }
  v19 = sub_335B0(v10) - 1;
  sub_330F0(v20);
  v21 = sub_33050(*v6, (const void *)v6[1]);
  sub_325A0(v21, v19);
  v22 = sub_33050(*(_QWORD *)a2, *(const void **)(a2 + 8));
  sub_325A0(v22, v19);
  sub_346C0(v23, v24, v5, v21, v22);
  sub_330F0(v21);
  sub_330F0(v22);
  if ( v5 )
    sub_32720((unsigned __int64 *)v5, v19);
}

__int64 *__fastcall sub_357D0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r12
  unsigned __int64 v3; // rdi
  __int64 *v4; // rbp

  v2 = a1;
  v3 = *a1;
  if ( *a2 <= v3 )
    v3 = *a2;
  v4 = sub_32F60(v3);
  sub_35660(v2, (__int64)a2, v4, 0LL, 0LL);
  return v4;
}

unsigned __int64 __fastcall sub_35810(unsigned __int64 *a1, unsigned __int64 *a2)
{
  __int64 *v2; // rax
  signed __int64 v3; // r9
  signed __int64 v4; // rcx
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdx

  v2 = sub_357D0(a1, a2);
  v3 = 1LL;
  v4 = 1LL;
  if ( *v2 )
    v3 = *v2;
  v5 = 0LL;
  v6 = 0LL;
  do
  {
    if ( *v2 > v6 )
      v4 ^= *(_QWORD *)(v2[1] + 8 * v6);
    ++v6;
    v5 |= v4;
    v4 = 0LL;
  }
  while ( v3 != v6 );
  sub_330F0(v2);
  return ((unsigned __int64)-(signed __int64)((v5 >> 1) | v5 & 1) >> 63) ^ 1;
}

unsigned __int64 __fastcall sub_35880(unsigned __int64 *a1, __int64 *a2, unsigned __int64 *a3, unsigned __int64 *a4)
{
  __int64 *v4; // r14
  unsigned __int64 v5; // r9
  signed __int64 v6; // rsi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // r11
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rsi
  __int64 v12; // rbp
  unsigned __int64 v13; // rcx
  __int64 v14; // r8
  unsigned __int64 v15; // rdx
  signed __int64 v16; // rax
  __int64 v17; // rcx
  signed __int64 v18; // rax
  __int64 v19; // rbp
  signed __int64 v20; // r10
  unsigned __int64 v21; // r8
  signed __int64 v22; // rdx
  signed __int64 v23; // r13
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rsi
  __int64 v26; // r12
  signed __int64 v27; // rbx
  unsigned __int64 v28; // r15
  signed __int64 v29; // rdx
  int v30; // ecx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r9
  signed __int64 v33; // r13
  unsigned __int64 v34; // r9
  __int64 *v35; // rax
  unsigned __int64 *v36; // rsi
  __int64 *v37; // r13
  __int64 v38; // r9
  unsigned __int64 v39; // r15
  __int64 *v40; // rax
  __int64 v41; // rdi
  unsigned __int64 *v42; // r12
  __int64 *v43; // rbp
  unsigned __int64 *v44; // rsi
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rdi
  unsigned __int64 v48; // rax
  __int64 v49; // r10
  unsigned __int64 *v50; // r15
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // r14
  __int64 v54; // r10
  unsigned __int64 *v55; // rax
  unsigned __int64 v56; // rdx
  unsigned __int64 *v57; // r12
  unsigned __int64 v58; // rax
  __int64 v59; // rdi
  unsigned __int64 *v60; // rbp
  unsigned __int64 *v61; // rbx
  signed int v62; // er15
  unsigned int v63; // ebp
  char v64; // al
  int v65; // er11
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // r8
  unsigned __int64 v68; // rsi
  _QWORD *v69; // rax
  unsigned __int64 v70; // r15
  unsigned __int128 v71; // kr00_16
  unsigned __int64 *v73; // [rsp+8h] [rbp-E0h]
  __int64 *v74; // [rsp+10h] [rbp-D8h]
  unsigned __int64 v75; // [rsp+18h] [rbp-D0h]
  unsigned __int64 *v76; // [rsp+18h] [rbp-D0h]
  unsigned __int64 v77; // [rsp+20h] [rbp-C8h]
  unsigned __int64 *v78; // [rsp+30h] [rbp-B8h]
  unsigned __int64 *v79; // [rsp+38h] [rbp-B0h]
  unsigned __int64 *v80; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v81; // [rsp+48h] [rbp-A0h]
  unsigned __int64 v82; // [rsp+80h] [rbp-68h]
  unsigned __int64 v83; // [rsp+88h] [rbp-60h]
  unsigned __int64 v84; // [rsp+90h] [rbp-58h]
  unsigned __int64 v85; // [rsp+98h] [rbp-50h]
  unsigned __int64 v86; // [rsp+A8h] [rbp-40h]

  v4 = a2;
  v5 = *a2;
  v6 = 1LL;
  v86 = __readfsqword(0x28u);
  v7 = 0LL;
  v79 = a3;
  v78 = a1;
  v80 = a4;
  if ( v5 )
    v6 = v5;
  v8 = 0LL;
  do
  {
    if ( v5 > v7 )
      v8 |= *(_QWORD *)(v4[1] + 8 * v7);
    ++v7;
  }
  while ( v6 != v7 );
  if ( !(v8 & 1 | (v8 >> 1)) )
    __assert_fail("!mp_eq_integer(d, 0)", "mpint.c", 0x7A9u, "mp_divmod_into");
  if ( v5 )
  {
    v9 = v4[1];
    v10 = 0LL;
    v11 = 0LL;
    v12 = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    do
    {
      v15 = *(_QWORD *)(v9 + 8 * v14);
      v16 = -(signed __int64)(*(_QWORD *)(v9 + 8 * v14) & 1LL | (v15 >> 1)) >> 63;
      v10 ^= v16 & (v10 ^ v13);
      v11 ^= v16 & (v15 ^ v11);
      v17 = v14++ ^ v12;
      v18 = v17 & v16;
      v13 = v15;
      v12 ^= v18;
    }
    while ( v5 != v14 );
    v19 = v12 << 6;
  }
  else
  {
    v10 = 0LL;
    v11 = 0LL;
    v19 = 0LL;
  }
  v20 = 5LL;
  v21 = 0LL;
  do
  {
    v22 = 1LL << v20;
    v23 = 64 - (1LL << v20--);
    v24 = ((unsigned __int64)-(signed __int64)((v11 >> v23) & 1 | (v11 >> v23 >> 1)) >> 63) - 1;
    v11 ^= v24 & (v11 ^ ((v10 >> v23) | (v11 << v22)));
    v10 ^= v24 & (v10 ^ (v10 << v22));
    v21 ^= (v21 ^ (v21 + v22)) & v24;
  }
  while ( v20 != -1 );
  v25 = v11 >> 32;
  v26 = 0LL;
  v27 = 5LL;
  v28 = (27517229472LL
       - ((2430105293u
         - (v25
          * (3975772737u
           - (v25
            * (4150055939u
             - (v25
              * (2866416568u
               - (v25
                * (2620235790u - (v25 * (3057066472u - (v25 * (4131287530u - (2463826902u * v25 >> 34)) >> 34)) >> 33)) >> 32)) >> 31)) >> 31)) >> 31))
        * v25 >> 26)) << 32;
  do
  {
    v29 = -(signed __int64)((v21 >> v27) & 1);
    v30 = 1LL << v27;
    v31 = (v26 << (1LL << v27)) | (v28 >> (64 - (unsigned __int8)(1LL << v27)));
    --v27;
    v26 ^= v29 & (v26 ^ v31);
    v28 ^= (v28 ^ (v28 << v30)) & v29;
  }
  while ( v27 != -1 );
  v32 = (*v78 + v5) << 6;
  v33 = v32 + 66;
  v34 = v32 + 3;
  if ( v34 > 0xBF )
    v34 = 191LL;
  v75 = (v33 - v34) & 0xFFFFFFFFFFFFFFC0LL;
  v35 = sub_32F60((v75 + 256) >> 6);
  v36 = (unsigned __int64 *)v35;
  v37 = v35;
  sub_324D0(v35, (unsigned __int64 *)v35, v28, (v75 + 64 - v19) >> 6);
  sub_324D0(v37, v36, v26, v38 + 1);
  v39 = (v75 + 256) >> 6;
  v74 = sub_32F60(v39);
  sub_324D0(v74, (unsigned __int64 *)v74, 1LL, (v75 + 192) >> 6);
  v40 = sub_32F60(v39 + *v4);
  v41 = (v75 + 256) >> 6;
  v42 = (unsigned __int64 *)v40;
  if ( *v40 >= v39 )
    v41 = *v40;
  v43 = sub_32F60(v41);
  v44 = sub_32F60(*v43 + v39);
  v45 = *v37;
  v46 = *v37;
  if ( *v4 >= (unsigned __int64)*v37 )
    v46 = *v4;
  if ( v46 > *v42 )
    v46 = *v42;
  v47 = 6 * v46;
  if ( *v43 >= v45 )
    v45 = *v43;
  if ( v45 > *v44 )
    v45 = *v44;
  v48 = 6 * v45;
  if ( v47 < v48 )
    v47 = v48;
  v50 = sub_32F60(v47);
  v51 = *v44;
  v52 = (v75 + 191) >> 6;
  v81 = (v75 + 191) >> 6;
  if ( *v44 <= v52 )
    v52 = *v44;
  if ( *v44 - v52 <= v51 )
    v51 = *v44 - v52;
  v83 = v44[1] + 8 * v52;
  v82 = v51;
  v77 = (*v78 << 6) + 4;
  if ( v77 > 0x14 )
  {
    v76 = (unsigned __int64 *)v4;
    v53 = 20LL;
    do
    {
      v53 = 2 * v53 - 1;
      sub_32940(v76, *v50, v42, (unsigned __int64 *)v37, v50[1], v49);
      sub_32400(v43[1], *v43, v74, v42, -1LL, -1LL, 1uLL);
      sub_32940((unsigned __int64 *)v43, *v50, v44, (unsigned __int64 *)v37, v50[1], v54);
      sub_343E0(v37, &v82, 0x3FuLL);
    }
    while ( v77 > v53 );
    v4 = (__int64 *)v76;
  }
  sub_330F0(v42);
  sub_330F0(v43);
  sub_330F0(v44);
  sub_330F0(v50);
  v55 = sub_342F0((unsigned __int64 *)v37, v78);
  v56 = *v55;
  v57 = v55;
  v58 = v81;
  if ( v81 > v56 )
    v58 = v56;
  if ( v56 - v58 <= v56 )
    v56 -= v58;
  v59 = *v78;
  v85 = v57[1] + 8 * v58;
  v84 = v56;
  v60 = sub_32F60(v59);
  sub_343E0(v60, &v84, 0x3FuLL);
  v61 = sub_32F60(*v4);
  sub_34290(v61, v60, (unsigned __int64 *)v4);
  v62 = 2;
  sub_32400(v61[1], *v61, v78, v61, -1LL, -1LL, 1uLL);
  v73 = v60;
  v63 = 0;
  while ( 1 )
  {
    v64 = sub_33E30(v61, (unsigned __int64 *)v4);
    sub_32400(
      v61[1],
      *v61,
      v61,
      (unsigned __int64 *)v4,
      -(signed __int64)(v64 & 1),
      -(signed __int64)(v64 & 1),
      v64 & 1);
    v63 += v65;
    if ( v62 == 1 )
      break;
    v62 = 1;
  }
  v66 = *v73;
  v67 = v73[1];
  if ( *v73 )
  {
    v68 = v63;
    v69 = (_QWORD *)v73[1];
    v70 = 0LL;
    do
    {
      v71 = v70 + (unsigned __int128)v68 + (unsigned __int64)*v69;
      v70 = *((_QWORD *)&v71 + 1);
      if ( v67 )
        *v69 = v71;
      ++v69;
      v68 = 0LL;
    }
    while ( v69 != (_QWORD *)(v67 + 8 * v66) );
  }
  if ( (unsigned int)sub_33E30(v61, (unsigned __int64 *)v4) )
    __assert_fail("!mp_cmp_hs(remainder, d)", "mpint.c", 0x8BAu, "mp_divmod_into");
  if ( v79 )
    sub_331D0(v79, v73);
  if ( v80 )
    sub_331D0(v80, v61);
  sub_330F0(v37);
  sub_330F0(v74);
  sub_330F0(v57);
  sub_330F0(v73);
  sub_330F0(v61);
  return __readfsqword(0x28u) ^ v86;
}

unsigned __int64 *__fastcall sub_35FB0(unsigned __int64 *a1, __int64 *a2)
{
  unsigned __int64 *v2; // rbx

  v2 = sub_32F60(*a2);
  sub_35880(a1, a2, 0LL, v2);
  return v2;
}

unsigned __int64 *__fastcall sub_362D0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 *a3)
{
  __int64 *v3; // rbp
  unsigned __int64 *v4; // rbx
  unsigned __int64 *v5; // rbp

  v3 = a3;
  v4 = sub_342F0(a1, a2);
  v5 = sub_35FB0(v4, v3);
  sub_330F0(v4);
  return v5;
}

__int64 **__fastcall sub_36310(__int64 *a1)
{
  __int64 *v1; // rbp
  __int64 **v2; // rax
  __int64 v3; // rdi
  __int64 **v4; // rbx
  const void *v5; // rsi
  __int64 *v6; // rax
  unsigned __int64 v7; // rsi
  unsigned __int64 *v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rsi
  unsigned __int64 *v11; // rax
  unsigned __int64 *v12; // rbp
  __int64 *v13; // rsi
  unsigned __int64 *v14; // rax
  unsigned __int64 *v15; // rdi
  __int64 *v16; // rdx
  __int64 *v17; // rax
  __int64 *v18; // rcx
  signed __int64 v19; // rdx
  __int64 **result; // rax
  __int64 **v21; // [rsp-10h] [rbp-48h]
  __int64 v22; // [rsp+0h] [rbp-38h]
  unsigned __int64 v23; // [rsp+18h] [rbp-20h]

  v1 = a1;
  v23 = __readfsqword(0x28u);
  v2 = (__int64 **)sub_2F450(1uLL, 0x48uLL, 0LL);
  v3 = *a1;
  v4 = v2;
  v5 = (const void *)v1[1];
  v2[2] = (__int64 *)*v1;
  v2[1] = (__int64 *)(v3 << 6);
  v2[3] = (__int64 *)(2 * v3 + 1);
  v6 = sub_33050(v3, v5);
  v7 = (unsigned __int64)v4[1];
  *v4 = v6;
  v8 = sub_34CB0((__int64)v6, v7);
  v22 = 0LL;
  v9 = v8[1];
  v10 = *v8;
  v4[4] = (__int64 *)v8;
  sub_32400(v9, v10, &v22, v8, -1LL, -1LL, 1uLL);
  v11 = sub_32F60((__int64)v4[2] + 1);
  v12 = v11;
  v13 = *v4;
  *(_QWORD *)(v11[1] + 8LL * (_QWORD)v4[2]) = 1LL;
  v4[5] = (__int64 *)sub_35FB0(v11, v13);
  sub_330F0(v12);
  v14 = sub_362D0((unsigned __int64 *)v4[5], (unsigned __int64 *)v4[5], *v4);
  v15 = (unsigned __int64 *)v4[5];
  v16 = *v4;
  v4[6] = (__int64 *)v14;
  v4[7] = (__int64 *)sub_362D0(v15, v14, v16);
  v17 = v4[2];
  v18 = v4[3];
  v19 = (signed __int64)v18 + 3 * (_QWORD)v17;
  if ( v17 > v18 )
    v17 = v4[3];
  v4[8] = sub_32F60(v19 + 6LL * (_QWORD)v17);
  result = v21;
  if ( __readfsqword(0x28u) == v23 )
    result = v4;
  return result;
}

unsigned __int64 *__fastcall sub_36450(__int64 a1, unsigned __int64 *a2)
{
  return sub_362D0(a2, *(unsigned __int64 **)(a1 + 40), *(__int64 **)a1);
}

void __fastcall sub_36470(__int64 a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbx

  v3 = sub_362D0(a3, *(unsigned __int64 **)(a1 + 40), *(__int64 **)a1);
  sub_331D0(a2, v3);
  sub_330F0(v3);
}

unsigned __int64 *__fastcall sub_364B0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 **v3; // rbx
  unsigned __int64 *v4; // r13
  unsigned __int64 *v5; // r12
  unsigned __int64 *v6; // rbp

  if ( !*(_QWORD *)a3 )
    __assert_fail("modulus->nw > 0", "mpint.c", 0x62Bu, "mp_modpow");
  if ( !(**(_BYTE **)(a3 + 8) & 1) )
    __assert_fail("modulus->w[0] & 1", "mpint.c", 0x62Cu, "mp_modpow");
  v3 = sub_36310((__int64 *)a3);
  v4 = sub_362D0(a1, (unsigned __int64 *)v3[5], *v3);
  v5 = sub_354C0((__int64)v3, (__int64)v4, a2);
  v6 = sub_32F60((__int64)v3[2]);
  sub_353E0((__int64)v3, v6, v5);
  sub_330F0(v4);
  sub_330F0(v5);
  sub_35210(v3);
  return v6;
}

unsigned __int64 *__fastcall sub_36590(_QWORD *a1, unsigned __int64 *a2, __int64 *a3)
{
  __int64 *v3; // rbp
  unsigned __int64 *v4; // rbx
  unsigned __int64 *v5; // rbp

  v3 = a3;
  v4 = (unsigned __int64 *)sub_341F0(a1, a2);
  v5 = sub_35FB0(v4, v3);
  sub_330F0(v4);
  return v5;
}

__int64 *__fastcall sub_36770(__int64 **a1, _QWORD *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r13
  __int64 *v4; // rbp
  __int64 *v5; // rbx
  unsigned __int8 v6; // al
  unsigned __int8 v7; // cl

  v3 = a3;
  v4 = *a1;
  v5 = sub_32F60(**a1);
  sub_32400(v5[1], *v5, a2, v3, -1LL, 0LL, 0LL);
  v6 = sub_33E30((unsigned __int64 *)v5, (unsigned __int64 *)v4);
  sub_32400(
    v5[1],
    *v5,
    v5,
    (unsigned __int64 *)v4,
    -(signed __int64)((v7 | v6) & 1),
    -(signed __int64)((v7 | v6) & 1),
    (v7 | v6) & 1);
  return v5;
}

__int64 *__fastcall sub_36800(__int64 **a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r13
  __int64 *v4; // rbp
  __int64 *v5; // rbx
  char v6; // al

  v3 = a3;
  v4 = *a1;
  v5 = sub_32F60(**a1);
  sub_32400(v5[1], *v5, a2, v3, -1LL, -1LL, 1uLL);
  v6 = sub_33E30(a2, v3);
  sub_32400(v5[1], *v5, v5, (unsigned __int64 *)v4, -(signed __int64)(~v6 & 1), 0LL, 0LL);
  return v5;
}

void __fastcall sub_36890(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbp
  char v4; // al

  v3 = a3;
  v4 = sub_33E30(a2, a3);
  sub_33240(a1, a2, v3, v4);
}

void __fastcall sub_368C0(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rbp
  unsigned __int64 *v4; // rsi
  char v5; // al

  v3 = a2;
  v4 = a3;
  v5 = sub_33E30(v3, a3);
  sub_33240(a1, v4, v3, v5);
}

__int64 *__fastcall sub_368F0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r12
  unsigned __int64 v3; // rdi
  __int64 *v4; // rbp

  v2 = a1;
  v3 = *a1;
  if ( *a2 <= v3 )
    v3 = *a2;
  v4 = sub_32F60(v3);
  sub_36890(v4, v2, a2);
  return v4;
}

__int64 *__fastcall sub_36930(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r12
  unsigned __int64 v3; // rdi
  __int64 *v4; // rbp

  v2 = a1;
  v3 = *a1;
  if ( *a2 >= v3 )
    v3 = *a2;
  v4 = sub_32F60(v3);
  sub_368C0(v4, v2, a2);
  return v4;
}

unsigned __int64 *__fastcall sub_36970(unsigned __int64 a1)
{
  unsigned __int64 *v1; // rbx

  v1 = sub_32F60((a1 + 64) >> 6);
  sub_33550(v1, a1, 1);
  return v1;
}

__int64 **__fastcall sub_369B0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // r12
  __int64 **v3; // rax
  __int64 **v4; // rbx
  __int64 *v5; // rax
  __int64 **v6; // rax
  unsigned __int64 *v7; // rsi
  __int64 *v8; // rdx
  unsigned __int64 *v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  unsigned __int64 *v13; // rax

  v2 = a2;
  v3 = (__int64 **)sub_2F450(1uLL, 0x38uLL, 0LL);
  v3[6] = 0LL;
  v4 = v3;
  *(_OWORD *)v3 = 0LL;
  *((_OWORD *)v3 + 1) = 0LL;
  *((_OWORD *)v3 + 2) = 0LL;
  v5 = sub_33050(*(_QWORD *)a1, *(const void **)(a1 + 8));
  *v4 = v5;
  v6 = sub_36310(v5);
  v7 = (unsigned __int64 *)v6[5];
  v8 = *v6;
  v4[1] = (__int64 *)v6;
  v9 = sub_362D0(v2, v7, v8);
  v10 = *(_QWORD *)a1;
  v4[5] = (__int64 *)v9;
  v11 = 1LL;
  v4[2] = (__int64 *)(&n + 1);
  if ( v10 << 6 > 1 )
  {
    do
    {
      if ( v11 >> 6 < v10 )
      {
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * (v11 >> 6));
        if ( _bittest64(&v12, v11) )
          break;
      }
      v4[2] = (__int64 *)++v11;
    }
    while ( v11 != v10 << 6 );
  }
  v13 = sub_34B90((unsigned __int64 *)a1, v11);
  v4[3] = (__int64 *)v13;
  v4[4] = sub_34B90(v13, 1uLL);
  return v4;
}

void __fastcall sub_36A90(_QWORD **a1)
{
  void *v1; // rbx
  _QWORD *v2; // rdi

  v1 = a1;
  sub_35210((_QWORD **)a1[1]);
  sub_330F0(*a1);
  sub_330F0(a1[5]);
  sub_330F0(a1[3]);
  sub_330F0(a1[4]);
  v2 = a1[6];
  if ( v2 )
    sub_330F0(v2);
  sub_2F4D0(v1);
}

unsigned __int64 *__fastcall sub_36AE0(__int64 a1, unsigned __int64 *a2, _DWORD *a3)
{
  __int64 v3; // r15
  unsigned __int64 *v4; // r13
  __int64 v5; // rdi
  const __m128i *v6; // rax
  unsigned __int64 *v7; // rdx
  __int64 v8; // rdi
  __int64 v9; // rdx
  unsigned __int64 v10; // rbp
  __int64 v11; // rax
  __int64 v12; // rdx
  unsigned __int64 v13; // rax
  unsigned __int64 *v14; // rsi
  __int64 v15; // rdx
  signed __int64 v16; // r12
  unsigned __int64 v17; // r14
  int v18; // eax
  signed __int64 v19; // rsi
  unsigned __int64 v20; // rdx
  bool v21; // cf
  bool v22; // zf
  __int64 v24; // rdi
  char v25; // ST00_1
  unsigned __int64 *v26; // rax
  __int64 v27; // [rsp+0h] [rbp-B8h]
  unsigned __int64 *v28; // [rsp+10h] [rbp-A8h]
  _DWORD *v29; // [rsp+18h] [rbp-A0h]
  __int64 *v30; // [rsp+28h] [rbp-90h]
  __m128i v31; // [rsp+30h] [rbp-88h]
  unsigned __int64 v32; // [rsp+40h] [rbp-78h]
  __int64 v33; // [rsp+48h] [rbp-70h]
  unsigned __int64 v34; // [rsp+50h] [rbp-68h]
  __int64 v35; // [rsp+58h] [rbp-60h]
  unsigned __int64 v36; // [rsp+60h] [rbp-58h]
  __int64 v37; // [rsp+68h] [rbp-50h]
  unsigned __int64 v38; // [rsp+78h] [rbp-40h]

  v3 = a1;
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 8);
  v38 = __readfsqword(0x28u);
  v29 = a3;
  if ( !*(_QWORD *)(v3 + 48) )
  {
    v26 = sub_354C0(v5, *(_QWORD *)(v3 + 40), *(unsigned __int64 **)(v3 + 24));
    v5 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 48) = v26;
  }
  v6 = (const __m128i *)sub_32F60(3LL * *(_QWORD *)(v5 + 16));
  v7 = *(unsigned __int64 **)(v3 + 32);
  v8 = *(_QWORD *)(v3 + 8);
  v30 = (__int64 *)v6;
  v31 = _mm_loadu_si128(v6);
  v28 = sub_354C0(v8, (__int64)a2, v7);
  v32 = sub_328F0((unsigned __int64 *)&v31, *(_QWORD *)(*(_QWORD *)(v3 + 8) + 16LL));
  v33 = v9;
  sub_331D0(&v32, v28);
  sub_35260(*(_QWORD *)(v3 + 8), v28, v28, a2);
  v10 = 0LL;
  sub_35260(*(_QWORD *)(v3 + 8), &v32, v28, &v32);
  v34 = sub_328F0((unsigned __int64 *)&v31, *(_QWORD *)(*(_QWORD *)(v3 + 8) + 16LL));
  v11 = *(_QWORD *)(v3 + 8);
  v35 = v12;
  v13 = sub_328F0((unsigned __int64 *)&v31, *(_QWORD *)(v11 + 16));
  v14 = *(unsigned __int64 **)(v3 + 48);
  v36 = v13;
  v37 = v15;
  sub_331D0(&v36, v14);
  while ( *(_QWORD *)(v3 + 16) > v10 )
  {
    while ( 1 )
    {
      v16 = v10 + 1;
      sub_331D0(&v34, &v32);
      if ( v10 + 1 < *(_QWORD *)(v3 + 16) )
      {
        v17 = v10 + 1;
        do
        {
          ++v17;
          sub_35260(*(_QWORD *)(v3 + 8), &v34, &v34, &v34);
        }
        while ( *(_QWORD *)(v3 + 16) > v17 );
      }
      v27 = *(_QWORD *)(v3 + 8);
      v18 = sub_34130(&v34, *(unsigned __int64 **)(*(_QWORD *)(v3 + 8) + 40LL));
      if ( v10 )
        break;
      v19 = 1LL;
      if ( *v4 )
        v19 = *v4;
      v20 = 0LL;
      while ( 1 )
      {
        if ( *v4 > v10 )
          v20 |= *(_QWORD *)(v4[1] + 8 * v10);
        v10 = v16;
        if ( v19 == v16 )
          break;
        ++v16;
      }
      v10 = 1LL;
      v21 = *(_QWORD *)(v3 + 16) < 1uLL;
      v22 = *(_QWORD *)(v3 + 16) == 1LL;
      *v29 = ((unsigned __int64)-(signed __int64)((v20 >> 1) | v20 & 1) >> 63) ^ 1 | v18;
      if ( v21 || v22 )
        goto LABEL_17;
    }
    v24 = v27;
    v25 = v18;
    sub_35260(v24, &v34, v28, &v36);
    ++v10;
    sub_33240((__int64 *)v28, &v34, v28, v25);
    sub_35260(*(_QWORD *)(v3 + 8), &v36, &v36, &v36);
    sub_35260(*(_QWORD *)(v3 + 8), &v34, &v32, &v36);
    sub_33240((__int64 *)&v32, &v34, &v32, v25);
  }
LABEL_17:
  sub_330F0(v30);
  return v28;
}

_QWORD *__fastcall sub_36E00(__int64 a1, void (__fastcall *a2)(_BYTE *, unsigned __int64))
{
  unsigned __int64 v2; // rbx
  _BYTE *v3; // rbp
  _QWORD *v4; // r12

  v2 = (unsigned __int64)(a1 + 7) >> 3;
  v3 = sub_2F450(v2, 1uLL, 0LL);
  a2(v3, v2);
  if ( v2 )
    *v3 &= (2 << ((a1 - 1) & 7)) - 1;
  v4 = sub_32FD0((__int64)v3, v2, -1LL, v2 - 1);
  sub_BD070(v3, v2);
  sub_2F4D0(v3);
  return v4;
}

unsigned __int64 *__fastcall sub_36E90(__int64 *a1, void (__fastcall *a2)(_BYTE *, unsigned __int64))
{
  unsigned __int64 *v2; // rbx
  unsigned __int64 *v3; // rbp

  v2 = sub_36E00((*a1 << 6) + 128, a2);
  v3 = sub_35FB0(v2, a1);
  sub_330F0(v2);
  return v3;
}

__int64 *__fastcall sub_36ED0(unsigned __int64 *a1, unsigned __int64 *a2, void (__fastcall *a3)(_BYTE *, unsigned __int64))
{
  void (__fastcall *v3)(_BYTE *, unsigned __int64); // r12
  __int64 *v4; // rbp
  unsigned __int64 *v5; // r12
  __int64 *v6; // rbx

  v3 = a3;
  v4 = (__int64 *)sub_34240(a2, a1);
  v5 = sub_36E90(v4, v3);
  v6 = sub_32F60(*a2);
  sub_32400(v6[1], *v6, v5, a1, -1LL, 0LL, 0LL);
  sub_330F0(v5);
  sub_330F0(v4);
  return v6;
}

void nullsub_6()
{
  ;
}

void nullsub_7()
{
  ;
}

void nullsub_8()
{
  ;
}

void nullsub_9()
{
  ;
}

__int64 __fastcall sub_36F90(unsigned int *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( (_DWORD)result )
  {
    result = sub_99D00((unsigned int)(1000 * result), (__int64)&off_36FF0, (__int64)a1);
    if ( !*((_BYTE *)a1 + 4)
      || (unsigned __int64)(result - *((_QWORD *)a1 + 1)) < *((_QWORD *)a1 + 2) - *((_QWORD *)a1 + 1) )
    {
      *((_QWORD *)a1 + 2) = result;
      result = sub_99DF0();
      *((_BYTE *)a1 + 4) = 1;
      *((_QWORD *)a1 + 1) = result;
    }
  }
  else
  {
    *((_BYTE *)a1 + 4) = 0;
  }
  return result;
}

_QWORD *__fastcall sub_37030(__int64 *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  int v3; // eax

  v2 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v3 = sub_1EFD0(a1, 6);
  v2[3] = a2;
  *(_DWORD *)v2 = v3;
  *((_BYTE *)v2 + 4) = 0;
  sub_36F90((unsigned int *)v2);
  return v2;
}

__int64 __fastcall sub_37080(unsigned int *a1, __int64 *a2, __int64 *a3)
{
  unsigned int v3; // ebx
  __int64 result; // rax

  v3 = sub_1EFD0(a3, 6);
  result = sub_1EFD0(a2, 6);
  if ( (_DWORD)result != v3 )
  {
    *a1 = v3;
    result = sub_36F90(a1);
  }
  return result;
}

void __fastcall sub_370D0(void *a1)
{
  sub_99EF0((__int64)a1);
  sub_2F4D0(a1);
}

void nullsub_10()
{
  ;
}

__int64 __fastcall sub_37100(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 - 64);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v1 + 24LL))();
  return result;
}

char *sub_37120()
{
  return sub_BC120("Forwarded port closed");
}

void __fastcall sub_37130(__int64 (__fastcall ***a1)())
{
  __int64 v1; // rax

  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x296u, "pfd_open_confirmation");
  *((_BYTE *)a1 - 47) = 1;
  (*((void (__fastcall **)(_QWORD, _QWORD))**(a1 - 7) + 5))(*(a1 - 7), 0LL);
  (*((void (__fastcall **)(_QWORD, _QWORD, _QWORD))**(a1 - 7) + 2))(*(a1 - 7), 0LL, 0LL);
  v1 = (__int64)*(a1 - 3);
  if ( v1 )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, char *, _QWORD))**(a1 - 9))(
      *(a1 - 9),
      0LL,
      (char *)*(a1 - 2) + *(_QWORD *)(v1 + 8),
      *(_QWORD *)(v1 + 16) - (_QWORD)*(a1 - 2));
    sub_BC660((void **)*(a1 - 3));
    *(a1 - 3) = 0LL;
  }
}

char *__fastcall sub_371C0(unsigned int a1)
{
  return sub_BC360((__int64)"%u.%u.%u.%u", a1 >> 24, BYTE2(a1), BYTE1(a1), (unsigned __int8)a1);
}

__int64 __fastcall sub_371F0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  unsigned int v6; // er13
  __int64 v7; // rax
  void **v8; // rbx
  char *v9; // r15
  __int64 v10; // rbp

  v5 = a5;
  v6 = a3;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 56LL))(a4);
  v8 = (void **)v7;
  if ( v7 && *(_QWORD *)(v7 + 40) )
    v9 = sub_BC360((__int64)"forwarding from %s");
  else
    v9 = sub_BC120("forwarding");
  v10 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, char *, void **, __int64))(*(_QWORD *)(a1 + 8) + 16LL))(
          a1,
          a2,
          v6,
          v9,
          v8,
          v5);
  sub_32240(v8);
  sub_2F4D0(v9);
  return v10;
}

__int64 __fastcall sub_37290(__int64 (__fastcall ***a1)(), char a2)
{
  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x275u, "pfd_set_input_wanted");
  *((_BYTE *)a1 - 48) = a2;
  return (*((__int64 (__fastcall **)(_QWORD, _QWORD))**(a1 - 7) + 5))(*(a1 - 7), (unsigned __int8)(a2 ^ 1));
}

__int64 __fastcall sub_372E0(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x28Fu, "pfd_send_eof");
  return (*((__int64 (**)(void))**(a1 - 7) + 4))();
}

__int64 __fastcall sub_37320(__int64 (__fastcall ***a1)(), __int64 a2, __int64 a3, __int64 a4)
{
  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x288u, "pfd_send");
  return (*((__int64 (__fastcall **)(_QWORD, __int64, __int64))**(a1 - 7) + 2))(*(a1 - 7), a3, a4);
}

unsigned __int64 __usercall sub_37370@<rax>(__int64 (__fastcall ***a1)()@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x2A6u, "pfd_open_failure");
  return sub_2D3F0((__int64)**(a1 - 8), (__int64)"Forwarded connection refused by remote%s%s", a2, a3);
}

void __fastcall sub_373D0(__int64 a1)
{
  void *v1; // rbx
  void **v2; // rdi

  v1 = (void *)a1;
  sub_2F4D0(*(void **)(a1 + 32));
  v2 = *(void ***)(a1 + 48);
  if ( v2 )
    sub_BC660(v2);
  sub_2F4D0(v1);
}

void __fastcall sub_37400(__int64 a1)
{
  if ( a1 )
  {
    (*(void (**)(void))(**(_QWORD **)(a1 + 16) + 8LL))();
    sub_373D0(a1);
  }
}

unsigned __int64 __fastcall sub_37430(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r12
  __int64 v5; // rbp
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rt1
  __int64 v8; // rax
  _BYTE *v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rsi
  unsigned int v12; // eax
  char *v13; // rax
  __int64 v14; // rdx
  signed __int64 v15; // rcx
  char *v16; // rdx
  signed int v17; // er14
  int v18; // eax
  signed __int64 v19; // r15
  __int64 v20; // rax
  char v21; // r15
  char v22; // r14
  char v23; // al
  signed int v24; // er14
  int v25; // eax
  bool v26; // zf
  signed int v27; // eax
  signed int v28; // er13
  signed __int64 v29; // rax
  __int64 (__fastcall **v30)(_QWORD, char *, signed __int64); // r15
  signed __int64 v31; // r14
  __int64 v32; // rax
  char v33; // r14
  char v34; // al
  bool v35; // r14
  int v36; // er15
  unsigned int v37; // er13
  char *v38; // rax
  int v39; // edx
  signed __int64 v40; // rax
  __int64 (__fastcall **v41)(_QWORD, char *, signed __int64); // r14
  signed __int64 v42; // r13
  __int64 v43; // rax
  signed __int64 v44; // rax
  __int64 (__fastcall **v45)(_QWORD, char *, signed __int64); // r12
  signed __int64 v46; // rbp
  char v47; // al
  char *v48; // rax
  size_t v49; // rdx
  unsigned int v50; // eax
  unsigned __int16 *v51; // rax
  __int64 v52; // rdx
  signed __int64 v53; // rax
  __int64 (__fastcall **v54)(_QWORD, char *, signed __int64); // r12
  signed __int64 v55; // rbp
  __int64 v56; // [rsp+0h] [rbp-78h]
  _BYTE *v57; // [rsp+10h] [rbp-68h]
  __int64 v58; // [rsp+18h] [rbp-60h]
  __int64 v59; // [rsp+20h] [rbp-58h]
  int v60; // [rsp+28h] [rbp-50h]
  __int64 *v61; // [rsp+30h] [rbp-48h]
  unsigned __int64 v62; // [rsp+38h] [rbp-40h]

  v62 = __readfsqword(0x28u);
  if ( !a4 )
    goto LABEL_5;
  v4 = a3;
  v5 = a4;
  if ( !*(_DWORD *)(a1 - 36) )
  {
LABEL_3:
    if ( *(_BYTE *)(a1 - 39) )
      (***(void (__fastcall ****)(_QWORD, _QWORD, __int64, __int64))(a1 - 64))(*(_QWORD *)(a1 - 64), 0LL, v4, v5);
    goto LABEL_5;
  }
  v56 = a1 - 64;
  sub_2EC20((__int64 (**)(void))(*(_QWORD *)(a1 - 16) + 24LL));
  v8 = *(_QWORD *)(a1 - 16);
  v9 = *(_BYTE **)(v8 + 8);
  if ( *(_DWORD *)(a1 - 36) == 1 )
  {
    if ( *v9 == 4 )
    {
      *(_DWORD *)(a1 - 36) = 2;
    }
    else
    {
      if ( *v9 != 5 )
        goto LABEL_46;
      *(_DWORD *)(a1 - 36) = 3;
    }
  }
  v10 = *(_QWORD *)(v8 + 16);
  v11 = *(_QWORD *)(a1 - 8);
  v57 = v9;
  v58 = 0LL;
  v60 = 0;
  v61 = (__int64 *)&v57;
  v59 = v10;
  sub_2F040((__int64)&v57, v11);
  v12 = *(_DWORD *)(a1 - 36);
  if ( !v12 )
  {
LABEL_33:
    (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(a1 - 48) + 40LL))(*(_QWORD *)(a1 - 48), 1LL);
    *(_QWORD *)(a1 - 64) = sub_371F0(
                             *(_QWORD *)(a1 - 56),
                             *(_QWORD *)(a1 - 32),
                             *(_DWORD *)(a1 - 24),
                             *(_QWORD *)(a1 - 48),
                             a1 + 8);
    goto LABEL_3;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v12 == 2 )
      {
        v33 = sub_2F080((__int64)v61);
        v34 = sub_2F080((__int64)v61);
        if ( *((_DWORD *)v61 + 6) == 1 )
          goto LABEL_5;
        v35 = v34 == 1 && v33 == 4;
        if ( !v35 )
          goto LABEL_66;
        v36 = sub_2F100((__int64)v61);
        v37 = sub_2F150((__int64)v61);
        if ( v37 - 1 <= 0xFE )
        {
          sub_2F240((__int64)v61);
          v38 = sub_2F240((__int64)v61);
        }
        else
        {
          sub_2F240((__int64)v61);
          v35 = 0;
          v38 = 0LL;
        }
        v39 = *((_DWORD *)v61 + 6);
        if ( v39 == 1 )
          goto LABEL_5;
        if ( v39 )
        {
LABEL_66:
          v53 = sub_BC640();
          v54 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v53 + 24);
          v55 = v53;
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v53 + 24), 0);
          sub_2ECE0(v54, 91);
          sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v54, 0);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v54, 0);
          (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 48) + 16LL))(
            *(_QWORD *)(a1 - 48),
            *(_QWORD *)(v55 + 8),
            *(_QWORD *)(v55 + 16));
          sub_BC660((void **)v55);
          sub_37400(v56);
          goto LABEL_5;
        }
        *(_DWORD *)(a1 - 24) = v36;
        if ( v35 )
          *(_QWORD *)(a1 - 32) = sub_BC120(v38);
        else
          *(_QWORD *)(a1 - 32) = sub_371C0(v37);
        v40 = sub_BC640();
        v41 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v40 + 24);
        v42 = v40;
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v40 + 24), 0);
        sub_2ECE0(v41, 90);
        sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v41, 0);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v41, 0);
        (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 48) + 16LL))(
          *(_QWORD *)(a1 - 48),
          *(_QWORD *)(v42 + 8),
          *(_QWORD *)(v42 + 16));
        sub_BC660((void **)v42);
        v43 = v58;
        *(_DWORD *)(a1 - 36) = 0;
        *(_QWORD *)(a1 - 8) = v43;
        goto LABEL_33;
      }
      if ( v12 > 2 )
        break;
      if ( v12 == 1 )
        __assert_fail("false && \"These case values cannot appear\"", "portfwd.c", 0xF6u, "pfd_receive");
    }
    if ( v12 == 3 )
      break;
    if ( v12 == 4 )
      goto LABEL_25;
  }
  sub_2F080((__int64)v61);
  v13 = sub_2F370((__int64)v61);
  if ( !v14 )
    goto LABEL_20;
  if ( *v13 )
  {
    v15 = (signed __int64)(v13 + 1);
    v16 = &v13[v14];
    while ( (char *)v15 != v16 )
    {
      if ( !*(_BYTE *)(++v15 - 1) )
        goto LABEL_47;
    }
LABEL_20:
    v17 = 255;
  }
  else
  {
LABEL_47:
    v17 = 0;
  }
  v18 = *((_DWORD *)v61 + 6);
  if ( v18 != 1 )
  {
    if ( v18 )
    {
      v44 = sub_BC640();
      v45 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v44 + 24);
      v46 = v44;
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v44 + 24), 5);
      sub_2ECE0(v45, 255);
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 48) + 16LL))(
        *(_QWORD *)(a1 - 48),
        *(_QWORD *)(v46 + 8),
        *(_QWORD *)(v46 + 16));
      sub_BC660((void **)v46);
      goto LABEL_46;
    }
    v19 = sub_BC640();
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24), 5);
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24), v17);
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 48) + 16LL))(
      *(_QWORD *)(a1 - 48),
      *(_QWORD *)(v19 + 8),
      *(_QWORD *)(v19 + 16));
    sub_BC660((void **)v19);
    if ( v17 == 255 )
      goto LABEL_46;
    v20 = v58;
    *(_DWORD *)(a1 - 36) = 4;
    *(_QWORD *)(a1 - 8) = v20;
LABEL_25:
    v21 = sub_2F080((__int64)v61);
    v22 = sub_2F080((__int64)v61);
    v23 = sub_2F080((__int64)v61);
    if ( v22 != 1 || v21 != 5 || v23 )
    {
      v24 = 7;
      goto LABEL_28;
    }
    v47 = sub_2F080((__int64)v61);
    if ( v47 != 3 )
    {
      if ( v47 != 4 )
      {
        if ( v47 == 1 )
        {
          v24 = 0;
          v50 = sub_2F150((__int64)v61);
          *(_QWORD *)(a1 - 32) = sub_371C0(v50);
        }
        else
        {
          *(_QWORD *)(a1 - 32) = 0LL;
          v24 = 8;
        }
        goto LABEL_57;
      }
      v51 = (unsigned __int16 *)sub_2F040((__int64)v61, 0x10uLL);
      if ( v52 == 16 )
      {
        v24 = 0;
        *(_QWORD *)(a1 - 32) = sub_BC360(
                                 (__int64)"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
                                 _byteswap_ushort(*v51),
                                 _byteswap_ushort(v51[1]),
                                 _byteswap_ushort(v51[2]),
                                 _byteswap_ushort(v51[3]),
                                 _byteswap_ushort(v51[4]),
                                 _byteswap_ushort(v51[5]),
                                 _byteswap_ushort(v51[6]),
                                 _byteswap_ushort(v51[7]));
        goto LABEL_57;
      }
LABEL_63:
      __assert_fail("ipv6.len == 16", "portfwd.c", 0xB7u, "ipv6_to_string");
    }
    v24 = 0;
    v48 = sub_2F370((__int64)v61);
    *(_QWORD *)(a1 - 32) = sub_BD360(v48, v49);
LABEL_57:
    *(_DWORD *)(a1 - 24) = sub_2F100((__int64)v61);
LABEL_28:
    v25 = *((_DWORD *)v61 + 6);
    if ( v25 != 1 )
    {
      v26 = v25 == 0;
      v27 = 1;
      if ( v26 )
        v27 = v24;
      v28 = v27;
      v29 = sub_BC640();
      v30 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v29 + 24);
      v31 = v29;
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v29 + 24), 5);
      sub_2ECE0(v30, v28);
      sub_2ECE0(v30, 0);
      sub_2ECE0(v30, 1);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v30, 0);
      sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v30, 0);
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 - 48) + 16LL))(
        *(_QWORD *)(a1 - 48),
        *(_QWORD *)(v31 + 8),
        *(_QWORD *)(v31 + 16));
      sub_BC660((void **)v31);
      if ( !v28 )
      {
        v32 = v58;
        *(_DWORD *)(a1 - 36) = 0;
        *(_QWORD *)(a1 - 8) = v32;
        goto LABEL_33;
      }
LABEL_46:
      sub_37400(v56);
    }
  }
LABEL_5:
  v7 = __readfsqword(0x28u);
  result = v7 ^ v62;
  if ( v7 != v62 )
    goto LABEL_63;
  return result;
}

void __fastcall sub_37AD0(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_323D80 )
    __assert_fail("chan->vt == &PortForwarding_channelvt", "portfwd.c", 0x27Du, "pfd_chan_free");
  sub_37400((__int64)(a1 - 9));
}

void __fastcall sub_37B10(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(a1 - 64);
  if ( a2 )
  {
    if ( v2 )
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2 + 16LL))(*(_QWORD *)(a1 - 64));
    else
      sub_37400(a1 - 64);
  }
  else if ( v2 )
  {
    (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2 + 8LL))(*(_QWORD *)(a1 - 64));
  }
}

char *__fastcall sub_37B60(char *src, int a2, __int64 a3, unsigned int a4, __int64 a5, __int64 *a6, _QWORD *a7, unsigned int a8)
{
  __int64 v8; // r12
  unsigned int v9; // er13
  __int64 v10; // r14
  __int64 *v11; // rbx
  void *v12; // rbp
  char v13; // al
  __int64 *v14; // rax
  __int64 v15; // rdx
  char *v16; // rax
  char *v17; // rbx

  v8 = a3;
  v9 = a4;
  v10 = a5;
  v11 = a6;
  v12 = sub_2F450(1uLL, 0x30uLL, 0LL);
  *((_QWORD *)v12 + 3) = 0LL;
  *a7 = v12;
  *((_QWORD *)v12 + 5) = off_31E400;
  if ( src )
  {
    *((_QWORD *)v12 + 3) = sub_BC120(src);
    *((_BYTE *)v12 + 16) = 0;
    *((_DWORD *)v12 + 8) = a2;
  }
  else
  {
    *((_BYTE *)v12 + 16) = 1;
  }
  *(_QWORD *)v12 = v10;
  v13 = sub_1EF00(v11, 172);
  v14 = (__int64 *)sub_3ADB0(v8, v9, (__int64)v12 + 40, v13 ^ 1u, (__int64)v11, a8);
  v15 = *v14;
  *((_QWORD *)v12 + 1) = v14;
  v16 = (char *)(*(__int64 (__fastcall **)(__int64 *, _QWORD))(v15 + 48))(v14, v9);
  if ( !v16 )
    return 0LL;
  v17 = sub_BC120(v16);
  (*(void (**)(void))(**((_QWORD **)v12 + 1) + 8LL))();
  sub_2F4D0(*((void **)v12 + 3));
  sub_2F4D0(v12);
  *a7 = 0LL;
  return v17;
}

int __fastcall sub_37C70(__int64 a1, __int64 a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  bool v5; // sf
  unsigned int v6; // edx
  int v7; // eax
  unsigned int v8; // eax

  v2 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 4) > v2 )
    return 1;
  if ( *(_DWORD *)(a1 + 4) < v2 )
    return -1;
  v3 = *(_DWORD *)(a2 + 56);
  if ( *(_DWORD *)(a1 + 56) > v3 )
    return 1;
  if ( *(_DWORD *)(a1 + 56) < v3 )
    return -1;
  result = sub_BD0D0(*(const char **)(a1 + 16), *(const char **)(a2 + 16));
  v5 = result < 0;
  if ( result )
    goto LABEL_21;
  v6 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(a1 + 8) > v6 )
    return 1;
  if ( *(_DWORD *)(a1 + 8) < v6 )
    return -1;
  if ( *(_DWORD *)(a1 + 4) == 68 )
    return result;
  v7 = sub_BD0D0(*(const char **)(a1 + 24), *(const char **)(a2 + 24));
  v5 = v7 < 0;
  if ( v7 )
  {
LABEL_21:
    if ( !v5 )
      return 1;
    return -1;
  }
  v8 = *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a1 + 12) > v8 )
    return 1;
  return -(*(_DWORD *)(a1 + 12) < v8);
}

void nullsub_11()
{
  ;
}

void __fastcall sub_37D10(__int64 a1)
{
  if ( a1 )
  {
    (*(void (**)(void))(**(_QWORD **)(a1 + 8) + 8LL))();
    sub_2F4D0(*(void **)(a1 + 24));
    sub_2F4D0((void *)a1);
  }
}

void __fastcall sub_37D40(__int64 a1)
{
  sub_37D10(a1);
}

void __fastcall sub_37D50(__int64 a1)
{
  void **v1; // rbx
  __int64 v2; // rdi

  v1 = (void **)a1;
  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 )
    sub_37D10(v2);
  sub_2F4D0(v1[2]);
  sub_2F4D0(v1[3]);
  sub_2F4D0(v1[4]);
  sub_2F4D0(v1[5]);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_37D90(__int64 a1, signed __int64 *a2, char a3)
{
  char v3; // bp
  _QWORD *v4; // rax
  signed __int64 v5; // rdx
  _QWORD *result; // rax

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x58uLL, 0LL);
  v5 = (signed __int64)(v4 + 8);
  v4[4] = 0LL;
  v4[6] = 0LL;
  *((_DWORD *)v4 + 20) = 0;
  result = v4 + 9;
  *(result - 1) = off_31E440;
  *((_BYTE *)result - 48) = 1;
  *(result - 9) = 0LL;
  *(result - 8) = a1;
  *result = off_323D80;
  *((_BYTE *)result - 47) = v3;
  *((_DWORD *)result - 11) = 0;
  *((_DWORD *)result - 8) = 0;
  *a2 = v5;
  return result;
}

void __fastcall sub_37E10(__int64 (__fastcall ***a1)())
{
  __int64 v1; // rdi

  if ( *a1 != off_323D80 )
    __assert_fail("pfchan->vt == &PortForwarding_channelvt", "portfwd.c", 0x1F1u, "portfwd_raw_free");
  v1 = (__int64)(a1 - 9);
  if ( v1 )
    sub_373D0(v1);
}

signed __int64 __fastcall sub_37E60(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64), __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // r13
  __int64 v5; // rdi
  __int64 (__fastcall ***v6)(); // rbx
  __int64 v7; // rbp
  char *v8; // rax
  unsigned int v9; // edx
  __int64 v10; // rdi
  __int64 v11; // rax
  signed __int64 result; // rax
  __int64 v13; // rax
  __int64 v14; // [rsp+0h] [rbp-38h]
  unsigned __int64 v15; // [rsp+8h] [rbp-30h]

  v3 = a1;
  v4 = a3;
  v5 = *(_QWORD *)(a1 - 40);
  v15 = __readfsqword(0x28u);
  v6 = (__int64 (__fastcall ***)())sub_37D90(v5, &v14, 0);
  v7 = a2(v4, v14);
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 48LL))(v7) )
  {
    sub_37E10(v6);
    result = 1LL;
  }
  else if ( *(_BYTE *)(v3 - 24) )
  {
    *(v6 - 7) = (__int64 (__fastcall **)())v7;
    *((_DWORD *)v6 - 11) = 1;
    *(v6 - 3) = (__int64 (__fastcall **)())sub_BC640();
    v13 = *(_QWORD *)v7;
    *(v6 - 2) = 0LL;
    *((_DWORD *)v6 - 8) = 0;
    (*(void (__fastcall **)(__int64, _QWORD))(v13 + 40))(v7, 0LL);
    result = 0LL;
  }
  else
  {
    v8 = sub_BC120(*(char **)(v3 - 16));
    v9 = *(_DWORD *)(v3 - 8);
    v10 = *(_QWORD *)(v3 - 40);
    *(v6 - 5) = (__int64 (__fastcall **)())v8;
    *((_DWORD *)v6 - 8) = v9;
    v11 = sub_371F0(v10, (__int64)v8, v9, v7, (__int64)v6);
    if ( *v6 != off_323D80 )
      goto LABEL_9;
    *(v6 - 9) = (__int64 (__fastcall **)())v11;
    *(v6 - 7) = (__int64 (__fastcall **)())v7;
    result = 0LL;
  }
  if ( __readfsqword(0x28u) != v15 )
LABEL_9:
    sub_1AE50();
  return result;
}

__int64 (__fastcall **__fastcall sub_37F70(__int64 (__fastcall ***a1)(), __int64 (__fastcall **a2)(), __int64 (__fastcall **a3)()))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_323D80;
  if ( *a1 != off_323D80 )
    sub_1AE50();
  *(a1 - 7) = a2;
  *(a1 - 9) = a3;
  return result;
}

_QWORD *__fastcall sub_37F90(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_2F450(1uLL, 0x18uLL, 0LL);
  v2 = v1;
  *v1 = a1;
  v1[1] = 0LL;
  v1[2] = sub_9AF60((__int64)sub_37C70);
  return v2;
}

void __fastcall sub_37FE0(__int64 a1, __int64 a2)
{
  if ( a2 == sub_9B440(*(__int64 **)(a1 + 16), a2) )
    sub_37D50(a2);
}

__int64 __fastcall sub_38010(__int64 a1)
{
  __int64 result; // rax

  while ( 1 )
  {
    result = sub_9B400(*(__int64 **)(a1 + 16), 0);
    if ( !result )
      break;
    sub_37D50(result);
  }
  return result;
}

void __fastcall sub_38040(__int64 a1)
{
  void *v1; // rbx
  _QWORD *v2; // rdi

  v1 = (void *)a1;
  sub_38010(a1);
  sub_9AF90(*(_QWORD ***)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if ( v2 )
    sub_1ED50(v2);
  sub_2F4D0(v1);
}

unsigned __int64 __usercall sub_38070@<rax>(__int64 a1@<rdi>, __int64 *a2@<rsi>, char *a3@<r13>)
{
  __int64 ***v3; // r15
  _QWORD *v4; // rdi
  signed int v5; // ebx
  _DWORD *v6; // rax
  char *v7; // r14
  char *v8; // rdi
  signed __int64 v9; // rcx
  char *v10; // rsi
  bool v11; // cf
  bool v12; // zf
  signed int v13; // ecx
  char *v14; // r14
  signed int v15; // er8
  signed int v16; // ebp
  _DWORD *v17; // rax
  __int64 v18; // rdx
  char *v19; // rax
  signed int v20; // ecx
  signed int v21; // er8
  char *v22; // rax
  int v23; // eax
  _DWORD *v24; // rax
  __int64 v25; // r15
  char *v26; // rbx
  char *v27; // rax
  char *v28; // r12
  char *v29; // rbx
  char *v30; // rdi
  size_t v31; // rax
  char *v32; // r13
  signed int v33; // eax
  signed int v34; // ebx
  char *v35; // r12
  char *v36; // rdx
  __int64 v37; // r8
  char *v38; // rcx
  int v39; // eax
  const char *v40; // rsi
  char *v41; // rax
  char *v42; // r14
  char *v43; // ST28_8
  int v44; // esi
  __int64 v45; // rax
  char *v46; // r13
  signed int i; // ebx
  __int64 *v48; // rdi
  __int64 v49; // rax
  char *v50; // r10
  __int64 v51; // rbp
  char *v52; // rcx
  __int64 v53; // r9
  char *v54; // r8
  char *v55; // rax
  char *v56; // rsi
  char *v57; // rdx
  char *v58; // rdx
  char *v59; // rcx
  char *v60; // r9
  int v61; // eax
  char *v62; // rsi
  __int64 v63; // rdx
  __int64 v64; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v66; // rt1
  __int64 v67; // ST30_8
  signed int v68; // ST28_4
  __int64 v69; // ST48_8
  signed int v70; // ST44_4
  signed int v71; // ST30_4
  int v72; // eax
  char *v73; // ST28_8
  char *v74; // r10
  char *v75; // r10
  char *v76; // ST28_8
  __int64 v77; // rcx
  __int64 v78; // rdx
  char *v79; // ST28_8
  __int64 v80; // rdi
  char *v81; // ST28_8
  _DWORD *v82; // [rsp+8h] [rbp-80h]
  int v83; // [rsp+8h] [rbp-80h]
  signed int v84; // [rsp+10h] [rbp-78h]
  __int64 *v85; // [rsp+18h] [rbp-70h]
  signed int v86; // [rsp+24h] [rbp-64h]
  signed int v87; // [rsp+28h] [rbp-60h]
  __int64 **v88; // [rsp+38h] [rbp-50h]
  char *nptr; // [rsp+40h] [rbp-48h]
  unsigned __int64 v90; // [rsp+48h] [rbp-40h]

  v3 = (__int64 ***)a1;
  v4 = *(_QWORD **)(a1 + 8);
  v90 = __readfsqword(0x28u);
  v85 = a2;
  if ( v4 )
    sub_1ED50(v4);
  v5 = 0;
  v3[1] = (__int64 **)sub_1EED0(a2);
  while ( 1 )
  {
    v6 = (_DWORD *)sub_9B010((__int64 *)v3[2], v5);
    if ( !v6 )
      break;
    *v6 = 0;
    ++v5;
  }
  v7 = (char *)sub_1F330(a2, 174, 0LL, &nptr);
  if ( v7 )
  {
    v88 = (__int64 **)v3;
    while ( 1 )
    {
      v25 = (unsigned __int8)*nptr;
      if ( (*nptr & 0xFD) == 52 || (_BYTE)v25 == 65 )
      {
        v16 = nptr[1];
        v26 = nptr + 1;
        if ( nptr[1] == 76 )
          goto LABEL_39;
      }
      else
      {
        v16 = (char)v25;
        v26 = nptr;
        v25 = 65LL;
        if ( (_BYTE)v16 == 76 )
          goto LABEL_39;
      }
      if ( (_BYTE)v16 != 82 )
      {
        v16 = 76;
        goto LABEL_30;
      }
LABEL_39:
      ++v26;
LABEL_30:
      v27 = sub_BC080(v26, 58);
      v28 = v27;
      if ( v27 )
      {
        v29 = sub_BC360((__int64)"%.*s", v27 - v26, v26);
        a3 = sub_BC440(v29);
        v30 = v29;
        v26 = v28 + 1;
        v28 = a3;
        sub_2F4D0(v30);
      }
      v83 = strtol(v26, 0LL, 10);
      v84 = 0;
      if ( !v83 )
      {
        v83 = sub_B72D0(v26);
        v84 = 1;
        if ( !v83 )
          sub_2D3F0(**v88, (__int64)"Service lookup failed for source port \"%s\"", (__int64)a3, v25);
      }
      v11 = (unsigned __int8)v16 < 0x4Cu;
      v12 = (_BYTE)v16 == 76;
      if ( (_BYTE)v16 != 76 )
        goto LABEL_98;
      v8 = "D";
      v9 = 2LL;
      v10 = v7;
      do
      {
        if ( !v9 )
          break;
        v11 = (unsigned __int8)*v10 < (unsigned __int8)*v8;
        v12 = *v10++ == *v8++;
        --v9;
      }
      while ( v12 );
      v13 = (char)((!v11 && !v12) - v11);
      if ( (!v11 && !v12) != v11 )
      {
LABEL_98:
        v31 = sub_BC050(v7, ":");
        v32 = &v7[v31];
        v14 = sub_BC360((__int64)"%.*s", (unsigned int)v31, v7);
        a3 = &v32[-((unsigned __int8)*v32 < 1u) + 1];
        v33 = strtol(a3, 0LL, 10);
        v13 = 0;
        v15 = v33;
        if ( !v33 )
        {
          v15 = sub_B72D0(a3);
          v13 = 1;
          if ( !v15 )
          {
            sub_2D3F0(**v88, (__int64)"Service lookup failed for destination port \"%s\"", (__int64)a3, v25);
            goto LABEL_37;
          }
        }
      }
      else
      {
        v14 = 0LL;
        a3 = 0LL;
        v15 = -1;
        v16 = 68;
      }
      v87 = v15;
      v86 = v13;
      if ( v83 )
      {
        v17 = sub_2F450(1uLL, 0x48uLL, 0LL);
        v18 = (__int64)v17;
        v17[1] = v16;
        *((_QWORD *)v17 + 2) = v28;
        v19 = 0LL;
        v20 = v86;
        v21 = v87;
        if ( v84 )
        {
          v69 = v18;
          v70 = v21;
          v71 = v20;
          v19 = sub_BC120(v26);
          v18 = v69;
          v21 = v70;
          v20 = v71;
        }
        *(_QWORD *)(v18 + 32) = v19;
        *(_QWORD *)(v18 + 24) = v14;
        *(_DWORD *)(v18 + 8) = v83;
        v22 = 0LL;
        if ( v20 )
        {
          v67 = v18;
          v68 = v21;
          v22 = sub_BC120(a3);
          v18 = v67;
          v21 = v68;
        }
        *(_QWORD *)(v18 + 40) = v22;
        *(_DWORD *)(v18 + 12) = v21;
        *(_QWORD *)(v18 + 64) = 0LL;
        *(_QWORD *)(v18 + 48) = 0LL;
        v23 = 1;
        if ( (_BYTE)v25 != 52 )
          v23 = 2 * ((_BYTE)v25 == 54);
        *(_DWORD *)(v18 + 56) = v23;
        v82 = (_DWORD *)v18;
        v24 = (_DWORD *)sub_9AFD0(v88[2], v18);
        if ( v82 == v24 )
        {
          *v82 = 2;
        }
        else
        {
          if ( !*v24 )
            *v24 = 1;
          sub_37D50((__int64)v82);
        }
        goto LABEL_24;
      }
LABEL_37:
      sub_2F4D0(v28);
      sub_2F4D0(v14);
LABEL_24:
      v7 = (char *)sub_1F330(v85, 174, nptr, &nptr);
      if ( !v7 )
      {
        v3 = (__int64 ***)v88;
        break;
      }
    }
  }
  v34 = 0;
  v35 = ":";
  while ( 1 )
  {
    v45 = sub_9B010((__int64 *)v3[2], v34);
    v46 = (char *)v45;
    if ( !v45 )
      break;
    if ( !*(_DWORD *)v45 )
    {
      v36 = *(char **)(v45 + 16);
      v37 = *(unsigned int *)(v45 + 8);
      v38 = ":";
      if ( !v36 )
      {
        v38 = &locale;
        v36 = &locale;
      }
      v39 = *(_DWORD *)(v45 + 4);
      v40 = "local";
      if ( v39 != 76 )
      {
        v40 = "dynamic";
        if ( v39 == 82 )
          v40 = "remote";
      }
      v41 = sub_BC360((__int64)"%s port forwarding from %s%s%d", v40, v36, v38, v37);
      v42 = v41;
      if ( *((_DWORD *)v46 + 1) != 68 )
      {
        v43 = sub_BC360((__int64)"%s to %s:%d", v41, *((_QWORD *)v46 + 3), *((unsigned int *)v46 + 3));
        sub_2F4D0(v42);
        v42 = v43;
      }
      sub_2D3F0((__int64)**v3, (__int64)"Cancelling %s", (__int64)v46, (__int64)v3);
      sub_2F4D0(v42);
      if ( *((_QWORD *)v46 + 6) )
      {
        ((void (*)(void))(*v3)[1][1])();
        *((_QWORD *)v46 + 6) = 0LL;
      }
      else
      {
        v80 = *((_QWORD *)v46 + 8);
        if ( v80 )
        {
          sub_37D10(v80);
          *((_QWORD *)v46 + 8) = 0LL;
        }
      }
      v44 = v34--;
      sub_9B400((__int64 *)v3[2], v44);
      sub_37D50((__int64)v46);
    }
    ++v34;
  }
  for ( i = 0; ; ++i )
  {
    v48 = (__int64 *)v3[2];
    v49 = sub_9B010(v48, i);
    v51 = v49;
    if ( !v49 )
      break;
    if ( *(_DWORD *)v49 != 2 )
      continue;
    v52 = *(char **)(v49 + 32);
    v53 = *(unsigned int *)(v49 + 8);
    if ( v52 )
    {
      v54 = "(";
      v55 = ")";
    }
    else
    {
      v54 = &locale;
      v55 = &locale;
      v52 = &locale;
    }
    v56 = *(char **)(v51 + 16);
    v57 = ":";
    if ( !v56 )
    {
      v57 = &locale;
      v56 = &locale;
    }
    v35 = sub_BC360((__int64)"%s%s%s%s%d%s", v56, v57, v52, v54, v53, v55);
    if ( *(_DWORD *)(v51 + 4) == 68 )
    {
      v63 = *(_QWORD *)(v51 + 16);
      v46 = 0LL;
    }
    else
    {
      v58 = *(char **)(v51 + 40);
      v59 = "(";
      v60 = ")";
      if ( !v58 )
      {
        v59 = &locale;
        v60 = &locale;
        v58 = &locale;
      }
      v46 = sub_BC360((__int64)"%s:%s%s%d%s", *(_QWORD *)(v51 + 24), v58, v59, *(unsigned int *)(v51 + 12), v60);
      v61 = *(_DWORD *)(v51 + 4);
      if ( v61 == 76 )
      {
        v75 = sub_37B60(
                *(char **)(v51 + 24),
                *(_DWORD *)(v51 + 12),
                *(_QWORD *)(v51 + 16),
                *(_DWORD *)(v51 + 8),
                (__int64)*v3,
                v85,
                (_QWORD *)(v51 + 64),
                *(_DWORD *)(v51 + 56));
        if ( !v75 )
        {
          sub_2D3F0((__int64)**v3, (__int64)"Local %sport %s forwarding to %s%s%s", (__int64)v46, (__int64)v3, &locale);
          goto LABEL_73;
        }
        v76 = v75;
        sub_2D3F0((__int64)**v3, (__int64)"Local %sport %s forwarding to %s%s%s", (__int64)v46, (__int64)v3, v75);
        v74 = v76;
        goto LABEL_85;
      }
      v62 = *(char **)(v51 + 16);
      v63 = *(_QWORD *)(v51 + 16);
      if ( v61 != 68 )
      {
        if ( !v62 )
        {
          v62 = &locale;
          if ( !(unsigned __int8)sub_1EF00(v85, 173) )
            v62 = "localhost";
        }
        v64 = ((__int64 (__fastcall *)(__int64 **, char *, _QWORD, _QWORD, _QWORD, _QWORD, char *, __int64, _QWORD))*(*v3)[1])(
                *v3,
                v62,
                *(unsigned int *)(v51 + 8),
                *(_QWORD *)(v51 + 24),
                *(unsigned int *)(v51 + 12),
                *(unsigned int *)(v51 + 56),
                v35,
                v51,
                0LL);
        *(_QWORD *)(v51 + 48) = v64;
        if ( v64 )
        {
          sub_2D3F0((__int64)**v3, (__int64)"Requesting remote port %s forward to %s", (__int64)v46, (__int64)v3);
        }
        else
        {
          v77 = *(unsigned int *)(v51 + 12);
          v78 = *(_QWORD *)(v51 + 24);
          sub_2D3F0((__int64)**v3, (__int64)"Duplicate remote port forwarding to %s:%d", (__int64)v46, (__int64)v3);
          sub_37D50(v51);
        }
        goto LABEL_73;
      }
    }
    v50 = sub_37B60(0LL, -1, v63, *(_DWORD *)(v51 + 8), (__int64)*v3, v85, (_QWORD *)(v51 + 64), *(_DWORD *)(v51 + 56));
    if ( !v50 )
    {
      sub_2D3F0((__int64)**v3, (__int64)"Local %sport %s SOCKS dynamic forwarding%s%s", (__int64)v46, (__int64)v3);
      goto LABEL_73;
    }
    v72 = *(_DWORD *)(v51 + 56);
    v48 = **v3;
    if ( v72 == 1 )
    {
      v79 = v50;
      sub_2D3F0((__int64)v48, (__int64)"Local %sport %s SOCKS dynamic forwarding%s%s", (__int64)v46, (__int64)v3);
      v74 = v79;
    }
    else
    {
      if ( v72 == 2 )
        goto LABEL_95;
      v73 = v50;
      sub_2D3F0((__int64)v48, (__int64)"Local %sport %s SOCKS dynamic forwarding%s%s", (__int64)v46, (__int64)v3);
      v74 = v73;
    }
LABEL_85:
    sub_2F4D0(v74);
LABEL_73:
    sub_2F4D0(v35);
    sub_2F4D0(v46);
  }
  v66 = __readfsqword(0x28u);
  result = v66 ^ v90;
  if ( v66 != v90 )
  {
LABEL_95:
    v81 = v50;
    sub_2D3F0((__int64)v48, (__int64)"Local %sport %s SOCKS dynamic forwarding%s%s", (__int64)v46, (__int64)v3);
    v74 = v81;
    goto LABEL_85;
  }
  return result;
}

char *__fastcall sub_38D40(__int64 *a1, _QWORD *a2, char *a3, unsigned int a4, __int64 a5, unsigned int a6)
{
  __int64 v6; // r15
  unsigned int v7; // er13
  _QWORD *v8; // r14
  __int64 *v9; // rcx
  __int64 v10; // rax
  struct addrinfo **v11; // rbp
  char *v12; // rax
  char *v13; // r12
  _QWORD *v15; // rax
  __int64 v16; // rbx
  __int64 v17; // rax
  void *v18; // rsi
  __int64 v19; // rax
  void *v20; // rdi
  char *v21; // rax
  void *v22; // [rsp+0h] [rbp-48h]
  unsigned __int64 v23; // [rsp+8h] [rbp-40h]

  v6 = a5;
  v7 = a4;
  v8 = a2;
  v9 = (__int64 *)a1[1];
  v23 = __readfsqword(0x28u);
  v22 = 0LL;
  v10 = sub_3A770(a3, v7, &v22, v9, a6, 0LL, 0LL);
  v11 = (struct addrinfo **)v10;
  v12 = (char *)sub_B72A0(v10);
  if ( v12 )
  {
    v13 = sub_BC120(v12);
    sub_B62D0(v11);
    sub_2F4D0(v22);
  }
  else
  {
    v15 = sub_2F450(1uLL, 0x58uLL, 0LL);
    v15[4] = 0LL;
    v15[6] = 0LL;
    v16 = (__int64)v15;
    *a2 = v15 + 9;
    *((_DWORD *)v15 + 20) = 0;
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v15 + 25) = 1;
    v15[8] = off_31E440;
    *v15 = v6;
    v15[9] = off_323D80;
    v17 = *a1;
    *(_DWORD *)(v16 + 28) = 0;
    *(_QWORD *)(v16 + 8) = v17;
    v18 = v22;
    v19 = sub_3A8A0(
            (__int64)v11,
            (const char *)v22,
            v7,
            0,
            1LL,
            0LL,
            0LL,
            (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))(v16 + 64),
            (__int64 *)a1[1]);
    v20 = v22;
    *(_QWORD *)(v16 + 16) = v19;
    sub_2F4D0(v20);
    v21 = (char *)(*(__int64 (__fastcall **)(_QWORD, void *))(**(_QWORD **)(v16 + 16) + 48LL))(
                    *(_QWORD *)(v16 + 16),
                    v18);
    if ( v21 )
    {
      v13 = sub_BC120(v21);
      (*(void (**)(void))(**(_QWORD **)(v16 + 16) + 8LL))();
      sub_373D0(v16);
      *v8 = 0LL;
    }
    else
    {
      v13 = 0LL;
    }
  }
  return v13;
}

__int64 __fastcall sub_38ED0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 - 240);
  if ( a2 )
    *(_QWORD *)(a1 - 240) = a2;
  return result;
}

__int64 __fastcall sub_38EF0(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 - 92);
  if ( !(_DWORD)result )
    return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 248) + 32LL))();
  *(_BYTE *)(a1 - 96) = 1;
  return result;
}

__int64 __fastcall sub_38F10(__int64 a1)
{
  return (***(__int64 (****)(void))(a1 - 248))();
}

__int64 __fastcall sub_38F20(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !*(_DWORD *)(a1 - 100) )
    return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 248) + 32LL))();
  *(_QWORD *)(a1 - 40) = a3;
  *(_QWORD *)(a1 - 48) = a2;
  return (*(__int64 (__fastcall **)(__int64, signed __int64))(a1 - 88))(a1 - 264, 3LL);
}

bool __fastcall sub_38F60(__int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // r8
  bool result; // al
  bool v6; // cf
  bool v7; // zf

  if ( !a2 )
    return 0;
  v3 = 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v4 = v3 + 1;
      if ( *(_BYTE *)(a1 + v3) == 10 )
        break;
      ++v3;
      if ( a2 <= v4 )
        return 0;
    }
    if ( v4 <= 2 )
    {
      *a3 = v4;
      return 1;
    }
    if ( v3 + 2 < a2 )
    {
      result = *(_BYTE *)(a1 + v3 + 2) != 32 && *(_BYTE *)(a1 + v3 + 2) != 9;
      if ( result )
        break;
    }
    v6 = a2 < v3 + 3;
    v7 = a2 == v3 + 3;
    v3 += 3LL;
    if ( v6 || v7 )
      return 0;
  }
  *a3 = v4;
  return result;
}

void __fastcall sub_38FD0(__int64 a1)
{
  (*(void (**)(void))(**(_QWORD **)(a1 - 248) + 8LL))();
  sub_B62D0(*(struct addrinfo ***)(a1 - 232));
  sub_2F4D0((void *)(a1 - 256));
}

__int64 __fastcall sub_39000(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbp
  int v6; // er12

  if ( !*(_DWORD *)(a1 - 100) )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64))(**(_QWORD **)(a1 - 248) + 16LL))(
             *(_QWORD *)(a1 - 248),
             a2,
             a3,
             a4);
  v5 = a3;
  v6 = a4;
  sub_BCD20(a1 - 264 + 120, (char *)a3, a4);
  *(_QWORD *)(a1 - 64) = v5;
  *(_DWORD *)(a1 - 56) = v6;
  *(_BYTE *)(a1 - 67) = (_DWORD)a2 != 0;
  return (*(__int64 (__fastcall **)(__int64, signed __int64))(a1 - 88))(a1 - 264, 2LL);
}

__int64 __fastcall sub_39070(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rdi

  result = *(_QWORD *)(a1 - 256);
  if ( !result )
  {
    v2 = *(_QWORD *)(a1 - 248);
    if ( v2 )
      result = (*(__int64 (**)(void))(*(_QWORD *)v2 + 48LL))();
  }
  return result;
}

__int64 __fastcall sub_390A0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  if ( !*(_DWORD *)(a1 - 100) )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 - 248) + 8LL))(
             *(_QWORD *)(a1 - 248),
             a2,
             a3,
             a4);
  *(_DWORD *)(a1 - 72) = a3;
  *(_QWORD *)(a1 - 80) = a2;
  *(_BYTE *)(a1 - 68) = a4;
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 - 88))(a1 - 264, 0LL);
}

__int64 __fastcall sub_390E0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 - 100) )
    result = (*(__int64 (__fastcall **)(__int64, signed __int64))(a1 - 88))(a1 - 264, 1LL);
  else
    result = (*(__int64 (**)(void))(**(_QWORD **)(a1 - 248) + 24LL))();
  return result;
}

unsigned __int64 __usercall sub_39220@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, unsigned __int8 a4@<sil>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>)
{
  __int64 v7; // r12
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 result; // rax
  __int64 v12; // [rsp-238h] [rbp-238h]
  unsigned __int64 v13; // [rsp-30h] [rbp-30h]
  __int64 v14; // [rsp-28h] [rbp-28h]
  __int64 v15; // [rsp-20h] [rbp-20h]
  __int64 v16; // [rsp-18h] [rbp-18h]
  __int64 v17; // [rsp-10h] [rbp-10h]
  __int64 v18; // [rsp-8h] [rbp-8h]

  result = *(unsigned int *)(a3 - 92);
  if ( (_DWORD)result )
  {
    *(_BYTE *)(a3 - 88) = a4;
  }
  else
  {
    v18 = a7;
    v17 = a6;
    v16 = a5;
    v7 = a3 - 136;
    v15 = a2;
    v14 = a1;
    v13 = __readfsqword(0x28u);
    if ( !sub_BCD00(a3 - 136) )
      goto LABEL_16;
    *(_BYTE *)(a3 - 88) = a4;
    if ( !a4 )
    {
      while ( sub_BCD00(v7) )
      {
        v8 = 512LL;
        v9 = sub_BCF00(v7);
        if ( v10 <= 0x200 )
          v8 = v10;
        __memcpy_chk(&v12, v9, v8, 512LL);
        sub_BCE20(v7, v8);
        (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, unsigned __int64))(**(_QWORD **)(a3 - 240) + 16LL))(
          *(_QWORD *)(a3 - 240),
          0LL,
          &v12,
          v8);
        if ( *(_BYTE *)(a3 - 88) )
          goto LABEL_5;
      }
      if ( !*(_BYTE *)(a3 - 88) )
LABEL_16:
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 - 248) + 40LL))(*(_QWORD *)(a3 - 248), a4);
    }
LABEL_5:
    result = __readfsqword(0x28u) ^ v13;
  }
  return result;
}

unsigned __int64 __usercall sub_39220@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, unsigned __int8 a4@<sil>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>)
{
  __int64 v7; // r12
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 result; // rax
  __int64 v12; // [rsp-238h] [rbp-238h]
  unsigned __int64 v13; // [rsp-30h] [rbp-30h]
  __int64 v14; // [rsp-28h] [rbp-28h]
  __int64 v15; // [rsp-20h] [rbp-20h]
  __int64 v16; // [rsp-18h] [rbp-18h]
  __int64 v17; // [rsp-10h] [rbp-10h]
  __int64 v18; // [rsp-8h] [rbp-8h]

  result = *(unsigned int *)(a3 - 92);
  if ( (_DWORD)result )
  {
    *(_BYTE *)(a3 - 88) = a4;
  }
  else
  {
    v18 = a7;
    v17 = a6;
    v16 = a5;
    v7 = a3 - 136;
    v15 = a2;
    v14 = a1;
    v13 = __readfsqword(0x28u);
    if ( !sub_BCD00(a3 - 136) )
      goto LABEL_16;
    *(_BYTE *)(a3 - 88) = a4;
    if ( !a4 )
    {
      while ( sub_BCD00(v7) )
      {
        v8 = 512LL;
        v9 = sub_BCF00(v7);
        if ( v10 <= 0x200 )
          v8 = v10;
        __memcpy_chk(&v12, v9, v8, 512LL);
        sub_BCE20(v7, v8);
        (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, unsigned __int64))(**(_QWORD **)(a3 - 240) + 16LL))(
          *(_QWORD *)(a3 - 240),
          0LL,
          &v12,
          v8);
        if ( *(_BYTE *)(a3 - 88) )
          goto LABEL_5;
      }
      if ( !*(_BYTE *)(a3 - 88) )
LABEL_16:
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 - 248) + 40LL))(*(_QWORD *)(a3 - 248), a4);
    }
LABEL_5:
    result = __readfsqword(0x28u) ^ v13;
  }
  return result;
}

unsigned __int64 __usercall sub_39220@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, unsigned __int8 a4@<sil>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>)
{
  __int64 v7; // r12
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 result; // rax
  __int64 v12; // [rsp-238h] [rbp-238h]
  unsigned __int64 v13; // [rsp-30h] [rbp-30h]
  __int64 v14; // [rsp-28h] [rbp-28h]
  __int64 v15; // [rsp-20h] [rbp-20h]
  __int64 v16; // [rsp-18h] [rbp-18h]
  __int64 v17; // [rsp-10h] [rbp-10h]
  __int64 v18; // [rsp-8h] [rbp-8h]

  result = *(unsigned int *)(a3 - 92);
  if ( (_DWORD)result )
  {
    *(_BYTE *)(a3 - 88) = a4;
  }
  else
  {
    v18 = a7;
    v17 = a6;
    v16 = a5;
    v7 = a3 - 136;
    v15 = a2;
    v14 = a1;
    v13 = __readfsqword(0x28u);
    if ( !sub_BCD00(a3 - 136) )
      goto LABEL_16;
    *(_BYTE *)(a3 - 88) = a4;
    if ( !a4 )
    {
      while ( sub_BCD00(v7) )
      {
        v8 = 512LL;
        v9 = sub_BCF00(v7);
        if ( v10 <= 0x200 )
          v8 = v10;
        __memcpy_chk(&v12, v9, v8, 512LL);
        sub_BCE20(v7, v8);
        (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, unsigned __int64))(**(_QWORD **)(a3 - 240) + 16LL))(
          *(_QWORD *)(a3 - 240),
          0LL,
          &v12,
          v8);
        if ( *(_BYTE *)(a3 - 88) )
          goto LABEL_5;
      }
      if ( !*(_BYTE *)(a3 - 88) )
LABEL_16:
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 - 248) + 40LL))(*(_QWORD *)(a3 - 248), a4);
    }
LABEL_5:
    result = __readfsqword(0x28u) ^ v13;
  }
  return result;
}

unsigned __int64 __usercall sub_39220@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, unsigned __int8 a4@<sil>, __int64 a5@<r12>, __int64 a6@<r13>, __int64 a7@<r14>)
{
  __int64 v7; // r12
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 result; // rax
  __int64 v12; // [rsp-238h] [rbp-238h]
  unsigned __int64 v13; // [rsp-30h] [rbp-30h]
  __int64 v14; // [rsp-28h] [rbp-28h]
  __int64 v15; // [rsp-20h] [rbp-20h]
  __int64 v16; // [rsp-18h] [rbp-18h]
  __int64 v17; // [rsp-10h] [rbp-10h]
  __int64 v18; // [rsp-8h] [rbp-8h]

  result = *(unsigned int *)(a3 - 92);
  if ( (_DWORD)result )
  {
    *(_BYTE *)(a3 - 88) = a4;
  }
  else
  {
    v18 = a7;
    v17 = a6;
    v16 = a5;
    v7 = a3 - 136;
    v15 = a2;
    v14 = a1;
    v13 = __readfsqword(0x28u);
    if ( !sub_BCD00(a3 - 136) )
      goto LABEL_16;
    *(_BYTE *)(a3 - 88) = a4;
    if ( !a4 )
    {
      while ( sub_BCD00(v7) )
      {
        v8 = 512LL;
        v9 = sub_BCF00(v7);
        if ( v10 <= 0x200 )
          v8 = v10;
        __memcpy_chk(&v12, v9, v8, 512LL);
        sub_BCE20(v7, v8);
        (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, unsigned __int64))(**(_QWORD **)(a3 - 240) + 16LL))(
          *(_QWORD *)(a3 - 240),
          0LL,
          &v12,
          v8);
        if ( *(_BYTE *)(a3 - 88) )
          goto LABEL_5;
      }
      if ( !*(_BYTE *)(a3 - 88) )
LABEL_16:
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 - 248) + 40LL))(*(_QWORD *)(a3 - 248), a4);
    }
LABEL_5:
    result = __readfsqword(0x28u) ^ v13;
  }
  return result;
}

__int64 __fastcall sub_39240(__int64 a1, const char *a2, __int64 *a3)
{
  __int64 *v3; // r14
  char *v4; // rbx
  int v5; // edx
  unsigned int v6; // eax
  int v7; // ebx
  unsigned int v8; // ebx
  int v10; // ebp
  unsigned __int8 *v11; // rax
  unsigned __int8 v12; // r15
  unsigned __int8 *v13; // r13
  int v14; // er12
  const unsigned __int16 *v15; // rbp
  __int64 v16; // rcx
  const char *v17; // r10
  unsigned int v18; // eax
  __int64 v19; // rdi
  int v20; // edx
  unsigned __int8 v21; // al
  int v22; // er14
  size_t v23; // r12
  const char *v24; // ST18_8
  int v25; // eax
  __int64 v26; // rdx
  unsigned __int8 v27; // al
  signed __int64 v28; // rdx
  int v29; // ecx
  unsigned int v30; // ecx
  const char *v31; // r12
  __int64 v32; // rcx
  size_t v33; // r15
  __int64 v34; // ST18_8
  int v35; // eax
  __int64 v36; // [rsp+8h] [rbp-B0h]
  signed __int64 v37; // [rsp+20h] [rbp-98h]
  signed __int64 v38; // [rsp+28h] [rbp-90h]
  char v39[72]; // [rsp+30h] [rbp-88h]
  unsigned __int64 v40; // [rsp+78h] [rbp-40h]

  v3 = a3;
  v36 = a1;
  v40 = __readfsqword(0x28u);
  if ( a1 )
  {
    if ( sub_B6210(a1) || !(unsigned __int8)sub_1EF00(v3, 12) && (sub_B6180(0, 1, a2) || sub_B61E0(a1)) )
      return 0;
    v4 = v39;
    sub_B60F0(a1, v39, 64);
    do
    {
      v5 = *(_DWORD *)v4;
      v4 += 4;
      v6 = ~v5 & (v5 - 16843009) & 0x80808080;
    }
    while ( !v6 );
    if ( !(~v5 & (v5 - 16843009) & 0x8080) )
      LOBYTE(v6) = (~v5 & (v5 - 16843009) & 0x80808080) >> 16;
    if ( !(~v5 & (v5 - 16843009) & 0x8080) )
      LODWORD(v4) = (_DWORD)v4 + 2;
    v7 = (_DWORD)v4 - (__CFADD__((_BYTE)v6, (_BYTE)v6) + 3) - (unsigned __int64)v39;
  }
  else
  {
    if ( !(unsigned __int8)sub_1EF00(a3, 12) && sub_B6180(0, 1, a2) )
      return 0;
    v7 = 0;
  }
  v10 = strlen(a2);
  v11 = (unsigned __int8 *)sub_1F170(v3, 10);
  v37 = v10 + 1LL;
  v12 = *v11;
  v38 = v7 + 1LL;
  v13 = v11;
  v14 = 0;
LABEL_18:
  if ( !v12 )
    return 1;
  v15 = *__ctype_b_loc();
  v16 = v14;
  while ( 1 )
  {
    v17 = (const char *)&v13[v16];
    v18 = (v15[v12] >> 13) & 1;
    LOBYTE(v18) = (v12 == 44) | (v15[v12] >> 13) & 1;
    if ( !(_BYTE)v18 )
      break;
    ++v16;
    ++v14;
    v12 = v13[v16];
    if ( !v12 )
      return v18;
  }
  v19 = v14;
  v8 = v18;
  v20 = 0;
  v21 = v13[v14];
  v22 = v14;
  if ( v21 )
  {
    do
    {
      if ( !(v15[v21] & 8) && v21 != 42 && (unsigned __int8)(v21 - 45) > 1u )
        break;
      ++v19;
      ++v22;
      v21 = v13[v19];
    }
    while ( v21 );
    v20 = v22 - v14;
  }
  if ( v12 != 42 )
  {
    if ( v13[v19 - 1] == 42 )
    {
      v23 = v20 - 1;
      if ( !v36 )
        goto LABEL_32;
    }
    else
    {
      v23 = v20;
      if ( !v36 )
        goto LABEL_32;
    }
    v24 = (const char *)&v13[v16];
    v25 = strncasecmp(v39, v17, v23);
    v17 = v24;
    if ( !v25 )
      return v8;
LABEL_32:
    if ( !strncasecmp(a2, v17, v23) )
      return v8;
    v26 = v22;
    v27 = v13[v22];
    if ( v27 )
      goto LABEL_34;
    return 1;
  }
  v31 = (const char *)&v13[v16 + 1];
  v32 = v20;
  v33 = v20 - 1;
  if ( v36 )
  {
    v34 = v20;
    v35 = strncasecmp(&v39[v38 - v20], v31, v20 - 1);
    v32 = v34;
    if ( !v35 )
      return v8;
  }
  if ( !strncasecmp(&a2[v37 - v32], v31, v33) )
    return v8;
  v26 = v22;
  v27 = v13[v22];
  if ( !v27 )
    return 1;
LABEL_34:
  v28 = (signed __int64)&v13[v26 + 1];
  do
  {
    v29 = v15[v27];
    LOWORD(v29) = (unsigned __int16)v29 >> 13;
    v30 = v29 ^ 1;
    LOBYTE(v30) = (v27 != 44) & v30;
    if ( !(_BYTE)v30 )
    {
      v14 = v22;
      v12 = v13[v22];
      goto LABEL_18;
    }
    v27 = *(_BYTE *)(++v28 - 1);
    ++v22;
  }
  while ( v27 );
  return v30;
}

__int64 __fastcall sub_395E0(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !*(_DWORD *)(a1 - 92) )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 - 248) + 16LL))(
             *(_QWORD *)(a1 - 248),
             a2,
             a3);
  sub_BCD20(a1 - 216, (char *)a2, a3);
  return sub_BCD00(a1 - 216);
}

__int64 __fastcall sub_39620(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbp
  __int64 v5; // rbx

  if ( !*(_DWORD *)(a1 - 92) )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 - 248) + 24LL))(
             *(_QWORD *)(a1 - 248),
             a2,
             a3);
  v4 = a3;
  v5 = a1 - 256 + 80;
  sub_BCCA0(a1 - 256 + 40);
  sub_BCCA0(v5);
  sub_BCD20(v5, (char *)a2, v4);
  return v4;
}

__int64 __fastcall sub_39680(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // r13
  __int64 v3; // r12
  unsigned __int64 v4; // rbx
  __int64 v5; // r14
  unsigned __int64 v6; // r14
  __int64 v7; // rax
  unsigned __int64 v8; // rdx
  __int64 result; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rdx

  v1 = 1LL;
  v2 = a1 + 80;
  v3 = a1 + 40;
  v4 = 0LL;
  *(_DWORD *)(a1 + 164) = 0;
  (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(a1 + 8) + 40LL))(*(_QWORD *)(a1 + 8), 1LL);
  v5 = sub_BCD00(a1 + 80);
  v6 = sub_BCD00(a1 + 40) + v5;
  while ( sub_BCD00(v2) )
  {
    v7 = sub_BCF00(v2);
    v1 = v8;
    v4 += (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 8) + 24LL))(*(_QWORD *)(a1 + 8), v7);
    sub_BCE20(v2, v1);
  }
  for ( result = sub_BCD00(v3); result; result = sub_BCD00(v3) )
  {
    v10 = sub_BCF00(v3);
    v1 = v11;
    v4 += (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), v10);
    sub_BCE20(v3, v1);
  }
  if ( v4 < v6 )
  {
    v1 = v4;
    result = (*(__int64 (__fastcall **)(_QWORD, unsigned __int64))(**(_QWORD **)(a1 + 16) + 24LL))(
               *(_QWORD *)(a1 + 16),
               v4);
  }
  if ( *(_BYTE *)(a1 + 160) )
    result = (*(__int64 (__fastcall **)(_QWORD, unsigned __int64))(**(_QWORD **)(a1 + 8) + 32LL))(
               *(_QWORD *)(a1 + 8),
               v1);
  if ( !*(_BYTE *)(a1 + 168) )
    result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 256) + 40LL))(a1 + 256, 0LL);
  return result;
}

__int64 __fastcall sub_397B0(char *a1, int a2)
{
  __int64 v2; // r15
  int v3; // eax
  __int64 result; // rax
  char *v5; // rax
  char *v6; // rbx
  size_t v7; // rax
  _BYTE *v8; // rbx
  _BYTE *v9; // rax
  char *v10; // rax
  unsigned __int8 *v11; // r12
  int v12; // eax
  int v13; // ebp
  char *v14; // rax
  __m128i v15; // xmm0
  char *v16; // r13
  signed int v17; // ebx
  int v18; // er14
  signed int v19; // esi
  char *v20; // rbx
  size_t v21; // rax
  __int64 v22; // rsi
  __int64 v23; // rbp
  __int64 v24; // rax
  unsigned __int64 v25; // rbx
  char *v26; // r12
  __int64 v27; // r13
  __int64 v28; // rax
  unsigned __int64 v29; // r12
  char *v30; // rbx
  __int64 v31; // rax
  char v32; // cl
  char *v33; // rbp
  int v34; // [rsp+Ch] [rbp-27Ch]
  char *v35; // [rsp+10h] [rbp-278h]
  char *s; // [rsp+18h] [rbp-270h]
  char v37; // [rsp+2Ch] [rbp-25Ch]
  char v38; // [rsp+30h] [rbp-258h]
  int v39; // [rsp+34h] [rbp-254h]
  unsigned __int64 v40; // [rsp+38h] [rbp-250h]
  char v41; // [rsp+40h] [rbp-248h]
  unsigned __int64 v42; // [rsp+248h] [rbp-40h]

  v2 = (__int64)a1;
  v42 = __readfsqword(0x28u);
  v3 = *((_DWORD *)a1 + 41);
  if ( v3 == -1 )
  {
    sub_B60F0(*((_QWORD *)a1 + 3), &v41, 512);
    v5 = sub_BC360(
           (__int64)"CONNECT %s:%i HTTP/1.1\r\nHost: %s:%i\r\n",
           &v41,
           *((unsigned int *)a1 + 8),
           &v41,
           *((unsigned int *)a1 + 8));
    v6 = v5;
    v7 = strlen(v5);
    (*(void (__fastcall **)(_QWORD, char *, size_t))(**((_QWORD **)a1 + 1) + 16LL))(*((_QWORD *)a1 + 1), v6, v7);
    sub_2F4D0(v6);
    v8 = (_BYTE *)sub_1F170(*((__int64 **)a1 + 29), 16);
    v9 = (_BYTE *)sub_1F170(*((__int64 **)a1 + 29), 17);
    if ( *v8 || *v9 )
    {
      v10 = sub_BC360((__int64)"%s:%s", v8, v9);
      v11 = (unsigned __int8 *)v10;
      v35 = v10;
      v12 = strlen(v10);
      v13 = v12;
      v34 = v12;
      v14 = (char *)sub_2F450(4 * v12 / 3 + 100, 1uLL, 0LL);
      v15 = _mm_load_si128((const __m128i *)&xmmword_E7B00);
      s = v14;
      *((_QWORD *)v14 + 2) = 8313999093289348969LL;
      *(__m128i *)v14 = v15;
      *((_DWORD *)v14 + 6) = 2122601;
      if ( v13 <= 0 )
      {
        v17 = 27;
      }
      else
      {
        v16 = v14 + 27;
        v17 = 27;
        v18 = 0;
        do
        {
          v19 = v13 - v18;
          if ( v13 - v18 > 3 )
            v19 = 3;
          v18 += 3;
          v17 += 4;
          sub_BCA40(v11, v19, v16);
          v11 += 3;
          v16 += 4;
        }
        while ( v34 > v18 );
      }
      v20 = &s[v17];
      *(_WORD *)v20 = 2573;
      v20[2] = 0;
      v21 = strlen(s);
      (*(void (__fastcall **)(_QWORD, char *, size_t))(**((_QWORD **)a1 + 1) + 16LL))(*((_QWORD *)a1 + 1), s, v21);
      sub_2F4D0(v35);
      sub_2F4D0(s);
    }
    a1 = (char *)*((_QWORD *)a1 + 1);
    (*(void (__fastcall **)(char *, char *, signed __int64))(*(_QWORD *)a1 + 16LL))(a1, "\r\n", 2LL);
    *(_DWORD *)(v2 + 164) = 1;
    result = 0LL;
  }
  else if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = 0LL;
    }
    else
    {
      if ( a2 != 3 )
      {
        if ( a2 == 2 )
        {
          if ( v3 == 1 )
            goto LABEL_31;
          if ( v3 == 2 )
          {
            v23 = (__int64)(a1 + 120);
            goto LABEL_26;
          }
        }
        a1 = (char *)*((_QWORD *)a1 + 2);
        (*(void (__fastcall **)(char *, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
          a1,
          "Proxy error: unexpected proxy error",
          8001LL,
          0LL);
        goto LABEL_21;
      }
      v22 = *((_QWORD *)a1 + 27);
      a1 = (char *)*((_QWORD *)a1 + 2);
      result = (*(__int64 (__fastcall **)(char *, __int64, _QWORD))(*(_QWORD *)a1 + 32LL))(
                 a1,
                 v22,
                 *(_QWORD *)(v2 + 224));
    }
  }
  else
  {
    a1 = (char *)*((_QWORD *)a1 + 2);
    (*(void (__fastcall **)(char *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 8LL))(
      a1,
      *(_QWORD *)(v2 + 184),
      *(unsigned int *)(v2 + 192),
      *(unsigned __int8 *)(v2 + 196));
    result = 0LL;
  }
  while ( __readfsqword(0x28u) != v42 )
  {
LABEL_31:
    v23 = (__int64)(a1 + 120);
    v28 = sub_BCD00((__int64)(a1 + 120));
    v29 = v28;
    if ( !v28 )
      __assert_fail("len > 0", "proxy.c", 0x28Au, "proxy_http_negotiate");
    v30 = (char *)sub_2F450(v28 + 1, 1uLL, 0LL);
    sub_BCF10(v23, v30, v29);
    v30[v29] = 0;
    if ( !sub_38F60((__int64)v30, v29, &v40) )
      goto LABEL_35;
    v39 = -1;
    if ( (signed int)__isoc99_sscanf(v30, "HTTP/%i.%i %n", &v38, &v37, &v39) <= 1 || v39 == -1 )
    {
      (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
        *(_QWORD *)(v2 + 16),
        "Proxy error: HTTP response was absent",
        8000LL,
        0LL);
LABEL_35:
      a1 = v30;
      sub_2F4D0(v30);
      goto LABEL_21;
    }
    sub_BCE20(v23, v40);
    if ( v30[v39] == 50 )
    {
      sub_2F4D0(v30);
      *(_DWORD *)(v2 + 164) = 2;
LABEL_26:
      v24 = sub_BCD00(v23);
      v25 = v24;
      if ( !v24 )
        __assert_fail("len > 0", "proxy.c", 0x2BFu, "proxy_http_negotiate");
      v26 = (char *)sub_2F450(v24, 1uLL, 0LL);
      v27 = (__int64)v26;
      sub_BCF10(v23, v26, v25);
      if ( !sub_38F60((__int64)v26, v25, &v40) )
        goto LABEL_52;
      while ( v40 > 2 )
      {
        sub_BCE20(v23, v40);
        v27 += v40;
        v25 -= v40;
        if ( !sub_38F60(v27, v25, &v40) )
          v40 = 0LL;
      }
      if ( v40 == 2 )
      {
        sub_BCE20(v23, 2uLL);
        sub_39680(v2);
        a1 = v26;
        sub_2F4D0(v26);
      }
      else
      {
LABEL_52:
        a1 = v26;
        sub_2F4D0(v26);
      }
    }
    else
    {
      v30[v40] = 0;
      while ( v39 < v40 )
      {
        v31 = v40 - 1;
        v32 = v30[v40 - 1];
        if ( v32 != 13 && v32 != 10 )
          break;
        --v40;
        v30[v31] = 0;
      }
      v33 = sub_BC360((__int64)"Proxy error: %s", &v30[v39]);
      (*(void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(**(_QWORD **)(v2 + 16) + 8LL))(
        *(_QWORD *)(v2 + 16),
        v33,
        8000LL,
        0LL);
      sub_2F4D0(v33);
      a1 = v30;
      sub_2F4D0(v30);
    }
LABEL_21:
    result = 1LL;
  }
  return result;
}

__int64 __fastcall sub_39CE0(__int64 a1, int a2)
{
  __int64 v2; // rbx
  int v3; // edx
  __int64 result; // rax
  signed __int64 v5; // rax
  __int64 (__fastcall **v6)(_QWORD, char *, signed __int64); // rbp
  void **v7; // r12
  int v8; // eax
  const char *v9; // rax
  __int64 v10; // rsi
  const char *v11; // rax
  __int64 v12; // rbp
  void (__fastcall *v13)(__int64, const char *, signed __int64, _QWORD); // rax
  char v14; // [rsp+0h] [rbp-238h]
  char v15; // [rsp+1h] [rbp-237h]
  unsigned __int64 v16; // [rsp+208h] [rbp-30h]

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 164);
  v16 = __readfsqword(0x28u);
  if ( v3 == -1 )
  {
    v5 = sub_BC640();
    v6 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 24);
    v7 = (void **)v5;
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 24), 4);
    sub_2ECE0(v6, 1);
    sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v6, *(_DWORD *)(a1 + 32));
    v8 = sub_B6220(*(_QWORD *)(a1 + 24));
    if ( v8 == 2 )
    {
      a1 = (__int64)v7;
      *(_QWORD *)v2 = "Proxy error: SOCKS version 4 does not support IPv6";
      sub_BC660(v7);
      result = 1LL;
    }
    else
    {
      if ( v8 == 4 )
      {
        sub_B60F0(*(_QWORD *)(a1 + 24), &v14, 512);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v6, 1);
        v11 = (const char *)sub_1F170(*(__int64 **)(a1 + 232), 16);
        sub_2EF90((__int64 (__fastcall **)(_QWORD, const char *, size_t))v6, v11);
        sub_2EF90((__int64 (__fastcall **)(_QWORD, const char *, size_t))v6, &v14);
      }
      else
      {
        if ( v8 == 1 )
        {
          sub_B6260(*(_QWORD *)(a1 + 24), (__m128i *)&v14);
          sub_2EC20((__int64 (**)(void))v6);
        }
        v9 = (const char *)sub_1F170(*(__int64 **)(a1 + 232), 16);
        sub_2EF90((__int64 (__fastcall **)(_QWORD, const char *, size_t))v6, v9);
      }
      (*(void (__fastcall **)(_QWORD, void *, void *))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), *v7, v7[2]);
      a1 = (__int64)v7;
      sub_BC660(v7);
      *(_DWORD *)(v2 + 164) = 1;
      result = 0LL;
    }
  }
  else if ( a2 )
  {
    result = 0LL;
    if ( a2 != 1 )
    {
      if ( a2 != 3 )
      {
        if ( a2 == 2 && v3 == 1 )
          goto LABEL_21;
        a1 = *(_QWORD *)(a1 + 16);
        (*(void (__fastcall **)(__int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
          a1,
          "Proxy error: unexpected proxy error",
          8001LL,
          0LL);
        goto LABEL_20;
      }
      v10 = *(_QWORD *)(a1 + 216);
      a1 = *(_QWORD *)(a1 + 16);
      result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 32LL))(
                 a1,
                 v10,
                 *(_QWORD *)(v2 + 224));
    }
  }
  else
  {
    a1 = *(_QWORD *)(a1 + 16);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 8LL))(
      a1,
      *(_QWORD *)(v2 + 184),
      *(unsigned int *)(v2 + 192),
      *(unsigned __int8 *)(v2 + 196));
    result = 0LL;
  }
  while ( __readfsqword(0x28u) != v16 )
  {
LABEL_21:
    v12 = a1 + 120;
    a1 += 120LL;
    if ( (unsigned __int64)sub_BCD00(a1) > 7 )
    {
      sub_BCF10(v12, &v14, 8uLL);
      if ( v14 )
      {
        a1 = *(_QWORD *)(v2 + 16);
        (*(void (__fastcall **)(__int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
          a1,
          "Proxy error: SOCKS proxy responded with unexpected reply code version",
          8000LL,
          0LL);
      }
      else if ( v15 == 90 )
      {
        sub_BCE20(v12, 8uLL);
        a1 = v2;
        sub_39680(v2);
      }
      else
      {
        a1 = *(_QWORD *)(v2 + 16);
        v13 = *(void (__fastcall **)(__int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL);
        if ( v15 == 92 )
        {
          v13(a1, "Proxy error: SOCKS server wanted IDENTD on client", 8000LL, 0LL);
        }
        else if ( v15 == 93 )
        {
          v13(a1, "Proxy error: Username and IDENTD on client don't agree", 8000LL, 0LL);
        }
        else
        {
          v13(a1, "Proxy error: Error while communicating with proxy", 8000LL, 0LL);
        }
      }
    }
LABEL_20:
    result = 1LL;
  }
  return result;
}

__int64 __fastcall sub_39FB0(signed __int64 a1, signed __int64 a2)
{
  signed __int64 v2; // rbx
  unsigned int v3; // ebp
  __int64 result; // rax
  signed __int64 v5; // rax
  __int64 (__fastcall **v6)(_QWORD, char *, signed __int64); // r12
  _QWORD *v7; // rbp
  _BYTE *v8; // r15
  __int64 v9; // r13
  __int64 v10; // r14
  __int64 v11; // rsi
  __int64 v12; // r12
  signed __int64 v13; // rax
  __int64 (__fastcall **v14)(_QWORD, char *, signed __int64); // rbp
  void **v15; // r12
  int v16; // eax
  void (__fastcall **v17)(_QWORD, char *, signed __int64, _QWORD); // rdi
  unsigned __int64 v18; // rsi
  __m128i *v19; // rax
  const char *v20; // r14
  const char *v21; // rax
  const char *v22; // r13
  signed __int64 v23; // rax
  void (__fastcall **v24)(_QWORD, char *, signed __int64); // r12
  _QWORD *v25; // rbp
  int v26; // ebp
  __int64 v27; // r8
  _BYTE *v28; // [rsp+8h] [rbp-260h]
  char v29; // [rsp+1Bh] [rbp-24Dh]
  char v30; // [rsp+1Ch] [rbp-24Ch]
  char v31; // [rsp+1Eh] [rbp-24Ah]
  unsigned __int8 v32; // [rsp+1Fh] [rbp-249h]
  char v33; // [rsp+20h] [rbp-248h]
  char v34; // [rsp+21h] [rbp-247h]
  __m128i v35; // [rsp+2Dh] [rbp-23Bh]
  char v36; // [rsp+3Dh] [rbp-22Bh]
  unsigned __int64 v37; // [rsp+228h] [rbp-40h]

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 164);
  v37 = __readfsqword(0x28u);
  if ( v3 == -1 )
  {
    v5 = sub_BC640();
    v6 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 24);
    v7 = (_QWORD *)v5;
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 24), 5);
    v8 = (_BYTE *)sub_1F170(*(__int64 **)(a1 + 232), 16);
    v28 = (_BYTE *)sub_1F170(*(__int64 **)(a1 + 232), 17);
    v9 = v7[2];
    sub_2ECE0(v6, 0);
    v10 = v7[2];
    sub_2ECE0(v6, 0);
    if ( *v8 || *v28 )
    {
      sub_28250((__int64)v6);
      sub_2ECE0(v6, 2);
    }
    *(_BYTE *)(v7[1] + (signed int)v9) = *((_BYTE *)v7 + 16) - v10;
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), *v7, v7[2]);
    a1 = (signed __int64)v7;
    v3 = 0;
    sub_BC660((void **)a1);
    *(_DWORD *)(v2 + 164) = 1;
  }
  else if ( (_DWORD)a2 )
  {
    switch ( (_DWORD)a2 )
    {
      case 1:
        v3 = 0;
        break;
      case 3:
        v11 = *(_QWORD *)(a1 + 216);
        a1 = *(_QWORD *)(a1 + 16);
        v3 = (*(__int64 (__fastcall **)(signed __int64, __int64, _QWORD))(*(_QWORD *)a1 + 32LL))(
               a1,
               v11,
               *(_QWORD *)(v2 + 224));
        break;
      case 2:
        if ( v3 == 1 )
          goto LABEL_23;
        goto LABEL_17;
      default:
        goto LABEL_15;
    }
  }
  else
  {
    a1 = *(_QWORD *)(a1 + 16);
    v3 = 0;
    (*(void (__fastcall **)(signed __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 8LL))(
      a1,
      *(_QWORD *)(v2 + 184),
      *(unsigned int *)(v2 + 192),
      *(unsigned __int8 *)(v2 + 196));
  }
  while ( 1 )
  {
    result = v3;
    if ( __readfsqword(0x28u) == v37 )
      return result;
LABEL_23:
    v12 = a1 + 120;
    a1 += 120LL;
    if ( (unsigned __int64)sub_BCD00(a1) > 1 )
    {
      sub_BCF10(v12, &v33, 2uLL);
      if ( v33 == 5 )
      {
        switch ( v34 )
        {
          case 0:
            *(_DWORD *)(v2 + 164) = 2;
            goto LABEL_51;
          case 1:
            *(_DWORD *)(v2 + 164) = 4;
LABEL_51:
            sub_BCE20(v12, 2uLL);
            v3 = *(_DWORD *)(v2 + 164);
LABEL_17:
            if ( v3 == 7 )
            {
              a1 = v2 + 120;
              if ( (unsigned __int64)sub_BCD00(v2 + 120) <= 1 )
                goto LABEL_29;
              sub_BCF10(v2 + 120, &v33, 2uLL);
              if ( v33 != 1 )
              {
                a1 = *(_QWORD *)(v2 + 16);
                (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                  a1,
                  "Proxy error: SOCKS password subnegotiation contained wrong version number",
                  8000LL,
                  0LL);
                goto LABEL_29;
              }
              if ( v34 )
              {
                a1 = *(_QWORD *)(v2 + 16);
                (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                  a1,
                  "Proxy error: SOCKS proxy refused password authentication",
                  8000LL,
                  0LL);
                goto LABEL_29;
              }
              sub_BCE20(v2 + 120, 2uLL);
              *(_DWORD *)(v2 + 164) = 2;
LABEL_38:
              v13 = sub_BC640();
              v14 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v13 + 24);
              v15 = (void **)v13;
              sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v13 + 24), 5);
              sub_2ECE0(v14, 1);
              sub_2ECE0(v14, 0);
              v16 = sub_B6220(*(_QWORD *)(v2 + 24));
              if ( v16 == 2 )
              {
                sub_2ECE0(v14, 4);
                v18 = 16LL;
LABEL_45:
                v19 = (__m128i *)sub_BC510((__int64)v15, v18);
                sub_B6260(*(_QWORD *)(v2 + 24), v19);
                goto LABEL_41;
              }
              if ( v16 != 4 )
              {
                if ( v16 != 1 )
                  goto LABEL_41;
                sub_2ECE0(v14, 1);
                v18 = 4LL;
                goto LABEL_45;
              }
              sub_2ECE0(v14, 3);
              sub_B60F0(*(_QWORD *)(v2 + 24), &v33, 512);
              if ( (unsigned __int8)sub_2EFC0((void (__fastcall **)(_QWORD, char *, signed __int64))v14, &v33) )
              {
LABEL_41:
                v17 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14;
                v3 = 1;
                sub_2ED40(v17, *(_DWORD *)(v2 + 32));
                (*(void (__fastcall **)(_QWORD, void *, void *))(**(_QWORD **)(v2 + 8) + 16LL))(
                  *(_QWORD *)(v2 + 8),
                  *v15,
                  v15[2]);
                a1 = (signed __int64)v15;
                sub_BC660(v15);
                *(_DWORD *)(v2 + 164) = 3;
              }
              else
              {
                a1 = (signed __int64)v15;
                v3 = 1;
                *(_QWORD *)v2 = "Proxy error: SOCKS 5 cannot support host names longer than 255 chars";
                sub_BC660(v15);
              }
            }
            else
            {
              if ( v3 != 8 )
                goto LABEL_19;
              a1 = v2;
              v3 = sub_28260(v2);
              if ( !v3 )
              {
                v3 = *(_DWORD *)(v2 + 164);
LABEL_19:
                switch ( v3 )
                {
                  case 2u:
                    goto LABEL_38;
                  case 3u:
                    a1 = v2 + 120;
                    if ( (unsigned __int64)sub_BCD00(v2 + 120) <= 4 )
                      goto LABEL_29;
                    sub_BCF10(v2 + 120, &v29, 5uLL);
                    if ( v29 != 5 )
                    {
                      a1 = *(_QWORD *)(v2 + 16);
                      (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                        a1,
                        "Proxy error: SOCKS proxy returned wrong version number",
                        8000LL,
                        0LL);
                      goto LABEL_29;
                    }
                    if ( v30 )
                    {
                      v27 = (unsigned int)v30;
                      strcpy(&v33, "Proxy error: ");
                      switch ( v30 )
                      {
                        case 1:
                          strcpy(&v35, "General SOCKS server failure");
                          break;
                        case 2:
                          strcpy(&v35, "Connection not allowed by ruleset");
                          break;
                        case 3:
                          v35 = _mm_load_si128((const __m128i *)&xmmword_E7B10);
                          *(_DWORD *)&v36 = 6646882;
                          break;
                        case 4:
                          v35 = _mm_load_si128((const __m128i *)&xmmword_E7B20);
                          v36 = 0;
                          break;
                        case 5:
                          strcpy(&v35, "Connection refused");
                          break;
                        case 6:
                          v35.m128i_i64[0] = 7597704947102930004LL;
                          v35.m128i_i32[2] = 6579570;
                          break;
                        case 7:
                          strcpy(&v35, "Command not supported");
                          break;
                        case 8:
                          strcpy(&v35, "Address type not supported");
                          break;
                        default:
                          __sprintf_chk(&v35, 1LL, -1LL, "Unrecognised SOCKS error code %d", v27);
                          break;
                      }
                      a1 = *(_QWORD *)(v2 + 16);
                      (*(void (__fastcall **)(signed __int64, char *, signed __int64, _QWORD, __int64))(*(_QWORD *)a1 + 8LL))(
                        a1,
                        &v33,
                        8000LL,
                        0LL,
                        v27);
                    }
                    else
                    {
                      switch ( v31 )
                      {
                        case 3:
                          v26 = v32 + 7;
                          break;
                        case 4:
                          v26 = 22;
                          break;
                        case 1:
                          v26 = 10;
                          break;
                        default:
                          a1 = *(_QWORD *)(v2 + 16);
                          (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                            a1,
                            "Proxy error: SOCKS proxy returned unrecognised address format",
                            8000LL,
                            0LL);
                          goto LABEL_29;
                      }
                      a1 = v2 + 120;
                      if ( sub_BCD00(v2 + 120) >= (unsigned __int64)v26 )
                      {
                        sub_BCE20(v2 + 120, v26);
                        a1 = v2;
                        sub_39680(v2);
                      }
                    }
LABEL_29:
                    v3 = 1;
                    break;
                  case 4u:
                    a1 = *(_QWORD *)(v2 + 16);
                    v3 = 1;
                    (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                      a1,
                      "Proxy error: We don't support GSSAPI authentication",
                      8000LL,
                      0LL);
                    break;
                  case 5u:
                    v20 = (const char *)sub_1F170(*(__int64 **)(v2 + 232), 16);
                    v21 = (const char *)sub_1F170(*(__int64 **)(v2 + 232), 17);
                    v22 = v21;
                    if ( !*v20 && !*v21 )
                    {
                      a1 = *(_QWORD *)(v2 + 16);
                      (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                        a1,
                        "Proxy error: Server chose username/password authentication but we didn't offer it!",
                        8000LL,
                        0LL);
                      goto LABEL_29;
                    }
                    v23 = sub_BC650();
                    v24 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v23 + 24);
                    v25 = (_QWORD *)v23;
                    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v23 + 24), 1);
                    if ( (unsigned __int8)sub_2EFC0(v24, v20) )
                    {
                      if ( (unsigned __int8)sub_2EFC0(v24, v22) )
                      {
                        (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 8) + 16LL))(
                          *(_QWORD *)(v2 + 8),
                          *v25,
                          v25[2]);
                        a1 = (signed __int64)v25;
                        v3 = 1;
                        sub_BC660((void **)a1);
                        *(_DWORD *)(v2 + 164) = 7;
                      }
                      else
                      {
                        a1 = (signed __int64)v25;
                        v3 = 1;
                        *(_QWORD *)v2 = "Proxy error: SOCKS 5 authentication cannot support passwords longer than 255 chars";
                        sub_BC660((void **)a1);
                      }
                    }
                    else
                    {
                      a1 = (signed __int64)v25;
                      v3 = 1;
                      *(_QWORD *)v2 = "Proxy error: SOCKS 5 authentication cannot support usernames longer than 255 chars";
                      sub_BC660((void **)a1);
                    }
                    break;
                  default:
                    if ( v3 != 6 || (a1 = v2, (v3 = sub_28570(v2)) == 0) )
                    {
LABEL_15:
                      a1 = *(_QWORD *)(v2 + 16);
                      v3 = 1;
                      (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
                        a1,
                        "Proxy error: Unexpected proxy error",
                        8001LL,
                        0LL);
                    }
                    break;
                }
              }
            }
            break;
          case 2:
            *(_DWORD *)(v2 + 164) = 5;
            goto LABEL_51;
          case 3:
            *(_DWORD *)(v2 + 164) = 6;
            goto LABEL_51;
          default:
            a1 = *(_QWORD *)(v2 + 16);
            (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
              a1,
              "Proxy error: SOCKS proxy did not accept our authentication",
              8000LL,
              0LL);
            break;
        }
      }
      else
      {
        a1 = *(_QWORD *)(v2 + 16);
        (*(void (__fastcall **)(signed __int64, const char *, signed __int64, _QWORD))(*(_QWORD *)a1 + 8LL))(
          a1,
          "Proxy error: SOCKS proxy returned unexpected version",
          8000LL,
          0LL);
      }
    }
  }
}

__int64 __fastcall sub_3A770(char *src, __int64 a2, _QWORD *a3, __int64 *a4, __int64 a5, __int64 a6, __int64 a7)
{
  _QWORD *v7; // r14
  __int64 *v8; // r12
  int v9; // ebp
  __int64 v10; // r13
  char *v11; // rdx
  char *v12; // rax
  __int64 result; // rax

  v7 = a3;
  v8 = a4;
  v9 = a5;
  v10 = a6;
  if ( (unsigned int)sub_1EFD0(a4, 13)
    && (!(unsigned int)sub_1EFD0(v8, 11) || (unsigned int)sub_1EFD0(v8, 11) == 2 && (unsigned int)sub_1EFD0(v8, 13) != 1)
    && (unsigned __int8)sub_39240(0LL, src, v8) )
  {
    if ( v10 )
      sub_2D3F0(v10, (__int64)"Leaving host lookup to proxy of \"%s\" (for %s)", v10, a7);
    *v7 = sub_BC120(src);
    result = sub_B6090(src);
  }
  else
  {
    if ( v10 )
    {
      v11 = " (IPv4)";
      if ( v9 != 1 )
      {
        v11 = " (IPv6)";
        if ( v9 != 2 )
          v11 = &locale;
      }
      v12 = sub_BC360((__int64)"Looking up host \"%s\"%s for %s", src, v11, a7);
      sub_2D3A0(v10, v12, v10, a7);
    }
    result = sub_B7550(src, v7, v9);
  }
  return result;
}

void *__fastcall sub_3A8A0(__int64 a1, const char *a2, unsigned int a3, unsigned __int8 a4, __int64 a5, __int64 a6, __int64 a7, void (__fastcall ***a8)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD), __int64 *a9)
{
  unsigned int v9; // er14
  unsigned int v10; // ebx
  unsigned __int8 v11; // ST28_1
  unsigned __int8 v12; // ST20_1
  int v13; // eax
  unsigned int v14; // er11
  char v15; // al
  void *v16; // r10
  char v18; // ST38_1
  _QWORD *v19; // rax
  signed __int64 v20; // rdi
  int v21; // eax
  char v22; // r11
  unsigned int v23; // er12
  __int64 v24; // rax
  char *v25; // r12
  int v26; // er12
  __int64 v27; // rax
  char *v28; // rdx
  char *v29; // r12
  char *v30; // rax
  struct addrinfo **v31; // r12
  unsigned int v32; // eax
  char *v33; // r14
  unsigned int v34; // eax
  __int64 v35; // rsi
  __int64 *v36; // rax
  __int64 v37; // rdx
  __int64 v38; // rax
  __int64 v39; // [rsp+0h] [rbp-188h]
  char v40; // [rsp+0h] [rbp-188h]
  unsigned int v41; // [rsp+8h] [rbp-180h]
  _QWORD *v42; // [rsp+8h] [rbp-180h]
  const char *v43; // [rsp+18h] [rbp-170h]
  char v44; // [rsp+20h] [rbp-168h]
  void *v45; // [rsp+28h] [rbp-160h]
  void *v46; // [rsp+38h] [rbp-150h]
  char v47; // [rsp+40h] [rbp-148h]
  unsigned __int64 v48; // [rsp+148h] [rbp-40h]

  v9 = a3;
  v10 = (unsigned __int8)a6;
  v11 = a4;
  v12 = a5;
  v48 = __readfsqword(0x28u);
  v13 = sub_1EFD0(a9, 13);
  v14 = v12;
  LODWORD(v39) = v11;
  if ( !v13 )
    return (void *)sub_B6300(a1, v9, v39, v14, v10, a7, (__int64)a8);
  v41 = v14;
  v15 = sub_39240(a1, a2, a9);
  LOBYTE(v14) = v41;
  if ( !v15 )
    return (void *)sub_B6300(a1, v9, v39, v14, v10, a7, (__int64)a8);
  v16 = sub_B8220(a1, (__int64)a2, v9, (unsigned int)v39, v41, v10, (unsigned __int8)a7, a8, a9);
  if ( !v16 )
  {
    v18 = v41;
    v19 = sub_2F450(1uLL, 0x110uLL, 0LL);
    v42 = v19;
    v19[32] = off_31E4C0;
    v19[33] = off_31E480;
    v19[29] = sub_1EED0(a9);
    v42[3] = a1;
    v42[2] = a8;
    *((_DWORD *)v42 + 8) = v9;
    v20 = (signed __int64)(v42 + 15);
    *(_QWORD *)(v20 - 120) = 0LL;
    *(_BYTE *)(v20 + 40) = 0;
    *(_BYTE *)(v20 + 48) = 0;
    sub_BCC70(v42 + 15);
    sub_BCC70(v42 + 5);
    sub_BCC70(v42 + 10);
    v42[1] = 0LL;
    *((_DWORD *)v42 + 41) = -1;
    v42[22] = 0LL;
    v21 = sub_1EFD0(a9, 13);
    v22 = v18;
    if ( v21 == 3 )
    {
      v16 = v42 + 32;
      v42[22] = sub_397B0;
      v43 = "HTTP";
    }
    else
    {
      v16 = v42 + 32;
      switch ( v21 )
      {
        case 1:
          v42[22] = sub_39CE0;
          v43 = "SOCKS 4";
          break;
        case 2:
          v42[22] = sub_39FB0;
          v43 = "SOCKS 5";
          break;
        case 4:
          v42[22] = sub_3B270;
          v43 = "Telnet";
          break;
        default:
          *v42 = "Proxy error: Unknown proxy method";
          return v16;
      }
    }
    v45 = v16;
    v44 = v22;
    v23 = sub_1EFD0(a9, 15);
    v24 = sub_1F170(a9, 14);
    v25 = sub_BC360((__int64)"Will use %s proxy at %s:%d to connect to %s:%d", v43, v24, v23, a2, v9, v39);
    (**a8)(a8, 3LL, 0LL, 0LL, v25, 0LL);
    sub_2F4D0(v25);
    v26 = sub_1EFD0(a9, 3);
    v27 = sub_1F170(a9, 14);
    v28 = " (IPv4)";
    if ( v26 != 1 )
    {
      v28 = &locale;
      if ( v26 == 2 )
        v28 = " (IPv6)";
    }
    v29 = sub_BC360((__int64)"Looking up host \"%s\"%s for %s", v27, v28, "proxy");
    (**a8)(a8, 3LL, 0LL, 0LL, v29, 0LL);
    sub_2F4D0(v29);
    LODWORD(v29) = sub_1EFD0(a9, 3);
    v30 = (char *)sub_1F170(a9, 14);
    v31 = (struct addrinfo **)sub_B7550(v30, &v46, (int)v29);
    if ( sub_B72A0((__int64)v31) )
    {
      *v42 = "Proxy error: Unable to resolve proxy host name";
      sub_B62D0(v31);
      v16 = v45;
    }
    else
    {
      sub_2F4D0(v46);
      sub_B60F0((__int64)v31, &v47, 256);
      v32 = sub_1EFD0(a9, 15);
      v33 = sub_BC360((__int64)"Connecting to %s proxy at %s port %d", v43, &v47, v32);
      (**a8)(a8, 3LL, 0LL, 0LL, v33, 0LL);
      sub_2F4D0(v33);
      v34 = sub_1EFD0(a9, 15);
      v35 = v34;
      v36 = (__int64 *)sub_B6300((__int64)v31, v34, v40, v44, v10, a7, (__int64)(v42 + 33));
      v37 = *v36;
      v42[1] = v36;
      v38 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v37 + 48))(v36, v35);
      v16 = v45;
      if ( !v38 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)v42[1] + 40LL))(v42[1], 0LL);
        ((void (__fastcall *)(_QWORD *, signed __int64))v42[22])(v42, 0xFFFFFFFFLL);
        v16 = v45;
      }
    }
  }
  return v16;
}

__int64 __fastcall sub_3ADB0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5, unsigned int a6)
{
  return sub_B6430((char *)a1, a2, a3, a4, a6);
}

__int64 __fastcall sub_3ADC0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rbx
  __int64 v4; // r12
  int v5; // edi
  char v6; // dl
  _BYTE *v7; // rax
  int v8; // er15
  char v9; // dl
  _BYTE *v10; // r14
  int v11; // ebp
  __int64 v12; // rdx
  char v13; // al
  int v14; // esi
  unsigned int v15; // eax
  __int64 (**v17)(void); // rdi
  char *v18; // rdx
  int v19; // esi
  const char *v20; // rbp
  const char *v21; // rbp
  signed __int64 v22; // r9
  int v23; // eax
  int v24; // ecx
  int v25; // er13
  int v26; // eax
  char *v27; // [rsp+0h] [rbp-268h]
  __int64 *v28; // [rsp+8h] [rbp-260h]
  __int64 v29; // [rsp+10h] [rbp-258h]
  unsigned int v30; // [rsp+1Ch] [rbp-24Ch]
  char v31; // [rsp+20h] [rbp-248h]
  unsigned __int64 v32; // [rsp+228h] [rbp-40h]

  v29 = a1;
  v30 = a2;
  v28 = a3;
  v32 = __readfsqword(0x28u);
  v3 = sub_1F170(a3, 18);
  v4 = sub_BC640();
  v5 = 0;
  v27 = &v31;
  while ( 1 )
  {
LABEL_2:
    v6 = *(_BYTE *)(v3 + v5);
    if ( !v6 )
      return sub_BC6B0((__int64 *)v4);
    if ( v6 == 37 )
    {
      v8 = v5;
      v10 = (_BYTE *)(v3 + v5);
      goto LABEL_10;
    }
    v7 = (_BYTE *)(v3 + v5 + 1);
    v8 = v5;
    if ( v6 == 92 )
      break;
    while ( 1 )
    {
      v9 = *v7;
      ++v8;
      v10 = v7;
      if ( !*v7 || v9 == 37 )
        break;
      ++v7;
      if ( v9 == 92 )
        goto LABEL_8;
    }
    if ( !v9 )
      goto LABEL_21;
LABEL_8:
    if ( v5 != v8 )
      sub_2EC20((__int64 (**)(void))(v4 + 24));
LABEL_10:
    v11 = v8 + 1;
    v12 = v8 + 1;
    v13 = *(_BYTE *)(v3 + v12);
    if ( !v13 )
    {
      v5 = v8++;
      goto LABEL_21;
    }
    if ( *v10 == 92 )
      goto LABEL_25;
    if ( v13 == 37 )
    {
      v17 = (__int64 (**)(void))(v4 + 24);
      goto LABEL_39;
    }
    if ( !strncasecmp((const char *)(v3 + v11), "host", 4uLL) )
    {
      sub_B60F0(v29, v27, 512);
      v18 = v27;
      do
      {
        v19 = *(_DWORD *)v18;
        v18 += 4;
      }
      while ( !(~v19 & (v19 - 16843009) & 0x80808080) );
      sub_2EC20((__int64 (**)(void))(v4 + 24));
      v5 = v8 + 5;
    }
    else
    {
      if ( !strncasecmp((const char *)(v3 + v11), "port", 4uLL) )
      {
        sub_BC720(v4, (__int64)"%d", v30, v27);
        v5 = v8 + 5;
        continue;
      }
      v14 = 16;
      if ( !strncasecmp((const char *)(v3 + v11), "user", 4uLL) )
        goto LABEL_41;
      if ( !strncasecmp((const char *)(v3 + v11), "pass", 4uLL) )
      {
        v14 = 17;
LABEL_41:
        v20 = (const char *)sub_1F170(v28, v14);
        strlen(v20);
        sub_2EC20((__int64 (**)(void))(v4 + 24));
        v5 = v8 + 5;
        continue;
      }
      if ( !strncasecmp((const char *)(v3 + v11), "proxyhost", 9uLL) )
      {
        v21 = (const char *)sub_1F170(v28, 14);
        strlen(v21);
        sub_2EC20((__int64 (**)(void))(v4 + 24));
        v5 = v8 + 10;
      }
      else if ( !strncasecmp((const char *)(v3 + v11), "proxyport", 9uLL) )
      {
        v15 = sub_1EFD0(v28, 15);
        sub_BC720(v4, (__int64)"%d", v15, v27);
        v5 = v8 + 10;
      }
      else
      {
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v4 + 24), 37);
        v5 = v8 + 1;
      }
    }
  }
  v11 = v5 + 1;
  v12 = v5 + 1;
  v13 = *(_BYTE *)(v3 + v12);
  if ( v13 )
  {
LABEL_25:
    v17 = (__int64 (**)(void))(v4 + 24);
    if ( v13 == 110 )
    {
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 10);
      v5 = v8 + 2;
      goto LABEL_2;
    }
    if ( v13 > 110 )
    {
      if ( v13 == 116 )
      {
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 9);
        v5 = v8 + 2;
        goto LABEL_2;
      }
      if ( v13 != 120 )
      {
        if ( v13 == 114 )
        {
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 13);
          v5 = v8 + 2;
          goto LABEL_2;
        }
        goto LABEL_30;
      }
    }
    else if ( v13 != 88 )
    {
      if ( v13 == 92 )
      {
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 92);
        v5 = v8 + 2;
        goto LABEL_2;
      }
      if ( v13 == 37 )
      {
LABEL_39:
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 37);
        v5 = v8 + 2;
        goto LABEL_2;
      }
LABEL_30:
      sub_2EC20(v17);
      v5 = v8 + 2;
      goto LABEL_2;
    }
    v22 = v12 + 2;
    v23 = 0;
    while ( 2 )
    {
      v24 = *(unsigned __int8 *)(v3 + v12 + 1);
      v25 = v12;
      if ( (unsigned __int8)(v24 - 48) > 9u )
      {
        if ( (unsigned __int8)(v24 - 97) <= 5u )
        {
          v26 = v24 + v23 - 87;
          goto LABEL_49;
        }
        if ( (unsigned __int8)(v24 - 65) > 5u )
        {
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, 92);
          v5 = v11;
          goto LABEL_2;
        }
        ++v12;
        v26 = v24 + v23 - 55;
        if ( v12 == v22 )
        {
LABEL_50:
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v17, v26);
          v5 = v25 + 2;
          goto LABEL_2;
        }
      }
      else
      {
        v26 = v24 + v23 - 48;
LABEL_49:
        if ( ++v12 == v22 )
          goto LABEL_50;
      }
      v23 = 16 * v26;
      continue;
    }
  }
  v8 = v5 + 1;
LABEL_21:
  if ( v5 != v8 )
    sub_2EC20((__int64 (**)(void))(v4 + 24));
  return sub_BC6B0((__int64 *)v4);
}

__int64 __fastcall sub_3B270(__int64 a1, int a2)
{
  __int64 v2; // rbx
  __int64 result; // rax
  const char *v4; // rax
  char *v5; // r13
  size_t v6; // rax
  unsigned __int8 *v7; // r14
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // rbp
  unsigned __int8 *v10; // r12
  char *v11; // rbp
  size_t v12; // rax
  unsigned __int8 *v13; // rdi

  v2 = a1;
  if ( *(_DWORD *)(a1 + 164) == -1 )
  {
    v4 = (const char *)sub_3ADC0(*(_QWORD *)(a1 + 24), *(unsigned int *)(a1 + 32), *(__int64 **)(a1 + 232));
    v5 = (char *)v4;
    v6 = strlen(v4);
    v7 = (unsigned __int8 *)sub_2F450(4 * v6 + 1, 1uLL, 0LL);
    v8 = *v5;
    v9 = v7;
    if ( *v5 )
    {
      v10 = (unsigned __int8 *)v5;
      do
      {
        while ( v8 == 10 )
        {
          ++v10;
          v9 += 2;
          *((_WORD *)v9 - 1) = 28252;
          v8 = *v10;
          if ( !*v10 )
            goto LABEL_15;
        }
        switch ( v8 )
        {
          case 0xDu:
            v9 += 2;
            *((_WORD *)v9 - 1) = 29276;
            break;
          case 9u:
            v9 += 2;
            *((_WORD *)v9 - 1) = 29788;
            break;
          case 0x5Cu:
            v9 += 2;
            *((_WORD *)v9 - 1) = 23644;
            break;
          default:
            if ( (unsigned int)v8 - 32 > 0x5E )
            {
              v13 = v9;
              v9 += 4;
              __sprintf_chk(v13, 1LL, -1LL, "\\x%02X", v8);
            }
            else
            {
              *v9++ = v8;
            }
            break;
        }
        v8 = *++v10;
      }
      while ( *v10 );
    }
LABEL_15:
    *v9 = 0;
    v11 = sub_BC360((__int64)"Sending Telnet proxy command: %s", v7);
    (***(void (__fastcall ****)(_QWORD, signed __int64, _QWORD, _QWORD, char *, _QWORD))(v2 + 16))(
      *(_QWORD *)(v2 + 16),
      3LL,
      0LL,
      0LL,
      v11,
      0LL);
    sub_2F4D0(v11);
    sub_2F4D0(v7);
    v12 = strlen(v5);
    (*(void (__fastcall **)(_QWORD, char *, size_t))(**(_QWORD **)(v2 + 8) + 16LL))(*(_QWORD *)(v2 + 8), v5, v12);
    sub_2F4D0(v5);
    *(_DWORD *)(v2 + 164) = 1;
    result = 0LL;
  }
  else if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = 0LL;
    }
    else if ( a2 == 3 )
    {
      result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 32LL))(
                 *(_QWORD *)(a1 + 16),
                 *(_QWORD *)(a1 + 216),
                 *(_QWORD *)(a1 + 224));
    }
    else
    {
      if ( a2 == 2 )
        sub_39680(a1);
      else
        (*(void (__fastcall **)(_QWORD, const char *, signed __int64, _QWORD))(**(_QWORD **)(a1 + 16) + 8LL))(
          *(_QWORD *)(a1 + 16),
          "Proxy error: Unexpected proxy error",
          8001LL,
          0LL);
      result = 1LL;
    }
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 8LL))(
      *(_QWORD *)(a1 + 16),
      *(_QWORD *)(a1 + 184),
      *(unsigned int *)(a1 + 192),
      *(unsigned __int8 *)(a1 + 196));
    result = 0LL;
  }
  return result;
}

__int64 __fastcall sub_3B4F0(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 result; // rax

  v1 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(a1 - 32))(*(_QWORD *)(a1 - 32), 0LL);
  result = (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 56) + 40LL))(*(_QWORD *)(a1 - 56), v1 > 0x1000);
  *(_BYTE *)(a1 - 14) = 1;
  return result;
}

void __fastcall sub_3B520(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 40) = a2;
}

void nullsub_12()
{
  ;
}

__int64 __fastcall sub_3B540(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 result; // rax

  v1 = a1;
  v2 = *(_QWORD *)(a1 - 64);
  if ( !v2 )
    return 0LL;
  result = (*(__int64 (**)(void))(*(_QWORD *)v2 + 16LL))();
  *(_QWORD *)(v1 - 48) = result;
  return result;
}

__int64 __fastcall sub_3B570(__int64 a1)
{
  return *(_QWORD *)(a1 - 48);
}

void nullsub_13()
{
  ;
}

__int64 sub_3B590()
{
  return 0LL;
}

bool __fastcall sub_3B5A0(__int64 a1)
{
  return *(_QWORD *)(a1 - 64) != 0LL;
}

signed __int64 sub_3B5B0()
{
  return 1LL;
}

__int64 __fastcall sub_3B5C0(__int64 a1, unsigned __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 64) + 40LL))(*(_QWORD *)(a1 - 64), a2 > 0x1000);
}

bool __fastcall sub_3B5E0(__int64 a1, unsigned int a2)
{
  return a2 <= 1;
}

signed __int64 __fastcall sub_3B5F0(__int64 a1)
{
  signed __int64 result; // rax

  result = 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 - 64) )
    result = *(_BYTE *)(a1 - 56) >= 1u ? 0x7FFFFFFF : 0;
  return result;
}

__int64 sub_3B610()
{
  return 0LL;
}

void __fastcall sub_3B620(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi

  v1 = (void *)(a1 - 64);
  v2 = a1;
  v3 = *(_QWORD *)(a1 - 64);
  if ( v3 )
    (*(void (**)(void))(*(_QWORD *)v3 + 8LL))();
  sub_1ED50(*(_QWORD **)(v2 - 16));
  sub_2F4D0(v1);
}

char *__fastcall sub_3B660(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 *a5, char *a6, unsigned int a7, __int64 *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  _QWORD *v10; // r15
  __int64 *v11; // rbp
  char *v12; // ST20_8
  __int64 v13; // ST28_8
  signed int v14; // er12
  char *v15; // rax
  char *v16; // rbx
  _QWORD *v17; // rax
  unsigned int v18; // eax
  __int64 v19; // rax
  struct addrinfo **v20; // r13
  __int64 v21; // rax
  __int64 v22; // rsi
  __int64 *v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rax
  char *v26; // rdi
  char *v28; // r15
  char *v29; // rbx
  char *v30; // rax
  _BYTE *v31; // rax

  v10 = a3;
  v11 = a5;
  v12 = a6;
  v13 = a4;
  v14 = a7;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a2 + 136LL))(a2, 0LL);
  v15 = (char *)sub_2F450(1uLL, 0x48uLL, 0LL);
  v16 = v15;
  *(_QWORD *)v15 = 0LL;
  v15[8] = 0;
  *((_QWORD *)v15 + 7) = off_31E5C0;
  *((_QWORD *)v15 + 8) = a1;
  *v10 = v15 + 64;
  v15[41] = 0;
  v15[40] = 0;
  *((_QWORD *)v15 + 2) = 0LL;
  v15[42] = 0;
  v17 = sub_1EED0(v11);
  *((_QWORD *)v16 + 3) = a2;
  *((_QWORD *)v16 + 6) = v17;
  *((_QWORD *)v16 + 4) = v13;
  v18 = sub_1EFD0(v11, 3);
  v19 = sub_3A770(v12, a7, a8, v11, v18, *((_QWORD *)v16 + 4), (__int64)"main connection");
  v20 = (struct addrinfo **)v19;
  v21 = sub_B72A0(v19);
  if ( v21 )
  {
    v28 = (char *)v21;
    sub_B62D0(v20);
    v26 = v28;
    return sub_BC120(v26);
  }
  if ( (a7 & 0x80000000) != 0 )
    v14 = 23;
  v22 = *a8;
  v23 = (__int64 *)sub_3A8A0(
                     (__int64)v20,
                     (const char *)*a8,
                     v14,
                     0,
                     1LL,
                     a9,
                     a10,
                     (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))v16 + 7,
                     v11);
  v24 = *v23;
  *(_QWORD *)v16 = v23;
  v25 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v24 + 48))(v23, v22);
  if ( v25 )
  {
    v26 = (char *)v25;
    return sub_BC120(v26);
  }
  v29 = (char *)sub_1F170(v11, 9);
  if ( *v29 )
  {
    sub_2F4D0((void *)*a8);
    v30 = sub_BC120(v29);
    *a8 = (__int64)v30;
    v31 = sub_BC0D0(v30, 58);
    if ( v31 )
      *v31 = 0;
  }
  return 0LL;
}

unsigned __int64 __usercall sub_3B820@<rax>(__int64 a1@<rdi>, unsigned int a2@<esi>, __int64 a3@<rdx>, unsigned int a4@<ecx>, __int64 a5@<r8>, __int64 a6@<r9>, void (__fastcall ***a7)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 a8@<r15>)
{
  return sub_1B7C0(
           *(void (__fastcall ****)(_QWORD, signed __int64, const char *, __int64))(a1 - 32),
           *(_QWORD *)(a1 - 24),
           a2,
           a3,
           a4,
           a5,
           a7,
           a8,
           a6,
           *(_QWORD *)(a1 - 8),
           *(_BYTE *)(a1 - 14));
}

__int64 __fastcall sub_3B860(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rdi
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    (*(void (**)(void))(*(_QWORD *)v2 + 8LL))();
    v3 = v1[3];
    *v1 = 0LL;
    result = (*(__int64 (**)(void))(*(_QWORD *)v3 + 24LL))();
  }
  return result;
}

void __fastcall sub_3B8A0(__int64 a1, int a2)
{
  __int64 v2; // rax
  bool v3; // zf

  if ( a2 == 1 )
  {
    v2 = *(_QWORD *)(a1 - 64);
    if ( v2 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 32LL))(v2);
      v3 = *(_BYTE *)(a1 - 24) == 0;
      *(_BYTE *)(a1 - 23) = 1;
      if ( !v3 )
        sub_3B860((_QWORD *)(a1 - 64));
    }
  }
}

__int64 __usercall sub_3B8E0@<rax>(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rdi
  __int64 result; // rax
  __int64 v8; // rdi

  v4 = a1;
  if ( !a2 )
  {
    if ( *(_BYTE *)(a1 - 16) || !(*(unsigned __int8 (**)(void))(**(_QWORD **)(a1 - 32) + 8LL))() )
    {
      result = *(unsigned __int8 *)(a1 - 15);
      *(_BYTE *)(a1 - 16) = 1;
      if ( !(_BYTE)result )
        return result;
    }
    else if ( *(_BYTE *)(a1 - 15) )
    {
      *(_BYTE *)(a1 - 16) = 1;
    }
    else
    {
      v8 = *(_QWORD *)(a1 - 56);
      if ( v8 )
        (*(void (**)(void))(*(_QWORD *)v8 + 32LL))();
      *(_BYTE *)(v4 - 15) = 1;
      *(_BYTE *)(v4 - 16) = 1;
    }
    return sub_3B860((_QWORD *)(v4 - 56));
  }
  v5 = *(_QWORD *)(a1 - 56);
  if ( v5 )
  {
    (*(void (**)(void))(*(_QWORD *)v5 + 8LL))();
    v6 = *(_QWORD *)(v4 - 32);
    *(_QWORD *)(v4 - 56) = 0LL;
    *(_BYTE *)(v4 - 48) = 1;
    (*(void (**)(void))(*(_QWORD *)v6 + 24LL))();
  }
  sub_2D2C0(*(_QWORD *)(v4 - 24), a2, a3, a4);
  return sub_31A30(*(_QWORD *)(v4 - 32), (__int64)"%s", a2);
}

void nullsub_14()
{
  ;
}

void __fastcall sub_3B9B0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 - 52) = a2;
}

void nullsub_15()
{
  ;
}

__int64 __fastcall sub_3B9D0(__int64 a1)
{
  return *(signed int *)(a1 - 60);
}

unsigned __int64 __fastcall sub_3B9E0(__int64 a1, int a2, int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v6; // [rsp+Ch] [rbp-1Ch]
  int v7; // [rsp+14h] [rbp-14h]
  unsigned __int64 v8; // [rsp+18h] [rbp-10h]

  v3 = a1;
  *(_DWORD *)(a1 - 52) = a2;
  *(_DWORD *)(a1 - 48) = a3;
  v4 = *(_QWORD *)(a1 - 72);
  v6 = 1936982015LL;
  v8 = __readfsqword(0x28u);
  v7 = 0;
  if ( v4 && *(_BYTE *)(v3 - 55) )
  {
    HIBYTE(v6) = a2;
    BYTE4(v6) = BYTE1(a3);
    BYTE5(v6) = a3;
    BYTE6(v6) = BYTE1(a2);
    *(_DWORD *)(v3 - 60) = (*(__int64 (__fastcall **)(__int64, __int64 *, signed __int64))(*(_QWORD *)v4 + 16LL))(
                             v4,
                             &v6,
                             12LL);
  }
  return __readfsqword(0x28u) ^ v8;
}

void nullsub_16()
{
  ;
}

__int64 sub_3BA70()
{
  return 0LL;
}

bool __fastcall sub_3BA80(__int64 a1)
{
  return *(_QWORD *)(a1 - 72) != 0LL;
}

signed __int64 sub_3BA90()
{
  return 1LL;
}

__int64 __fastcall sub_3BAA0(__int64 a1, unsigned __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 72) + 40LL))(*(_QWORD *)(a1 - 72), a2 > 0x1000);
}

__int64 sub_3BAC0()
{
  return 0LL;
}

signed __int64 __fastcall sub_3BAD0(__int64 a1)
{
  signed __int64 result; // rax

  result = 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 - 72) )
    result = *(_BYTE *)(a1 - 64) >= 1u ? 0x7FFFFFFF : 0;
  return result;
}

__int64 sub_3BAF0()
{
  return 0LL;
}

unsigned __int64 __fastcall sub_3BB00(_QWORD *a1, const char *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  const char *v4; // rax
  const char *v5; // r13
  size_t v6; // rax
  size_t v7; // rax
  const char *v8; // rax
  const char *v9; // r12
  size_t v10; // rax
  const char *v11; // rax
  const char *v12; // r12
  size_t v13; // rax
  char v15; // [rsp+7h] [rbp-31h]
  unsigned __int64 v16; // [rsp+8h] [rbp-30h]

  v2 = a1;
  v3 = *a1;
  v16 = __readfsqword(0x28u);
  v15 = 0;
  (*(void (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v3 + 16LL))(v3, &v15, 1LL);
  v4 = (const char *)sub_1F170((__int64 *)v2[6], 58);
  v5 = v4;
  v6 = strlen(v4);
  (*(void (__fastcall **)(_QWORD, const char *, size_t))(*(_QWORD *)*v2 + 16LL))(*v2, v5, v6);
  (*(void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)*v2 + 16LL))(*v2, &v15, 1LL);
  v7 = strlen(a2);
  (*(void (__fastcall **)(_QWORD, const char *, size_t))(*(_QWORD *)*v2 + 16LL))(*v2, a2, v7);
  (*(void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)*v2 + 16LL))(*v2, &v15, 1LL);
  v8 = (const char *)sub_1F170((__int64 *)v2[6], 52);
  v9 = v8;
  v10 = strlen(v8);
  (*(void (__fastcall **)(_QWORD, const char *, size_t))(*(_QWORD *)*v2 + 16LL))(*v2, v9, v10);
  (*(void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)*v2 + 16LL))(*v2, "/", 1LL);
  v11 = (const char *)sub_1F170((__int64 *)v2[6], 53);
  v12 = v11;
  v13 = strspn(v11, "0123456789");
  (*(void (__fastcall **)(_QWORD, const char *, size_t))(*(_QWORD *)*v2 + 16LL))(*v2, v12, v13);
  *((_DWORD *)v2 + 3) = (*(__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)*v2 + 16LL))(
                          *v2,
                          &v15,
                          1LL);
  v2[7] = 0LL;
  return __readfsqword(0x28u) ^ v16;
}

__int64 __fastcall sub_3BC50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // r12
  __int64 v5; // rsi
  const char *v6; // rax
  __int64 v7; // rax
  char v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  result = 0LL;
  if ( *(_QWORD *)(a1 - 72) )
  {
    v4 = a3;
    sub_BCC70(&v8);
    sub_BCD20((__int64)&v8, (char *)a2, v4);
    v5 = *(_QWORD *)(a1 - 16);
    if ( !v5 )
      goto LABEL_13;
    if ( (*(signed int (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 - 40) + 16LL))(
           *(_QWORD *)(a1 - 40),
           v5,
           &v8) >= 0 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 - 40) + 136LL))(*(_QWORD *)(a1 - 40), 0LL);
      v6 = (const char *)sub_31C30(**(_QWORD **)(*(_QWORD *)(a1 - 16) + 56LL));
      sub_3BB00((_QWORD *)(a1 - 72), v6);
    }
    if ( !*(_QWORD *)(a1 - 16) )
    {
LABEL_13:
      while ( sub_BCD00((__int64)&v8) )
      {
        v7 = sub_BCF00((__int64)&v8);
        *(_DWORD *)(a1 - 60) = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 - 72) + 16LL))(
                                 *(_QWORD *)(a1 - 72),
                                 v7);
        sub_BCE20((__int64)&v8, v4);
      }
    }
    sub_BCCA0((__int64)&v8);
    result = *(signed int *)(a1 - 60);
  }
  return result;
}

void __fastcall sub_3BD50(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rdi

  v1 = (void *)(a1 - 72);
  v2 = a1;
  v3 = *(_QWORD *)(a1 - 16);
  if ( v3 )
    sub_31C50(v3);
  v4 = *(_QWORD *)(v2 - 72);
  if ( v4 )
    (*(void (**)(void))(*(_QWORD *)v4 + 8LL))();
  sub_1ED50(*(_QWORD **)(v2 - 24));
  sub_2F4D0(v1);
}

char *__fastcall sub_3BDA0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 *a5, char *a6, unsigned int a7, __int64 *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  _QWORD *v10; // r15
  __int64 *v11; // rbp
  char *src; // ST20_8
  __int64 v13; // ST28_8
  signed int v14; // er12
  __int64 **v15; // rax
  __int64 **v16; // rbx
  unsigned int v17; // eax
  __int64 v18; // rax
  struct addrinfo **v19; // r14
  __int64 v20; // rax
  __int64 v21; // rsi
  __int64 *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rax
  char *v25; // rdi
  char *v27; // r15
  char *v28; // rax
  char *v29; // rbp
  char *v30; // ST20_8
  char *v31; // rax
  _BYTE *v32; // rax
  __int64 *v33; // rax
  char *v34; // rax
  const char *v35; // rax

  v10 = a3;
  v11 = a5;
  src = a6;
  v13 = a4;
  v14 = a7;
  v15 = (__int64 **)sub_2F450(1uLL, 0x50uLL, 0LL);
  v16 = v15;
  v15[4] = (__int64 *)a2;
  *v15 = 0LL;
  *((_BYTE *)v15 + 8) = 0;
  v15[9] = (__int64 *)a1;
  v15[5] = (__int64 *)v13;
  v15[8] = (__int64 *)off_31E6C0;
  *((_DWORD *)v15 + 5) = sub_1EFD0(v11, 123);
  *((_DWORD *)v16 + 6) = sub_1EFD0(v11, 124);
  *((_BYTE *)v16 + 16) = 1;
  *((_BYTE *)v16 + 17) = 0;
  v16[7] = 0LL;
  v16[6] = sub_1EED0(v11);
  *v10 = v16 + 9;
  v17 = sub_1EFD0(v11, 3);
  v18 = sub_3A770(src, a7, a8, v11, v17, (__int64)v16[5], (__int64)"rlogin connection");
  v19 = (struct addrinfo **)v18;
  v20 = sub_B72A0(v18);
  if ( v20 )
  {
    v27 = (char *)v20;
    sub_B62D0(v19);
    v25 = v27;
    return sub_BC120(v25);
  }
  if ( (a7 & 0x80000000) != 0 )
    v14 = 513;
  v21 = *a8;
  v22 = (__int64 *)sub_3A8A0(
                     (__int64)v19,
                     (const char *)*a8,
                     v14,
                     1u,
                     0LL,
                     a9,
                     a10,
                     (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))v16 + 8,
                     v11);
  v23 = *v22;
  *v16 = v22;
  v24 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v23 + 48))(v22, v21);
  if ( v24 )
  {
    v25 = (char *)v24;
    return sub_BC120(v25);
  }
  v28 = (char *)sub_1F170(v11, 9);
  if ( *v28 )
  {
    v30 = v28;
    sub_2F4D0((void *)*a8);
    v31 = sub_BC120(v30);
    *a8 = (__int64)v31;
    v32 = sub_BC0D0(v31, 58);
    if ( v32 )
      *v32 = 0;
  }
  v29 = (char *)sub_3D010(v11);
  if ( v29 )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD))(*v16[4] + 136))(v16[4], 0LL);
    sub_3BB00(v16, v29);
    sub_2F4D0(v29);
  }
  else
  {
    v33 = sub_31B10();
    v16[7] = v33;
    *(_BYTE *)v33 = 1;
    *((_BYTE *)v33 + 1) = 0;
    v33[1] = (__int64)sub_BC120("Rlogin login name");
    v34 = sub_BC120("rlogin username: ");
    sub_31B70(v16[7], (__int64)v34, 1);
    if ( (*(signed int (__fastcall **)(__int64 *, __int64 *, _QWORD))(*v16[4] + 16))(v16[4], v16[7], 0LL) >= 0 )
    {
      (*(void (__fastcall **)(__int64 *, _QWORD))(*v16[4] + 136))(v16[4], 0LL);
      v35 = (const char *)sub_31C30(*(_QWORD *)v16[7][7]);
      sub_3BB00(v16, v35);
    }
  }
  return 0LL;
}

unsigned __int64 __usercall sub_3C040@<rax>(__int64 a1@<rdi>, unsigned int a2@<esi>, __int64 a3@<rdx>, unsigned int a4@<ecx>, __int64 a5@<r8>, __int64 a6@<r9>, void (__fastcall ***a7)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 a8@<r15>)
{
  return sub_1B7C0(
           *(void (__fastcall ****)(_QWORD, signed __int64, const char *, __int64))(a1 - 32),
           *(_QWORD *)(a1 - 24),
           a2,
           a3,
           a4,
           a5,
           a7,
           a8,
           a6,
           *(_QWORD *)(a1 - 16),
           *(_BYTE *)(a1 - 48) ^ 1u);
}

void __fastcall sub_3C080(__int64 a1, int a2, _BYTE *a3, __int64 a4)
{
  bool v4; // zf
  unsigned __int64 v5; // rax
  __int64 v6; // rax

  if ( a4 )
  {
    if ( a2 == 2 )
    {
      if ( *a3 == -128 )
      {
        v6 = *(_QWORD *)(a1 + 8);
        *(_BYTE *)(a1 - 47) = 1;
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(v6 + 40))(
          a1 + 8,
          *(unsigned int *)(a1 - 44),
          *(unsigned int *)(a1 - 40));
      }
    }
    else if ( !*(_BYTE *)(a1 - 48) || (v4 = *a3 == 0, *(_BYTE *)(a1 - 48) = 0, !v4) || a4 != 1 )
    {
      v5 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(a1 - 32))(*(_QWORD *)(a1 - 32), 0LL);
      (*(void (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 64) + 40LL))(*(_QWORD *)(a1 - 64), v5 > 0x1000);
    }
  }
}

unsigned __int64 __usercall sub_3C110@<rax>(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  unsigned __int64 result; // rax

  v4 = a1;
  v5 = *(_QWORD *)(a1 - 64);
  if ( v5 )
  {
    (*(void (**)(void))(*(_QWORD *)v5 + 8LL))();
    *(_QWORD *)(v4 - 64) = 0LL;
    if ( a2 )
      *(_BYTE *)(v4 - 56) = 1;
    result = (*(__int64 (**)(void))(**(_QWORD **)(v4 - 32) + 24LL))();
  }
  if ( a2 )
  {
    sub_2D2C0(*(_QWORD *)(v4 - 24), a2, a3, a4);
    result = sub_31A30(*(_QWORD *)(v4 - 32), (__int64)"%s", a2);
  }
  return result;
}

void nullsub_17()
{
  ;
}

void __fastcall sub_3C190(__int64 *a1)
{
  char *v1; // rax
  char *v2; // rax
  char *v3; // rbp
  size_t v4; // rax
  char *v5; // rbx
  char *v6; // rax
  char *v7; // rdx
  _BYTE *v8; // r13
  _BYTE *v9; // rax
  char v10; // cl
  char *i; // rax

  v1 = (char *)sub_1F170(a1, 0);
  v2 = sub_BC120(v1);
  v3 = v2;
  v4 = strspn(v2, " \t");
  v5 = &v3[v4];
  if ( v3[v4] )
  {
    v6 = strrchr(&v3[v4], 64);
    if ( v6 )
    {
      v7 = v5;
      v5 = v6 + 1;
      *v6 = 0;
      sub_1F890(a1, 56, v7);
    }
  }
  v8 = sub_BC080(v5, 58);
  if ( v8 )
  {
    v9 = sub_BC0D0(v5, 58);
    if ( v9 == v8 )
      *v9 = 0;
  }
  v10 = *v5;
  for ( i = v3; *v5; v10 = *v5 )
  {
    if ( v10 != 32 && v10 != 9 )
      *i++ = v10;
    ++v5;
  }
  *i = 0;
  sub_1F890(a1, 0, v3);
  sub_2F4D0(v3);
}

int __usercall compar@<eax>(const void *a1@<rdi>, const void *a2@<rsi>, bool a3@<cf>, bool a4@<zf>)
{
  const char *v4; // r8
  const char *v5; // r9
  signed __int64 v6; // rcx
  const char *v7; // rdi
  const char *v8; // rsi
  char v9; // al
  bool v10; // cf
  bool v11; // zf
  signed __int64 v12; // rcx
  const char *v13; // rsi
  const char *v14; // rdi
  int result; // eax

  v4 = *(const char **)a1;
  v5 = *(const char **)a2;
  v6 = 17LL;
  v7 = "Default Settings";
  v8 = v4;
  do
  {
    if ( !v6 )
      break;
    a3 = (const unsigned __int8)*v8 < *v7;
    a4 = *v8++ == *v7++;
    --v6;
  }
  while ( a4 );
  v9 = (!a3 && !a4) - a3;
  v10 = 0;
  v11 = v9 == 0;
  if ( !v9 )
    return -1;
  v12 = 17LL;
  v13 = v5;
  v14 = "Default Settings";
  do
  {
    if ( !v12 )
      break;
    v10 = (const unsigned __int8)*v13 < *v14;
    v11 = *v13++ == *v14++;
    --v12;
  }
  while ( v11 );
  if ( (!v10 && !v11) == v10 )
    result = 1;
  else
    result = strcmp(v4, v5);
  return result;
}

void __fastcall sub_3C2D0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 *a5, int a6)
{
  __int64 v6; // r13
  __int64 v7; // r14
  int v8; // er12
  int v9; // ebx
  int v10; // ebp
  __int64 v11; // r15
  int v12; // eax
  const char **v13; // rdx
  int v14; // er12
  signed __int64 v15; // r15
  _BYTE *v16; // r13
  int v17; // eax
  __int64 v18; // rdx
  char *v19; // r8
  const char **v20; // rcx
  __int64 *v21; // [rsp+8h] [rbp-60h]
  _BYTE *v22; // [rsp+10h] [rbp-58h]
  int v23; // [rsp+28h] [rbp-40h]

  v21 = a5;
  v23 = a6;
  if ( a4 <= 0 )
  {
    v22 = sub_2F450(1uLL, 1uLL, 0LL);
    v16 = v22;
    goto LABEL_14;
  }
  v6 = a3 + 24;
  v7 = a3;
  v8 = a4;
  v9 = 0;
  v10 = 0;
  v11 = a3 + 24 + 24LL * (unsigned int)(a4 - 1);
  do
  {
    while ( 1 )
    {
      v12 = sub_1F0A0(v21, v23, v10);
      v13 = (const char **)v6;
      if ( v12 != *(_DWORD *)(v7 + 8) )
      {
        while ( v13 != (const char **)v11 )
        {
          v20 = v13;
          v13 += 3;
          if ( v12 == *((_DWORD *)v13 - 4) )
            goto LABEL_20;
        }
        goto LABEL_7;
      }
      v20 = (const char **)v7;
LABEL_20:
      if ( *v20 )
        break;
LABEL_7:
      if ( v8 == ++v10 )
        goto LABEL_8;
    }
    ++v10;
    v9 += strlen(*v20) + (v9 > 0);
  }
  while ( v8 != v10 );
LABEL_8:
  v14 = 0;
  v22 = sub_2F450(v9 + 1, 1uLL, 0LL);
  v15 = v6 + 24LL * (unsigned int)(v10 - 1);
  v16 = v22;
  while ( 2 )
  {
    while ( 2 )
    {
      v17 = sub_1F0A0(v21, v23, v14);
      v18 = v7;
      while ( v17 != *(_DWORD *)(v18 + 8) )
      {
        v18 += 24LL;
        if ( v18 == v15 )
          goto LABEL_12;
      }
      if ( !*(_QWORD *)v18 )
      {
LABEL_12:
        if ( ++v14 != v10 )
          continue;
        goto LABEL_13;
      }
      break;
    }
    v19 = ",";
    if ( v22 >= v16 )
      v19 = &locale;
    ++v14;
    v16 += (signed int)__sprintf_chk(v16, 1LL, -1LL, "%s%s", v19);
    if ( v14 != v10 )
      continue;
    break;
  }
LABEL_13:
  if ( v16 - v22 != v9 )
    __assert_fail("p - buf == maxlen", "settings.c", 0x1D4u, "wprefs");
LABEL_14:
  *v16 = 0;
  sub_BA520((_QWORD *)a1, a2);
  sub_2F4D0(v22);
}

unsigned __int64 __fastcall sub_3C4E0(__int64 a1, __int64 a2, __int64 *a3, int a4, char a5)
{
  unsigned int v5; // ebx
  __int64 v6; // rax
  const char *v7; // r15
  signed int v8; // er13
  char *v9; // r14
  int v10; // ebp
  unsigned __int64 v11; // rdi
  _BYTE *v12; // rax
  _BYTE *v13; // r13
  _BYTE *v14; // r15
  char *v15; // rax
  signed __int64 v16; // r14
  char *v17; // r10
  bool v18; // cf
  bool v19; // zf
  char *v20; // rcx
  int v21; // edx
  _BYTE *v22; // rsi
  char v23; // dl
  unsigned __int64 v24; // rdx
  _BYTE *v25; // rsi
  char v26; // dl
  char *v27; // rdx
  signed __int64 v29; // rcx
  char *v30; // rsi
  char *v31; // rdi
  char *v32; // ST10_8
  char *v33; // rdx
  int v34; // edx
  _BYTE *v35; // rcx
  char v36; // dl
  unsigned __int64 v37; // rdx
  __int64 *v38; // [rsp+8h] [rbp-70h]
  char *v39; // [rsp+10h] [rbp-68h]
  char v40; // [rsp+1Fh] [rbp-59h]
  _QWORD *v41; // [rsp+20h] [rbp-58h]
  __int64 v42; // [rsp+28h] [rbp-50h]
  char *s; // [rsp+30h] [rbp-48h]
  unsigned __int64 v44; // [rsp+38h] [rbp-40h]

  v5 = a4;
  v41 = (_QWORD *)a1;
  v42 = a2;
  v38 = a3;
  v40 = a5;
  v44 = __readfsqword(0x28u);
  v6 = sub_1F330(a3, a4, 0LL, &s);
  if ( v6 )
  {
    v7 = (const char *)v6;
    v8 = 1;
    do
    {
      v9 = s;
      v10 = strlen(s);
      v8 += 2 * (v10 + strlen(v7) + 1);
      v7 = (const char *)sub_1F330(v38, v5, v9, &s);
    }
    while ( v7 );
    v11 = v8;
  }
  else
  {
    v11 = 1LL;
  }
  v12 = sub_2F450(v11, 1uLL, 0LL);
  v13 = v12;
  v14 = v12;
  v15 = (char *)sub_1F330(v38, v5, 0LL, &s);
  if ( v15 )
  {
    v16 = 281474976841729LL;
    while ( 1 )
    {
      v17 = 0LL;
      v18 = v5 < 0xAE;
      v19 = v5 == 174;
      if ( v5 == 174 )
      {
        v29 = 2LL;
        v30 = v15;
        v31 = "D";
        do
        {
          if ( !v29 )
            break;
          v18 = (unsigned __int8)*v30 < (unsigned __int8)*v31;
          v19 = *v30++ == *v31++;
          --v29;
        }
        while ( v19 );
        if ( (!v18 && !v19) == v18 )
        {
          v32 = s;
          s = sub_BC120(s);
          v33 = strchr(s, 76);
          v17 = v32;
          v15 = &locale;
          if ( v33 )
            *v33 = 68;
        }
      }
      if ( v13 != v14 )
        *v14++ = 44;
      v20 = s;
      v21 = (unsigned __int8)*s;
      if ( (_BYTE)v21 )
        break;
LABEL_17:
      if ( v40 )
      {
        *v14 = 61;
        v34 = (unsigned __int8)*v15;
        ++v14;
        for ( ; (_BYTE)v34; v34 = (unsigned __int8)*v15 )
        {
          v37 = (unsigned int)(v34 - 44);
          if ( (unsigned __int8)v37 > 0x30u )
          {
            v35 = v14++;
          }
          else
          {
            v35 = v14 + 1;
            if ( _bittest64(&v16, v37) )
            {
              *v14 = 92;
              v14 += 2;
            }
            else
            {
              v35 = v14++;
            }
          }
          v36 = *v15++;
          *v35 = v36;
        }
      }
      v27 = s;
      v39 = v17;
      if ( v17 )
      {
        free(s);
        s = v39;
        v27 = v39;
      }
      v15 = (char *)sub_1F330(v38, v5, v27, &s);
      if ( !v15 )
        goto LABEL_21;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v24 = (unsigned int)(v21 - 44);
        if ( (unsigned __int8)v24 <= 0x30u )
          break;
        v22 = v14++;
LABEL_13:
        v23 = *v20++;
        *v22 = v23;
        v21 = (unsigned __int8)*v20;
        if ( !(_BYTE)v21 )
          goto LABEL_17;
      }
      v25 = v14 + 1;
      if ( !_bittest64(&v16, v24) )
      {
        v22 = v14++;
        goto LABEL_13;
      }
      *v14 = 92;
      v26 = *v20++;
      v14 += 2;
      *v25 = v26;
      v21 = (unsigned __int8)*v20;
      if ( !(_BYTE)v21 )
        goto LABEL_17;
    }
  }
LABEL_21:
  *v14 = 0;
  sub_BA520(v41, v42);
  sub_2F4D0(v13);
  return __readfsqword(0x28u) ^ v44;
}

void __fastcall sub_3C7B0(char *a1, __int64 a2, int a3, __int64 *a4, int a5)
{
  int v5; // er13
  int v6; // ebx
  __int64 *v7; // r12
  int v8; // er14
  char *v9; // rax
  const char *v10; // rbp
  int v11; // er12
  char v12; // al
  const char *i; // rdx
  char v14; // al
  char *v15; // rbx
  __int64 v16; // r13
  int v17; // ecx
  __int64 v18; // rax
  int v19; // edx
  int v20; // er13
  signed int v21; // ecx
  int *v22; // rbp
  int v23; // ecx
  int v24; // ebx
  int v25; // ebx
  int v26; // eax
  int v27; // ebx
  int v28; // er15
  int v29; // eax
  int v30; // edx
  unsigned __int64 v31; // [rsp+0h] [rbp-68h]
  __int64 *v32; // [rsp+8h] [rbp-60h]
  int v33; // [rsp+18h] [rbp-50h]
  int v34; // [rsp+18h] [rbp-50h]
  int v35; // [rsp+1Ch] [rbp-4Ch]
  char *v36; // [rsp+20h] [rbp-48h]
  signed __int64 v37; // [rsp+28h] [rbp-40h]

  v5 = a5;
  v6 = a3;
  v7 = a4;
  v8 = 0;
  v35 = a3;
  v9 = sub_BC120(a1);
  v10 = v9;
  v36 = v9;
  v32 = v7;
  v31 = 0LL;
  v11 = v6;
  v33 = v5;
  v12 = *v9;
  v37 = 24LL * (unsigned int)(v6 - 1);
  if ( v12 == 44 )
    goto LABEL_17;
  while ( v12 )
  {
    for ( i = v10; ; ++i )
    {
      v14 = i[1];
      v15 = (char *)(i + 1);
      if ( !v14 || v14 == 44 )
        break;
    }
    if ( v14 )
    {
      *v15 = 0;
      v15 = (char *)(i + 2);
    }
    if ( v11 > 0 )
    {
      v16 = a2;
      while ( strcmp(*(const char **)v16, v10) )
      {
        v16 += 24LL;
        if ( v16 == a2 + v37 + 24 )
          goto LABEL_16;
      }
      v17 = *(_DWORD *)(v16 + 8);
      if ( v17 != -1 )
      {
        v18 = 1 << v17;
        if ( !(v18 & v31) )
        {
          v19 = v8++;
          v31 |= v18;
          sub_1F7F0(v32, v33, v19, v17);
        }
      }
    }
LABEL_16:
    while ( 1 )
    {
      v10 = v15;
      v12 = *v15;
      if ( *v15 != 44 )
        break;
LABEL_17:
      v15 = (char *)(v10 + 1);
    }
  }
  v20 = v33;
  sub_2F4D0(v36);
  while ( v8 < v35 )
  {
    v21 = *(_DWORD *)(a2 + 8);
    if ( v21 < 0 )
LABEL_45:
      __assert_fail("mapping[i].v >= 0", "settings.c", 0x181u, "gprefs_from_str");
    if ( v21 > 31 )
LABEL_38:
      __assert_fail("mapping[i].v < 32", "settings.c", 0x182u, "gprefs_from_str");
    v22 = (int *)(a2 + 8);
    while ( 1 )
    {
      if ( (1 << v21) & v31 )
        goto LABEL_35;
      v23 = v22[1];
      if ( v23 == -1 )
      {
        v25 = 0;
        if ( v22[2] < 0 )
          v25 = v8;
      }
      else
      {
        if ( !((1 << v23) & v31) )
          goto LABEL_35;
        if ( !v8 )
LABEL_39:
          __assert_fail("j < n", "settings.c", 0x196u, "gprefs_from_str");
        v24 = 0;
        while ( (unsigned int)sub_1F0A0(v32, v20, v24) != v22[1] )
        {
          if ( ++v24 == v8 )
            goto LABEL_39;
        }
        v25 = ((unsigned int)v22[2] < 0x80000000) + v24;
      }
      if ( v25 <= v8 - 1 )
      {
        v26 = v25 - 1;
        v34 = v25;
        v27 = v8 - 1;
        v28 = v26;
        do
        {
          v29 = sub_1F0A0(v32, v20, v27);
          v30 = v27-- + 1;
          sub_1F7F0(v32, v20, v30, v29);
        }
        while ( v27 != v28 );
        v25 = v34;
      }
      ++v8;
      sub_1F7F0(v32, v20, v25, *v22);
      v31 |= 1 << *v22;
LABEL_35:
      if ( (int *)(a2 + 8 + v37) == v22 )
        break;
      v21 = v22[6];
      if ( v21 < 0 )
        goto LABEL_45;
      v22 += 6;
      if ( v21 > 31 )
        goto LABEL_38;
    }
  }
}

void __fastcall sub_3CAC0(__int64 a1, __int64 a2, int a3, _QWORD *a4, int a5, int a6)
{
  int v6; // er14
  _QWORD *v7; // r12
  int v8; // er13
  signed int v9; // ebp
  char *v10; // rbx
  bool v11; // cf
  bool v12; // zf
  const char *v13; // rdi
  signed __int64 v14; // rcx
  char *v15; // rsi
  char v16; // al
  bool v17; // cf
  bool v18; // zf
  const char *v19; // rdi
  signed __int64 v20; // rcx
  char *v21; // rsi
  char v22; // al
  bool v23; // cf
  bool v24; // zf
  const char *v25; // rdi
  signed __int64 v26; // rcx
  char *v27; // rsi

  v6 = a5;
  v7 = a4;
  v8 = a6;
  v9 = a3;
  v10 = (char *)sub_BA820((__int64 **)a1, (char *)a2);
  sub_1F890(v7, v8, &locale);
  v11 = 0;
  v12 = v10 == 0LL;
  if ( v10 )
  {
    v13 = "implicit";
    v14 = 9LL;
    v15 = v10;
    v9 = 1;
    do
    {
      if ( !v14 )
        break;
      v11 = (unsigned __int8)*v15 < *v13;
      v12 = *v15++ == *v13++;
      --v14;
    }
    while ( v12 );
    v16 = (!v11 && !v12) - v11;
    v17 = 0;
    v18 = v16 == 0;
    if ( v16 )
    {
      v19 = "explicit";
      v20 = 9LL;
      v21 = v10;
      v9 = 2;
      do
      {
        if ( !v20 )
          break;
        v17 = (unsigned __int8)*v21 < *v19;
        v18 = *v21++ == *v19++;
        --v20;
      }
      while ( v18 );
      v22 = (!v17 && !v18) - v17;
      v23 = 0;
      v24 = v22 == 0;
      if ( v22 )
      {
        v25 = "custom:";
        v26 = 7LL;
        v27 = v10;
        do
        {
          if ( !v26 )
            break;
          v23 = (unsigned __int8)*v27 < *v25;
          v24 = *v27++ == *v25++;
          --v26;
        }
        while ( v24 );
        v9 = 0;
        if ( (!v23 && !v24) == v23 )
        {
          v9 = 3;
          sub_1F890(v7, v8, v10 + 7);
        }
      }
    }
  }
  sub_1F760(v7, v6, v9);
  sub_2F4D0(v10);
}

void __fastcall sub_3CB90(__int64 a1, __int64 a2, _QWORD *a3, int a4)
{
  int v4; // er13
  _QWORD *v5; // r12
  void **v6; // rbx

  v4 = a4;
  v5 = a3;
  v6 = (void **)sub_BAA20((__int64 **)a1, (char *)a2);
  if ( !v6 )
    v6 = (void **)sub_AF790(0, 1, (_BYTE *)a2);
  sub_1FAC0(v5, v4, (__int64)v6);
  sub_B4E60(v6);
}

signed int *__fastcall sub_3CBE0(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4, int a5)
{
  _QWORD *v5; // rbp
  int v6; // er12
  unsigned int v7; // eax
  int v8; // eax

  v5 = a4;
  v6 = a5;
  v7 = sub_AF840(0, 0, (_BYTE *)a2, a3);
  v8 = sub_BA8C0((__int64 **)a1, (char *)a2, v7);
  return sub_1F760(v5, v6, v8);
}

void __fastcall sub_3CC30(__int64 a1, __int64 a2, _QWORD *a3, int a4)
{
  int v4; // er13
  _QWORD *v5; // r12
  void **v6; // rbx

  v4 = a4;
  v5 = a3;
  v6 = (void **)sub_BA960((__int64 **)a1, (char *)a2);
  if ( !v6 )
    v6 = (void **)sub_AF750(0, 1, (_BYTE *)a2);
  sub_1FB70(v5, v4, (__int64)v6);
  sub_B5230(v6);
}

unsigned __int8 __fastcall sub_3CC80(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  unsigned __int8 result; // al

  result = sub_AF810(0, 0, (_BYTE *)a2, a3);
  if ( a1 )
    result = (unsigned int)sub_BA8C0((__int64 **)a1, (char *)a2, result) != 0;
  return result;
}

void __fastcall sub_3CCC0(__int64 a1, __int64 a2, __int64 *a3, int a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  __int64 *v13; // rbx
  int v14; // er13
  int v15; // eax
  __int64 v16; // rax
  double v17; // xmm4_8
  double v18; // xmm5_8
  char *v19; // rbx

  v13 = a3;
  v14 = a5;
  v15 = sub_1EFD0(a3, a4);
  if ( v15 != 2 && v15 == 3 )
  {
    v16 = sub_1F170(v13, v14);
    v19 = sub_BC160("custom:", a6, a7, a8, a9, v17, v18, a12, a13, v16, 0LL);
    sub_BA520((_QWORD *)a1, a2);
    sub_2F4D0(v19);
  }
  else
  {
    sub_BA520((_QWORD *)a1, a2);
  }
}

__int64 __fastcall sub_3CD80(__int64 a1, __int64 a2, char *a3)
{
  char *v3; // rbp
  __int64 result; // rax

  v3 = a3;
  result = sub_BA820((__int64 **)a1, (char *)a2);
  if ( !result )
  {
    result = sub_AF7D0(0, 1, (_BYTE *)a2);
    if ( !result )
    {
      if ( v3 )
        result = (__int64)sub_BC120(v3);
    }
  }
  return result;
}

void __fastcall sub_3CDC0(__int64 a1, __int64 a2, char *a3, _QWORD *a4, int a5)
{
  int v5; // er12
  _QWORD *v6; // rbp
  char *v7; // rbx

  v5 = a5;
  v6 = a4;
  v7 = (char *)sub_3CD80(a1, a2, a3);
  sub_1F890(v6, v5, v7);
  sub_2F4D0(v7);
}

signed __int64 __fastcall sub_3CDF0(__int64 a1, __int64 a2, _QWORD *a3, int a4)
{
  _QWORD *v4; // rbp
  int i; // ebx
  __int64 v6; // rax
  char *v7; // r12
  signed __int64 result; // rax
  char *v9; // r14
  int v10; // eax
  char *v11; // r15
  char *v12; // rdx
  char *v13; // rsi
  char *v14; // rax
  char *v15; // r15

  v4 = a3;
  for ( i = a4; ; sub_1F9F0(v4, i, v6) )
  {
    v6 = sub_1F430(v4, i, 0);
    if ( !v6 )
      break;
  }
  v7 = (char *)sub_3CD80(a1, a2, 0LL);
  result = 0LL;
  if ( v7 )
  {
    v9 = v7;
    while ( 1 )
    {
      v10 = *v9;
      if ( !*v9 )
        break;
      while ( 1 )
      {
        v11 = 0LL;
        v12 = v7;
        while ( (_BYTE)v10 && (_BYTE)v10 != 44 )
        {
          ++v12;
          v13 = v9 + 1;
          if ( v10 == 61 )
          {
            *(v12 - 1) = 0;
            v11 = v12;
            ++v9;
          }
          else
          {
            if ( v10 == 92 )
            {
              v10 = v9[1];
              v13 = v9 + 2;
            }
            *(v12 - 1) = v10;
            v9 = v13;
            if ( !v10 )
              v11 = v12;
          }
          v10 = *v13;
        }
        *v12 = 0;
        v9 += (_BYTE)v10 == 44;
        if ( !v11 )
          v11 = v12;
        if ( i != 174 || !strchr(v7, 68) )
          break;
        v14 = sub_BC120(v7);
        v15 = v14;
        *strchr(v14, 68) = 76;
        sub_1F940(v4, 174, v15, "D");
        sub_2F4D0(v15);
        v10 = *v9;
        if ( !*v9 )
          goto LABEL_22;
      }
      sub_1F940(v4, i, v7, v11);
    }
LABEL_22:
    sub_2F4D0(v7);
    result = 1LL;
  }
  return result;
}

void __fastcall sub_3CF60(int a1)
{
  dword_326194 = a1;
}

void __fastcall sub_3CF70(int a1)
{
  dword_326190 = a1;
}

void **__fastcall sub_3CF80(char *s2)
{
  void **v1; // rbx
  void ***v2; // rbp

  v1 = &off_31EC80;
  if ( &off_31EC80 )
  {
    v2 = &off_323400;
    do
    {
      if ( !strcmp((const char *)v1[17], s2) )
        break;
      ++v2;
      v1 = *v2;
    }
    while ( *v2 );
  }
  return v1;
}

void **__fastcall sub_3CFD0(int a1)
{
  void **result; // rax
  void ***v2; // rdx

  result = &off_31EC80;
  if ( &off_31EC80 && a1 != *((_DWORD *)&off_31EC80 + 38) )
  {
    v2 = &off_323400;
    do
    {
      ++v2;
      result = *v2;
    }
    while ( *v2 && *((_DWORD *)result + 38) != a1 );
  }
  return result;
}

char *__fastcall sub_3D010(__int64 *a1)
{
  char *v1; // rax

  v1 = (char *)sub_1F170(a1, 56);
  if ( *v1 )
    return sub_BC120(v1);
  if ( (unsigned __int8)sub_1EF00(a1, 57) )
    return (char *)sub_B4EC0();
  return 0LL;
}

unsigned __int64 __fastcall sub_3D060(__int64 a1, __int64 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 *v10; // rax
  int v11; // eax
  void **v12; // rdx
  void ***v13; // rcx
  int v14; // ebx
  __int64 *v15; // rax
  __int64 *v16; // rax
  __int64 *v17; // rax
  __int64 *v18; // rax
  unsigned int v19; // er14
  __int64 v20; // r8
  int v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // ebx
  int v24; // er15
  char *v25; // r8
  char *v26; // rdi
  int v27; // ecx
  unsigned int v28; // edx
  double v29; // xmm4_8
  double v30; // xmm5_8
  double v31; // xmm4_8
  double v32; // xmm5_8
  double v33; // xmm4_8
  double v34; // xmm5_8
  __int64 *v35; // rax
  __int64 *v36; // rax
  __int64 *v37; // rax
  __int64 *v38; // rax
  void *v40; // rdx
  _QWORD *v41; // [rsp+8h] [rbp-170h]
  char v42; // [rsp+10h] [rbp-168h]
  char v43; // [rsp+30h] [rbp-148h]
  unsigned __int64 v44; // [rsp+138h] [rbp-40h]

  v44 = __readfsqword(0x28u);
  v41 = (_QWORD *)a1;
  sub_BA540((_QWORD *)a1, (__int64)"Present");
  sub_1F170(a2, 0);
  sub_BA520((_QWORD *)a1, (__int64)"HostName");
  v10 = (__int64 *)sub_1F530(a2, 127);
  sub_BAAB0((_QWORD *)a1, (__int64)"LogFileName", v10);
  sub_1EFD0(a2, 128);
  sub_BA540((_QWORD *)a1, (__int64)"LogType");
  sub_1EFD0(a2, 129);
  sub_BA540((_QWORD *)a1, (__int64)"LogFileClash");
  sub_1EF00(a2, 130);
  sub_BA540((_QWORD *)a1, (__int64)"LogFlush");
  sub_1EF00(a2, 131);
  sub_BA540((_QWORD *)a1, (__int64)"LogHeader");
  sub_1EF00(a2, 132);
  sub_BA540((_QWORD *)a1, (__int64)"SSHLogOmitPasswords");
  sub_1EF00(a2, 133);
  sub_BA540((_QWORD *)a1, (__int64)"SSHLogOmitData");
  v11 = sub_1EFD0(a2, 2);
  v12 = &off_31EC80;
  if ( &off_31EC80 )
  {
    if ( v11 == *((_DWORD *)&off_31EC80 + 38) )
    {
LABEL_20:
      v40 = v12[17];
    }
    else
    {
      v13 = &off_323400;
      while ( 1 )
      {
        ++v13;
        v12 = *v13;
        if ( !*v13 )
          break;
        if ( v11 == *((_DWORD *)v12 + 38) )
          goto LABEL_20;
      }
    }
  }
  sub_BA520((_QWORD *)a1, (__int64)"Protocol");
  sub_1EFD0(a2, 1);
  sub_BA540((_QWORD *)a1, (__int64)"PortNumber");
  sub_1EFD0(a2, 4);
  sub_BA540((_QWORD *)a1, (__int64)"CloseOnExit");
  sub_1EF00(a2, 5);
  sub_BA540((_QWORD *)a1, (__int64)"WarnOnClose");
  sub_1EFD0(a2, 6);
  sub_BA540((_QWORD *)a1, (__int64)"PingInterval");
  sub_1EFD0(a2, 6);
  v14 = 2;
  sub_BA540((_QWORD *)a1, (__int64)"PingIntervalSecs");
  sub_1EF00(a2, 7);
  sub_BA540((_QWORD *)a1, (__int64)"TCPNoDelay");
  sub_1EF00(a2, 8);
  sub_BA540((_QWORD *)a1, (__int64)"TCPKeepalives");
  sub_1F170(a2, 52);
  sub_BA520((_QWORD *)a1, (__int64)"TerminalType");
  sub_1F170(a2, 53);
  sub_BA520((_QWORD *)a1, (__int64)"TerminalSpeed");
  sub_3C4E0(a1, (__int64)"TerminalModes", a2, 54, 1);
  sub_1EFD0(a2, 3);
  sub_BA540((_QWORD *)a1, (__int64)"AddressFamily");
  sub_1F170(a2, 10);
  sub_BA520((_QWORD *)a1, (__int64)"ProxyExcludeList");
  sub_1EFD0(a2, 11);
  sub_BA540((_QWORD *)a1, (__int64)"ProxyDNS");
  sub_1EF00(a2, 12);
  sub_BA540((_QWORD *)a1, (__int64)"ProxyLocalhost");
  sub_1EFD0(a2, 13);
  sub_BA540((_QWORD *)a1, (__int64)"ProxyMethod");
  sub_1F170(a2, 14);
  sub_BA520((_QWORD *)a1, (__int64)"ProxyHost");
  sub_1EFD0(a2, 15);
  sub_BA540((_QWORD *)a1, (__int64)"ProxyPort");
  sub_1F170(a2, 16);
  sub_BA520((_QWORD *)a1, (__int64)"ProxyUsername");
  sub_1F170(a2, 17);
  sub_BA520((_QWORD *)a1, (__int64)"ProxyPassword");
  sub_1F170(a2, 18);
  sub_BA520((_QWORD *)a1, (__int64)"ProxyTelnetCommand");
  sub_1EFD0(a2, 19);
  sub_BA540((_QWORD *)a1, (__int64)"ProxyLogToTerm");
  sub_3C4E0(a1, (__int64)"Environment", a2, 55, 1);
  sub_1F170(a2, 56);
  sub_BA520((_QWORD *)a1, (__int64)"UserName");
  sub_1EF00(a2, 57);
  sub_BA540((_QWORD *)a1, (__int64)&unk_E7D7B);
  sub_1F170(a2, 58);
  sub_BA520((_QWORD *)a1, (__int64)&unk_E7D93);
  sub_1EF00(a2, 22);
  sub_BA540((_QWORD *)a1, (__int64)"NoPTY");
  sub_1EF00(a2, 23);
  sub_BA540((_QWORD *)a1, (__int64)"Compression");
  sub_1EF00(a2, 29);
  sub_BA540((_QWORD *)a1, (__int64)"TryAgent");
  sub_1EF00(a2, 30);
  sub_BA540((_QWORD *)a1, (__int64)"AgentFwd");
  sub_1EF00(a2, 43);
  sub_BA540((_QWORD *)a1, (__int64)"GssapiFwd");
  sub_1EF00(a2, 31);
  sub_BA540((_QWORD *)a1, (__int64)"ChangeUsername");
  sub_3C2D0(a1, (__int64)"Cipher", (__int64)&off_31EB00, 7, a2, 32);
  sub_3C2D0(a1, (__int64)"KEX", (__int64)&off_31EA60, 6, a2, 24);
  sub_3C2D0(a1, (__int64)"HostKey", (__int64)&off_31E9C0, 6, a2, 25);
  sub_1EF00(a2, 26);
  sub_BA540((_QWORD *)a1, (__int64)"PreferKnownHostKeys");
  sub_1EFD0(a2, 27);
  sub_BA540((_QWORD *)a1, (__int64)"RekeyTime");
  sub_1EFD0(a2, 44);
  sub_BA540((_QWORD *)a1, (__int64)"GssapiRekey");
  sub_1F170(a2, 28);
  sub_BA520((_QWORD *)a1, (__int64)"RekeyBytes");
  sub_1EF00(a2, 36);
  sub_BA540((_QWORD *)a1, (__int64)"SshNoAuth");
  sub_1EF00(a2, 37);
  sub_BA540((_QWORD *)a1, (__int64)"SshNoTrivialAuth");
  sub_1EF00(a2, 38);
  sub_BA540((_QWORD *)a1, (__int64)"SshBanner");
  sub_1EF00(a2, 39);
  sub_BA540((_QWORD *)a1, (__int64)"AuthTIS");
  sub_1EF00(a2, 40);
  sub_BA540((_QWORD *)a1, (__int64)"AuthKI");
  sub_1EF00(a2, 41);
  sub_BA540((_QWORD *)a1, (__int64)"AuthGSSAPI");
  sub_1EF00(a2, 42);
  sub_BA540((_QWORD *)a1, (__int64)"AuthGSSAPIKEX");
  sub_3C2D0(a1, (__int64)"GSSLibs", (__int64)&off_322880, 4, a2, 45);
  v15 = (__int64 *)sub_1F530(a2, 46);
  sub_BAAB0((_QWORD *)a1, (__int64)"GSSCustom", v15);
  sub_1EF00(a2, 49);
  sub_BA540((_QWORD *)a1, (__int64)"SshNoShell");
  sub_1EFD0(a2, 34);
  sub_BA540((_QWORD *)a1, (__int64)"SshProt");
  sub_1F170(a2, 9);
  sub_BA520((_QWORD *)a1, (__int64)"LogHost");
  sub_1EF00(a2, 35);
  sub_BA540((_QWORD *)a1, (__int64)"SSH2DES");
  v16 = (__int64 *)sub_1F530(a2, 33);
  sub_BAAB0((_QWORD *)a1, (__int64)"PublicKeyFile", v16);
  sub_1F170(a2, 20);
  sub_BA520((_QWORD *)a1, (__int64)"RemoteCommand");
  sub_1EF00(a2, 59);
  sub_BA540((_QWORD *)a1, (__int64)"RFCEnviron");
  sub_1EF00(a2, 60);
  sub_BA540((_QWORD *)a1, (__int64)"PassiveTelnet");
  sub_1EF00(a2, 71);
  sub_BA540((_QWORD *)a1, (__int64)"BackspaceIsDelete");
  sub_1EF00(a2, 72);
  sub_BA540((_QWORD *)a1, (__int64)"RXVTHomeEnd");
  sub_1EFD0(a2, 73);
  sub_BA540((_QWORD *)a1, (__int64)"LinuxFunctionKeys");
  sub_1EF00(a2, 75);
  sub_BA540((_QWORD *)a1, (__int64)"NoApplicationKeys");
  sub_1EF00(a2, 74);
  sub_BA540((_QWORD *)a1, (__int64)"NoApplicationCursors");
  sub_1EF00(a2, 76);
  sub_BA540((_QWORD *)a1, (__int64)"NoMouseReporting");
  sub_1EF00(a2, 77);
  sub_BA540((_QWORD *)a1, (__int64)"NoRemoteResize");
  sub_1EF00(a2, 78);
  sub_BA540((_QWORD *)a1, (__int64)"NoAltScreen");
  sub_1EF00(a2, 79);
  sub_BA540((_QWORD *)a1, (__int64)"NoRemoteWinTitle");
  sub_1EF00(a2, 80);
  sub_BA540((_QWORD *)a1, (__int64)"NoRemoteClearScroll");
  sub_1EFD0(a2, 83);
  sub_BA540((_QWORD *)a1, (__int64)"RemoteQTitleAction");
  sub_1EF00(a2, 81);
  sub_BA540((_QWORD *)a1, (__int64)"NoDBackspace");
  sub_1EF00(a2, 82);
  sub_BA540((_QWORD *)a1, (__int64)"NoRemoteCharset");
  sub_1EF00(a2, 84);
  sub_BA540((_QWORD *)a1, (__int64)"ApplicationCursorKeys");
  sub_1EF00(a2, 85);
  sub_BA540((_QWORD *)a1, (__int64)"ApplicationKeypad");
  sub_1EF00(a2, 86);
  sub_BA540((_QWORD *)a1, (__int64)"NetHackKeypad");
  sub_1EF00(a2, 89);
  sub_BA540((_QWORD *)a1, (__int64)"AltF4");
  sub_1EF00(a2, 90);
  sub_BA540((_QWORD *)a1, (__int64)"AltSpace");
  sub_1EF00(a2, 91);
  sub_BA540((_QWORD *)a1, (__int64)"AltOnly");
  sub_1EF00(a2, 99);
  sub_BA540((_QWORD *)a1, (__int64)"ComposeKey");
  sub_1EF00(a2, 100);
  sub_BA540((_QWORD *)a1, (__int64)"CtrlAltKeys");
  sub_1EF00(a2, 87);
  sub_BA540((_QWORD *)a1, (__int64)"TelnetKey");
  sub_1EF00(a2, 88);
  sub_BA540((_QWORD *)a1, (__int64)"TelnetRet");
  sub_1EFD0(a2, 92);
  sub_BA540((_QWORD *)a1, (__int64)"LocalEcho");
  sub_1EFD0(a2, 93);
  sub_BA540((_QWORD *)a1, (__int64)"LocalEdit");
  sub_1F170(a2, 137);
  sub_BA520((_QWORD *)a1, (__int64)"Answerback");
  sub_1EF00(a2, 94);
  sub_BA540((_QWORD *)a1, (__int64)"AlwaysOnTop");
  sub_1EF00(a2, 95);
  sub_BA540((_QWORD *)a1, (__int64)"FullScreenOnAltEnter");
  sub_1EF00(a2, 134);
  sub_BA540((_QWORD *)a1, (__int64)"HideMousePtr");
  sub_1EF00(a2, 135);
  sub_BA540((_QWORD *)a1, (__int64)"SunkenEdge");
  sub_1EFD0(a2, 136);
  sub_BA540((_QWORD *)a1, (__int64)"WindowBorder");
  sub_1EFD0(a2, 108);
  sub_BA540((_QWORD *)a1, (__int64)"CurType");
  sub_1EF00(a2, 109);
  sub_BA540((_QWORD *)a1, (__int64)"BlinkCur");
  sub_1EFD0(a2, 110);
  sub_BA540((_QWORD *)a1, (__int64)"Beep");
  sub_1EFD0(a2, 111);
  sub_BA540((_QWORD *)a1, (__int64)"BeepInd");
  v17 = (__int64 *)sub_1F530(a2, 116);
  sub_BAAB0((_QWORD *)a1, (__int64)"BellWaveFile", v17);
  sub_1EF00(a2, 112);
  sub_BA540((_QWORD *)a1, (__int64)"BellOverload");
  sub_1EFD0(a2, 113);
  sub_BA540((_QWORD *)a1, (__int64)"BellOverloadN");
  sub_1EFD0(a2, 114);
  sub_BA540((_QWORD *)a1, (__int64)"BellOverloadT");
  sub_1EFD0(a2, 115);
  sub_BA540((_QWORD *)a1, (__int64)"BellOverloadS");
  sub_1EFD0(a2, 104);
  sub_BA540((_QWORD *)a1, (__int64)"ScrollbackLines");
  sub_1EF00(a2, 105);
  sub_BA540((_QWORD *)a1, (__int64)"DECOriginMode");
  sub_1EF00(a2, 106);
  sub_BA540((_QWORD *)a1, (__int64)"AutoWrapMode");
  sub_1EF00(a2, 107);
  sub_BA540((_QWORD *)a1, (__int64)"LFImpliesCR");
  sub_1EF00(a2, 201);
  sub_BA540((_QWORD *)a1, (__int64)"CRImpliesLF");
  sub_1EF00(a2, 139);
  sub_BA540((_QWORD *)a1, (__int64)"DisableArabicShaping");
  sub_1EF00(a2, 140);
  sub_BA540((_QWORD *)a1, (__int64)"DisableBidi");
  sub_1EF00(a2, 122);
  sub_BA540((_QWORD *)a1, (__int64)"WinNameAlways");
  sub_1F170(a2, 103);
  sub_BA520((_QWORD *)a1, (__int64)"WinTitle");
  sub_1EFD0(a2, 123);
  sub_BA540((_QWORD *)a1, (__int64)"TermWidth");
  sub_1EFD0(a2, 124);
  sub_BA540((_QWORD *)a1, (__int64)"TermHeight");
  v18 = (__int64 *)sub_1F600(a2, 125);
  sub_BAA60((_QWORD *)a1, "Font", v18);
  sub_1EFD0(a2, 126);
  sub_BA540((_QWORD *)a1, (__int64)"FontQuality");
  sub_1EFD0(a2, 163);
  sub_BA540((_QWORD *)a1, (__int64)"FontVTMode");
  sub_1EF00(a2, 144);
  sub_BA540((_QWORD *)a1, (__int64)"UseSystemColours");
  sub_1EF00(a2, 145);
  sub_BA540((_QWORD *)a1, (__int64)"TryPalette");
  sub_1EF00(a2, 141);
  sub_BA540((_QWORD *)a1, (__int64)"ANSIColour");
  sub_1EF00(a2, 142);
  sub_BA540((_QWORD *)a1, (__int64)"Xterm256Colour");
  sub_1EF00(a2, 143);
  sub_BA540((_QWORD *)a1, (__int64)"TrueColour");
  sub_1EFD0(a2, 146);
  v19 = 0;
  sub_BA540((_QWORD *)a1, (__int64)"BoldAsColour");
  do
  {
    v20 = v19++;
    __sprintf_chk(&v42, 1LL, 20LL, "Colour%d", v20);
    sub_1F0A0(a2, 147, v14);
    sub_1F0A0(a2, 147, v14 - 1);
    v21 = v14 - 2;
    v14 += 3;
    v22 = sub_1F0A0(a2, 147, v21);
    __sprintf_chk(&v43, 1LL, 30LL, "%d,%d,%d", v22);
    sub_BA520((_QWORD *)a1, (__int64)&v42);
  }
  while ( v19 != 22 );
  sub_1EF00(a2, 151);
  sub_BA540((_QWORD *)a1, (__int64)"RawCNP");
  sub_1EF00(a2, 152);
  sub_BA540((_QWORD *)a1, (__int64)"UTF8linedraw");
  sub_1EF00(a2, 153);
  sub_BA540((_QWORD *)a1, (__int64)"PasteRTF");
  sub_1EFD0(a2, 148);
  sub_BA540((_QWORD *)a1, (__int64)"MouseIsXterm");
  sub_1EF00(a2, 149);
  sub_BA540((_QWORD *)a1, (__int64)"RectSelect");
  sub_1EF00(a2, 150);
  sub_BA540((_QWORD *)a1, (__int64)"PasteControls");
  sub_1EF00(a2, 154);
  v23 = 0;
  sub_BA540((_QWORD *)a1, (__int64)"MouseOverride");
  do
  {
    v24 = v23 + 32;
    __sprintf_chk(&v42, 1LL, 20LL, "Wordness%d", v23);
    v43 = 0;
    do
    {
      sub_1F0A0(a2, 155, v23);
      v25 = &locale;
      v26 = &v43;
      if ( v43 )
        v25 = ",";
      do
      {
        v27 = *(_DWORD *)v26;
        v26 += 4;
        v28 = ~v27 & (v27 - 16843009) & 0x80808080;
      }
      while ( !v28 );
      if ( !(~v27 & (v27 - 16843009) & 0x8080) )
        v28 >>= 16;
      if ( !(~v27 & (v27 - 16843009) & 0x8080) )
        v26 += 2;
      ++v23;
      __sprintf_chk(&v26[-__CFADD__((_BYTE)v28, (_BYTE)v28) - 3], 1LL, -1LL, "%s%d", v25);
    }
    while ( v23 != v24 );
    sub_BA520(v41, (__int64)&v42);
  }
  while ( v23 != 256 );
  sub_1EF00(a2, 156);
  sub_BA540(v41, (__int64)"MouseAutocopy");
  sub_3CCC0((__int64)v41, (__int64)"MousePaste", a2, 157, 160, a3, a4, a5, a6, v29, v30, a9, a10);
  sub_3CCC0((__int64)v41, (__int64)"CtrlShiftIns", a2, 158, 161, a3, a4, a5, a6, v31, v32, a9, a10);
  sub_3CCC0((__int64)v41, (__int64)"CtrlShiftCV", a2, 159, 162, a3, a4, a5, a6, v33, v34, a9, a10);
  sub_1F170(a2, 164);
  sub_BA520(v41, (__int64)"LineCodePage");
  sub_1EF00(a2, 165);
  sub_BA540(v41, (__int64)"CJKAmbigWide");
  sub_1EF00(a2, 166);
  sub_BA540(v41, (__int64)"UTF8Override");
  sub_1F170(a2, 138);
  sub_BA520(v41, (__int64)"Printer");
  sub_1EF00(a2, 167);
  sub_BA540(v41, (__int64)"CapsLockCyr");
  sub_1EF00(a2, 117);
  sub_BA540(v41, (__int64)"ScrollBar");
  sub_1EF00(a2, 118);
  sub_BA540(v41, (__int64)"ScrollBarFullScreen");
  sub_1EF00(a2, 96);
  sub_BA540(v41, (__int64)"ScrollOnKey");
  sub_1EF00(a2, 97);
  sub_BA540(v41, (__int64)"ScrollOnDisp");
  sub_1EF00(a2, 98);
  sub_BA540(v41, (__int64)"EraseToScrollback");
  sub_1EFD0(a2, 119);
  sub_BA540(v41, (__int64)"LockSize");
  sub_1EF00(a2, 120);
  sub_BA540(v41, (__int64)"BCE");
  sub_1EF00(a2, 121);
  sub_BA540(v41, (__int64)"BlinkText");
  sub_1EF00(a2, 168);
  sub_BA540(v41, (__int64)"X11Forward");
  sub_1F170(a2, 169);
  sub_BA520(v41, (__int64)"X11Display");
  sub_1EFD0(a2, 170);
  sub_BA540(v41, (__int64)"X11AuthType");
  v35 = (__int64 *)sub_1F530(a2, 171);
  sub_BAAB0(v41, (__int64)"X11AuthFile", v35);
  sub_1EF00(a2, 172);
  sub_BA540(v41, (__int64)"LocalPortAcceptAll");
  sub_1EF00(a2, 173);
  sub_BA540(v41, (__int64)"RemotePortAcceptAll");
  sub_3C4E0((__int64)v41, (__int64)"PortForwardings", a2, 174, 1);
  sub_1EFD0(a2, 175);
  sub_BA540(v41, (__int64)"BugIgnore1");
  sub_1EFD0(a2, 176);
  sub_BA540(v41, (__int64)"BugPlainPW1");
  sub_1EFD0(a2, 177);
  sub_BA540(v41, (__int64)"BugRSA1");
  sub_1EFD0(a2, 184);
  sub_BA540(v41, (__int64)"BugIgnore2");
  sub_1EFD0(a2, 178);
  sub_BA540(v41, (__int64)"BugHMAC2");
  sub_1EFD0(a2, 179);
  sub_BA540(v41, (__int64)"BugDeriveKey2");
  sub_1EFD0(a2, 180);
  sub_BA540(v41, (__int64)"BugRSAPad2");
  sub_1EFD0(a2, 181);
  sub_BA540(v41, (__int64)"BugPKSessID2");
  sub_1EFD0(a2, 182);
  sub_BA540(v41, (__int64)"BugRekey2");
  sub_1EFD0(a2, 183);
  sub_BA540(v41, (__int64)"BugMaxPkt2");
  sub_1EFD0(a2, 185);
  sub_BA540(v41, (__int64)"BugOldGex2");
  sub_1EFD0(a2, 186);
  sub_BA540(v41, (__int64)"BugWinadj");
  sub_1EFD0(a2, 187);
  sub_BA540(v41, (__int64)"BugChanReq");
  sub_1EF00(a2, 193);
  sub_BA540(v41, (__int64)"StampUtmp");
  sub_1EF00(a2, 194);
  sub_BA540(v41, (__int64)"LoginShell");
  sub_1EF00(a2, 195);
  sub_BA540(v41, (__int64)"ScrollbarOnLeft");
  v36 = (__int64 *)sub_1F600(a2, 197);
  sub_BAA60(v41, (char *)&unk_E843A, v36);
  v37 = (__int64 *)sub_1F600(a2, 198);
  sub_BAA60(v41, "WideFont", v37);
  v38 = (__int64 *)sub_1F600(a2, 199);
  sub_BAA60(v41, (char *)&unk_E8436, v38);
  sub_1EF00(a2, 196);
  sub_BA540(v41, (__int64)"ShadowBold");
  sub_1EFD0(a2, 200);
  sub_BA540(v41, (__int64)"ShadowBoldOffset");
  sub_1F170(a2, 61);
  sub_BA520(v41, (__int64)"SerialLine");
  sub_1EFD0(a2, 62);
  sub_BA540(v41, (__int64)"SerialSpeed");
  sub_1EFD0(a2, 63);
  sub_BA540(v41, (__int64)"SerialDataBits");
  sub_1EFD0(a2, 64);
  sub_BA540(v41, (__int64)"SerialStopHalfbits");
  sub_1EFD0(a2, 65);
  sub_BA540(v41, (__int64)"SerialParity");
  sub_1EFD0(a2, 66);
  sub_BA540(v41, (__int64)"SerialFlowControl");
  sub_1F170(a2, 202);
  sub_BA520(v41, (__int64)"WindowClass");
  sub_1EF00(a2, 189);
  sub_BA540(v41, (__int64)"ConnectionSharing");
  sub_1EF00(a2, 190);
  sub_BA540(v41, (__int64)"ConnectionSharingUpstream");
  sub_1EF00(a2, 191);
  sub_BA540(v41, (__int64)"ConnectionSharingDownstream");
  sub_3C4E0((__int64)v41, (__int64)"SSHManualHostKeys", a2, 192, 0);
  sub_1F170(a2, 67);
  sub_BA520(v41, (__int64)"SUPDUPLocation");
  sub_1EFD0(a2, 68);
  sub_BA540(v41, (__int64)"SUPDUPCharset");
  sub_1EF00(a2, 69);
  sub_BA540(v41, (__int64)"SUPDUPMoreProcessing");
  sub_1EF00(a2, 70);
  sub_BA540(v41, (__int64)"SUPDUPScrolling");
  return __readfsqword(0x28u) ^ v44;
}

__int64 __fastcall sub_3EA30(__int64 a1, __int64 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  FILE **v10; // rax
  double v11; // xmm4_8
  double v12; // xmm5_8
  FILE **v14; // ST08_8
  __int64 v15; // [rsp+10h] [rbp-18h]
  unsigned __int64 v16; // [rsp+18h] [rbp-10h]

  v16 = __readfsqword(0x28u);
  v10 = (FILE **)sub_BA3F0((const char *)a1, &v15);
  if ( !v10 )
    return v15;
  v14 = v10;
  sub_3D060((__int64)v10, a2, a3, a4, a5, a6, v11, v12, a9, a10);
  sub_BA560(v14);
  return 0LL;
}

unsigned __int64 __fastcall sub_3EAA0(__int64 a1, __int64 *a2)
{
  __int64 **v2; // r12
  __int64 *v3; // rbp
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  char *v8; // rbx
  void **v9; // rax
  unsigned int v10; // eax
  int v11; // eax
  unsigned __int8 v12; // al
  unsigned int v13; // eax
  int v14; // ebx
  unsigned int v15; // eax
  int v16; // eax
  unsigned __int8 v17; // al
  unsigned __int8 v18; // al
  char **v19; // r13
  const char *v20; // rbx
  char *v21; // r14
  char *v22; // rax
  __int64 v23; // rax
  bool v24; // cf
  bool v25; // zf
  const char *v26; // rdi
  signed __int64 v27; // rcx
  char *v28; // rsi
  char *v29; // rcx
  unsigned int v30; // eax
  int v31; // eax
  unsigned __int8 v32; // al
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  unsigned __int8 v35; // al
  unsigned __int8 v36; // al
  unsigned __int8 v37; // al
  unsigned __int8 v38; // al
  unsigned __int8 v39; // al
  char *v40; // rbx
  unsigned int v41; // eax
  int v42; // eax
  char *v43; // rdx
  _BYTE *v44; // rax
  bool v45; // cf
  bool v46; // zf
  const char *v47; // rdi
  signed __int64 v48; // rcx
  _BYTE *v49; // rsi
  char v50; // dl
  bool v51; // cf
  bool v52; // zf
  const char *v53; // rdi
  signed __int64 v54; // rcx
  _BYTE *v55; // rsi
  void *v56; // ST00_8
  char *v57; // rbx
  unsigned __int8 v58; // al
  unsigned int v59; // eax
  int v60; // eax
  char **v61; // r13
  unsigned __int8 v62; // al
  unsigned __int8 v63; // al
  unsigned __int8 v64; // al
  unsigned __int8 v65; // al
  unsigned __int8 v66; // al
  unsigned __int8 v67; // al
  unsigned __int8 v68; // al
  unsigned __int8 v69; // al
  char *v70; // rbx
  unsigned __int8 v71; // al
  unsigned __int8 v72; // al
  unsigned __int8 v73; // al
  unsigned __int8 v74; // al
  unsigned __int8 v75; // al
  unsigned __int8 v76; // al
  unsigned __int8 v77; // al
  unsigned __int8 v78; // al
  unsigned __int8 v79; // al
  unsigned __int8 v80; // al
  unsigned __int8 v81; // al
  unsigned __int8 v82; // al
  unsigned int v83; // eax
  int v84; // eax
  unsigned __int8 v85; // al
  unsigned __int8 v86; // al
  unsigned __int8 v87; // al
  unsigned __int8 v88; // al
  unsigned __int8 v89; // al
  unsigned __int8 v90; // al
  unsigned __int8 v91; // al
  unsigned __int8 v92; // al
  unsigned __int8 v93; // al
  unsigned __int8 v94; // al
  unsigned __int8 v95; // al
  unsigned __int8 v96; // al
  unsigned __int8 v97; // al
  unsigned __int8 v98; // al
  unsigned __int8 v99; // al
  unsigned __int8 v100; // al
  unsigned __int8 v101; // al
  unsigned __int8 v102; // al
  unsigned int v103; // eax
  int v104; // eax
  unsigned int v105; // eax
  int v106; // eax
  unsigned __int8 v107; // al
  unsigned __int8 v108; // al
  unsigned __int8 v109; // al
  unsigned __int8 v110; // al
  unsigned __int8 v111; // al
  unsigned __int8 v112; // al
  unsigned __int8 v113; // al
  unsigned int v114; // ebx
  unsigned __int8 v115; // al
  unsigned __int8 v116; // al
  unsigned __int8 v117; // al
  unsigned __int8 v118; // al
  unsigned __int8 v119; // al
  unsigned int v120; // eax
  int v121; // eax
  void *v122; // rbp
  int v123; // ebx
  unsigned __int8 v124; // al
  unsigned __int8 v125; // al
  unsigned __int8 v126; // al
  unsigned __int8 v127; // al
  unsigned __int8 v128; // al
  unsigned __int8 v129; // al
  int v130; // er13
  const char *v131; // rax
  const char *v132; // rdi
  char *v133; // r15
  char v134; // al
  char *v135; // r12
  int v136; // eax
  int v137; // edx
  unsigned __int8 v138; // al
  unsigned __int8 v139; // al
  unsigned __int8 v140; // al
  unsigned __int8 v141; // al
  unsigned __int8 v142; // al
  unsigned __int8 v143; // al
  unsigned __int8 v144; // al
  unsigned __int8 v145; // al
  unsigned __int8 v146; // al
  unsigned __int8 v147; // al
  unsigned __int8 v148; // al
  unsigned __int8 v149; // al
  unsigned __int8 v150; // al
  unsigned __int8 v151; // al
  unsigned int v152; // eax
  int v153; // eax
  unsigned int v154; // eax
  int v155; // eax
  unsigned int v156; // eax
  int v157; // eax
  unsigned int v158; // eax
  int v159; // eax
  unsigned int v160; // eax
  int v161; // er13
  unsigned int v162; // eax
  int v163; // eax
  unsigned int v164; // eax
  int v165; // eax
  unsigned int v166; // eax
  int v167; // eax
  unsigned int v168; // eax
  int v169; // eax
  unsigned int v170; // eax
  int v171; // eax
  unsigned int v172; // eax
  int v173; // eax
  unsigned int v174; // eax
  int v175; // eax
  unsigned int v176; // eax
  int v177; // eax
  unsigned __int8 v178; // al
  unsigned __int8 v179; // al
  unsigned __int8 v180; // al
  unsigned __int8 v181; // al
  unsigned __int8 v182; // al
  unsigned __int8 v183; // al
  unsigned __int8 v184; // al
  unsigned __int8 v185; // al
  unsigned __int8 v186; // al
  unsigned __int64 result; // rax
  unsigned __int64 v188; // rt1
  char **v189; // rbx
  char *v190; // rdx
  unsigned int v191; // eax
  unsigned int v192; // eax
  unsigned int v193; // eax
  unsigned int v194; // eax
  __int64 **v195; // [rsp+0h] [rbp-88h]
  __int64 *v196; // [rsp+18h] [rbp-70h]
  int v197; // [rsp+24h] [rbp-64h]
  int v198; // [rsp+28h] [rbp-60h]
  int v199; // [rsp+2Ch] [rbp-5Ch]
  char v200; // [rsp+30h] [rbp-58h]
  unsigned __int64 v201; // [rsp+48h] [rbp-40h]

  v2 = (__int64 **)a1;
  v3 = a2;
  v201 = __readfsqword(0x28u);
  sub_1F6D0(a2, 47, 0);
  sub_1F890(a2, 20, &locale);
  sub_1F890(a2, 21, &locale);
  sub_1F890(a2, 50, &locale);
  sub_3CDC0(a1, (__int64)"HostName", &locale, a2, 0);
  sub_3CB90(a1, (__int64)"LogFileName", a2, 127);
  sub_3CBE0(a1, (__int64)"LogType", 0, a2, 128);
  sub_3CBE0(a1, (__int64)"LogFileClash", 0xFFFFFFFF, a2, 129);
  v4 = sub_3CC80(a1, (__int64)"LogFlush", 1u);
  sub_1F6D0(a2, 130, v4);
  v5 = sub_3CC80(a1, (__int64)"LogHeader", 1u);
  sub_1F6D0(a2, 131, v5);
  v6 = sub_3CC80(a1, (__int64)"SSHLogOmitPasswords", 1u);
  sub_1F6D0(a2, 132, v6);
  v7 = sub_3CC80(a1, (__int64)"SSHLogOmitData", 0);
  sub_1F6D0(a2, 133, v7);
  v8 = (char *)sub_3CD80(a1, (__int64)"Protocol", "default");
  sub_1F760(a2, 2, dword_326194);
  sub_1F760(a2, 1, dword_326190);
  v9 = sub_3CF80(v8);
  if ( v9 )
  {
    sub_1F760(a2, 2, *((_DWORD *)v9 + 38));
    sub_3CBE0(a1, (__int64)"PortNumber", dword_326190, a2, 1);
  }
  sub_2F4D0(v8);
  sub_3CBE0(a1, (__int64)"AddressFamily", 0, a2, 3);
  v10 = sub_AF840(v24, v25, "CloseOnExit", 1u);
  v11 = sub_BA8C0((__int64 **)a1, "CloseOnExit", v10);
  sub_1F760(a2, 4, (v11 + 1) % 3);
  v12 = sub_3CC80(a1, (__int64)"WarnOnClose", 1u);
  sub_1F6D0(a2, 5, v12);
  v13 = sub_AF840(0, 1, "PingInterval", 0);
  v14 = sub_BA8C0((__int64 **)a1, "PingInterval", v13);
  v15 = sub_AF840(0, 1, "PingIntervalSecs", 0);
  v16 = sub_BA8C0((__int64 **)a1, "PingIntervalSecs", v15);
  sub_1F760(a2, 6, v16 + 60 * v14);
  v17 = sub_3CC80(a1, (__int64)"TCPNoDelay", 1u);
  sub_1F6D0(a2, 7, v17);
  v18 = sub_3CC80(a1, (__int64)"TCPKeepalives", 0);
  sub_1F6D0(a2, 8, v18);
  sub_3CDC0(a1, (__int64)"TerminalType", "xterm", a2, 52);
  sub_3CDC0(a1, (__int64)"TerminalSpeed", "38400,38400", a2, 53);
  if ( (unsigned __int8)sub_3CDF0(a1, (__int64)"TerminalModes", a2, 54) )
  {
    v19 = off_31E810;
    v20 = "QUIT";
    v21 = "INTR";
    while ( 1 )
    {
      v23 = sub_1F240(v3, 54, (__int64)v21);
      v24 = 0;
      v25 = v23 == 0;
      if ( v23 )
      {
        if ( !v20 )
          goto LABEL_14;
      }
      else
      {
        v26 = "IUTF8";
        v27 = 6LL;
        v28 = v21;
        do
        {
          if ( !v27 )
            break;
          v24 = (unsigned __int8)*v28 < *v26;
          v25 = *v28++ == *v26++;
          --v27;
        }
        while ( v25 );
        v29 = "A";
        if ( (!v24 && !v25) != v24 )
          v29 = "N";
        sub_1F940(v3, 54, v21, v29);
        if ( !v20 )
          goto LABEL_14;
      }
      v22 = *v19;
      v21 = (char *)v20;
      ++v19;
      v20 = v22;
    }
  }
  v189 = off_31E808;
  v190 = "INTR";
  do
  {
    ++v189;
    sub_1F940(a2, 54, v190, "A");
    v190 = *(v189 - 1);
  }
  while ( v190 );
LABEL_14:
  sub_3CDC0((__int64)v2, (__int64)"ProxyExcludeList", &locale, v3, 10);
  v30 = sub_AF840(v24, v25, "ProxyDNS", 1u);
  v31 = sub_BA8C0(v2, "ProxyDNS", v30);
  sub_1F760(v3, 11, (v31 + 1) % 3);
  v32 = sub_3CC80((__int64)v2, (__int64)"ProxyLocalhost", 0);
  sub_1F6D0(v3, 12, v32);
  sub_3CBE0((__int64)v2, (__int64)"ProxyMethod", 0xFFFFFFFF, v3, 13);
  if ( (unsigned int)sub_1EFD0(v3, 13) != -1 )
    goto LABEL_15;
  v192 = sub_AF840(0, 1, "ProxyType", 0);
  v193 = sub_BA8C0(v2, "ProxyType", v192);
  switch ( v193 )
  {
    case 0u:
      sub_1F760(v3, 13, 0);
      goto LABEL_15;
    case 1u:
      sub_1F760(v3, 13, 3);
      goto LABEL_15;
    case 3u:
      sub_1F760(v3, 13, 4);
      goto LABEL_15;
    case 4u:
      sub_1F760(v3, 13, 5);
      goto LABEL_15;
  }
  v194 = sub_AF840(v193 < 4, v193 == 4, "ProxySOCKSVersion", 5u);
  if ( (unsigned int)sub_BA8C0(v2, "ProxySOCKSVersion", v194) != 5 )
  {
    sub_1F760(v3, 13, 1);
    goto LABEL_15;
  }
  do
  {
    sub_1F760(v3, 13, 2);
LABEL_15:
    sub_3CDC0((__int64)v2, (__int64)"ProxyHost", "proxy", v3, 14);
    sub_3CBE0((__int64)v2, (__int64)"ProxyPort", 0x50u, v3, 15);
    sub_3CDC0((__int64)v2, (__int64)"ProxyUsername", &locale, v3, 16);
    sub_3CDC0((__int64)v2, (__int64)"ProxyPassword", &locale, v3, 17);
    sub_3CDC0((__int64)v2, (__int64)"ProxyTelnetCommand", "connect %host %port\\n", v3, 18);
    sub_3CBE0((__int64)v2, (__int64)"ProxyLogToTerm", 1u, v3, 19);
    sub_3CDF0((__int64)v2, (__int64)"Environment", v3, 55);
    sub_3CDC0((__int64)v2, (__int64)"UserName", &locale, v3, 56);
    v33 = sub_3CC80((__int64)v2, (__int64)&unk_E7D7B, 0);
    sub_1F6D0(v3, 57, v33);
    sub_3CDC0((__int64)v2, (__int64)&unk_E7D93, &locale, v3, 58);
    v34 = sub_3CC80((__int64)v2, (__int64)"NoPTY", 0);
    sub_1F6D0(v3, 22, v34);
    v35 = sub_3CC80((__int64)v2, (__int64)"Compression", 0);
    sub_1F6D0(v3, 23, v35);
    v36 = sub_3CC80((__int64)v2, (__int64)"TryAgent", 1u);
    sub_1F6D0(v3, 29, v36);
    v37 = sub_3CC80((__int64)v2, (__int64)"AgentFwd", 0);
    sub_1F6D0(v3, 30, v37);
    v38 = sub_3CC80((__int64)v2, (__int64)"ChangeUsername", 0);
    sub_1F6D0(v3, 31, v38);
    v39 = sub_3CC80((__int64)v2, (__int64)"GssapiFwd", 0);
    sub_1F6D0(v3, 43, v39);
    v40 = (char *)sub_3CD80((__int64)v2, (__int64)"Cipher", (char *)&unk_E8AA0);
    sub_3C7B0(v40, (__int64)&off_31EB00, 7, v3, 32);
    sub_2F4D0(v40);
    v41 = sub_AF840(0, 1, "BugDHGEx2", 0);
    v42 = sub_BA8C0(v2, "BugDHGEx2", v41);
    v43 = "ecdh,dh-group14-sha1,rsa,WARN,dh-group1-sha1,dh-gex-sha1";
    if ( v42 != 2 )
      v43 = "ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1";
    v44 = (_BYTE *)sub_3CD80((__int64)v2, (__int64)"KEX", v43);
    v45 = 0;
    v46 = v44 == 0LL;
    if ( !v44 )
      __assert_fail("raw != NULL", "settings.c", 0x3D8u, "load_open_settings");
    v47 = "dh-group14-sha1,dh-group1-sha1,rsa,WARN,dh-gex-sha1";
    v48 = 52LL;
    v49 = v44;
    do
    {
      if ( !v48 )
        break;
      v45 = *v49 < (const unsigned __int8)*v47;
      v46 = *v49++ == *v47++;
      --v48;
    }
    while ( v46 );
    v50 = (!v45 && !v46) - v45;
    v51 = 0;
    v52 = v50 == 0;
    if ( v50 )
    {
      v53 = "dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN";
      v54 = 52LL;
      v55 = v44;
      do
      {
        if ( !v54 )
          break;
        v51 = *v55 < (const unsigned __int8)*v53;
        v52 = *v55++ == *v53++;
        --v54;
      }
      while ( v52 );
      if ( (!v51 && !v52) == v51 )
      {
        sub_2F4D0(v44);
        v44 = sub_BC120("ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1");
      }
    }
    else
    {
      sub_2F4D0(v44);
      v44 = sub_BC120("ecdh,dh-group14-sha1,rsa,WARN,dh-group1-sha1,dh-gex-sha1");
    }
    v56 = v44;
    sub_3C7B0(v44, (__int64)&off_31EA60, 6, v3, 24);
    sub_2F4D0(v56);
    v57 = (char *)sub_3CD80((__int64)v2, (__int64)"HostKey", "ed25519,ecdsa,rsa,dsa,WARN");
    sub_3C7B0(v57, (__int64)&off_31E9C0, 6, v3, 25);
    sub_2F4D0(v57);
    v58 = sub_3CC80((__int64)v2, (__int64)"PreferKnownHostKeys", 1u);
    sub_1F6D0(v3, 26, v58);
    sub_3CBE0((__int64)v2, (__int64)"RekeyTime", 0x3Cu, v3, 27);
    sub_3CBE0((__int64)v2, (__int64)"GssapiRekey", 2u, v3, 44);
    sub_3CDC0((__int64)v2, (__int64)"RekeyBytes", "1G", v3, 28);
    v59 = sub_AF840(v24, v25, "SshProt", 3u);
    v60 = sub_BA8C0(v2, "SshProt", v59);
    if ( v60 == 1 )
    {
      v60 = 0;
    }
    else if ( v60 == 2 )
    {
      v60 = 3;
    }
    sub_1F760(v3, 34, v60);
    v61 = off_31E740;
    sub_3CDC0((__int64)v2, (__int64)"LogHost", &locale, v3, 9);
    v62 = sub_3CC80((__int64)v2, (__int64)"SSH2DES", 0);
    sub_1F6D0(v3, 35, v62);
    v63 = sub_3CC80((__int64)v2, (__int64)"SshNoAuth", 0);
    sub_1F6D0(v3, 36, v63);
    v64 = sub_3CC80((__int64)v2, (__int64)"SshNoTrivialAuth", 0);
    sub_1F6D0(v3, 37, v64);
    v65 = sub_3CC80((__int64)v2, (__int64)"SshBanner", 1u);
    sub_1F6D0(v3, 38, v65);
    v66 = sub_3CC80((__int64)v2, (__int64)"AuthTIS", 0);
    sub_1F6D0(v3, 39, v66);
    v67 = sub_3CC80((__int64)v2, (__int64)"AuthKI", 1u);
    sub_1F6D0(v3, 40, v67);
    v68 = sub_3CC80((__int64)v2, (__int64)"AuthGSSAPI", 1u);
    sub_1F6D0(v3, 41, v68);
    v69 = sub_3CC80((__int64)v2, (__int64)"AuthGSSAPIKEX", 1u);
    sub_1F6D0(v3, 42, v69);
    v70 = (char *)sub_3CD80((__int64)v2, (__int64)"GSSLibs", (char *)&unk_E8AA0);
    sub_3C7B0(v70, (__int64)&off_322880, 4, v3, 45);
    sub_2F4D0(v70);
    sub_3CB90((__int64)v2, (__int64)"GSSCustom", v3, 46);
    v71 = sub_3CC80((__int64)v2, (__int64)"SshNoShell", 0);
    sub_1F6D0(v3, 49, v71);
    sub_3CB90((__int64)v2, (__int64)"PublicKeyFile", v3, 33);
    sub_3CDC0((__int64)v2, (__int64)"RemoteCommand", &locale, v3, 20);
    v72 = sub_3CC80((__int64)v2, (__int64)"RFCEnviron", 0);
    sub_1F6D0(v3, 59, v72);
    v73 = sub_3CC80((__int64)v2, (__int64)"PassiveTelnet", 0);
    sub_1F6D0(v3, 60, v73);
    v74 = sub_3CC80((__int64)v2, (__int64)"BackspaceIsDelete", 1u);
    sub_1F6D0(v3, 71, v74);
    v75 = sub_3CC80((__int64)v2, (__int64)"RXVTHomeEnd", 0);
    sub_1F6D0(v3, 72, v75);
    sub_3CBE0((__int64)v2, (__int64)"LinuxFunctionKeys", 0, v3, 73);
    v76 = sub_3CC80((__int64)v2, (__int64)"NoApplicationKeys", 0);
    sub_1F6D0(v3, 75, v76);
    v77 = sub_3CC80((__int64)v2, (__int64)"NoApplicationCursors", 0);
    sub_1F6D0(v3, 74, v77);
    v78 = sub_3CC80((__int64)v2, (__int64)"NoMouseReporting", 0);
    sub_1F6D0(v3, 76, v78);
    v79 = sub_3CC80((__int64)v2, (__int64)"NoRemoteResize", 0);
    sub_1F6D0(v3, 77, v79);
    v80 = sub_3CC80((__int64)v2, (__int64)"NoAltScreen", 0);
    sub_1F6D0(v3, 78, v80);
    v81 = sub_3CC80((__int64)v2, (__int64)"NoRemoteWinTitle", 0);
    sub_1F6D0(v3, 79, v81);
    v82 = sub_3CC80((__int64)v2, (__int64)"NoRemoteClearScroll", 0);
    sub_1F6D0(v3, 80, v82);
    v83 = sub_AF840(v24, v25, "NoRemoteQTitle", 1u);
    v84 = sub_BA8C0(v2, "NoRemoteQTitle", v83);
    sub_3CBE0((__int64)v2, (__int64)"RemoteQTitleAction", (v84 == 0) + 1, v3, 83);
    v85 = sub_3CC80((__int64)v2, (__int64)"NoDBackspace", 0);
    sub_1F6D0(v3, 81, v85);
    v86 = sub_3CC80((__int64)v2, (__int64)"NoRemoteCharset", 0);
    sub_1F6D0(v3, 82, v86);
    v87 = sub_3CC80((__int64)v2, (__int64)"ApplicationCursorKeys", 0);
    sub_1F6D0(v3, 84, v87);
    v88 = sub_3CC80((__int64)v2, (__int64)"ApplicationKeypad", 0);
    sub_1F6D0(v3, 85, v88);
    v89 = sub_3CC80((__int64)v2, (__int64)"NetHackKeypad", 0);
    sub_1F6D0(v3, 86, v89);
    v90 = sub_3CC80((__int64)v2, (__int64)"AltF4", 1u);
    sub_1F6D0(v3, 89, v90);
    v91 = sub_3CC80((__int64)v2, (__int64)"AltSpace", 0);
    sub_1F6D0(v3, 90, v91);
    v92 = sub_3CC80((__int64)v2, (__int64)"AltOnly", 0);
    sub_1F6D0(v3, 91, v92);
    v93 = sub_3CC80((__int64)v2, (__int64)"ComposeKey", 0);
    sub_1F6D0(v3, 99, v93);
    v94 = sub_3CC80((__int64)v2, (__int64)"CtrlAltKeys", 1u);
    sub_1F6D0(v3, 100, v94);
    v95 = sub_3CC80((__int64)v2, (__int64)"TelnetKey", 0);
    sub_1F6D0(v3, 87, v95);
    v96 = sub_3CC80((__int64)v2, (__int64)"TelnetRet", 1u);
    sub_1F6D0(v3, 88, v96);
    sub_3CBE0((__int64)v2, (__int64)"LocalEcho", 2u, v3, 92);
    sub_3CBE0((__int64)v2, (__int64)"LocalEdit", 2u, v3, 93);
    sub_3CDC0((__int64)v2, (__int64)"Answerback", "PuTTY", v3, 137);
    v97 = sub_3CC80((__int64)v2, (__int64)"AlwaysOnTop", 0);
    sub_1F6D0(v3, 94, v97);
    v98 = sub_3CC80((__int64)v2, (__int64)"FullScreenOnAltEnter", 0);
    sub_1F6D0(v3, 95, v98);
    v99 = sub_3CC80((__int64)v2, (__int64)"HideMousePtr", 0);
    sub_1F6D0(v3, 134, v99);
    v100 = sub_3CC80((__int64)v2, (__int64)"SunkenEdge", 0);
    sub_1F6D0(v3, 135, v100);
    sub_3CBE0((__int64)v2, (__int64)"WindowBorder", 1u, v3, 136);
    sub_3CBE0((__int64)v2, (__int64)"CurType", 0, v3, 108);
    v101 = sub_3CC80((__int64)v2, (__int64)"BlinkCur", 0);
    sub_1F6D0(v3, 109, v101);
    sub_3CBE0((__int64)v2, (__int64)"Beep", 1u, v3, 110);
    sub_3CBE0((__int64)v2, (__int64)"BeepInd", 0, v3, 111);
    sub_3CB90((__int64)v2, (__int64)"BellWaveFile", v3, 116);
    v102 = sub_3CC80((__int64)v2, (__int64)"BellOverload", 1u);
    sub_1F6D0(v3, 112, v102);
    sub_3CBE0((__int64)v2, (__int64)"BellOverloadN", 5u, v3, 113);
    v103 = sub_AF840(v24, v25, "BellOverloadT", 0x1E8480u);
    v104 = sub_BA8C0(v2, "BellOverloadT", v103);
    sub_1F760(v3, 114, v104 / 1000);
    v105 = sub_AF840(v24, v25, "BellOverloadS", 0x4C4B40u);
    v106 = sub_BA8C0(v2, "BellOverloadS", v105);
    sub_1F760(v3, 115, v106 / 1000);
    sub_3CBE0((__int64)v2, (__int64)"ScrollbackLines", 0x7D0u, v3, 104);
    v107 = sub_3CC80((__int64)v2, (__int64)"DECOriginMode", 0);
    sub_1F6D0(v3, 105, v107);
    v108 = sub_3CC80((__int64)v2, (__int64)"AutoWrapMode", 1u);
    sub_1F6D0(v3, 106, v108);
    v109 = sub_3CC80((__int64)v2, (__int64)"LFImpliesCR", 0);
    sub_1F6D0(v3, 107, v109);
    v110 = sub_3CC80((__int64)v2, (__int64)"CRImpliesLF", 0);
    sub_1F6D0(v3, 201, v110);
    v111 = sub_3CC80((__int64)v2, (__int64)"DisableArabicShaping", 0);
    sub_1F6D0(v3, 139, v111);
    v112 = sub_3CC80((__int64)v2, (__int64)"DisableBidi", 0);
    sub_1F6D0(v3, 140, v112);
    v113 = sub_3CC80((__int64)v2, (__int64)"WinNameAlways", 1u);
    sub_1F6D0(v3, 122, v113);
    v114 = 0;
    sub_3CDC0((__int64)v2, (__int64)"WinTitle", &locale, v3, 103);
    sub_3CBE0((__int64)v2, (__int64)"TermWidth", 0x50u, v3, 123);
    sub_3CBE0((__int64)v2, (__int64)"TermHeight", 0x18u, v3, 124);
    sub_3CC30((__int64)v2, (__int64)"Font", v3, 125);
    sub_3CBE0((__int64)v2, (__int64)"FontQuality", 0, v3, 126);
    sub_3CBE0((__int64)v2, (__int64)"FontVTMode", 4u, v3, 163);
    v115 = sub_3CC80((__int64)v2, (__int64)"UseSystemColours", 0);
    sub_1F6D0(v3, 144, v115);
    v116 = sub_3CC80((__int64)v2, (__int64)"TryPalette", 0);
    sub_1F6D0(v3, 145, v116);
    v117 = sub_3CC80((__int64)v2, (__int64)"ANSIColour", 1u);
    sub_1F6D0(v3, 141, v117);
    v118 = sub_3CC80((__int64)v2, (__int64)"Xterm256Colour", 1u);
    sub_1F6D0(v3, 142, v118);
    v119 = sub_3CC80((__int64)v2, (__int64)"TrueColour", 1u);
    sub_1F6D0(v3, 143, v119);
    v120 = sub_AF840(v24, v25, "BoldAsColour", 1u);
    v121 = sub_BA8C0(v2, "BoldAsColour", v120);
    sub_1F760(v3, 146, v121 + 1);
    v196 = v3;
    do
    {
      __sprintf_chk(&v200, 1LL, 20LL, "Colour%d", v114);
      v122 = (void *)sub_3CD80((__int64)v2, (__int64)&v200, *v61);
      if ( (unsigned int)__isoc99_sscanf(v122, "%d,%d,%d", &v197, &v198, &v199) == 3 )
      {
        sub_1F7F0(v196, 147, 3 * v114, v197);
        sub_1F7F0(v196, 147, 3 * v114 + 1, v198);
        sub_1F7F0(v196, 147, 3 * v114 + 2, v199);
      }
      ++v114;
      ++v61;
      sub_2F4D0(v122);
    }
    while ( v114 != 22 );
    v3 = v196;
    v123 = 0;
    v124 = sub_3CC80((__int64)v2, (__int64)"RawCNP", 0);
    sub_1F6D0(v196, 151, v124);
    v125 = sub_3CC80((__int64)v2, (__int64)"UTF8linedraw", 0);
    sub_1F6D0(v196, 152, v125);
    v126 = sub_3CC80((__int64)v2, (__int64)"PasteRTF", 0);
    sub_1F6D0(v196, 153, v126);
    sub_3CBE0((__int64)v2, (__int64)"MouseIsXterm", 0, v196, 148);
    v127 = sub_3CC80((__int64)v2, (__int64)"RectSelect", 0);
    sub_1F6D0(v196, 149, v127);
    v128 = sub_3CC80((__int64)v2, (__int64)"PasteControls", 0);
    sub_1F6D0(v196, 150, v128);
    v129 = sub_3CC80((__int64)v2, (__int64)"MouseOverride", 1u);
    sub_1F6D0(v196, 154, v129);
    v195 = v2;
    do
    {
      __sprintf_chk(&v200, 1LL, 20LL, "Wordness%d", (unsigned int)v123);
      v130 = v123 + 32;
      v131 = (const char *)sub_3CD80((__int64)v195, (__int64)&v200, off_31E700[v123 >> 5]);
      v132 = v131;
      v133 = (char *)v131;
      v134 = *v131;
      if ( v134 == 44 )
      {
LABEL_44:
        v135 = (char *)v132;
        goto LABEL_40;
      }
      while ( 1 )
      {
        v135 = (char *)v132;
        if ( !v134 )
          goto LABEL_44;
        do
          v134 = *++v135;
        while ( *v135 && v134 != 44 );
LABEL_40:
        if ( v134 == 44 )
          *v135++ = 0;
        v136 = strtol(v132, 0LL, 10);
        v137 = v123++;
        sub_1F7F0(v196, 155, v137, v136);
        if ( v130 == v123 )
          break;
        v132 = v135;
        v134 = *v135;
        if ( *v135 == 44 )
          goto LABEL_44;
      }
      v123 = v130;
      sub_2F4D0(v133);
    }
    while ( v130 != 256 );
    v2 = v195;
    v138 = sub_3CC80((__int64)v195, (__int64)"MouseAutocopy", 0);
    sub_1F6D0(v196, 156, v138);
    sub_3CAC0((__int64)v195, (__int64)"MousePaste", 1, v196, 157, 160);
    sub_3CAC0((__int64)v195, (__int64)"CtrlShiftIns", 1, v196, 158, 161);
    sub_3CAC0((__int64)v195, (__int64)"CtrlShiftCV", 0, v196, 159, 162);
    sub_3CDC0((__int64)v195, (__int64)"LineCodePage", &locale, v196, 164);
    v139 = sub_3CC80((__int64)v195, (__int64)"CJKAmbigWide", 0);
    sub_1F6D0(v196, 165, v139);
    v140 = sub_3CC80((__int64)v195, (__int64)"UTF8Override", 1u);
    sub_1F6D0(v196, 166, v140);
    sub_3CDC0((__int64)v195, (__int64)"Printer", &locale, v196, 138);
    v141 = sub_3CC80((__int64)v195, (__int64)"CapsLockCyr", 0);
    sub_1F6D0(v196, 167, v141);
    v142 = sub_3CC80((__int64)v195, (__int64)"ScrollBar", 1u);
    sub_1F6D0(v196, 117, v142);
    v143 = sub_3CC80((__int64)v195, (__int64)"ScrollBarFullScreen", 0);
    sub_1F6D0(v196, 118, v143);
    v144 = sub_3CC80((__int64)v195, (__int64)"ScrollOnKey", 0);
    sub_1F6D0(v196, 96, v144);
    v145 = sub_3CC80((__int64)v195, (__int64)"ScrollOnDisp", 1u);
    sub_1F6D0(v196, 97, v145);
    v146 = sub_3CC80((__int64)v195, (__int64)"EraseToScrollback", 1u);
    sub_1F6D0(v196, 98, v146);
    sub_3CBE0((__int64)v195, (__int64)"LockSize", 0, v196, 119);
    v147 = sub_3CC80((__int64)v195, (__int64)"BCE", 1u);
    sub_1F6D0(v196, 120, v147);
    v148 = sub_3CC80((__int64)v195, (__int64)"BlinkText", 0);
    sub_1F6D0(v196, 121, v148);
    v149 = sub_3CC80((__int64)v195, (__int64)"X11Forward", 0);
    sub_1F6D0(v196, 168, v149);
    sub_3CDC0((__int64)v195, (__int64)"X11Display", &locale, v196, 169);
    sub_3CBE0((__int64)v195, (__int64)"X11AuthType", 1u, v196, 170);
    sub_3CB90((__int64)v195, (__int64)"X11AuthFile", v196, 171);
    v150 = sub_3CC80((__int64)v195, (__int64)"LocalPortAcceptAll", 0);
    sub_1F6D0(v196, 172, v150);
    v151 = sub_3CC80((__int64)v195, (__int64)"RemotePortAcceptAll", 0);
    sub_1F6D0(v196, 173, v151);
    sub_3CDF0((__int64)v195, (__int64)"PortForwardings", v196, 174);
    v152 = sub_AF840(0, 1, "BugIgnore1", 0);
    v153 = sub_BA8C0(v195, "BugIgnore1", v152);
    sub_1F760(v196, 175, 2 - v153);
    v154 = sub_AF840(0, 1, "BugPlainPW1", 0);
    v155 = sub_BA8C0(v195, "BugPlainPW1", v154);
    sub_1F760(v196, 176, 2 - v155);
    v156 = sub_AF840(0, 1, "BugRSA1", 0);
    v157 = sub_BA8C0(v195, "BugRSA1", v156);
    sub_1F760(v196, 177, 2 - v157);
    v158 = sub_AF840(0, 1, "BugIgnore2", 0);
    v159 = sub_BA8C0(v195, "BugIgnore2", v158);
    sub_1F760(v196, 184, 2 - v159);
    v160 = sub_AF840(0, 1, "BugHMAC2", 0);
    v161 = sub_BA8C0(v195, "BugHMAC2", v160);
    sub_1F760(v196, 178, 2 - v161);
    if ( !v161 )
    {
      v191 = sub_AF840(0, 1, "BuggyMAC", 0);
      if ( (unsigned int)sub_BA8C0(v195, "BuggyMAC", v191) == 1 )
        sub_1F760(v196, 178, 0);
    }
    v162 = sub_AF840(0, 1, "BugDeriveKey2", 0);
    v163 = sub_BA8C0(v195, "BugDeriveKey2", v162);
    sub_1F760(v196, 179, 2 - v163);
    v164 = sub_AF840(0, 1, "BugRSAPad2", 0);
    v165 = sub_BA8C0(v195, "BugRSAPad2", v164);
    sub_1F760(v196, 180, 2 - v165);
    v166 = sub_AF840(0, 1, "BugPKSessID2", 0);
    v167 = sub_BA8C0(v195, "BugPKSessID2", v166);
    sub_1F760(v196, 181, 2 - v167);
    v168 = sub_AF840(0, 1, "BugRekey2", 0);
    v169 = sub_BA8C0(v195, "BugRekey2", v168);
    sub_1F760(v196, 182, 2 - v169);
    v170 = sub_AF840(0, 1, "BugMaxPkt2", 0);
    v171 = sub_BA8C0(v195, "BugMaxPkt2", v170);
    sub_1F760(v196, 183, 2 - v171);
    v172 = sub_AF840(0, 1, "BugOldGex2", 0);
    v173 = sub_BA8C0(v195, "BugOldGex2", v172);
    sub_1F760(v196, 185, 2 - v173);
    v174 = sub_AF840(0, 1, "BugWinadj", 0);
    v175 = sub_BA8C0(v195, "BugWinadj", v174);
    sub_1F760(v196, 186, 2 - v175);
    v176 = sub_AF840(0, 1, "BugChanReq", 0);
    v177 = sub_BA8C0(v195, "BugChanReq", v176);
    sub_1F760(v196, 187, 2 - v177);
    sub_1F6D0(v196, 188, 0);
    v178 = sub_3CC80((__int64)v195, (__int64)"StampUtmp", 1u);
    sub_1F6D0(v196, 193, v178);
    v179 = sub_3CC80((__int64)v195, (__int64)"LoginShell", 1u);
    sub_1F6D0(v196, 194, v179);
    v180 = sub_3CC80((__int64)v195, (__int64)"ScrollbarOnLeft", 0);
    sub_1F6D0(v196, 195, v180);
    v181 = sub_3CC80((__int64)v195, (__int64)"ShadowBold", 0);
    sub_1F6D0(v196, 196, v181);
    sub_3CC30((__int64)v195, (__int64)&unk_E843A, v196, 197);
    sub_3CC30((__int64)v195, (__int64)"WideFont", v196, 198);
    sub_3CC30((__int64)v195, (__int64)&unk_E8436, v196, 199);
    sub_3CBE0((__int64)v195, (__int64)"ShadowBoldOffset", 1u, v196, 200);
    sub_3CDC0((__int64)v195, (__int64)"SerialLine", &locale, v196, 61);
    sub_3CBE0((__int64)v195, (__int64)"SerialSpeed", 0x2580u, v196, 62);
    sub_3CBE0((__int64)v195, (__int64)"SerialDataBits", 8u, v196, 63);
    sub_3CBE0((__int64)v195, (__int64)"SerialStopHalfbits", 2u, v196, 64);
    sub_3CBE0((__int64)v195, (__int64)"SerialParity", 0, v196, 65);
    sub_3CBE0((__int64)v195, (__int64)"SerialFlowControl", 1u, v196, 66);
    sub_3CDC0((__int64)v195, (__int64)"WindowClass", &locale, v196, 202);
    v182 = sub_3CC80((__int64)v195, (__int64)"ConnectionSharing", 0);
    sub_1F6D0(v196, 189, v182);
    v183 = sub_3CC80((__int64)v195, (__int64)"ConnectionSharingUpstream", 1u);
    sub_1F6D0(v196, 190, v183);
    v184 = sub_3CC80((__int64)v195, (__int64)"ConnectionSharingDownstream", 1u);
    sub_1F6D0(v196, 191, v184);
    sub_3CDF0((__int64)v195, (__int64)"SSHManualHostKeys", v196, 192);
    sub_3CDC0((__int64)v195, (__int64)"SUPDUPLocation", "The Internet", v196, 67);
    sub_3CBE0((__int64)v195, (__int64)"SUPDUPCharset", 0, v196, 68);
    v185 = sub_3CC80((__int64)v195, (__int64)"SUPDUPMoreProcessing", 0);
    sub_1F6D0(v196, 69, v185);
    v186 = sub_3CC80((__int64)v195, (__int64)"SUPDUPScrolling", 0);
    sub_1F6D0(v196, 70, v186);
    v188 = __readfsqword(0x28u);
    result = v188 ^ v201;
  }
  while ( v188 != v201 );
  return result;
}

__int64 __usercall sub_40A20@<rax>(__int64 *a1@<rsi>, unsigned int a2@<r12d>, const char *a3@<rdi>)
{
  __int64 **v3; // rbx

  v3 = sub_BA700(a3);
  sub_3EAA0((__int64)v3, a1);
  sub_BAAD0(v3);
  if ( v3 )
    sub_31CC0(a1);
  LOBYTE(a2) = v3 != 0LL;
  return a2;
}

__int64 __usercall sub_40A60@<rax>(__int64 *a1@<rsi>, unsigned int a2@<r12d>, const char *a3@<rdi>)
{
  return sub_40A20(a1, a2, a3);
}

void __fastcall sub_40A70(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  DIR **v4; // r12
  _BYTE *v5; // rax
  bool v6; // cf
  bool v7; // zf
  signed int v8; // er8
  const char *v9; // rdi
  signed __int64 v10; // rcx
  _BYTE *v11; // rsi
  unsigned __int64 v12; // rdi
  int v13; // edx
  _BYTE *v14; // rdx
  _QWORD *v15; // rax
  _BYTE *v16; // rdx
  bool v17; // cf
  bool v18; // zf
  signed int v19; // er9
  signed __int64 v20; // r8
  signed __int64 v21; // rcx
  _BYTE *v22; // rsi
  const char *v23; // rdi
  size_t v24; // rsi
  _BYTE *v25; // rcx

  v2 = a1;
  if ( (_BYTE)a2 )
  {
    v3 = sub_BC640();
    v4 = (DIR **)sub_BAB70();
    if ( v4 )
    {
      while ( (unsigned __int8)sub_BABC0(v4, v3) )
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v3 + 24), 0);
      sub_BAD80(v4);
    }
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v3 + 24), 0);
    v5 = (_BYTE *)sub_BC6B0((__int64 *)v3);
    *(_DWORD *)a1 = 1;
    *(_QWORD *)(a1 + 16) = v5;
    v6 = 0;
    v7 = *v5 == 0;
    if ( *v5 )
    {
      v8 = 1;
      do
      {
        v9 = "Default Settings";
        v10 = 17LL;
        v11 = v5;
        do
        {
          if ( !v10 )
            break;
          v6 = *v11 < (const unsigned __int8)*v9;
          v7 = *v11++ == *v9++;
          --v10;
        }
        while ( v7 );
        LODWORD(v12) = v8 + 1;
        if ( (!v6 && !v7) != v6 )
        {
          v13 = v8 + 2;
          *(_DWORD *)v2 = v12;
          ++v8;
          LODWORD(v12) = v13;
        }
        while ( *v5 )
          ++v5;
        v14 = v5++;
        v6 = 0;
        v7 = v14[1] == 0;
      }
      while ( v14[1] );
      v12 = (signed int)v12;
    }
    else
    {
      v12 = 2LL;
    }
    v15 = sub_2F450(v12, 8uLL, 0LL);
    *(_QWORD *)(v2 + 8) = v15;
    *v15 = "Default Settings";
    v16 = *(_BYTE **)(v2 + 16);
    v17 = 0;
    v18 = *v16 == 0;
    if ( *v16 )
    {
      v19 = 1;
      v20 = 1LL;
      do
      {
        v21 = 17LL;
        v22 = v16;
        v23 = "Default Settings";
        do
        {
          if ( !v21 )
            break;
          v17 = *v22 < (const unsigned __int8)*v23;
          v18 = *v22++ == *v23++;
          --v21;
        }
        while ( v18 );
        v24 = v20;
        if ( (!v17 && !v18) != v17 )
        {
          ++v19;
          v15[v20] = v16;
          v20 = v19;
          v24 = v19;
        }
        for ( ; *v16; ++v16 )
          ;
        v25 = v16++;
        v17 = 0;
        v18 = v25[1] == 0;
      }
      while ( v25[1] );
    }
    else
    {
      v24 = 1LL;
    }
    qsort(v15, v24, 8uLL, (__compar_fn_t)compar);
  }
  else
  {
    sub_2F4D0(*(void **)(a1 + 16));
    sub_2F4D0(*(void **)(a1 + 8));
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
  }
}

void nullsub_18()
{
  ;
}

__int64 __fastcall sub_40C50(__int64 a1, int a2, int a3)
{
  __int64 v3; // rdi
  __int64 result; // rax

  *(_DWORD *)(a1 + 140) = a2;
  *(_DWORD *)(a1 + 144) = a3;
  v3 = *(_QWORD *)(a1 + 368);
  if ( v3 )
    result = (*(__int64 (**)(void))(*(_QWORD *)(v3 + 8) + 120LL))();
  return result;
}

__int64 __fastcall sub_40C80(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 360);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v1 + 24LL))();
  return result;
}

__int64 __fastcall sub_40CA0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 368);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)(v1 + 8) + 128LL))();
  return result;
}

bool __fastcall sub_40CD0(__int64 a1)
{
  return *(_QWORD *)(a1 - 48) != 0LL;
}

__int64 __fastcall sub_40CE0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 360);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v1 + 32LL))();
  else
    result = 0LL;
  return result;
}

__int64 __fastcall sub_40D10(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 368);
  if ( v1 )
    result = (*(__int64 (**)(void))(*(_QWORD *)(v1 + 8) + 152LL))();
  else
    result = 0LL;
  return result;
}

void __fastcall sub_40D40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 8) = a2;
}

signed __int64 __fastcall sub_40D50(__int64 a1)
{
  signed __int64 result; // rax

  if ( !*(_QWORD *)(a1 - 48) || (result = 0xFFFFFFFFLL, *(_BYTE *)(a1 + 392)) && !*(_QWORD *)(a1 + 360) )
  {
    result = *(unsigned int *)(a1 + 116);
    if ( (signed int)result < 0 )
      result = 0x7FFFFFFFLL;
  }
  return result;
}

signed __int64 __fastcall sub_40D90(__int64 a1)
{
  signed __int64 result; // rax

  result = *(unsigned int *)(a1 + 120);
  if ( (_DWORD)result )
  {
    if ( *(_BYTE *)(a1 + 32) )
      result = 0xFFFFFFFFLL;
  }
  return result;
}

void __fastcall sub_40DB0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  void **v2; // rdi
  void *v3; // rdi
  __int64 (***v4)(void); // rdi

  v1 = a1;
  sub_99EF0((__int64)a1);
  v2 = (void **)a1[11];
  if ( v2 )
  {
    sub_81B70(v2);
    v1[11] = 0LL;
  }
  v3 = (void *)v1[56];
  if ( v3 )
  {
    sub_370D0(v3);
    v1[56] = 0LL;
  }
  v4 = (__int64 (***)(void))v1[51];
  if ( v4 )
  {
    sub_62630(v4);
    v1[51] = 0LL;
  }
  v1[52] = 0LL;
}

void __fastcall sub_40E20(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 (***v2)(void); // rdi

  v1 = a1;
  sub_40DB0(a1);
  v2 = (__int64 (***)(void))a1[50];
  if ( v2 )
  {
    sub_627F0(v2);
    v1[50] = 0LL;
  }
  if ( *v1 )
  {
    (*(void (**)(void))(*(_QWORD *)*v1 + 8LL))();
    *v1 = 0LL;
  }
  sub_BCCA0((__int64)(v1 + 25));
  sub_BCCA0((__int64)(v1 + 30));
  sub_BCCA0((__int64)(v1 + 35));
}

__int64 __fastcall sub_40E80(__int64 a1)
{
  __int64 result; // rax

  sub_40DB0((_QWORD *)a1);
  (*(void (**)(void))(**(_QWORD **)(a1 + 400) + 16LL))();
  *(_BYTE *)(a1 + 320) = 1;
  sub_1BE20(a1 + 328);
  result = *(_QWORD *)(a1 + 400);
  *(_BYTE *)(result + 222) = 1;
  return result;
}

char *__fastcall sub_40EC0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // eax
  char *v3; // rdx

  v1 = *(_QWORD *)(a1 + 40);
  if ( !v1 )
    return 0LL;
  v2 = sub_83550(v1);
  if ( !v2 )
    return 0LL;
  v3 = &locale;
  if ( v2 != 1 )
    v3 = "s";
  return sub_BC360((__int64)"This will also close %d downstream connection%s.", v2, v3);
}

void __fastcall sub_40F20(char *src, signed int a2, __int64 *a3, _QWORD *a4, signed int *a5, char **a6)
{
  char **v6; // rbp
  signed int v7; // ebx
  _QWORD *v8; // r13
  signed int *v9; // r12
  char *v10; // rax
  char *v11; // rax
  char *v12; // rbx
  _BYTE *v13; // rbp
  _BYTE *v14; // rax
  bool v15; // zf

  v6 = a6;
  v7 = a2;
  v8 = a4;
  v9 = a5;
  v10 = (char *)sub_1F170(a3, 9);
  if ( v6 )
    *v6 = v10;
  if ( *v10 )
  {
    v11 = sub_BC120(v10);
    *v9 = 22;
    v12 = v11;
    v13 = sub_BC0D0(v11, 58);
    if ( v13 )
    {
      v14 = sub_BC080(v12, 58);
      if ( v14 == v13 )
      {
        v15 = v14[1] == 0;
        *v14 = 0;
        if ( !v15 )
          *v9 = strtol(v14 + 1, 0LL, 10);
      }
    }
    *v8 = sub_BC440(v12);
    sub_2F4D0(v12);
  }
  else
  {
    *v8 = sub_BC440(src);
    if ( a2 < 0 )
      v7 = 22;
    *v9 = v7;
  }
}

void __fastcall sub_41000(char *a1, signed int a2, __int64 *a3)
{
  __int64 *v3; // rbx
  int v4; // [rsp+Ch] [rbp-2Ch]
  void *v5; // [rsp+10h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v3 = a3;
  v6 = __readfsqword(0x28u);
  sub_7C100();
  sub_40F20(a1, a2, v3, &v5, &v4, 0LL);
  sub_836F0((__int64)v5, v4, v3);
  sub_2F4D0(v5);
  sub_7C1B0();
  __readfsqword(0x28u);
}

signed __int64 __fastcall sub_41090(__int64 a1, __int64 a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // er12
  char *v6; // rax
  __int64 v7; // rdx
  signed __int64 result; // rax

  v4 = a4;
  v5 = a3;
  v6 = (char *)sub_2F4F0(*(void **)a1, (unsigned __int64 *)(a1 + 16), 0x10uLL, *(_QWORD *)(a1 + 8), 1uLL, 0);
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = v6;
  result = (signed __int64)&v6[16 * v7];
  *(_QWORD *)(a1 + 8) = v7 + 1;
  *(_QWORD *)result = a2;
  *(_DWORD *)(result + 8) = v5;
  *(_DWORD *)(result + 12) = v4;
  return result;
}

__int64 __fastcall sub_410F0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 result; // rax
  __int64 v4; // [rsp+0h] [rbp-38h]
  __int64 v5; // [rsp+8h] [rbp-30h]
  __int64 v6; // [rsp+10h] [rbp-28h]
  unsigned __int64 v7; // [rsp+18h] [rbp-20h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 360);
  v7 = __readfsqword(0x28u);
  v4 = 0LL;
  v6 = 0LL;
  v5 = 0LL;
  if ( v2 )
  {
    (*(void (__fastcall **)(__int64, signed __int64 (__fastcall *)(__int64, __int64, int, int), __int64 *))(*(_QWORD *)v2 + 16LL))(
      v2,
      sub_41090,
      &v4);
    if ( v4 )
      sub_41090((__int64)&v4, 0LL, 32, 0);
  }
  sub_2F4D0(*(void **)(v1 + 24));
  result = v4;
  *(_QWORD *)(v1 + 24) = v4;
  return result;
}

__int64 __fastcall sub_41190(__int64 a1)
{
  __int64 v1; // rbx
  char v2; // al
  __int64 *v3; // rdi
  __int64 result; // rax

  v1 = a1;
  v2 = sub_1EF00(*(__int64 **)(a1 + 16), 132);
  v3 = *(__int64 **)(a1 + 16);
  *(_BYTE *)(v1 + 352) = v2;
  result = sub_1EF00(v3, 133);
  *(_BYTE *)(v1 + 353) = result;
  return result;
}

__int64 __fastcall sub_411C0(__int64 a1, __int64 *a2)
{
  __int64 v2; // r12
  __int64 v3; // rbx
  unsigned int *v4; // rdi

  v2 = a1 - 48;
  v3 = a1;
  v4 = *(unsigned int **)(a1 + 400);
  if ( v4 )
    sub_37080(v4, *(__int64 **)(v3 - 32), a2);
  (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(v3 + 360) + 48LL))(*(_QWORD *)(v3 + 360), a2);
  sub_1ED50(*(_QWORD **)(v3 - 32));
  *(_QWORD *)(v3 - 32) = sub_1EED0(a2);
  return sub_41190(v2);
}

void __fastcall sub_41220(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  void **v3; // rdi
  _DWORD *v4; // rdi
  char v5; // bl

  v1 = (void *)(a1 - 48);
  v2 = a1;
  sub_40E20((_QWORD *)(a1 - 48));
  sub_1ED50(*(_QWORD **)(a1 - 32));
  v3 = *(void ***)(a1 + 40);
  if ( v3 )
    sub_81B70(v3);
  sub_2F4D0(*(void **)(v2 + 88));
  sub_2F4D0(*(void **)(v2 + 104));
  sub_2F4D0(*(void **)(v2 + 24));
  if ( *(_QWORD *)(v2 + 72) )
    (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v2 + 64) + 32LL))(*(_QWORD *)(v2 + 64), v2 + 72);
  if ( *(_QWORD *)(v2 + 80) )
    (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v2 + 64) + 64LL))(*(_QWORD *)(v2 + 64), v2 + 80);
  v4 = *(_DWORD **)(v2 + 56);
  if ( v4 )
    sub_B4CA0(v4);
  sub_2F4D0(*(void **)(v2 + 408));
  sub_1BCD0((__int64)v1);
  v5 = *(_BYTE *)(v2 + 416);
  sub_2F4D0(v1);
  if ( v5 )
    sub_7C1B0();
}

__int64 __fastcall sub_412E0(__int64 a1)
{
  _QWORD *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 result; // rax

  v1 = *(_QWORD **)(a1 + 400);
  v2 = a1;
  v3 = a1 + 328;
  v1[20] = a1;
  v1[1] = a1 + 200;
  v4 = a1 + 240;
  v1[2] = v4;
  sub_BCD10(v4, v3, (__int64)sub_1BE20);
  result = *(_QWORD *)(v2 + 400);
  *(_QWORD *)(result + 144) = v2 + 352;
  *(_QWORD *)(result + 152) = *(_QWORD *)(v2 + 64);
  *(_DWORD *)(result + 216) = *(_DWORD *)(v2 + 32);
  return result;
}

__int64 __fastcall sub_41350(__int64 a1, int a2)
{
  bool v2; // zf
  __int64 (***v3)(void); // r12
  __int64 v4; // rbx
  __int64 v5; // rbp
  int v6; // eax
  __int64 v7; // rax
  __int64 v8; // rdx
  char *v9; // rsi
  _QWORD *v10; // rdi
  __int64 v11; // rdx
  signed __int64 v12; // rax
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rax
  bool v17; // r13
  __int64 v18; // rax
  int v19; // eax
  int v20; // er14
  int v21; // eax
  __int64 v22; // rdx
  int v23; // esi
  _DWORD *v24; // rcx
  signed __int64 v25; // rdx
  signed __int64 v26; // rsi
  __int64 v27; // r15
  char *v28; // rax
  char v29; // dl
  __int64 v30; // r13
  __int64 v31; // r14
  __int64 v32; // rax
  __int64 *v33; // rdi
  __int64 v34; // rax
  char *v35; // ST50_8
  char *v36; // rax
  signed __int64 v37; // rax
  __int64 v38; // rax
  char *v39; // rax
  signed __int64 v40; // rax
  __int64 v41; // rax
  char *v42; // ST50_8
  char v43; // ST59_1
  char v44; // ST5A_1
  char v45; // ST5B_1
  char v46; // ST5C_1
  char v47; // ST5D_1
  char v48; // ST5E_1
  char v49; // ST5F_1
  char v50; // r15
  __int64 v51; // rax
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // [rsp+0h] [rbp-58h]
  __int64 v55; // [rsp+8h] [rbp-50h]

  v2 = *(_DWORD *)(a1 + 144) == a2;
  *(_BYTE *)(a1 + 416) = 1;
  if ( !v2 )
    __assert_fail("ssh->version == major_version", "ssh.c", 0xBDu, "ssh_got_ssh_version");
  v3 = *(__int64 (****)(void))(a1 + 376);
  v4 = a1;
  v5 = a1 - 24;
  v6 = sub_84D80(*(_QWORD *)(a1 + 376));
  v2 = *(_BYTE *)(a1 + 56) == 0;
  *(_DWORD *)(a1 + 8) = v6;
  if ( !v2 )
  {
    *(_QWORD *)(a1 + 376) = sub_48130(*(_QWORD *)(a1 + 40));
    sub_412E0(v5);
    v39 = (char *)sub_84D60((__int64)v3);
    v40 = sub_4BBD0(v5, *(_QWORD *)(a1 + 64), 0, *(_QWORD **)(a1 - 8), v39, (_QWORD *)(a1 + 392));
    v13 = *(_QWORD *)(a1 + 376);
    v14 = v40;
    *(_QWORD *)(v40 + 8) = v13;
    *(_QWORD *)(v40 + 64) = v4 + 256;
    v41 = *(_QWORD *)(v4 - 16);
    *(_QWORD *)(v14 + 88) = v5;
    *(_QWORD *)(v14 + 80) = v41;
    *(_QWORD *)(v14 + 72) = *(_QWORD *)(v4 + 40);
    *(_DWORD *)(v14 + 96) = *(_DWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 384) = v14;
    goto LABEL_5;
  }
  if ( *(_DWORD *)(a1 + 144) != 2 )
  {
    *(_QWORD *)(a1 + 376) = sub_42CA0(*(_QWORD *)(a1 + 40));
    sub_412E0(v5);
    v7 = sub_44C80(v5, *(_QWORD **)(a1 - 8), (_QWORD *)(a1 + 392));
    v8 = *(_QWORD *)(a1 + 376);
    v9 = *(char **)(a1 + 112);
    v10 = *(_QWORD **)(a1 - 8);
    *(_QWORD *)(v7 + 64) = v4 + 256;
    *(_QWORD *)(v7 + 8) = v8;
    v11 = *(_QWORD *)(v4 - 16);
    *(_QWORD *)(v7 + 88) = v5;
    *(_QWORD *)(v7 + 80) = v11;
    *(_QWORD *)(v7 + 72) = *(_QWORD *)(v4 + 40);
    *(_DWORD *)(v7 + 96) = *(_DWORD *)(v4 + 8);
    v12 = sub_47BE0(v10, v9, *(_DWORD *)(v4 + 120), v7);
    v13 = *(_QWORD *)(v4 + 376);
    *(_QWORD *)(v4 + 384) = v12;
    v14 = v12;
    *(_QWORD *)(v12 + 64) = v4 + 256;
    *(_QWORD *)(v12 + 8) = v13;
    v15 = *(_QWORD *)(v4 - 16);
    *(_QWORD *)(v14 + 88) = v5;
    *(_QWORD *)(v14 + 80) = v15;
    *(_QWORD *)(v14 + 72) = *(_QWORD *)(v4 + 40);
    *(_DWORD *)(v14 + 96) = *(_DWORD *)(v4 + 8);
    goto LABEL_5;
  }
  v17 = 0;
  if ( (unsigned __int8)sub_1EF00(*(__int64 **)(a1 - 8), 188) )
    v17 = *(_QWORD *)(a1 + 64) == 0LL;
  v55 = a1 + 344;
  *(_QWORD *)(a1 + 376) = sub_49760(*(_QWORD *)(a1 + 40), a1 + 344, 0);
  sub_412E0(v5);
  v18 = *(_QWORD *)(a1 + 80);
  if ( !v18 )
  {
    v18 = sub_B4B20(*(__int64 **)(a1 - 8));
    *(_QWORD *)(a1 + 80) = v18;
  }
  v19 = *(_DWORD *)(v18 + 8);
  *(_QWORD *)(a1 + 88) = 0LL;
  if ( v19 <= 0 )
    goto LABEL_21;
  v20 = 0;
  while ( 1 )
  {
    v21 = sub_1F0A0(*(__int64 **)(a1 - 8), 45, v20);
    v22 = *(_QWORD *)(a1 + 80);
    v23 = *(_DWORD *)(v22 + 8);
    if ( v23 > 0 )
      break;
LABEL_17:
    if ( ++v20 == 4 )
    {
      v24 = *(_DWORD **)(a1 + 88);
      goto LABEL_20;
    }
  }
  v24 = *(_DWORD **)v22;
  if ( v21 != **(_DWORD **)v22 )
  {
    v25 = (signed __int64)(v24 + 50);
    v26 = (signed __int64)&v24[50 * (v23 - 1) + 50];
    while ( v26 != v25 )
    {
      v24 = (_DWORD *)v25;
      v25 += 200LL;
      if ( *(_DWORD *)(v25 - 200) == v21 )
        goto LABEL_19;
    }
    goto LABEL_17;
  }
LABEL_19:
  *(_QWORD *)(a1 + 88) = v24;
LABEL_20:
  if ( !v24 )
    __assert_fail("ssh->gss_state.lib", "ssh.c", 0xEEu, "ssh_got_ssh_version");
LABEL_21:
  v27 = 0LL;
  v28 = (char *)sub_84D60((__int64)v3);
  v29 = v17;
  v30 = a1 + 256;
  v31 = sub_4BBD0(v5, *(_QWORD *)(a1 + 64), v29, *(_QWORD **)(a1 - 8), v28, (_QWORD *)(a1 + 392));
  v32 = *(_QWORD *)(a1 + 376);
  v33 = *(__int64 **)(a1 - 8);
  *(_QWORD *)(v31 + 64) = v4 + 256;
  *(_QWORD *)(v31 + 8) = v32;
  v34 = *(_QWORD *)(v4 - 16);
  *(_QWORD *)(v31 + 88) = v5;
  *(_QWORD *)(v31 + 80) = v34;
  *(_QWORD *)(v31 + 72) = *(_QWORD *)(v4 + 40);
  *(_DWORD *)(v31 + 96) = *(_DWORD *)(v4 + 8);
  v54 = v4 + 80;
  if ( !(unsigned __int8)sub_1EF00(v33, 36) )
  {
    v42 = sub_3D010(*(__int64 **)(v4 - 8));
    v43 = sub_1EF00(*(__int64 **)(v4 - 8), 43);
    v44 = sub_1EF00(*(__int64 **)(v4 - 8), 42);
    v45 = sub_1EF00(*(__int64 **)(v4 - 8), 41);
    v46 = sub_1EF00(*(__int64 **)(v4 - 8), 40);
    v47 = sub_1EF00(*(__int64 **)(v4 - 8), 31);
    v48 = sub_1EF00(*(__int64 **)(v4 - 8), 37);
    v49 = sub_1EF00(*(__int64 **)(v4 - 8), 29);
    v50 = sub_1EF00(*(__int64 **)(v4 - 8), 38);
    v51 = sub_1F530(*(__int64 **)(v4 - 8), 33);
    v27 = sub_56370(
            v31,
            *(char **)(v4 + 112),
            *(char **)(v4 + 128),
            v51,
            v50,
            v49,
            v48,
            v42,
            v47,
            v46,
            v45,
            v44,
            v43,
            v54);
    v52 = *(_QWORD *)(v4 + 376);
    *(_QWORD *)(v27 + 64) = v30;
    v31 = v27;
    *(_QWORD *)(v27 + 8) = v52;
    v53 = *(_QWORD *)(v4 - 16);
    *(_QWORD *)(v27 + 88) = v5;
    *(_QWORD *)(v27 + 80) = v53;
    *(_QWORD *)(v27 + 72) = *(_QWORD *)(v4 + 40);
    *(_DWORD *)(v27 + 96) = *(_DWORD *)(v4 + 8);
    sub_2F4D0(v42);
  }
  v35 = (char *)sub_84D60((__int64)v3);
  v36 = (char *)sub_84D70((__int64)v3);
  v37 = sub_502E0(
          *(_QWORD **)(v4 - 8),
          *(char **)(v4 + 112),
          *(_DWORD *)(v4 + 120),
          *(char **)(v4 + 128),
          v36,
          v35,
          v54,
          v55,
          v31,
          0LL);
  v13 = *(_QWORD *)(v4 + 376);
  *(_QWORD *)(v4 + 384) = v37;
  v14 = v37;
  *(_QWORD *)(v37 + 64) = v30;
  *(_QWORD *)(v37 + 8) = v13;
  v38 = *(_QWORD *)(v4 - 16);
  *(_QWORD *)(v14 + 88) = v5;
  *(_QWORD *)(v14 + 80) = v38;
  *(_QWORD *)(v14 + 72) = *(_QWORD *)(v4 + 40);
  *(_DWORD *)(v14 + 96) = *(_DWORD *)(v4 + 8);
  if ( v27 )
  {
    sub_564E0(v27, v14);
    v14 = *(_QWORD *)(v4 + 384);
    v13 = *(_QWORD *)(v4 + 376);
  }
LABEL_5:
  *(_QWORD *)(v14 + 56) = v4 + 384;
  sub_62650((_QWORD *)v14, v13 + 32, v13 + 88);
  (*(void (**)(void))(**(_QWORD **)(v4 - 16) + 40LL))();
  *(_QWORD *)(v4 + 424) = sub_37030(*(__int64 **)(v4 - 8), v4 + 24);
  sub_1BE20(*(_QWORD *)(v4 + 376) + 168LL);
  (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v4 + 384) + 8LL))(*(_QWORD *)(v4 + 384), v4 + 24);
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v4 + 392) + 8LL) + 120LL))(
    *(_QWORD *)(v4 + 392),
    *(unsigned int *)(v4 + 164),
    *(unsigned int *)(v4 + 168));
  return sub_627F0(v3);
}

__int64 __fastcall sub_41900(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rbp
  __int64 v4; // rax
  __int64 v5; // rdi

  v1 = 0LL;
  if ( a1 != 48 )
  {
    if ( *(_QWORD *)(a1 - 48) )
    {
      v2 = *(_QWORD *)(a1 + 368);
      if ( v2 )
      {
        v3 = a1;
        v4 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(v2 + 8) + 136LL))(*(_QWORD *)(a1 + 368));
        v5 = *(_QWORD *)(a1 + 360);
        v1 = v4;
        if ( v5 )
          v1 = (*(__int64 (**)(void))(*(_QWORD *)v5 + 56LL))() + v4;
        if ( *(_BYTE *)(v3 + 136) )
          v1 += *(_QWORD *)(v3 + 128);
      }
    }
  }
  return v1;
}

_QWORD *__fastcall sub_41970(__int64 a1, unsigned __int64 a2)
{
  _QWORD *result; // rax

  if ( a2 <= 0x7FFF )
  {
    if ( *(_BYTE *)(a1 + 144) )
    {
      *(_QWORD *)(a1 + 136) = a2;
      *(_BYTE *)(a1 + 144) = 0;
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 376) + 8LL) + 144LL))(
        *(_QWORD *)(a1 + 376),
        0LL);
    }
    result = sub_1BE20(a1 + 288);
  }
  return result;
}

__int64 __fastcall sub_419C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi

  if ( a1 == 48 || !*(_QWORD *)(a1 - 48) )
    return 0LL;
  v3 = a1;
  sub_BCD20(a1 + 232, (char *)a2, a3);
  v4 = *(_QWORD *)(a1 + 360);
  if ( v4 )
    (*(void (**)(void))(*(_QWORD *)v4 + 40LL))();
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 32LL))(v3);
}

unsigned __int64 __usercall sub_41A10@<rax>(__int64 a1@<rdi>, unsigned int a2@<esi>, __int64 a3@<rdx>, unsigned int a4@<ecx>, __int64 a5@<r8>, unsigned int a6@<r9d>, void (__fastcall ***a7)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 a8@<r15>)
{
  unsigned __int64 result; // rax

  if ( !*(_BYTE *)(a1 + 56) )
    result = sub_1B7C0(
               *(void (__fastcall ****)(_QWORD, signed __int64, const char *, __int64))(a1 - 32),
               *(_QWORD *)(a1 + 24),
               a2,
               a3,
               a4,
               a5,
               a7,
               a8,
               a6,
               *(_QWORD *)(a1 - 24),
               *(_BYTE *)(a1 + 400));
  return result;
}

char *__fastcall sub_41A60(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, _QWORD *a5, char *a6, unsigned int a7, __int64 *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  __int64 v10; // r13
  char *v11; // rbp
  __int64 v12; // r12
  _QWORD *v13; // ST30_8
  _QWORD *v14; // ST28_8
  _QWORD *v15; // rax
  __int64 v16; // rbx
  __int64 *v17; // rdi
  int v18; // eax
  __int64 *v19; // rdi
  int v20; // eax
  bool v21; // zf
  __int64 *v22; // rdx
  __int64 v23; // rdi
  __int64 v24; // rcx
  __int64 *v25; // rdx
  int v26; // esi
  __int64 v27; // rax
  __int64 v28; // rdi
  char *v29; // rax
  __int64 v30; // rdi
  int v31; // eax
  char v32; // dl
  __int64 v33; // r8
  char *v34; // rcx
  char *v35; // rbp
  unsigned int v37; // eax
  struct addrinfo **v38; // rbp
  char *v39; // r13
  __int64 v40; // rsi
  __int64 *v41; // rax
  __int64 v42; // rdx
  char *v43; // rbp
  __int64 v44; // rdi
  char *src; // [rsp+20h] [rbp-48h]
  unsigned __int64 v46; // [rsp+28h] [rbp-40h]

  v10 = a1;
  v11 = a6;
  v12 = a4;
  v13 = a3;
  v14 = a5;
  v46 = __readfsqword(0x28u);
  v15 = sub_2F450(1uLL, 0x1D8uLL, 0LL);
  v16 = (__int64)v15;
  *v15 = 0LL;
  v15[58] = 0LL;
  memset(
    (void *)((unsigned __int64)(v15 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v15 - (((_DWORD)v15 + 8) & 0xFFFFFFF8) + 472) >> 3));
  v15[2] = sub_1EED0(v14);
  sub_41190(v16);
  *(_DWORD *)(v16 + 164) = -1;
  *(_DWORD *)(v16 + 356) = 0;
  *(_DWORD *)(v16 + 360) = 0;
  sub_BCC70((_QWORD *)(v16 + 200));
  sub_BCC70((_QWORD *)(v16 + 240));
  sub_BCC70((_QWORD *)(v16 + 280));
  v17 = *(__int64 **)(v16 + 16);
  *(_QWORD *)(v16 + 336) = v16;
  *(_QWORD *)(v16 + 328) = sub_41F80;
  v18 = sub_1EFD0(v17, 123);
  v19 = *(__int64 **)(v16 + 16);
  *(_DWORD *)(v16 + 188) = v18;
  v20 = sub_1EFD0(v19, 124);
  v21 = *(_DWORD *)(v10 + 152) == 4;
  *(_DWORD *)(v16 + 192) = v20;
  *(_QWORD *)(v16 + 48) = v10;
  *v13 = v16 + 48;
  *(_QWORD *)(v16 + 64) = v12;
  *(_BYTE *)(v16 + 80) = v21;
  *(_QWORD *)(v16 + 424) = v12;
  *(_QWORD *)(v16 + 432) = &unk_31ED40;
  *(_QWORD *)(v16 + 8) = a2;
  sub_7C100();
  v22 = *(__int64 **)(v16 + 16);
  *(_BYTE *)(v16 + 464) = 1;
  sub_40F20(v11, a7, v22, (_QWORD *)(v16 + 136), (signed int *)(v16 + 144), &src);
  v23 = *(_QWORD *)(v16 + 136);
  v24 = *(_QWORD *)(v16 + 64);
  v25 = *(__int64 **)(v16 + 16);
  v26 = *(_DWORD *)(v16 + 144);
  *(_QWORD *)(v16 + 40) = off_31EE00;
  *(_QWORD *)(v16 + 88) = 0LL;
  *(_BYTE *)(v16 + 96) = 1;
  v27 = sub_83820(v23, v26, v25, v24, v16 + 40, (_QWORD *)(v16 + 88));
  v28 = *(_QWORD *)(v16 + 88);
  *(_QWORD *)v16 = v27;
  if ( v28 )
  {
    sub_83810(v28, v16 + 424);
    v27 = *(_QWORD *)v16;
  }
  *(_BYTE *)(v16 + 96) = 0;
  if ( v27 )
  {
    *(_BYTE *)(v16 + 80) = 1;
    *(_QWORD *)(v16 + 152) = 0LL;
    v29 = sub_BC120(v11);
    v30 = *(_QWORD *)(v16 + 8);
    *a8 = (__int64)v29;
    if ( (*(unsigned __int8 (**)(void))(*(_QWORD *)v30 + 144LL))()
      || (*(unsigned __int8 (**)(void))(**(_QWORD **)(v16 + 8) + 152LL))() )
    {
      (***(void (__fastcall ****)(_QWORD, signed __int64, const char *, signed __int64))(v16 + 8))(
        *(_QWORD *)(v16 + 8),
        1LL,
        "Reusing a shared connection to this server.\r\n",
        45LL);
    }
    goto LABEL_6;
  }
  v37 = sub_1EFD0(*(__int64 **)(v16 + 16), 3);
  v38 = (struct addrinfo **)sub_3A770(
                              v11,
                              a7,
                              a8,
                              *(__int64 **)(v16 + 16),
                              v37,
                              *(_QWORD *)(v16 + 64),
                              (__int64)"SSH connection");
  v39 = (char *)sub_B72A0((__int64)v38);
  if ( v39 )
  {
    sub_B62D0(v38);
    v35 = sub_BC120(v39);
  }
  else
  {
    *(_QWORD *)(v16 + 152) = sub_BC120((char *)*a8);
    v40 = *a8;
    v41 = (__int64 *)sub_3A8A0(
                       (__int64)v38,
                       (const char *)*a8,
                       a7,
                       0,
                       1LL,
                       a9,
                       a10,
                       (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))(v16 + 40),
                       *(__int64 **)(v16 + 16));
    v42 = *v41;
    *(_QWORD *)v16 = v41;
    v43 = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64))(v42 + 48))(v41, v40);
    if ( !v43 )
    {
LABEL_6:
      v31 = sub_1EFD0(*(__int64 **)(v16 + 16), 34);
      if ( v31 && v31 != 3 )
        __assert_fail("sshprot == 0 || sshprot == 3", "ssh.c", 0x322u, "connect_to_host");
      v32 = *(_BYTE *)(v16 + 80);
      if ( v31 || (*(_DWORD *)(v16 + 168) = 1, v32) )
      {
        v33 = v16 + 24;
        v34 = "2.0";
        *(_DWORD *)(v16 + 168) = 2;
        *(_QWORD *)(v16 + 24) = sub_41350;
      }
      else
      {
        v33 = v16 + 24;
        v34 = "1.5";
        *(_QWORD *)(v16 + 24) = sub_41350;
      }
      *(_QWORD *)(v16 + 400) = sub_84C20(*(_QWORD **)(v16 + 16), *(_QWORD *)(v16 + 64), v32, v34, v33, 0, "PuTTY");
      sub_412E0(v16);
      sub_1BE20(*(_QWORD *)(v16 + 400) + 168LL);
      if ( *src )
      {
        sub_2F4D0((void *)*a8);
        *a8 = (__int64)sub_BC120(src);
      }
      return 0LL;
    }
    v44 = *(_QWORD *)(v16 + 8);
    *(_QWORD *)v16 = 0LL;
    (*(void (**)(void))(*(_QWORD *)v44 + 24LL))();
    v35 = sub_BC120(v43);
  }
  if ( v35 )
  {
    *(_BYTE *)(v16 + 464) = 0;
    sub_7C1B0();
  }
  return v35;
}

__int64 __fastcall sub_41EE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 64);
}

void __fastcall sub_41EF0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  unsigned __int8 v3; // al
  char v4; // bp
  signed __int64 v5; // rsi
  __int64 v6; // rdi
  unsigned __int64 v7; // rax

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    v3 = *((_BYTE *)v1 + 185);
    v4 = *((_BYTE *)v1 + 186);
    v5 = 1LL;
    if ( !v3 )
    {
      v7 = sub_BCD00((__int64)(v1 + 25));
      v2 = *v1;
      v3 = v7 > 0x8000;
      v5 = v3;
    }
    *((_BYTE *)v1 + 186) = v3;
    (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v2 + 40LL))(v2, v5);
    if ( v4 && !*((_BYTE *)v1 + 186) )
    {
      v6 = v1[50];
      if ( v6 )
        sub_1BE20(v6 + 168);
    }
  }
}

void __usercall sub_41F80(_QWORD *a1@<rdi>, __int64 a2@<r15>)
{
  _QWORD *v2; // r12
  __int64 v3; // rbp
  __int64 v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // rdi
  __int64 v7; // r13
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r13
  __int64 v10; // rdi

  if ( *a1 )
  {
    v2 = a1;
    v3 = (__int64)(a1 + 30);
    do
    {
      if ( !sub_BCD00(v3) )
      {
        sub_41EF0(v2);
        if ( *((_BYTE *)v2 + 320) )
        {
          (*(void (**)(void))(*(_QWORD *)*v2 + 8LL))();
          *v2 = 0LL;
        }
        return;
      }
      v4 = sub_BCF00(v3);
      v6 = v2[8];
      v7 = v4;
      v8 = v5;
      if ( v6 )
        sub_2D4B0(0LL, v6, 1u, v4, v5, a2, 0LL, 0LL, 0LL, 0, 0LL);
      v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)*v2 + 16LL))(*v2, v7, v8);
      sub_BCE20(v3, v8);
    }
    while ( v9 <= 0x8000 );
    if ( !*((_BYTE *)v2 + 184) )
    {
      v10 = v2[52];
      *((_BYTE *)v2 + 184) = 1;
      v2[22] = v9;
      (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)(v10 + 8) + 144LL))(v10, 1LL);
    }
  }
}

void __usercall sub_420A0(__int64 a1@<rdx>, unsigned __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<r15>)
{
  _QWORD *v4; // r13
  __int64 v5; // rbx
  char *v6; // rbp
  unsigned __int64 v7; // r12
  __int64 v8; // rdi
  __int64 v9; // rdi

  v4 = (_QWORD *)(a3 - 40);
  v5 = a3;
  v6 = (char *)a1;
  v7 = a2;
  v8 = *(_QWORD *)(a3 + 24);
  if ( v8 )
    sub_2D4B0(0LL, v8, 0, a1, a2, a4, 0LL, 0LL, 0LL, 0, 0LL);
  sub_BCD20(v5 + 160, v6, v7);
  if ( !*(_BYTE *)(v5 + 145) )
  {
    v9 = *(_QWORD *)(v5 + 360);
    if ( v9 )
      sub_1BE20(v9 + 168);
  }
  sub_41EF0(v4);
}

void __fastcall sub_42130(_QWORD *a1)
{
  sub_41EF0(a1);
}

unsigned __int64 __usercall sub_42140@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rax
  char *v5; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v8; // [rsp+18h] [rbp-D0h]

  v8 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 408) || !*(_BYTE *)(a1 + 440) )
  {
    va_start(va, a4);
    v4 = sub_BC310(a2, (const __m128i *)va);
    *(_DWORD *)(a1 + 164) = 128;
    v5 = v4;
    sub_40E20((_QWORD *)a1);
    sub_2D2C0(*(_QWORD *)(a1 + 64), v5, a3, a4);
    sub_31A30(*(_QWORD *)(a1 + 8), (__int64)"%s", v5);
    sub_2F4D0(v5);
  }
  return __readfsqword(0x28u) ^ v8;
}

_QWORD *__usercall sub_42260@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rdi
  _QWORD *result; // rax

  if ( a2 )
    return (_QWORD *)sub_42140(a1 - 40, (__int64)"%s", a3, a4);
  v4 = *(_QWORD *)(a1 + 360);
  if ( v4 )
  {
    *(_BYTE *)(v4 + 24) = 1;
    result = sub_1BE20(v4 + 168);
  }
  return result;
}

unsigned __int64 __usercall sub_422B0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rax
  char *v5; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v8; // [rsp+18h] [rbp-D0h]

  v8 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 + 408) && *(_BYTE *)(a1 + 440) )
  {
    sub_40E20((_QWORD *)a1);
  }
  else
  {
    va_start(va, a4);
    v4 = sub_BC310(a2, (const __m128i *)va);
    *(_DWORD *)(a1 + 164) = 0;
    v5 = v4;
    sub_40E20((_QWORD *)a1);
    sub_2D2C0(*(_QWORD *)(a1 + 64), v5, a3, a4);
    sub_2F4D0(v5);
    (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 8) + 24LL))(*(_QWORD *)(a1 + 8), v5);
  }
  return __readfsqword(0x28u) ^ v8;
}

unsigned __int64 __usercall sub_423C0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  __int64 v4; // rbx
  char *v5; // rax
  __int64 v6; // rdi
  char *v7; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v10; // [rsp+18h] [rbp-D0h]

  v4 = a1;
  v10 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 408) || !*(_BYTE *)(a1 + 440) )
  {
    va_start(va, a4);
    v5 = sub_BC310(a2, (const __m128i *)va);
    v6 = *(_QWORD *)(a1 + 400);
    v7 = v5;
    *(_DWORD *)(v4 + 164) = 128;
    (*(void (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v6 + 32LL))(v6, v5, 2LL);
    sub_40E80(v4);
    sub_2D2C0(*(_QWORD *)(v4 + 64), v7, a3, a4);
    sub_31A30(*(_QWORD *)(v4 + 8), (__int64)"%s", v7);
    sub_2F4D0(v7);
  }
  return __readfsqword(0x28u) ^ v10;
}

unsigned __int64 __usercall sub_42500@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rax
  char *v5; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v8; // [rsp+18h] [rbp-D0h]

  v8 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 408) || !*(_BYTE *)(a1 + 440) )
  {
    va_start(va, a4);
    v4 = sub_BC310(a2, (const __m128i *)va);
    *(_DWORD *)(a1 + 164) = 128;
    v5 = v4;
    sub_40E80(a1);
    sub_2D2C0(*(_QWORD *)(a1 + 64), v5, a3, a4);
    sub_31A30(*(_QWORD *)(a1 + 8), (__int64)"%s", v5);
    sub_2F4D0(v5);
    (*(void (**)(void))(**(_QWORD **)(a1 + 8) + 24LL))();
  }
  return __readfsqword(0x28u) ^ v8;
}

void __usercall sub_42630(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  void *v3; // rbx

  v3 = *(void **)(a1 + 456);
  *(_QWORD *)(a1 + 456) = 0LL;
  sub_42500(a1, (__int64)"%s", a2, a3);
  sub_2F4D0(v3);
}

unsigned __int64 __usercall sub_42660@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rbp
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v7; // [rsp+18h] [rbp-D0h]

  v7 = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 408) || !*(_BYTE *)(a1 + 440) )
  {
    va_start(va, a4);
    v4 = sub_BC310(a2, (const __m128i *)va);
    if ( *(_DWORD *)(a1 + 164) < 0 )
      *(_DWORD *)(a1 + 164) = 0;
    sub_40E80(a1);
    sub_2D2C0(*(_QWORD *)(a1 + 64), v4, a3, a4);
    sub_2F4D0(v4);
    (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 8) + 24LL))(*(_QWORD *)(a1 + 8), v4);
  }
  return __readfsqword(0x28u) ^ v7;
}

unsigned __int64 sub_42780(__int64 a1, __int64 a2, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v4; // [rsp+18h] [rbp-C0h]

  v4 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 + 456) )
  {
    va_start(va, a2);
    *(_QWORD *)(a1 + 456) = sub_BC310(a2, (const __m128i *)va);
    sub_1BD80((__int64)sub_42630, a1);
  }
  return __readfsqword(0x28u) ^ v4;
}

void __fastcall sub_42860(__int64 a1, int a2)
{
  int v2; // eax
  int v3; // esi

  v2 = *(_DWORD *)(a1 + 172);
  v3 = v2 + a2;
  *(_DWORD *)(a1 + 172) = v3;
  if ( v3 < 0 )
    __assert_fail("ssh->conn_throttle_count >= 0", "ssh.c", 0x34Cu, "ssh_throttle_conn");
  if ( v3 )
  {
    if ( !v2 )
    {
      *(_BYTE *)(a1 + 185) = 1;
      sub_41EF0((_QWORD *)a1);
    }
  }
  else if ( v2 )
  {
    *(_BYTE *)(a1 + 185) = 0;
    sub_41EF0((_QWORD *)a1);
  }
}

bool __fastcall sub_428D0(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 48) + 152LL) == 4;
}

__int64 __fastcall sub_428E0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 56);
  if ( v1 )
    result = sub_2C080(v1);
  return result;
}

void __fastcall sub_42900(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 164) = a2;
}

void __fastcall sub_42920(__int64 a1)
{
  *(_BYTE *)(a1 + 160) = 1;
}

__int64 __fastcall sub_42930(__int64 a1, char *a2)
{
  __int64 v2; // rbp

  v2 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)a1 + 24LL))(1LL);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 96), a2);
  return sub_614E0(a1 + 88, (__int64 *)(v2 + 64));
}

__int64 __fastcall sub_42970(int a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rax

  v1 = sub_617D0();
  v2 = v1;
  *(_QWORD *)(v1 + 8) = 12LL;
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v1 + 96), a1);
  v3 = *(_QWORD *)(v2 + 8);
  *(_DWORD *)(v2 + 16) = a1;
  *(_DWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 56) = 0LL;
  *(_QWORD *)v2 = v3;
  return v2;
}

unsigned __int64 __fastcall sub_429C0(__int64 a1)
{
  __int64 v1; // r12
  signed int v2; // er13
  unsigned __int64 v3; // rbp
  __int64 v4; // rbx
  __int64 v5; // r14
  const char *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rdi
  int v9; // ST3C_4
  __int64 v10; // rbp
  int v11; // ebx
  int v12; // eax
  _BYTE *v13; // rdx
  _BYTE *v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rax
  __int64 v17; // r15
  __int64 v19; // [rsp+10h] [rbp-A8h]
  int v20; // [rsp+34h] [rbp-84h]
  void *v21; // [rsp+38h] [rbp-80h]
  char v22; // [rsp+40h] [rbp-78h]
  unsigned __int64 v23; // [rsp+78h] [rbp-40h]

  v23 = __readfsqword(0x28u);
  v19 = a1 + 88;
  if ( !*(_BYTE *)(a1 - 24) )
  {
    v1 = a1;
    while ( 1 )
    {
      v16 = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(v1 + 136))(v19, v19, 1LL);
      v17 = v16;
      if ( !v16 )
        break;
      v2 = *(_DWORD *)(v16 + 16);
      if ( *(_QWORD *)(v1 + 152) )
      {
        v3 = *(_QWORD *)(v16 + 8) - *(_QWORD *)v16;
        v4 = *(_QWORD *)(v16 + 32) + *(_QWORD *)v16;
        v5 = (unsigned int)sub_43430(*(_BYTE **)(v1 + 144), v2, 1, v4, v3, &v22);
        v6 = sub_61F60(*(_DWORD *)(v17 + 16));
        v7 = *(unsigned int *)(v17 + 16);
        sub_2D4B0((__int64)v6, *(_QWORD *)(v1 + 152), 1u, v4, v3, v17, v5, (__int64)&v22, 0LL, 0, 0LL);
      }
      v8 = *(_QWORD *)(v1 - 16);
      if ( v8 )
      {
        (*(void (__fastcall **)(__int64, signed __int64, _QWORD, void **, int *, _QWORD))(*(_QWORD *)v8 + 32LL))(
          v8,
          *(_QWORD *)(v17 + 32) + 12LL,
          (unsigned int)(*(_DWORD *)(v17 + 8) - 12),
          &v21,
          &v20,
          0LL);
        *(_QWORD *)(v17 + 8) = 12LL;
        sub_2EC20((__int64 (**)(void))(v17 + 96));
        sub_2F4D0(v21);
      }
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v17 + 96), 0);
      v9 = *(_DWORD *)(v17 + 8) - 12;
      v10 = v9 % 8;
      v11 = v9 + 8 - v9 % 8;
      sub_7BF50((char *)(v10 + *(_QWORD *)(v17 + 32)), 12 - v9 % 8);
      v12 = sub_62CF0(v10 + 4 + *(_QWORD *)(v17 + 32), v11 - 4);
      v13 = (_BYTE *)(*(_QWORD *)(v17 + 32) + v10 + v11);
      v13[3] = v12;
      v13[2] = BYTE1(v12);
      v13[1] = BYTE2(v12);
      *v13 = HIBYTE(v12);
      v14 = (_BYTE *)(v10 + *(_QWORD *)(v17 + 32));
      v14[3] = v9;
      v14[2] = BYTE1(v9);
      v14[1] = BYTE2(v9);
      *v14 = HIBYTE(v9);
      v15 = *(_QWORD *)(v1 - 48);
      if ( v15 )
        (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v15 + 32LL))(
          v15,
          v10 + 4 + *(_QWORD *)(v17 + 32),
          (unsigned int)v11);
      sub_BCD20(*(_QWORD *)(v1 + 16), (char *)(v10 + *(_QWORD *)(v17 + 32)), v11 + 4);
      sub_61840((void **)v17);
      if ( v2 == 37 )
      {
        *(_BYTE *)(v1 - 24) = 1;
        return __readfsqword(0x28u) ^ v23;
      }
    }
  }
  return __readfsqword(0x28u) ^ v23;
}

void __fastcall sub_42C20(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rdi
  __int64 v5; // rdi
  __int64 v6; // rdi
  void **v7; // rdi

  v1 = (void *)(a1 - 136);
  v2 = a1;
  v3 = *(_QWORD *)(a1 - 56);
  if ( v3 )
    (*(void (**)(void))(*(_QWORD *)v3 + 8LL))();
  v4 = *(_QWORD *)(v2 - 48);
  if ( v4 )
    (*(void (**)(void))(*(_QWORD *)v4 + 8LL))();
  v5 = *(_QWORD *)(v2 - 16);
  if ( v5 )
    (*(void (**)(void))(*(_QWORD *)v5 + 24LL))();
  v6 = *(_QWORD *)(v2 - 8);
  if ( v6 )
    (*(void (**)(void))(*(_QWORD *)v6 + 48LL))();
  v7 = *(void ***)(v2 - 40);
  if ( v7 )
    sub_62E00(v7);
  sub_2F4D0(*(void **)(v2 - 64));
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_42CA0(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_2F450(1uLL, 0x168uLL, 0LL);
  *v1 = 0LL;
  v1[44] = 0LL;
  memset(
    (void *)((unsigned __int64)(v1 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) & 0xFFFFFFF8) + 360) >> 3));
  v1[36] = a1;
  v2 = v1 + 17;
  *v2 = off_31EE40;
  sub_62760((__int64)(v1 + 17));
  return v2;
}

__int64 (__fastcall **__usercall sub_42D10@<rax>(__int64 a1@<rdx>, __int64 (__fastcall ***a2)()@<rdi>, __int64 a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r15>))()
{
  __int64 (__fastcall **result)(); // rax
  __int64 (__fastcall ***v6)(); // rbx
  __int64 v7; // rbp
  __int64 v8; // r12
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rsi
  char *v13; // rax

  result = off_31EE40;
  if ( *a2 != off_31EE40 )
    __assert_fail("bpp->vt == &ssh1_bpp_vtable", "ssh1bpp.c", 0x50u, "ssh1_bpp_new_cipher");
  v6 = a2;
  if ( *(a2 - 7) )
    __assert_fail("!s->cipher_in", "ssh1bpp.c", 0x53u, "ssh1_bpp_new_cipher");
  if ( *(a2 - 6) )
    __assert_fail("!s->cipher_out", "ssh1bpp.c", 0x54u, "ssh1_bpp_new_cipher");
  v7 = a3;
  if ( a3 )
  {
    v8 = a1;
    *(a2 - 7) = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(__int64))a3)(a3);
    v9 = (*(__int64 (__fastcall **)(__int64))a3)(a3);
    v10 = (__int64)*(a2 - 7);
    *(v6 - 6) = (__int64 (__fastcall **)())v9;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 24LL))(v10, v8);
    (*((void (__fastcall **)(_QWORD, __int64))**(v6 - 6) + 3))(*(v6 - 6), v8);
    if ( *(v6 - 5) )
      __assert_fail("!s->crcda_ctx", "ssh1bpp.c", 0x5Cu, "ssh1_bpp_new_cipher");
    v11 = sub_62DD0();
    v12 = *(_QWORD *)(a3 + 88);
    *(v6 - 5) = (__int64 (__fastcall **)())v11;
    v13 = sub_BC360((__int64)"Initialised %s encryption", v12);
    sub_2D3A0((__int64)v6[19], v13, a4, a5);
    *(v6 - 4) = 0LL;
    if ( *(_DWORD *)(v7 + 72) > 8u )
      __assert_fail("cipher->blksize <= sizeof(s->iv)", "ssh1bpp.c", 0x63u, "ssh1_bpp_new_cipher");
    (*((void (__fastcall **)(_QWORD, __int64 (__fastcall ***)()))**(v6 - 7) + 2))(*(v6 - 7), v6 - 4);
    result = (__int64 (__fastcall **)())(*((__int64 (__fastcall **)(_QWORD, __int64 (__fastcall ***)()))**(v6 - 6) + 2))(
                                          *(v6 - 6),
                                          v6 - 4);
  }
  return result;
}

void __usercall sub_42E90(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  char *v3; // rax

  if ( *(__int64 (__fastcall ***)())a1 != off_31EE40 )
    __assert_fail("bpp->vt == &ssh1_bpp_vtable", "ssh1bpp.c", 0x6Cu, "ssh1_bpp_start_compression");
  if ( *(_QWORD *)(a1 - 16) )
    __assert_fail("!s->compctx", "ssh1bpp.c", 0x6Fu, "ssh1_bpp_start_compression");
  if ( *(_QWORD *)(a1 - 8) )
    __assert_fail("!s->decompctx", "ssh1bpp.c", 0x70u, "ssh1_bpp_start_compression");
  *(_QWORD *)(a1 - 16) = sub_86340();
  *(_QWORD *)(a1 - 8) = sub_86440();
  v3 = sub_BC360((__int64)"Started zlib (RFC1950) compression");
  sub_2D3A0(*(_QWORD *)(a1 + 152), v3, a2, a3);
}

unsigned __int64 __usercall sub_42F40@<rax>(__int64 a1@<rdi>, unsigned __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbx
  int v4; // eax
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rt1
  unsigned __int64 v7; // rdx
  char *v8; // rsi
  signed __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rdi
  unsigned __int8 *v16; // rsi
  __int64 v17; // r8
  size_t v18; // rdx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rcx
  signed int v23; // esi
  __int64 v24; // rdx
  bool v25; // zf
  __int64 v26; // r14
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rbp
  const char *v30; // rax
  __int64 v31; // rdx
  int v32; // eax
  __int64 v33; // rdi
  signed __int32 v34; // edx
  unsigned __int64 v35; // rcx
  unsigned __int64 v36; // rax
  __int64 v37; // rdx
  char *v38; // rax
  __m128i *v39; // rbp
  __int64 v40; // rdx
  _QWORD *v41; // rax
  __m128i v42; // xmm0
  size_t v43; // rsi
  int v44; // [rsp+4h] [rbp-74h]
  void *src; // [rsp+8h] [rbp-70h]
  char v46; // [rsp+10h] [rbp-68h]
  unsigned int v47; // [rsp+44h] [rbp-34h]
  unsigned __int64 v48; // [rsp+48h] [rbp-30h]

  v3 = a1;
  v48 = __readfsqword(0x28u);
  v4 = *(_DWORD *)(a1 - 136);
  if ( v4 == 143 )
    goto LABEL_27;
  if ( v4 == 169 )
  {
    v7 = *(_QWORD *)(a1 - 112);
    v8 = *(char **)(a1 - 88);
    goto LABEL_8;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 - 136) = 0;
  }
  else
  {
    while ( 1 )
    {
      *(_QWORD *)(v3 - 96) = 0LL;
      *(_QWORD *)(v3 - 104) = 0LL;
      *(_DWORD *)(v3 - 136) = 143;
LABEL_27:
      if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(v3 + 8), (char *)&v47, 4uLL) )
        break;
      sub_41EF0(*(_QWORD **)(v3 + 160));
      v34 = _byteswap_ulong(v47);
      v35 = v34 - 5LL;
      *(_QWORD *)(v3 - 128) = v34;
      if ( v35 > 0x3FFFB )
      {
        sub_42500(
          *(_QWORD *)(v3 + 160),
          (__int64)"Out-of-range packet length from remote suggests data stream corruption",
          a2,
          a3);
        *(_DWORD *)(v3 - 136) = 0;
        goto LABEL_5;
      }
      *(_QWORD *)(v3 - 104) = v35;
      v36 = ((unsigned __int64)((signed __int64)v34 >> 63) >> 61)
          - (((_BYTE)v34 + ((unsigned __int64)((signed __int64)v34 >> 63) >> 61)) & 7)
          + 8;
      v37 = v36 + v34;
      *(_QWORD *)(v3 - 120) = v36;
      *(_QWORD *)(v3 - 112) = v37;
      v38 = (char *)sub_2F450(1uLL, 0x58uLL, v37);
      v7 = *(_QWORD *)(v3 - 112);
      v8 = v38 + 88;
      *(_QWORD *)(v3 - 64) = v38;
      *((_QWORD *)v38 + 2) = 0LL;
      *((_QWORD *)v38 + 3) = 0LL;
      v38[40] = 0;
      *(_DWORD *)v38 = 0;
      *(_QWORD *)(v3 - 96) = v7;
      *(_QWORD *)(v3 - 88) = v38 + 88;
      *(_DWORD *)(v3 - 136) = 169;
LABEL_8:
      if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(v3 + 8), v8, v7) )
        break;
      sub_41EF0(*(_QWORD **)(v3 + 160));
      if ( *(_QWORD *)(v3 - 56)
        && sub_62E30(
             *(_QWORD *)(v3 - 40),
             *(unsigned int **)(v3 - 88),
             *(_DWORD *)(v3 - 112),
             (unsigned int *)(v3 - 32)) )
      {
        sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Network attack (CRC compensation) detected!", a2, a3);
        *(_DWORD *)(v3 - 136) = 0;
        goto LABEL_5;
      }
      v9 = *(_QWORD *)(v3 - 112);
      if ( v9 <= 7 )
        goto LABEL_39;
      v10 = *(_QWORD *)(v3 - 88);
      v11 = *(_QWORD *)(v3 - 56);
      *(_QWORD *)(v3 - 32) = *(_QWORD *)(v10 + v9 - 8);
      if ( v11 )
      {
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v11 + 40LL))(v11, v10);
        v9 = *(_QWORD *)(v3 - 112);
        v10 = *(_QWORD *)(v3 - 88);
      }
      v12 = sub_62CF0(v10, v9 - 4);
      v13 = *(_QWORD *)(v3 - 88);
      v14 = *(_QWORD *)(v3 - 112);
      *(_DWORD *)(v3 - 80) = v12;
      LODWORD(v14) = _byteswap_ulong(*(_DWORD *)(v13 + v14 - 4));
      *(_DWORD *)(v3 - 76) = v14;
      if ( v12 != (_DWORD)v14 )
      {
        sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Incorrect CRC received on packet", a2, a3);
        *(_DWORD *)(v3 - 136) = 0;
        goto LABEL_5;
      }
      v15 = *(_QWORD *)(v3 - 8);
      v16 = (unsigned __int8 *)(*(_QWORD *)(v3 - 120) + v13);
      v17 = *(_QWORD *)(v3 - 104);
      if ( v15 )
      {
        if ( !(*(unsigned __int8 (__fastcall **)(__int64, unsigned __int8 *, _QWORD, void **, int *))(*(_QWORD *)v15 + 56LL))(
                v15,
                v16,
                (unsigned int)(v17 + 1),
                &src,
                &v44) )
        {
          sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Zlib decompression encountered invalid data", a2, a3);
          *(_DWORD *)(v3 - 136) = 0;
          goto LABEL_5;
        }
        v18 = v44;
        v19 = *(_QWORD *)(v3 - 120);
        v20 = v44 + v19;
        if ( *(_QWORD *)(v3 - 96) < v20 )
        {
          v39 = *(__m128i **)(v3 - 64);
          v40 = v44 + v19;
          *(_QWORD *)(v3 - 96) = v20;
          v41 = sub_2F450(1uLL, 0x58uLL, v40);
          v42 = _mm_loadu_si128(v39);
          *(_QWORD *)(v3 - 64) = v41;
          v43 = *(_QWORD *)(v3 - 112);
          v41 += 11;
          *(__m128i *)(v41 - 11) = v42;
          *(__m128i *)(v41 - 9) = _mm_loadu_si128(v39 + 1);
          *(__m128i *)(v41 - 7) = _mm_loadu_si128(v39 + 2);
          *(__m128i *)(v41 - 5) = _mm_loadu_si128(v39 + 3);
          *(__m128i *)(v41 - 3) = _mm_loadu_si128(v39 + 4);
          *(v41 - 1) = v39[5].m128i_i64[0];
          *(_QWORD *)(v3 - 88) = v41;
          sub_BD070(v39, v43);
          sub_2F4D0(v39);
          v19 = *(_QWORD *)(v3 - 120);
          v18 = v44;
        }
        memcpy((void *)(*(_QWORD *)(v3 - 88) + v19), src, v18);
        sub_2F4D0(src);
        v16 = (unsigned __int8 *)(*(_QWORD *)(v3 - 88) + *(_QWORD *)(v3 - 120));
        v17 = v44 - 1;
        *(_QWORD *)(v3 - 104) = v17;
      }
      v21 = *(_QWORD *)(v3 - 64);
      v22 = (__int64)(v16 + 1);
      *(_QWORD *)(v3 - 88) = v16 + 1;
      v23 = *v16;
      *(_QWORD *)(v21 + 48) = v22;
      *(_QWORD *)(v21 + 64) = v17;
      *(_QWORD *)(v21 + 56) = 0LL;
      *(_DWORD *)(v21 + 72) = 0;
      *(_QWORD *)(v21 + 80) = v21 + 48;
      v24 = 0LL;
      v25 = *(_QWORD *)(v3 + 152) == 0LL;
      *(_DWORD *)v21 = v23;
      if ( !v25 )
      {
        v26 = (unsigned int)sub_43430(*(_BYTE **)(v3 + 144), v23, 0, v22, v17, &v46);
        v27 = *(_QWORD *)(v3 - 64);
        v28 = *(_QWORD *)(v27 + 56);
        a2 = *(_QWORD *)(v27 + 64) - v28;
        v29 = *(_QWORD *)(v27 + 48) + v28;
        v30 = sub_61F60(*(_DWORD *)v27);
        v31 = **(unsigned int **)(v3 - 64);
        sub_2D4B0((__int64)v30, *(_QWORD *)(v3 + 152), 0, v29, a2, a3, v26, (__int64)&v46, 0LL, 0, 0LL);
        v21 = *(_QWORD *)(v3 - 64);
        v17 = *(_QWORD *)(v21 + 64);
        v24 = *(_QWORD *)(v21 + 56);
      }
      *(_QWORD *)(v21 + 32) = v17 - v24;
      sub_614E0(v3 + 32, (__int64 *)(v21 + 16));
      v32 = **(_DWORD **)(v3 - 64);
      *(_QWORD *)(v3 - 64) = 0LL;
      if ( (unsigned int)(v32 - 14) <= 1 && *(_BYTE *)(v3 - 24) )
      {
        if ( v32 == 14 )
          sub_42E90(v3, a2, a3);
        *(_BYTE *)(v3 - 24) = 0;
        sub_1BE20(v3 + 192);
      }
    }
    if ( *(_BYTE *)(v3 + 24) )
    {
      v33 = *(_QWORD *)(v3 + 160);
      if ( *(_BYTE *)(v3 + 222) )
        sub_422B0(v33, (__int64)"Remote side closed network connection", a2, a3);
      else
        sub_42140(v33, (__int64)"Remote side unexpectedly closed network connection", a2, a3);
    }
  }
LABEL_5:
  v6 = __readfsqword(0x28u);
  result = v6 ^ v48;
  if ( v6 != v48 )
LABEL_39:
    __assert_fail("s->biglen >= 8", "ssh1bpp.c", 0xB3u, "ssh1_bpp_handle_input");
  return result;
}

__int64 __fastcall sub_43430(_BYTE *a1, signed int a2, char a3, __int64 a4, __int64 a5, _DWORD *a6)
{
  _BYTE *v6; // rbp
  char v7; // r12
  bool v8; // zf
  __int64 *v9; // rdi
  signed int v10; // ebx
  int v12; // ST10_4
  int v13; // edx
  int v14; // eax
  __int64 v15; // rax
  _DWORD *v16; // rax
  _DWORD *v17; // ST18_8
  int v18; // ST10_4
  int v19; // edx
  signed __int64 v20; // rax
  _DWORD *v21; // rax
  _DWORD *v22; // [rsp+8h] [rbp-60h]
  _DWORD *v23; // [rsp+18h] [rbp-50h]
  __int64 v24; // [rsp+20h] [rbp-48h]
  __int64 v25; // [rsp+28h] [rbp-40h]
  __int64 v26; // [rsp+30h] [rbp-38h]
  int v27; // [rsp+38h] [rbp-30h]
  __int64 *v28; // [rsp+40h] [rbp-28h]
  unsigned __int64 v29; // [rsp+48h] [rbp-20h]

  v6 = a1;
  v7 = a3;
  v29 = __readfsqword(0x28u);
  v8 = a1[1] == 0;
  v9 = &v24;
  v24 = a4;
  v26 = a5;
  v25 = 0LL;
  v27 = 0;
  v28 = &v24;
  if ( v8 || (unsigned int)(a2 - 16) > 2 && a2 != 23 )
    goto LABEL_20;
  if ( a2 == 23 )
  {
    v17 = a6;
    v18 = a5;
    sub_2F150((__int64)&v24);
    v9 = v28;
    a6 = v17;
    LODWORD(a5) = v18;
    a2 = 23;
  }
  v23 = a6;
  v12 = a5;
  sub_2F1D0((__int64)v9);
  LODWORD(a5) = v12;
  a6 = v23;
  if ( *((_DWORD *)v28 + 6) )
  {
LABEL_20:
    v10 = 0;
  }
  else
  {
    v14 = v25;
    v23[2] = 2;
    v10 = 1;
    v23[1] = v13;
    *v23 = v14 - v13;
  }
  if ( v7 && *v6 )
  {
    if ( (a2 & 0xFFFFFFDF) == 9 || a2 == 72 )
    {
      v15 = v10++;
      v16 = &a6[3 * v15];
      *v16 = 0;
      v16[1] = a5;
      v16[2] = 1;
    }
    else if ( a2 == 34 )
    {
      v22 = a6;
      sub_2F1D0((__int64)v28);
      sub_2F1D0((__int64)v28);
      if ( !*((_DWORD *)v28 + 6) )
      {
        v20 = 3LL * v10++;
        v21 = &v22[v20];
        *v21 = v25 - v19;
        v21[2] = 1;
        v21[1] = v19;
      }
    }
  }
  return (unsigned int)v10;
}

__int64 __fastcall sub_435F0(__int64 a1, unsigned __int8 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 168LL))(*(_QWORD *)(a1 + 48), a2);
}

void nullsub_19()
{
  ;
}

__int64 sub_43620()
{
  return 0LL;
}

__int64 sub_43630()
{
  return 0LL;
}

__int64 sub_43640()
{
  return 0LL;
}

void nullsub_20()
{
  ;
}

__int64 __fastcall sub_43660(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 + 48) + 8LL))();
}

__int64 __fastcall sub_43670(__int64 a1, int a2, int a3)
{
  int v3; // er13
  __int64 v4; // rax
  void (__fastcall **v5)(_QWORD, char *, signed __int64, _QWORD); // rbp
  __int64 v6; // rbx

  v3 = a3;
  v4 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(11LL);
  v5 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v4 + 96);
  v6 = v4;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v4 + 96), v3);
  sub_2ED90(v5, a2);
  sub_2ED90(v5, 0);
  sub_2ED90(v5, 0);
  return sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v6 + 64));
}

__int64 __fastcall sub_436E0(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(19LL);
  return sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v1 + 64));
}

_QWORD *__fastcall sub_43710(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // r12
  char v5; // bp
  _QWORD *v6; // rax
  __int64 v7; // rdx

  v4 = a3;
  v5 = a4;
  v6 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v7 = *(_QWORD *)(a1 + 152);
  *v6 = a2;
  v6[1] = v4;
  *((_BYTE *)v6 + 24) = v5;
  v6[2] = 0LL;
  if ( v7 )
    *(_QWORD *)(v7 + 16) = v6;
  else
    *(_QWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 152) = v6;
  return sub_1BD80((__int64)sub_43890, a1);
}

_QWORD *__fastcall sub_43790(__int64 a1, char a2)
{
  char v2; // r12
  __int64 v3; // rax
  __int64 v4; // rdi
  void *v5; // rsi

  v2 = a2;
  v3 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(12LL);
  sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v3 + 64));
  v4 = a1 - 32;
  v5 = sub_435F0;
  if ( !v2 )
    v5 = nullsub_19;
  return sub_43710(v4, (__int64)v5, 0LL, 1);
}

_QWORD *__fastcall sub_437F0(__int64 a1, char a2)
{
  char v2; // r12
  __int64 v3; // rax
  __int64 v4; // rdi
  void *v5; // rsi

  v2 = a2;
  v3 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(30LL);
  sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v3 + 64));
  v4 = a1 - 32;
  v5 = sub_435F0;
  if ( !v2 )
    v5 = nullsub_19;
  return sub_43710(v4, (__int64)v5, 0LL, 0);
}

void __fastcall sub_43850(__int64 a1, unsigned __int8 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax

  v2 = *(_QWORD **)(a1 + 144);
  v3 = v2[2];
  *(_QWORD *)(a1 + 144) = v3;
  if ( !v3 )
    *(_QWORD *)(a1 + 152) = 0LL;
  ((void (__fastcall *)(__int64, _QWORD, _QWORD))*v2)(a1, a2, v2[1]);
  sub_2F4D0(v2);
}

__int64 __fastcall sub_43890(__int64 a1)
{
  __int64 result; // rax

  for ( result = *(_QWORD *)(a1 + 144); result; result = *(_QWORD *)(a1 + 144) )
  {
    if ( !*(_BYTE *)(result + 24) )
      break;
    sub_43850(a1, 1u);
  }
  return result;
}

_QWORD *__fastcall sub_438E0(__int64 a1, char a2, char *a3)
{
  char *v3; // r14
  char v4; // r13
  __int64 v5; // rbx
  __int64 v6; // rdi
  void *v7; // rsi

  v3 = a3;
  v4 = a2;
  v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(13LL);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 96), v3);
  sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v5 + 64));
  v6 = a1 - 32;
  v7 = sub_435F0;
  if ( !v4 )
    v7 = nullsub_19;
  return sub_43710(v6, (__int64)v7, 0LL, 1);
}

_QWORD *__fastcall sub_43960(__int64 a1, char a2, char *a3, char *a4, int a5)
{
  char *v5; // r15
  char v6; // r14
  char *v7; // ST08_8
  __int64 v8; // rax
  void (__fastcall **v9)(_QWORD, char *, signed __int64); // r13
  __int64 v10; // rbx
  void *v11; // rsi
  int v13; // [rsp+4h] [rbp-44h]

  v5 = a4;
  v6 = a2;
  v13 = a5;
  v7 = a3;
  v8 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 184) + 24LL))(34LL);
  v9 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96);
  v10 = v8;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96), v7);
  sub_2EF40(v9, v5);
  if ( *(_BYTE *)(a1 - 16) & 1 )
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v9, v13);
  sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v10 + 64));
  v11 = sub_435F0;
  if ( !v6 )
    v11 = nullsub_19;
  return sub_43710(a1 - 32, (__int64)v11, 0LL, 0);
}

__int64 __fastcall sub_43A20(_QWORD *a1, char a2, __int64 a3, int a4, int a5)
{
  char v5; // r15
  int v6; // er12
  __int64 v7; // rax
  __int64 v8; // r13
  char *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  void *v13; // rsi
  __int64 result; // rax
  unsigned __int64 v15; // rt1
  int v16; // [rsp-510h] [rbp-A78h]
  int v17; // [rsp-508h] [rbp-A70h]
  int v18; // [rsp-500h] [rbp-A68h]
  int v19; // [rsp-4F8h] [rbp-A60h]
  int v20; // [rsp-4F0h] [rbp-A58h]
  int v21; // [rsp-4E8h] [rbp-A50h]
  int v22; // [rsp-4E0h] [rbp-A48h]
  int v23; // [rsp-4D8h] [rbp-A40h]
  int v24; // [rsp-4D0h] [rbp-A38h]
  int v25; // [rsp-4C8h] [rbp-A30h]
  int v26; // [rsp-4C0h] [rbp-A28h]
  int v27; // [rsp-4B8h] [rbp-A20h]
  int v28; // [rsp-4B0h] [rbp-A18h]
  int v29; // [rsp-4A8h] [rbp-A10h]
  int v30; // [rsp-4A0h] [rbp-A08h]
  int v31; // [rsp-498h] [rbp-A00h]
  int v32; // [rsp-490h] [rbp-9F8h]
  int v33; // [rsp-488h] [rbp-9F0h]
  int v34; // [rsp-480h] [rbp-9E8h]
  int v35; // [rsp-478h] [rbp-9E0h]
  int v36; // [rsp-470h] [rbp-9D8h]
  int v37; // [rsp-468h] [rbp-9D0h]
  int v38; // [rsp-460h] [rbp-9C8h]
  int v39; // [rsp-458h] [rbp-9C0h]
  int v40; // [rsp-450h] [rbp-9B8h]
  int v41; // [rsp-448h] [rbp-9B0h]
  int v42; // [rsp-440h] [rbp-9A8h]
  int v43; // [rsp-438h] [rbp-9A0h]
  int v44; // [rsp-430h] [rbp-998h]
  int v45; // [rsp-428h] [rbp-990h]
  int v46; // [rsp-420h] [rbp-988h]
  int v47; // [rsp-418h] [rbp-980h]
  __int64 v48; // [rsp-410h] [rbp-978h]
  int v49; // [rsp-8h] [rbp-570h]
  int v50; // [rsp+4h] [rbp-564h]
  __int64 *v51; // [rsp+8h] [rbp-560h]
  char v52; // [rsp+10h] [rbp-558h]
  int v53; // [rsp+518h] [rbp-50h]
  unsigned __int64 v54; // [rsp+528h] [rbp-40h]

  v5 = a2;
  v6 = a5;
  v54 = __readfsqword(0x28u);
  v7 = a1[23];
  v50 = a4;
  v51 = (__int64 *)a3;
  v8 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v7 + 24LL))(10LL);
  v9 = (char *)sub_1F170((__int64 *)*(a1 - 3), 52);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96), v9);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v8 + 96), v6);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v8 + 96), v50);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v8 + 96), 0);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v8 + 96), 0);
  sub_61890(&v52, a1[32], v51);
  qmemcpy(&v16, &v52, 0x508uLL);
  v49 = v53;
  sub_61CE0(
    v8 + 96,
    1,
    v10,
    0LL,
    v11,
    v12,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48);
  sub_614E0(a1[25], (__int64 *)(v8 + 64));
  v13 = sub_435F0;
  if ( !v5 )
    v13 = nullsub_19;
  v15 = __readfsqword(0x28u);
  result = v15 ^ v54;
  if ( v15 == v54 )
    result = (__int64)sub_43710((__int64)(a1 - 4), (__int64)v13, 0LL, 0);
  return result;
}

__int64 __fastcall sub_43B60(__int64 a1, __int64 a2, char *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r13
  char *v5; // r12
  __int64 v6; // rbx

  v4 = a4;
  v5 = a3;
  v6 = (*(__int64 (__fastcall **)(signed __int64, __int64))(**(_QWORD **)(a1 + 184) + 24LL))(16LL, a2);
  sub_2EE80((void (__fastcall **)(_QWORD, char *, signed __int64))(v6 + 96), v5, v4);
  sub_614E0(*(_QWORD *)(a1 + 200), (__int64 *)(v6 + 64));
  return 0LL;
}

void __usercall sub_43BC0(__int64 a1@<rdx>, _QWORD *a2@<rdi>, char a3@<sil>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  __int64 v5; // rbx
  char *v6; // rax
  char *v7; // rax

  if ( a3 )
  {
    v7 = sub_BC360((__int64)"Remote port forwarding from %s enabled", *(_QWORD *)(a1 + 32), a1);
    sub_2D3A0(a2[35], v7, a4, a5);
  }
  else
  {
    v5 = a1;
    v6 = sub_BC360((__int64)"Remote port forwarding from %s refused", *(_QWORD *)(a1 + 32));
    sub_2D3A0(a2[35], v6, a4, a5);
    if ( v5 != sub_9B440((__int64 *)a2[15], v5) )
      __assert_fail("realpf == rpf", "ssh1connection-client.c", 0x1ECu, "ssh1_rportfwd_response");
    sub_37FE0(a2[16], *(_QWORD *)(v5 + 48));
    sub_83CB0((void **)v5);
  }
}

__int64 sub_43C70()
{
  return 0LL;
}

void __fastcall sub_43C80(__int64 a1)
{
  if ( !*(_QWORD *)(a1 + 56) )
    *(_QWORD *)(a1 + 56) = sub_2E040(
                             a1 + 208,
                             a1 + 192,
                             *(__int64 **)(a1 + 8),
                             *(_DWORD *)(a1 + 72),
                             *(_DWORD *)(a1 + 76),
                             0,
                             0LL);
}

__int64 __usercall sub_43CD0@<rax>(__int64 a1@<rdi>, unsigned int *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbp
  int v5; // edi
  int v6; // er13
  unsigned int v7; // ebx
  __int64 v8; // rbx
  __int64 *v9; // rsi
  char *v11; // rax
  __int64 v12; // rdx
  signed int v13; // eax
  unsigned int v14; // eax
  int v15; // ebx
  char *v16; // rax
  int v17; // eax
  int v18; // er12
  __int64 v19; // rbx
  __int64 *v20; // rsi
  char *v21; // rax
  int v22; // er14
  char *v23; // rax
  size_t v24; // rdx
  size_t v25; // r12
  char *v26; // r15
  __int64 v27; // r13
  char *v28; // rax
  __int64 *v29; // rdi
  __int64 v30; // r12
  _QWORD *v31; // rax
  char *v32; // rsi
  _QWORD *v33; // rbx
  char *v34; // rax
  char *v35; // rax
  char *v36; // r12
  char *v37; // rsi
  __int64 v38; // rbx
  __int64 v39; // rax
  __int64 v40; // rax
  void (__fastcall **v41)(_QWORD, char *, signed __int64, _QWORD); // r13
  __int64 v42; // r12
  char *v43; // rax
  __int64 v44; // rdi
  __int64 *v45; // rax
  __int64 *v46; // r14
  __int64 (__fastcall ***v47)(); // r13
  __int64 (__fastcall **v48)(); // r12
  __int64 v49; // rax
  void (__fastcall **v50)(_QWORD, char *, signed __int64, _QWORD); // r13
  __int64 v51; // r12
  __int64 *v52; // rax
  __int64 v53; // rdi
  __int64 v54; // rax
  __int64 v55; // rax
  void (__fastcall **v56)(_QWORD, char *, signed __int64, _QWORD); // r14
  __int64 v57; // r12
  __int64 v58; // [rsp+10h] [rbp-78h]
  char *v59; // [rsp+20h] [rbp-68h]
  unsigned __int64 v60; // [rsp+48h] [rbp-40h]

  v4 = a1;
  v5 = *a2;
  v60 = __readfsqword(0x28u);
  switch ( v5 )
  {
    case 14:
    case 15:
      if ( *(_QWORD *)(v4 + 144) )
      {
        v7 = 1;
        sub_43850(v4, v5 == 14);
        sub_1BD80((__int64)sub_43890, v4);
      }
      else
      {
        sub_61F60(v5);
        v7 = 1;
        sub_42140(*(_QWORD *)(v4 + 296), (__int64)"Received %s with no outstanding request", a3, a4);
      }
      return v7;
    case 17:
    case 18:
      v11 = sub_2F1D0((__int64)(a2 + 12));
      if ( a2[18] )
        return 1;
      v13 = (***(__int64 (__fastcall ****)(_QWORD, bool, char *, __int64))(v4 + 288))(
              *(_QWORD *)(v4 + 288),
              *a2 == 18,
              v11,
              v12);
      v7 = *(unsigned __int8 *)(v4 + 67) ^ 1;
      LOBYTE(v7) = (v13 > 0x8000) & (*(_BYTE *)(v4 + 67) ^ 1);
      if ( !(_BYTE)v7 )
        return 1;
      v44 = *(_QWORD *)(v4 + 296);
      *(_BYTE *)(v4 + 67) = 1;
      sub_42860(v44, 1);
      return v7;
    case 20:
      v14 = sub_2F150((__int64)(a2 + 12));
      v15 = v14;
      v16 = sub_BC360((__int64)"Server sent command exit status %d", v14);
      sub_2D3A0(*(_QWORD *)(v4 + 280), v16, a3, a4);
      sub_42900(*(_QWORD *)(v4 + 296), v15);
      *(_BYTE *)(v4 + 69) = 1;
      return 1;
    case 27:
      v17 = sub_2F150((__int64)(a2 + 12));
      v7 = *(unsigned __int8 *)(v4 + 88);
      v18 = v17;
      if ( (_BYTE)v7 )
      {
        v52 = (__int64 *)sub_2F450(1uLL, 0x38uLL, 0LL);
        *v52 = v4;
        a3 = (__int64)v52;
        sub_45370(v52);
        v53 = *(_QWORD *)(v4 + 112);
        *(_DWORD *)(a3 + 8) = v18;
        *(_QWORD *)(a3 + 32) = sub_BF100(v53, a3 + 40, 0LL, -1, 0);
        v54 = *(_QWORD *)(v4 + 216);
        *(_DWORD *)(a3 + 8) = v18;
        *(_BYTE *)(a3 + 20) = 0;
        v55 = (*(__int64 (__fastcall **)(signed __int64, __int64))(*(_QWORD *)v54 + 24LL))(21LL, a3 + 40);
        v56 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v55 + 96);
        v57 = v55;
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v55 + 96), *(_DWORD *)(a3 + 8));
        sub_2ED90(v56, *(_DWORD *)(a3 + 12));
        sub_614E0(*(_QWORD *)(v4 + 232), (__int64 *)(v57 + 64));
        v21 = sub_BC360((__int64)"Opened X11 forward channel", v57 + 64);
      }
      else
      {
        v19 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v4 + 216) + 24LL))(22LL);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v19 + 96), v18);
        v20 = (__int64 *)(v19 + 64);
        v7 = 1;
        sub_614E0(*(_QWORD *)(v4 + 232), v20);
        v21 = sub_BC360((__int64)"Rejected X11 connect request");
      }
      sub_2D3A0(*(_QWORD *)(v4 + 280), v21, a3, a4);
      return v7;
    case 29:
      v22 = sub_2F150((__int64)(a2 + 12));
      v23 = sub_2F1D0((__int64)(a2 + 12));
      v25 = v24;
      v26 = v23;
      v27 = sub_2F150((__int64)(a2 + 12));
      v28 = sub_BD360(v26, v25);
      v29 = *(__int64 **)(v4 + 120);
      v59 = v28;
      HIDWORD(v58) = v27;
      v30 = sub_9B3D0(v29, (__int64)&v58, 0LL);
      if ( !v30 )
      {
        v37 = sub_BC360((__int64)"Rejected remote port open request for %s:%d", v59, (unsigned int)v27);
        sub_2D3A0(*(_QWORD *)(v4 + 280), v37, v27, (__int64)v26);
        goto LABEL_17;
      }
      v31 = sub_2F450(1uLL, 0x38uLL, 0LL);
      v32 = v59;
      v33 = v31;
      *v31 = v4;
      v34 = sub_BC360((__int64)"Received remote port open request for %s:%d", v32, (unsigned int)v27);
      sub_2D3A0(*(_QWORD *)(v4 + 280), v34, v27, (__int64)v26);
      v35 = sub_38D40(*(__int64 **)(v4 + 128), v33 + 4, v59, v27, (__int64)(v33 + 5), *(_DWORD *)(v30 + 24));
      v36 = v35;
      if ( v35 )
      {
        v37 = sub_BC360((__int64)"Port open failed: %s", v35);
        sub_2D3A0(*(_QWORD *)(v4 + 280), v37, v27, (__int64)v26);
        sub_2F4D0(v36);
        sub_44950((void (****)(void))v33);
LABEL_17:
        v38 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 216) + 24LL))(22LL, v37);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v38 + 96), v22);
        sub_614E0(*(_QWORD *)(v4 + 232), (__int64 *)(v38 + 64));
        goto LABEL_18;
      }
      sub_45370(v33);
      v39 = *(_QWORD *)(v4 + 216);
      *((_DWORD *)v33 + 2) = v22;
      *((_BYTE *)v33 + 20) = 0;
      v40 = (*(__int64 (__fastcall **)(signed __int64, _QWORD *))(*(_QWORD *)v39 + 24LL))(21LL, v33 + 4);
      v41 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v40 + 96);
      v42 = v40;
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v40 + 96), *((_DWORD *)v33 + 2));
      sub_2ED90(v41, *((_DWORD *)v33 + 3));
      sub_614E0(*(_QWORD *)(v4 + 232), (__int64 *)(v42 + 64));
      v43 = sub_BC360((__int64)"Forwarded port opened successfully", v42 + 64);
      sub_2D3A0(*(_QWORD *)(v4 + 280), v43, (__int64)v41, (__int64)v26);
LABEL_18:
      v7 = 1;
      sub_2F4D0(v59);
      return v7;
    case 31:
      v6 = sub_2F150((__int64)(a2 + 12));
      v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v4 + 200) + 112LL))(v4 + 192);
      if ( (_BYTE)v7 )
      {
        v45 = (__int64 *)sub_2F450(1uLL, 0x38uLL, 0LL);
        *v45 = v4;
        v46 = v45;
        sub_45370(v45);
        *((_DWORD *)v46 + 2) = v6;
        *((_BYTE *)v46 + 20) = 0;
        v47 = (__int64 (__fastcall ***)())sub_37D90(v4 + 192, &v58, 1);
        v48 = (__int64 (__fastcall **)())sub_B3DF0(v58, (__int64)&v58);
        if ( (*((__int64 (__fastcall **)(__int64 (__fastcall **)()))*v48 + 6))(v48) )
        {
          sub_37E10(v47);
          v46[4] = sub_1B720((__int64)(v46 + 5));
        }
        else
        {
          sub_37F70(v47, v48, (__int64 (__fastcall **)())v46 + 5);
          v46[4] = (__int64)v47;
        }
        v49 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v4 + 216) + 24LL))(21LL);
        v50 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v49 + 96);
        v51 = v49;
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v49 + 96), *((_DWORD *)v46 + 2));
        sub_2ED90(v50, *((_DWORD *)v46 + 3));
        sub_614E0(*(_QWORD *)(v4 + 232), (__int64 *)(v51 + 64));
      }
      else
      {
        v8 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v4 + 216) + 24LL))(22LL);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v8 + 96), v6);
        v9 = (__int64 *)(v8 + 64);
        v7 = 1;
        sub_614E0(*(_QWORD *)(v4 + 232), v9);
      }
      return v7;
    default:
      return 0;
  }
}

signed __int64 __fastcall sub_442B0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 144) = a2;
  *(_QWORD *)(a1 - 152) = a1;
  *(_QWORD *)(a1 - 160) = off_31EE80;
  sub_1BD80((__int64)sub_43660, a1 - 192);
  return a1 - 192 + 32;
}

void *__fastcall sub_442F0(__int64 a1, char *a2, int a3, char *a4, int a5, int a6, char *a7, __int64 a8)
{
  __int64 v8; // rbp
  int v9; // er14
  int v10; // er13
  int v11; // er12
  char *src; // ST00_8
  void *v13; // rbx
  __int64 *v14; // rdi
  __int64 v15; // rax
  void (__fastcall **v16)(_QWORD, char *, signed __int64); // r13
  __int64 v17; // r12
  void **v19; // rdi
  __int64 v20; // [rsp+8h] [rbp-40h]

  v8 = a1;
  v9 = a3;
  v10 = a5;
  v11 = a6;
  src = a4;
  v20 = a1 - 192;
  v13 = sub_2F450(1uLL, 0x38uLL, 0LL);
  *((_QWORD *)v13 + 1) = sub_BC120(a2);
  *(_DWORD *)v13 = v9;
  *((_QWORD *)v13 + 2) = sub_BC120(src);
  *((_DWORD *)v13 + 1) = v10;
  *((_DWORD *)v13 + 6) = v11;
  *((_QWORD *)v13 + 4) = sub_BC120(a7);
  v14 = *(__int64 **)(a1 - 72);
  *((_QWORD *)v13 + 6) = a8;
  if ( (void *)sub_9AFD0(v14, (__int64)v13) == v13 )
  {
    v15 = (*(__int64 (__fastcall **)(signed __int64, void *))(**(_QWORD **)(v8 + 24) + 24LL))(28LL, v13);
    v16 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v15 + 96);
    v17 = v15;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v15 + 96), *(_DWORD *)v13);
    sub_2EF40(v16, *((char **)v13 + 2));
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v16, *((_DWORD *)v13 + 1));
    sub_614E0(*(_QWORD *)(v8 + 40), (__int64 *)(v17 + 64));
    sub_43710(v20, (__int64)sub_43BC0, (__int64)v13, 0);
  }
  else
  {
    v19 = (void **)v13;
    v13 = 0LL;
    sub_83CB0(v19);
  }
  return v13;
}

void __noreturn sub_44400()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh1connection-client.c",
    0x218u,
    "ssh1_serverside_x11_open");
}

void __noreturn sub_44430()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh1connection-client.c",
    0x21Du,
    "ssh1_serverside_agent_open");
}

__int64 __fastcall sub_44460(__int64 a1)
{
  return (*(unsigned int (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 288) + 136LL))(*(_QWORD *)(a1 + 288), 0LL) ^ 1;
}

void nullsub_21()
{
  ;
}

signed __int64 __fastcall sub_44490(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a1 + 12) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 12) > v2;
  return result;
}

signed __int64 __fastcall sub_444B0(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 12);
  if ( *a1 < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > v2;
  return result;
}

__int64 __fastcall sub_444D0(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 - 40) + 8LL);
}

void nullsub_22()
{
  ;
}

__int64 sub_444F0()
{
  return 0LL;
}

__int64 __fastcall sub_44500(__int64 a1, int a2)
{
  return *(unsigned __int8 *)(a1 + a2 - 127);
}

void __fastcall sub_44510(__int64 a1, int a2, char a3)
{
  *(_BYTE *)(a1 + a2 - 127) = a3;
}

void __fastcall sub_44520(__int64 a1)
{
  *(_BYTE *)(a1 - 104) = 1;
}

void __fastcall sub_44530(__int64 a1, char a2)
{
  *(_BYTE *)(a1 - 124) = a2;
  *(_BYTE *)(a1 - 55) = 1;
}

__int64 __fastcall sub_44540(__int64 a1)
{
  return *(unsigned __int8 *)(a1 - 140);
}

__int64 __fastcall sub_44550(__int64 a1, char a2)
{
  signed int v2; // ebx
  __int64 result; // rax

  v2 = 0;
  while ( 1 )
  {
    result = sub_9B010(*(__int64 **)(a1 - 168), v2);
    if ( !result )
      break;
    ++v2;
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(result + 32) + 40LL))(
      *(_QWORD *)(result + 32),
      (unsigned __int8)(a2 ^ 1));
  }
  return result;
}

void __fastcall sub_44590(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  if ( *(_BYTE *)(a1 - 11) )
  {
    if ( a2 <= 0x8000 )
    {
      v2 = *(_QWORD *)(a1 - 40);
      *(_BYTE *)(a1 - 11) = 0;
      sub_42860(*(_QWORD *)(v2 + 296), -1);
    }
  }
}

__int64 __fastcall sub_445D0(__int64 a1, int a2, int a3)
{
  bool v3; // zf
  __int64 result; // rax
  __int64 v5; // rdi

  *(_DWORD *)(a1 - 120) = a2;
  *(_DWORD *)(a1 - 116) = a3;
  v5 = *(_QWORD *)(a1 - 136);
  if ( v5 )
  {
    v3 = *(_BYTE *)(v5 + 39) == 0;
    *(_DWORD *)(v5 + 60) = a2;
    *(_DWORD *)(v5 + 64) = a3;
    if ( !v3 || *(_BYTE *)(v5 + 58) )
      result = (*(__int64 (**)(void))(**(_QWORD **)v5 + 152LL))();
  }
  return result;
}

__int64 __fastcall sub_445D0(__int64 a1, int a2, int a3)
{
  bool v3; // zf
  __int64 result; // rax
  __int64 v5; // rdi

  *(_DWORD *)(a1 - 120) = a2;
  *(_DWORD *)(a1 - 116) = a3;
  v5 = *(_QWORD *)(a1 - 136);
  if ( v5 )
  {
    v3 = *(_BYTE *)(v5 + 39) == 0;
    *(_DWORD *)(v5 + 60) = a2;
    *(_DWORD *)(v5 + 64) = a3;
    if ( !v3 || *(_BYTE *)(v5 + 58) )
      result = (*(__int64 (**)(void))(**(_QWORD **)v5 + 152LL))();
  }
  return result;
}

__int64 __fastcall sub_445D0(__int64 a1, int a2, int a3)
{
  bool v3; // zf
  __int64 result; // rax
  __int64 v5; // rdi

  *(_DWORD *)(a1 - 120) = a2;
  *(_DWORD *)(a1 - 116) = a3;
  v5 = *(_QWORD *)(a1 - 136);
  if ( v5 )
  {
    v3 = *(_BYTE *)(v5 + 39) == 0;
    *(_DWORD *)(v5 + 60) = a2;
    *(_DWORD *)(v5 + 64) = a3;
    if ( !v3 || *(_BYTE *)(v5 + 58) )
      result = (*(__int64 (**)(void))(**(_QWORD **)v5 + 152LL))();
  }
  return result;
}

__int64 __fastcall sub_44600(__int64 a1)
{
  __int64 result; // rax

  result = sub_1EF00(*(__int64 **)(a1 - 184), 30);
  if ( (_BYTE)result )
    result = sub_B3CE0();
  return result;
}

signed int *__fastcall sub_44630(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  signed int *result; // rax

  v3 = a3;
  result = sub_BE220(*(__int64 **)(a1 - 80), a2);
  *((_QWORD *)result + 7) = v3;
  return result;
}

__int64 *__usercall sub_44650@<rax>(__int64 a1@<rdi>, _QWORD *a2@<rsi>, char *a3@<r13>)
{
  __int64 *result; // rax
  bool v4; // zf

  sub_1ED50(*(_QWORD **)(a1 - 200));
  result = sub_1EED0(a2);
  v4 = *(_BYTE *)(a1 - 72) == 0;
  *(_QWORD *)(a1 - 200) = result;
  if ( !v4 )
    result = (__int64 *)sub_38070(*(_QWORD *)(a1 - 80), result, a3);
  return result;
}

void __fastcall sub_446A0(__int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  unsigned __int64 v3; // rdx

  while ( *(_QWORD *)(a1 - 152) )
  {
    if ( !sub_BCD00(*(_QWORD *)(a1 + 64)) )
      break;
    v1 = 512LL;
    v2 = sub_BCF00(*(_QWORD *)(a1 + 64));
    if ( v3 <= 0x200 )
      v1 = v3;
    (**(void (__fastcall ***)(__int64, _QWORD, __int64, unsigned __int64))(a1 - 176))(a1 - 208 + 32, 0LL, v2, v1);
    sub_BCE20(*(_QWORD *)(a1 + 64), v1);
  }
}

signed __int64 __fastcall sub_44730(__int64 a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax
  unsigned int v4; // edx

  v2 = strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16));
  if ( v2 )
    return (v2 >> 31) | 1u;
  v4 = *(_DWORD *)(a2 + 4);
  result = 1LL;
  if ( *(_DWORD *)(a1 + 4) <= v4 )
    result = (unsigned int)-(*(_DWORD *)(a1 + 4) < v4);
  return result;
}

void __fastcall sub_44780(__int64 a1, unsigned __int64 a2)
{
  if ( *(_BYTE *)(a1 - 125) )
  {
    if ( a2 <= 0x7FFF )
    {
      *(_BYTE *)(a1 - 125) = 0;
      sub_42860(*(_QWORD *)(a1 + 104), -1);
    }
  }
}

void __usercall sub_447B0(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  _QWORD *v4; // rdi
  __int64 v5; // rbp

  if ( (unsigned int)(a2 - 2) <= 1 )
  {
    if ( !(*(_BYTE *)(a1 + 96) & 1) )
    {
      v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 8) + 24LL))(32LL);
      sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 96), &locale);
      sub_614E0(*(_QWORD *)(a1 + 24), (__int64 *)(v5 + 64));
    }
  }
  else
  {
    v4 = *(_QWORD **)(a1 - 152);
    if ( v4 )
      sub_2E2F0(v4, a2, a3, a4);
  }
}

void (***__usercall sub_44820@<rax>(__int64 a1@<rdi>, void (****a2)(void)@<rsi>, __int64 a3@<r15>, char *a4@<rdx>))(void)
{
  char *v4; // r12
  void (****v5)(void); // rbx
  __int64 v6; // rax
  void *v7; // rbp
  char *v8; // rdx
  char *v9; // rsi
  void (***result)(void); // rax

  v4 = a4;
  v5 = a2;
  v6 = ((__int64 (*)(void))(**a2)[6])();
  if ( v6 )
  {
    v7 = (void *)v6;
    v8 = " ";
    if ( !v4 )
    {
      v4 = &locale;
      v8 = &locale;
    }
    v9 = sub_BC360((__int64)"%s%s%s", v6, v8, v4);
    sub_2D3A0(*(_QWORD *)(a1 + 280), v9, a1, a3);
    sub_2F4D0(v7);
  }
  (***v5)();
  result = (void (***)(void))sub_61860();
  *v5 = result;
  return result;
}

__int64 __fastcall sub_448B0(__int64 a1, __int64 a2, char *a3, unsigned __int64 a4)
{
  __int64 v4; // r12
  unsigned __int64 v5; // r15
  char *v6; // r14
  __int64 v7; // rax
  void (__fastcall **v8)(_QWORD, char *, signed __int64); // r13
  __int64 v9; // rbx

  v4 = *(_QWORD *)(a1 - 40);
  if ( *(_BYTE *)(a1 - 16) & 1 )
    __assert_fail("!(c->closes & CLOSES_SENT_CLOSE)", "ssh1connection.c", 0x26Cu, "ssh1channel_write");
  v5 = a4;
  v6 = a3;
  v7 = (*(__int64 (__fastcall **)(signed __int64, __int64))(**(_QWORD **)(v4 + 216) + 24LL))(23LL, a2);
  v8 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 96);
  v9 = v7;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v7 + 96), *(_DWORD *)(a1 - 32));
  sub_2EE80(v8, v6, v5);
  sub_614E0(*(_QWORD *)(v4 + 232), (__int64 *)(v9 + 64));
  return 0LL;
}

void __fastcall sub_44950(void (****a1)(void))
{
  void (****v1)(void); // rbx
  void (***v2)(void); // rdi

  v1 = a1;
  v2 = a1[4];
  if ( v2 )
    (**v2)();
  sub_2F4D0(v1);
}

void __usercall sub_44970(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  unsigned int v2; // esi
  __int64 v3; // rbp
  char v4; // al
  __int64 v5; // r12
  __int64 v6; // r12
  __int64 v7; // rbp

  if ( !*(_BYTE *)(a1 + 20) )
  {
    v2 = *(_DWORD *)(a1 + 24);
    v3 = *(_QWORD *)a1;
    if ( !(~*(_BYTE *)(a1 + 24) & 5)
      || (v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 56LL))(
                 *(_QWORD *)(a1 + 32),
                 v2 & 1,
                 (v2 >> 2) & 1),
          v2 = *(_DWORD *)(a1 + 24),
          v4) )
    {
      if ( !(v2 & 2) )
      {
        if ( !(v2 & 1) )
        {
          v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v3 + 216) + 24LL))(24LL);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 96), *(_DWORD *)(a1 + 8));
          sub_614E0(*(_QWORD *)(v3 + 232), (__int64 *)(v5 + 64));
          v2 = *(_DWORD *)(a1 + 24) | 1;
          *(_DWORD *)(a1 + 24) = v2;
        }
        if ( v2 & 4 )
        {
          v6 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v3 + 216) + 24LL))(25LL);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v6 + 96), *(_DWORD *)(a1 + 8));
          sub_614E0(*(_QWORD *)(v3 + 232), (__int64 *)(v6 + 64));
          v2 = *(_DWORD *)(a1 + 24) | 2;
          *(_DWORD *)(a1 + 24) = v2;
        }
      }
    }
    if ( !(~(_BYTE)v2 & 0xA) )
    {
      v7 = *(_QWORD *)a1;
      sub_44820(*(_QWORD *)a1, (void (****)(void))(a1 + 32), a2, 0LL);
      sub_9B440(*(__int64 **)(v7 + 24), a1);
      sub_44950((void (****)(void))a1);
      sub_1BD80((__int64)sub_45360, v7);
    }
  }
}

void __usercall sub_44A90(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 v2; // r12
  __int64 v3; // rax
  __int64 v4; // rbp

  v2 = *(_QWORD *)a1;
  if ( !*(_BYTE *)(a1 + 28) )
    __assert_fail("c->pending_eof", "ssh1connection.c", 0x1DFu, "ssh1_channel_try_eof");
  if ( !*(_BYTE *)(a1 + 20) )
  {
    v3 = *(_QWORD *)(v2 + 216);
    *(_BYTE *)(a1 + 28) = 0;
    v4 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v3 + 24LL))(24LL);
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v4 + 96), *(_DWORD *)(a1 + 8));
    sub_614E0(*(_QWORD *)(v2 + 232), (__int64 *)(v4 + 64));
    *(_DWORD *)(a1 + 24) |= 1u;
    sub_44970(a1, a2);
  }
}

void __usercall sub_44B20(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  if ( !(*(_BYTE *)(a1 - 16) & 1) )
  {
    *(_BYTE *)(a1 - 12) = 1;
    sub_44A90(a1 - 40, a2);
  }
}

void __usercall sub_44B40(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r15>)
{
  char *v3; // rbp

  v3 = 0LL;
  if ( a2 )
    v3 = sub_BC360((__int64)"due to local error: %s");
  sub_44820(*(_QWORD *)(a1 - 40), (void (****)(void))(a1 - 8), a3, v3);
  sub_2F4D0(v3);
  *(_BYTE *)(a1 - 12) = 0;
  sub_44970(a1 - 40, a3);
}

void __fastcall sub_44B90(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  void (****v3)(void); // rax
  void (__fastcall ***v4)(_QWORD, _QWORD); // rdi
  __int64 v5; // rdi
  __int64 v6; // rax
  void **v7; // rax
  __int64 v8; // rdi

  v1 = (void *)(a1 - 208);
  v2 = a1;
  sub_1ED50(*(_QWORD **)(a1 - 200));
  while ( 1 )
  {
    v3 = (void (****)(void))sub_9B400(*(__int64 **)(a1 - 184), 0);
    if ( !v3 )
      break;
    sub_44950(v3);
  }
  sub_9AF90(*(_QWORD ***)(a1 - 184));
  v4 = *(void (__fastcall ****)(_QWORD, _QWORD))(a1 - 160);
  if ( v4 )
    (**v4)(v4, 0LL);
  v5 = *(_QWORD *)(v2 - 112);
  if ( v5 )
    sub_BE9C0(v5);
  while ( 1 )
  {
    v6 = sub_9B400(*(__int64 **)(v2 - 96), 0);
    if ( !v6 )
      break;
    sub_BE420(v6);
  }
  sub_9AF90(*(_QWORD ***)(v2 - 96));
  while ( 1 )
  {
    v7 = (void **)sub_9B400(*(__int64 **)(v2 - 88), 0);
    if ( !v7 )
      break;
    sub_83CB0(v7);
  }
  sub_9AF90(*(_QWORD ***)(v2 - 88));
  sub_38040(*(_QWORD *)(v2 - 80));
  v8 = *(_QWORD *)(v2 - 40);
  if ( v8 )
    sub_31C50(v8);
  sub_1BCD0((__int64)v1);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_44C80(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // r13
  _QWORD *v4; // rax
  _QWORD *v5; // rbx

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x138uLL, 0LL);
  v5 = v4;
  *v4 = 0LL;
  v4[38] = 0LL;
  memset(
    (void *)((unsigned __int64)(v4 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v4 - (((_DWORD)v4 + 8) & 0xFFFFFFF8) + 312) >> 3));
  v4[26] = off_323F00;
  v4[1] = sub_1EED0(a2);
  v5[3] = sub_9AF60((__int64)sub_44490);
  v5[14] = sub_9AF60((__int64)sub_BE4A0);
  v5[25] = &off_323E40;
  v5[24] = sub_41EE0(a1);
  v5[16] = sub_37F90((__int64)(v5 + 24));
  v5[15] = sub_9AF60((__int64)sub_44730);
  *v3 = v5 + 24;
  return v5 + 26;
}

__int64 (__fastcall **__fastcall sub_44D70(__int64 (__fastcall ***a1)(), int a2, int a3))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_323F00;
  if ( *a1 != off_323F00 )
    __assert_fail("ppl->vt == &ssh1_connection_vtable", "ssh1connection.c", 0xCCu, "ssh1_connection_set_protoflags");
  *((_DWORD *)a1 - 48) = a2;
  *((_DWORD *)a1 - 47) = a3;
  return result;
}

__int64 __usercall sub_44DB0@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  unsigned int v3; // ebp
  __int64 v5; // rax

  v3 = *(unsigned __int8 *)(a1 + 69);
  if ( !(_BYTE)v3 || (unsigned int)sub_9AFB0(*(__int64 **)(a1 + 24)) )
    return 0LL;
  v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 216) + 24LL))(33LL);
  sub_614E0(*(_QWORD *)(a1 + 232), (__int64 *)(v5 + 64));
  sub_42660(*(_QWORD *)(a1 + 296), (__int64)"Session finished", a2, a3);
  return v3;
}

__int64 __usercall sub_44E20@<rax>(_QWORD *a1@<rdi>, int *a2@<r15>)
{
  _QWORD *v2; // r12
  _QWORD *v3; // rbx
  unsigned int v4; // ebp
  unsigned int *v5; // rax
  int v6; // eax
  __int64 *v7; // rdi
  __int64 v8; // r14
  char v9; // dl
  int v10; // eax
  __int64 v11; // rdi
  char *v13; // rax
  __int64 v14; // rdx
  signed int v15; // eax
  __int64 v16; // rdi
  int v17; // eax
  __int64 v18; // rdi
  int v19; // eax
  __int64 v20; // rdx
  int v21; // [rsp+14h] [rbp-44h]
  unsigned __int64 v22; // [rsp+18h] [rbp-40h]

  v2 = a1 + 26;
  v3 = a1;
  v22 = __readfsqword(0x28u);
  do
  {
    v4 = (unsigned __int64)sub_62AB0(v2, (__int64)off_E9300, (__int64)a2);
    if ( (_BYTE)v4 )
      break;
    while ( 1 )
    {
      v5 = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(v3[28] + 48LL))(v3[28], v3[28], 0LL);
      a2 = (int *)v5;
      if ( !v5 )
        return v4;
      if ( *v5 - 21 > 4 )
        break;
      v6 = sub_2F150((__int64)(v5 + 12));
      v7 = (__int64 *)v3[3];
      v21 = v6;
      v8 = sub_9B3D0(v7, (__int64)&v21, (__int64 (__fastcall *)(__int64))sub_444B0);
      if ( !v8 || (v9 = *(_BYTE *)(v8 + 20), v9 != (unsigned int)(*a2 - 21) <= 1) )
      {
        sub_61F60(*a2);
        sub_42140(v3[37], (__int64)"Received %s for %s channel %u", (__int64)off_E9300, (__int64)a2);
        return 1;
      }
      switch ( *a2 )
      {
        case 21:
          if ( !v9 )
            __assert_fail("c->halfopen", "ssh1connection.c", 0xFFu, "ssh1_connection_filter_queue");
          v17 = sub_2F150((__int64)(a2 + 12));
          v18 = *(_QWORD *)(v8 + 32);
          *(_DWORD *)(v8 + 8) = v17;
          *(_BYTE *)(v8 + 20) = 0;
          *(_BYTE *)(v8 + 29) = 0;
          (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v18 + 8LL))(v18, &v21);
          sub_44970(v8, (__int64)a2);
          if ( *(_BYTE *)(v8 + 28) )
            sub_44A90(v8, (__int64)a2);
          goto LABEL_10;
        case 22:
          if ( !v9 )
            __assert_fail("c->halfopen", "ssh1connection.c", 0x11Cu, "ssh1_connection_filter_queue");
          (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v8 + 32) + 16LL))(*(_QWORD *)(v8 + 32), 0LL);
          (***(void (****)(void))(v8 + 32))();
          sub_9B440((__int64 *)v3[3], v8);
          sub_44950((void (****)(void))v8);
          goto LABEL_10;
        case 23:
          v13 = sub_2F1D0((__int64)(a2 + 12));
          if ( !a2[18] )
          {
            v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *, __int64))(**(_QWORD **)(v8 + 32) + 24LL))(
                    *(_QWORD *)(v8 + 32),
                    0LL,
                    v13,
                    v14);
            if ( *(_BYTE *)(v8 + 29) != 1 && v15 > 0x8000 )
            {
              v16 = v3[37];
              *(_BYTE *)(v8 + 29) = 1;
              sub_42860(v16, 1);
            }
          }
          goto LABEL_10;
        case 24:
          v10 = *(_DWORD *)(v8 + 24);
          if ( !(v10 & 4) )
          {
            v11 = *(_QWORD *)(v8 + 32);
            *(_DWORD *)(v8 + 24) = v10 | 4;
            (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 32LL))(v11, &v21);
            sub_44970(v8, (__int64)a2);
          }
          goto LABEL_10;
        case 25:
          v19 = *(_DWORD *)(v8 + 24);
          if ( v19 & 8 )
            goto LABEL_10;
          if ( !(v19 & 1) )
          {
            v20 = *(unsigned int *)(v8 + 12);
            v4 = 1;
            sub_42140(
              v3[37],
              (__int64)"Received CHANNEL_CLOSE_CONFIRMATION for channel %u for which we never sent CHANNEL_CLOSE\n",
              (__int64)off_E9300,
              (__int64)a2);
            return v4;
          }
          *(_DWORD *)(v8 + 24) = v19 | 8;
          sub_44970(v8, (__int64)a2);
LABEL_10:
          (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(v3[28] + 48LL))(v3[28], v3[28], 1LL);
          v4 = (unsigned __int64)sub_62AB0(v2, (__int64)off_E9300, (__int64)a2);
          if ( (_BYTE)v4 )
            return 1;
          break;
        default:
          goto LABEL_10;
      }
    }
    if ( !(unsigned __int8)sub_43CD0((__int64)v3, v5, (__int64)off_E9300, (__int64)v5) )
      return v4;
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(v3[28] + 48LL))(v3[28], v3[28], 1LL);
  }
  while ( !(unsigned __int8)sub_44DB0((__int64)v3, (__int64)off_E9300, (__int64)a2) );
  return 1;
}

void __usercall sub_45190(__int64 a1@<rdi>, char *a2@<r13>, __int64 a3@<r15>)
{
  _QWORD *v3; // rbp
  signed int v4; // eax
  int v5; // eax
  int *v6; // rax
  int *v7; // rbp
  __int64 v8; // rdx
  _QWORD *v9; // rax
  char *v10; // rax

  v3 = (_QWORD *)(a1 - 208);
  if ( !(unsigned __int8)sub_44E20((_QWORD *)(a1 - 208), (int *)a3) )
  {
    v4 = *(_DWORD *)(a1 - 208);
    if ( v4 == 392 )
    {
      *(_BYTE *)(a1 - 140) = 0;
      v5 = *(_DWORD *)(a1 - 32);
      goto LABEL_11;
    }
    if ( v4 > 392 )
    {
      if ( v4 != 404 )
      {
        if ( v4 != 421 )
        {
LABEL_6:
          *(_DWORD *)(a1 - 208) = 0;
          return;
        }
LABEL_15:
        sub_44E20(v3, (int *)a3);
        v6 = (int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 16) + 48LL))(
                      *(_QWORD *)(a1 + 16),
                      *(_QWORD *)(a1 + 16),
                      1LL);
        v7 = v6;
        if ( v6 )
        {
          sub_61F60(*v6);
          v8 = (unsigned int)*v7;
          sub_423C0(*(_QWORD *)(a1 + 88), (__int64)"Unexpected packet received, type %d (%s)", (__int64)a2, a3);
        }
        else
        {
          *(_DWORD *)(a1 - 208) = 421;
        }
        return;
      }
LABEL_14:
      if ( !*(_BYTE *)(a1 - 71) )
      {
        sub_43C80((__int64)v3);
        *(_DWORD *)(a1 - 208) = 404;
        return;
      }
      goto LABEL_15;
    }
    if ( v4 )
      goto LABEL_6;
    if ( !(unsigned __int8)sub_44460((__int64)v3) )
    {
LABEL_13:
      sub_38070(*(_QWORD *)(a1 - 80), *(__int64 **)(a1 - 200), a2);
      *(_BYTE *)(a1 - 72) = 1;
      goto LABEL_14;
    }
    v9 = sub_31B10();
    *(_QWORD *)(a1 - 40) = v9;
    *(_BYTE *)v9 = 1;
    *((_BYTE *)v9 + 1) = 0;
    v9[1] = sub_BC120("Authentication successful");
    v10 = sub_BC120("Access granted. Press Return to begin session. ");
    sub_31B70(*(_QWORD **)(a1 - 40), (__int64)v10, 0);
    v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 80) + 16LL))(
           *(_QWORD *)(a1 + 80),
           *(_QWORD *)(a1 - 40),
           0LL);
    for ( *(_DWORD *)(a1 - 32) = v5; ; *(_DWORD *)(a1 - 32) = v5 )
    {
LABEL_11:
      if ( v5 >= 0 )
        goto LABEL_12;
      if ( !sub_BCD00(*(_QWORD *)(a1 + 64)) )
        break;
      v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 80) + 16LL))(
             *(_QWORD *)(a1 + 80),
             *(_QWORD *)(a1 - 40),
             *(_QWORD *)(a1 + 64));
    }
    if ( *(_DWORD *)(a1 - 32) >= 0 )
    {
LABEL_12:
      sub_31C50(*(_QWORD *)(a1 - 40));
      *(_QWORD *)(a1 - 40) = 0LL;
      goto LABEL_13;
    }
    *(_BYTE *)(a1 - 140) = 1;
    *(_DWORD *)(a1 - 208) = 392;
  }
}

__int64 __usercall sub_45360@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  return sub_44DB0(a1, a2, a3);
}

__int64 __fastcall sub_45370(__int64 *a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rbp
  int v3; // eax
  __int64 *v4; // rdi

  v1 = a1;
  v2 = *a1;
  a1[5] = (__int64)off_31EF40;
  *((_DWORD *)a1 + 6) = 0;
  *((_BYTE *)a1 + 28) = 0;
  *((_BYTE *)a1 + 29) = 0;
  a1[6] = v2 + 192;
  v3 = sub_61DD0(*(_QWORD *)(v2 + 24), 12LL);
  v4 = *(__int64 **)(v2 + 24);
  *((_DWORD *)v1 + 3) = v3;
  return sub_9AFD0(v4, (__int64)v1);
}

__int64 *__fastcall sub_453D0(__int64 a1, char *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v6; // r15
  __int64 v7; // r13
  __int64 v8; // r14
  __int64 v9; // rbp
  __int64 *v10; // rax
  __int64 *v11; // rbx
  char *v12; // rsi
  __int64 v13; // rax
  void (__fastcall **v14)(_QWORD, char *, signed __int64); // r14
  __int64 v15; // rbp

  v6 = a2;
  v7 = a3;
  v8 = a6;
  v9 = a4;
  v10 = (__int64 *)sub_2F450(1uLL, 0x38uLL, 0LL);
  v11 = v10;
  *v10 = a1 - 192;
  sub_45370(v10);
  v11[4] = v8;
  *((_BYTE *)v11 + 20) = 1;
  v12 = sub_BC360((__int64)"Opening connection to %s:%d for %s", a2, (unsigned int)v7, v9);
  sub_2D3A0(*(_QWORD *)(a1 + 88), v12, v7, (__int64)v6);
  v13 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(a1 + 24) + 24LL))(29LL, v12);
  v14 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v13 + 96);
  v15 = v13;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v13 + 96), *((_DWORD *)v11 + 3));
  sub_2EF40(v14, v6);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, v7);
  sub_614E0(*(_QWORD *)(a1 + 40), (__int64 *)(v15 + 64));
  return v11 + 5;
}

__int64 __fastcall sub_454A0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 384) = a2;
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 568) + 8LL))(a1 + 568);
}

__int64 __fastcall sub_454C0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 - 24);
}

__int64 __fastcall sub_454D0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 560) + 48LL))();
}

_QWORD *__fastcall sub_454E0(__int64 a1)
{
  _QWORD *result; // rax

  if ( *(_BYTE *)(a1 - 24) )
    result = sub_1BE20(a1 + 32);
  return result;
}

_QWORD *__fastcall sub_45500(_QWORD *a1, __int64 a2, int a3)
{
  a1[11] = 0LL;
  a1[26] = a2;
  a1[27] = a2;
  a1[28] = a3;
  return sub_1BE20((__int64)(a1 + 75));
}

__int64 __usercall sub_45530@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 result; // rax

  if ( (unsigned __int8)sub_62AB0((_QWORD *)(a1 + 568), a2, a3) )
    result = 0LL;
  else
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 584) + 48LL))(
               *(_QWORD *)(a1 + 584),
               *(_QWORD *)(a1 + 584),
               1LL);
  return result;
}

unsigned __int64 __fastcall sub_45570(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  void *v3; // rdi
  __int64 v4; // rax
  __int64 v6; // rax
  int v7; // [rsp+Ch] [rbp-2Ch]
  __int64 v8; // [rsp+10h] [rbp-28h]
  unsigned __int64 v9; // [rsp+18h] [rbp-20h]

  v2 = a1;
  v3 = (void *)a1[26];
  v9 = __readfsqword(0x28u);
  sub_2F4D0(v3);
  v2[26] = 0LL;
  v4 = sub_B3E40((_QWORD *)a2, &v8, &v7, (__int64)sub_45500, (__int64)v2);
  v2[11] = v4;
  if ( !v4 )
  {
    v6 = v8;
    v2[26] = v8;
    v2[27] = v6;
    v2[28] = v7;
    sub_1BE20((__int64)(v2 + 75));
  }
  return __readfsqword(0x28u) ^ v9;
}

void __fastcall sub_45620(__int64 a1)
{
  __int64 v1; // rax

  if ( !*(_BYTE *)(a1 + 560) )
  {
    v1 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(**(_QWORD **)(a1 + 648) + 128LL))(
           *(_QWORD *)(a1 + 648),
           0LL,
           1LL);
    *(_QWORD *)(a1 + 552) = v1;
    if ( v1 )
      sub_87B00(v1);
    *(_BYTE *)(a1 + 560) = 1;
  }
}

void __fastcall sub_45670(__int64 a1)
{
  void *v1; // r13
  __int64 v2; // rbx
  __int64 (***v3)(void); // rdi
  void **v4; // rdi
  __int64 v5; // rdi
  char *v6; // rdi
  __int64 v7; // rbp
  unsigned __int64 v8; // r12
  void **v9; // rdi
  int *v10; // rdi

  v1 = (void *)(a1 - 568);
  v2 = a1;
  v3 = *(__int64 (****)(void))(a1 - 560);
  if ( v3 )
    sub_62630(v3);
  sub_1ED50(*(_QWORD **)(v2 - 552));
  sub_2F4D0(*(void **)(v2 - 544));
  sub_2F4D0(*(void **)(v2 - 464));
  sub_2F4D0(*(void **)(v2 - 488));
  v4 = *(void ***)(v2 - 408);
  if ( v4 )
    sub_BC660(v4);
  sub_2F4D0(*(void **)(v2 - 400));
  v5 = *(_QWORD *)(v2 - 384);
  if ( v5 )
    sub_31C50(v5);
  v6 = *(char **)(v2 - 288);
  if ( v6 )
  {
    if ( *(_QWORD *)(v2 - 296) )
    {
      v7 = 0LL;
      v8 = 0LL;
      do
      {
        ++v8;
        sub_7D770(&v6[v7]);
        v9 = *(void ***)(*(_QWORD *)(v2 - 288) + v7 + 72);
        v7 += 96LL;
        sub_BC660(v9);
        v6 = *(char **)(v2 - 288);
      }
      while ( *(_QWORD *)(v2 - 296) > v8 );
    }
    sub_2F4D0(v6);
  }
  sub_2F4D0(*(void **)(v2 - 360));
  v10 = *(int **)(v2 - 480);
  if ( v10 )
    sub_B3D10(v10);
  sub_2F4D0(v1);
}

unsigned __int64 __usercall sub_45780@<rax>(__int64 a1@<rdi>, signed __int64 a2@<rsi>, char *a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // r14
  unsigned int *v5; // rbx
  signed int v6; // eax
  int *v7; // rax
  int v8; // edi
  __int64 v9; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v11; // rt1
  _DWORD *v12; // rax
  _DWORD *v13; // rbp
  char *v14; // rax
  unsigned __int64 v15; // rsi
  __int64 v16; // rax
  char *v17; // rsi
  char *v18; // rax
  signed __int64 v19; // rsi
  int v20; // er12
  __int64 v21; // rbp
  int *v22; // rax
  int *v23; // rbp
  int v24; // edi
  __int64 v25; // rdx
  int *v26; // rax
  int v27; // edi
  int i; // eax
  char *v29; // rax
  _QWORD *v30; // rsi
  int v31; // eax
  int v32; // eax
  __int64 v33; // rax
  __int64 (**v34)(void); // rbp
  __int64 v35; // r12
  __int64 v36; // rdx
  __int64 v37; // rsi
  char *v38; // rsi
  __int64 v39; // rdi
  int v40; // eax
  _DWORD *v41; // rax
  _DWORD *v42; // rax
  __int64 v43; // rbp
  char *v44; // rax
  char *v45; // rsi
  int *v46; // rax
  int *v47; // rbp
  int v48; // edi
  char *v49; // rsi
  bool v50; // zf
  char *v51; // rax
  __int64 v52; // rbp
  __int64 v53; // rdx
  __int64 v54; // rax
  const char *v55; // rdi
  char *v56; // rax
  void *v57; // r12
  int v58; // er9
  __int64 v59; // r12
  unsigned __int64 v60; // rax
  char *v61; // rax
  char v62; // bp
  char *v63; // rax
  char *v64; // rdi
  __int64 v65; // rax
  __int64 (**v66)(void); // rbp
  void **v67; // r12
  _BYTE *v68; // rbp
  char *v69; // rax
  char *v70; // rax
  __int64 v71; // rdi
  __int64 v72; // rbp
  char *v73; // rsi
  char *v74; // rax
  int *v75; // rbp
  __int64 *v76; // rdi
  _BYTE **v77; // rax
  char v78; // al
  int v79; // eax
  _DWORD *v80; // rax
  const char *v81; // rdi
  char *v82; // rax
  int *v83; // rax
  int *v84; // rbp
  int v85; // edi
  __int64 v86; // rdx
  char *v87; // rsi
  int *v88; // rax
  char *v89; // rax
  unsigned __int64 v90; // rdx
  unsigned __int64 v91; // r12
  char *v92; // rax
  __int64 v93; // rbp
  __int64 v94; // rax
  __int64 (**v95)(void); // rbp
  __int64 v96; // rdi
  __int64 v97; // rbp
  char *v98; // rdi
  char *v99; // rax
  int v100; // eax
  int v101; // eax
  char *v102; // rax
  char *v103; // rax
  size_t v104; // rdx
  int v105; // er11
  __int64 v106; // rax
  int v107; // er10
  signed int v108; // eax
  signed int v109; // edx
  void **v110; // rax
  void **v111; // rbp
  int v112; // eax
  __int64 v113; // rbp
  __int64 v114; // rax
  char *v115; // rax
  _QWORD *v116; // rax
  __int64 *v117; // rdi
  char *v118; // rsi
  __int64 v119; // rax
  char *v120; // rax
  int v121; // eax
  int v122; // er12
  char *v123; // rax
  char *v124; // rax
  char *v125; // r12
  __int64 v126; // rax
  char *v127; // rax
  char *v128; // rsi
  char *v129; // rax
  _QWORD *v130; // rax
  char *v131; // rax
  char *v132; // rsi
  __int64 v133; // rbp
  unsigned __int64 *v134; // rax
  unsigned __int64 *v135; // r12
  __int64 v136; // rsi
  signed __int64 v137; // rax
  __int64 (***v138)(void); // r13
  __int64 v139; // rdx
  char *v140; // rsi
  char *v141; // rbp
  __int64 v142; // rdi
  __int64 v143; // rdx
  char *v144; // rsi
  char *v145; // rax
  char *v146; // rsi
  unsigned __int64 v147; // rdx
  unsigned __int64 v148; // r12
  char *v149; // rax
  __int64 v150; // rbp
  __int64 v151; // rax
  __int64 (**v152)(void); // rbp
  __int64 v153; // rdi
  __int64 v154; // rbp
  signed __int64 v155; // rax
  __int64 v156; // rdi
  signed __int64 v157; // rsi
  char *v158; // rax
  void *v159; // ST30_8
  char *v160; // rax
  char *v161; // rax
  const char *v162; // rdi
  char *v163; // rsi
  const char *v164; // rdi
  char v165; // r12
  char *v166; // rax
  signed __int64 v167; // rax
  signed __int64 v168; // rax
  bool v169; // dl
  bool v170; // al
  int v171; // eax
  char *v172; // rsi
  char *v173; // rsi
  char *v174; // rsi
  char *v175; // rsi
  __int64 v176; // rax
  __int64 v177; // rbp
  unsigned int v178; // eax
  char *v179; // rax
  __int64 v180; // r12
  __int64 v181; // rdi
  unsigned __int64 v182; // rbp
  char *v183; // rsi
  __int64 v184; // rbp
  char *v185; // rax
  char *v186; // rax
  __int64 v187; // r12
  __int64 v188; // rax
  char *v189; // rax
  int v190; // eax
  char *v191; // rsi
  __int64 v192; // r12
  const char *v193; // rax
  unsigned __int64 v194; // rbp
  char *v195; // rax
  __int64 v196; // rbp
  char *v197; // rax
  __int64 v198; // rdx
  __int64 v199; // rsi
  char *v200; // rax
  __int64 v201; // rdi
  char *v202; // rsi
  __int64 v203; // r12
  char *v204; // rax
  signed __int64 v205; // rcx
  __int64 v206; // rax
  signed __int64 v207; // ST38_8
  _QWORD *v208; // rdi
  __int64 v209; // ST30_8
  __int64 v210; // r13
  __int64 v211; // ST28_8
  signed __int64 v212; // rax
  __int64 v213; // rdi
  __int64 v214; // rdx
  char *v215; // rax
  __int64 v216; // rax
  unsigned __int64 v217; // r12
  char *v218; // rsi
  char *v219; // rax
  char *v220; // rsi
  __int64 v221; // rdi
  signed int v222; // eax
  unsigned __int64 v223; // kr08_8
  signed int v224; // er12
  unsigned __int64 v225; // rbp
  char *v226; // rax
  char *v227; // rax
  __int64 v228; // ST30_8
  char *v229; // rsi
  _BYTE *v230; // rax
  _BYTE *v231; // rbp
  char *v232; // rax
  __int64 v233; // rsi
  char *v234; // rax
  char *v235; // rax
  unsigned __int64 *v236; // [rsp+8h] [rbp-90h]
  char *v237; // [rsp+18h] [rbp-80h]
  __int64 v238; // [rsp+28h] [rbp-70h]
  char v239[40]; // [rsp+30h] [rbp-68h]
  unsigned __int64 v240; // [rsp+58h] [rbp-40h]

  v4 = a1;
  v5 = (unsigned int *)(a1 - 568);
  v240 = __readfsqword(0x28u);
  if ( (unsigned __int8)sub_62AB0((_QWORD *)a1, (__int64)a3, a4) )
    goto LABEL_14;
  v6 = *(_DWORD *)(a1 - 568);
  if ( v6 == 637 )
    goto LABEL_110;
  if ( v6 > 637 )
  {
    if ( v6 == 859 )
      goto LABEL_148;
    if ( v6 <= 859 )
    {
      if ( v6 == 729 )
      {
        *(_BYTE *)(a1 - 24) = 0;
        goto LABEL_169;
      }
      if ( v6 <= 729 )
      {
        if ( v6 == 653 )
          goto LABEL_139;
      }
      else
      {
        if ( v6 == 777 )
          goto LABEL_40;
        if ( v6 == 827 )
          goto LABEL_48;
      }
    }
    else
    {
      if ( v6 == 992 )
      {
        *(_BYTE *)(a1 - 24) = 0;
        v100 = *(_DWORD *)(a1 - 376);
        goto LABEL_160;
      }
      if ( v6 <= 992 )
      {
        if ( v6 == 914 )
          goto LABEL_143;
      }
      else
      {
        if ( v6 == 1116 )
          goto LABEL_83;
        if ( v6 == 1143 )
        {
LABEL_10:
          v7 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
          v5 = (unsigned int *)v7;
          if ( v7 )
          {
            v8 = *v7;
            if ( *v7 == 14 )
              goto LABEL_56;
            if ( v8 == 15 )
            {
              v144 = sub_BC360((__int64)"Server refused to enable compression", a2);
              sub_2D3A0(*(_QWORD *)(v4 + 72), v144, (__int64)a3, a4);
              v145 = sub_BC360((__int64)"Server refused to compress\r\n", v144);
              sub_62710(v4, v145);
LABEL_56:
              sub_44D70(*(__int64 (__fastcall ****)())(v4 - 560), *(_DWORD *)(v4 - 524), *(_DWORD *)(v4 - 528));
              v30 = *(_QWORD **)(v4 - 560);
              *(_QWORD *)(v4 - 560) = 0LL;
              sub_626A0(v4, v30);
            }
            else
            {
              sub_61F60(v8);
              v9 = *v5;
              sub_423C0(
                *(_QWORD *)(v4 + 88),
                (__int64)"Received unexpected packet in response to compression request, type %d (%s)",
                (__int64)a3,
                a4);
            }
          }
          goto LABEL_14;
        }
      }
    }
LABEL_166:
    *(_DWORD *)(a1 - 568) = 0;
    goto LABEL_14;
  }
  if ( v6 == 397 )
    goto LABEL_71;
  if ( v6 <= 397 )
  {
    if ( v6 != 175 )
    {
      if ( v6 > 175 )
      {
        if ( v6 != 271 )
        {
          if ( v6 != 348 )
            goto LABEL_166;
          v31 = *(_DWORD *)(a1 - 184);
          goto LABEL_62;
        }
        goto LABEL_96;
      }
      if ( v6 )
        goto LABEL_166;
      *(_DWORD *)(a1 - 568) = 175;
    }
    v42 = (_DWORD *)sub_45530(a1 - 568, (__int64)a3, a4);
    a4 = (__int64)v42;
    if ( !v42 )
      goto LABEL_14;
    if ( *v42 != 2 )
    {
      sub_423C0(*(_QWORD *)(a1 + 88), (__int64)"Public key packet not received", (__int64)a3, (__int64)v42);
      goto LABEL_14;
    }
    v59 = (__int64)(v5 + 100);
    a3 = (char *)(v5 + 118);
    v102 = sub_BC360((__int64)"Received public keys", a2);
    sub_2D3A0(*(_QWORD *)(a1 + 72), v102, (__int64)(v5 + 118), a4);
    v103 = sub_2F040(a4 + 48, 8uLL);
    memcpy(v5 + 33, v103, v104);
    sub_7CCA0(a4 + 48, (__int64)(v5 + 100), 0);
    sub_7CCA0(a4 + 48, (__int64)(v5 + 118), 0);
    v105 = *(_DWORD *)(a4 + 72);
    *(_QWORD *)(a1 - 40) = 0LL;
    if ( !v105 )
    {
      v159 = (void *)sub_7D260((__int64)(v5 + 118));
      v160 = sub_BC360((__int64)"Host key fingerprint is:", v5 + 118);
      sub_2D3A0(*(_QWORD *)(a1 + 72), v160, (__int64)a3, a4);
      v161 = sub_BC360((__int64)"      %s", v159);
      sub_2D3A0(*(_QWORD *)(a1 + 72), v161, (__int64)a3, a4);
      sub_2F4D0(v159);
    }
    *(_DWORD *)(a1 - 528) = sub_2F150(a4 + 48);
    *(_QWORD *)(a1 - 456) = sub_2F150(a4 + 48);
    v106 = sub_2F150(a4 + 48);
    v107 = *(_DWORD *)(a4 + 72);
    *(_QWORD *)(a1 - 448) = v106;
    if ( v107 )
    {
      sub_423C0(*(_QWORD *)(a1 + 88), (__int64)"Bad SSH-1 public key packet", (__int64)a3, a4);
      goto LABEL_14;
    }
    if ( *(_BYTE *)(a1 + 96) & 8 )
      *(_QWORD *)(a1 - 448) = v106 & 0xFFFFFFFFFFFFFFFBLL;
    *(_DWORD *)(a1 - 524) = 1;
    sub_62B70((__int64)(v5 + 35), (__int64)(v5 + 33), (__int64)(v5 + 118), (__int64)(v5 + 100));
    sub_7BF50((char *)v5 + 48, 0x20uLL);
    v108 = *(_DWORD *)(a1 - 92);
    if ( *(_DWORD *)(a1 - 96) > 8 * v108 || (v109 = *(_DWORD *)(a1 - 164), *(_DWORD *)(a1 - 168) > 8 * v109) )
    {
      sub_423C0(*(_QWORD *)(a1 + 88), (__int64)"SSH-1 public keys were badly formatted", (__int64)a3, a4);
      goto LABEL_14;
    }
    if ( v108 > 32 )
    {
      *(_DWORD *)(a1 - 472) = v108;
    }
    else
    {
      *(_DWORD *)(a1 - 472) = 32;
      v108 = 32;
    }
    if ( v109 > v108 )
    {
      *(_DWORD *)(a1 - 472) = v109;
      v108 = v109;
    }
    *(_QWORD *)(a1 - 464) = sub_2F450(v108, 1uLL, 0LL);
    a4 = sub_7D210((__int64)(v5 + 118), 1LL);
    v110 = (void **)sub_7D400((__int64)(v5 + 118));
    v111 = v110;
    v112 = sub_628E0(*(__int64 **)(a1 - 552), (__int64)v110, 0LL);
    *(_DWORD *)(a1 - 184) = v112;
    if ( !v112 )
    {
      sub_7BAB0(v111);
      sub_2F4D0((void *)a4);
      sub_423C0(*(_QWORD *)(a1 + 88), (__int64)"Host key did not appear in manually configured list", (__int64)a3, a4);
      goto LABEL_14;
    }
    if ( v112 >= 0 )
    {
      sub_7BAB0(v111);
      sub_2F4D0((void *)a4);
LABEL_99:
      v60 = 0LL;
      do
      {
        *(_BYTE *)(*(_QWORD *)(a1 - 464) + v60) = *(_BYTE *)(a1 + v60 - 520);
        if ( v60 <= 0xF )
          *(_BYTE *)(v60 + *(_QWORD *)(a1 - 464)) ^= *(_BYTE *)(a1 + v60 - 428);
        ++v60;
      }
      while ( v60 != 32 );
      if ( *(_DWORD *)(a1 - 92) <= *(_DWORD *)(a1 - 164) )
      {
        v61 = a3;
        a3 = (char *)v59;
        v59 = (__int64)v61;
      }
      if ( !(unsigned __int8)sub_7CEC0(*(void **)(a1 - 464), 32, v59)
        || (v62 = sub_7CEC0(*(void **)(a1 - 464), *(_DWORD *)(v59 + 4), (__int64)a3)) == 0 )
      {
        sub_423C0(
          *(_QWORD *)(a1 + 88),
          (__int64)"SSH-1 public key encryptions failed due to bad formatting",
          (__int64)a3,
          a4);
        goto LABEL_14;
      }
      v165 = 0;
      a4 = 0LL;
      a3 = 0LL;
      v166 = sub_BC360((__int64)"Encrypted session key");
      sub_2D3A0(*(_QWORD *)(a1 + 72), v166, 0LL, 0LL);
      do
      {
        a2 = 32LL;
        v171 = sub_1F0A0(*(__int64 **)(a1 - 552), 32, a4);
        if ( v171 )
        {
          if ( v171 == 3 )
          {
            a2 = (signed __int64)sub_BC360((__int64)"AES not supported in SSH-1, skipping", 32LL);
            sub_2D3A0(*(_QWORD *)(a1 + 72), (char *)a2, (__int64)a3, a4);
            v170 = v62;
            v169 = 0;
          }
          else
          {
            switch ( v171 )
            {
              case 2:
                *(_DWORD *)(a1 - 412) = 6;
                v167 = 64LL;
                a3 = "Blowfish";
                break;
              case 4:
                *(_DWORD *)(a1 - 412) = 2;
                v167 = 4LL;
                a3 = "single-DES";
                break;
              case 1:
                *(_DWORD *)(a1 - 412) = 3;
                v167 = 8LL;
                a3 = "3DES";
                break;
              default:
                v167 = 1 << *(_DWORD *)(a1 - 412);
                break;
            }
            v168 = *(_QWORD *)(a1 - 456) & v167;
            v169 = v168 != 0;
            v170 = v168 == 0;
          }
        }
        else
        {
          v170 = v62;
          v165 = v62;
          v169 = 0;
        }
        a4 = (unsigned int)(a4 + 1);
      }
      while ( (signed int)a4 <= 6 && v170 );
      if ( !v169 )
      {
        v201 = *(_QWORD *)(a1 + 88);
        if ( *(_BYTE *)(v4 - 456) & 8 )
          sub_42500(v201, (__int64)"No supported ciphers found", (__int64)a3, a4);
        else
          sub_423C0(v201, (__int64)"Server violates SSH-1 protocol by not supporting 3DES encryption", (__int64)a3, a4);
        goto LABEL_14;
      }
      if ( !v165 )
      {
LABEL_64:
        v32 = *(_DWORD *)(a1 - 412);
        switch ( v32 )
        {
          case 3:
            v164 = "Using 3DES encryption";
            break;
          case 6:
            v164 = "Using Blowfish encryption";
            break;
          case 2:
            v164 = "Using single-DES encryption";
            break;
          default:
            goto LABEL_67;
        }
        a2 = (signed __int64)sub_BC360((__int64)v164, a2);
        sub_2D3A0(*(_QWORD *)(v4 + 72), (char *)a2, (__int64)a3, a4);
LABEL_67:
        v33 = (*(__int64 (__fastcall **)(signed __int64, signed __int64))(**(_QWORD **)(v4 + 8) + 24LL))(3LL, a2);
        v34 = (__int64 (**)(void))(v33 + 96);
        v35 = v33;
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v33 + 96), *(_BYTE *)(v4 - 412));
        sub_2EC20(v34);
        sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v34, 8 * *(_WORD *)(v4 - 472));
        v36 = *(signed int *)(v4 - 472);
        v37 = *(_QWORD *)(v4 - 464);
        sub_2EC20(v34);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v34, *(_DWORD *)(v4 - 524));
        sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v35 + 64));
        v38 = sub_BC360((__int64)"Trying to enable encryption...", v35 + 64);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v38, (__int64)a3, a4);
        sub_2F4D0(*(void **)(v4 - 464));
        v39 = *(_QWORD *)(v4 + 8);
        *(_QWORD *)(v4 - 464) = 0LL;
        (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v39 + 16LL))(v39, v38);
        v40 = *(_DWORD *)(v4 - 412);
        a2 = (signed __int64)off_31FE40;
        if ( v40 != 6 )
        {
          a2 = (signed __int64)off_320320;
          if ( v40 == 2 )
            a2 = (signed __int64)off_320560;
        }
        sub_42D10((__int64)(v5 + 12), *(__int64 (__fastcall ****)())(v4 + 8), a2, (__int64)a3, a4);
        sub_7D770((_QWORD *)v5 + 50);
        sub_7D770((_QWORD *)v5 + 59);
        *(_DWORD *)(v4 - 568) = 397;
LABEL_71:
        v41 = (_DWORD *)sub_45530((__int64)v5, (__int64)a3, a4);
        if ( !v41 )
          goto LABEL_14;
        if ( *v41 != 14 )
        {
          sub_423C0(*(_QWORD *)(v4 + 88), (__int64)"Encryption not successfully enabled", (__int64)a3, a4);
          goto LABEL_14;
        }
        v128 = sub_BC360((__int64)"Successfully started encryption", a2);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v128, (__int64)a3, a4);
        v129 = sub_3D010(*(__int64 **)(v4 - 552));
        *(_QWORD *)(v4 - 488) = v129;
        if ( v129 )
        {
LABEL_119:
          v72 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v4 + 8) + 24LL))(4LL);
          sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v72 + 96), *(char **)(v4 - 488));
          sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v72 + 64));
          v73 = sub_BC360((__int64)"Sent username \"%s\"", *(_QWORD *)(v4 - 488));
          sub_2D3A0(*(_QWORD *)(v4 + 72), v73, (__int64)a3, a4);
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v4 + 80) + 144LL))(
                 *(_QWORD *)(v4 + 80),
                 v73)
            || (*(unsigned __int8 (**)(void))(**(_QWORD **)(v4 + 80) + 152LL))() )
          {
            v74 = sub_BC360((__int64)"Sent username \"%s\"\r\n", *(_QWORD *)(v4 - 488));
            sub_62710(v4, v74);
          }
          *(_DWORD *)(v4 - 568) = 447;
          goto LABEL_123;
        }
        v130 = sub_31B10();
        *(_QWORD *)(v4 - 384) = v130;
        *(_BYTE *)v130 = 1;
        *((_BYTE *)v130 + 1) = 0;
        v130[1] = sub_BC120("SSH login name");
        v131 = sub_BC120("login as: ");
        sub_31B70(*(_QWORD **)(v4 - 384), (__int64)v131, 1);
        v79 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                *(_QWORD *)(v4 + 80),
                *(_QWORD *)(v4 - 384),
                0LL);
        *(_DWORD *)(v4 - 376) = v79;
LABEL_132:
        if ( v79 < 0 )
        {
          while ( sub_BCD00(*(_QWORD *)(v4 + 64)) )
          {
            v79 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                    *(_QWORD *)(v4 + 80),
                    *(_QWORD *)(v4 - 384),
                    *(_QWORD *)(v4 + 64));
            *(_DWORD *)(v4 - 376) = v79;
            if ( v79 >= 0 )
              goto LABEL_117;
          }
          v79 = *(_DWORD *)(v4 - 376);
          if ( v79 < 0 )
          {
            *(_BYTE *)(v4 - 24) = 1;
            *(_DWORD *)(v4 - 568) = 424;
            goto LABEL_14;
          }
        }
LABEL_117:
        if ( !v79 )
        {
          sub_42660(*(_QWORD *)(v4 + 88), (__int64)"No username provided", (__int64)a3, a4);
          goto LABEL_14;
        }
        v70 = sub_31C40(**(_QWORD **)(*(_QWORD *)(v4 - 384) + 56LL));
        v71 = *(_QWORD *)(v4 - 384);
        *(_QWORD *)(v4 - 488) = v70;
        sub_31C50(v71);
        *(_QWORD *)(v4 - 384) = 0LL;
        goto LABEL_119;
      }
      a2 = (signed __int64)"cipher";
      v31 = (*(__int64 (__fastcall **)(_QWORD, const char *, char *, __int64 (__fastcall *)(__int64, int), unsigned int *))(**(_QWORD **)(a1 + 80) + 72LL))(
              *(_QWORD *)(a1 + 80),
              "cipher",
              a3,
              sub_454A0,
              v5);
      *(_DWORD *)(a1 - 568) = 348;
      *(_DWORD *)(a1 - 184) = v31;
LABEL_62:
      if ( v31 < 0 )
        goto LABEL_14;
      if ( !v31 )
      {
        sub_42660(*(_QWORD *)(a1 + 88), (__int64)"User aborted at cipher warning", (__int64)a3, a4);
        goto LABEL_14;
      }
      goto LABEL_64;
    }
    v57 = (void *)sub_7B450((__int64 *)v5 + 59);
    *(_DWORD *)(a1 - 184) = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, char *, __int64, void *, void **, __int64 (__fastcall *)(__int64, int), unsigned int *))(**(_QWORD **)(a1 + 80) + 64LL))(
                              *(_QWORD *)(a1 + 80),
                              *(_QWORD *)(a1 - 544),
                              *(unsigned int *)(a1 - 536),
                              "rsa",
                              a4,
                              v57,
                              v111,
                              sub_454A0,
                              v5);
    sub_2F4D0(v57);
    sub_7BAB0(v111);
    sub_2F4D0((void *)a4);
    *(_DWORD *)(a1 - 568) = 271;
LABEL_96:
    v58 = *(_DWORD *)(a1 - 184);
    if ( v58 < 0 )
      goto LABEL_14;
    if ( !v58 )
    {
      sub_42660(*(_QWORD *)(a1 + 88), (__int64)"User aborted at host key verification", (__int64)a3, a4);
      goto LABEL_14;
    }
    v59 = (__int64)(v5 + 100);
    a3 = (char *)(v5 + 118);
    goto LABEL_99;
  }
  if ( v6 != 447 )
  {
    if ( v6 > 447 )
    {
      if ( v6 == 515 )
        goto LABEL_91;
      if ( v6 == 606 )
        goto LABEL_22;
      goto LABEL_166;
    }
    if ( v6 != 424 )
      goto LABEL_166;
    v79 = *(_DWORD *)(a1 - 376);
    *(_BYTE *)(a1 - 24) = 0;
    goto LABEL_132;
  }
LABEL_123:
  v75 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
  if ( !v75 )
    goto LABEL_14;
  if ( *(_BYTE *)(v4 - 448) & 4 )
  {
    *(_BYTE *)(v4 - 439) = 0;
    *(_BYTE *)(v4 - 440) = 0;
  }
  else
  {
    *(_BYTE *)(v4 - 439) = 1;
    *(_BYTE *)(v4 - 440) = 1;
  }
  v76 = *(__int64 **)(v4 - 552);
  *(_BYTE *)(v4 - 437) = 0;
  *(_BYTE *)(v4 - 438) = 0;
  v77 = (_BYTE **)sub_1F530(v76, 33);
  *(_QWORD *)(v4 - 176) = v77;
  if ( !sub_B4E50(v77) )
  {
    v119 = sub_B4E20(*(_QWORD *)(v4 - 176));
    v120 = sub_BC360((__int64)"Reading key file \"%s\"", v119);
    sub_2D3A0(*(_QWORD *)(v4 + 72), v120, (__int64)a3, a4);
    v121 = sub_7BB00(*(_QWORD *)(v4 - 176));
    v122 = v121;
    LOBYTE(a3) = v121 == 2;
    if ( v121 == 8 || (_BYTE)a3 )
    {
      v155 = sub_BC640();
      v156 = *(_QWORD *)(v4 - 176);
      v157 = v155 + 24;
      *(_QWORD *)(v4 - 408) = v155;
      if ( (unsigned int)sub_78EF0(v156, v155 + 24, (__int64 *)v5 + 21, (char **)&v238) )
      {
        *(_BYTE *)(v4 - 392) = (_BYTE)a3;
        if ( v122 != 2 )
        {
          v158 = sub_BC360((__int64)"Key file contains public key only", v157);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v158, (__int64)a3, a4);
        }
        *(_BYTE *)(v4 - 391) = sub_78BD0(*(_QWORD *)(v4 - 176), 0LL);
      }
      else
      {
        v186 = sub_BC360((__int64)"Unable to load key (%s)", v238);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v186, (__int64)a3, a4);
        v187 = v238;
        v188 = sub_B4E20(*(_QWORD *)(v4 - 176));
        v189 = sub_BC360((__int64)"Unable to load key file \"%s\" (%s)\r\n", v188, v187);
        sub_62710(v4, v189);
        sub_BC660(*(void ***)(v4 - 408));
        *(_QWORD *)(v4 - 408) = 0LL;
      }
    }
    else
    {
      v123 = sub_7BB90(v121);
      v124 = sub_BC360((__int64)"Unable to use this key file (%s)", v123);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v124, (__int64)a3, a4);
      v125 = sub_7BB90(v122);
      v126 = sub_B4E20(*(_QWORD *)(v4 - 176));
      v127 = sub_BC360((__int64)"Unable to use key file \"%s\" (%s)\r\n", v126, v125);
      sub_62710(v4, v127);
    }
  }
  v78 = sub_1EF00(*(__int64 **)(v4 - 552), 29);
  if ( v78 )
    v78 = sub_B3CE0();
  *(_BYTE *)(v4 - 532) = v78;
  for ( i = *v75; ; i = *v23 )
  {
    while ( 1 )
    {
LABEL_52:
      if ( i != 15 )
        goto LABEL_53;
      v50 = *(_BYTE *)(v4 - 532) == 0;
      *(_DWORD *)(v4 - 368) = 9;
      if ( v50 || *(_BYTE *)(v4 - 439) )
        goto LABEL_28;
      *(_BYTE *)(v4 - 264) = 0;
      *(_BYTE *)(v4 - 439) = 1;
      v51 = sub_BC360((__int64)"Pageant is running. Requesting keys.");
      sub_2D3A0(*(_QWORD *)(v4 + 72), v51, (__int64)a3, a4);
      v52 = sub_BC7E0();
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v52 + 24), 1);
      a2 = v52;
      sub_45570(v5, v52);
      sub_BC660((void **)v52);
      *(_DWORD *)(v4 - 568) = 515;
LABEL_91:
      if ( *(_QWORD *)(v4 - 480) )
        goto LABEL_14;
      v53 = *(_QWORD *)(v4 - 352);
      v54 = *(_QWORD *)(v4 - 344);
      *(_QWORD *)(v4 - 328) = 0LL;
      *(_DWORD *)(v4 - 312) = 0;
      *(_QWORD *)(v4 - 304) = v5 + 58;
      *(_QWORD *)(v4 - 336) = v53;
      *(_QWORD *)(v4 - 320) = v54;
      sub_2F150((__int64)(v5 + 58));
      v55 = "Failed to get reply from Pageant";
      if ( (unsigned __int8)sub_2F080(*(_QWORD *)(v4 - 304)) != 2 )
        goto LABEL_93;
      v180 = sub_2F150(*(_QWORD *)(v4 - 304));
      a3 = *(char **)(v4 - 328);
      v181 = *(_QWORD *)(v4 - 304);
      if ( !v180 )
      {
        sub_2F3E0(v181, *(_QWORD *)(v4 - 328));
        *(_QWORD *)(v4 - 296) = 0LL;
        *(_QWORD *)(v4 - 288) = sub_2F450(0LL, 0x60uLL, 0LL);
        v218 = sub_BC360((__int64)"Pageant has %zu SSH-1 keys", 0LL);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v218, (__int64)a3, a4);
        if ( *(_QWORD *)(v4 - 408) )
          goto LABEL_317;
        goto LABEL_318;
      }
      v182 = 0LL;
      do
      {
        a2 = 0LL;
        sub_7CCA0(v181, 0LL, 0);
        sub_2F1D0(*(_QWORD *)(v4 - 304));
        v181 = *(_QWORD *)(v4 - 304);
        if ( *(_DWORD *)(v181 + 24) )
        {
          v55 = "Pageant's response was truncated";
LABEL_93:
          v56 = sub_BC360((__int64)v55, a2);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v56, (__int64)a3, a4);
LABEL_94:
          v15 = *(_QWORD *)(v4 - 280);
          goto LABEL_26;
        }
        ++v182;
      }
      while ( v180 != v182 );
      a4 = 0LL;
      sub_2F3E0(v181, (unsigned __int64)a3);
      *(_QWORD *)(v4 - 296) = v180;
      v204 = (char *)sub_2F450(v180, 0x60uLL, 0LL);
      v205 = 0LL;
      *(_QWORD *)(v4 - 288) = v204;
      do
      {
        v206 = (__int64)&v204[a4];
        *(_QWORD *)(v206 + 64) = 0LL;
        v207 = v205;
        *(_OWORD *)v206 = 0LL;
        *(_OWORD *)(v206 + 16) = 0LL;
        *(_OWORD *)(v206 + 32) = 0LL;
        *(_OWORD *)(v206 + 48) = 0LL;
        v208 = *(_QWORD **)(v4 - 304);
        v209 = *v208 + v208[1];
        sub_7CCA0((__int64)v208, a4 + *(_QWORD *)(v4 - 288), 0);
        v210 = **(_QWORD **)(v4 - 304) + *(_QWORD *)(*(_QWORD *)(v4 - 304) + 8LL);
        v211 = a4 + *(_QWORD *)(v4 - 288);
        v212 = sub_BC640();
        v213 = *(_QWORD *)(v4 - 304);
        *(_QWORD *)(v211 + 72) = v212;
        sub_2F1D0(v213);
        sub_2EC30((__int64 (**)(void))(*(_QWORD *)(*(_QWORD *)(v4 - 288) + a4 + 72) + 24LL));
        v204 = *(char **)(v4 - 288);
        v214 = (__int64)&v204[a4];
        v205 = v207 + 1;
        a4 += 96LL;
        a3 = (char *)(v210 - v209);
        *(_QWORD *)(v214 + 80) = v209;
        *(_QWORD *)(v214 + 88) = a3;
      }
      while ( v207 + 1 != v182 );
      v215 = sub_BC360((__int64)"Pageant has %zu SSH-1 keys", v182);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v215, (__int64)a3, a4);
      v216 = *(_QWORD *)(v4 - 408);
      if ( v216 )
      {
        a4 = *(_QWORD *)(v216 + 16);
        a3 = *(char **)(v216 + 8);
        v217 = 0LL;
        while ( 1 )
        {
          v218 = (char *)a4;
          if ( sub_BD140(
                 a3,
                 a4,
                 *(const void **)(*(_QWORD *)(v4 - 288) + 96 * v217 + 80),
                 *(_QWORD *)(*(_QWORD *)(v4 - 288) + 96 * v217 + 88)) )
          {
            break;
          }
          if ( ++v217 == v182 )
            goto LABEL_317;
        }
        if ( v182 > v217 )
        {
          v219 = sub_BC360((__int64)"Pageant key #%zu matches configured key file", v217);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v219, (__int64)a3, a4);
          *(_QWORD *)(v4 - 280) = v217;
          *(_QWORD *)(v4 - 272) = v217 + 1;
          goto LABEL_94;
        }
LABEL_317:
        v235 = sub_BC360((__int64)"Configured key file not in Pageant", v218);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v235, (__int64)a3, a4);
        *(_QWORD *)(v4 - 280) = 0LL;
        *(_QWORD *)(v4 - 272) = 0LL;
        goto LABEL_94;
      }
LABEL_318:
      *(_QWORD *)(v4 - 280) = 0LL;
      *(_QWORD *)(v4 - 272) = v180;
      v15 = 0LL;
LABEL_26:
      if ( *(_QWORD *)(v4 - 272) > v15 )
        break;
      if ( *(_BYTE *)(v4 - 264) )
        goto LABEL_53;
LABEL_28:
      if ( *(_QWORD *)(v4 - 408) && *(_BYTE *)(v4 - 392) && !*(_BYTE *)(v4 - 440) )
      {
        if ( (*(unsigned __int8 (**)(void))(**(_QWORD **)(v4 + 80) + 144LL))() )
        {
          v185 = sub_BC360((__int64)"Trying public key authentication.\r\n");
          sub_62710(v4, v185);
        }
        v16 = sub_B4E20(*(_QWORD *)(v4 - 176));
        v17 = sub_BC360((__int64)"Trying public key \"%s\"", v16);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v17, (__int64)a3, a4);
        *(_BYTE *)(v4 - 440) = 1;
        goto LABEL_34;
      }
LABEL_193:
      v116 = sub_31B10();
      v117 = *(__int64 **)(v4 - 552);
      *(_QWORD *)(v4 - 384) = v116;
      if ( (unsigned __int8)sub_1EF00(v117, 39) && *(_BYTE *)(v4 - 448) & 0x20 && !*(_BYTE *)(v4 - 438) )
      {
        sub_45620((__int64)v5);
        *(_DWORD *)(v4 - 368) = 41;
        v87 = sub_BC360((__int64)"Requested TIS authentication");
        sub_2D3A0(*(_QWORD *)(v4 + 72), v87, (__int64)a3, a4);
        a2 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 8) + 24LL))(39LL, v87) + 64;
        sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)a2);
        *(_DWORD *)(v4 - 568) = 859;
LABEL_148:
        v88 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
        v84 = v88;
        if ( !v88 )
          goto LABEL_14;
        v85 = *v88;
        if ( *v88 != 15 )
        {
          if ( v85 != 40 )
            goto LABEL_146;
          v89 = sub_2F1D0((__int64)(v88 + 12));
          v91 = v90;
          a3 = v89;
          if ( v84[18] )
          {
            sub_423C0(*(_QWORD *)(v4 + 88), (__int64)"TIS challenge packet was badly formed", (__int64)v89, a4);
            goto LABEL_14;
          }
          v92 = sub_BC360((__int64)"Received TIS challenge", a2);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v92, (__int64)a3, a4);
          v93 = *(_QWORD *)(v4 - 384);
          *(_BYTE *)v93 = 1;
          *(_BYTE *)(v93 + 1) = 1;
          *(_QWORD *)(v93 + 8) = sub_BC120("SSH TIS authentication");
          v94 = sub_BC640();
          v95 = (__int64 (**)(void))(v94 + 24);
          a4 = v94;
          sub_2EC30((__int64 (**)(void))(v94 + 24));
          v96 = *(_QWORD *)(v4 - 16);
          if ( v96 )
          {
            sub_87AD0(v96, (__int64)v95);
            sub_2EC30(*(__int64 (***)(void))(v4 - 16));
            sub_87AD0(*(_QWORD *)(v4 - 16), 0LL);
          }
          else
          {
            sub_2EC30(v95);
          }
          if ( !(unsigned __int8)sub_BD220((__int64)a3, v91, "\n", 1uLL, 0LL) )
            sub_2EC30(v95);
          sub_2EC30(v95);
          v97 = *(_QWORD *)(v4 - 384);
          v98 = "TIS authentication response: ";
          *(_QWORD *)(v97 + 24) = sub_BC6B0((__int64 *)a4);
          *(_BYTE *)(*(_QWORD *)(v4 - 384) + 32LL) = 1;
          goto LABEL_157;
        }
        v172 = sub_BC360((__int64)"TIS authentication declined", a2);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v172, (__int64)a3, a4);
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v4 + 80) + 152LL))(
               *(_QWORD *)(v4 + 80),
               v172) )
        {
          v173 = sub_BC360((__int64)"TIS authentication refused.\r\n");
          sub_62710(v4, v173);
        }
        *(_BYTE *)(v4 - 438) = 1;
        i = *v84;
      }
      else
      {
        if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(v4 - 552), 39)
          || !(*(_BYTE *)(v4 - 446) & 1)
          || *(_BYTE *)(v4 - 437) )
        {
          goto LABEL_158;
        }
        sub_45620((__int64)v5);
        *(_DWORD *)(v4 - 368) = 72;
        v118 = sub_BC360((__int64)"Requested CryptoCard authentication", 39LL);
        sub_2D3A0(*(_QWORD *)(v4 + 72), v118, (__int64)a3, a4);
        a2 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 8) + 24LL))(70LL, v118) + 64;
        sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)a2);
        *(_DWORD *)(v4 - 568) = 914;
LABEL_143:
        v83 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
        v84 = v83;
        if ( !v83 )
          goto LABEL_14;
        v85 = *v83;
        if ( *v83 == 15 )
        {
          v174 = sub_BC360((__int64)"CryptoCard authentication declined", a2);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v174, (__int64)a3, a4);
          v175 = sub_BC360((__int64)"CryptoCard authentication refused.\r\n", v174);
          sub_62710(v4, v175);
          *(_BYTE *)(v4 - 437) = 1;
          i = *v84;
        }
        else
        {
          if ( v85 != 71 )
          {
LABEL_146:
            sub_61F60(v85);
            v86 = (unsigned int)*v84;
            sub_423C0(
              *(_QWORD *)(v4 + 88),
              (__int64)"Received unexpected packet in response to TIS authentication, type %d (%s)",
              (__int64)a3,
              a4);
            goto LABEL_14;
          }
          a3 = sub_2F1D0((__int64)(v83 + 12));
          v148 = v147;
          if ( v84[18] )
          {
            sub_423C0(*(_QWORD *)(v4 + 88), (__int64)"CryptoCard challenge packet was badly formed", (__int64)a3, a4);
            goto LABEL_14;
          }
          v149 = sub_BC360((__int64)"Received CryptoCard challenge", a2);
          sub_2D3A0(*(_QWORD *)(v4 + 72), v149, (__int64)a3, a4);
          v150 = *(_QWORD *)(v4 - 384);
          *(_BYTE *)v150 = 1;
          *(_BYTE *)(v150 + 1) = 1;
          *(_QWORD *)(v150 + 8) = sub_BC120("SSH CryptoCard authentication");
          v151 = sub_BC640();
          v152 = (__int64 (**)(void))(v151 + 24);
          a4 = v151;
          sub_2EC30((__int64 (**)(void))(v151 + 24));
          v153 = *(_QWORD *)(v4 - 16);
          if ( v153 )
          {
            sub_87AD0(v153, (__int64)v152);
            sub_2EC30(*(__int64 (***)(void))(v4 - 16));
            sub_87AD0(*(_QWORD *)(v4 - 16), 0LL);
          }
          else
          {
            sub_2EC30(v152);
          }
          if ( !(unsigned __int8)sub_BD220((__int64)a3, v148, "\n", 1uLL, 0LL) )
            sub_2EC30(v152);
          sub_2EC30(v152);
          v154 = *(_QWORD *)(v4 - 384);
          v98 = "CryptoCard authentication response: ";
          *(_QWORD *)(v154 + 24) = sub_BC6B0((__int64 *)a4);
          *(_BYTE *)(*(_QWORD *)(v4 - 384) + 32LL) = 1;
LABEL_157:
          v99 = sub_BC120(v98);
          sub_31B70(*(_QWORD **)(v4 - 384), (__int64)v99, 0);
LABEL_158:
          if ( *(_DWORD *)(v4 - 368) == 9 )
          {
            if ( !(*(_BYTE *)(v4 - 448) & 8) )
            {
              sub_42500(*(_QWORD *)(v4 + 88), (__int64)"No supported authentication methods available", (__int64)a3, a4);
              goto LABEL_14;
            }
            v196 = *(_QWORD *)(v4 - 384);
            *(_BYTE *)v196 = 1;
            *(_BYTE *)(v196 + 1) = 0;
            v197 = sub_BC120("SSH password");
            v198 = *(_QWORD *)(v4 - 544);
            v199 = *(_QWORD *)(v4 - 488);
            *(_QWORD *)(v196 + 8) = v197;
            v200 = sub_BC360((__int64)"%s@%s's password: ", v199, v198);
            sub_31B70(*(_QWORD **)(v4 - 384), (__int64)v200, 0);
          }
          v100 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                   *(_QWORD *)(v4 + 80),
                   *(_QWORD *)(v4 - 384),
                   0LL);
          *(_DWORD *)(v4 - 376) = v100;
LABEL_160:
          if ( v100 < 0 )
          {
            while ( sub_BCD00(*(_QWORD *)(v4 + 64)) )
            {
              v100 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                       *(_QWORD *)(v4 + 80),
                       *(_QWORD *)(v4 - 384),
                       *(_QWORD *)(v4 + 64));
              *(_DWORD *)(v4 - 376) = v100;
              if ( v100 >= 0 )
                goto LABEL_79;
            }
            v100 = *(_DWORD *)(v4 - 376);
            if ( v100 < 0 )
            {
              *(_BYTE *)(v4 - 24) = 1;
              *(_DWORD *)(v4 - 568) = 992;
              goto LABEL_14;
            }
          }
LABEL_79:
          if ( !v100 )
          {
            sub_42660(*(_QWORD *)(v4 + 88), (__int64)"User aborted at password prompt", (__int64)a3, a4);
            goto LABEL_14;
          }
          if ( *(_DWORD *)(v4 - 368) == 9 )
          {
            v190 = *(_DWORD *)(v4 + 96);
            if ( v190 & 5 )
            {
              if ( v190 & 4 )
              {
                v220 = sub_BC360((__int64)"Sending unpadded password");
                sub_2D3A0(*(_QWORD *)(v4 + 72), v220, (__int64)a3, a4);
                v221 = *(unsigned int *)(v4 - 368);
                goto LABEL_81;
              }
              a3 = (char *)sub_BC650();
              v191 = sub_BC360((__int64)"Sending length-padded password");
              sub_2D3A0(*(_QWORD *)(v4 + 72), v191, (__int64)a3, a4);
              v192 = (*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v4 + 8) + 24LL))(
                       *(unsigned int *)(v4 - 368),
                       v191);
              v193 = (const char *)sub_31C30(**(_QWORD **)(*(_QWORD *)(v4 - 384) + 56LL));
              sub_2EF90((__int64 (__fastcall **)(_QWORD, const char *, size_t))a3 + 3, v193);
              v194 = -*((_DWORD *)a3 + 4) & 0x3F;
              v195 = sub_BC510((__int64)a3, v194);
              sub_7BF50(v195, v194);
              sub_2EF70((void (__fastcall **)(_QWORD, char *, signed __int64))(v192 + 96), (__int64)a3);
              v45 = (char *)(v192 + 64);
              sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v192 + 64));
            }
            else
            {
              v237 = (char *)sub_31C30(**(_QWORD **)(*(_QWORD *)(v4 - 384) + 56LL));
              v223 = strlen(v237) + 1;
              v222 = v223 - 1;
              if ( (signed int)v223 - 1 <= 15 )
              {
                v224 = 15;
                LODWORD(a4) = 0;
              }
              else
              {
                LODWORD(a4) = v222 & 0xFFFFFFF8;
                v224 = (v222 & 0xFFFFFFF8) + 7;
              }
              if ( (signed int)a4 > v222 || (v225 = (signed int)a4, v224 < v222) )
                __assert_fail("pwlen >= bottom && pwlen <= top", "ssh1login.c", 0x426u, "ssh1_login_process_queue");
              do
              {
                if ( (_DWORD)v223 - 1 == (_DWORD)a4 )
                {
                  a3 = (char *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v4 + 8) + 24LL))(*(unsigned int *)(v4 - 368));
                  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))a3 + 12, v237);
                  v229 = a3 + 64;
                  sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)a3 + 8);
                }
                else
                {
                  v226 = (char *)sub_BC650();
                  a3 = v226;
                  v227 = sub_BC510((__int64)v226, v225);
                  sub_7BF50(v227, v225);
                  v228 = (*(__int64 (__fastcall **)(signed __int64, unsigned __int64))(**(_QWORD **)(v4 + 8) + 24LL))(
                           32LL,
                           v225);
                  sub_2EF70((void (__fastcall **)(_QWORD, char *, signed __int64))(v228 + 96), (__int64)a3);
                  v229 = (char *)(v228 + 64);
                  sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v228 + 64));
                }
                a4 = (unsigned int)(a4 + 1);
                ++v225;
              }
              while ( v224 >= (signed int)a4 );
              v45 = sub_BC360((__int64)"Sending password with camouflage packets", v229);
              sub_2D3A0(*(_QWORD *)(v4 + 72), v45, (__int64)a3, a4);
            }
          }
          else
          {
LABEL_81:
            v43 = (*(__int64 (**)(void))(**(_QWORD **)(v4 + 8) + 24LL))();
            v44 = (char *)sub_31C30(**(_QWORD **)(*(_QWORD *)(v4 - 384) + 56LL));
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v43 + 96), v44);
            v45 = (char *)(v43 + 64);
            sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v43 + 64));
          }
          *(_BYTE *)(v4 - 531) = 0;
          a2 = (signed __int64)sub_BC360((__int64)"Sent password", v45);
          sub_2D3A0(*(_QWORD *)(v4 + 72), (char *)a2, (__int64)a3, a4);
          sub_31C50(*(_QWORD *)(v4 - 384));
          *(_QWORD *)(v4 - 384) = 0LL;
          *(_DWORD *)(v4 - 568) = 1116;
LABEL_83:
          v46 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
          v47 = v46;
          if ( !v46 )
            goto LABEL_14;
          v48 = *v46;
          if ( *v46 != 15 )
          {
            if ( v48 == 14 )
              goto LABEL_53;
            sub_61F60(v48);
            v143 = (unsigned int)*v47;
            sub_423C0(
              *(_QWORD *)(v4 + 88),
              (__int64)"Received unexpected packet in response to password authentication, type %d (%s)",
              (__int64)a3,
              a4);
            goto LABEL_14;
          }
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 80) + 144LL))(
                 *(_QWORD *)(v4 + 80),
                 a2) )
          {
            v140 = sub_BC360((__int64)"Access denied\r\n");
            sub_62710(v4, v140);
          }
          v49 = sub_BC360((__int64)"Authentication refused");
          sub_2D3A0(*(_QWORD *)(v4 + 72), v49, (__int64)a3, a4);
          i = *v47;
        }
      }
    }
    v183 = sub_BC360((__int64)"Trying Pageant key #%zu");
    sub_2D3A0(*(_QWORD *)(v4 + 72), v183, (__int64)a3, a4);
    v184 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 8) + 24LL))(6LL, v183);
    sub_33680(v184 + 96, *(__int64 **)(*(_QWORD *)(v4 - 288) + 96LL * *(_QWORD *)(v4 - 280) + 8));
    a2 = v184 + 64;
    sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v184 + 64));
    *(_DWORD *)(v4 - 568) = 606;
LABEL_22:
    v12 = (_DWORD *)sub_45530((__int64)v5, (__int64)a3, a4);
    v13 = v12;
    if ( !v12 )
      goto LABEL_14;
    if ( *v12 != 7 )
    {
      v14 = sub_BC360((__int64)"Key refused", a2);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v14, (__int64)a3, a4);
LABEL_25:
      v15 = *(_QWORD *)(v4 - 280) + 1LL;
      *(_QWORD *)(v4 - 280) = v15;
      goto LABEL_26;
    }
    v63 = sub_BC360((__int64)"Received RSA challenge", a2);
    sub_2D3A0(*(_QWORD *)(v4 + 72), v63, (__int64)a3, a4);
    a3 = (char *)sub_337C0((__int64)(v13 + 12));
    v64 = a3;
    if ( v13[18] )
      goto LABEL_213;
    v65 = sub_BC7E0();
    v66 = (__int64 (**)(void))(v65 + 24);
    v67 = (void **)v65;
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v65 + 24), 3);
    sub_7D5B0((__int64)v66, *(_QWORD *)(v4 - 288) + 96LL * *(_QWORD *)(v4 - 280), 0);
    sub_33680((__int64)v66, (__int64 *)a3);
    sub_330F0(a3);
    sub_2EC20(v66);
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v66, 1);
    a2 = (signed __int64)v67;
    sub_45570(v5, (__int64)v67);
    sub_BC660(v67);
    *(_DWORD *)(v4 - 568) = 637;
LABEL_110:
    if ( *(_QWORD *)(v4 - 480) )
      goto LABEL_14;
    v68 = *(_BYTE **)(v4 - 352);
    if ( !v68 )
    {
      v81 = "No reply received from Pageant";
LABEL_141:
      v82 = sub_BC360((__int64)v81, a2);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v82, (__int64)a3, a4);
      goto LABEL_115;
    }
    if ( *(_QWORD *)(v4 - 344) <= 0x14uLL || v68[4] != 4 )
    {
      v69 = sub_BC360((__int64)"Pageant failed to answer challenge", a2);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v69, (__int64)a3, a4);
      sub_2F4D0(v68);
LABEL_115:
      if ( *(_BYTE *)(v4 - 264) )
        goto LABEL_53;
      goto LABEL_25;
    }
    v202 = sub_BC360((__int64)"Sending Pageant's response", a2);
    sub_2D3A0(*(_QWORD *)(v4 + 72), v202, (__int64)a3, a4);
    v203 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 8) + 24LL))(8LL, v202);
    sub_2EC20((__int64 (**)(void))(v203 + 96));
    a2 = v203 + 64;
    sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v203 + 64));
    *(_BYTE *)(v4 - 531) = 0;
    *(_DWORD *)(v4 - 568) = 653;
LABEL_139:
    v80 = (_DWORD *)sub_45530((__int64)v5, (__int64)a3, a4);
    if ( !v80 )
      goto LABEL_14;
    v81 = "Pageant's response not accepted";
    if ( *v80 != 14 )
      goto LABEL_141;
    v146 = sub_BC360((__int64)"Pageant's response accepted", a2);
    sub_2D3A0(*(_QWORD *)(v4 + 72), v146, (__int64)a3, a4);
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v4 + 80) + 144LL))(
           *(_QWORD *)(v4 + 80),
           v146) )
    {
      v176 = *(_QWORD *)(*(_QWORD *)(v4 - 288) + 96LL * *(_QWORD *)(v4 - 280) + 72);
      v177 = *(_QWORD *)(v176 + 8);
      v178 = sub_BC2F0(*(_QWORD *)(v176 + 16));
      v179 = sub_BC360((__int64)"Authenticated using RSA key \"%.*s\" from agent\r\n", v178, v177);
      sub_62710(v4, v179);
    }
    *(_BYTE *)(v4 - 264) = 1;
LABEL_53:
    if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(v4 - 552), 37) || !*(_BYTE *)(v4 - 531) )
    {
      v29 = sub_BC360((__int64)"Authentication successful", 37LL);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v29, (__int64)a3, a4);
      if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(v4 - 552), 23) )
        goto LABEL_56;
      v132 = sub_BC360((__int64)"Requesting compression", 23LL);
      sub_2D3A0(*(_QWORD *)(v4 + 72), v132, (__int64)a3, a4);
      v133 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v4 + 8) + 24LL))(37LL, v132);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v133 + 96), 6);
      a2 = v133 + 64;
      sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v133 + 64));
      *(_DWORD *)(v4 - 568) = 1143;
      goto LABEL_10;
    }
    sub_423C0(
      *(_QWORD *)(v4 + 88),
      (__int64)"Authentication was trivial! Abandoning session as specified in configuration.",
      (__int64)a3,
      a4);
LABEL_14:
    v11 = __readfsqword(0x28u);
    result = v11 ^ v240;
    if ( v11 == v240 )
      break;
LABEL_315:
    v230 = sub_31B10();
    *(_QWORD *)(v4 - 384) = v230;
    *v230 = 0;
    v230[1] = 0;
    v231 = v230;
    v232 = sub_BC120("SSH key passphrase");
    v233 = *(_QWORD *)(v4 - 400);
    *((_QWORD *)v231 + 1) = v232;
    v234 = sub_BC360((__int64)"Passphrase for key \"%s\": ", v233);
    sub_31B70(*(_QWORD **)(v4 - 384), (__int64)v234, 0);
    *(_DWORD *)(v4 - 376) = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                              *(_QWORD *)(v4 + 80),
                              *(_QWORD *)(v4 - 384),
                              0LL);
LABEL_169:
    v101 = *(_DWORD *)(v4 - 376);
    if ( v101 < 0 )
    {
      while ( sub_BCD00(*(_QWORD *)(v4 + 64)) )
      {
        v101 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v4 + 80) + 16LL))(
                 *(_QWORD *)(v4 + 80),
                 *(_QWORD *)(v4 - 384),
                 *(_QWORD *)(v4 + 64));
        *(_DWORD *)(v4 - 376) = v101;
        if ( v101 >= 0 )
          goto LABEL_175;
      }
      v101 = *(_DWORD *)(v4 - 376);
      if ( v101 < 0 )
      {
        *(_BYTE *)(v4 - 24) = 1;
        *(_DWORD *)(v4 - 568) = 729;
        goto LABEL_14;
      }
    }
LABEL_175:
    if ( !v101 )
    {
      sub_42660(*(_QWORD *)(v4 + 88), (__int64)"User aborted at passphrase prompt", (__int64)a3, a4);
      goto LABEL_14;
    }
    v141 = sub_31C40(**(_QWORD **)(*(_QWORD *)(v4 - 384) + 56LL));
    sub_31C50(*(_QWORD *)(v4 - 384));
    v142 = *(_QWORD *)(v4 - 176);
    v19 = (signed __int64)(v5 + 78);
    *(_QWORD *)(v4 - 384) = 0LL;
    v20 = sub_78B20(v142, (_QWORD *)v5 + 39, v141, (char **)&v238);
    if ( v141 )
    {
      v19 = strlen(v141);
      sub_BD070(v141, v19);
      sub_2F4D0(v141);
    }
    while ( v20 != 1 )
    {
      if ( !v20 )
      {
        v113 = v238;
        v114 = sub_B4E20(*(_QWORD *)(v4 - 176));
        v115 = sub_BC360((__int64)"Couldn't load private key from %s (%s).\r\n", v114, v113);
        sub_62710(v4, v115);
        goto LABEL_193;
      }
      if ( v20 != -1 )
        __assert_fail(
          "false && \"unexpected return from rsa1_load_f()\"",
          "ssh1login.c",
          0x2FBu,
          "ssh1_login_process_queue");
      v17 = sub_BC360((__int64)"Wrong passphrase.\r\n", v19);
      sub_62710(v4, v17);
LABEL_34:
      if ( *(_BYTE *)(v4 - 391) )
        goto LABEL_315;
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v4 + 80) + 144LL))(
             *(_QWORD *)(v4 + 80),
             v17) )
      {
        v18 = sub_BC360((__int64)"No passphrase required.\r\n");
        sub_62710(v4, v18);
      }
      v19 = (signed __int64)(v5 + 78);
      v20 = sub_78B20(*(_QWORD *)(v4 - 176), (_QWORD *)v5 + 39, 0LL, (char **)&v238);
    }
    v21 = (*(__int64 (__fastcall **)(signed __int64, signed __int64))(**(_QWORD **)(v4 + 8) + 24LL))(6LL, v19);
    sub_33680(v21 + 96, *(__int64 **)(v4 - 248));
    sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)(v21 + 64));
    *(_DWORD *)(v4 - 568) = 777;
LABEL_40:
    v22 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
    v23 = v22;
    if ( !v22 )
      goto LABEL_14;
    v24 = *v22;
    if ( *v22 == 15 )
    {
      v162 = "Server refused our public key.\r\n";
    }
    else
    {
      if ( v24 != 7 )
      {
        sub_61F60(v24);
        v25 = (unsigned int)*v23;
        sub_423C0(
          *(_QWORD *)(v4 + 88),
          (__int64)"Received unexpected packet in response to offer of public key, type %d (%s)",
          (__int64)a3,
          a4);
        goto LABEL_14;
      }
      v134 = sub_337C0((__int64)(v22 + 12));
      v236 = v134;
      if ( v23[18] )
      {
        v64 = (char *)v134;
LABEL_213:
        sub_330F0(v64);
        sub_423C0(*(_QWORD *)(v4 + 88), (__int64)"Server's RSA challenge was badly formatted", (__int64)a3, a4);
        goto LABEL_14;
      }
      a4 = 0LL;
      v135 = sub_7D090(v134, (__int64)(v5 + 78));
      sub_7D710((_QWORD *)v5 + 39);
      do
      {
        v136 = 31 - a4;
        v239[a4] = sub_334D0(v135, 31 - a4);
        ++a4;
      }
      while ( a4 != 32 );
      v137 = sub_76E90((__int64)off_320E40);
      v138 = (__int64 (***)(void))v137;
      if ( v137 )
        (*(void (__fastcall **)(signed __int64, __int64))(*(_QWORD *)v137 + 8LL))(v137, v136);
      sub_2EC20(v138[1]);
      sub_2EC20(v138[1]);
      ((void (__fastcall *)(__int64 (***)(void), char *))(*v138)[3])(v138, v239);
      ((void (__fastcall *)(__int64 (***)(void)))(*v138)[4])(v138);
      a3 = (char *)(*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v4 + 8) + 24LL))(8LL);
      sub_2EC20((__int64 (**)(void))a3 + 12);
      a2 = (signed __int64)(a3 + 64);
      sub_614E0(*(_QWORD *)(v4 + 24), (__int64 *)a3 + 8);
      *(_BYTE *)(v4 - 531) = 0;
      sub_330F0(v236);
      sub_330F0(v135);
      *(_DWORD *)(v4 - 568) = 827;
LABEL_48:
      v26 = (int *)sub_45530((__int64)v5, (__int64)a3, a4);
      v23 = v26;
      if ( !v26 )
        goto LABEL_14;
      v27 = *v26;
      if ( *v26 != 15 )
      {
        if ( v27 == 14 )
          goto LABEL_53;
        sub_61F60(v27);
        v139 = (unsigned int)*v23;
        sub_423C0(
          *(_QWORD *)(v4 + 88),
          (__int64)"Received unexpected packet in response to RSA authentication, type %d (%s)",
          (__int64)a3,
          a4);
        goto LABEL_14;
      }
      if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v4 + 80) + 144LL))(
              *(_QWORD *)(v4 + 80),
              a2) )
      {
        i = *v23;
        goto LABEL_52;
      }
      v162 = "Failed to authenticate with our public key.\r\n";
    }
    v163 = sub_BC360((__int64)v162);
    sub_62710(v4, v163);
  }
  return result;
}

void __fastcall sub_47B80(__int64 a1, int a2)
{
  __int64 v2; // rbp

  if ( (unsigned int)(a2 - 2) <= 1 && !(*(_BYTE *)(a1 + 96) & 1) )
  {
    v2 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 8) + 24LL))(32LL);
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 96), &locale);
    sub_614E0(*(_QWORD *)(a1 + 24), (__int64 *)(v2 + 64));
  }
}

_QWORD *__fastcall sub_47BE0(_QWORD *a1, char *a2, int a3, __int64 a4)
{
  int v4; // er14
  __int64 v5; // r13
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  char *v8; // rax
  _QWORD *result; // rax

  v4 = a3;
  v5 = a4;
  v6 = sub_2F450(1uLL, 0x2A0uLL, 0LL);
  v7 = v6;
  *v6 = 0LL;
  v6[83] = 0LL;
  memset(
    (void *)((unsigned __int64)(v6 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v6 - (((_DWORD)v6 + 8) & 0xFFFFFFF8) + 672) >> 3));
  v6[71] = off_323F60;
  v6[2] = sub_1EED0(a1);
  v8 = sub_BC120(a2);
  *((_DWORD *)v7 + 8) = v4;
  v7[3] = v8;
  result = v7 + 71;
  v7[1] = v5;
  *((_BYTE *)v7 + 37) = 1;
  return result;
}

__int64 __fastcall sub_47C80(int a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx

  v1 = sub_617D0();
  *(_DWORD *)(v1 + 16) = a1;
  *(_QWORD *)(v1 + 8) = 4LL;
  v2 = v1;
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v1 + 96), a1);
  return v2;
}

unsigned __int64 __fastcall sub_47CC0(__int64 a1)
{
  __int64 v1; // rax
  _BYTE *v2; // r8
  signed __int64 v3; // r15
  __int64 v4; // r12
  unsigned int v5; // ST44_4
  __int64 v6; // ST38_8
  int v7; // ST40_4
  const char *v8; // rax
  __int64 v9; // rdx
  int v10; // eax
  __int64 v11; // rax
  __int64 v12; // r13
  char v14; // [rsp+20h] [rbp-78h]
  unsigned __int64 v15; // [rsp+58h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  while ( 1 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(a1 + 136))(a1 + 88, a1 + 88, 1LL);
    v12 = v11;
    if ( !v11 )
      break;
    v1 = *(_QWORD *)(v11 + 8);
    v2 = *(_BYTE **)(v12 + 32);
    if ( *(_QWORD *)(a1 + 152) )
    {
      v3 = v1 - 5;
      v4 = (__int64)(v2 + 5);
      v5 = sub_49C80(*(_QWORD *)(a1 + 144), *(_DWORD *)(v12 + 16), 1, (__int64)(v2 + 5), v1 - 5, &v14);
      v6 = *(_QWORD *)(v12 + 56);
      v7 = *(_DWORD *)(v12 + 48);
      v8 = sub_621E0(
             *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4LL),
             *(_DWORD *)(*(_QWORD *)(a1 + 144) + 8LL),
             *(_DWORD *)(v12 + 16));
      v9 = *(unsigned int *)(v12 + 16);
      sub_2D4B0((__int64)v8, *(_QWORD *)(a1 + 152), 1u, v4, v3, v3, v5, (__int64)&v14, (__int64 *)(a1 - 16), v7, v6);
      v1 = *(_QWORD *)(v12 + 8);
      v2 = *(_BYTE **)(v12 + 32);
    }
    v10 = v1 - 4;
    ++*(_QWORD *)(a1 - 16);
    v2[3] = v10;
    v2[2] = BYTE1(v10);
    v2[1] = BYTE2(v10);
    *v2 = HIBYTE(v10);
    sub_BCD20(*(_QWORD *)(a1 + 16), *(char **)(v12 + 32), *(_QWORD *)(v12 + 8));
    sub_61840((void **)v12);
  }
  return __readfsqword(0x28u) ^ v15;
}

void __fastcall sub_47E30(__int64 a1)
{
  sub_2F4D0(*(void **)(a1 - 8));
  sub_2F4D0((void *)(a1 - 56));
}

unsigned __int64 __usercall sub_47E50@<rax>(__int64 a1@<rdi>, unsigned __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbx
  int v4; // eax
  char *v6; // rsi
  unsigned __int8 *v7; // rcx
  __int64 v8; // rsi
  signed int v9; // eax
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned int v12; // eax
  __int64 *v13; // rbp
  __int64 v14; // r8
  __int64 v15; // r13
  __int64 v16; // r14
  const char *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rdi
  __int64 v20; // rdx
  char *v21; // rax
  __int64 v22; // rdx
  __int64 *v23; // rsi
  __int64 v24; // rax
  __int64 v25; // [rsp+0h] [rbp-78h]
  unsigned int v26; // [rsp+34h] [rbp-44h]
  unsigned __int64 v27; // [rsp+38h] [rbp-40h]

  v3 = a1;
  v27 = __readfsqword(0x28u);
  v4 = *(_DWORD *)(a1 - 56);
  if ( v4 == 79 )
    goto LABEL_15;
  if ( v4 == 102 )
  {
    v6 = *(char **)(a1 - 32);
    goto LABEL_7;
  }
  if ( v4 )
  {
    *(_DWORD *)(a1 - 56) = 0;
  }
  else
  {
    while ( 1 )
    {
      *(_DWORD *)(a1 - 56) = 79;
LABEL_15:
      if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(a1 + 8), (char *)&v26, 4uLL) )
        break;
      sub_41EF0(*(_QWORD **)(a1 + 160));
      v20 = (signed int)_byteswap_ulong(v26);
      *(_QWORD *)(a1 - 48) = (signed int)v20;
      if ( (unsigned __int64)((signed int)v20 - 1LL) > 0x8FFE )
      {
        sub_42500(*(_QWORD *)(a1 + 160), (__int64)"Invalid packet length received", a2, a3);
        *(_DWORD *)(a1 - 56) = 0;
        return __readfsqword(0x28u) ^ v27;
      }
      v21 = (char *)sub_2F450(1uLL, 0x58uLL, v20);
      v22 = *(_QWORD *)(a1 - 24);
      v6 = v21 + 88;
      *(_QWORD *)(a1 - 8) = v21;
      *((_QWORD *)v21 + 2) = 0LL;
      *((_QWORD *)v21 + 3) = 0LL;
      v21[40] = 0;
      *(_QWORD *)(a1 - 40) = 0LL;
      *(_QWORD *)(a1 - 32) = v21 + 88;
      *(_QWORD *)(a1 - 24) = v22 + 1;
      *((_QWORD *)v21 + 1) = v22;
      *(_DWORD *)(a1 - 56) = 102;
LABEL_7:
      if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(a1 + 8), v6, *(_QWORD *)(a1 - 48)) )
        break;
      sub_41EF0(*(_QWORD **)(a1 + 160));
      v7 = *(unsigned __int8 **)(a1 - 32);
      v8 = *(_QWORD *)(a1 - 8);
      v9 = *v7;
      v10 = *(_QWORD *)(a1 - 48) - 1LL;
      v11 = (__int64)(v7 + 1);
      *(_DWORD *)v8 = v9;
      *(_QWORD *)(a1 - 32) = v11;
      *(_QWORD *)(a1 - 48) = v10;
      *(_QWORD *)(v8 + 48) = v11;
      *(_QWORD *)(v8 + 64) = v10;
      *(_QWORD *)(v8 + 56) = 0LL;
      *(_DWORD *)(v8 + 72) = 0;
      *(_QWORD *)(v8 + 80) = v8 + 48;
      if ( v9 == 7 )
      {
        sub_423C0(
          *(_QWORD *)(a1 + 160),
          (__int64)"Remote side sent SSH2_MSG_EXT_INFO in bare connection protocol",
          a2,
          a3);
        return __readfsqword(0x28u) ^ v27;
      }
      if ( *(_QWORD *)(a1 + 152) )
      {
        v12 = sub_49C80(*(_QWORD *)(a1 + 144), v9, 0, v11, v10, &v25);
        v13 = *(__int64 **)(a1 - 8);
        a3 = v12;
        v14 = v13[7];
        v15 = v13[8];
        ++v13;
        a2 = v15 - v14;
        v16 = v14 + v13[5];
        v17 = sub_621E0(
                *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4LL),
                *(_DWORD *)(*(_QWORD *)(a1 + 144) + 8LL),
                *((_DWORD *)v13 - 2));
        v18 = **(unsigned int **)(a1 - 8);
        sub_2D4B0((__int64)v17, *(_QWORD *)(a1 + 152), 0, v16, a2, a3, a3, (__int64)&v25, v13, 0, 0LL);
        v8 = *(_QWORD *)(a1 - 8);
      }
      if ( (unsigned __int8)sub_62870(a1, v8) )
      {
        sub_2F4D0(*(void **)(a1 - 8));
      }
      else
      {
        v23 = *(__int64 **)(a1 - 8);
        v24 = v23[8] - v23[7];
        v23 += 2;
        v23[2] = v24;
        sub_614E0(a1 + 32, v23);
      }
      *(_QWORD *)(a1 - 8) = 0LL;
    }
    if ( *(_BYTE *)(a1 + 24) )
    {
      v19 = *(_QWORD *)(a1 + 160);
      if ( *(_BYTE *)(v3 + 222) )
        sub_422B0(v19, (__int64)"Remote side closed network connection", a2, a3);
      else
        sub_42140(v19, (__int64)"Remote side unexpectedly closed network connection", a2, a3);
    }
  }
  return __readfsqword(0x28u) ^ v27;
}

_QWORD *__fastcall sub_48130(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_2F450(1uLL, 0x118uLL, 0LL);
  *v1 = 0LL;
  v1[34] = 0LL;
  memset(
    (void *)((unsigned __int64)(v1 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) & 0xFFFFFFF8) + 280) >> 3));
  v1[26] = a1;
  v2 = v1 + 7;
  *v2 = off_323FC0;
  sub_62760((__int64)(v1 + 7));
  return v2;
}

__int64 __fastcall sub_481A0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 result; // rax
  __int64 v4; // rdi
  __int64 v5; // rdi

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 176);
  if ( v2 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v2 + 8LL))();
  v4 = *(_QWORD *)(v1 + 168);
  if ( v4 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v4 + 8LL))();
  v5 = *(_QWORD *)(v1 + 208);
  if ( v5 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v5 + 24LL))();
  return result;
}

__int64 __fastcall sub_481F0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 result; // rax
  __int64 v4; // rdi
  __int64 v5; // rdi

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 136);
  if ( v2 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v2 + 8LL))();
  v4 = *(_QWORD *)(v1 + 128);
  if ( v4 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v4 + 8LL))();
  v5 = *(_QWORD *)(v1 + 200);
  if ( v5 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v5 + 48LL))();
  return result;
}

_QWORD *__fastcall sub_48240(int a1)
{
  __int64 v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_617D0();
  v2 = (_QWORD *)v1;
  *(_DWORD *)(v1 + 16) = a1;
  *(_QWORD *)(v1 + 8) = 5LL;
  *(_QWORD *)(v1 + 24) = 0LL;
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v1 + 96), a1);
  *v2 = v2[1];
  return v2;
}

void __fastcall sub_48290(__int64 a1)
{
  sub_2F4D0(*(void **)(a1 - 168));
  sub_481A0(a1 - 232);
  sub_481F0(a1 - 232);
  sub_2F4D0(*(void **)(a1 - 136));
  sub_2F4D0((void *)(a1 - 232));
}

void __usercall sub_482E0(_QWORD *a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rax
  __int64 v4; // rax
  char *v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rax
  char *v8; // rax

  v3 = a1[19];
  if ( v3 )
  {
    v4 = (*(__int64 (**)(void))(v3 + 40))();
    a1[25] = v4;
    v5 = sub_BC360((__int64)"Initialised delayed %s decompression", *(_QWORD *)(*(_QWORD *)v4 + 64LL));
    sub_2D3A0(a1[48], v5, a2, a3);
    a1[19] = 0LL;
  }
  v6 = a1[24];
  if ( v6 )
  {
    v7 = (*(__int64 (**)(void))(v6 + 16))();
    a1[26] = v7;
    v8 = sub_BC360((__int64)"Initialised delayed %s compression", *(_QWORD *)(*(_QWORD *)v7 + 64LL));
    sub_2D3A0(a1[48], v8, a2, a3);
    a1[24] = 0LL;
  }
}

unsigned __int64 __usercall sub_48370@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbx
  signed int v4; // eax
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rt1
  void *v7; // rax
  __int64 *v8; // rdi
  __int64 v9; // rax
  unsigned int v10; // ecx
  unsigned __int64 v11; // rcx
  signed __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rsi
  __int64 v15; // rdi
  __int64 v16; // rsi
  __int64 *v17; // rcx
  __int64 v18; // rsi
  unsigned int v19; // eax
  __int64 v20; // rdx
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rdx
  int v23; // er8
  size_t v24; // rsi
  __int64 v25; // rdi
  signed __int32 v26; // eax
  signed __int64 v27; // rcx
  __int64 v28; // rax
  _QWORD *v29; // rax
  __int64 (***v30)(void); // rdi
  __int64 v31; // rdi
  __int64 v32; // rax
  __int64 v33; // rdi
  __int64 v34; // rdx
  _QWORD *v35; // rax
  size_t v36; // rdx
  const void *v37; // rsi
  __int64 v38; // rdi
  __int64 (***v39)(void); // rdi
  signed __int64 v40; // rcx
  signed __int64 v41; // rdx
  signed __int64 v42; // rsi
  unsigned __int64 v43; // rdx
  __int64 v44; // rsi
  __int64 v45; // rdi
  signed __int64 v46; // rdx
  __int64 v47; // rsi
  __int64 v48; // rdi
  int v49; // eax
  __int64 v50; // rdx
  __int64 v51; // rcx
  void *v52; // rsi
  __int64 v53; // rcx
  __int64 v54; // r8
  bool v55; // zf
  unsigned int v56; // eax
  __int64 v57; // rbp
  unsigned __int64 v58; // r14
  const char *v59; // rax
  __int64 v60; // rdx
  __int64 *v61; // rsi
  __int64 v62; // rax
  int v63; // edx
  int v64; // eax
  void *v65; // rsi
  __int64 v66; // rdi
  signed __int32 v67; // eax
  __int64 v68; // rdx
  _QWORD *v69; // rax
  const void *v70; // rsi
  size_t v71; // rdx
  size_t v72; // rsi
  __int64 v73; // rdx
  unsigned int v74; // eax
  unsigned __int64 v75; // rdi
  __m128i *v76; // rbp
  _QWORD *v77; // rax
  __m128i v78; // xmm0
  __int64 v79; // rsi
  size_t v80; // rsi
  int v81; // [rsp+4h] [rbp-84h]
  void *src; // [rsp+8h] [rbp-80h]
  char v83; // [rsp+10h] [rbp-78h]
  unsigned int v84; // [rsp+44h] [rbp-44h]
  unsigned __int64 v85; // [rsp+48h] [rbp-40h]

  v3 = a1;
  v85 = __readfsqword(0x28u);
  v4 = *(_DWORD *)(a1 - 232);
  if ( v4 == 425 )
    goto LABEL_46;
  if ( v4 <= 425 )
  {
    if ( v4 == 329 )
    {
      v22 = *(_QWORD *)(a1 - 192);
      v7 = *(void **)(a1 - 168);
      goto LABEL_89;
    }
    if ( v4 <= 329 )
    {
      if ( !v4 )
        goto LABEL_29;
    }
    else
    {
      if ( v4 == 338 )
      {
        v12 = *(_QWORD *)(a1 - 200);
        goto LABEL_23;
      }
      if ( v4 == 381 )
      {
        v7 = *(void **)(a1 - 168);
        goto LABEL_15;
      }
    }
    goto LABEL_56;
  }
  if ( v4 == 491 )
    goto LABEL_60;
  if ( v4 <= 491 )
  {
    if ( v4 == 450 )
    {
      v24 = *(unsigned int *)(a1 - 144);
      v7 = *(void **)(a1 - 168);
      goto LABEL_39;
    }
    goto LABEL_56;
  }
  if ( v4 != 626 )
  {
    if ( v4 == 713 )
    {
LABEL_7:
      if ( !(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v3 + 80))(v3 + 32, v3 + 32, 0LL) )
      {
        v33 = *(_QWORD *)(v3 + 160);
        if ( *(_BYTE *)(v3 + 222) )
          sub_422B0(v33, (__int64)"Remote side closed network connection", a2, a3);
        else
          sub_42140(v33, (__int64)"Remote side unexpectedly closed network connection", a2, a3);
      }
      goto LABEL_8;
    }
LABEL_56:
    *(_DWORD *)(a1 - 232) = 0;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 - 15) )
    goto LABEL_8;
LABEL_29:
  while ( 1 )
  {
    v17 = *(__int64 **)(v3 - 104);
    *(_QWORD *)(v3 - 176) = 0LL;
    *(_QWORD *)(v3 - 184) = 0LL;
    if ( v17 )
    {
      v18 = *v17;
      v19 = *(_DWORD *)(*v17 + 72);
      *(_DWORD *)(v3 - 144) = v19;
      if ( v19 > 7 )
        break;
    }
    v20 = *(_QWORD *)(v3 - 96);
    *(_DWORD *)(v3 - 144) = 8;
    v21 = *(_QWORD *)(v3 - 160);
    v7 = *(void **)(v3 - 168);
    if ( !v20 )
      goto LABEL_100;
    v22 = *(signed int *)(*(_QWORD *)v20 + 64LL);
    v23 = v22;
    *(_QWORD *)(v3 - 192) = v22;
    if ( v17 )
    {
      v18 = *v17;
      goto LABEL_34;
    }
LABEL_35:
    if ( *(_BYTE *)(v3 - 88) )
      goto LABEL_93;
LABEL_36:
    v24 = *(unsigned int *)(v3 - 144);
    if ( v24 > v21 )
    {
      *(_QWORD *)(v3 - 160) = v24;
      v7 = sub_2F490(v7, v24, 1uLL);
      v24 = *(unsigned int *)(v3 - 144);
      *(_QWORD *)(v3 - 168) = v7;
    }
    *(_DWORD *)(v3 - 232) = 450;
LABEL_39:
    if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(v3 + 8), (char *)v7, v24) )
      goto LABEL_51;
    sub_41EF0(*(_QWORD **)(v3 + 160));
    v25 = *(_QWORD *)(v3 - 104);
    if ( v25 )
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v25 + 40LL))(
        v25,
        *(_QWORD *)(v3 - 168),
        *(unsigned int *)(v3 - 144));
    v26 = _byteswap_ulong(**(_DWORD **)(v3 - 168));
    *(_QWORD *)(v3 - 224) = v26;
    if ( (unsigned __int64)v26 > 0x9000 || (v27 = v26 + 4LL, v27 % *(unsigned int *)(v3 - 144)) )
    {
      sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Incoming packet was garbled on decryption", a2, a3);
      *(_DWORD *)(v3 - 232) = 0;
      goto LABEL_8;
    }
    *(_QWORD *)(v3 - 200) = v27;
    v34 = *(_QWORD *)(v3 - 192) + v27;
    *(_QWORD *)(v3 - 176) = v34;
    v35 = sub_2F450(1uLL, 0x58uLL, v34);
    v36 = *(unsigned int *)(v3 - 144);
    v37 = *(const void **)(v3 - 168);
    *(_QWORD *)(v3 - 136) = v35;
    v35[2] = 0LL;
    v35[3] = 0LL;
    *(_DWORD *)v35 = 0;
    *((_BYTE *)v35 + 40) = 0;
    *(_QWORD *)(v3 - 152) = v35 + 11;
    memcpy(v35 + 11, v37, v36);
    *(_DWORD *)(v3 - 232) = 491;
LABEL_60:
    if ( !(unsigned __int8)sub_BCFF0(
                             *(_QWORD *)(v3 + 8),
                             (char *)(*(_QWORD *)(v3 - 152) + *(unsigned int *)(v3 - 144)),
                             *(_QWORD *)(v3 - 200) + *(_QWORD *)(v3 - 192) - *(unsigned int *)(v3 - 144)) )
      goto LABEL_51;
    sub_41EF0(*(_QWORD **)(v3 + 160));
    v38 = *(_QWORD *)(v3 - 104);
    if ( v38 )
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v38 + 40LL))(
        v38,
        *(_QWORD *)(v3 - 152) + *(unsigned int *)(v3 - 144),
        (unsigned int)(*(_DWORD *)(v3 - 200) - *(_DWORD *)(v3 - 144)));
    v39 = *(__int64 (****)(void))(v3 - 96);
    v32 = *(_QWORD *)(v3 - 152);
    if ( v39 )
    {
      if ( !(unsigned __int8)sub_76DA0(v39, *(_QWORD *)(v3 - 152), *(_DWORD *)(v3 - 224) + 4, *(_QWORD *)(v3 - 112)) )
      {
        sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Incorrect MAC received on packet", a2, a3);
        *(_DWORD *)(v3 - 232) = 0;
        goto LABEL_8;
      }
      v32 = *(_QWORD *)(v3 - 152);
    }
LABEL_66:
    v40 = *(unsigned __int8 *)(v32 + 4);
    *(_QWORD *)(v3 - 216) = v40;
    if ( v40 <= 3 || (v41 = *(_QWORD *)(v3 - 224) - v40, v41 <= 0) )
    {
      sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Invalid padding length on received packet", a2, a3);
      *(_DWORD *)(v3 - 232) = 0;
      goto LABEL_8;
    }
    v42 = v41 - 1;
    *(_QWORD *)(v3 - 184) = v41 + 4;
    v43 = *(_QWORD *)(v3 - 200);
    *(_QWORD *)(v3 - 208) = v42;
    v44 = *(_QWORD *)(v3 - 128);
    if ( *(_BYTE *)v44 )
    {
      v75 = *(_QWORD *)(v44 + 8);
      if ( v43 >= v75 )
      {
        *(_BYTE *)v44 = 0;
        *(_BYTE *)(v44 + 1) = 1;
      }
      else
      {
        *(_QWORD *)(v44 + 8) = v75 - v43;
      }
    }
    v45 = *(_QWORD *)(v3 - 112);
    v46 = v43 - v40;
    *(_QWORD *)(v3 - 112) = v45 + 1;
    v47 = *(_QWORD *)(v3 - 136);
    *(_QWORD *)(v47 + 8) = v45;
    *(_QWORD *)(v3 - 184) = v46;
    if ( v46 < 0 )
      __assert_fail("s->length >= 0", "ssh2bpp.c", 0x20Fu, "ssh2_bpp_handle_input");
    v48 = *(_QWORD *)(v3 - 32);
    if ( v48 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD, void **, int *))(*(_QWORD *)v48 + 56LL))(
             v48,
             v32 + 5,
             (unsigned int)(v46 - 5),
             &src,
             &v81) )
      {
        v49 = v81;
        v50 = v81 + 5;
        if ( *(_QWORD *)(v3 - 176) < v50 )
        {
          v76 = *(__m128i **)(v3 - 136);
          *(_QWORD *)(v3 - 176) = v50;
          v77 = sub_2F450(1uLL, 0x58uLL, v50);
          v78 = _mm_loadu_si128(v76);
          *(_QWORD *)(v3 - 136) = v77;
          v79 = *(_QWORD *)(v3 - 192);
          v77 += 11;
          *(__m128i *)(v77 - 11) = v78;
          v80 = *(_QWORD *)(v3 - 200) + v79;
          *(__m128i *)(v77 - 9) = _mm_loadu_si128(v76 + 1);
          *(__m128i *)(v77 - 7) = _mm_loadu_si128(v76 + 2);
          *(__m128i *)(v77 - 5) = _mm_loadu_si128(v76 + 3);
          *(__m128i *)(v77 - 3) = _mm_loadu_si128(v76 + 4);
          *(v77 - 1) = v76[5].m128i_i64[0];
          *(_QWORD *)(v3 - 152) = v77;
          sub_BD070(v76, v80);
          sub_2F4D0(v76);
          v49 = v81;
          v50 = v81 + 5;
        }
        v51 = *(_QWORD *)(v3 - 152);
        v52 = src;
        *(_QWORD *)(v3 - 184) = v50;
        memcpy((void *)(v51 + 5), v52, v49);
        sub_2F4D0(src);
      }
      v46 = *(_QWORD *)(v3 - 184);
      v32 = *(_QWORD *)(v3 - 152);
      v47 = *(_QWORD *)(v3 - 136);
    }
    if ( v46 > 5 )
    {
      v54 = v46 - 6;
      *(_DWORD *)v47 = *(unsigned __int8 *)(v32 + 5);
      v53 = v32 + 6;
      *(_QWORD *)(v3 - 184) = v46 - 6;
      *(_QWORD *)(v3 - 152) = v32 + 6;
    }
    else
    {
      v53 = v32 + 5;
      *(_DWORD *)v47 = 256;
      v54 = 0LL;
      *(_QWORD *)(v3 - 184) = 0LL;
      *(_QWORD *)(v3 - 152) = v32 + 5;
    }
    v55 = *(_QWORD *)(v3 + 152) == 0LL;
    *(_QWORD *)(v47 + 48) = v53;
    *(_QWORD *)(v47 + 64) = v54;
    *(_QWORD *)(v47 + 56) = 0LL;
    *(_DWORD *)(v47 + 72) = 0;
    *(_QWORD *)(v47 + 80) = v47 + 48;
    if ( !v55 )
    {
      v56 = sub_49C80(*(_QWORD *)(v3 + 144), *(_DWORD *)v47, 0, v53, v54, &v83);
      v57 = *(_QWORD *)(v3 - 136);
      a3 = v56;
      v58 = *(_QWORD *)(v3 - 184);
      a2 = *(_QWORD *)(v3 - 152);
      v59 = sub_621E0(
              *(_DWORD *)(*(_QWORD *)(v3 + 144) + 4LL),
              *(_DWORD *)(*(_QWORD *)(v3 + 144) + 8LL),
              *(_DWORD *)v57);
      v60 = **(unsigned int **)(v3 - 136);
      sub_2D4B0((__int64)v59, *(_QWORD *)(v3 + 152), 0, a2, v58, a3, a3, (__int64)&v83, (__int64 *)(v57 + 8), 0, 0LL);
      v47 = *(_QWORD *)(v3 - 136);
    }
    if ( (unsigned __int8)sub_62870(v3, v47) )
    {
      sub_2F4D0(*(void **)(v3 - 136));
      *(_QWORD *)(v3 - 136) = 0LL;
    }
    else
    {
      v61 = *(__int64 **)(v3 - 136);
      v62 = v61[8] - v61[7];
      v61 += 2;
      v61[2] = v62;
      sub_614E0(v3 + 32, v61);
      v55 = *(_BYTE *)(v3 - 12) == 0;
      v63 = *(_DWORD *)(v3 - 4);
      v64 = **(_DWORD **)(v3 - 136);
      *(_QWORD *)(v3 - 136) = 0LL;
      *(_DWORD *)(v3 - 4) = v64;
      if ( v55 )
      {
        switch ( v64 )
        {
          case 21:
            v74 = *(_DWORD *)(v3 - 8);
            if ( v74 <= 1 )
              *(_DWORD *)(v3 - 8) = v74 + 1;
            *(_BYTE *)(v3 - 15) = 1;
            *(_DWORD *)(v3 - 232) = 626;
            goto LABEL_8;
          case 52:
            goto LABEL_84;
          case 7:
            if ( v63 != 21 || *(_DWORD *)(v3 - 8) != 1 )
            {
              if ( *(_BYTE *)(v3 - 16) )
              {
                sub_423C0(
                  *(_QWORD *)(v3 + 160),
                  (__int64)"Remote side sent SSH2_MSG_EXT_INFO that was not immediately after the initial NEWKEYS",
                  a2,
                  a3);
                goto LABEL_8;
              }
              if ( *(_DWORD *)(v3 - 8) && *(_BYTE *)(v3 - 13) )
                goto LABEL_133;
              *(_BYTE *)(v3 - 12) = 1;
            }
            break;
          default:
            if ( *(_BYTE *)(v3 - 14) && (unsigned int)(v64 - 50) <= 0x13 )
              goto LABEL_87;
            break;
        }
      }
      else
      {
        if ( v64 != 52 )
        {
          sub_423C0(
            *(_QWORD *)(v3 + 160),
            (__int64)"Remote side sent SSH2_MSG_EXT_INFO not either preceded by NEWKEYS or followed by USERAUTH_SUCCESS",
            a2,
            a3);
          goto LABEL_8;
        }
        *(_BYTE *)(v3 - 12) = 0;
LABEL_84:
        if ( !*(_BYTE *)(v3 - 16) )
        {
          sub_482E0((_QWORD *)(v3 - 232), a2, a3);
          *(_BYTE *)(v3 - 13) = 1;
        }
        if ( *(_BYTE *)(v3 - 14) )
        {
LABEL_87:
          *(_BYTE *)(v3 - 14) = 0;
          sub_1BE20(v3 + 192);
        }
      }
    }
  }
  v73 = *(_QWORD *)(v3 - 96);
  v21 = *(_QWORD *)(v3 - 160);
  v7 = *(void **)(v3 - 168);
  if ( !v73 )
  {
LABEL_100:
    *(_QWORD *)(v3 - 192) = 0LL;
    goto LABEL_36;
  }
  v22 = *(signed int *)(*(_QWORD *)v73 + 64LL);
  v23 = v22;
  *(_QWORD *)(v3 - 192) = v22;
LABEL_34:
  if ( !(*(_BYTE *)(v18 + 84) & 1) )
    goto LABEL_35;
  if ( *(_BYTE *)(v3 - 88) )
  {
LABEL_93:
    if ( v21 <= 3 )
    {
      *(_QWORD *)(v3 - 160) = 4LL;
      v7 = sub_2F490(v7, 4uLL, 1uLL);
      *(_QWORD *)(v3 - 168) = v7;
    }
    *(_DWORD *)(v3 - 232) = 381;
LABEL_15:
    if ( !(unsigned __int8)sub_BCFF0(*(_QWORD *)(v3 + 8), (char *)v7, 4uLL) )
      goto LABEL_51;
    sub_41EF0(*(_QWORD **)(v3 + 160));
    v8 = *(__int64 **)(v3 - 104);
    if ( v8 )
    {
      v9 = *v8;
      v10 = **(_DWORD **)(v3 - 168);
      if ( *(_BYTE *)(*v8 + 84) & 2 )
      {
        v84 = **(_DWORD **)(v3 - 168);
        (*(void (__fastcall **)(__int64 *, unsigned int *, signed __int64, _QWORD))(v9 + 56))(
          v8,
          &v84,
          4LL,
          *(_QWORD *)(v3 - 112));
        v11 = (signed int)_byteswap_ulong(v84);
        *(_QWORD *)(v3 - 224) = (signed int)v11;
        goto LABEL_19;
      }
    }
    else
    {
      v10 = **(_DWORD **)(v3 - 168);
    }
    v11 = (signed int)_byteswap_ulong(v10);
    *(_QWORD *)(v3 - 224) = (signed int)v11;
LABEL_19:
    if ( v11 > 0x9000 || (signed __int64)v11 % *(unsigned int *)(v3 - 144) )
    {
      sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Incoming packet length field was garbled", a2, a3);
      *(_DWORD *)(v3 - 232) = 0;
      goto LABEL_8;
    }
    v28 = *(_QWORD *)(v3 - 192);
    *(_QWORD *)(v3 - 200) = v11 + 4;
    v29 = sub_2F450(1uLL, 0x58uLL, v28 + 36864);
    *(_QWORD *)(v3 - 136) = v29;
    v29[2] = 0LL;
    v29[3] = 0LL;
    *(_DWORD *)v29 = 0;
    *((_BYTE *)v29 + 40) = 0;
    *(_QWORD *)(v3 - 152) = v29 + 11;
    *((_DWORD *)v29 + 22) = **(_DWORD **)(v3 - 168);
    *(_DWORD *)(v3 - 232) = 425;
LABEL_46:
    if ( !(unsigned __int8)sub_BCFF0(
                             *(_QWORD *)(v3 + 8),
                             (char *)(*(_QWORD *)(v3 - 152) + 4LL),
                             *(_QWORD *)(v3 - 200) + *(_QWORD *)(v3 - 192) - 4LL) )
      goto LABEL_51;
    sub_41EF0(*(_QWORD **)(v3 + 160));
    v30 = *(__int64 (****)(void))(v3 - 96);
    if ( v30
      && !(unsigned __int8)sub_76DA0(v30, *(_QWORD *)(v3 - 152), *(_DWORD *)(v3 - 224) + 4, *(_QWORD *)(v3 - 112)) )
    {
      sub_42500(*(_QWORD *)(v3 + 160), (__int64)"Incorrect MAC received on packet", a2, a3);
      *(_DWORD *)(v3 - 232) = 0;
      goto LABEL_8;
    }
    v31 = *(_QWORD *)(v3 - 104);
    v32 = *(_QWORD *)(v3 - 152);
    if ( v31 )
    {
      (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v31 + 40LL))(
        v31,
        v32 + 4,
        (unsigned int)(*(_DWORD *)(v3 - 200) - 4));
      v32 = *(_QWORD *)(v3 - 152);
    }
    goto LABEL_66;
  }
  v72 = (unsigned int)(v23 + 36864);
  if ( v72 > v21 )
  {
    *(_QWORD *)(v3 - 160) = v72;
    v7 = sub_2F490(v7, v72, 1uLL);
    v22 = *(_QWORD *)(v3 - 192);
    *(_QWORD *)(v3 - 168) = v7;
  }
  *(_DWORD *)(v3 - 232) = 329;
LABEL_89:
  v65 = v7;
  if ( (unsigned __int8)sub_BCFF0(*(_QWORD *)(v3 + 8), (char *)v7, v22) )
  {
    sub_41EF0(*(_QWORD **)(v3 + 160));
    v66 = *(_QWORD *)(v3 - 96);
    *(_QWORD *)(v3 - 200) = 0LL;
    (*(void (__fastcall **)(__int64, void *))(*(_QWORD *)v66 + 24LL))(v66, v65);
    sub_2ED90(
      *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 96) + 8LL),
      *(_QWORD *)(v3 - 112));
    v12 = *(_QWORD *)(v3 - 200);
    while ( 1 )
    {
      *(_DWORD *)(v3 - 232) = 338;
LABEL_23:
      if ( !(unsigned __int8)sub_BCFF0(
                               *(_QWORD *)(v3 + 8),
                               (char *)(*(_QWORD *)(v3 - 168) + *(_QWORD *)(v3 - 192) + v12),
                               *(unsigned int *)(v3 - 144)) )
        break;
      sub_41EF0(*(_QWORD **)(v3 + 160));
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v3 - 104) + 40LL))(
        *(_QWORD *)(v3 - 104),
        *(_QWORD *)(v3 - 168) + *(_QWORD *)(v3 - 200),
        *(unsigned int *)(v3 - 144));
      v13 = *(unsigned int *)(v3 - 144);
      v14 = *(_QWORD *)(v3 - 168) + *(_QWORD *)(v3 - 200);
      sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v3 - 96) + 8LL));
      v15 = *(_QWORD *)(v3 - 96);
      v16 = *(_QWORD *)(v3 - 200) + *(unsigned int *)(v3 - 144);
      *(_QWORD *)(v3 - 200) = v16;
      if ( (unsigned __int8)sub_76CB0(v15, *(_QWORD *)(v3 - 168) + v16) )
      {
        v12 = *(_QWORD *)(v3 - 200);
        v67 = _byteswap_ulong(**(_DWORD **)(v3 - 168));
        *(_QWORD *)(v3 - 224) = v67;
        if ( v67 == v12 - 4 )
        {
          v68 = v12 + *(_QWORD *)(v3 - 192);
          *(_QWORD *)(v3 - 176) = v68;
          v69 = sub_2F450(1uLL, 0x58uLL, v68);
          v70 = *(const void **)(v3 - 168);
          v71 = *(_QWORD *)(v3 - 176);
          *(_QWORD *)(v3 - 136) = v69;
          v69[2] = 0LL;
          v69[3] = 0LL;
          *(_DWORD *)v69 = 0;
          *((_BYTE *)v69 + 40) = 0;
          *(_QWORD *)(v3 - 152) = v69 + 11;
          memcpy(v69 + 11, v70, v71);
          v32 = *(_QWORD *)(v3 - 152);
          goto LABEL_66;
        }
      }
      else
      {
        v12 = *(_QWORD *)(v3 - 200);
      }
      if ( v12 > 36863 )
      {
        sub_42500(*(_QWORD *)(v3 + 160), (__int64)"No valid incoming packet found", a2, a3);
        *(_DWORD *)(v3 - 232) = 0;
        goto LABEL_8;
      }
    }
  }
LABEL_51:
  if ( *(_BYTE *)(v3 + 24) )
  {
    *(_DWORD *)(v3 - 232) = 713;
    goto LABEL_7;
  }
LABEL_8:
  while ( 1 )
  {
    v6 = __readfsqword(0x28u);
    result = v6 ^ v85;
    if ( v6 == v85 )
      break;
LABEL_133:
    sub_423C0(*(_QWORD *)(v3 + 160), (__int64)"Remote side sent SSH2_MSG_EXT_INFO after USERAUTH_SUCCESS", a2, a3);
  }
  return result;
}

unsigned __int64 __fastcall sub_490D0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 *v3; // rbp
  unsigned __int64 v4; // r13
  unsigned __int64 v5; // r13
  __int64 v6; // r14
  __int64 v7; // r15
  __int64 v8; // ST38_8
  int v9; // ST30_4
  const char *v10; // rax
  __int64 v11; // rdx
  __int64 *v12; // rax
  unsigned __int64 v13; // r14
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  unsigned __int64 v19; // rax
  signed int v20; // ebx
  int v21; // er15
  char *v22; // rdi
  unsigned int v23; // ebx
  _BYTE *v24; // rax
  __int64 v25; // rdi
  __int64 (***v26)(void); // rdi
  __int64 v27; // rsi
  __int64 v28; // rax
  __int64 v29; // rdi
  __int64 v30; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // [rsp+0h] [rbp-98h]
  int v34; // [rsp+14h] [rbp-84h]
  void *v35; // [rsp+18h] [rbp-80h]
  char v36; // [rsp+20h] [rbp-78h]
  unsigned __int64 v37; // [rsp+58h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a2 + 8);
  v37 = __readfsqword(0x28u);
  if ( a1[48] )
  {
    v5 = v4 - *(_QWORD *)a2;
    v6 = *(_QWORD *)(a2 + 32) + *(_QWORD *)a2;
    v7 = (unsigned int)sub_49C80(a1[47], *(_DWORD *)(a2 + 16), 1, v6, v5, &v36);
    v8 = *(_QWORD *)(a2 + 56);
    v9 = *(_DWORD *)(a2 + 48);
    v10 = sub_621E0(*(_DWORD *)(a1[47] + 4), *(_DWORD *)(a1[47] + 8), *(_DWORD *)(a2 + 16));
    v11 = *(unsigned int *)(a2 + 16);
    sub_2D4B0((__int64)v10, a1[48], 1u, v6, v5, v7, v7, (__int64)&v36, a1 + 20, v9, v8);
    v4 = *(_QWORD *)(a2 + 8);
  }
  v12 = (__int64 *)a1[21];
  v13 = 8LL;
  if ( v12 )
  {
    v14 = *v12;
    if ( *(_DWORD *)(v14 + 72) >= 8 )
      LODWORD(v13) = *(_DWORD *)(v14 + 72);
    v13 = (signed int)v13;
  }
  v15 = a1[26];
  if ( v15 )
  {
    v16 = (unsigned int)*(_QWORD *)(a2 + 24);
    if ( (unsigned int)*(_QWORD *)(a2 + 24) )
    {
      v17 = v3[22];
      if ( v17 )
        LODWORD(v16) = v16 - *(_DWORD *)(*(_QWORD *)v17 + 64LL);
      v16 = (unsigned int)(v16 - 8);
    }
    (*(void (__fastcall **)(__int64, signed __int64, _QWORD, void **, int *, __int64))(*(_QWORD *)v15 + 32LL))(
      v15,
      *(_QWORD *)(a2 + 32) + 5LL,
      (unsigned int)(v4 - 5),
      &v35,
      &v34,
      v16);
    *(_QWORD *)(a2 + 8) = 5LL;
    sub_2EC20((__int64 (**)(void))(a2 + 96));
    sub_2F4D0(v35);
    v4 = *(_QWORD *)(a2 + 8);
  }
  v18 = v3[22];
  if ( v18 )
  {
    v19 = v4;
    if ( !*((_BYTE *)v3 + 184) )
      v19 = v4 + 4;
    v20 = (v13 - v19 % v13) % v13 + 4;
    if ( v20 <= 255 )
    {
      v33 = *(signed int *)(*(_QWORD *)v18 + 64LL);
      goto LABEL_18;
    }
LABEL_39:
    __assert_fail("padding <= 255", "ssh2bpp.c", 0x318u, "ssh2_bpp_format_packet_inner");
  }
  v20 = (v13 - (v4 + 4) % v13) % v13 + 4;
  if ( v20 > 255 )
    goto LABEL_39;
  v33 = 0LL;
LABEL_18:
  if ( v20 > 0 )
  {
    v21 = 0;
    do
    {
      ++v21;
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a2 + 96), 0);
    }
    while ( v21 != v20 );
  }
  v22 = (char *)(*(_QWORD *)(a2 + 32) + (signed int)v4);
  LODWORD(v4) = v20 + v4;
  sub_7BF50(v22, v20);
  *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = v20;
  v23 = v4 - 4;
  v24 = *(_BYTE **)(a2 + 32);
  v24[3] = v4 - 4;
  v24[2] = BYTE1(v23);
  v24[1] = (unsigned int)(v4 - 4) >> 16;
  *v24 = (unsigned int)(v4 - 4) >> 24;
  v25 = v3[21];
  if ( v25 && *(_BYTE *)(*(_QWORD *)v25 + 84LL) & 2 )
    (*(void (__fastcall **)(__int64, _QWORD, signed __int64, __int64))(*(_QWORD *)v25 + 48LL))(
      v25,
      *(_QWORD *)(a2 + 32),
      4LL,
      v3[20]);
  sub_2EC40((void (__fastcall **)(_QWORD, __int64 *, signed __int64))(a2 + 96), v33, 0);
  v26 = (__int64 (***)(void))v3[22];
  if ( v26 )
  {
    v27 = *(_QWORD *)(a2 + 32);
    if ( *((_BYTE *)v3 + 184) )
    {
      v28 = v3[21];
      if ( v28 )
      {
        (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v28 + 32LL))(v3[21], v27 + 4, v23);
        v27 = *(_QWORD *)(v2 + 32);
        v26 = (__int64 (***)(void))v3[22];
      }
      sub_76D40(v26, v27, v4, v3[20]);
      goto LABEL_32;
    }
    sub_76D40(v26, v27, v4, v3[20]);
  }
  v29 = v3[21];
  if ( v29 )
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v29 + 32LL))(
      v29,
      *(_QWORD *)(v2 + 32),
      (unsigned int)v4);
LABEL_32:
  v30 = v3[13];
  ++v3[20];
  if ( *(_BYTE *)(v30 + 16) )
  {
    v32 = *(_QWORD *)(v30 + 24);
    v4 = (signed int)v4;
    if ( (signed int)v4 >= v32 )
    {
      *(_BYTE *)(v30 + 16) = 0;
      *(_BYTE *)(v30 + 17) = 1;
    }
    else
    {
      *(_QWORD *)(v30 + 24) = v32 - v4;
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

void __fastcall sub_49460(__int64 *a1, __int64 a2)
{
  __int64 *v2; // rbp
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 *v5; // rax
  __int64 v6; // rax
  signed int v7; // edi
  int v8; // edx
  __int64 v9; // rax
  int v10; // esi
  int v11; // eax
  int v12; // esi
  signed int v13; // edx
  size_t v14; // r12
  _QWORD *v15; // r13
  __int64 v16; // r15
  __int64 v17; // [rsp+0h] [rbp-48h]
  signed int v18; // [rsp+Ch] [rbp-3Ch]

  v2 = a1;
  v3 = a2;
  v4 = *(_QWORD *)(a2 + 24);
  if ( v4 && !a1[26] )
  {
    v5 = (__int64 *)a1[21];
    if ( v5 )
    {
      v6 = *v5;
      v7 = 8;
      if ( *(_DWORD *)(v6 + 72) >= 8 )
        v7 = *(_DWORD *)(v6 + 72);
      v8 = v7 - 1;
    }
    else
    {
      v8 = 7;
      v7 = 8;
    }
    v9 = v2[22];
    v10 = v8 + *(_DWORD *)(a2 + 8) + 4 - (v8 + *(_DWORD *)(a2 + 8) + 4) % v7;
    if ( v9 )
    {
      v11 = *(_DWORD *)(*(_QWORD *)v9 + 64LL);
      v12 = v11 + v10;
      if ( v4 <= v12 )
        goto LABEL_3;
      v13 = v4 - v12 - v11;
    }
    else
    {
      v13 = v4 - v10;
      if ( v4 <= v10 )
        goto LABEL_3;
    }
    LODWORD(v14) = v13 - 13;
    v18 = v13;
    v15 = sub_48240(2);
    if ( (v14 & 0x80000000) != 0LL )
      LODWORD(v14) = 0;
    v14 = (signed int)v14;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v15 + 12, v14);
    v17 = v15[1];
    if ( v18 > 13 )
    {
      v16 = 0LL;
      do
      {
        ++v16;
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v15 + 12, 0);
      }
      while ( v14 != v16 );
    }
    sub_7BF50((char *)(v15[4] + v17), v14);
    sub_490D0(v2, (__int64)v15);
    sub_BCD20(v2[31], (char *)v15[4], v15[1]);
    sub_61840((void **)v15);
  }
LABEL_3:
  sub_490D0(v2, v3);
  sub_BCD20(v2[31], *(char **)(v3 + 32), *(_QWORD *)(v3 + 8));
}

void __fastcall sub_495E0(__int64 a1)
{
  __int64 v1; // r13
  __int64 *v2; // r14
  __int64 v3; // rax
  int v4; // ebp
  bool v5; // al
  __int64 v6; // rax
  void **v7; // rbx
  __int64 v8; // r15
  __int64 v9; // rbx

  v1 = a1 + 88;
  v2 = (__int64 *)(a1 - 232);
  v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 136))(a1 + 88, a1 + 88, 0LL);
  if ( v3 )
  {
    v4 = 0;
    do
    {
      v4 += (unsigned int)(*(_DWORD *)(v3 + 16) - 50) < 0x14;
      v3 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 136))(v1, v3 + 64, 0LL);
    }
    while ( v3 );
    v5 = v4 == 0;
  }
  else
  {
    v5 = 1;
    v4 = 0;
  }
  if ( !*(_BYTE *)(a1 - 14) || !v5 )
  {
    if ( *(_BYTE *)(a1 - 120)
      && sub_BCD00(*(_QWORD *)(a1 + 16)) < (unsigned __int64)(*(_DWORD *)(**(_QWORD **)(a1 - 64) + 72LL)
                                                            + *(_DWORD *)(**(_QWORD **)(a1 - 56) + 64LL)) )
    {
      v9 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)a1 + 24LL))(2LL);
      sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v9 + 96), &locale);
      sub_49460(v2, v9);
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(a1 + 136))(v1, v1, 1LL);
        v7 = (void **)v6;
        if ( !v6 )
          return;
        v8 = *(unsigned int *)(v6 + 16);
        v4 -= (unsigned int)(v8 - 50) < 0x14;
        sub_49460(v2, v6);
        sub_61840(v7);
        if ( !v4 )
        {
          if ( *(_QWORD *)(a1 - 40) )
            break;
        }
        if ( (_DWORD)v8 == 52 && *(_BYTE *)(a1 - 16) )
          goto LABEL_13;
      }
      if ( !*(_BYTE *)(a1 - 16) )
      {
        *(_BYTE *)(a1 - 14) = 1;
        return;
      }
      if ( (_DWORD)v8 == 52 )
LABEL_13:
        sub_482E0(v2, v1, v8);
    }
  }
}

signed __int64 __fastcall sub_49760(__int64 a1, __int64 a2, char a3)
{
  char v3; // bl
  _QWORD *v4; // rax
  signed __int64 v5; // rbx

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x1C8uLL, 0LL);
  *v4 = 0LL;
  v4[56] = 0LL;
  memset(
    (void *)((unsigned __int64)(v4 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v4 - (((_DWORD)v4 + 8) & 0xFFFFFFF8) + 456) >> 3));
  *((_BYTE *)v4 + 216) = v3;
  v5 = (signed __int64)(v4 + 29);
  v4[48] = a1;
  v4[13] = a2;
  v4[29] = off_324000;
  sub_62760((__int64)(v4 + 29));
  return v5;
}

void __fastcall sub_497F0(__int64 (__fastcall ***a1)(), char *a2, __int64 a3, __int64 a4, __int64 a5, char a6, __int64 a7, __int64 a8, unsigned int a9)
{
  __int64 (__fastcall ***v9)(); // r15
  __int64 (__fastcall ***v10)(); // rdi
  __int64 v11; // r14
  __int64 v12; // rbx
  char v13; // bp
  __int64 (__fastcall **v14)(); // rax
  __int64 (__fastcall *v15)(); // rdx
  __int64 v16; // rdx
  char v17; // al
  __int64 v18; // rsi
  char *v19; // rax
  char *v20; // r14
  __int64 (__fastcall **v21)(); // rax
  __int64 (__fastcall *v22)(); // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  char *v25; // rbx
  __int64 v26; // rax
  char *v27; // rax
  __int64 v28; // rax
  const char *v29; // rdi
  __int64 v30; // rsi
  char *v31; // rax
  __int64 v32; // [rsp+10h] [rbp-48h]

  v32 = a3;
  if ( *a1 != off_324000 )
    __assert_fail("bpp->vt == &ssh2_bpp_vtable", "ssh2bpp.c", 0x79u, "ssh2_bpp_new_outgoing_crypto");
  v9 = a1;
  v10 = a1 - 29;
  v11 = a4;
  v12 = a5;
  v13 = a6;
  sub_481A0((__int64)v10);
  if ( a2 )
  {
    v14 = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(char *))a2)(a2);
    v15 = *v14;
    *(v9 - 8) = v14;
    (*((void (__fastcall **)(__int64 (__fastcall **)(), __int64))v15 + 3))(v14, v32);
    (*((void (__fastcall **)(_QWORD, __int64))**(v9 - 8) + 2))(*(v9 - 8), v11);
    v16 = (__int64)**(v9 - 8);
    v17 = 0;
    if ( *(_BYTE *)(v16 + 84) & 1 )
      v17 = ((*((_DWORD *)v9 + 54) >> 9) ^ 1) & 1;
    v18 = *(_QWORD *)(v16 + 88);
    *((_BYTE *)v9 - 120) = v17;
    v19 = sub_BC360((__int64)"Initialised %s outbound encryption", v18);
    v10 = (__int64 (__fastcall ***)())v9[19];
    a2 = v19;
    sub_2D3A0((__int64)v10, v19, a9, (__int64)v9);
  }
  else
  {
    *(v9 - 8) = 0LL;
    *((_BYTE *)v9 - 120) = 0;
  }
  *((_BYTE *)v9 - 48) = v13;
  if ( v12 )
  {
    v20 = &locale;
    v21 = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(__int64, _QWORD))v12)(v12, *(v9 - 8));
    v22 = *v21;
    v23 = *(signed int *)(v12 + 68);
    *(v9 - 7) = v21;
    (*((void (__fastcall **)(__int64 (__fastcall **)(), __int64, __int64))v22 + 2))(v21, a7, v23);
    v24 = (__int64)*(v9 - 8);
    if ( v24 && *(_QWORD *)(*(_QWORD *)v24 + 96LL) )
      v20 = " (required by cipher)";
    v25 = &locale;
    if ( v13 )
      v25 = " (in ETM mode)";
    v26 = (*((__int64 (**)(void))**(v9 - 7) + 5))();
    v27 = sub_BC360((__int64)"Initialised %s outbound MAC algorithm%s%s", v26, v25, v20);
    v10 = (__int64 (__fastcall ***)())v9[19];
    a2 = v27;
    sub_2D3A0((__int64)v10, v27, a9, (__int64)v9);
  }
  else
  {
    *(v9 - 7) = 0LL;
  }
  if ( (_BYTE)a9 && !*((_BYTE *)v9 - 13) )
  {
    *(v9 - 5) = (__int64 (__fastcall **)())a8;
    *(v9 - 3) = 0LL;
    v29 = "Will enable %s compression after user authentication";
    v30 = *(_QWORD *)(a8 + 64);
    goto LABEL_16;
  }
  *(v9 - 5) = 0LL;
  v28 = (*(__int64 (__fastcall **)(__int64 (__fastcall ***)(), char *))(a8 + 16))(v10, a2);
  *(v9 - 3) = (__int64 (__fastcall **)())v28;
  if ( v28 )
  {
    v29 = "Initialised %s compression";
    v30 = *(_QWORD *)(*(_QWORD *)v28 + 64LL);
LABEL_16:
    v31 = sub_BC360((__int64)v29, v30);
    sub_2D3A0((__int64)v9[19], v31, a9, (__int64)v9);
  }
}

_QWORD *__fastcall sub_49A30(__int64 (__fastcall ***a1)(), char *a2, __int64 a3, __int64 a4, __int64 a5, char a6, __int64 a7, __int64 a8, unsigned int a9)
{
  __int64 (__fastcall ***v9)(); // r15
  __int64 (__fastcall ***v10)(); // rdi
  __int64 v11; // r14
  __int64 v12; // rbx
  char v13; // bp
  __int64 (__fastcall **v14)(); // rax
  __int64 (__fastcall *v15)(); // rdx
  char *v16; // rax
  char *v17; // r14
  __int64 (__fastcall **v18)(); // rax
  __int64 (__fastcall *v19)(); // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  char *v22; // rbx
  __int64 v23; // rax
  char *v24; // rax
  __int64 v25; // rax
  const char *v26; // rdi
  __int64 v27; // rsi
  char *v28; // rax
  __int64 v30; // [rsp+10h] [rbp-48h]

  v30 = a3;
  if ( *a1 != off_324000 )
    __assert_fail("bpp->vt == &ssh2_bpp_vtable", "ssh2bpp.c", 0xB7u, "ssh2_bpp_new_incoming_crypto");
  v9 = a1;
  v10 = a1 - 29;
  v11 = a4;
  v12 = a5;
  v13 = a6;
  sub_481F0((__int64)v10);
  if ( a2 )
  {
    v14 = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(char *))a2)(a2);
    v15 = *v14;
    *(v9 - 13) = v14;
    (*((void (__fastcall **)(__int64 (__fastcall **)(), __int64))v15 + 3))(v14, v30);
    (*((void (__fastcall **)(_QWORD, __int64))**(v9 - 13) + 2))(*(v9 - 13), v11);
    v16 = sub_BC360((__int64)"Initialised %s inbound encryption", *((_QWORD *)**(v9 - 13) + 11));
    v10 = (__int64 (__fastcall ***)())v9[19];
    a2 = v16;
    sub_2D3A0((__int64)v10, v16, a9, (__int64)v9);
  }
  else
  {
    *(v9 - 13) = 0LL;
  }
  *((_BYTE *)v9 - 88) = v13;
  if ( v12 )
  {
    v17 = &locale;
    v18 = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(__int64, _QWORD))v12)(v12, *(v9 - 13));
    v19 = *v18;
    v20 = *(signed int *)(v12 + 68);
    *(v9 - 12) = v18;
    (*((void (__fastcall **)(__int64 (__fastcall **)(), __int64, __int64))v19 + 2))(v18, a7, v20);
    v21 = (__int64)*(v9 - 13);
    if ( v21 && *(_QWORD *)(*(_QWORD *)v21 + 96LL) )
      v17 = " (required by cipher)";
    v22 = " (in ETM mode)";
    if ( !v13 )
      v22 = &locale;
    v23 = (*((__int64 (**)(void))**(v9 - 12) + 5))();
    v24 = sub_BC360((__int64)"Initialised %s inbound MAC algorithm%s%s", v23, v22, v17);
    v10 = (__int64 (__fastcall ***)())v9[19];
    a2 = v24;
    sub_2D3A0((__int64)v10, v24, a9, (__int64)v9);
  }
  else
  {
    *(v9 - 12) = 0LL;
  }
  if ( (_BYTE)a9 && !*((_BYTE *)v9 - 13) )
  {
    *(v9 - 10) = (__int64 (__fastcall **)())a8;
    *(v9 - 4) = 0LL;
    v26 = "Will enable %s decompression after user authentication";
    v27 = *(_QWORD *)(a8 + 64);
    goto LABEL_14;
  }
  *(v9 - 10) = 0LL;
  v25 = (*(__int64 (__fastcall **)(__int64 (__fastcall ***)(), char *))(a8 + 40))(v10, a2);
  *(v9 - 4) = (__int64 (__fastcall **)())v25;
  if ( v25 )
  {
    v26 = "Initialised %s decompression";
    v27 = *(_QWORD *)(*(_QWORD *)v25 + 64LL);
LABEL_14:
    v28 = sub_BC360((__int64)v26, v27);
    sub_2D3A0((__int64)v9[19], v28, a9, (__int64)v9);
  }
  *((_BYTE *)v9 - 15) = 0;
  return sub_1BE20((__int64)(v9 + 21));
}

__int64 __fastcall sub_49C40(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_324000 )
    __assert_fail("bpp->vt == &ssh2_bpp_vtable", "ssh2bpp.c", 0xF4u, "ssh2_bpp_rekey_inadvisable");
  return *((unsigned __int8 *)a1 - 14);
}

__int64 __fastcall sub_49C80(__int64 a1, signed int a2, char a3, __int64 a4, __int64 a5, _DWORD *a6)
{
  char v6; // r12
  bool v7; // zf
  signed int v8; // ebp
  _DWORD *v10; // r9
  int v11; // edx
  int v12; // eax
  char *v13; // rax
  size_t v14; // rdx
  int v15; // edx
  __int64 v16; // rdi
  int v17; // ecx
  __int64 v18; // rax
  signed __int64 v19; // rbx
  int v20; // edx
  _DWORD *v21; // rax
  char *v22; // rax
  size_t v23; // rdx
  int v24; // edx
  signed __int64 v25; // rax
  _DWORD *v26; // rax
  _DWORD *v27; // ST00_8
  __int64 v28; // rdi
  _DWORD *v29; // rbx
  int v30; // eax
  _DWORD *v31; // [rsp+0h] [rbp-58h]
  _DWORD *v32; // [rsp+0h] [rbp-58h]
  _DWORD *v33; // [rsp+8h] [rbp-50h]
  _DWORD *v34; // [rsp+8h] [rbp-50h]
  __int64 v35; // [rsp+10h] [rbp-48h]
  __int64 v36; // [rsp+18h] [rbp-40h]
  __int64 v37; // [rsp+20h] [rbp-38h]
  int v38; // [rsp+28h] [rbp-30h]
  __int64 *v39; // [rsp+30h] [rbp-28h]
  unsigned __int64 v40; // [rsp+38h] [rbp-20h]

  v6 = a3;
  v40 = __readfsqword(0x28u);
  v7 = *(_BYTE *)(a1 + 1) == 0;
  v35 = a4;
  v37 = a5;
  v36 = 0LL;
  v38 = 0;
  v39 = &v35;
  if ( v7 || (unsigned int)(a2 - 94) > 1 )
    goto LABEL_27;
  v33 = a6;
  sub_2F150((__int64)&v35);
  v10 = v33;
  if ( a2 == 95 )
  {
    sub_2F150((__int64)v39);
    v10 = v33;
    a2 = 95;
  }
  v34 = v10;
  sub_2F1D0((__int64)v39);
  a6 = v34;
  if ( *((_DWORD *)v39 + 6) )
  {
LABEL_27:
    v8 = 0;
  }
  else
  {
    v12 = v36;
    v34[2] = 2;
    v8 = 1;
    v34[1] = v11;
    *v34 = v12 - v11;
  }
  if ( v6 && *(_BYTE *)a1 )
  {
    if ( a2 == 50 )
    {
      v31 = a6;
      sub_2F1D0((__int64)v39);
      sub_2F1D0((__int64)v39);
      v13 = sub_2F1D0((__int64)v39);
      if ( (unsigned __int8)sub_BD100(v13, v14, "password") )
      {
        sub_2F0C0((__int64)v39);
        sub_2F1D0((__int64)v39);
        v16 = (__int64)v39;
        v17 = v15;
        if ( !*((_DWORD *)v39 + 6) )
        {
          v18 = v8++;
          v19 = 3 * v18;
          v20 = v36 - v15;
          v21 = &v31[3 * v18];
          v21[1] = v17;
          *v21 = v20;
          v21[2] = 1;
          sub_2F1D0(v16);
          if ( !*((_DWORD *)v39 + 6) )
            v31[v19 + 1] = v36 - v31[v19 + 3];
        }
      }
    }
    else if ( *(_DWORD *)(a1 + 8) == 4 && a2 == 61 )
    {
      v27 = a6;
      sub_2F150((__int64)v39);
      v28 = (__int64)v39;
      v29 = &v27[3 * v8];
      v30 = v36;
      v29[2] = 1;
      *v29 = v30;
      do
      {
        sub_2F1D0(v28);
        v28 = (__int64)v39;
      }
      while ( !*((_DWORD *)v39 + 6) );
      ++v8;
      v29[1] = v36 - *v29;
    }
    else if ( a2 == 98 )
    {
      v32 = a6;
      sub_2F150((__int64)v39);
      v22 = sub_2F1D0((__int64)v39);
      if ( (unsigned __int8)sub_BD100(v22, v23, "x11-req") )
      {
        sub_2F0C0((__int64)v39);
        sub_2F0C0((__int64)v39);
        sub_2F1D0((__int64)v39);
        sub_2F1D0((__int64)v39);
        if ( !*((_DWORD *)v39 + 6) )
        {
          v25 = 3LL * v8++;
          v26 = &v32[v25];
          *v26 = v36 - v24;
          v26[2] = 1;
          v26[1] = v24;
        }
      }
    }
  }
  return (unsigned int)v8;
}

__int64 __fastcall sub_49F70(__int64 a1, _DWORD *a2)
{
  _BOOL4 v2; // eax

  v2 = 0;
  if ( a2 )
    v2 = *a2 == 99;
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 168) + 168LL))(
           *(_QWORD *)(a1 + 168),
           (unsigned int)v2);
}

void __usercall sub_49FA0(__int64 a1@<rdx>, _QWORD *a2@<rdi>, _DWORD *a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  __int64 v5; // rbx
  char *v6; // rax
  char *v7; // rax

  if ( *a3 == 81 )
  {
    v7 = sub_BC360((__int64)"Remote port forwarding from %s enabled", *(_QWORD *)(a1 + 32), a1);
    sub_2D3A0(a2[33], v7, a4, a5);
  }
  else
  {
    v5 = a1;
    v6 = sub_BC360((__int64)"Remote port forwarding from %s refused", *(_QWORD *)(a1 + 32));
    sub_2D3A0(a2[33], v6, a4, a5);
    if ( v5 != sub_9B440((__int64 *)a2[13], v5) )
      __assert_fail("realpf == rpf", "ssh2connection-client.c", 0xE1u, "ssh2_rportfwd_globreq_response");
    sub_37FE0(a2[14], *(_QWORD *)(v5 + 48));
    sub_83CB0((void **)v5);
  }
}

signed __int64 __fastcall sub_4A050(__int64 a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax

  v2 = strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
  if ( v2 )
    return (v2 >> 31) | 1u;
  result = 1LL;
  if ( *(_DWORD *)a1 <= *(_DWORD *)a2 )
    result = (unsigned int)-(*(_DWORD *)a1 < *(_DWORD *)a2);
  return result;
}

__int64 __fastcall sub_4A0A0(__int64 a1, __int64 a2, void *a3, size_t a4, __int64 a5, __int64 (__fastcall **a6)())
{
  void *v6; // r15
  __int64 v7; // r12
  __int64 v8; // rbp
  __int64 v9; // rbx
  __int64 (__fastcall **v10)(); // r13
  size_t v11; // r14
  char *v12; // rax
  __int64 v13; // rbx
  char *v14; // rax
  unsigned __int64 v15; // rdx
  unsigned __int64 n; // ST18_8
  char *v17; // r15
  unsigned int v18; // er14
  char *v19; // rax
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // ST20_8
  char *v22; // ST28_8
  __int64 v23; // rbx
  unsigned int v24; // eax
  char *v25; // rax
  _BYTE *v26; // rax
  __int64 *v27; // rdi
  char *v28; // rsi
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rbx
  char *v32; // rax
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // r15
  char *v35; // r14
  unsigned int v36; // ebx
  unsigned int v37; // eax
  const char *v38; // rdi
  char *v39; // r9
  char *v40; // ST18_8
  signed __int64 v41; // rbx
  char *v42; // rax
  __int64 (__fastcall ***v44)(); // rbp
  __int64 (__fastcall **v45)(); // rbx
  signed __int64 v46; // rax
  char *v47; // rax
  char *v48; // rax
  char *v49; // r13
  char *v50; // rsi
  char *v51; // rsi
  char *v52; // rax
  char *v53; // rax
  __int64 v54; // rax
  __int64 v55; // [rsp+28h] [rbp-80h]
  __int64 v56; // [rsp+30h] [rbp-78h]
  void *v57; // [rsp+38h] [rbp-70h]
  unsigned __int64 v58; // [rsp+68h] [rbp-40h]

  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = a5;
  v10 = a6;
  v58 = __readfsqword(0x28u);
  v11 = a4;
  if ( !(unsigned __int8)sub_BD100(a3, a4, "x11") )
  {
    if ( !(unsigned __int8)sub_BD100(v6, v11, "forwarded-tcpip") )
    {
      if ( (unsigned __int8)sub_BD100(v6, v11, "auth-agent@openssh.com") )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64, size_t))(*(_QWORD *)(a2 + 184) + 112LL))(a2 + 176, v11) )
        {
          v44 = (__int64 (__fastcall ***)())sub_37D90(a2 + 176, &v56, 1);
          v45 = (__int64 (__fastcall **)())sub_B3DF0(v56, (__int64)&v56);
          if ( (*((__int64 (__fastcall **)(__int64 (__fastcall **)()))*v45 + 6))(v45) )
          {
            sub_37E10(v44);
            v46 = sub_1B720((__int64)v10);
            *(_DWORD *)a1 = 1;
            *(_QWORD *)(a1 + 8) = v46;
          }
          else
          {
            sub_37F70(v44, v45, v10);
            *(_DWORD *)a1 = 1;
            *(_QWORD *)(a1 + 8) = v44;
          }
        }
        else
        {
          v48 = sub_BC360((__int64)"Agent forwarding is not enabled");
          *(_DWORD *)a1 = 0;
          *(_QWORD *)(a1 + 8) = v48;
          *(_DWORD *)(a1 + 16) = 1;
        }
      }
      else
      {
        v12 = sub_BC360((__int64)"Unsupported channel type requested", v11);
        *(_DWORD *)a1 = 0;
        *(_QWORD *)(a1 + 8) = v12;
        *(_DWORD *)(a1 + 16) = 3;
      }
      return v7;
    }
    v13 = v9 + 48;
    v14 = sub_2F1D0(v13);
    n = v15;
    v17 = v14;
    v18 = sub_2F150(v13);
    v19 = sub_2F1D0(v13);
    v21 = v20;
    v22 = v19;
    v23 = sub_2F150(v13);
    LODWORD(v21) = sub_BC2F0(v21);
    v24 = sub_BC2F0(n);
    v25 = sub_BC360(
            (__int64)"Received remote port %.*s:%d open request from %.*s:%d",
            v24,
            v17,
            v18,
            (unsigned int)v21,
            v22,
            v23);
    sub_2D3A0(*(_QWORD *)(a2 + 264), v25, (__int64)v10, (__int64)v17);
    v26 = sub_BD360(v17, n);
    v27 = *(__int64 **)(a2 + 104);
    v28 = (char *)&v56;
    v57 = v26;
    LODWORD(v56) = v18;
    v29 = sub_9B3D0(v27, (__int64)&v56, 0LL);
    sub_2F4D0(v57);
    if ( v29 )
    {
      v30 = *(_QWORD *)(v29 + 40);
      if ( v30 )
      {
        *(_DWORD *)v7 = 2;
        *(_QWORD *)(v7 + 8) = v30;
      }
      else
      {
        v49 = sub_38D40(
                *(__int64 **)(v8 + 112),
                &v55,
                *(char **)(v29 + 16),
                *(_DWORD *)(v29 + 4),
                (__int64)v10,
                *(_DWORD *)(v29 + 24));
        v50 = sub_BC360(
                (__int64)"Attempting to forward remote port to %s:%d",
                *(_QWORD *)(v29 + 16),
                *(unsigned int *)(v29 + 4));
        sub_2D3A0(*(_QWORD *)(v8 + 264), v50, (__int64)v49, (__int64)v17);
        if ( v49 )
        {
          v51 = sub_BC360((__int64)"Port open failed: %s", v49);
          sub_2D3A0(*(_QWORD *)(v8 + 264), v51, (__int64)v49, (__int64)v17);
          sub_2F4D0(v49);
          v52 = sub_BC360((__int64)"Port open failed", v51);
          *(_DWORD *)v7 = 0;
          *(_QWORD *)(v7 + 8) = v52;
          *(_DWORD *)(v7 + 16) = 2;
        }
        else
        {
          v53 = sub_BC360((__int64)"Forwarded port opened successfully", v50);
          sub_2D3A0(*(_QWORD *)(v8 + 264), v53, 0LL, (__int64)v17);
          v54 = v55;
          *(_DWORD *)v7 = 1;
          *(_QWORD *)(v7 + 8) = v54;
        }
      }
      return v7;
    }
    v38 = "Remote port is not recognised";
LABEL_18:
    v47 = sub_BC360((__int64)v38, v28);
    *(_DWORD *)v7 = 0;
    *(_QWORD *)(v7 + 8) = v47;
    *(_DWORD *)(v7 + 16) = 1;
    return v7;
  }
  v31 = v9 + 48;
  v32 = sub_2F1D0(v31);
  v34 = v33;
  v35 = v32;
  v36 = sub_2F150(v31);
  v37 = sub_BC2F0(v34);
  v28 = sub_BC360((__int64)"Received X11 connect request from %.*s:%d", v37, v35, v36);
  sub_2D3A0(*(_QWORD *)(v8 + 264), v28, (__int64)v10, v34);
  if ( !*(_BYTE *)(v8 + 81) )
  {
    v38 = "X11 forwarding is not enabled";
    if ( !*(_QWORD *)(v8 + 8) )
      goto LABEL_18;
  }
  v39 = 0LL;
  if ( v35 )
    v39 = sub_BD360(v35, v34);
  v40 = v39;
  v41 = sub_BF100(*(_QWORD *)(v8 + 88), (__int64)v10, v39, v36, *(_QWORD *)(v8 + 8) != 0LL);
  sub_2F4D0(v40);
  v42 = sub_BC360((__int64)"Opened X11 forward channel", v10);
  sub_2D3A0(*(_QWORD *)(v8 + 264), v42, (__int64)v10, v34);
  *(_DWORD *)v7 = 1;
  *(_QWORD *)(v7 + 8) = v41;
  return v7;
}

__int64 sub_4A510()
{
  return 0LL;
}

__int64 __usercall sub_4A520@<rax>(char *a1@<rdx>, int a2@<ecx>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r15>, __int64 a6@<r8>)
{
  int v6; // ebp
  char *v7; // rbx
  char *v8; // rax
  __int64 v9; // rax
  __int64 v10; // r12
  char *v11; // rdi
  void (__fastcall **v12)(_QWORD, char *, signed __int64); // rbx
  char *v13; // r13

  v6 = a2;
  v7 = a1;
  v8 = sub_BC360((__int64)"Opening connection to %s:%d for %s", a1, (unsigned int)a2, a6);
  sub_2D3A0(*(_QWORD *)(a3 + 264), v8, a3, a5);
  v9 = sub_4BEA0((int *)a4, "direct-tcpip");
  v10 = v9;
  v11 = v7;
  v12 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v9 + 96);
  v13 = sub_BC440(v11);
  sub_2EF40(v12, v13);
  sub_2F4D0(v13);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v12, v6);
  sub_2EF40(v12, "0.0.0.0");
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v12, 0);
  return v10;
}

void *__fastcall sub_4A5D0(__int64 a1, char *a2, int a3, char *a4, int a5, int a6, char *a7, __int64 a8, __int64 a9)
{
  int v9; // er14
  __int64 v10; // rbx
  int v11; // er12
  int v12; // ebp
  void *v13; // r13
  __int64 *v14; // rdi
  __int64 v15; // rax
  void (__fastcall **v16)(_QWORD, char *, signed __int64); // r12
  __int64 v17; // rbp
  void **v19; // rdi
  char *src; // [rsp+8h] [rbp-40h]

  v9 = a3;
  v10 = a1;
  v11 = a5;
  v12 = a6;
  src = a4;
  v13 = sub_2F450(1uLL, 0x38uLL, 0LL);
  if ( !*(_QWORD *)(a1 - 72) )
    *(_QWORD *)(a1 - 72) = sub_9AF60((__int64)sub_4A050);
  *((_QWORD *)v13 + 1) = sub_BC120(a2);
  *(_DWORD *)v13 = v9;
  *((_QWORD *)v13 + 2) = sub_BC120(src);
  *((_DWORD *)v13 + 1) = v11;
  *((_DWORD *)v13 + 6) = v12;
  *((_QWORD *)v13 + 4) = sub_BC120(a7);
  v14 = *(__int64 **)(a1 - 72);
  *((_QWORD *)v13 + 6) = a8;
  *((_QWORD *)v13 + 5) = a9;
  if ( (void *)sub_9AFD0(v14, (__int64)v13) == v13 )
  {
    if ( !*((_QWORD *)v13 + 5) )
    {
      v15 = (*(__int64 (__fastcall **)(signed __int64, void *))(**(_QWORD **)(v10 + 24) + 24LL))(80LL, v13);
      v16 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v15 + 96);
      v17 = v15;
      sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v15 + 96), "tcpip-forward");
      sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v16, 1);
      sub_2EF40(v16, *((char **)v13 + 1));
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v16, *(_DWORD *)v13);
      sub_614E0(*(_QWORD *)(v10 + 40), (__int64 *)(v17 + 64));
      sub_4BB50(v10 - 176, (__int64)sub_49FA0, (__int64)v13);
    }
  }
  else
  {
    v19 = (void **)v13;
    v13 = 0LL;
    sub_83CB0(v19);
  }
  return v13;
}

void __fastcall sub_4A720(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  void (__fastcall **v3)(_QWORD, char *, signed __int64); // r12
  __int64 v4; // rbp
  __int64 *v5; // rdi

  if ( !*(_QWORD *)(a2 + 40) )
  {
    v2 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 24) + 24LL))(80LL);
    v3 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 96);
    v4 = v2;
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 96), "cancel-tcpip-forward");
    sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v3, 0);
    sub_2EF40(v3, *(char **)(a2 + 8));
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v3, *(_DWORD *)a2);
    sub_614E0(*(_QWORD *)(a1 + 40), (__int64 *)(v4 + 64));
  }
  v5 = *(__int64 **)(a1 - 72);
  if ( !v5 )
    __assert_fail("s->rportfwds", "ssh2connection-client.c", 0x128u, "ssh2_rportfwd_remove");
  if ( a2 != sub_9B440(v5, a2) )
    __assert_fail("realpf == rpf", "ssh2connection-client.c", 0x12Au, "ssh2_rportfwd_remove");
  sub_83CB0((void **)a2);
}

_QWORD *__usercall sub_4A7F0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  char *v6; // rax
  __int64 v7; // rax

  v4 = sub_2F450(1uLL, 0xC0uLL, 0LL);
  v5 = v4;
  *v4 = a1 - 176;
  sub_4BD00((__int64)v4, 192LL);
  v5[21] = a2;
  *((_BYTE *)v5 + 20) = 1;
  v6 = sub_BC360((__int64)"Opening main session channel");
  sub_2D3A0(*(_QWORD *)(a1 + 88), v6, a3, a4);
  v7 = sub_4BEA0((int *)v5, "session");
  sub_614E0(*(_QWORD *)(a1 + 40), (__int64 *)(v7 + 64));
  return v5 + 22;
}

void __noreturn sub_4A870()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh2connection-client.c",
    0x146u,
    "ssh2_serverside_x11_open");
}

void __noreturn sub_4A8A0()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh2connection-client.c",
    0x14Bu,
    "ssh2_serverside_agent_open");
}

__int64 __fastcall sub_4A8D0(__int64 a1, char a2)
{
  __int64 (__fastcall *v2)(__int64, _DWORD *); // rdx
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax

  v2 = sub_49F70;
  v3 = *(_QWORD *)(a1 - 176);
  v4 = a1 - 176;
  if ( !a2 )
    v2 = 0LL;
  v5 = sub_4BF10(v4, "shell", (__int64)v2, 0LL);
  return sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(v5 + 64));
}

__int64 __fastcall sub_4A920(__int64 a1, char a2, char *a3)
{
  __int64 v3; // rax
  char *v4; // r12
  __int64 (__fastcall *v5)(__int64, _DWORD *); // rdx
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // rbx

  v3 = a1;
  v4 = a3;
  v5 = sub_49F70;
  v6 = a1 - 176;
  v7 = *(_QWORD *)(v3 - 176);
  if ( !a2 )
    v5 = 0LL;
  v8 = sub_4BF10(v6, "exec", (__int64)v5, 0LL);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96), v4);
  return sub_614E0(*(_QWORD *)(v7 + 216), (__int64 *)(v8 + 64));
}

signed __int64 __fastcall sub_4A980(__int64 a1, char a2, char *a3)
{
  __int64 v3; // rax
  char *v4; // r12
  __int64 (__fastcall *v5)(__int64, _DWORD *); // rdx
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // rbx

  v3 = a1;
  v4 = a3;
  v5 = sub_49F70;
  v6 = a1 - 176;
  v7 = *(_QWORD *)(v3 - 176);
  if ( !a2 )
    v5 = 0LL;
  v8 = sub_4BF10(v6, "subsystem", (__int64)v5, 0LL);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96), v4);
  sub_614E0(*(_QWORD *)(v7 + 216), (__int64 *)(v8 + 64));
  return 1LL;
}

void __noreturn sub_4A9F0()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh2connection-client.c",
    0x17Eu,
    "ssh2channel_send_exit_status");
}

void __noreturn sub_4AA20()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh2connection-client.c",
    0x184u,
    "ssh2channel_send_exit_signal");
}

void __noreturn sub_4AA50()
{
  __assert_fail(
    "false && \"Should never be called in the client\"",
    "ssh2connection-client.c",
    0x18Au,
    "ssh2channel_send_exit_signal_numeric");
}

__int64 __fastcall sub_4AA80(__int64 a1, char a2, char *a3, char *a4, int a5, char a6)
{
  __int64 v6; // rax
  char *v7; // r15
  __int64 (__fastcall *v8)(__int64, _DWORD *); // rdx
  __int64 v9; // rdi
  char *v10; // r14
  char v11; // r13
  __int64 v12; // r12
  __int64 v13; // rax
  void (__fastcall **v14)(_QWORD, char *, signed __int64); // rbp
  __int64 v15; // rbx
  int v17; // [rsp+Ch] [rbp-3Ch]

  v6 = a1;
  v7 = a3;
  v8 = sub_49F70;
  v9 = a1 - 176;
  v10 = a4;
  v11 = a6;
  v12 = *(_QWORD *)(v6 - 176);
  v17 = a5;
  if ( !a2 )
    v8 = 0LL;
  v13 = sub_4BF10(v9, "x11-req", (__int64)v8, 0LL);
  v14 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v13 + 96);
  v15 = v13;
  sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v13 + 96), v11);
  sub_2EF40(v14, v7);
  sub_2EF40(v14, v10);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, v17);
  return sub_614E0(*(_QWORD *)(v12 + 216), (__int64 *)(v15 + 64));
}

__int64 __fastcall sub_4AB30(__int64 a1, char a2)
{
  __int64 (__fastcall *v2)(__int64, _DWORD *); // rdx
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax

  v2 = sub_49F70;
  v3 = *(_QWORD *)(a1 - 176);
  v4 = a1 - 176;
  if ( !a2 )
    v2 = 0LL;
  v5 = sub_4BF10(v4, "auth-agent-req@openssh.com", (__int64)v2, 0LL);
  return sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(v5 + 64));
}

__int64 __fastcall sub_4AB80(__int64 a1, char a2, __int64 *a3, int a4, int a5)
{
  __int64 v5; // rax
  __int64 *v6; // r15
  __int64 (__fastcall *v7)(__int64, _DWORD *); // rdx
  int v8; // er13
  __int64 v9; // rdi
  int v10; // ebp
  __int64 v11; // r14
  __int64 v12; // rax
  __int64 v13; // r12
  void (__fastcall **v14)(_QWORD, char *, signed __int64); // rbx
  char *v15; // rax
  __int64 v16; // r13
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 result; // rax
  unsigned __int64 v20; // rt1
  int v21; // [rsp-510h] [rbp-A68h]
  int v22; // [rsp-508h] [rbp-A60h]
  int v23; // [rsp-500h] [rbp-A58h]
  int v24; // [rsp-4F8h] [rbp-A50h]
  int v25; // [rsp-4F0h] [rbp-A48h]
  int v26; // [rsp-4E8h] [rbp-A40h]
  int v27; // [rsp-4E0h] [rbp-A38h]
  int v28; // [rsp-4D8h] [rbp-A30h]
  int v29; // [rsp-4D0h] [rbp-A28h]
  int v30; // [rsp-4C8h] [rbp-A20h]
  int v31; // [rsp-4C0h] [rbp-A18h]
  int v32; // [rsp-4B8h] [rbp-A10h]
  int v33; // [rsp-4B0h] [rbp-A08h]
  int v34; // [rsp-4A8h] [rbp-A00h]
  int v35; // [rsp-4A0h] [rbp-9F8h]
  int v36; // [rsp-498h] [rbp-9F0h]
  int v37; // [rsp-490h] [rbp-9E8h]
  int v38; // [rsp-488h] [rbp-9E0h]
  int v39; // [rsp-480h] [rbp-9D8h]
  int v40; // [rsp-478h] [rbp-9D0h]
  int v41; // [rsp-470h] [rbp-9C8h]
  int v42; // [rsp-468h] [rbp-9C0h]
  int v43; // [rsp-460h] [rbp-9B8h]
  int v44; // [rsp-458h] [rbp-9B0h]
  int v45; // [rsp-450h] [rbp-9A8h]
  int v46; // [rsp-448h] [rbp-9A0h]
  int v47; // [rsp-440h] [rbp-998h]
  int v48; // [rsp-438h] [rbp-990h]
  int v49; // [rsp-430h] [rbp-988h]
  int v50; // [rsp-428h] [rbp-980h]
  int v51; // [rsp-420h] [rbp-978h]
  int v52; // [rsp-418h] [rbp-970h]
  __int64 v53; // [rsp-410h] [rbp-968h]
  unsigned int v54; // [rsp-8h] [rbp-560h]
  __int64 v55; // [rsp+0h] [rbp-558h]
  unsigned int v56; // [rsp+508h] [rbp-50h]
  unsigned __int64 v57; // [rsp+518h] [rbp-40h]

  v5 = a1;
  v6 = a3;
  v7 = sub_49F70;
  v8 = a4;
  v9 = a1 - 176;
  v10 = a5;
  v11 = *(_QWORD *)(v5 - 176);
  v57 = __readfsqword(0x28u);
  if ( !a2 )
    v7 = 0LL;
  v12 = sub_4BF10(v9, "pty-req", (__int64)v7, 0LL);
  v13 = v12;
  v14 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v12 + 96);
  v15 = (char *)sub_1F170(v6, 52);
  sub_2EF40(v14, v15);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, v8);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, v10);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, 0);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v14, 0);
  v16 = sub_BC640();
  sub_61890(&v55, *(_QWORD *)(v11 + 272), v6);
  qmemcpy(&v21, &v55, 0x508uLL);
  v54 = v56;
  sub_61CE0(
    v16 + 24,
    2,
    v56,
    0LL,
    v17,
    v18,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53);
  sub_2EF70(v14, v16);
  v20 = __readfsqword(0x28u);
  result = v20 ^ v57;
  if ( v20 == v57 )
    result = sub_614E0(*(_QWORD *)(v11 + 216), (__int64 *)(v13 + 64));
  return result;
}

signed __int64 __fastcall sub_4ACC0(__int64 a1, char a2, char *a3, char *a4)
{
  __int64 v4; // rax
  char *v5; // r13
  __int64 (__fastcall *v6)(__int64, _DWORD *); // rdx
  __int64 v7; // rdi
  __int64 v8; // r14
  char *v9; // r12
  __int64 v10; // rax
  void (__fastcall **v11)(_QWORD, char *, signed __int64); // rbp
  __int64 v12; // rbx

  v4 = a1;
  v5 = a3;
  v6 = sub_49F70;
  v7 = a1 - 176;
  v8 = *(_QWORD *)(v4 - 176);
  v9 = a4;
  if ( !a2 )
    v6 = 0LL;
  v10 = sub_4BF10(v7, "env", (__int64)v6, 0LL);
  v11 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v10 + 96);
  v12 = v10;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v10 + 96), v5);
  sub_2EF40(v11, v9);
  sub_614E0(*(_QWORD *)(v8 + 216), (__int64 *)(v12 + 64));
  return 1LL;
}

signed __int64 __fastcall sub_4AD40(__int64 a1, char a2, int a3)
{
  int v3; // ebp
  __int64 (__fastcall *v4)(__int64, _DWORD *); // rdx
  __int64 v5; // r12
  __int64 v6; // rdi
  __int64 v7; // rbx

  v3 = a3;
  v4 = sub_49F70;
  v5 = *(_QWORD *)(a1 - 176);
  v6 = a1 - 176;
  if ( !a2 )
    v4 = 0LL;
  v7 = sub_4BF10(v6, "break", (__int64)v4, 0LL);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v7 + 96), v3);
  sub_614E0(*(_QWORD *)(v5 + 216), (__int64 *)(v7 + 64));
  return 1LL;
}

signed __int64 __fastcall sub_4ADB0(__int64 a1, char a2, char *a3)
{
  __int64 v3; // rax
  char *v4; // r12
  __int64 (__fastcall *v5)(__int64, _DWORD *); // rdx
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // rbx

  v3 = a1;
  v4 = a3;
  v5 = sub_49F70;
  v6 = a1 - 176;
  v7 = *(_QWORD *)(v3 - 176);
  if ( !a2 )
    v5 = 0LL;
  v8 = sub_4BF10(v6, "signal", (__int64)v5, 0LL);
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 96), v4);
  sub_614E0(*(_QWORD *)(v7 + 216), (__int64 *)(v8 + 64));
  return 1LL;
}

__int64 __fastcall sub_4AE20(__int64 a1, int a2, int a3)
{
  __int64 v3; // r14
  int v4; // er12
  __int64 v5; // rax
  void (__fastcall **v6)(_QWORD, char *, signed __int64, _QWORD); // rbp
  __int64 v7; // rbx

  v3 = *(_QWORD *)(a1 - 176);
  v4 = a3;
  v5 = sub_4BF10(a1 - 176, "window-change", 0LL, 0LL);
  v6 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 96);
  v7 = v5;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 96), a2);
  sub_2ED90(v6, v4);
  sub_2ED90(v6, 0);
  sub_2ED90(v6, 0);
  return sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(v7 + 64));
}

__int64 __fastcall sub_4AEA0(__int64 a1)
{
  char v1; // al
  unsigned int v2; // edx
  int v3; // eax

  v1 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 272) + 136LL))(*(_QWORD *)(a1 + 272), 0LL);
  v2 = 0;
  if ( !v1 )
  {
    LOBYTE(v3) = sub_428D0(*(_QWORD *)(a1 + 280));
    v2 = v3 ^ 1;
  }
  return v2;
}

signed __int64 __fastcall sub_4AEE0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a1 + 12) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 12) > v2;
  return result;
}

signed __int64 __fastcall sub_4AF00(unsigned int *a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 12);
  if ( *a1 < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > v2;
  return result;
}

__int64 __fastcall sub_4AF20(__int64 a1)
{
  _BOOL8 v1; // rsi

  v1 = 0LL;
  if ( !*(_BYTE *)(a1 + 30) && !*(_BYTE *)(*(_QWORD *)a1 + 80LL) && !*(_BYTE *)(a1 + 28) )
    v1 = (*(_BYTE *)(a1 + 24) & 1) == 0;
  return (*(__int64 (__fastcall **)(_QWORD, _BOOL8))(**(_QWORD **)(a1 + 168) + 40LL))(*(_QWORD *)(a1 + 168), v1);
}

__int64 __fastcall sub_4AF50(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 - 176) + 64LL);
}

__int64 __fastcall sub_4AF60(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 - 152) )
    result = (*(__int64 (**)(void))(**(_QWORD **)(a1 - 144) + 24LL))();
  return result;
}

__int64 __fastcall sub_4AF90(__int64 a1, int a2)
{
  return *(unsigned __int8 *)(a1 + a2 - 136);
}

void __fastcall sub_4AFA0(__int64 a1, int a2, char a3)
{
  *(_BYTE *)(a1 + a2 - 136) = a3;
}

void __fastcall sub_4AFB0(__int64 a1)
{
  *(_BYTE *)(a1 - 95) = 1;
}

void __fastcall sub_4AFC0(__int64 a1, char a2)
{
  *(_BYTE *)(a1 - 116) = a2;
}

__int64 __fastcall sub_4AFD0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 - 132);
}

__int64 __fastcall sub_4AFE0(__int64 a1, char a2)
{
  signed int v2; // ebx
  __int64 result; // rax

  v2 = 0;
  *(_BYTE *)(a1 - 96) = a2;
  while ( 1 )
  {
    result = sub_9B010(*(__int64 **)(a1 - 104), v2);
    if ( !result )
      break;
    if ( !*(_QWORD *)(result + 160) )
      sub_4AF20(result);
    ++v2;
  }
  return result;
}

__int64 __fastcall sub_4B030(__int64 a1, int a2, int a3)
{
  bool v3; // zf
  __int64 result; // rax
  __int64 v5; // rdi

  *(_DWORD *)(a1 - 124) = a2;
  *(_DWORD *)(a1 - 120) = a3;
  v5 = *(_QWORD *)(a1 - 152);
  if ( v5 )
  {
    v3 = *(_BYTE *)(v5 + 39) == 0;
    *(_DWORD *)(v5 + 60) = a2;
    *(_DWORD *)(v5 + 64) = a3;
    JUMPOUT(v3, &loc_2EB00);
    result = (*(__int64 (**)(void))(**(_QWORD **)v5 + 152LL))();
  }
  return result;
}

__int64 __fastcall sub_445D0(__int64 a1, int a2, int a3)
{
  bool v3; // zf
  __int64 result; // rax
  __int64 v5; // rdi

  *(_DWORD *)(a1 - 120) = a2;
  *(_DWORD *)(a1 - 116) = a3;
  v5 = *(_QWORD *)(a1 - 136);
  if ( v5 )
  {
    v3 = *(_BYTE *)(v5 + 39) == 0;
    *(_DWORD *)(v5 + 60) = a2;
    *(_DWORD *)(v5 + 64) = a3;
    if ( !v3 || *(_BYTE *)(v5 + 58) )
      result = (*(__int64 (**)(void))(**(_QWORD **)v5 + 152LL))();
  }
  return result;
}

__int64 __fastcall sub_4B060(__int64 a1)
{
  __int64 result; // rax

  result = sub_1EF00(*(__int64 **)(a1 - 112), 30);
  if ( (_BYTE)result )
    result = sub_B3CE0();
  return result;
}

_QWORD *__fastcall sub_4B080(__int64 a1)
{
  return sub_1BD80((__int64)sub_4B0A0, a1 - 176);
}

void __usercall sub_4B0A0(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbx
  __int64 v4; // rdi

  if ( !*(_BYTE *)(a1 + 62) )
  {
    if ( *(_BYTE *)(a1 + 63) )
    {
      v3 = a1;
      if ( !(unsigned int)sub_9AFB0(*(__int64 **)(a1 + 72)) )
      {
        v4 = *(_QWORD *)(a1 + 8);
        if ( !v4 || (signed int)sub_83550(v4) <= 0 )
          sub_42660(*(_QWORD *)(v3 + 280), (__int64)"All channels closed", a2, a3);
      }
    }
  }
}

__int64 __fastcall sub_4B0F0(__int64 a1, __int64 a2, unsigned int *a3)
{
  return sub_83120(a3, *(_DWORD *)a2, *(_QWORD *)(a2 + 48), *(_DWORD *)(a2 + 64));
}

void __fastcall sub_4B110(__int64 a1, __int64 a2, _DWORD *a3)
{
  *(_DWORD *)(a1 + 128) += *a3;
  sub_2F4D0(a3);
  if ( *(_DWORD *)(a1 + 152) == 1 )
    *(_DWORD *)(a1 + 152) = 2;
}

void __usercall sub_4B140(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r15>)
{
  char *v3; // r12
  __int64 v4; // r13
  __int64 v5; // rax
  void *v6; // rbp
  char *v7; // rdx

  if ( !*(_QWORD *)(a1 + 160) )
  {
    v3 = a2;
    v4 = *(_QWORD *)a1;
    v5 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 168) + 48LL))();
    v6 = (void *)v5;
    if ( v5 )
    {
      v7 = " ";
      if ( !a2 )
      {
        v3 = &locale;
        v7 = &locale;
      }
      a2 = sub_BC360((__int64)"%s%s%s", v5, v7, v3);
      sub_2D3A0(*(_QWORD *)(v4 + 264), a2, v4, a3);
    }
    sub_2F4D0(v6);
    (***(void (__fastcall ****)(_QWORD, char *))(a1 + 168))(*(_QWORD *)(a1 + 168), a2);
    *(_QWORD *)(a1 + 168) = sub_61860();
  }
}

void __fastcall sub_4B1F0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  void (***v3)(void); // rdi
  __int64 v4; // rax

  v1 = a1;
  sub_BCCA0((__int64)(a1 + 4));
  sub_BCCA0((__int64)(a1 + 9));
  for ( i = (_QWORD *)a1[17]; i; i = (_QWORD *)v1[17] )
  {
    v1[17] = i[2];
    sub_2F4D0(i);
  }
  v3 = (void (***)(void))v1[21];
  if ( v3 )
  {
    v4 = *v1;
    if ( *(_QWORD **)(*v1 + 32LL) == v1 + 22 )
    {
      *(_QWORD *)(v4 + 24) = 0LL;
      *(_QWORD *)(v4 + 32) = 0LL;
    }
    (**v3)();
  }
  sub_2F4D0(v1);
}

__int64 __fastcall sub_4B280(__int64 a1, int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 v8; // rbx

  v6 = a6;
  v7 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 24LL))(a3);
  *(_DWORD *)(v7 + 48) = a2;
  *(_QWORD *)(v7 + 56) = v6;
  v8 = v7;
  sub_2EC20((__int64 (**)(void))(v7 + 96));
  return sub_614E0(*(_QWORD *)(a1 + 40), (__int64 *)(v8 + 64));
}

void __fastcall sub_4B2E0(__int64 a1, __int64 a2)
{
  sub_9B440(*(__int64 **)(a1 - 88), a2);
  sub_BE420(a2);
}

signed int *__fastcall sub_4B300(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  signed int *result; // rax

  v4 = a3;
  v5 = a4;
  result = sub_BE220(*(__int64 **)(a1 - 88), a2);
  *((_QWORD *)result + 8) = v4;
  *((_QWORD *)result + 9) = v5;
  return result;
}

signed int *__fastcall sub_4B330(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  signed int *result; // rax

  v3 = a3;
  result = sub_BE220(*(__int64 **)(a1 - 88), a2);
  *((_QWORD *)result + 7) = v3;
  return result;
}

__int64 *__usercall sub_4B350@<rax>(__int64 a1@<rdi>, _QWORD *a2@<rsi>, char *a3@<r13>)
{
  __int64 *result; // rax
  bool v4; // zf

  sub_1ED50(*(_QWORD **)(a1 - 128));
  result = sub_1EED0(a2);
  v4 = *(_BYTE *)(a1 - 72) == 0;
  *(_QWORD *)(a1 - 128) = result;
  if ( !v4 )
    result = (__int64 *)sub_38070(*(_QWORD *)(a1 - 80), result, a3);
  return result;
}

void __fastcall sub_4B3A0(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // rbp

  while ( *(_QWORD *)(a1 - 168) )
  {
    if ( !sub_BCD00(*(_QWORD *)(a1 + 64)) )
      break;
    v1 = sub_BCF00(*(_QWORD *)(a1 + 64));
    v3 = v2;
    (***(void (__fastcall ****)(_QWORD, _QWORD, __int64, unsigned __int64))(a1 - 160))(
      *(_QWORD *)(a1 - 160),
      0LL,
      v1,
      v2);
    sub_BCE20(*(_QWORD *)(a1 + 64), v3);
  }
}

void __fastcall sub_4B410(__int64 a1)
{
  void *v1; // r12
  __int64 v2; // rbx
  _QWORD *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rbp
  __int64 *v7; // rdi
  void **v8; // rax
  __int64 v9; // rdi

  v1 = (void *)(a1 - 192);
  v2 = a1;
  sub_2F4D0(*(void **)(a1 - 176));
  sub_1ED50(*(_QWORD **)(a1 - 128));
  while ( 1 )
  {
    v3 = (_QWORD *)sub_9B400(*(__int64 **)(a1 - 120), 0);
    if ( !v3 )
      break;
    sub_4B1F0(v3);
  }
  sub_9AF90(*(_QWORD ***)(a1 - 120));
  while ( 1 )
  {
    v5 = sub_9B400(*(__int64 **)(v2 - 104), 0);
    v6 = v5;
    if ( !v5 )
      break;
    v4 = *(_QWORD *)(v5 + 56);
    if ( v4 )
      sub_BE9C0(v4);
    sub_BE420(v6);
  }
  sub_9AF90(*(_QWORD ***)(v2 - 104));
  v7 = *(__int64 **)(v2 - 88);
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = (void **)sub_9B400(v7, 0);
      if ( !v8 )
        break;
      sub_83CB0(v8);
      v7 = *(__int64 **)(v2 - 88);
    }
    sub_9AF90(*(_QWORD ***)(v2 - 88));
  }
  sub_38040(*(_QWORD *)(v2 - 80));
  v9 = *(_QWORD *)(v2 - 64);
  if ( v9 )
    sub_31C50(v9);
  sub_1BCD0((__int64)v1);
  sub_2F4D0(v1);
}

__int64 __fastcall sub_4B4F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  __int64 v10; // rbx
  _QWORD *v11; // rdi
  __int64 v12; // rsi
  int v13; // edx
  __int64 result; // rax

  v10 = a1;
  v11 = (_QWORD *)a2;
  v12 = a3;
  v13 = *(_DWORD *)(v10 - 164);
  *(_QWORD *)(v10 - 16) = v11;
  sub_82DC0(
    v11,
    v12,
    v13,
    *(_DWORD *)(v10 - 168),
    *(_DWORD *)(v10 - 64),
    *(_DWORD *)(v10 - 60),
    *(_DWORD *)(v10 - 56),
    (char *)a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10);
  result = (***(__int64 (****)(void))(v10 - 8))();
  *(_QWORD *)(v10 - 8) = 0LL;
  return result;
}

__int64 __fastcall sub_4B550(__int64 a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rbp

  if ( !*(_QWORD *)(a1 - 152) )
    return 0LL;
  v1 = *(_QWORD *)(a1 - 144) - 176LL;
  v2 = sub_BCD00(v1 + 32);
  return v2 + sub_BCD00(v1 + 72);
}

_QWORD *__usercall sub_4B5A0@<rax>(__int64 *a1@<rdi>, __int64 a2@<r15>)
{
  __int64 v2; // rbp

  v2 = *a1;
  if ( a1[17] )
    __assert_fail("c->chanreq_head == NULL", "ssh2connection.c", 0x4CAu, "ssh2_channel_destroy");
  sub_4B140((__int64)a1, 0LL, a2);
  sub_9B440(*(__int64 **)(v2 + 72), (__int64)a1);
  sub_4B1F0(a1);
  return sub_1BD80((__int64)sub_4B0A0, v2);
}

__int64 *__usercall sub_4B610@<rax>(__int64 a1@<rdi>, int a2@<esi>, __int64 a3@<r15>)
{
  __int64 *v3; // rdi
  __int64 *result; // rax
  int v5; // [rsp+Ch] [rbp-Ch]

  v3 = *(__int64 **)(a1 - 104);
  v5 = a2;
  result = (__int64 *)sub_9B3D0(v3, (__int64)&v5, (__int64 (__fastcall *)(__int64))sub_4AF00);
  if ( result )
    result = sub_4B5A0(result, a3);
  return result;
}

void __usercall sub_4B640(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 v2; // rbp
  bool v3; // zf
  int v4; // eax
  __int64 v5; // r12

  v2 = *(_QWORD *)a1;
  if ( *(_BYTE *)(a1 + 20) )
    return;
  v3 = (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 168) + 56LL))(
         *(_QWORD *)(a1 + 168),
         *(_DWORD *)(a1 + 24) & 1,
         (*(_DWORD *)(a1 + 24) >> 2) & 1) == 0;
  v4 = *(_DWORD *)(a1 + 24);
  if ( !v3 )
  {
    if ( *(_QWORD *)(a1 + 136) )
    {
      if ( ~(_BYTE)v4 & 0xA )
        return;
LABEL_11:
      __assert_fail("c->chanreq_head == NULL", "ssh2connection.c", 0x43Au, "ssh2_channel_check_close");
    }
    if ( v4 & 2 )
    {
      if ( !(~(_BYTE)v4 & 0xA) )
        goto LABEL_10;
      return;
    }
    v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v2 + 200) + 24LL))(97LL);
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 96), *(_DWORD *)(a1 + 8));
    sub_614E0(*(_QWORD *)(v2 + 216), (__int64 *)(v5 + 64));
    v4 = *(_DWORD *)(a1 + 24) | 3;
    *(_DWORD *)(a1 + 24) = v4;
  }
  if ( !(~(_BYTE)v4 & 0xA) )
  {
    if ( *(_QWORD *)(a1 + 136) )
      goto LABEL_11;
LABEL_10:
    sub_4B5A0((__int64 *)a1, a2);
  }
}

void __usercall sub_4B720(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r15>)
{
  char *v3; // rbx
  __int64 v4; // rbp

  v3 = 0LL;
  v4 = a1 - 176;
  if ( a2 )
    v3 = sub_BC360((__int64)"due to local error: %s");
  sub_4B140(v4, v3, a3);
  sub_2F4D0(v3);
  *(_BYTE *)(a1 - 148) = 0;
  sub_4B640(v4, a3);
}

void __usercall sub_4B770(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 v2; // rbp
  __int64 v3; // rax
  __int64 v4; // r12

  if ( !*(_BYTE *)(a1 + 28) )
    __assert_fail("c->pending_eof", "ssh2connection.c", 0x447u, "ssh2_channel_try_eof");
  if ( !*(_BYTE *)(a1 + 20) )
  {
    v2 = *(_QWORD *)a1;
    if ( !sub_BCD00(a1 + 32) && !sub_BCD00(a1 + 72) )
    {
      v3 = *(_QWORD *)(v2 + 200);
      *(_BYTE *)(a1 + 28) = 0;
      v4 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v3 + 24LL))(96LL);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v4 + 96), *(_DWORD *)(a1 + 8));
      sub_614E0(*(_QWORD *)(v2 + 216), (__int64 *)(v4 + 64));
      *(_DWORD *)(a1 + 24) |= 1u;
      sub_4B640(a1, a2);
    }
  }
}

void __usercall sub_4B820(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  if ( !(*(_BYTE *)(a1 - 152) & 1) )
  {
    *(_BYTE *)(a1 - 148) = 1;
    sub_4B770(a1 - 176, a2);
  }
}

__int64 __usercall sub_4B850@<rax>(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 v2; // r14
  __int64 v3; // rax
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rbx
  __int64 v6; // rax
  void (__fastcall **v7)(_QWORD, char *, signed __int64); // r13
  __int64 v8; // r12
  bool v9; // zf
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 result; // rax
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  char *v17; // [rsp+18h] [rbp-40h]

  v2 = a1 + 72;
  v15 = a1 + 32;
  if ( !*(_BYTE *)(a1 + 20) && *(_DWORD *)(a1 + 112) )
  {
    a2 = *(_QWORD *)a1;
    do
    {
      if ( !sub_BCD00(v15) && !sub_BCD00(v2) )
        break;
      if ( sub_BCD00(v2) )
      {
        v3 = sub_BCF00(v2);
        v5 = *(unsigned int *)(a1 + 112);
        v17 = (char *)v3;
        if ( v5 > *(unsigned int *)(a1 + 116) )
          v5 = *(unsigned int *)(a1 + 116);
        if ( v5 > v4 )
          v5 = v4;
        v6 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a2 + 200) + 24LL))(95LL);
        v7 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v6 + 96);
        v8 = v6;
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v6 + 96), *(_DWORD *)(a1 + 8));
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v7, 1);
        v16 = a1 + 72;
      }
      else
      {
        v17 = (char *)sub_BCF00(v15);
        v11 = *(unsigned int *)(a1 + 112);
        if ( v11 > *(unsigned int *)(a1 + 116) )
          v11 = *(unsigned int *)(a1 + 116);
        if ( v11 <= v10 )
          v10 = v11;
        v5 = v10;
        v12 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a2 + 200) + 24LL))(94LL);
        v7 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v12 + 96);
        v8 = v12;
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v12 + 96), *(_DWORD *)(a1 + 8));
        v16 = a1 + 32;
      }
      sub_2EF30(v7, v17, v5);
      sub_614E0(*(_QWORD *)(a2 + 216), (__int64 *)(v8 + 64));
      sub_BCE20(v16, v5);
      v9 = *(_DWORD *)(a1 + 112) == (_DWORD)v5;
      *(_DWORD *)(a1 + 112) -= v5;
    }
    while ( !v9 );
  }
  v13 = sub_BCD00(v15);
  result = v13 + sub_BCD00(v2);
  if ( !result )
  {
    if ( *(_BYTE *)(a1 + 28) )
    {
      sub_4B770(a1, a2);
      result = 0LL;
    }
  }
  return result;
}

void __usercall sub_4BA10(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  _QWORD *v4; // rdi
  __int64 v5; // rbp

  if ( (unsigned int)(a2 - 2) <= 1 )
  {
    if ( !(*(_BYTE *)(a1 + 97) & 2) )
    {
      v5 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(a1 + 8) + 24LL))(2LL);
      sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v5 + 96), &locale);
      sub_614E0(*(_QWORD *)(a1 + 24), (__int64 *)(v5 + 64));
    }
  }
  else
  {
    v4 = *(_QWORD **)(a1 - 168);
    if ( v4 )
      sub_2E2F0(v4, a2, a3, a4);
  }
}

signed __int64 __fastcall sub_4BA80(__int64 a1, void (__fastcall *a2)(__int64, const char *, signed __int64, _QWORD), __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  __int64 v5; // rdi
  signed __int64 result; // rax

  v3 = a3;
  v4 = a1;
  v5 = *(_QWORD *)(a1 - 168);
  if ( v5 )
  {
    sub_2E1B0(v5, a2, a3);
    result = 1LL;
    if ( *(_BYTE *)(v4 + 97) & 2 )
      return result;
    a2(v3, 0LL, 30LL, 0LL);
  }
  else
  {
    result = 0LL;
    if ( *(_BYTE *)(v4 + 97) & 2 )
      return result;
  }
  a2(v3, "IGNORE message", 2LL, 0LL);
  return 1LL;
}

__int64 __usercall sub_4BAF0@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, char a4@<sil>, __int64 a5@<r15>)
{
  __int64 v5; // rbx
  bool v6; // zf
  char *v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rdi

  if ( *(_BYTE *)(a3 - 152) & 1 )
    __assert_fail("!(c->closes & CLOSES_SENT_EOF)", "ssh2connection.c", 0x581u, "ssh2channel_write");
  v5 = a3 - 176;
  v6 = a4 == 0;
  v7 = (char *)a1;
  v8 = a3 - 176 + 72;
  v9 = a3 - 176 + 32;
  if ( !v6 )
    v9 = v8;
  sub_BCD20(v9, v7, a2);
  return sub_4B850(v5, a5);
}

_QWORD *__fastcall sub_4BB50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  _QWORD *result; // rax
  __int64 v5; // rdx

  v3 = a3;
  result = sub_2F450(1uLL, 0x18uLL, 0LL);
  v5 = *(_QWORD *)(a1 + 168);
  *result = a2;
  result[1] = v3;
  if ( v5 )
    *(_QWORD *)(v5 + 16) = result;
  else
    *(_QWORD *)(a1 + 160) = result;
  *(_QWORD *)(a1 + 168) = result;
  return result;
}

_QWORD *__fastcall sub_4BBB0(__int64 a1, __int64 a2)
{
  return sub_4BB50(a1 - 176, (__int64)sub_4B0F0, a2);
}

char *__fastcall sub_4BBD0(__int64 a1, __int64 a2, char a3, _QWORD *a4, char *a5, _QWORD *a6)
{
  char v6; // r15
  char *v7; // r12
  _QWORD *v8; // r13
  _QWORD *v9; // ST08_8
  _QWORD *v10; // rbx
  __int64 *v11; // rax
  _QWORD *v12; // rax
  __int64 v13; // rdi

  v6 = a3;
  v7 = a5;
  v8 = a4;
  v9 = a6;
  v10 = sub_2F450(1uLL, 0x128uLL, 0LL);
  *v10 = 0LL;
  v10[36] = 0LL;
  memset(
    (void *)((unsigned __int64)(v10 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v10 - (((_DWORD)v10 + 8) & 0xFFFFFFF8) + 296) >> 3));
  v10[24] = off_3241C0;
  v11 = sub_1EED0(v8);
  v10[8] = v11;
  *((_BYTE *)v10 + 61) = v6;
  *((_BYTE *)v10 + 62) = sub_1EF00(v11, 49);
  v10[1] = a2;
  v10[2] = sub_BC120(v7);
  v10[9] = sub_9AF60((__int64)sub_4AEE0);
  v10[11] = sub_9AF60((__int64)sub_BE4A0);
  v10[23] = &off_324100;
  v10[22] = sub_41EE0(a1);
  v12 = sub_37F90((__int64)(v10 + 22));
  v13 = v10[1];
  v10[14] = v12;
  *v9 = v10 + 22;
  if ( v13 )
    sub_83810(v13, (__int64)(v10 + 22));
  return (char *)(v10 + 24);
}

__int64 __fastcall sub_4BD00(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rbp
  bool v5; // cf
  unsigned int v6; // eax
  __int64 v7; // rdi
  int v8; // eax
  __int64 *v9; // rdi

  v2 = a1;
  v3 = a1 + 32;
  v4 = *(_QWORD *)(v3 - 32);
  *(_DWORD *)(v3 - 8) = 0;
  *(_BYTE *)(v3 - 4) = 0;
  *(_BYTE *)(v3 - 3) = 0;
  *(_BYTE *)(v3 - 2) = 0;
  *(_QWORD *)(v3 + 128) = 0LL;
  v5 = *(_BYTE *)(v4 + 61) < 1u;
  *(_QWORD *)(v3 + 104) = 0LL;
  *(_DWORD *)(v3 + 120) = 2;
  v6 = v5 ? 0x4000 : 0x7FFFFFFF;
  *(_DWORD *)(v3 + 96) = v6;
  *(_DWORD *)(v3 + 92) = v6;
  *(_DWORD *)(v3 + 88) = v6;
  sub_BCC70((_QWORD *)v3);
  sub_BCC70((_QWORD *)(v2 + 72));
  v7 = *(_QWORD *)(v4 + 72);
  *(_QWORD *)(v2 + 176) = off_324040;
  *(_QWORD *)(v2 + 184) = v4 + 176;
  v8 = sub_61DD0(v7, 12LL);
  v9 = *(__int64 **)(v4 + 72);
  *(_DWORD *)(v2 + 12) = v8;
  return sub_9AFD0(v9, v2);
}

__int64 __fastcall sub_4BDB0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rbx

  v2 = sub_2F450(1uLL, 0xC0uLL, 0LL);
  v3 = v2;
  *v2 = a1 - 176;
  sub_4BD00((__int64)v2, 192LL);
  v3[21] = 0LL;
  v3[20] = a2;
  return *((unsigned int *)v3 + 3);
}

signed __int64 __fastcall sub_4BE00(__int64 a1, char *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // er14
  __int64 v7; // r15
  __int64 v8; // ST00_8
  _QWORD *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax

  v6 = a3;
  v7 = a4;
  v8 = a6;
  v9 = sub_2F450(1uLL, 0xC0uLL, 0LL);
  *v9 = a1 - 176;
  v10 = (__int64)v9;
  sub_4BD00((__int64)v9, 192LL);
  *(_BYTE *)(v10 + 20) = 1;
  *(_QWORD *)(v10 + 168) = v8;
  v11 = sub_4A520(a2, v6, a1 - 176, v10, v7, v7);
  sub_614E0(*(_QWORD *)(a1 + 40), (__int64 *)(v11 + 64));
  return v10 + 176;
}

__int64 __fastcall sub_4BEA0(int *a1, char *a2)
{
  __int64 v2; // rax
  void (__fastcall **v3)(_QWORD, char *, signed __int64, _QWORD); // rbx
  __int64 v4; // r12

  v2 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(*(_QWORD *)a1 + 200LL) + 24LL))(90LL);
  v3 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v2 + 96);
  v4 = v2;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 96), a2);
  sub_2ED90(v3, a1[3]);
  sub_2ED90(v3, a1[30]);
  sub_2ED90(v3, 0x4000);
  return v4;
}

__int64 __fastcall sub_4BF10(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r12
  __int64 v5; // r14
  __int64 v6; // rax
  void (__fastcall **v7)(_QWORD, char *, signed __int64); // rbp
  __int64 v8; // r13
  _QWORD *v9; // rax
  bool v10; // zf

  if ( *(_BYTE *)(a1 + 24) & 0xA )
    __assert_fail(
      "!(c->closes & (CLOSES_SENT_CLOSE | CLOSES_RCVD_CLOSE))",
      "ssh2connection.c",
      0x539u,
      "ssh2_chanreq_init");
  v4 = a3;
  v5 = a4;
  v6 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(*(_QWORD *)a1 + 200LL) + 24LL))(98LL);
  v7 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v6 + 96);
  v8 = v6;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v6 + 96), *(_DWORD *)(a1 + 8));
  sub_2EF40(v7, a2);
  sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v7, v4 != 0);
  if ( v4 )
  {
    v9 = sub_2F450(1uLL, 0x18uLL, 0LL);
    v10 = *(_QWORD *)(a1 + 136) == 0LL;
    *v9 = v4;
    v9[1] = v5;
    v9[2] = 0LL;
    if ( v10 )
      *(_QWORD *)(a1 + 136) = v9;
    else
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16LL) = v9;
    *(_QWORD *)(a1 + 144) = v9;
  }
  return v8;
}

void __fastcall sub_4C000(__int64 a1, unsigned int a2)
{
  __int64 v2; // r12
  unsigned int v3; // ebp
  int v4; // edx
  int v5; // eax
  __int64 v6; // rax
  void (__fastcall **v7)(_QWORD, char *, signed __int64, _QWORD); // r14
  __int64 v8; // r13
  _DWORD *v9; // rax
  __int64 *v10; // rsi

  if ( !(*(_BYTE *)(a1 + 24) & 6) && !*(_DWORD *)(*(_QWORD *)(a1 + 168) + 8LL) )
  {
    v2 = *(_QWORD *)a1;
    v3 = a2;
    v4 = *(_DWORD *)(*(_QWORD *)a1 + 288LL);
    if ( v4 & 0x100 && a2 > 0x4000 )
    {
      v5 = 0x2000;
      v3 = 0x4000;
    }
    else
    {
      v5 = (signed int)a2 / 2;
    }
    if ( *(_DWORD *)(a1 + 120) <= v5 )
    {
      if ( *(_DWORD *)(a1 + 124) != v3 || v4 & 0x400 )
      {
        *(_DWORD *)(a1 + 128) = v3;
        *(_DWORD *)(a1 + 152) = 0;
      }
      else
      {
        v9 = sub_2F450(1uLL, 4uLL, 0LL);
        *v9 = v3 - *(_DWORD *)(a1 + 120);
        v10 = (__int64 *)(sub_4BF10(a1, "winadj@putty.projects.tartarus.org", (__int64)sub_4B110, (__int64)v9) + 64);
        sub_614E0(*(_QWORD *)(v2 + 216), v10);
        if ( *(_DWORD *)(a1 + 152) != 2 )
          *(_DWORD *)(a1 + 152) = 1;
      }
      v6 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v2 + 200) + 24LL))(93LL);
      v7 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v6 + 96);
      v8 = v6;
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v6 + 96), *(_DWORD *)(a1 + 8));
      sub_2ED90(v7, v3 - *(_DWORD *)(a1 + 120));
      sub_614E0(*(_QWORD *)(v2 + 216), (__int64 *)(v8 + 64));
      *(_DWORD *)(a1 + 120) = v3;
    }
  }
}

__int64 __usercall sub_4C140@<rax>(__int64 a1@<rbp>, __int64 a2@<rdi>, signed __int64 a3@<r12>)
{
  __int64 v3; // r15
  unsigned int v4; // ebx
  int *v5; // rax
  __int64 v6; // r14
  int v7; // edx
  unsigned int v8; // eax
  __int64 *v9; // rdi
  __int64 v10; // rax
  unsigned int *v11; // rdi
  unsigned int v12; // esi
  char *v13; // rax
  size_t v14; // rdx
  char *v15; // rbp
  _QWORD *v16; // rax
  __int64 v17; // rbx
  int v18; // eax
  int v19; // ecx
  signed __int64 v20; // rax
  void (__fastcall **v21)(_QWORD, char *, signed __int64); // r14
  char *v22; // rax
  __int64 v23; // rax
  _QWORD *v24; // rdi
  signed __int64 v25; // rdx
  bool v26; // bl
  char v27; // al
  __int64 v28; // rax
  __int64 result; // rax
  char v30; // dl
  size_t v31; // rdx
  bool v32; // al
  size_t v33; // rax
  __int64 v34; // r12
  __int64 v35; // rbx
  size_t v36; // rax
  unsigned int v37; // er14
  __int64 v38; // rdx
  __int64 v39; // r10
  __int64 v40; // r11
  signed __int64 v41; // rdi
  __int64 v42; // rbx
  int v43; // eax
  __int64 v44; // rdi
  int v45; // eax
  int v46; // eax
  __int64 v47; // rdi
  unsigned int v48; // ebx
  char *v49; // rax
  __int64 v50; // rdx
  __int64 v51; // rdi
  __int64 v52; // rcx
  size_t v53; // rax
  signed int v54; // edx
  __int64 v55; // rdi
  unsigned int v56; // eax
  char *v57; // rbx
  unsigned __int64 v58; // rdx
  unsigned int v59; // eax
  char *v60; // rbx
  __int64 v61; // rbx
  unsigned int v62; // eax
  __int64 v63; // rdx
  unsigned int v64; // edx
  _QWORD *v65; // rbx
  _QWORD *v66; // rbx
  unsigned int v67; // eax
  char v68; // al
  int v69; // eax
  __int64 v70; // rdx
  unsigned int v71; // eax
  int v72; // eax
  __int64 v73; // rax
  size_t v74; // rsi
  int v75; // ebx
  char *v76; // rax
  char *v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rdx
  char *v80; // rax
  __int64 v81; // r14
  unsigned int v82; // eax
  __int64 v83; // rdx
  __int64 v84; // rdx
  __int64 v85; // rax
  __int64 *v86; // rdi
  __int64 v87; // r11
  size_t v88; // rsi
  __int64 v89; // r14
  char *v90; // rax
  size_t v91; // rdx
  char *v92; // rax
  __int64 v93; // rdx
  __int64 v94; // rdx
  __int64 v95; // rcx
  __int64 v96; // r8
  __int64 v97; // r9
  __int64 *v98; // rax
  __int64 v99; // r11
  char *v100; // r14
  __int64 v101; // rdx
  char *v102; // rax
  __int64 v103; // rdx
  char *v104; // rsi
  unsigned int v105; // eax
  size_t v106; // r14
  char *v107; // rax
  __int64 v108; // r14
  unsigned int v109; // eax
  char v110; // [rsp-518h] [rbp-1150h]
  __int64 v111; // [rsp-10h] [rbp-C48h]
  _QWORD *v112; // [rsp+8h] [rbp-C30h]
  size_t n; // [rsp+10h] [rbp-C28h]
  __int64 v114; // [rsp+18h] [rbp-C20h]
  int *v115; // [rsp+20h] [rbp-C18h]
  __int64 v116; // [rsp+28h] [rbp-C10h]
  unsigned int *v117; // [rsp+30h] [rbp-C08h]
  size_t v118; // [rsp+38h] [rbp-C00h]
  __int64 v119; // [rsp+40h] [rbp-BF8h]
  __int64 v120; // [rsp+48h] [rbp-BF0h]
  __int64 v121; // [rsp+50h] [rbp-BE8h]
  char v122; // [rsp+5Fh] [rbp-BD9h]
  __int64 v123; // [rsp+60h] [rbp-BD8h]
  char *v124; // [rsp+68h] [rbp-BD0h]
  unsigned int v125; // [rsp+7Ch] [rbp-BBCh]
  int v126; // [rsp+80h] [rbp-BB8h]
  unsigned int *v127; // [rsp+88h] [rbp-BB0h]
  int v128; // [rsp+90h] [rbp-BA8h]
  char *v129; // [rsp+A0h] [rbp-B98h]
  __int64 v130; // [rsp+A8h] [rbp-B90h]
  __int64 v131; // [rsp+B0h] [rbp-B88h]
  int v132; // [rsp+B8h] [rbp-B80h]
  __int64 *v133; // [rsp+C0h] [rbp-B78h]
  char v134; // [rsp+D0h] [rbp-B68h]
  int v135; // [rsp+5D8h] [rbp-660h]
  char v136; // [rsp+5E0h] [rbp-658h]
  int v137; // [rsp+AE8h] [rbp-150h]
  char v138; // [rsp+AF0h] [rbp-148h]
  unsigned __int64 v139; // [rsp+BF8h] [rbp-40h]

  v3 = a2;
  v139 = __readfsqword(0x28u);
  v112 = (_QWORD *)(a2 + 192);
  v117 = &v125;
  while ( 1 )
  {
    v4 = sub_50560(v112, v3);
    if ( !(_BYTE)v4 )
    {
      v5 = (int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v3 + 208) + 48LL))(
                    *(_QWORD *)(v3 + 208),
                    *(_QWORD *)(v3 + 208),
                    0LL);
      v6 = (__int64)v5;
      if ( v5 )
      {
        v7 = *v5;
        switch ( *v5 )
        {
          case 80:
            a1 = (__int64)sub_2F1D0((__int64)(v5 + 12));
            a3 = v25;
            v26 = sub_2F0C0(v6 + 48);
            v27 = sub_4A510();
            if ( v26 )
            {
              v28 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(v3 + 200) + 24LL))(
                      (unsigned int)(v27 == 0) + 81,
                      a1);
              sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(v28 + 64));
            }
            goto LABEL_11;
          case 81:
          case 82:
            v23 = *(_QWORD *)(v3 + 160);
            if ( v23 )
            {
              (*(void (__fastcall **)(__int64, __int64, _QWORD))v23)(v3, v6, *(_QWORD *)(v23 + 8));
              v24 = *(_QWORD **)(v3 + 160);
              *(_QWORD *)(v3 + 160) = v24[2];
              sub_2F4D0(v24);
              goto LABEL_11;
            }
            v4 = 1;
            sub_621E0(
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 4LL),
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 8LL),
              v7);
            sub_423C0(
              *(_QWORD *)(v3 + 280),
              (__int64)"Received %s with no outstanding global request",
              (__int64)off_EACA0,
              v3);
            break;
          case 90:
            v13 = sub_2F1D0((__int64)(v5 + 12));
            n = v14;
            v15 = v13;
            v16 = sub_2F450(1uLL, 0xC0uLL, 0LL);
            *v16 = v3;
            v16[21] = 0LL;
            v17 = (__int64)v16;
            v115 = (int *)sub_2F150(v6 + 48);
            v118 = sub_2F150(v6 + 48);
            a3 = sub_2F150(v6 + 48);
            sub_4A0A0((__int64)&v126, v3, v15, n, v6, (__int64 (__fastcall **)())(v17 + 176));
            v18 = v126;
            a1 = (__int64)v127;
            if ( v126 == 2 )
            {
              sub_83120(v127, *(_DWORD *)v6, *(_QWORD *)(v6 + 48), *(_DWORD *)(v6 + 64));
              sub_2F4D0((void *)v17);
              continue;
            }
            v19 = (signed int)v115;
            *(_BYTE *)(v17 + 20) = 0;
            *(_DWORD *)(v17 + 8) = v19;
            if ( v18 )
            {
              *(_QWORD *)(v17 + 168) = a1;
              sub_4BD00(v17, v3);
              v69 = v118;
              *(_DWORD *)(v17 + 116) = a3;
              *(_DWORD *)(v17 + 112) = v69;
              v70 = **(_QWORD **)(v3 + 200);
              v71 = *(_DWORD *)(v70 + 40);
              if ( v71 < (unsigned int)a3 )
                *(_DWORD *)(v17 + 116) = v71;
              v72 = *(_DWORD *)(*(_QWORD *)(v17 + 168) + 8LL);
              if ( v72 )
              {
                *(_DWORD *)(v17 + 128) = v72;
                *(_DWORD *)(v17 + 124) = v72;
                *(_DWORD *)(v17 + 120) = v72;
              }
              v73 = (*(__int64 (__fastcall **)(signed __int64))(v70 + 24))(91LL);
              a3 = v73 + 96;
              a1 = v73;
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v73 + 96), *(_DWORD *)(v17 + 8));
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, *(_DWORD *)(v17 + 12));
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, *(_DWORD *)(v17 + 120));
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, 0x4000);
              sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(a1 + 64));
            }
            else
            {
              v20 = (*(__int64 (__fastcall **)(signed __int64, __int64))(**(_QWORD **)(v3 + 200) + 24LL))(92LL, v3);
              v21 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v20 + 96);
              a3 = v20;
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v20 + 96), *(_DWORD *)(v17 + 8));
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v21, v128);
              sub_2EF40(v21, (char *)a1);
              sub_2EF40(v21, "en");
              sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(a3 + 64));
              v22 = sub_BC360((__int64)"Rejected channel open: %s", a1);
              sub_2D3A0(*(_QWORD *)(v3 + 264), v22, (__int64)off_EACA0, v3);
              sub_2F4D0((void *)a1);
              sub_2F4D0((void *)v17);
            }
            goto LABEL_11;
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 97:
          case 98:
          case 99:
          case 100:
            v115 = v5 + 12;
            v8 = sub_2F150((__int64)(v5 + 12));
            v9 = *(__int64 **)(v3 + 72);
            v125 = v8;
            v10 = sub_9B3D0(v9, (__int64)v117, (__int64 (__fastcall *)(__int64))sub_4AF00);
            a3 = v10;
            if ( !v10 )
            {
              v12 = *(_DWORD *)v6;
              a1 = v125;
LABEL_17:
              sub_621E0(
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 4LL),
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 8LL),
                v12);
              v4 = 1;
              sub_423C0(*(_QWORD *)(v3 + 280), (__int64)"Received %s for %s channel %u", (__int64)off_EACA0, v3);
              break;
            }
            v11 = *(unsigned int **)(v10 + 160);
            v12 = *(_DWORD *)v6;
            if ( v11 )
            {
              sub_83120(v11, v12, *(_QWORD *)(v6 + 48), *(_QWORD *)(v6 + 64));
              goto LABEL_11;
            }
            v30 = *(_BYTE *)(v10 + 20);
            if ( v30 != v12 - 91 <= 1 )
            {
              a1 = v125;
              goto LABEL_17;
            }
            switch ( v12 )
            {
              case 0x5Bu:
                if ( !v30 )
                  __assert_fail("c->halfopen", "ssh2connection.c", 0x1E6u, "ssh2_connection_filter_queue");
                v61 = (__int64)v115;
                *(_DWORD *)(v10 + 8) = sub_2F150((__int64)v115);
                *(_BYTE *)(a3 + 20) = 0;
                *(_DWORD *)(a3 + 112) = sub_2F150(v61);
                v62 = sub_2F150(v61);
                v63 = *(_QWORD *)(v3 + 200);
                *(_DWORD *)(a3 + 116) = v62;
                v64 = *(_DWORD *)(*(_QWORD *)v63 + 40LL);
                if ( v62 > v64 )
                  *(_DWORD *)(a3 + 116) = v64;
                (*(void (**)(void))(**(_QWORD **)(a3 + 168) + 8LL))();
                sub_4B640(a3, v3);
                if ( *(_BYTE *)(a3 + 28) )
                  sub_4B770(a3, v3);
                goto LABEL_11;
              case 0x5Cu:
                if ( !v30 )
                  __assert_fail("c->halfopen", "ssh2connection.c", 0x206u, "ssh2_connection_filter_queue");
                v56 = sub_2F150((__int64)v115);
                if ( v56 > 4 || (v57 = (char *)qword_31F000[v56]) == 0LL )
                {
                  v57 = &v138;
                  __sprintf_chk(&v138, 1LL, 256LL, "unknown reason code %#x", v56);
                }
                a1 = (__int64)sub_2F1D0((__int64)v115);
                v59 = sub_BC2F0(v58);
                v60 = sub_BC360((__int64)"%s [%.*s]", v57, v59, a1);
                (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a3 + 168) + 16LL))(*(_QWORD *)(a3 + 168), v60);
                sub_2F4D0(v60);
                sub_9B440(*(__int64 **)(v3 + 72), a3);
                sub_4B1F0((_QWORD *)a3);
                goto LABEL_11;
              case 0x5Du:
                if ( !(*(_BYTE *)(v10 + 24) & 1) )
                {
                  *(_DWORD *)(v10 + 112) += sub_2F150((__int64)v115);
                  if ( !(*(_BYTE *)(a3 + 24) & 1) && !(unsigned int)sub_4B850(a3, v3) )
                  {
                    *(_BYTE *)(a3 + 30) = 0;
                    sub_4AF20(a3);
                  }
                }
                goto LABEL_11;
              case 0x5Eu:
              case 0x5Fu:
                v48 = 0;
                if ( v12 != 94 )
                  v48 = sub_2F150((__int64)v115);
                v49 = sub_2F1D0((__int64)v115);
                if ( !*(_DWORD *)(v6 + 72) )
                {
                  v51 = *(_QWORD *)(a3 + 168);
                  *(_DWORD *)(a3 + 120) -= v50;
                  v52 = 0LL;
                  *(_DWORD *)(a3 + 128) -= v50;
                  if ( v48 < 2 )
                    v52 = v50;
                  v53 = (*(__int64 (__fastcall **)(__int64, bool, char *, __int64))(*(_QWORD *)v51 + 24LL))(
                          v51,
                          v48 == 1,
                          v49,
                          v52);
                  if ( !*(_QWORD *)(a3 + 160) )
                  {
                    v54 = *(_DWORD *)(a3 + 124);
                    if ( *(_DWORD *)(a3 + 128) <= 0 && *(_DWORD *)(a3 + 152) == 2 && v54 <= 0x3FFFFFFF )
                    {
                      v54 += 0x4000;
                      *(_DWORD *)(a3 + 124) = v54;
                    }
                    if ( (signed int)v53 < v54 )
                    {
                      n = v53;
                      sub_4C000(a3, v54 - v53);
                      v54 = *(_DWORD *)(a3 + 124);
                      LODWORD(v53) = n;
                    }
                    if ( (v54 < (signed int)v53 || *(_BYTE *)(v3 + 61) && (signed int)v53 > 0) && !*(_BYTE *)(a3 + 29) )
                    {
                      v55 = *(_QWORD *)(v3 + 280);
                      *(_BYTE *)(a3 + 29) = 1;
                      sub_42860(v55, 1);
                    }
                  }
                }
                goto LABEL_11;
              case 0x60u:
                v46 = *(_DWORD *)(v10 + 24);
                if ( !(v46 & 4) )
                {
                  v47 = *(_QWORD *)(a3 + 168);
                  *(_DWORD *)(a3 + 24) = v46 | 4;
                  (*(void (**)(void))(*(_QWORD *)v47 + 32LL))();
                  sub_4B640(a3, v3);
                }
                goto LABEL_11;
              case 0x61u:
                v43 = *(_DWORD *)(v10 + 24);
                if ( !(v43 & 4) )
                {
                  v44 = *(_QWORD *)(a3 + 168);
                  *(_DWORD *)(a3 + 24) = v43 | 4;
                  (*(void (**)(void))(*(_QWORD *)v44 + 32LL))();
                }
                if ( !(*(_BYTE *)(v3 + 289) & 8) )
                {
                  while ( 1 )
                  {
                    v66 = *(_QWORD **)(a3 + 136);
                    if ( !v66 )
                      break;
                    ((void (__fastcall *)(signed __int64, _QWORD, _QWORD))*v66)(a3, 0LL, v66[1]);
                    *(_QWORD *)(a3 + 136) = v66[2];
                    sub_2F4D0(v66);
                  }
                }
                v45 = *(_DWORD *)(a3 + 24);
                if ( !(v45 & 1) )
                {
                  sub_BCCA0(a3 + 32);
                  sub_BCCA0(a3 + 72);
                  (*(void (__fastcall **)(signed __int64))(*(_QWORD *)(a3 + 176) + 8LL))(a3 + 176);
                  sub_4AF20(a3);
                  v45 = *(_DWORD *)(a3 + 24);
                }
                if ( !(v45 & 8) )
                {
                  *(_DWORD *)(a3 + 24) = v45 | 8;
                  sub_4B640(a3, v3);
                }
                goto LABEL_11;
              case 0x62u:
                a1 = (__int64)sub_2F1D0((__int64)v115);
                n = v31;
                v32 = sub_2F0C0((__int64)v115);
                if ( !(*(_BYTE *)(a3 + 24) & 2) )
                  LOBYTE(v4) = v32;
                v118 = n;
                if ( (unsigned __int8)sub_BD100((void *)a1, n, "exit-status") )
                {
                  v67 = sub_2F150((__int64)v115);
                  v68 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 + 168) + 64LL))(
                          *(_QWORD *)(a3 + 168),
                          v67);
                  goto LABEL_79;
                }
                if ( (unsigned __int8)sub_BD100((void *)a1, v118, &unk_EAA83) )
                {
                  v33 = *(_QWORD *)(v6 + 56);
                  v121 = a3;
                  v34 = 0LL;
                  a1 = (__int64)v115;
                  v122 = v4;
                  v35 = v6;
                  n = v33;
                  while ( 1 )
                  {
                    v36 = n;
                    LODWORD(v120) = v34;
                    *(_DWORD *)(v35 + 72) = 0;
                    *(_QWORD *)(v35 + 56) = v36;
                    if ( !v34 )
                      break;
                    v37 = sub_2F150(a1);
                    LOBYTE(v115) = sub_2F0C0(a1);
                    v118 = (size_t)sub_2F1D0(a1);
                    v119 = v38;
                    sub_2F1D0(a1);
                    if ( !*(_DWORD *)(v35 + 72) )
                    {
                      v39 = 0LL;
                      v40 = 0LL;
LABEL_30:
                      if ( *(_QWORD *)(v35 + 64) == *(_QWORD *)(v35 + 56) )
                      {
                        a3 = v121;
                        LOBYTE(v4) = v122;
                        if ( (_DWORD)v120 )
                        {
                          if ( (_DWORD)v120 != 1 )
                            goto LABEL_33;
                          v68 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, size_t, __int64))(**(_QWORD **)(v121 + 168) + 80LL))(
                                  *(_QWORD *)(v121 + 168),
                                  v37,
                                  (unsigned __int8)v115,
                                  v118,
                                  v119);
                        }
                        else
                        {
                          v68 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, size_t, __int64))(**(_QWORD **)(v121 + 168) + 72LL))(
                                  *(_QWORD *)(v121 + 168),
                                  v40,
                                  v39,
                                  (unsigned __int8)v115,
                                  v118,
                                  v119);
                        }
                        goto LABEL_79;
                      }
                    }
                    if ( (_DWORD)v34 == 1 )
                    {
                      LOBYTE(v4) = v122;
                      a3 = v121;
                      goto LABEL_33;
                    }
LABEL_92:
                    ++v34;
                  }
                  v77 = sub_2F1D0(a1);
                  v123 = v78;
                  v124 = v77;
                  LOBYTE(v115) = sub_2F0C0(a1);
                  v118 = (size_t)sub_2F1D0(a1);
                  v119 = v79;
                  sub_2F1D0(a1);
                  if ( *(_DWORD *)(v35 + 72) )
                    goto LABEL_92;
                  v39 = v123;
                  v40 = (__int64)v124;
                  v37 = 0;
                  goto LABEL_30;
                }
                v74 = v118;
                if ( (unsigned __int8)sub_BD100((void *)a1, v118, "shell") )
                {
                  v68 = (*(__int64 (__fastcall **)(_QWORD, size_t))(**(_QWORD **)(a3 + 168) + 88LL))(
                          *(_QWORD *)(a3 + 168),
                          v74);
                  goto LABEL_79;
                }
                if ( (unsigned __int8)sub_BD100((void *)a1, v118, "exec") )
                {
                  v76 = sub_2F1D0((__int64)v115);
                  v68 = (*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a3 + 168) + 96LL))(
                          *(_QWORD *)(a3 + 168),
                          v76);
                  goto LABEL_79;
                }
                goto LABEL_105;
              case 0x63u:
              case 0x64u:
                v65 = *(_QWORD **)(v10 + 136);
                if ( v65 )
                {
                  ((void (__fastcall *)(__int64, __int64, _QWORD))*v65)(v10, v6, v65[1]);
                  *(_QWORD *)(a3 + 136) = v65[2];
                  sub_2F4D0(v65);
                  sub_4B640(a3, v3);
                  goto LABEL_11;
                }
                v75 = *(_DWORD *)(v10 + 12);
                sub_621E0(
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 4LL),
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 200) + 144LL) + 8LL),
                  v12);
                v4 = 1;
                sub_423C0(
                  *(_QWORD *)(v3 + 280),
                  (__int64)"Received %s for channel %d with no outstanding channel request",
                  (__int64)off_EACA0,
                  v3);
                break;
              default:
                goto LABEL_11;
            }
            break;
          default:
            break;
        }
      }
    }
    result = v4;
    if ( __readfsqword(0x28u) == v139 )
      return result;
LABEL_105:
    if ( (unsigned __int8)sub_BD100((void *)a1, v118, "subsystem") )
    {
      v80 = sub_2F1D0((__int64)v115);
      v68 = (*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a3 + 168) + 104LL))(*(_QWORD *)(a3 + 168), v80);
    }
    else if ( (unsigned __int8)sub_BD100((void *)a1, v118, "x11-req") )
    {
      v81 = (__int64)v115;
      LOBYTE(v82) = sub_2F0C0((__int64)v115);
      a1 = v82;
      n = (size_t)sub_2F1D0(v81);
      v114 = v83;
      v115 = (int *)sub_2F1D0(v81);
      v116 = v84;
      v85 = sub_2F150(v81);
      v86 = *(__int64 **)(a3 + 168);
      v87 = *v86;
      v111 = v85;
      v68 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, size_t, __int64, int *, __int64, __int64))(v87 + 112))(
              v86,
              (unsigned __int8)a1,
              n,
              v114,
              v115,
              v116,
              v85);
    }
    else
    {
      v88 = v118;
      if ( (unsigned __int8)sub_BD100((void *)a1, v118, "auth-agent-req@openssh.com") )
      {
        v68 = (*(__int64 (__fastcall **)(_QWORD, size_t))(**(_QWORD **)(a3 + 168) + 120LL))(*(_QWORD *)(a3 + 168), v88);
      }
      else if ( (unsigned __int8)sub_BD100((void *)a1, v118, "pty-req") )
      {
        v89 = (__int64)v115;
        v90 = sub_2F1D0((__int64)v115);
        v118 = v91;
        v115 = (int *)v90;
        n = sub_2F150(v89);
        v120 = sub_2F150(v89);
        v119 = sub_2F150(v89);
        a1 = sub_2F150(v89);
        v92 = sub_2F1D0(v89);
        v131 = v93;
        v129 = v92;
        v130 = 0LL;
        v132 = 0;
        v133 = (__int64 *)&v129;
        sub_61BA0(&v134, (__int64)&v129, 2);
        if ( *((_DWORD *)v133 + 6) || (v95 = v133[1], v97 = v119, v96 = v120, v133[2] != v95) )
        {
          v104 = sub_BC360((__int64)"Unable to decode terminal mode string", &v129, v94, v95, v96, v97);
          sub_2D3A0(*(_QWORD *)(v3 + 264), v104, (__int64)off_EACA0, v3);
LABEL_33:
          if ( !(_BYTE)v4 )
            goto LABEL_11;
LABEL_34:
          v41 = 100LL;
LABEL_35:
          v42 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v3 + 200) + 24LL))(v41);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v42 + 96), *(_DWORD *)(a3 + 8));
          sub_614E0(*(_QWORD *)(v3 + 216), (__int64 *)(v42 + 64));
          goto LABEL_11;
        }
        qmemcpy(&v136, &v134, 0x508uLL);
        v98 = *(__int64 **)(a3 + 168);
        v99 = *v98;
        v137 = v135;
        qmemcpy(&v110, &v136, 0x508uLL);
        LODWORD(v111) = v135;
        v68 = (*(__int64 (__fastcall **)(__int64 *, int *, size_t, _QWORD, __int64, __int64, __int64))(v99 + 128))(
                v98,
                v115,
                v118,
                (unsigned int)n,
                v120,
                v119,
                a1);
      }
      else if ( (unsigned __int8)sub_BD100((void *)a1, v118, "env") )
      {
        v100 = sub_2F1D0((__int64)v115);
        a1 = v101;
        v102 = sub_2F1D0((__int64)v115);
        v68 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64, char *, __int64))(**(_QWORD **)(a3 + 168) + 136LL))(
                *(_QWORD *)(a3 + 168),
                v100,
                a1,
                v102,
                v103);
      }
      else if ( (unsigned __int8)sub_BD100((void *)a1, v118, "break") )
      {
        v105 = sub_2F150((__int64)v115);
        v68 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a3 + 168) + 144LL))(*(_QWORD *)(a3 + 168), v105);
      }
      else
      {
        v106 = n;
        if ( (unsigned __int8)sub_BD100((void *)a1, n, "signal") )
        {
          v107 = sub_2F1D0((__int64)v115);
          v68 = (*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a3 + 168) + 152LL))(
                  *(_QWORD *)(a3 + 168),
                  v107);
        }
        else
        {
          if ( !(unsigned __int8)sub_BD100((void *)a1, v106, "window-change") )
            goto LABEL_33;
          v108 = (__int64)v115;
          n = sub_2F150((__int64)v115);
          a1 = sub_2F150(v108);
          v115 = (int *)v108;
          LODWORD(v108) = sub_2F150(v108);
          v109 = sub_2F150((__int64)v115);
          v68 = (*(__int64 (__fastcall **)(_QWORD, size_t, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a3 + 168) + 160LL))(
                  *(_QWORD *)(a3 + 168),
                  n,
                  (unsigned int)a1,
                  (unsigned int)v108,
                  v109);
        }
      }
    }
LABEL_79:
    if ( (_BYTE)v4 )
    {
      v41 = 99LL;
      if ( !v68 )
        goto LABEL_34;
      goto LABEL_35;
    }
LABEL_11:
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(v3 + 208) + 48LL))(
      *(_QWORD *)(v3 + 208),
      *(_QWORD *)(v3 + 208),
      1LL);
  }
}

__int64 __usercall sub_4D0C0@<rax>(__int64 a1@<rdi>, signed __int64 a2@<r12>, char *a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  __int64 result; // rax
  int v7; // eax
  char v8; // r9
  __int64 *v9; // rdx
  int v10; // ecx
  int v11; // er8
  unsigned int *v12; // rbp
  __int64 v13; // rdx
  __int64 v14; // rdi
  _QWORD *v15; // rax
  char *v16; // rax

  v4 = a1 - 192;
  v5 = a1;
  result = sub_4C140(a1 - 192, a1 - 192, a2);
  if ( (_BYTE)result )
    return result;
  result = *(unsigned int *)(a1 - 192);
  if ( (_DWORD)result == 1004 )
  {
    *(_BYTE *)(a1 - 132) = 0;
    v7 = *(_DWORD *)(a1 - 56);
    goto LABEL_10;
  }
  if ( (_DWORD)result == 1045 )
  {
LABEL_13:
    sub_4C140(v4, v4, a2);
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(v5 + 16) + 48LL))(
               *(_QWORD *)(v5 + 16),
               *(_QWORD *)(v5 + 16),
               1LL);
    v12 = (unsigned int *)result;
    if ( result )
    {
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 144LL) + 8LL),
        *(_DWORD *)result);
      v13 = *v12;
      result = sub_423C0(
                 *(_QWORD *)(v5 + 88),
                 (__int64)"Received unexpected connection-layer packet, type %d (%s)",
                 (__int64)a3,
                 a4);
    }
    else
    {
      *(_DWORD *)(v5 - 192) = 1045;
    }
    return result;
  }
  if ( (_DWORD)result )
  {
    *(_DWORD *)(a1 - 192) = 0;
    return result;
  }
  v14 = *(_QWORD *)(a1 - 184);
  if ( v14 )
    sub_83560(v14, *(const char **)(v5 - 176));
  if ( !(unsigned __int8)sub_4AEA0(v4) )
  {
LABEL_12:
    sub_38070(*(_QWORD *)(v5 - 80), *(__int64 **)(v5 - 128), a3);
    v8 = *(_BYTE *)(v5 - 131);
    v9 = *(__int64 **)(v5 - 128);
    v10 = *(_DWORD *)(v5 - 140);
    v11 = *(_DWORD *)(v5 - 136);
    *(_BYTE *)(v5 - 72) = 1;
    *(_QWORD *)(v5 - 168) = sub_2E040(v5, v4 + 176, v9, v10, v11, v8, (_QWORD *)(v4 + 32));
    *(_BYTE *)(v5 - 129) = 1;
    goto LABEL_13;
  }
  v15 = sub_31B10();
  *(_QWORD *)(v5 - 64) = v15;
  *(_BYTE *)v15 = 1;
  *((_BYTE *)v15 + 1) = 0;
  a2 = (signed __int64)v15;
  v15[1] = sub_BC120("Authentication successful");
  v16 = sub_BC120("Access granted. Press Return to begin session. ");
  sub_31B70(*(_QWORD **)(v5 - 64), (__int64)v16, 0);
  v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v5 + 80) + 16LL))(
         *(_QWORD *)(v5 + 80),
         *(_QWORD *)(v5 - 64),
         0LL);
  for ( *(_DWORD *)(v5 - 56) = v7; ; *(_DWORD *)(v5 - 56) = v7 )
  {
LABEL_10:
    if ( v7 >= 0 )
      goto LABEL_11;
    result = sub_BCD00(*(_QWORD *)(v5 + 64));
    if ( !result )
      break;
    v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v5 + 80) + 16LL))(
           *(_QWORD *)(v5 + 80),
           *(_QWORD *)(v5 - 64),
           *(_QWORD *)(v5 + 64));
  }
  if ( *(_DWORD *)(v5 - 56) >= 0 )
  {
LABEL_11:
    sub_31C50(*(_QWORD *)(v5 - 64));
    *(_QWORD *)(v5 - 64) = 0LL;
    goto LABEL_12;
  }
  *(_BYTE *)(v5 - 132) = 1;
  *(_DWORD *)(v5 - 192) = 1004;
  return result;
}

void __fastcall sub_4D2D0(__int64 a1)
{
  if ( *(_DWORD *)(*(_QWORD *)(a1 - 8) + 8LL) )
    __assert_fail(
      "!c->chan->initial_fixed_window_size",
      "ssh2connection.c",
      0x5A8u,
      "ssh2channel_window_override_removed");
  sub_4C000(a1 - 176, *(_BYTE *)(*(_QWORD *)(a1 - 176) + 61LL) < 1u ? 0x4000 : 0x7FFFFFFF);
}

void __fastcall sub_4D330(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbp
  unsigned __int64 v3; // rdx

  v2 = *(_QWORD *)(a1 - 176);
  if ( *(_BYTE *)(v2 + 61) )
  {
    v3 = 0LL;
  }
  else
  {
    v3 = *(signed int *)(a1 - 52);
    if ( v3 > a2 )
    {
      sub_4C000(a1 - 176, *(_DWORD *)(a1 - 52) - a2);
      if ( !*(_BYTE *)(a1 - 147) )
        return;
      goto LABEL_4;
    }
  }
  if ( *(_BYTE *)(a1 - 147) && a2 <= v3 )
  {
LABEL_4:
    *(_BYTE *)(a1 - 147) = 0;
    sub_42860(*(_QWORD *)(v2 + 280), -1);
  }
}

__int64 __fastcall sub_4D3B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = *(_QWORD *)(a1 - 176);
  v2 = sub_4BF10(a1 - 176, "simple@putty.projects.tartarus.org", 0LL, 0LL);
  return sub_614E0(*(_QWORD *)(v1 + 216), (__int64 *)(v2 + 64));
}

unsigned __int64 __usercall sub_4D3E0@<rax>(__int64 a1@<rdi>, _BYTE *a2@<rsi>, __int64 a3@<r13>, char *a4@<r15>)
{
  _BYTE *v4; // rbp
  __int64 v5; // rbx
  signed int v6; // eax
  int v7; // eax
  __int64 v8; // rax
  char *v9; // r12
  __int64 v10; // rdi
  int *v11; // rax
  int *v12; // r12
  __int64 v13; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v15; // rt1
  _QWORD *v16; // rax
  unsigned int v17; // er12
  _QWORD *v18; // rax
  __int64 v19; // rdx
  __int64 v20; // r12
  unsigned int v21; // eax
  char *v22; // rax
  __int64 v23; // r12
  int *v24; // rax
  int *v25; // r12
  char *v26; // rax
  __int64 (__fastcall **v27)(_QWORD, char *); // rcx
  __int64 v28; // rdx
  char *v29; // rax
  unsigned int v30; // er11
  __int64 v31; // rdx
  __int64 v32; // r12
  char *v33; // rsi
  __int64 v34; // rax
  unsigned __int64 v35; // rdx
  char *v36; // rax
  __int64 v37; // rdx
  unsigned __int64 v38; // r12
  signed __int64 v39; // rax
  __int64 v40; // rax
  int v41; // eax
  __int64 *v42; // rdx
  int v43; // eax
  unsigned __int64 v44; // r12
  unsigned __int64 *v45; // r13
  __int64 *v46; // rax
  signed __int64 v47; // r12
  __int64 v48; // r14
  int *v49; // rax
  int *v50; // r12
  __int64 v51; // rdx
  char *v52; // rax
  int *v53; // rax
  int *v54; // r12
  __int64 v55; // rdx
  __int64 v56; // rdi
  int v57; // eax
  __int64 v58; // rax
  __int64 v59; // rcx
  unsigned __int64 v60; // rdx
  unsigned __int64 v61; // rax
  __int64 v62; // rdx
  __int64 v63; // rdx
  char *v64; // rsi
  _QWORD *v65; // rdx
  int v66; // eax
  int v67; // ecx
  int v68; // eax
  signed int v69; // eax
  __int64 (__fastcall *v70)(signed __int64, char *); // rax
  __int64 v71; // r12
  int *v72; // rax
  int *v73; // r12
  int v74; // edx
  __int64 v75; // rdx
  int *v76; // rax
  int *v77; // r12
  int v78; // edx
  __int64 v79; // r12
  unsigned __int64 v80; // rdx
  unsigned int v81; // eax
  char *v82; // rax
  __int64 v83; // rdx
  __int64 v84; // rax
  int v85; // eax
  __int64 v86; // rdx
  int v87; // eax
  int v88; // ecx
  int v89; // eax
  char *v90; // rsi
  __int64 v91; // rax
  __int64 v92; // r12
  int *v93; // rax
  _QWORD *v94; // rax
  unsigned int v95; // er8
  char *v96; // rax
  __int64 v97; // rax
  __int64 v98; // rcx
  char *v99; // rax
  int v100; // eax
  __int64 v101; // rsi
  __int64 v102; // rdx
  signed __int64 v103; // rax
  unsigned int v104; // eax
  __int64 v105; // rax
  __int64 v106; // rax
  unsigned __int64 v107; // rdx
  __int64 v108; // r14
  char *v109; // rax
  __int64 v110; // rdx
  unsigned __int64 *v111; // rax
  __int64 v112; // rdi
  void (__fastcall **v113)(_QWORD, char *, signed __int64, _QWORD); // rdi
  _QWORD *v114; // rdi
  __int64 v115; // rdi
  __int64 v116; // rax
  __int64 v117; // rax
  __int64 v118; // rsi
  int v119; // eax
  void *v120; // r12
  __int64 v121; // r12
  __int64 v122; // rax
  char *v123; // rsi
  __int64 v124; // rdi
  _QWORD *v125; // rax
  __int64 v126; // r12
  __int64 v127; // r14
  char *v128; // rax
  char *v129; // rsi
  __int64 v130; // rax
  unsigned __int64 v131; // rdx
  signed __int64 v132; // r13
  unsigned __int64 v133; // rdx
  __int64 v134; // rax
  unsigned int v135; // er10
  char *v136; // rax
  unsigned int v137; // er9
  __int64 v138; // rdx
  char *v139; // rax
  __int64 v140; // rdx
  __int64 v141; // rdi
  __int64 v142; // rax
  __int64 v143; // rdx
  __int64 v144; // r12
  unsigned int v145; // eax
  char *v146; // rax
  __int64 v147; // rdx
  char *v148; // rax
  __int64 (__fastcall **v149)(_QWORD, char *); // rcx
  __int64 v150; // rdx
  __int64 v151; // r12
  __int64 v152; // rdx
  __int64 v153; // rdi
  bool v154; // zf
  __int64 v155; // rdi
  void *v156; // r12
  char *v157; // rax
  char *v158; // rax
  __int64 v159; // rax
  __int64 v160; // rdx
  char *v161; // r14
  __int64 v162; // r13
  char *v163; // rsi
  int v164; // ecx
  signed __int64 v165; // rax
  signed __int64 v166; // rcx
  char *v167; // rcx
  char *v168; // rdx
  void **v169; // r12
  char *v170; // rax
  char *v171; // rax
  int v172; // eax
  __int64 v173; // rax
  __int64 v174; // rdx
  char *v175; // rax
  char *v176; // ST28_8
  __int64 v177; // r8
  char *v178; // rax
  _QWORD *v179; // rdi
  char *v180; // rsi
  int v181; // edx
  __int64 v182; // rax
  _QWORD *v183; // rdi
  char *v184; // rax
  char *v185; // rax
  __int64 v186; // rcx
  __int64 v187; // rsi
  __int64 v188; // rdi
  __int64 v189; // rdx
  unsigned __int64 *v190; // rax
  __int64 v191; // rdi
  void *v192; // r12
  char *v193; // rax
  char *v194; // rax
  char *v195; // rax
  char *v196; // rax
  char *v197; // rsi
  __int64 v198; // [rsp+10h] [rbp-58h]
  __int64 v199; // [rsp+18h] [rbp-50h]
  unsigned __int64 v200; // [rsp+28h] [rbp-40h]

  v4 = a2;
  v5 = a1;
  v200 = __readfsqword(0x28u);
  v6 = *(_DWORD *)(a1 + 4);
  if ( v6 == 295 )
    goto LABEL_80;
  if ( v6 > 295 )
  {
    if ( v6 != 532 )
    {
      if ( v6 > 532 )
      {
        if ( v6 != 619 )
        {
          if ( v6 == 872 )
          {
LABEL_7:
            v7 = *(_DWORD *)(v5 + 896);
            if ( v7 < 0 )
              goto LABEL_20;
            if ( v7 )
              goto LABEL_9;
            sub_42660(*(_QWORD *)(v5 + 4216), (__int64)"User aborted at host key verification", a3, (__int64)a4);
            goto LABEL_106;
          }
LABEL_12:
          *(_DWORD *)(v5 + 4) = 0;
          goto LABEL_20;
        }
LABEL_34:
        v49 = (int *)sub_50890(v5, (__int64)a4);
        v50 = v49;
        if ( !v49 )
          goto LABEL_20;
        if ( *v49 != 32 )
        {
          sub_621E0(
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
            *v49);
          v51 = (unsigned int)*v50;
          sub_423C0(
            *(_QWORD *)(v5 + 4216),
            (__int64)"Received unexpected packet when expecting RSA kex signature, type %d (%s)",
            a3,
            (__int64)a4);
          *v4 = 1;
          goto LABEL_20;
        }
        v139 = sub_2F1D0((__int64)(v49 + 12));
        *(_QWORD *)(v5 + 712) = v140;
        LODWORD(v140) = v50[18];
        *(_QWORD *)(v5 + 704) = v139;
        if ( (_DWORD)v140 )
        {
          sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Unable to parse RSA kex signature", a3, (__int64)a4);
          *v4 = 1;
          goto LABEL_20;
        }
        goto LABEL_115;
      }
      if ( v6 != 407 )
        goto LABEL_12;
      while ( 1 )
      {
        v76 = (int *)sub_50890(v5, (__int64)a4);
        v77 = v76;
        if ( !v76 )
          goto LABEL_20;
        v78 = *v76;
        if ( *v76 == 32 )
        {
          v151 = (__int64)(v76 + 12);
          *(_BYTE *)(v5 + 4049) = 1;
          *(_QWORD *)(v5 + 536) = sub_33840((__int64)(v76 + 12));
          *(_QWORD *)(v5 + 4040) = sub_2F1D0(v151);
          *(_QWORD *)(v5 + 4032) = v152;
          if ( sub_2F0C0(v151) )
          {
            *(_QWORD *)(v5 + 4000) = sub_2F1D0(v151);
            *(_QWORD *)(v5 + 3992) = v110;
          }
          else
          {
            v110 = *(_QWORD *)(v5 + 3992);
          }
        }
        else
        {
          if ( v78 > 32 )
          {
            if ( v78 == 33 )
            {
              v148 = sub_2F1D0((__int64)(v76 + 12));
              v149 = *(__int64 (__fastcall ***)(_QWORD, char *))(v5 + 208);
              *(_QWORD *)(v5 + 688) = v148;
              *(_QWORD *)(v5 + 696) = v150;
              if ( v149 )
              {
                *(_QWORD *)(v5 + 736) = (*v149)(v149, v148);
                sub_2EF30(
                  *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL),
                  *(char **)(v5 + 688),
                  *(_QWORD *)(v5 + 696));
              }
            }
            else
            {
              if ( v78 != 34 )
                goto LABEL_133;
              v79 = (__int64)(v76 + 12);
              sub_2F150((__int64)(v76 + 12));
              sub_2F150(v79);
              a3 = (__int64)sub_2F1D0(v79);
              v81 = sub_BC2F0(v80);
              v82 = sub_BC360((__int64)"GSSAPI key exchange failed; server's message: %.*s", v81, a3);
              sub_2D3A0(*(_QWORD *)(v5 + 4200), v82, a3, (__int64)a4);
              sub_2F1D0(v79);
            }
            goto LABEL_71;
          }
          if ( v78 != 31 )
          {
LABEL_133:
            sub_621E0(
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
              v78);
            v147 = (unsigned int)*v77;
            sub_423C0(
              *(_QWORD *)(v5 + 4216),
              (__int64)"Received unexpected packet during GSSAPI key exchange, type %d (%s)",
              a3,
              (__int64)a4);
            *v4 = 1;
            goto LABEL_20;
          }
          *(_QWORD *)(v5 + 4000) = sub_2F1D0((__int64)(v76 + 12));
          *(_QWORD *)(v5 + 3992) = v110;
        }
        if ( !v110 && *(_DWORD *)(v5 + 4024) != 1 && *(_BYTE *)(v5 + 4049) )
          goto LABEL_97;
        v101 = *(_QWORD *)(v5 + 456);
        v102 = *(_QWORD *)(v101 + 16);
LABEL_88:
        v103 = 0LL;
        if ( *(_QWORD *)(v5 + 472) == -1LL )
          v103 = v5 + 472;
        v104 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, __int64, __int64, signed __int64, _QWORD))(*(_QWORD *)(v101 + 8) + 40LL))(
                 *(_QWORD *)(v101 + 8),
                 v101 + 24,
                 v102,
                 *(unsigned __int8 *)(v5 + 4050),
                 v5 + 3992,
                 v5 + 4008,
                 v103,
                 0LL);
        *(_DWORD *)(v5 + 4024) = v104;
        *(_QWORD *)(v5 + 3992) = 0LL;
        *(_QWORD *)(v5 + 4000) = 0LL;
        if ( v104 )
        {
          if ( v104 > 1 )
          {
            if ( !(*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL)
                                                                          + 96LL))(
                    *(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL),
                    *(_QWORD *)(*(_QWORD *)(v5 + 456) + 24LL),
                    v5 + 3976) )
            {
              v192 = *(void **)(v5 + 3984);
              sub_42500(
                *(_QWORD *)(v5 + 4216),
                (__int64)"GSSAPI key exchange failed to initialise context: %s",
                a3,
                (__int64)a4);
              sub_2F4D0(v192);
              *v4 = 1;
              goto LABEL_20;
            }
            if ( *(_DWORD *)(v5 + 4024) > 1u )
              __assert_fail(
                "s->gss_stat == SSH_GSS_S_COMPLETE || s->gss_stat == SSH_GSS_S_CONTINUE_NEEDED",
                "ssh2kex-client.c",
                0x177u,
                "ssh2kex_coroutine");
          }
        }
        else if ( *(_BYTE *)(v5 + 4049) )
        {
          goto LABEL_97;
        }
        if ( *(_BYTE *)(v5 + 4048) )
        {
          if ( *(_QWORD *)(v5 + 4008) )
          {
            a3 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v5 + 4136) + 24LL))(31LL);
            sub_2EE80(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(a3 + 96),
              *(char **)(v5 + 4016),
              *(_QWORD *)(v5 + 4008));
            sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(a3 + 64));
            (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL) + 48LL))(
              *(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL),
              v5 + 4008);
          }
        }
        else
        {
          v105 = *(_QWORD *)(v5 + 4136);
          *(_BYTE *)(v5 + 4048) = 1;
          v106 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)v105 + 24LL))(30LL);
          v107 = *(_QWORD *)(v5 + 4008);
          a3 = v106;
          if ( !v107 )
          {
            sub_42500(
              *(_QWORD *)(v5 + 4216),
              (__int64)"GSSAPI key exchange failed: no initial context token",
              v106,
              (__int64)a4);
            *v4 = 1;
            goto LABEL_20;
          }
          v108 = v106 + 96;
          sub_2EE80((void (__fastcall **)(_QWORD, char *, signed __int64))(v106 + 96), *(char **)(v5 + 4016), v107);
          sub_33730(v108, *(__int64 **)(v5 + 528));
          sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(a3 + 64));
          (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL) + 48LL))(
            *(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL),
            v5 + 4008);
          v109 = sub_BC360((__int64)"GSSAPI key exchange initialised");
          sub_2D3A0(*(_QWORD *)(v5 + 4200), v109, a3, (__int64)a4);
        }
        if ( !*(_DWORD *)(v5 + 4024) && *(_BYTE *)(v5 + 4049) )
        {
LABEL_97:
          if ( sub_72610(*(_QWORD *)(v5 + 360), *(signed __int64 **)(v5 + 536)) )
          {
            sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"GSSAPI reply failed validation: %s", a3, (__int64)a4);
            *v4 = 1;
            goto LABEL_20;
          }
          v190 = sub_72690(*(_QWORD *)(v5 + 360), *(unsigned __int64 **)(v5 + 536));
          v191 = *(_QWORD *)(v5 + 4208);
          *(_QWORD *)(v5 + 544) = v190;
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v191 + 56LL))(v191, 0LL);
          if ( !*(_QWORD *)(v5 + 736) )
            sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL), &locale);
          if ( (unsigned __int8)sub_723F0(*(_QWORD *)(v5 + 200)) )
          {
            sub_2ED90(
              *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL),
              *(_DWORD *)(v5 + 504));
            sub_2ED90(
              *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL),
              *(_DWORD *)(v5 + 504));
            sub_2ED90(
              *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL),
              2 * *(_DWORD *)(v5 + 504));
            goto LABEL_112;
          }
          goto LABEL_113;
        }
LABEL_71:
        *(_DWORD *)(v5 + 4) = 407;
      }
    }
LABEL_41:
    v53 = (int *)sub_50890(v5, (__int64)a4);
    v54 = v53;
    if ( !v53 )
      goto LABEL_20;
    if ( *v53 != 30 )
    {
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
        *v53);
      v55 = (unsigned int)*v54;
      sub_423C0(
        *(_QWORD *)(v5 + 4216),
        (__int64)"Received unexpected packet when expecting RSA public key, type %d (%s)",
        a3,
        (__int64)a4);
      *a2 = 1;
      goto LABEL_20;
    }
    v32 = (__int64)(v53 + 12);
    v33 = sub_2F1D0((__int64)(v53 + 12));
    *(_QWORD *)(v5 + 688) = v33;
    v34 = *(_QWORD *)(v5 + 368);
    *(_QWORD *)(v5 + 696) = v35;
    sub_2EF30(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v34 + 8), v33, v35);
    *(_QWORD *)(v5 + 736) = (**(__int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD))(v5 + 208))(
                              *(_QWORD *)(v5 + 208),
                              *(_QWORD *)(v5 + 688),
                              *(_QWORD *)(v5 + 696));
    v36 = sub_2F1D0(v32);
    a3 = (__int64)v36;
    v38 = v37;
    v39 = sub_7DAE0((__int64)v36, v37);
    *(_QWORD *)(v5 + 752) = v39;
    if ( !v39 )
    {
      sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Unable to parse RSA public key packet", a3, (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    v40 = *(_QWORD *)(v5 + 368);
    *(_BYTE *)(v5 + 760) = 1;
    sub_2EF30(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v40 + 8), (char *)a3, v38);
    v41 = sub_7DB30(*(_QWORD *)(v5 + 752));
    v42 = *(__int64 **)(v5 + 200);
    if ( *(_DWORD *)v42[4] > v41 )
    {
      v177 = *v42;
      sub_423C0(
        *(_QWORD *)(v5 + 4216),
        (__int64)"Server sent %d-bit RSA key, less than the minimum size %d for %s key exchange",
        a3,
        (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    v43 = v41 - 16 * *(unsigned __int64 *)(v42[3] + 40) - 49;
    if ( v43 <= 0 )
      __assert_fail("nbits > 0", "ssh2kex-client.c", 0x246u, "ssh2kex_coroutine");
    v44 = v43 - 1;
    v45 = sub_36E00(v44, (void (__fastcall *)(_BYTE *, unsigned __int64))sub_7BF50);
    v46 = (__int64 *)sub_36970(v44);
    *(_QWORD *)(v5 + 544) = v46;
    sub_338A0(v46, v46, v45);
    sub_330F0(v45);
    v47 = sub_BC650();
    sub_33730(v47 + 24, *(__int64 **)(v5 + 544));
    v48 = sub_7DB50(
            *(_QWORD *)(v5 + 752),
            *(_QWORD *)(*(_QWORD *)(v5 + 200) + 24LL),
            *(void **)(v47 + 8),
            *(_QWORD *)(v47 + 16));
    a3 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v5 + 4136) + 24LL))(31LL);
    sub_2EF30(
      (void (__fastcall **)(_QWORD, char *, signed __int64))(a3 + 96),
      *(char **)(v48 + 8),
      *(_QWORD *)(v48 + 16));
    sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(a3 + 64));
    sub_2EF70(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL), v48);
    sub_BC660((void **)v47);
    sub_7DB10(*(_QWORD **)(v5 + 752));
    *(_QWORD *)(v5 + 752) = 0LL;
    *(_BYTE *)(v5 + 760) = 0;
    *(_DWORD *)(v5 + 4) = 619;
    goto LABEL_34;
  }
  if ( v6 == 77 )
  {
LABEL_61:
    v72 = (int *)sub_50890(v5, (__int64)a4);
    v73 = v72;
    if ( !v72 )
      goto LABEL_20;
    v74 = *v72;
    if ( *v72 != 31 )
      goto LABEL_63;
    a3 = (__int64)(v72 + 12);
    *(_QWORD *)(v5 + 512) = sub_33840((__int64)(v72 + 12));
    v16 = sub_33840(a3);
    v17 = v73[18];
    *(_QWORD *)(v5 + 520) = v16;
    if ( !v17 )
    {
      v18 = sub_72480(*(_QWORD *)(v5 + 512), (__int64)v16);
      v19 = *(_QWORD *)(v5 + 368);
      *(_QWORD *)(v5 + 584) = 141733920800LL;
      *(_QWORD *)(v5 + 360) = v18;
      v20 = *(_QWORD *)(*(_QWORD *)v19 + 72LL);
      v21 = sub_724E0((__int64)v18);
      v22 = sub_BC360(
              (__int64)"Doing Diffie-Hellman key exchange using %d-bit modulus and hash %s with a server-supplied group",
              v21,
              v20);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v22, a3, (__int64)a4);
LABEL_24:
      (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v5 + 4208) + 56LL))(*(_QWORD *)(v5 + 4208), 2LL);
      *(_QWORD *)(v5 + 528) = sub_72560(*(_QWORD *)(v5 + 360), 2 * *(_DWORD *)(v5 + 500));
      v23 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v5 + 4136) + 24LL))(*(unsigned int *)(v5 + 584));
      sub_33730(v23 + 96, *(__int64 **)(v5 + 528));
      sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(v23 + 64));
      (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v5 + 4208) + 56LL))(*(_QWORD *)(v5 + 4208), 1LL);
      *(_DWORD *)(v5 + 4) = 127;
      goto LABEL_25;
    }
LABEL_128:
    sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Unable to parse Diffie-Hellman group packet", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  if ( v6 > 77 )
  {
    if ( v6 != 127 )
    {
      if ( v6 != 208 )
        goto LABEL_12;
      goto LABEL_17;
    }
LABEL_25:
    v24 = (int *)sub_50890(v5, (__int64)a4);
    v25 = v24;
    if ( !v24 )
      goto LABEL_20;
    if ( *v24 != *(_DWORD *)(v5 + 588) )
    {
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
        *v24);
      v160 = (unsigned int)*v25;
      sub_423C0(
        *(_QWORD *)(v5 + 4216),
        (__int64)"Received unexpected packet when expecting Diffie-Hellman reply, type %d (%s)",
        a3,
        (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    a3 = (__int64)(v24 + 12);
    (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v5 + 4208) + 56LL))(*(_QWORD *)(v5 + 4208), 2LL);
    v26 = sub_2F1D0((__int64)(v25 + 12));
    v27 = *(__int64 (__fastcall ***)(_QWORD, char *))(v5 + 208);
    *(_QWORD *)(v5 + 696) = v28;
    *(_QWORD *)(v5 + 688) = v26;
    *(_QWORD *)(v5 + 736) = (*v27)(v27, v26);
    *(_QWORD *)(v5 + 536) = sub_33840((__int64)(v25 + 12));
    v29 = sub_2F1D0((__int64)(v25 + 12));
    v30 = v25[18];
    *(_QWORD *)(v5 + 704) = v29;
    *(_QWORD *)(v5 + 712) = v31;
    if ( v30 )
    {
      sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Unable to parse Diffie-Hellman reply packet", a3, (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    if ( sub_72610(*(_QWORD *)(v5 + 360), *(signed __int64 **)(v5 + 536)) )
    {
      sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Diffie-Hellman reply failed validation: %s", a3, (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    v111 = sub_72690(*(_QWORD *)(v5 + 360), *(unsigned __int64 **)(v5 + 536));
    v112 = *(_QWORD *)(v5 + 4208);
    *(_QWORD *)(v5 + 544) = v111;
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v112 + 56LL))(v112, 0LL);
    sub_2EF30(
      *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL),
      *(char **)(v5 + 688),
      *(_QWORD *)(v5 + 696));
    if ( (unsigned __int8)sub_723F0(*(_QWORD *)(v5 + 200)) )
    {
      v113 = *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL);
      if ( !(*(_BYTE *)(v5 + 4225) & 0x10) )
      {
        sub_2ED90(v113, 1024);
        v113 = *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL);
      }
      sub_2ED90(v113, *(_DWORD *)(v5 + 504));
      if ( !(*(_BYTE *)(v5 + 4225) & 0x10) )
        sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v5 + 368) + 8LL), 0x2000);
LABEL_112:
      sub_33730(*(_QWORD *)(*(_QWORD *)(v5 + 368) + 8LL), *(__int64 **)(v5 + 512));
      sub_33730(*(_QWORD *)(*(_QWORD *)(v5 + 368) + 8LL), *(__int64 **)(v5 + 520));
    }
LABEL_113:
    sub_33730(*(_QWORD *)(*(_QWORD *)(v5 + 368) + 8LL), *(__int64 **)(v5 + 528));
    sub_33730(*(_QWORD *)(*(_QWORD *)(v5 + 368) + 8LL), *(__int64 **)(v5 + 536));
    sub_72500(*(_QWORD ***)(v5 + 360));
    v114 = *(_QWORD **)(v5 + 536);
    *(_QWORD *)(v5 + 360) = 0LL;
    sub_330F0(v114);
    v115 = *(_QWORD *)(v5 + 200);
    *(_QWORD *)(v5 + 536) = 0LL;
    if ( (unsigned __int8)sub_723F0(v115) )
    {
      sub_330F0(*(_QWORD **)(v5 + 520));
      v179 = *(_QWORD **)(v5 + 512);
      *(_QWORD *)(v5 + 520) = 0LL;
      sub_330F0(v179);
      *(_QWORD *)(v5 + 512) = 0LL;
    }
    goto LABEL_115;
  }
  if ( v6 )
    goto LABEL_12;
  v56 = *(_QWORD *)(a1 + 200);
  v57 = *(_DWORD *)(v56 + 16);
  if ( !v57 )
  {
    v58 = *(_QWORD *)(v5 + 632);
    v59 = *(_QWORD *)(v5 + 592);
    if ( v58 )
    {
      v60 = *(signed int *)(v58 + 76);
      v61 = 0LL;
      if ( !v59 )
      {
LABEL_49:
        if ( (signed int)v61 < (signed int)v60 )
          v61 = v60;
        v62 = *(_QWORD *)(v56 + 24);
        *(_DWORD *)(v5 + 500) = v61;
        v63 = *(_QWORD *)(v62 + 40);
        if ( v61 > 8 * v63 )
          *(_DWORD *)(v5 + 500) = 8 * v63;
        goto LABEL_53;
      }
    }
    else
    {
      v60 = 0LL;
      if ( !v59 )
      {
        *(_DWORD *)(v5 + 500) = 0;
LABEL_53:
        if ( !(unsigned __int8)sub_723F0(v56) )
        {
          v141 = *(_QWORD *)(v5 + 200);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL) = 1;
          v142 = sub_72400(v141);
          v143 = *(_QWORD *)(v5 + 200);
          *(_QWORD *)(v5 + 360) = v142;
          *(_QWORD *)(v5 + 584) = 133143986206LL;
          a3 = *(_QWORD *)(v143 + 8);
          v144 = *(_QWORD *)(**(_QWORD **)(v5 + 368) + 72LL);
          v145 = sub_724E0(v142);
          v146 = sub_BC360(
                   (__int64)"Doing Diffie-Hellman key exchange using %d-bit modulus and hash %s with standard group \"%s\"",
                   v145,
                   v144,
                   a3);
          sub_2D3A0(*(_QWORD *)(v5 + 4200), v146, a3, (__int64)a4);
          goto LABEL_24;
        }
        v64 = sub_BC360((__int64)"Doing Diffie-Hellman group exchange");
        sub_2D3A0(*(_QWORD *)(v5 + 4200), v64, a3, (__int64)a4);
        v65 = *(_QWORD **)(v5 + 4136);
        *(_DWORD *)(v65[18] + 4LL) = 2;
        v66 = *(_DWORD *)(v5 + 500);
        v67 = v66 + 62;
        v68 = v66 - 1;
        if ( v68 >= 0 )
          v67 = v68;
        v69 = 512 << (v67 >> 6);
        if ( v69 > 1023 )
        {
          if ( v69 <= 0x2000 )
            *(_DWORD *)(v5 + 504) = v69;
          else
            *(_DWORD *)(v5 + 504) = 0x2000;
        }
        else
        {
          *(_DWORD *)(v5 + 504) = 1024;
        }
        v70 = *(__int64 (__fastcall **)(signed __int64, char *))(*v65 + 24LL);
        if ( *(_BYTE *)(v5 + 4225) & 0x10 )
        {
          v71 = v70(30LL, v64);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v71 + 96), *(_DWORD *)(v5 + 504));
        }
        else
        {
          v159 = v70(34LL, v64);
          a3 = v159 + 96;
          v71 = v159;
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v159 + 96), 1024);
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, *(_DWORD *)(v5 + 504));
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, 0x2000);
        }
        sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(v71 + 64));
        *(_DWORD *)(v5 + 4) = 77;
        goto LABEL_61;
      }
    }
    v61 = *(signed int *)(v59 + 76);
    goto LABEL_49;
  }
  if ( v57 != 2 )
  {
    if ( v57 != 3 )
    {
      if ( v57 != 1 )
        __assert_fail("s->kex_alg->main_type == KEXTYPE_RSA", "ssh2kex-client.c", 0x20Cu, "ssh2kex_coroutine");
      v52 = sub_BC360((__int64)"Doing RSA key exchange with hash %s", *(_QWORD *)(**(_QWORD **)(v5 + 368) + 72LL));
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v52, a3, (__int64)a4);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL) = 5;
      *(_DWORD *)(v5 + 4) = 532;
      goto LABEL_41;
    }
    v83 = *(_QWORD *)(v5 + 632);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL) = 4;
    v84 = *(_QWORD *)(v5 + 592);
    *(_BYTE *)(v5 + 4048) = 0;
    *(_BYTE *)(v5 + 4049) = 0;
    *(_QWORD *)(v5 + 736) = 0LL;
    *(_QWORD *)(v5 + 728) = 0LL;
    v85 = *(_DWORD *)(v84 + 76);
    if ( *(_DWORD *)(v83 + 76) >= v85 )
      v85 = *(_DWORD *)(v83 + 76);
    v86 = *(_QWORD *)(*(_QWORD *)(v56 + 24) + 40LL);
    *(_DWORD *)(v5 + 500) = v85;
    if ( v85 > (unsigned __int64)(8 * v86) )
      *(_DWORD *)(v5 + 500) = 8 * v86;
    if ( !(unsigned __int8)sub_723F0(v56) )
    {
      *(_QWORD *)(v5 + 360) = sub_72400(*(_QWORD *)(v5 + 200));
      v178 = sub_BC360(
               (__int64)"Using GSSAPI (with Kerberos V5) Diffie-Hellman with standard group \"%s\"",
               *(_QWORD *)(*(_QWORD *)(v5 + 200) + 8LL));
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v178, a3, (__int64)a4);
      goto LABEL_84;
    }
    v87 = *(_DWORD *)(v5 + 500);
    v88 = v87 + 62;
    v89 = v87 - 1;
    if ( v89 >= 0 )
      v88 = v89;
    *(_DWORD *)(v5 + 504) = 512 << (v88 >> 6);
    v90 = sub_BC360((__int64)"Doing GSSAPI (with Kerberos V5) Diffie-Hellman group exchange, with minimum %d bits");
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v90, a3, (__int64)a4);
    v91 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v5 + 4136) + 24LL))(40LL, v90);
    a3 = v91 + 96;
    v92 = v91;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v91 + 96), *(_DWORD *)(v5 + 504));
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, *(_DWORD *)(v5 + 504));
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a3, 2 * *(_DWORD *)(v5 + 504));
    sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(v92 + 64));
    *(_DWORD *)(v5 + 4) = 295;
LABEL_80:
    v93 = (int *)sub_50890(v5, (__int64)a4);
    v73 = v93;
    if ( !v93 )
      goto LABEL_20;
    v74 = *v93;
    if ( *v93 != 41 )
    {
LABEL_63:
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
        v74);
      v75 = (unsigned int)*v73;
      sub_423C0(
        *(_QWORD *)(v5 + 4216),
        (__int64)"Received unexpected packet when expecting Diffie-Hellman group, type %d (%s)",
        a3,
        (__int64)a4);
      *v4 = 1;
      goto LABEL_20;
    }
    a3 = (__int64)(v93 + 12);
    *(_QWORD *)(v5 + 512) = sub_33840((__int64)(v93 + 12));
    v94 = sub_33840(a3);
    v95 = v73[18];
    *(_QWORD *)(v5 + 520) = v94;
    if ( v95 )
      goto LABEL_128;
    *(_QWORD *)(v5 + 360) = sub_72480(*(_QWORD *)(v5 + 512), (__int64)v94);
LABEL_84:
    v96 = sub_BC360(
            (__int64)"Doing GSSAPI (with Kerberos V5) Diffie-Hellman key exchange with hash %s",
            *(_QWORD *)(**(_QWORD **)(v5 + 368) + 72LL));
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v96, a3, (__int64)a4);
    (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v5 + 4208) + 56LL))(*(_QWORD *)(v5 + 4208), 2LL);
    *(_QWORD *)(v5 + 528) = sub_72560(*(_QWORD *)(v5 + 360), 2 * *(_DWORD *)(v5 + 500));
    v97 = *(_QWORD *)(v5 + 456);
    v98 = *(_QWORD *)(v97 + 8);
    if ( *(_QWORD *)(v98 + 8) )
    {
      v99 = sub_BC360((__int64)"%s");
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v99, a3, (__int64)a4);
      v97 = *(_QWORD *)(v5 + 456);
      v98 = *(_QWORD *)(v97 + 8);
    }
    *(_QWORD *)(v5 + 3992) = 0LL;
    *(_QWORD *)(v5 + 4000) = 0LL;
    *(_QWORD *)(v5 + 4008) = 0LL;
    *(_QWORD *)(v5 + 4016) = 0LL;
    *(_QWORD *)(v5 + 4032) = 0LL;
    *(_QWORD *)(v5 + 4040) = 0LL;
    v100 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v98 + 56))(v98, v97 + 24, v5 + 472);
    *(_DWORD *)(v5 + 4024) = v100;
    if ( !v100 )
    {
      v101 = *(_QWORD *)(v5 + 456);
      v102 = *(_QWORD *)(v101 + 16);
      if ( !v102 )
        __assert_fail("s->shgss->srv_name", "ssh2kex-client.c", 0x158u, "ssh2kex_coroutine");
      goto LABEL_88;
    }
    sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"GSSAPI key exchange failed to initialise", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  v121 = *(_QWORD *)(**(_QWORD **)(v5 + 368) + 72LL);
  v122 = sub_75EF0(v56);
  v123 = sub_BC360((__int64)"Doing ECDH key exchange with curve %s and hash %s", v122, v121);
  sub_2D3A0(*(_QWORD *)(v5 + 4200), v123, a3, (__int64)a4);
  v124 = *(_QWORD *)(v5 + 200);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL) = 3;
  v125 = sub_75F10(v124);
  *(_QWORD *)(v5 + 768) = v125;
  if ( !v125 )
    goto LABEL_218;
  v126 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v5 + 4136) + 24LL))(30LL, v123);
  a3 = sub_BC640();
  sub_75F50(*(_QWORD *)(v5 + 768));
  sub_2EF70((void (__fastcall **)(_QWORD, char *, signed __int64))(v126 + 96), a3);
  sub_614E0(*(_QWORD *)(v5 + 4152), (__int64 *)(v126 + 64));
  *(_DWORD *)(v5 + 4) = 208;
LABEL_17:
  v11 = (int *)sub_50890(v5, (__int64)a4);
  v12 = v11;
  if ( !v11 )
    goto LABEL_20;
  if ( *v11 != 31 )
  {
    sub_621E0(
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 4LL),
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 4136) + 144LL) + 8LL),
      *v11);
    v13 = (unsigned int)*v12;
    sub_423C0(
      *(_QWORD *)(v5 + 4216),
      (__int64)"Received unexpected packet when expecting ECDH reply, type %d (%s)",
      a3,
      (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  v127 = (__int64)(v11 + 12);
  v128 = sub_2F1D0((__int64)(v11 + 12));
  v129 = v128;
  *(_QWORD *)(v5 + 688) = v128;
  v130 = *(_QWORD *)(v5 + 368);
  *(_QWORD *)(v5 + 696) = v131;
  sub_2EF30(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v130 + 8), v129, v131);
  *(_QWORD *)(v5 + 736) = (**(__int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD))(v5 + 208))(
                            *(_QWORD *)(v5 + 208),
                            *(_QWORD *)(v5 + 688),
                            *(_QWORD *)(v5 + 696));
  v132 = sub_BC640();
  sub_75F50(*(_QWORD *)(v5 + 768));
  sub_2EE80(
    *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL),
    *(char **)(v132 + 8),
    *(_QWORD *)(v132 + 16));
  sub_BC660((void **)v132);
  a4 = sub_2F1D0(v127);
  a3 = v133;
  sub_2EF30(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 + 368) + 8LL), a4, v133);
  v134 = sub_75F60(*(_QWORD *)(v5 + 768));
  v135 = v12[18];
  *(_QWORD *)(v5 + 544) = v134;
  if ( !v135 && !v134 )
  {
    sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Received invalid elliptic curve point in ECDH reply", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  v136 = sub_2F1D0(v127);
  v137 = v12[18];
  *(_QWORD *)(v5 + 704) = v136;
  *(_QWORD *)(v5 + 712) = v138;
  if ( v137 )
  {
    sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Unable to parse ECDH reply packet", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  sub_75F70(*(_QWORD ***)(v5 + 768));
  *(_QWORD *)(v5 + 768) = 0LL;
LABEL_115:
  sub_52AF0(v5);
  v116 = *(_QWORD *)(v5 + 200);
  if ( *(_DWORD *)(v116 + 16) == 3 )
  {
    v117 = *(_QWORD *)(v116 + 24);
    v118 = *(_QWORD *)(v5 + 456);
    *(_QWORD *)(v5 + 3976) = 0LL;
    *(_QWORD *)(v5 + 3984) = 0LL;
    v199 = v5 + 776;
    v198 = *(_QWORD *)(v117 + 40);
    v119 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *, __int64))(*(_QWORD *)(v118 + 8) + 80LL))(
             *(_QWORD *)(v118 + 8),
             *(_QWORD *)(v118 + 24),
             &v198,
             v5 + 4032);
    *(_DWORD *)(v5 + 4024) = v119;
    if ( v119 )
    {
      if ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL) + 96LL))(
             *(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL),
             *(_QWORD *)(*(_QWORD *)(v5 + 456) + 24LL),
             v5 + 3976) )
      {
        sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"GSSAPI key exchange MIC was not valid", a3, (__int64)a4);
      }
      else
      {
        v120 = *(void **)(v5 + 3984);
        sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"GSSAPI key exchange MIC was not valid: %s", a3, (__int64)a4);
        sub_2F4D0(v120);
      }
LABEL_106:
      *v4 = 1;
      goto LABEL_20;
    }
    v154 = *(_BYTE *)(v5 + 893) == 0;
    *(_BYTE *)(v5 + 496) = 1;
    if ( !v154 )
      (*(void (__fastcall **)(_QWORD, signed __int64))(*(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL) + 64LL))(
        *(_QWORD *)(*(_QWORD *)(v5 + 456) + 8LL),
        *(_QWORD *)(v5 + 456) + 24LL);
    v180 = sub_BC360((__int64)"GSSAPI Key Exchange complete!");
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v180, a3, (__int64)a4);
    v116 = *(_QWORD *)(v5 + 200);
    v153 = *(_QWORD *)(v5 + 736);
    v181 = *(_DWORD *)(v116 + 16);
    *(_QWORD *)(v5 + 360) = 0LL;
    if ( v181 == 3 )
      goto LABEL_142;
  }
  else
  {
    v153 = *(_QWORD *)(v5 + 736);
    *(_QWORD *)(v5 + 360) = 0LL;
  }
  if ( !v153 )
  {
    sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Server's host key is invalid", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD, __int64, _QWORD))(*(_QWORD *)v153 + 48LL))(
          v153,
          *(_QWORD *)(v5 + 704),
          *(_QWORD *)(v5 + 712),
          v5 + 776,
          *(_QWORD *)(*(_QWORD *)(v116 + 24) + 40LL)) )
  {
    sub_423C0(*(_QWORD *)(v5 + 4216), (__int64)"Signature from server's host key is invalid", a3, (__int64)a4);
    *v4 = 1;
    goto LABEL_20;
  }
  v153 = *(_QWORD *)(v5 + 736);
LABEL_142:
  if ( v153 )
    v9 = (char *)(*(__int64 (**)(void))(*(_QWORD *)v153 + 80LL))();
  else
    v9 = 0LL;
  v154 = *(_BYTE *)(v5 + 496) == 0;
  *(_QWORD *)(v5 + 728) = v9;
  if ( v154 )
  {
    if ( *(_BYTE *)(v5 + 893) )
    {
      v182 = *(_QWORD *)(v5 + 4104);
      if ( !v182 )
      {
        if ( !v9 )
          __assert_fail("s->keystr", "ssh2kex-client.c", 0x38Fu, "ssh2kex_coroutine");
        if ( !strcmp(*(const char **)(v5 + 216), v9) )
          goto LABEL_10;
        sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"Host key was different in repeat key exchange", a3, (__int64)a4);
        *v4 = 1;
        goto LABEL_20;
      }
      v183 = *(_QWORD **)(v5 + 736);
      if ( !v183 )
        __assert_fail("s->hkey", "ssh2kex-client.c", 0x378u, "ssh2kex_coroutine");
      if ( v182 != *v183 )
        __assert_fail("ssh_key_alg(s->hkey) == s->cross_certifying", "ssh2kex-client.c", 0x379u, "ssh2kex_coroutine");
      v4 = (_BYTE *)sub_7BA10((__int64)v183, 1LL);
      v184 = sub_BC360((__int64)"Storing additional host key for this host:", 1LL);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v184, a3, (__int64)a4);
      v185 = sub_BC360((__int64)"%s", v4);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v185, a3, (__int64)a4);
      sub_2F4D0(v4);
      v186 = *(_QWORD *)(v5 + 728);
      v187 = *(unsigned int *)(v5 + 168);
      v188 = *(_QWORD *)(v5 + 160);
      v189 = *(_QWORD *)(**(_QWORD **)(v5 + 736) + 112LL);
      sub_BAFD0();
    }
    else
    {
      a4 = 0LL;
      v161 = 0LL;
      v162 = 0LL;
      do
      {
        v163 = (char *)off_324260[2 * (_QWORD)a4];
        if ( v163 != *(char **)(v5 + 208) )
        {
          v164 = *(_DWORD *)(v5 + 4100);
          if ( v164 > 0 )
          {
            if ( (_DWORD)a4 == *(_DWORD *)(v5 + 4064) )
            {
LABEL_178:
              v174 = *((_QWORD *)v163 + 13);
              if ( v161 )
              {
                v163 = v161;
                v175 = sub_BC360((__int64)"%s/%s", v161, v174);
              }
              else
              {
                v163 = (char *)*((_QWORD *)v163 + 13);
                v175 = sub_BC360((__int64)"%s", v163);
              }
              v176 = v175;
              v162 = (unsigned int)(v162 + 1);
              sub_2F4D0(v161);
              v161 = v176;
            }
            else
            {
              v165 = v5 + 4068;
              v166 = v5 + 4068 + 4LL * (unsigned int)(v164 - 1);
              while ( v166 != v165 )
              {
                v165 += 4LL;
                if ( *(_DWORD *)(v165 - 4) == (_DWORD)a4 )
                  goto LABEL_178;
              }
            }
          }
        }
        ++a4;
      }
      while ( a4 != byte_9 );
      if ( v161 )
      {
        v167 = "it";
        v168 = &locale;
        if ( (signed int)v162 >= 2 )
          v167 = "any of them";
        if ( (signed int)v162 >= 2 )
          v168 = "s";
        v163 = sub_BC360((__int64)"Server also has %s host key%s, but we don't know %s", v161, v168, v167);
        sub_2D3A0(*(_QWORD *)(v5 + 4200), v163, v162, 9LL);
        sub_2F4D0(v161);
      }
      v169 = (void **)sub_7BA60(*(_QWORD *)(v5 + 736), (__int64)v163);
      a3 = (unsigned int)sub_BD840((__int64)v169);
      v170 = sub_BC360((__int64)"Host key fingerprint is:");
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v170, a3, 9LL);
      v171 = sub_BC360((__int64)"%s", v169[a3]);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v171, a3, 9LL);
      v172 = sub_628E0(*(__int64 **)(v5 + 152), (__int64)v169, *(_QWORD *)(v5 + 736));
      *(_DWORD *)(v5 + 896) = v172;
      if ( !v172 )
      {
        sub_7BAB0(v169);
        sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"Host key did not appear in manually configured list", a3, 9LL);
        *v4 = 1;
        goto LABEL_20;
      }
      if ( v172 < 0 )
      {
        v173 = *(_QWORD *)(v5 + 736);
        v199 = 0LL;
        v198 = v173;
        a3 = sub_7B520((char **)&v198, (__int64)v169);
        *(_DWORD *)(v5 + 896) = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64, void **, __int64 (__fastcall *)(__int64, int), __int64))(**(_QWORD **)(v5 + 4208) + 64LL))(
                                  *(_QWORD *)(v5 + 4208),
                                  *(_QWORD *)(v5 + 160),
                                  *(unsigned int *)(v5 + 168),
                                  *(_QWORD *)(**(_QWORD **)(v5 + 736) + 112LL),
                                  *(_QWORD *)(v5 + 728),
                                  a3,
                                  v169,
                                  sub_4F470,
                                  v5);
        sub_2F4D0((void *)a3);
        sub_7BAB0(v169);
        *(_DWORD *)(v5 + 4) = 872;
        goto LABEL_7;
      }
    }
LABEL_9:
    v8 = *(_QWORD *)(v5 + 728);
    v9 = 0LL;
    *(_QWORD *)(v5 + 728) = 0LL;
    *(_QWORD *)(v5 + 216) = v8;
    goto LABEL_10;
  }
  v155 = *(_QWORD *)(v5 + 736);
  if ( *(_DWORD *)(*(_QWORD *)(v5 + 200) + 16LL) == 3 )
  {
    if ( v155 )
    {
      v4 = (_BYTE *)sub_7BA10(v155, 1LL);
      v193 = sub_BC360((__int64)"GSS kex provided fallback host key:", 1LL);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v193, a3, (__int64)a4);
      v194 = sub_BC360((__int64)"%s", v4);
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v194, a3, (__int64)a4);
      sub_2F4D0(v4);
      sub_4F2A0(*(_QWORD **)(v5 + 488), *(_QWORD **)(v5 + 736));
      v9 = *(char **)(v5 + 728);
      goto LABEL_10;
    }
    if ( sub_4F3F0(*(_QWORD **)(v5 + 488)) )
      goto LABEL_231;
    if ( *(_QWORD *)(v5 + 208) )
    {
      *(_BYTE *)(v5 + 891) = 1;
      v9 = *(char **)(v5 + 728);
      goto LABEL_10;
    }
    if ( *(_BYTE *)(v5 + 892) )
    {
LABEL_231:
      v9 = *(char **)(v5 + 728);
    }
    else
    {
      v197 = sub_BC360((__int64)"No fallback host key available");
      sub_2D3A0(*(_QWORD *)(v5 + 4200), v197, a3, (__int64)a4);
      *(_BYTE *)(v5 + 892) = 1;
      v9 = *(char **)(v5 + 728);
    }
LABEL_10:
    sub_2F4D0(v9);
    v10 = *(_QWORD *)(v5 + 736);
    *(_QWORD *)(v5 + 728) = 0LL;
    if ( v10 )
    {
      (*(void (**)(void))(*(_QWORD *)v10 + 24LL))();
      *(_QWORD *)(v5 + 736) = 0LL;
    }
    goto LABEL_12;
  }
  if ( !v155 )
    __assert_fail("s->hkey", "ssh2kex-client.c", 0x30Du, "ssh2kex_coroutine");
  v156 = (void *)sub_7BA10(v155, 1LL);
  if ( *(_BYTE *)(v5 + 891) )
  {
    v157 = sub_BC360((__int64)"Post-GSS rekey provided fallback host key:", 1LL);
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v157, a3, (__int64)a4);
    v158 = sub_BC360((__int64)"%s", v156);
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v158, a3, (__int64)a4);
    sub_4F2A0(*(_QWORD **)(v5 + 488), *(_QWORD **)(v5 + 736));
    *(_BYTE *)(v5 + 891) = 0;
LABEL_149:
    sub_2F4D0(v156);
    v9 = *(char **)(v5 + 728);
    goto LABEL_10;
  }
  if ( (unsigned __int8)sub_4F350(*(__int64 **)(v5 + 488), *(_QWORD **)(v5 + 736)) )
    goto LABEL_149;
  v195 = sub_BC360((__int64)"Non-GSS rekey after initial GSS kex used host key:");
  sub_2D3A0(*(_QWORD *)(v5 + 4200), v195, a3, (__int64)a4);
  v196 = sub_BC360((__int64)"%s", v156);
  sub_2D3A0(*(_QWORD *)(v5 + 4200), v196, a3, (__int64)a4);
  sub_2F4D0(v156);
  sub_42500(
    *(_QWORD *)(v5 + 4216),
    (__int64)"Server's host key did not match any used in previous GSS kex",
    a3,
    (__int64)a4);
LABEL_20:
  for ( *v4 = 1; ; *v4 = 1 )
  {
    v15 = __readfsqword(0x28u);
    result = v15 ^ v200;
    if ( v15 == v200 )
      break;
LABEL_218:
    sub_42500(*(_QWORD *)(v5 + 4216), (__int64)"Unable to generate key for ECDH", a3, (__int64)a4);
  }
  return result;
}

int __fastcall sub_4F1F0(__int64 a1, __int64 a2)
{
  return strcmp(*(const char **)(*(_QWORD *)a1 + 104LL), *(const char **)(*(_QWORD *)a2 + 104LL));
}

int __fastcall sub_4F210(__int64 a1, __int64 a2)
{
  return strcmp(*(const char **)(a1 + 104), *(const char **)(*(_QWORD *)a2 + 104LL));
}

_QWORD *sub_4F220()
{
  _QWORD *v0; // rbx

  v0 = sub_2F450(1uLL, 8uLL, 0LL);
  *v0 = sub_9AF60((__int64)sub_4F1F0);
  return v0;
}

void __fastcall sub_4F250(_QWORD *a1)
{
  __int64 v1; // rax
  void *v2; // rbx

  while ( 1 )
  {
    v1 = sub_9B400((__int64 *)*a1, 0);
    v2 = (void *)v1;
    if ( !v1 )
      break;
    sub_BC660(*(void ***)(v1 + 8));
    sub_2F4D0(v2);
  }
  sub_9AF90((_QWORD **)*a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_4F2A0(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax
  void ***v3; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rbx
  signed __int64 v6; // rax
  __int64 result; // rax

  v2 = sub_9B3D0((__int64 *)*a1, *a2, (__int64 (__fastcall *)(__int64))sub_4F210);
  if ( v2 )
  {
    v3 = (void ***)v2;
    sub_9B440((__int64 *)*a1, v2);
    sub_BC660(v3[1]);
    sub_2F4D0(v3);
  }
  v4 = sub_2F450(1uLL, 0x10uLL, 0LL);
  v5 = (__int64)v4;
  *v4 = *a2;
  v6 = sub_BC640();
  *(_QWORD *)(v5 + 8) = v6;
  (*(void (__fastcall **)(_QWORD *, signed __int64))(*a2 + 56LL))(a2, v6 + 24);
  result = sub_9AFD0((__int64 *)*a1, v5);
  if ( v5 != result )
    __assert_fail("retd == ent", "ssh2transhk.c", 0x59u, "ssh_transient_hostkey_cache_add");
  return result;
}

__int64 __fastcall sub_4F350(__int64 *a1, _QWORD *a2)
{
  unsigned int v2; // er13
  __int64 v3; // rax
  __int64 v4; // rbp
  signed __int64 v5; // r12
  __int64 v6; // rax
  size_t v7; // rdx

  v2 = 0;
  v3 = sub_9B3D0((__int64 *)*a1, *a2, (__int64 (__fastcall *)(__int64))sub_4F210);
  if ( v3 )
  {
    v4 = v3;
    v5 = sub_BC640();
    (*(void (__fastcall **)(_QWORD *, signed __int64))(*a2 + 56LL))(a2, v5 + 24);
    v6 = *(_QWORD *)(v4 + 8);
    v7 = *(_QWORD *)(v5 + 16);
    if ( v7 == *(_QWORD *)(v6 + 16) )
      LOBYTE(v2) = memcmp(*(const void **)v5, *(const void **)v6, v7) == 0;
    sub_BC660((void **)v5);
  }
  return v2;
}

bool __fastcall sub_4F3D0(_QWORD *a1, __int64 a2)
{
  return sub_9B3D0((__int64 *)*a1, a2, (__int64 (__fastcall *)(__int64))sub_4F210) != 0;
}

bool __fastcall sub_4F3F0(_QWORD *a1)
{
  return (signed int)sub_9AFB0((__int64 *)*a1) > 0;
}

__int64 sub_4F410()
{
  return 0LL;
}

void nullsub_23()
{
  ;
}

__int64 sub_4F430()
{
  return 0LL;
}

void nullsub_24()
{
  ;
}

__int64 sub_4F450()
{
  return 0LL;
}

__int64 __fastcall sub_4F460(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 8LL))();
}

__int64 __fastcall sub_4F470(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 896) = a2;
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 4128) + 8LL))(a1 + 4128);
}

__int64 __fastcall sub_4F490(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 4120) + 32LL))();
}

__int64 __fastcall sub_4F4A0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 4120) + 40LL))();
}

signed __int64 __fastcall sub_4F4B0(unsigned __int64 a1, unsigned __int64 a2)
{
  signed __int64 result; // rax

  if ( a1 < a2 )
    result = 0xFFFFFFFFLL;
  else
    result = a1 > a2;
  return result;
}

__int64 __fastcall sub_4F4D0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = sub_62750(a1);
  return v1 + (*(__int64 (**)(void))(**(_QWORD **)(a1 - 4120) + 56LL))();
}

__int64 __usercall sub_4F500@<rax>(unsigned int a1@<ebx>, __int64 a2@<rdi>, unsigned __int64 a3@<rsi>)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // r14
  __int64 v7; // rax
  __int64 v8; // r14
  unsigned __int64 v9; // rax
  int v10; // eax

  v3 = sub_1EFD0(*(__int64 **)(a2 + 152), 27);
  if ( v3 > 0x8BCF )
  {
    v4 = 60LL;
    LODWORD(v5) = 3600000;
    LOBYTE(a1) = a3 != 0 && a3 != 60;
    if ( !(_BYTE)a1 )
    {
LABEL_3:
      if ( !*(_BYTE *)(a2 + 496) )
        goto LABEL_4;
LABEL_9:
      LODWORD(v9) = sub_1EFD0(*(__int64 **)(a2 + 152), 44);
      if ( (unsigned int)v9 <= 0x8BCF )
      {
        if ( !(_DWORD)v9 )
          goto LABEL_4;
        v9 = (signed int)v9;
      }
      else
      {
        v9 = 2LL;
      }
      if ( v4 > v9 )
      {
        LODWORD(v5) = 60000 * v9;
        v4 = v9;
      }
      v10 = *(_DWORD *)(a2 + 464);
      if ( v10 & 1 && !(v10 & 4) && *(_QWORD *)(a2 + 480) - 60 * v4 < 0xA )
        LODWORD(v5) = v5 - 10000;
      goto LABEL_4;
    }
  }
  else
  {
    v4 = (signed int)v3;
    LODWORD(v5) = 60000 * v3;
    LOBYTE(a1) = a3 != 0 && a3 != v3;
    if ( !(_BYTE)a1 )
      goto LABEL_3;
  }
  v7 = sub_B4D20();
  v8 = *(_QWORD *)(a2 + 424);
  if ( v7 - v8 > 60000 * a3 )
    return a1;
  v4 = a3;
  v5 = 60000 * a3 + v8 - v7;
  if ( *(_BYTE *)(a2 + 496) )
    goto LABEL_9;
LABEL_4:
  a1 = 0;
  *(_QWORD *)(a2 + 416) = sub_99D00((unsigned int)v5, (__int64)sub_4FE50, a2);
  return a1;
}

unsigned __int64 __usercall sub_4F650@<rax>(__int64 a1@<rdi>, char a2@<sil>, __int64 *a3@<r13>, __int64 a4@<r15>)
{
  __int64 v5; // rbx
  char v6; // bp
  __int64 v7; // rdx
  __int64 v8; // rax
  time_t *v9; // r12
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 *v13; // rsi
  unsigned int v14; // er12
  __int64 v15; // rdx
  const char *v16; // rdi
  char *v17; // rax
  int v18; // eax
  int v19; // eax
  bool v20; // cf
  bool v21; // zf
  time_t v22; // rsi
  unsigned int v23; // eax
  unsigned __int64 v24; // rax
  __int64 v25; // [rsp-8h] [rbp-70h]
  time_t time1; // [rsp+0h] [rbp-68h]
  __int64 v27; // [rsp+8h] [rbp-60h]
  __int64 v28; // [rsp+10h] [rbp-58h]
  __int64 v29; // [rsp+18h] [rbp-50h]
  __int64 v30; // [rsp+20h] [rbp-48h]
  __int64 v31; // [rsp+28h] [rbp-40h]
  unsigned __int64 v32; // [rsp+38h] [rbp-30h]

  *(_DWORD *)(a1 + 464) = 0;
  v32 = __readfsqword(0x28u);
  if ( !*(_DWORD *)(**(_QWORD **)(a1 + 456) + 8LL) )
    return __readfsqword(0x28u) ^ v32;
  v5 = a1;
  v6 = a2;
  if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(a1 + 152), 41)
    && !(unsigned __int8)sub_1EF00(*(__int64 **)(a1 + 152), 42) )
  {
    return __readfsqword(0x28u) ^ v32;
  }
  v7 = *(_QWORD *)(a1 + 456);
  v8 = *(_QWORD *)(v7 + 8);
  if ( !*(_QWORD *)(v7 + 16) )
  {
    v13 = *(__int64 **)(a1 + 448);
    v18 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64))(v8 + 24))(v8, v13, v7 + 16);
    if ( v18 )
    {
      v16 = "GSSAPI import name failed - Bad service name; won't use GSS key exchange";
      if ( v18 != 3 )
        v16 = "GSSAPI import name failed; won't use GSS key exchange";
      goto LABEL_12;
    }
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 456) + 8LL);
  }
  a3 = &v27;
  v9 = &time1;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64 *, time_t *))(v8 + 56))(v8, &v27, &time1) )
    return __readfsqword(0x28u) ^ v32;
  v10 = *(_QWORD *)(a1 + 456);
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = 0LL;
  v11 = *(_QWORD *)(v10 + 8);
  v12 = *(_QWORD *)(v10 + 16);
  if ( time1 != -1 )
    v9 = 0LL;
  v13 = &v27;
  v14 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, _QWORD, __int64 *, __int64 *, time_t *, __int64))(v11 + 40))(
          v11,
          &v27,
          v12,
          0LL,
          &v30,
          &v28,
          v9,
          a1 + 480);
  v15 = v25;
  if ( v27 )
  {
    v13 = &v27;
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8LL) + 64LL))(
      *(_QWORD *)(*(_QWORD *)(a1 + 456) + 8LL),
      &v27,
      v25);
  }
  if ( v14 > 1 )
  {
    v16 = "No GSSAPI security context available";
    if ( !v6 )
      return __readfsqword(0x28u) ^ v32;
LABEL_12:
    v17 = sub_BC360((__int64)v16, v13, v15);
    sub_2D3A0(*(_QWORD *)(v5 + 4200), v17, (__int64)a3, a4);
    return __readfsqword(0x28u) ^ v32;
  }
  if ( v28 )
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8LL) + 48LL))(
      *(_QWORD *)(*(_QWORD *)(a1 + 456) + 8LL),
      &v28,
      v15);
  v19 = *(_DWORD *)(a1 + 464);
  v20 = *(_QWORD *)(a1 + 480) < 4uLL;
  v21 = *(_QWORD *)(a1 + 480) == 4LL;
  *(_DWORD *)(a1 + 464) |= 1u;
  if ( v20 || v21 )
    *(_DWORD *)(a1 + 464) = v19 | 9;
  if ( (unsigned __int8)sub_1EF00(*(__int64 **)(a1 + 152), 43) )
  {
    v22 = *(_QWORD *)(a1 + 472);
    if ( v22 != -1 && difftime(time1, v22) > 0.0 )
      *(_DWORD *)(a1 + 464) |= 2u;
    v23 = sub_1EFD0(*(__int64 **)(a1 + 152), 44);
    if ( v23 > 0x8BCF )
    {
      v24 = 120LL;
    }
    else
    {
      if ( !v23 )
        return __readfsqword(0x28u) ^ v32;
      v24 = 60LL * (signed int)v23;
    }
    if ( *(_QWORD *)(a1 + 480) <= v24 )
      *(_DWORD *)(a1 + 464) |= 4u;
  }
  return __readfsqword(0x28u) ^ v32;
}

void __fastcall sub_4F900(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, char a5, int a6)
{
  __int64 v6; // r14
  __int64 v7; // r15
  signed int v8; // er12
  char *v9; // rbp
  __int64 v10; // rax
  __int64 (***v11)(void); // rbx
  __int64 (**v12)(void); // rdi
  __int64 v13; // r13
  __int64 v14; // rdx
  char *v15; // r14
  char *v16; // rsi
  __int64 v17; // rbp
  int v18; // [rsp+8h] [rbp-48h]
  char v19; // [rsp+Ch] [rbp-44h]
  __int64 *v20; // [rsp+10h] [rbp-40h]

  if ( a6 )
  {
    v6 = a1;
    v20 = a3;
    v19 = a5;
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 200) + 24LL) + 40LL);
    v18 = v7;
    v8 = v7 * ((a6 + (signed int)v7 - 1) / (signed int)v7);
    sub_BC590((__int64 *)a2, 0LL);
    v9 = sub_BC510(a2, v8);
    v10 = (**(__int64 (__fastcall ***)(_QWORD, _QWORD))(*(_QWORD *)(v6 + 200) + 24LL))(
            *(_QWORD *)(*(_QWORD *)(v6 + 200) + 24LL),
            v8);
    v11 = (__int64 (***)(void))v10;
    if ( v10 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
    v12 = v11[1];
    if ( !(*(_BYTE *)(v6 + 4224) & 0x20) )
    {
      sub_33730((__int64)v12, v20);
      v12 = v11[1];
    }
    v13 = (signed int)v7;
    sub_2EC20(v12);
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v11[1], v19);
    v14 = *(signed int *)(v6 + 340);
    sub_2EC20(v11[1]);
    ((void (__fastcall *)(__int64 (***)(void), char *))(*v11)[3])(v11, v9);
    if ( (signed int)v7 < v8 )
    {
      ((void (__fastcall *)(__int64 (***)(void)))(*v11)[1])(v11);
      if ( !(*(_BYTE *)(v6 + 4224) & 0x20) )
        sub_33730((__int64)v11[1], v20);
      v15 = v9;
      sub_2EC20(v11[1]);
      do
      {
        v16 = v15;
        v15 += v13;
        sub_2EC20(v11[1]);
        v17 = ((__int64 (__fastcall *)(__int64 (**)(void), char *))**v11)(*v11, v16);
        (*(void (__fastcall **)(__int64, __int64 (***)(void)))(*(_QWORD *)v17 + 16LL))(v17, v11);
        (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v17 + 24LL))(v17, v15);
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 32LL))(v17);
        LODWORD(v7) = v18 + v7;
      }
      while ( v8 > (signed int)v7 );
    }
    ((void (__fastcall *)(__int64 (***)(void)))(*v11)[4])(v11);
  }
}

void __fastcall sub_4FAB0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbp
  __int64 v3; // rbx
  _QWORD *v4; // rdi
  __int64 v5; // rdi
  _QWORD *v6; // rdi
  _QWORD *v7; // rdi
  _QWORD *v8; // rdi
  _QWORD *v9; // rdi
  _QWORD **v10; // rdi
  _QWORD **v11; // rdi
  __int64 v12; // rdi

  v2 = (_QWORD *)(a1 - 4128);
  v3 = a1;
  v4 = *(_QWORD **)(a1 + 24);
  if ( v4 )
  {
    a2 = (__int64)v4;
    sub_61680(v4, v4, v2 + 9);
  }
  sub_1ED50(*(_QWORD **)(v3 - 3976));
  sub_62630(*(__int64 (****)(void))(v3 - 4120));
  sub_61600((__int64)(v2 + 2));
  sub_61630((__int64)(v2 + 9));
  sub_2F4D0(*(void **)(v3 - 3968));
  sub_2F4D0(*(void **)(v3 - 3680));
  sub_2F4D0(*(void **)(v3 - 3736));
  sub_2F4D0(*(void **)(v3 - 3728));
  sub_2F4D0(*(void **)(v3 - 3400));
  sub_2F4D0(*(void **)(v3 - 3912));
  sub_BC660(*(void ***)(v3 - 3408));
  v5 = *(_QWORD *)(v3 - 3392);
  if ( v5 && !*(_QWORD *)(v3 - 16) )
  {
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 24LL))(v5, a2);
    *(_QWORD *)(v3 - 3392) = 0LL;
  }
  v6 = *(_QWORD **)(v3 - 3592);
  if ( v6 )
    sub_330F0(v6);
  v7 = *(_QWORD **)(v3 - 3616);
  if ( v7 )
    sub_330F0(v7);
  v8 = *(_QWORD **)(v3 - 3608);
  if ( v8 )
    sub_330F0(v8);
  v9 = *(_QWORD **)(v3 - 3584);
  if ( v9 )
    sub_330F0(v9);
  v10 = *(_QWORD ***)(v3 - 3768);
  if ( v10 )
    sub_72500(v10);
  if ( *(_BYTE *)(v3 - 3368) )
  {
    sub_7DB10(*(_QWORD **)(v3 - 3376));
    sub_2F4D0(*(void **)(v3 - 3376));
  }
  v11 = *(_QWORD ***)(v3 - 3360);
  if ( v11 )
    sub_75F70(v11);
  v12 = *(_QWORD *)(v3 - 3760);
  if ( v12 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v12 + 32LL))(v12, a2);
  sub_BC660(*(void ***)(v3 - 3576));
  sub_BC660(*(void ***)(v3 - 3568));
  sub_4F250(*(_QWORD **)(v3 - 3640));
  sub_9AF90(*(_QWORD ***)(v3 - 72));
  sub_99EF0((__int64)v2);
  sub_2F4D0(v2);
}

__int64 __fastcall sub_4FC60(__int64 a1, void (__fastcall *a2)(__int64, __int64 (__fastcall *)(), signed __int64), __int64 a3)
{
  __int64 v3; // r12
  __int64 result; // rax
  signed __int64 v5; // rbx
  int v6; // eax

  v3 = a3;
  result = (*(__int64 (**)(void))(**(_QWORD **)(a1 - 4120) + 16LL))();
  if ( !(_BYTE)result )
  {
    if ( *(_BYTE *)(a1 + 96) & 0x40 )
      return result;
    goto LABEL_3;
  }
  if ( !(*(_BYTE *)(a1 + 96) & 0x40) )
  {
    ((void (__fastcall *)(__int64, _QWORD, signed __int64, _QWORD))a2)(v3, 0LL, 30LL, 0LL);
LABEL_3:
    ((void (__fastcall *)(__int64, const char *, signed __int64, _QWORD))a2)(v3, "Repeat key exchange", 15LL, 0LL);
    if ( *(_DWORD *)(a1 - 28) )
    {
      ((void (__fastcall *)(__int64, _QWORD, signed __int64, _QWORD))a2)(v3, 0LL, 30LL, 0LL);
      ((void (__fastcall *)(__int64, void *, signed __int64, _QWORD))a2)(v3, &unk_EBDE8, 31LL, 0LL);
      if ( *(_DWORD *)(a1 - 28) > 0 )
      {
        v5 = 1LL;
        do
        {
          a2(v3, (*off_324260[2 * *(signed int *)(a1 + 4 * v5 - 68)])[13], 16LL);
          v6 = v5++;
        }
        while ( v6 < *(_DWORD *)(a1 - 28) );
      }
      ((void (__fastcall *)(__int64, _QWORD, signed __int64, _QWORD))a2)(v3, 0LL, 32LL, 0LL);
    }
  }
  return 1LL;
}

_QWORD *__fastcall sub_4FD50(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  result = a1;
  while ( *result && *result != a2 )
  {
    result += 3;
    if ( a1 + 48 == result )
      __assert_fail(
        "false && \"Should never run out of space in KEXINIT list\"",
        "ssh2transport.c",
        0x144u,
        "ssh2_kexinit_addalg");
  }
  *result = a2;
  return result;
}

_QWORD *__fastcall sub_4FDB0(__int64 a1, int a2, int a3)
{
  _QWORD *result; // rax
  __int64 v4; // rdi
  __int64 v5; // rdi
  __int64 (__fastcall *(*v6)[13])(); // rax

  if ( a2 == 15 )
  {
    if ( !*(_BYTE *)(a1 - 3720) )
    {
      *(_DWORD *)(a1 - 3944) = 3;
      v4 = a1 + 32;
      *(_QWORD *)(v4 - 3984) = "at user request";
      result = sub_1BE20(v4);
    }
  }
  else if ( a2 == 16 )
  {
    if ( !*(_BYTE *)(a1 - 3720) )
    {
      *(_DWORD *)(a1 - 3944) = 3;
      v5 = a1 + 32;
      v6 = off_324260[2 * a3];
      *(_QWORD *)(v5 - 3952) = v6;
      *(_QWORD *)(v5 - 56) = v6;
      *(_QWORD *)(v5 - 3984) = "cross-certifying new host key";
      result = sub_1BE20(v5);
    }
  }
  else
  {
    result = (_QWORD *)(*(__int64 (**)(void))(**(_QWORD **)(a1 - 4120) + 24LL))();
  }
  return result;
}

void __usercall sub_4FE50(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 *a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbp
  unsigned int v5; // eax
  unsigned __int64 v6; // rax
  unsigned int v7; // [rsp-10h] [rbp-10h]

  if ( !*(_BYTE *)(a1 + 408) )
  {
    v4 = *(_QWORD *)(a1 + 416);
    if ( v4 == a2 )
    {
      v5 = sub_1EFD0(*(__int64 **)(a1 + 152), 27);
      if ( v5 > 0x8BCF )
      {
        v6 = 3570000LL;
      }
      else
      {
        if ( !v5 )
          return;
        v6 = 60000LL * (signed int)v5 - 30000;
      }
      if ( v4 - *(_QWORD *)(a1 + 424) > v6 )
      {
        *(_DWORD *)(a1 + 184) = 3;
        *(_QWORD *)(a1 + 176) = "timeout";
      }
      else
      {
        if ( !(unsigned int)sub_1EFD0(*(__int64 **)(a1 + 152), 44)
          || (sub_4F650(a1, 0, a3, a4), (*(_DWORD *)(a1 + 464) & 9) != 1)
          || !(*(_DWORD *)(a1 + 464) & 6) )
        {
          sub_4F500(v7, a1, 0LL);
          return;
        }
        *(_DWORD *)(a1 + 184) = 5;
        *(_QWORD *)(a1 + 176) = "GSS credentials updated";
      }
      sub_1BE20(a1 + 4160);
    }
  }
}

__int64 __fastcall sub_4FF50(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  __int64 v5; // rbp

  v4 = a3;
  v5 = a4;
  if ( sub_9B3D0(*(__int64 **)(a1 + 4056), a4, 0LL) )
    return 1LL;
  sub_9AFD0(*(__int64 **)(a1 + 4056), v5);
  return (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64 (__fastcall *)(__int64, int), __int64))(**(_QWORD **)(a1 + 4208) + 72LL))(
           *(_QWORD *)(a1 + 4208),
           a2,
           v4,
           sub_4F470,
           a1);
}

void nullsub_25()
{
  ;
}

__int64 __fastcall sub_4FFE0(__int64 (__fastcall ***a1)(), __int64 *a2)
{
  __int64 *v2; // r13
  __int64 (__fastcall ***v3)(); // r14
  unsigned int v4; // ebx
  const char *v5; // rbp
  signed int v6; // eax
  __int64 (__fastcall ***v7)(); // rdi
  char v8; // al
  unsigned __int64 v9; // rbx
  const char *v10; // rax
  unsigned __int64 v11; // rax
  char v12; // bl
  char v13; // al
  bool v14; // r12
  int v15; // ebx
  int v16; // er15
  int v17; // eax
  char v18; // bl
  char v19; // al
  _QWORD *v20; // rdi
  __int64 (__fastcall **v21)(); // rax
  bool v22; // zf
  char *v24; // rdx
  char v25; // si
  unsigned __int64 v26; // rbx
  char v27; // al
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rsi

  if ( *a1 != off_31F100 )
    __assert_fail("ppl->vt == &ssh2_transport_vtable", "ssh2transport.c", 0x816u, "ssh2_transport_reconfigure");
  v2 = a2;
  v3 = a1;
  v4 = (_DWORD)a1 - 4128;
  v5 = "timeout shortened";
  v6 = sub_1EFD0(a2, 27);
  v7 = a1 - 516;
  if ( (unsigned int)v6 >= 0x8BD0 )
    v6 = 60;
  v8 = sub_4F500(v4, (__int64)v7, v6);
  v9 = (unsigned __int64)*(v3 - 492);
  if ( !v8 )
    v5 = 0LL;
  v10 = (const char *)sub_1F170((__int64 *)*(v3 - 497), 28);
  v11 = sub_BBEB0(v10);
  *(v3 - 492) = (__int64 (__fastcall **)())v11;
  if ( v11 && v9 != v11 )
  {
    v24 = (char *)*(v3 - 469);
    v25 = v24[16];
    if ( v9 <= v11 )
    {
      v28 = v11 - v9;
      if ( v25 )
        *((_QWORD *)v24 + 3) += v28;
      if ( *v24 )
        *((_QWORD *)v24 + 1) += v28;
      goto LABEL_8;
    }
    v26 = v9 - v11;
    if ( v25 )
    {
      v29 = *((_QWORD *)v24 + 3);
      if ( v26 >= v29 )
      {
        v27 = *v24;
        v24[16] = 0;
        v24[17] = 1;
        if ( !v27 )
          goto LABEL_38;
LABEL_39:
        v30 = *((_QWORD *)v24 + 1);
        if ( v26 >= v30 )
        {
          *v24 = 0;
          v24[1] = 1;
        }
        else
        {
          *((_QWORD *)v24 + 1) = v30 - v26;
        }
LABEL_22:
        if ( !v27 )
        {
          if ( v24[1] )
            v5 = "data limit lowered";
          goto LABEL_8;
        }
LABEL_38:
        v5 = "data limit lowered";
        goto LABEL_8;
      }
      *((_QWORD *)v24 + 3) = v29 - v26;
    }
    v27 = v24[17];
    if ( !*v24 )
      goto LABEL_22;
    goto LABEL_39;
  }
LABEL_8:
  v12 = sub_1EF00((__int64 *)*(v3 - 497), 23);
  v13 = sub_1EF00(v2, 23);
  v14 = v12 != v13;
  if ( v12 != v13 )
    v5 = (const char *)&unk_EBE83;
  v15 = 0;
  do
  {
    v16 = sub_1F0A0((__int64 *)*(v3 - 497), 32, v15);
    v17 = sub_1F0A0(v2, 32, v15);
    if ( v16 != v17 )
    {
      v14 = 1;
      if ( v16 != v17 )
        v5 = "cipher settings changed";
    }
    ++v15;
  }
  while ( v15 != 7 );
  v18 = sub_1EF00((__int64 *)*(v3 - 497), 35);
  v19 = sub_1EF00(v2, 35);
  v20 = *(v3 - 497);
  if ( v18 == v19 )
  {
    sub_1ED50(v20);
    *(v3 - 497) = (__int64 (__fastcall **)())sub_1EED0(v2);
    if ( !v5 )
      return (*((__int64 (__fastcall **)(_QWORD, __int64 *))**(v3 - 515) + 6))(*(v3 - 515), v2);
    if ( !*((_BYTE *)v3 - 3720) && !(unsigned __int8)sub_49C40((__int64 (__fastcall ***)())v3[1]) )
      goto LABEL_27;
    if ( !v14 )
      return (*((__int64 (__fastcall **)(_QWORD, __int64 *))**(v3 - 515) + 6))(*(v3 - 515), v2);
  }
  else
  {
    sub_1ED50(v20);
    v5 = "cipher settings changed";
    v21 = (__int64 (__fastcall **)())sub_1EED0(v2);
    v22 = *((_BYTE *)v3 - 3720) == 0;
    *(v3 - 497) = v21;
    if ( v22 && !(unsigned __int8)sub_49C40((__int64 (__fastcall ***)())v3[1]) )
    {
LABEL_27:
      *(v3 - 494) = (__int64 (__fastcall **)())v5;
      *((_DWORD *)v3 - 986) = 3;
      sub_1BE20((__int64)(v3 + 4));
      return (*((__int64 (__fastcall **)(_QWORD, __int64 *))**(v3 - 515) + 6))(*(v3 - 515), v2);
    }
  }
  *(v3 - 462) = (__int64 (__fastcall **)())v5;
  return (*((__int64 (__fastcall **)(_QWORD, __int64 *))**(v3 - 515) + 6))(*(v3 - 515), v2);
}

_QWORD *__fastcall sub_502E0(_QWORD *a1, char *a2, int a3, char *a4, char *a5, char *a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)
{
  int v10; // ebx
  char *v11; // r12
  char *v12; // r13
  char *src; // ST08_8
  _QWORD *v14; // rax
  _QWORD *v15; // rbp
  char *v16; // rax
  __int64 v17; // rax
  _QWORD *v18; // rax
  signed __int64 v19; // rax
  __int64 v20; // rax
  _QWORD *v21; // rax
  __int64 *v22; // rdi
  const char *v23; // rax
  __int64 v25; // rdx

  v10 = a3;
  v11 = a6;
  v12 = a4;
  src = a5;
  v14 = sub_2F450(1uLL, 0x1088uLL, 0LL);
  v15 = v14;
  *v14 = 0LL;
  v14[528] = 0LL;
  memset(
    (void *)((unsigned __int64)(v14 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v14 - (((_DWORD)v14 + 8) & 0xFFFFFFF8) + 4232) >> 3));
  v14[516] = off_31F100;
  v14[19] = sub_1EED0(a1);
  v16 = sub_BC120(a2);
  *((_DWORD *)v15 + 42) = v10;
  v15[20] = v16;
  v15[56] = sub_BC120(v12);
  v15[57] = a7;
  v15[49] = sub_BC120(src);
  v15[50] = sub_BC120(v11);
  v15[47] = a8;
  v15[90] = sub_BC640();
  sub_615A0(v15 + 2);
  sub_615D0(v15 + 9);
  v15[17] = v15 + 516;
  v15[14] = v15 + 16;
  v15[16] = sub_4F460;
  v15[1] = a9;
  *(_QWORD *)(a9 + 56) = v15 + 1;
  sub_62650((_QWORD *)a9, (__int64)(v15 + 2), (__int64)(v15 + 9));
  v17 = v15[57];
  v15[59] = -1LL;
  *(_QWORD *)(v17 + 16) = 0LL;
  *(_QWORD *)(v17 + 24) = 0LL;
  v18 = sub_4F220();
  *((_BYTE *)v15 + 496) = 0;
  v15[61] = v18;
  v15[69] = sub_BC640();
  v19 = sub_BC640();
  v15[70] = v19;
  if ( a10 )
  {
    v15[71] = v19;
    v20 = v15[69];
    *((_DWORD *)v15 + 167) = 1;
    v15[72] = v20;
    v15[48] = a10;
    v15[84] = v15 + 74;
    v15[85] = v15 + 79;
  }
  else
  {
    v15[72] = v19;
    v25 = v15[69];
    *((_DWORD *)v15 + 157) = 1;
    v15[84] = v15 + 79;
    v15[71] = v25;
    v15[85] = v15 + 74;
  }
  v21 = sub_9AF60((__int64)sub_4F4B0);
  v22 = (__int64 *)v15[19];
  v15[507] = v21;
  v23 = (const char *)sub_1F170(v22, 28);
  v15[24] = sub_BBEB0(v23);
  return v15 + 516;
}

signed __int64 __usercall sub_50560@<rax>(_QWORD *a1@<rdi>, __int64 a2@<r15>)
{
  signed int *v2; // rax
  signed int *v3; // rbx
  signed int v4; // eax
  char *s1; // ST08_8
  size_t v6; // rdx
  size_t n; // ST10_8
  char *v8; // rax
  __int64 v9; // rdx
  __int64 v11; // rbx
  char *v12; // rbx
  unsigned __int64 v13; // rdx
  unsigned int v14; // eax
  char *v15; // rax
  __int64 v16; // rbx
  int v17; // ebp
  unsigned __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // [rsp+0h] [rbp-88h]
  int v21; // [rsp+1Ch] [rbp-6Ch]
  char *v22; // [rsp+20h] [rbp-68h]
  __int64 v23; // [rsp+28h] [rbp-60h]
  void *v24; // [rsp+30h] [rbp-58h]
  size_t v25; // [rsp+38h] [rbp-50h]
  unsigned __int64 v26; // [rsp+48h] [rbp-40h]

  v26 = __readfsqword(0x28u);
  while ( 1 )
  {
    v2 = (signed int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1[2] + 48LL))(a1[2], a1[2], 0LL);
    v3 = v2;
    if ( !v2 )
      return 0LL;
    v4 = *v2;
    if ( v4 != 2 )
      break;
LABEL_22:
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(a1[2] + 48LL))(a1[2], a1[2], 1LL);
  }
  if ( v4 > 2 )
  {
    if ( v4 == 4 )
    {
      v11 = (__int64)(v3 + 12);
      sub_2F0C0(v11);
      v12 = sub_2F1D0(v11);
      v14 = sub_BC2F0(v13);
      v15 = sub_BC360((__int64)"Remote debug message: %.*s", v14, v12, v20);
      sub_2D3A0(a1[9], v15, (__int64)"rsa-sha2-256", a2);
    }
    else
    {
      if ( v4 != 7 )
        return 0LL;
      v20 = (__int64)(v3 + 12);
      v21 = sub_2F150((__int64)(v3 + 12));
      if ( v21 && !v3[18] )
      {
        LODWORD(a2) = 0;
        do
        {
          s1 = sub_2F1D0(v20);
          n = v6;
          v8 = sub_2F1D0(v20);
          v23 = v9;
          v22 = v8;
          if ( (unsigned __int8)sub_BD100(s1, n, "server-sig-algs") )
          {
            while ( (unsigned __int8)sub_61EA0((__m128i *)&v22, (__m128i *)&v24) )
            {
              if ( (unsigned __int8)sub_BD100(v24, v25, "rsa-sha2-256") )
                *(_BYTE *)(a1[1] + 220LL) = 1;
              if ( (unsigned __int8)sub_BD100(v24, v25, "rsa-sha2-512") )
                *(_BYTE *)(a1[1] + 221LL) = 1;
            }
          }
          a2 = (unsigned int)(a2 + 1);
        }
        while ( v21 != (_DWORD)a2 && !v3[18] );
      }
    }
    goto LABEL_22;
  }
  if ( v4 != 1 )
    return 0LL;
  v16 = (__int64)(v3 + 12);
  v17 = sub_2F150(v16);
  sub_2F1D0(v16);
  sub_BC2F0(v18);
  if ( (unsigned int)(v17 - 1) <= 0xE )
    v19 = qword_31F040[v17];
  sub_42140(
    a1[11],
    (__int64)"Remote side sent disconnect message\ntype %d (%s):\n\"%.*s\"",
    (__int64)"rsa-sha2-256",
    a2,
    v20);
  return 1LL;
}

signed __int64 __usercall sub_507B0@<rax>(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 i; // r13
  int *v3; // rax
  __int64 *v4; // rbx
  unsigned int v5; // er14
  __int64 v7; // rdx

  for ( i = a1 + 16; ; sub_614E0(i, v4 + 2) )
  {
    v5 = sub_50560((_QWORD *)(a1 + 4128), a2);
    if ( (_BYTE)v5 )
      return v5;
    v3 = (int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 4144) + 48LL))(
                  *(_QWORD *)(a1 + 4144),
                  *(_QWORD *)(a1 + 4144),
                  0LL);
    v4 = (__int64 *)v3;
    if ( !v3 || *v3 <= 49 )
      return v5;
    if ( !*(_BYTE *)(a1 + 440) )
      break;
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 4144) + 48LL))(
      *(_QWORD *)(a1 + 4144),
      *(_QWORD *)(a1 + 4144),
      1LL);
  }
  sub_621E0(
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 4136) + 144LL) + 4LL),
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 4136) + 144LL) + 8LL),
    *v3);
  v7 = *(unsigned int *)v4;
  sub_423C0(*(_QWORD *)(a1 + 4216), (__int64)"Received premature higher-layer packet, type %d (%s)", i, a2);
  return 1LL;
}

__int64 __usercall sub_50890@<rax>(__int64 a1@<rdi>, __int64 a2@<r15>)
{
  __int64 result; // rax

  if ( (unsigned __int8)sub_507B0(a1, a2) )
    result = 0LL;
  else
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 4144) + 48LL))(
               *(_QWORD *)(a1 + 4144),
               *(_QWORD *)(a1 + 4144),
               1LL);
  return result;
}

unsigned __int64 __usercall sub_508C0@<rax>(signed __int64 a1@<rdi>, __int64 a2@<rsi>, signed __int64 a3@<r12>, __int64 *a4@<r13>, __int64 (__fastcall *(**a5)[13])()@<r15>, __m128i a6@<xmm0>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  signed __int64 v11; // rbx
  signed int v12; // eax
  unsigned __int64 result; // rax
  unsigned __int64 v14; // rt1
  int *v15; // rax
  int *v16; // rbp
  __int64 v17; // rdx
  __int64 *v18; // rsi
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // rdi
  __int64 v22; // rbp
  __int64 v23; // rax
  __int64 v24; // r8
  bool v25; // zf
  int *v26; // rax
  int *v27; // rbp
  __int64 v28; // rdx
  int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rbp
  char *v32; // rsi
  void (__fastcall **v33)(_QWORD, char *, signed __int64); // rdi
  __int64 *v34; // rdi
  int v35; // eax
  __int64 v36; // rcx
  int v37; // edx
  int v38; // eax
  int v39; // eax
  int v40; // ebp
  int v41; // eax
  double v42; // xmm4_8
  double v43; // xmm5_8
  __int64 v44; // r13
  __int64 v45; // rax
  __int64 v46; // rdx
  __int64 v47; // rsi
  __int64 v48; // rax
  __int64 v49; // rcx
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // rsi
  __int64 v53; // rax
  char *v54; // rax
  __int64 v55; // rdi
  __int64 v56; // rdx
  __int64 v57; // rax
  __int64 v58; // rdx
  unsigned __int8 v59; // bl
  __int64 v60; // rbp
  _DWORD *v61; // rax
  __int64 v62; // rdx
  __int64 v63; // rdx
  __int64 v64; // rax
  __int64 v65; // rbp
  __int64 v66; // rax
  __int64 v67; // r8
  __int64 v68; // rdi
  char *v69; // rax
  __int64 *v70; // rdi
  char *v71; // rax
  signed int v72; // er12
  signed int v73; // ebx
  int v74; // er12
  __int64 v75; // rax
  signed int v76; // er12
  int v77; // ebp
  int v78; // er13
  int v79; // eax
  __int64 v80; // rdx
  __int64 v81; // rax
  __int64 v82; // rax
  __int64 v83; // rax
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 m; // rax
  signed int v87; // edx
  __int64 v88; // rcx
  __int64 v89; // rsi
  char v90; // dl
  char v91; // dl
  char v92; // dl
  char v93; // dl
  char v94; // dl
  char v95; // al
  __int64 (__fastcall *(*v96)[13])(); // rax
  int v97; // ebx
  size_t v98; // rax
  void **v99; // rbp
  unsigned __int8 v100; // r14
  char *v101; // rdx
  int v102; // ebx
  int v103; // er15
  __int64 v104; // rax
  signed __int64 v105; // rbx
  _QWORD *v106; // r14
  char **v107; // rax
  signed __int64 v108; // rax
  __int64 v109; // rdx
  char *v110; // r12
  char v111; // r13
  __int64 v112; // r14
  char *v113; // r15
  __int64 v114; // rcx
  __int64 v115; // rbx
  _QWORD *v116; // rax
  __int64 v117; // rdx
  char *v118; // rax
  __int64 v119; // rax
  __int64 v120; // rax
  __int64 v121; // rax
  __int64 v122; // rax
  __int64 v123; // rax
  __int64 v124; // rax
  _QWORD *v125; // r12
  __int64 **v126; // r15
  __int64 v127; // rbx
  _QWORD *v128; // rax
  _QWORD *v129; // rax
  _QWORD *v130; // rax
  _QWORD *v131; // rax
  _QWORD *v132; // r13
  char v133; // r12
  __int128 *v134; // rbp
  __int64 v135; // r14
  __int64 v136; // rdx
  __int64 v137; // rbx
  _QWORD *v138; // rax
  __int64 v139; // rcx
  __int64 (__fastcall **v140)(); // rax
  unsigned int v141; // edx
  _QWORD *v142; // r12
  int v143; // esi
  __int64 (__fastcall *(**v144)[4])(); // rdx
  int v145; // esi
  __int64 (__fastcall *(**v146)[4])(); // rbp
  signed __int64 v147; // r13
  __int64 (__fastcall ***l)(); // r15
  _QWORD *v149; // rax
  __int64 v150; // rdx
  __int64 (__fastcall *(**v151)[4])(); // r15
  __int64 v152; // rsi
  _QWORD *v153; // rax
  __int64 (__fastcall *(*v154)[4])(); // rdx
  _QWORD *v155; // rbp
  _QWORD *v156; // rax
  __int64 v157; // rsi
  _QWORD *v158; // rax
  _QWORD *v159; // rax
  _QWORD *v160; // rax
  _QWORD *v161; // rdi
  _QWORD *v162; // rax
  __int64 *v163; // rbx
  signed __int64 v164; // rax
  __int64 v165; // rsi
  __int64 v166; // rdx
  __int64 v167; // rbp
  const char *v168; // rsi
  __int64 v169; // rbp
  __int64 v170; // rax
  __int64 v171; // rcx
  signed __int64 v172; // rsi
  int *v173; // rax
  int *v174; // rbp
  __int64 v175; // rdx
  int v176; // eax
  __int64 v177; // rax
  unsigned int *v178; // rbp
  __int64 v179; // rdx
  __int64 v180; // rcx
  signed __int64 v181; // rax
  char v182; // cl
  __int64 *v183; // r15
  char *v184; // rbp
  char v185; // al
  int v186; // er13
  __int64 (__fastcall *(**v187)[13])(); // r14
  signed int i; // eax
  __int64 (__fastcall *(*v189)[13])(); // rbx
  _QWORD *v190; // rax
  char *v191; // r12
  char v192; // bp
  int *v193; // rax
  __int64 (__fastcall *(**v194)[13])(); // r15
  __int64 (__fastcall *(**v195)[13])(); // r13
  int v196; // er14
  signed int j; // eax
  __int64 (__fastcall *(*v198)[13])(); // rbx
  _QWORD *v199; // rax
  __int64 v200; // rdx
  char *v201; // rbp
  int *v202; // rax
  __int64 *v203; // rax
  __int64 (__fastcall *(*v204)[13])(); // rax
  __int64 v205; // rax
  int v206; // eax
  char *v207; // rax
  __int64 v208; // rdx
  __int64 v209; // rax
  signed __int64 v210; // rsi
  char *v211; // rax
  char *v212; // rbp
  size_t v213; // rdx
  size_t v214; // rsi
  __int64 v215; // rbp
  char *v216; // rbp
  int *v217; // rax
  char v218; // r15
  int v219; // er14
  __int64 (__fastcall *(**v220)[13])(); // rbx
  signed int k; // eax
  __int64 v222; // r13
  _QWORD *v223; // rax
  char *v224; // rax
  signed __int64 v225; // rax
  void (__fastcall **v226)(_QWORD, char *, signed __int64); // r14
  __int64 v227; // rbp
  __int64 (__fastcall *(*v228)[13])(); // rax
  __int64 v229; // rax
  __int64 v230; // rbp
  __int64 v231; // rsi
  __int64 v232; // rdx
  __int64 v233; // rax
  __int64 v234; // rbp
  char *v235; // rdx
  __int64 v236; // rcx
  __int16 v237; // dx
  __m128i v238; // xmm0
  __int64 v239; // rax
  __int64 v240; // rdx
  __int64 v241; // r13
  __int64 v242; // rcx
  __int64 v243; // rsi
  __int64 v244; // [rsp+8h] [rbp-310h]
  __int64 v245; // [rsp+10h] [rbp-308h]
  signed __int64 v246; // [rsp+18h] [rbp-300h]
  char v247; // [rsp+18h] [rbp-300h]
  __int64 **v248; // [rsp+20h] [rbp-2F8h]
  char v249; // [rsp+28h] [rbp-2F0h]
  __int64 *v250; // [rsp+28h] [rbp-2F0h]
  signed __int64 v251; // [rsp+28h] [rbp-2F0h]
  _QWORD *v252; // [rsp+28h] [rbp-2F0h]
  int v253; // [rsp+30h] [rbp-2E8h]
  signed __int64 v254; // [rsp+38h] [rbp-2E0h]
  int v255; // [rsp+38h] [rbp-2E0h]
  char v256; // [rsp+40h] [rbp-2D8h]
  _QWORD *v257; // [rsp+40h] [rbp-2D8h]
  char v258; // [rsp+40h] [rbp-2D8h]
  char *v259; // [rsp+40h] [rbp-2D8h]
  char v260; // [rsp+48h] [rbp-2D0h]
  _QWORD *v261; // [rsp+48h] [rbp-2D0h]
  unsigned __int64 v262; // [rsp+50h] [rbp-2C8h]
  signed __int64 v263; // [rsp+50h] [rbp-2C8h]
  __int64 v264; // [rsp+58h] [rbp-2C0h]
  int v265; // [rsp+58h] [rbp-2C0h]
  __int64 v266; // [rsp+60h] [rbp-2B8h]
  __int64 v267; // [rsp+60h] [rbp-2B8h]
  __int64 v268; // [rsp+68h] [rbp-2B0h]
  __int64 *v269; // [rsp+68h] [rbp-2B0h]
  signed __int64 v270; // [rsp+70h] [rbp-2A8h]
  unsigned int v271; // [rsp+70h] [rbp-2A8h]
  signed __int64 v272; // [rsp+70h] [rbp-2A8h]
  _QWORD *v273; // [rsp+70h] [rbp-2A8h]
  const char *v274; // [rsp+78h] [rbp-2A0h]
  _QWORD *v275; // [rsp+78h] [rbp-2A0h]
  int v276; // [rsp+80h] [rbp-298h]
  signed __int64 v277; // [rsp+80h] [rbp-298h]
  _QWORD *v278; // [rsp+88h] [rbp-290h]
  _QWORD *v279; // [rsp+88h] [rbp-290h]
  int v280; // [rsp+98h] [rbp-280h]
  __int64 v281; // [rsp+A0h] [rbp-278h]
  signed __int64 v282; // [rsp+A0h] [rbp-278h]
  int v283; // [rsp+ACh] [rbp-26Ch]
  __m128i v284; // [rsp+B0h] [rbp-268h]
  __m128i v285; // [rsp+C0h] [rbp-258h]
  size_t v286[2]; // [rsp+D0h] [rbp-248h]
  void *s1; // [rsp+E0h] [rbp-238h]
  size_t n; // [rsp+E8h] [rbp-230h]
  __int64 v289; // [rsp+F0h] [rbp-228h]
  __int64 v290; // [rsp+F8h] [rbp-220h]
  __int64 v291; // [rsp+100h] [rbp-218h]
  int v292; // [rsp+108h] [rbp-210h]
  __int64 *v293; // [rsp+110h] [rbp-208h]
  __int64 v294; // [rsp+120h] [rbp-1F8h]
  __int64 v295; // [rsp+128h] [rbp-1F0h]
  __int64 v296; // [rsp+130h] [rbp-1E8h]
  int v297; // [rsp+138h] [rbp-1E0h]
  __int64 *v298; // [rsp+140h] [rbp-1D8h]
  int v299; // [rsp+150h] [rbp-1C8h]
  char v300[60]; // [rsp+154h] [rbp-1C4h]
  int v301; // [rsp+190h] [rbp-188h]
  char v302[28]; // [rsp+194h] [rbp-184h]
  __int64 v303; // [rsp+1B0h] [rbp-168h]
  __int128 v304[8]; // [rsp+1D0h] [rbp-148h]
  __int128 v305; // [rsp+250h] [rbp-C8h]
  __int128 v306; // [rsp+260h] [rbp-B8h]
  unsigned __int64 v307; // [rsp+2D8h] [rbp-40h]

  v11 = a1;
  v307 = __readfsqword(0x28u);
  v244 = a1 - 4128;
  if ( (unsigned __int8)sub_507B0(a1 - 4128, (__int64)a5) )
    goto LABEL_10;
  v12 = *(_DWORD *)(a1 - 4128);
  if ( v12 == 1352 )
  {
    v38 = *(_DWORD *)(a1 - 3232);
    goto LABEL_57;
  }
  if ( v12 > 1352 )
  {
    if ( v12 == 1491 )
      goto LABEL_31;
    if ( v12 > 1491 )
    {
      if ( v12 == 1589 )
        goto LABEL_235;
      if ( v12 != 1619 )
      {
        if ( v12 != 1579 )
          goto LABEL_9;
        goto LABEL_84;
      }
      a5 = (__int64 (__fastcall *(**)[13])())(a1 - 4128);
      sub_61680(*(_QWORD **)(a1 + 24), *(_QWORD **)(a1 + 24), (_QWORD *)(v244 + 72));
      v177 = sub_50890((__int64)a5, (__int64)a5);
      v178 = (unsigned int *)v177;
      if ( v177 )
      {
        if ( *(_DWORD *)v177 != 20 )
        {
          sub_621E0(
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 144LL) + 4LL),
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 144LL) + 8LL),
            *(_DWORD *)v177);
          v179 = *v178;
          sub_423C0(
            *(_QWORD *)(a1 + 88),
            (__int64)"Received unexpected transport-layer packet outside a key exchange, type %d (%s)",
            (__int64)a4,
            v244);
          goto LABEL_10;
        }
        v210 = v177 + 16;
        sub_61540(*(__int64 **)(a1 + 16), (__int64 *)(v177 + 16));
        v211 = sub_BC360((__int64)"Remote side initiated key re-exchange", v210);
        sub_2D3A0(*(_QWORD *)(a1 + 72), v211, (__int64)a4, v244);
        *(_DWORD *)(a1 - 3944) = 2;
        goto LABEL_95;
      }
      v206 = *(_DWORD *)(a1 - 3944);
      if ( v206 == 4 )
      {
        if ( *(_BYTE *)(a1 - 3237) )
        {
          *(_DWORD *)(a1 - 3944) = 3;
          *(_QWORD *)(a1 - 3952) = "populating transient host key cache";
          goto LABEL_293;
        }
        *(_DWORD *)(a1 - 3944) = 0;
      }
      else if ( v206 )
      {
        if ( !(v206 & 0xFFFFFFFD) )
          goto LABEL_95;
        v243 = *(_QWORD *)(a1 - 3952);
        goto LABEL_293;
      }
      v233 = *(_QWORD *)(a1 - 3752);
      if ( *(_BYTE *)(v233 + 1) )
      {
        *(_DWORD *)(a1 - 3944) = 3;
        *(_QWORD *)(a1 - 3952) = "too much data received";
      }
      else
      {
        if ( !*(_BYTE *)(v233 + 17) )
        {
LABEL_316:
          if ( !*(_DWORD *)(a1 - 3944) )
            goto LABEL_88;
LABEL_95:
          if ( *(_BYTE *)(v11 - 3237) )
            goto LABEL_96;
          goto LABEL_239;
        }
        *(_DWORD *)(a1 - 3944) = 3;
        *(_QWORD *)(a1 - 3952) = "too much data sent";
      }
LABEL_293:
      if ( *(_BYTE *)(a1 + 96) & 0x40 )
      {
        v207 = sub_BC360((__int64)"Remote bug prevents key re-exchange (%s)");
        sub_2D3A0(*(_QWORD *)(a1 + 72), v207, (__int64)a4, v244);
        v208 = *(_QWORD *)(a1 - 3936);
        v209 = *(_QWORD *)(a1 - 3752);
        *(_BYTE *)(v209 + 1) = 0;
        *(_QWORD *)(v209 + 8) = v208;
        *(_BYTE *)(v209 + 17) = 0;
        *(_QWORD *)(v209 + 24) = v208;
        *(_BYTE *)v209 = v208 != 0;
        *(_BYTE *)(v209 + 16) = v208 != 0;
        sub_4F500(a1, v244, 0LL);
        *(_DWORD *)(a1 - 3944) = 0;
        goto LABEL_88;
      }
      v224 = sub_BC360((__int64)"Initiating key re-exchange (%s)");
      sub_2D3A0(*(_QWORD *)(a1 + 72), v224, (__int64)a4, v244);
      goto LABEL_316;
    }
    if ( v12 == 1364 )
      goto LABEL_42;
    if ( v12 == 1382 )
      goto LABEL_21;
LABEL_9:
    *(_DWORD *)(a1 - 4128) = 0;
    goto LABEL_10;
  }
  if ( v12 == 1274 )
  {
    v39 = *(_DWORD *)(a1 - 3232);
LABEL_61:
    if ( v39 >= 0 )
    {
      if ( v39 )
        goto LABEL_63;
      sub_42660(*(_QWORD *)(v11 + 88), (__int64)"User aborted at kex warning", (__int64)a4, (__int64)a5);
    }
    goto LABEL_10;
  }
  if ( v12 > 1274 )
  {
    if ( v12 == 1330 )
      goto LABEL_52;
    if ( v12 == 1341 )
    {
      v29 = *(_DWORD *)(a1 - 3232);
      goto LABEL_37;
    }
    goto LABEL_9;
  }
  if ( v12 )
  {
    if ( v12 == 1221 )
      goto LABEL_16;
    goto LABEL_9;
  }
  *(_QWORD *)(a1 - 3496) = 0LL;
  *(_QWORD *)(a1 - 3536) = 0LL;
  *(_QWORD *)(a1 - 3488) = 0LL;
  *(_QWORD *)(a1 - 3528) = 0LL;
  *(_QWORD *)(a1 - 3472) = 0LL;
  *(_QWORD *)(a1 - 3512) = 0LL;
  *(_BYTE *)(a1 - 3235) = 0;
  *(_BYTE *)(a1 - 3237) = 0;
  *(_BYTE *)(a1 - 3236) = 0;
LABEL_239:
  if ( (unsigned __int8)sub_1EF00(*(__int64 **)(v11 - 3976), 42) )
  {
    if ( *(_DWORD *)(v11 - 3944) != 5 )
      sub_4F650(v244, 1, a4, (__int64)a5);
    v176 = *(_DWORD *)(v11 - 3664);
    *(_BYTE *)(v11 - 3238) = v176;
    *(_BYTE *)(v11 - 3238) &= 1u;
    if ( !*(_BYTE *)(v11 - 3235) && v176 & 8 )
      *(_BYTE *)(v11 - 3238) = 0;
    *(_BYTE *)(v11 - 78) = sub_1EF00(*(__int64 **)(v11 - 3976), 43);
    goto LABEL_97;
  }
LABEL_96:
  *(_BYTE *)(v11 - 3238) = 0;
LABEL_97:
  v70 = *(__int64 **)(v11 - 3560);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 4LL) = 0;
  sub_BC590(v70, 0LL);
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v11 - 3576) + 24LL), 20);
  v71 = sub_BC510(*(_QWORD *)(v11 - 3576), 0x10uLL);
  sub_7BF50(v71, 0x10uLL);
  v280 = 0;
  if ( *(_BYTE *)(v11 - 3632) )
    v280 = (unsigned __int8)(*(_BYTE *)(v11 - 3237) ^ 1);
  v72 = 0;
  v260 = *(_BYTE *)(v11 - 3238);
  v247 = *(_BYTE *)(v11 - 3235) ^ 1;
  v276 = *(_DWORD *)(v11 - 8);
  v248 = *(__int64 ***)(v11 - 16);
  v257 = *(_QWORD **)(v11 - 3640);
  v281 = *(_QWORD *)(v11 - 3920);
  v271 = *(_DWORD *)(v11 - 3960);
  v274 = *(const char **)(v11 - 3968);
  v265 = *(_DWORD *)(v11 + 96);
  v267 = *(_QWORD *)(v11 - 3744);
  v250 = *(__int64 **)(v11 - 3976);
  v245 = *(_QWORD *)(v11 - 3576);
  if ( v260 )
  {
    v72 = 1;
    *(_QWORD *)&v304[0] = &unk_3205D0;
  }
  v254 = v11;
  v73 = v72;
  v74 = 0;
  do
  {
    switch ( (unsigned int)sub_1F0A0(v250, 24, v74) )
    {
      case 0u:
        if ( v74 != 5 )
        {
          v85 = v73++;
          *((_QWORD *)v304 + v85) = 0LL;
          break;
        }
        goto LABEL_105;
      case 1u:
        v84 = v73++;
        *((_QWORD *)v304 + v84) = &unk_320650;
        break;
      case 2u:
        v82 = v73++;
        *((_QWORD *)v304 + v82) = &unk_320620;
        break;
      case 3u:
        v81 = v73++;
        *((_QWORD *)v304 + v81) = &unk_320600;
        break;
      case 4u:
        v75 = v73++;
        *((_QWORD *)v304 + v75) = &unk_320F60;
        break;
      case 5u:
        v83 = v73++;
        *((_QWORD *)v304 + v83) = &unk_320740;
        break;
      default:
        break;
    }
    ++v74;
  }
  while ( v74 != 6 );
LABEL_105:
  v76 = v73;
  v77 = 0;
  v78 = 0;
  do
  {
    v79 = sub_1F0A0(v250, 25, v78);
    if ( v79 || v78 <= 4 )
    {
      v80 = v77++;
      *(&v301 + v80) = v79;
    }
    ++v78;
  }
  while ( v78 != 6 );
  v263 = v254;
  v283 = v77;
  v102 = 0;
  v103 = 0;
  do
  {
    switch ( (unsigned int)sub_1F0A0(v250, 32, v102) )
    {
      case 0u:
        if ( v102 != 6 )
        {
          v120 = v103++;
          *((_QWORD *)&v305 + v120) = 0LL;
          break;
        }
        goto LABEL_157;
      case 1u:
        v122 = v103++;
        *((_QWORD *)&v305 + v122) = &unk_320390;
        break;
      case 2u:
        v119 = v103++;
        *((_QWORD *)&v305 + v119) = &unk_31FD20;
        break;
      case 3u:
        v124 = v103++;
        *((_QWORD *)&v305 + v124) = &unk_31F1C0;
        break;
      case 4u:
        if ( (unsigned __int8)sub_1EF00(v250, 35) )
        {
          v123 = v103++;
          *((_QWORD *)&v305 + v123) = &unk_3204B0;
        }
        break;
      case 5u:
        v104 = v103++;
        *((_QWORD *)&v305 + v104) = &unk_31FBA0;
        break;
      case 6u:
        v121 = v103++;
        *((_QWORD *)&v305 + v121) = &unk_31FEC0;
        break;
      default:
        break;
    }
    ++v102;
  }
  while ( v102 != 7 );
LABEL_157:
  v255 = v103;
  v105 = v263;
  v106 = (_QWORD *)(v244 + 904);
  v25 = (unsigned __int8)sub_1EF00(v250, 23) == 0;
  v107 = off_3218A0;
  if ( v25 )
    v107 = &off_31F160;
  v269 = (__int64 *)v107;
  do
  {
    v108 = (signed __int64)(v106 + 48);
    do
    {
      *v106 = 0LL;
      v106 += 3;
    }
    while ( v106 != (_QWORD *)v108 );
  }
  while ( v106 != (_QWORD *)(v244 + 3976) );
  if ( v76 )
  {
    v278 = v106;
    v109 = (unsigned int)(v76 - 1);
    v110 = (char *)v304 + 8;
    v111 = 0;
    v112 = *(_QWORD *)&v304[0];
    v113 = (char *)v304 + 8 * v109 + 8;
    if ( !*(_QWORD *)&v304[0] )
      goto LABEL_170;
LABEL_165:
    if ( *(_DWORD *)v112 > 0 )
    {
      v114 = *(_QWORD *)(v112 + 8);
      v115 = 0LL;
      do
      {
        v116 = sub_4FD50((_QWORD *)(v244 + 904), **(_QWORD **)(v114 + 8 * v115));
        v114 = *(_QWORD *)(v112 + 8);
        v117 = *(_QWORD *)(v114 + 8 * v115);
        *((_BYTE *)v116 + 16) = v111;
        v116[1] = v117;
        ++v115;
      }
      while ( *(_DWORD *)v112 > (signed int)v115 );
    }
    while ( 1 )
    {
      v118 = v110;
      if ( v113 == v110 )
        break;
      v112 = *(_QWORD *)v110;
      v110 += 8;
      if ( *(_QWORD *)v118 )
        goto LABEL_165;
LABEL_170:
      v111 = 1;
    }
    v106 = v278;
    v105 = v263;
  }
  if ( v248 )
  {
    if ( v276 > 0 )
    {
      v125 = (_QWORD *)(v105 - 2840);
      v126 = v248;
      v251 = v105;
      do
      {
        v127 = **v126;
        v128 = sub_4FD50(v125, *(_QWORD *)(v127 + 104));
        v128[1] = v127;
        *((_DWORD *)v128 + 4) = 0;
        *((_BYTE *)v128 + 20) = 0;
        if ( (__int64 (__fastcall **)())v127 == off_3210C0 )
        {
          v129 = sub_4FD50(v125, (__int64)"rsa-sha2-256");
          v129[1] = off_3210C0;
          *((_DWORD *)v129 + 4) = 2;
          *((_BYTE *)v129 + 20) = 0;
          v130 = sub_4FD50(v125, (__int64)"rsa-sha2-512");
          v130[1] = off_3210C0;
          *((_DWORD *)v130 + 4) = 4;
          *((_BYTE *)v130 + 20) = 0;
        }
        ++v126;
      }
      while ( &v248[(unsigned int)(v276 - 1) + 1] != v126 );
      v105 = v251;
    }
  }
  else if ( v247 )
  {
    if ( v77 )
    {
      v183 = v250;
      v258 = 0;
      v252 = v106;
      v184 = (char *)&v301;
      v282 = v105;
      v279 = (_QWORD *)(v105 - 2840);
      do
      {
        v185 = v258;
        v186 = *(_DWORD *)v184;
        v187 = off_324260;
        if ( !*(_DWORD *)v184 )
          v185 = v247;
        v258 = v185;
        for ( i = 4; ; i = *((_DWORD *)v187 + 2) )
        {
          if ( v186 == i )
          {
            if ( (unsigned __int8)sub_1EF00(v183, 26) )
            {
              v189 = *v187;
              if ( sub_BAFB0(v274, v271, (const char *)(**v187)[14]) )
              {
                v190 = sub_4FD50(v279, (__int64)(*v189)[13]);
                v190[1] = v189;
                *((_BYTE *)v190 + 20) = v258;
              }
            }
          }
          v187 += 2;
          if ( &unk_3242F0 == (_UNKNOWN *)v187 )
            break;
        }
        v184 += 4;
      }
      while ( &v302[4 * (v283 - 1)] != v184 );
      v191 = v302;
      v259 = v184;
      v192 = 0;
      v193 = &v301;
      while ( 1 )
      {
        v194 = v187;
        v195 = off_324260;
        v196 = *v193;
        if ( !*v193 )
          v192 = v247;
        for ( j = 4; ; j = *((_DWORD *)v195 + 2) )
        {
          if ( v196 == j )
          {
            v198 = *v195;
            v199 = sub_4FD50((_QWORD *)(v282 - 2840), (__int64)(**v195)[13]);
            v199[1] = v198;
            *((_BYTE *)v199 + 20) = v192;
          }
          v195 += 2;
          if ( v195 == v194 )
            break;
        }
        v187 = v194;
        v193 = (int *)v191;
        if ( v191 == v259 )
          break;
        v191 += 4;
      }
      v106 = v252;
      v105 = v282;
    }
  }
  else if ( v280 )
  {
    if ( v77 )
    {
      v216 = v302;
      v217 = &v301;
      v218 = 0;
      v275 = v106;
      v277 = v105;
      v273 = (_QWORD *)(v105 - 2840);
      while ( 1 )
      {
        v219 = *v217;
        v220 = off_324260;
        if ( !*v217 )
          v218 = 1;
        for ( k = 4; ; k = *((_DWORD *)v220 + 2) )
        {
          if ( v219 == k )
          {
            v222 = (__int64)*v220;
            if ( sub_4F3D0(v257, (__int64)*v220) )
            {
              v223 = sub_4FD50(v273, *(_QWORD *)(v222 + 104));
              v223[1] = v222;
              *((_BYTE *)v223 + 20) = v218;
            }
          }
          v220 += 2;
          if ( &unk_3242F0 == (_UNKNOWN *)v220 )
            break;
        }
        v217 = (int *)v216;
        if ( &v302[4 * (v283 - 1)] == v216 )
          break;
        v216 += 4;
      }
      v106 = v275;
      v105 = v277;
    }
  }
  else
  {
    if ( !v281 )
      __assert_fail("hk_prev", "ssh2transport.c", 0x2DEu, "ssh2_write_kexinit_lists");
    v131 = sub_4FD50((_QWORD *)(v105 - 2840), *(_QWORD *)(v281 + 104));
    v131[1] = v281;
    *((_BYTE *)v131 + 20) = 0;
  }
  if ( v260 )
    sub_4FD50((_QWORD *)(v105 - 2840), (__int64)"null")[1] = 0LL;
  v132 = (_QWORD *)(v105 - 2456);
  v261 = v106;
  v272 = v105;
  do
  {
    v133 = 0;
    v134 = &v305;
    if ( v255 )
    {
      do
      {
        v135 = *(_QWORD *)v134;
        if ( *(_QWORD *)v134 )
        {
          if ( *(_DWORD *)v135 > 0 )
          {
            v136 = *(_QWORD *)(v135 + 8);
            v137 = 0LL;
            do
            {
              v138 = sub_4FD50(v132, *(_QWORD *)(*(_QWORD *)(v136 + 8 * v137) + 64LL));
              v136 = *(_QWORD *)(v135 + 8);
              v139 = *(_QWORD *)(v136 + 8 * v137);
              *((_BYTE *)v138 + 16) = v133;
              v138[1] = v139;
              ++v137;
            }
            while ( (signed int)v137 < *(_DWORD *)v135 );
          }
        }
        else
        {
          v133 = 1;
        }
        v134 = (__int128 *)((char *)v134 + 8);
      }
      while ( v134 != (__int128 *)((char *)&v305 + 8 * (unsigned int)(v255 - 1) + 8) );
    }
    v132 += 48;
  }
  while ( v132 != (_QWORD *)(v244 + 2440) );
  v140 = off_320DE0;
  v141 = v265 & 2;
  if ( v265 & 2 )
    v140 = off_320C60;
  v142 = (_QWORD *)(v272 - 1688);
  v143 = -(v141 < 1);
  v25 = v141 == 0;
  v144 = off_324220;
  v145 = ~v143;
  if ( v25 )
    v144 = off_324240;
  v146 = v144;
  v147 = (signed __int64)&v144[(unsigned int)(v145 + 3) + 1];
  while ( 1 )
  {
    for ( l = (__int64 (__fastcall ***)())v146; ; v140 = *l )
    {
      ++l;
      v149 = sub_4FD50(v142, (__int64)v140[6]);
      v150 = (__int64)*(l - 1);
      *((_BYTE *)v149 + 16) = 0;
      v149[1] = v150;
      if ( (__int64 (__fastcall ***)())v147 == l )
        break;
    }
    v151 = v146;
    do
    {
      v152 = (__int64)(**v151)[7];
      if ( v152 )
      {
        v153 = sub_4FD50(v142, v152);
        v154 = *v151;
        *((_BYTE *)v153 + 16) = 1;
        v153[1] = v154;
      }
      ++v151;
    }
    while ( (__int64 (__fastcall *(**)[4])())v147 != v151 );
    v142 += 48;
    if ( (_QWORD *)(v244 + 3208) == v142 )
      break;
    v140 = (__int64 (__fastcall **)())*v146;
  }
  v155 = (_QWORD *)(v272 - 920);
  do
  {
    v156 = sub_4FD50(v155, *v269);
    v157 = v269[1];
    v156[1] = v269;
    *((_BYTE *)v156 + 16) = 0;
    if ( v157 )
    {
      v158 = sub_4FD50(v155, v157);
      v158[1] = v269;
      *((_BYTE *)v158 + 16) = 1;
    }
    v159 = sub_4FD50(v155, (__int64)"zlib");
    v159[1] = off_3218A0;
    *((_BYTE *)v159 + 16) = 0;
    if ( "zlib@openssh.com" )
    {
      v160 = sub_4FD50(v155, (__int64)"zlib@openssh.com");
      v160[1] = off_3218A0;
      *((_BYTE *)v160 + 16) = 1;
    }
    v161 = v155;
    v155 += 48;
    v162 = sub_4FD50(v161, (__int64)"none");
    *((_BYTE *)v162 + 16) = 0;
    v162[1] = &off_31F160;
  }
  while ( v261 != v155 );
  a3 = 0LL;
  v163 = (__int64 *)(v244 + 904);
  do
  {
    v167 = sub_BC640();
    if ( v267 && *(_QWORD *)(v267 + 16 * a3 + 40) )
    {
      a4 = v163 + 48;
      v164 = v267 + 16 * ((signed int)a3 + 2LL);
      v165 = *(_QWORD *)(v164 + 8);
      v166 = *(_QWORD *)(v164 + 16);
      sub_2EC30((__int64 (**)(void))(v167 + 24));
    }
    else
    {
      a4 = v163 + 48;
      do
      {
        v168 = (const char *)*v163;
        if ( !*v163 )
          break;
        v163 += 3;
        sub_61E60(v167, v168);
      }
      while ( a4 != v163 );
    }
    if ( !(_DWORD)a3 && v247 )
    {
      if ( v248 )
        sub_61E60(v167, "ext-info-s");
      else
        sub_61E60(v167, "ext-info-c");
    }
    ++a3;
    v163 = a4;
    sub_2EF70(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v245 + 32), v167);
  }
  while ( a3 != 8 );
  a5 = (__int64 (__fastcall *(**)[13])())v245;
  v11 = v272;
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v245 + 32), &locale);
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v245 + 32), &locale);
  sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v272 - 3576) + 24LL), 0);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v272 - 3576) + 24LL), 0);
  v169 = (*(__int64 (__fastcall **)(signed __int64, _QWORD))(**(_QWORD **)(v272 + 8) + 24LL))(20LL, 0LL);
  v170 = *(_QWORD *)(v272 - 3576);
  v171 = *(_QWORD *)(v170 + 16);
  v172 = *(_QWORD *)(v170 + 8) + 1LL;
  sub_2EC20((__int64 (**)(void))(v169 + 96));
  sub_614E0(*(_QWORD *)(v272 + 24), (__int64 *)(v169 + 64));
  *(_BYTE *)(v272 - 3720) = 1;
  *(_DWORD *)(v272 - 4128) = 1221;
LABEL_16:
  v15 = (int *)sub_50890(v244, (__int64)a5);
  v16 = v15;
  if ( !v15 )
    goto LABEL_10;
  if ( *v15 != 20 )
  {
    sub_621E0(
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 4LL),
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 8LL),
      *v15);
    v17 = (unsigned int)*v16;
    sub_423C0(
      *(_QWORD *)(v11 + 88),
      (__int64)"Received unexpected packet when expecting KEXINIT, type %d (%s)",
      (__int64)a4,
      (__int64)a5);
    goto LABEL_10;
  }
  a5 = (__int64 (__fastcall *(**)[13])())&s1;
  v44 = 0LL;
  sub_BC590(*(__int64 **)(v11 - 3568), 0LL);
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v11 - 3568) + 24LL), 20);
  v45 = *((_QWORD *)v16 + 7);
  v46 = *((_QWORD *)v16 + 8) - v45;
  v47 = *((_QWORD *)v16 + 6) + v45;
  sub_2EC20((__int64 (**)(void))(*(_QWORD *)(v11 - 3568) + 24LL));
  v264 = *(_QWORD *)(v11 + 88);
  v266 = *(_QWORD *)(v11 - 3448);
  v268 = *(_QWORD *)(v11 - 3456);
  v48 = *(_QWORD *)(v11 - 3552);
  v49 = *(_QWORD *)(v48 + 8);
  v50 = *(_QWORD *)(v48 + 16);
  v51 = *(_QWORD *)(v11 - 3560);
  v294 = v49;
  v52 = *(_QWORD *)(v51 + 16);
  v53 = *(_QWORD *)(v51 + 8);
  v293 = &v289;
  v290 = 0LL;
  v292 = 0;
  v296 = v50;
  v289 = v53;
  v291 = v52;
  v295 = 0LL;
  v297 = 0;
  v298 = &v294;
  sub_2F040((__int64)&v289, 0x11uLL);
  sub_2F040((__int64)v298, 0x11uLL);
  v256 = 1;
  v270 = v11;
  v246 = v244 + 904;
  do
  {
    v253 = v44;
    v11 = 16LL * (signed int)v44;
    v54 = sub_2F1D0((__int64)v293);
    v55 = (__int64)v298;
    *(_QWORD *)((char *)v304 + v11) = v54;
    *(_QWORD *)((char *)v304 + v11 + 8) = v56;
    *(_QWORD *)((char *)&v305 + v11) = sub_2F1D0(v55);
    v57 = (__int64)v293;
    *(_QWORD *)((char *)&v305 + v11 + 8) = v58;
    if ( *(_DWORD *)(v57 + 24) || *((_DWORD *)v298 + 6) )
    {
      sub_423C0(v264, (__int64)"KEXINIT packet was incomplete", v44, (__int64)&s1);
      goto LABEL_10;
    }
    v249 = 1;
    a3 = 16 * v44;
    v284 = _mm_load_si128((const __m128i *)&v304[v44]);
LABEL_75:
    v59 = sub_61EA0(&v284, (__m128i *)v286);
    if ( v59 )
    {
      v285 = _mm_load_si128((const __m128i *)((char *)&v305 + a3));
      while ( 1 )
      {
        if ( !(unsigned __int8)sub_61EA0(&v285, (__m128i *)&s1) )
        {
          v249 = 0;
          goto LABEL_75;
        }
        if ( sub_BD140((const void *)v286[0], v286[1], s1, n) )
          break;
        v59 = 0;
      }
      v98 = v286[0];
      a3 = v286[1];
      v99 = (void **)v246;
      v262 = v44;
      *((_QWORD *)&v301 + v44) = 0LL;
      LODWORD(v44) = 0;
      v100 = v59;
      v11 = v98;
      while ( !*v99 || !(unsigned __int8)sub_BD100((void *)v11, a3, *v99) )
      {
        v44 = (unsigned int)(v44 + 1);
        v99 += 3;
        if ( (_DWORD)v44 == 16 )
          goto LABEL_152;
      }
      v180 = (signed int)v44;
      v44 = v262;
      v181 = v246 + 24 * v180;
      *((_QWORD *)&v301 + v262) = v181;
      if ( !v181 )
      {
LABEL_152:
        sub_BC2F0(a3);
        v101 = off_31F0C0[v253];
        sub_42500(
          v264,
          (__int64)"Selected %s \"%.*s\" does not correspond to any supported algorithm",
          v44,
          (__int64)&s1);
        goto LABEL_10;
      }
      if ( v262 <= 1 )
      {
        v182 = v256;
        if ( !(v100 | (unsigned __int8)v249) )
          v182 = 0;
        v256 = v182;
      }
    }
    else
    {
      v256 = 0;
      *((_QWORD *)&v301 + v44) = 0LL;
    }
    ++v44;
    v246 += 384LL;
  }
  while ( v44 != 8 );
  sub_2F1D0((__int64)v293);
  sub_2F1D0((__int64)v293);
  sub_2F1D0((__int64)v298);
  sub_2F1D0((__int64)v298);
  *(_BYTE *)(v270 - 3227) = (v256 | !sub_2F0C0((__int64)v298)) ^ 1;
  for ( m = 0LL; ; ++m )
  {
    v87 = m;
    if ( m != 4 )
      break;
    if ( *(_QWORD *)v268 && (v240 = *(_QWORD *)(*(_QWORD *)v268 + 96LL)) != 0 )
    {
      v25 = *(_QWORD *)(v240 + 56) == 0LL;
      *(_QWORD *)(v268 + 8) = v240;
      *(_BYTE *)(v268 + 16) = !v25;
    }
    else
    {
      v88 = v303;
      if ( !v303 )
      {
        v87 = 4;
        goto LABEL_329;
      }
      v89 = *(_QWORD *)(v303 + 8);
LABEL_135:
      v94 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)(v268 + 8) = v89;
      *(_BYTE *)(v268 + 16) = v94;
    }
LABEL_124:
    ;
  }
  if ( (_DWORD)m == 5 )
  {
    if ( *(_QWORD *)v266 && (v242 = *(_QWORD *)(*(_QWORD *)v266 + 96LL)) != 0 )
    {
      v25 = *(_QWORD *)(v242 + 56) == 0LL;
      *(_QWORD *)(v266 + 8) = v242;
      *(_BYTE *)(v266 + 16) = !v25;
    }
    else
    {
      v88 = *((_QWORD *)&v301 + m);
      if ( !v88 )
        goto LABEL_329;
      v89 = *(_QWORD *)(v88 + 8);
LABEL_132:
      v93 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)(v266 + 8) = v89;
      *(_BYTE *)(v266 + 16) = v93;
    }
    goto LABEL_124;
  }
  v88 = *((_QWORD *)&v301 + m);
  if ( !v88 )
  {
LABEL_329:
    v11 = v87;
    v234 = *((_QWORD *)&v305 + 2 * v87);
    sub_BC2F0(*((_QWORD *)&v305 + 2 * v87 + 1));
    v235 = off_31F0C0[v11];
    sub_42500(v264, (__int64)"Couldn't agree a %s (available: %.*s)", 8LL, (__int64)&s1);
    goto LABEL_10;
  }
  v89 = *(_QWORD *)(v88 + 8);
  switch ( (_DWORD)m )
  {
    case 1:
      if ( v89 || *(_DWORD *)(*(_QWORD *)(v270 - 3928) + 16LL) == 3 )
      {
        *(_QWORD *)(v270 - 3920) = v89;
        *(_DWORD *)(v270 - 3384) = *(_DWORD *)(v88 + 16);
        *(_BYTE *)(v270 - 3619) = *(_BYTE *)(v88 + 20);
      }
      goto LABEL_124;
    case 2:
      v92 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)v268 = v89;
      *(_BYTE *)(v270 - 3618) = v92;
      goto LABEL_124;
    case 3:
      v91 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)v266 = v89;
      *(_BYTE *)(v270 - 3617) = v91;
      goto LABEL_124;
    case 4:
      goto LABEL_135;
    case 5:
      goto LABEL_132;
    case 6:
      v90 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)(v268 + 24) = v89;
      *(_BYTE *)(v268 + 32) = v90;
      goto LABEL_124;
    case 7:
      v95 = *(_BYTE *)(v88 + 16);
      *(_QWORD *)(v266 + 24) = v89;
      *(_BYTE *)(v266 + 32) = v95;
      goto LABEL_137;
    default:
      *(_QWORD *)(v270 - 3928) = v89;
      *(_BYTE *)(v270 - 3620) = *(_BYTE *)(v88 + 16);
      if ( (_DWORD)m != 7 )
        goto LABEL_124;
LABEL_137:
      *(__m128i *)v286 = _mm_load_si128((const __m128i *)v304);
      while ( (unsigned __int8)sub_61EA0((__m128i *)v286, (__m128i *)&s1) )
      {
        if ( sub_BD140(s1, n, "ext-info-c", 0xAuLL) )
          *(_BYTE *)(v270 - 3234) = 1;
      }
      a6 = _mm_load_si128((const __m128i *)&v306);
      a4 = (__int64 *)off_320B60;
      a3 = 0LL;
      *(__m128i *)v286 = a6;
      break;
  }
LABEL_142:
  while ( (unsigned __int8)sub_61EA0((__m128i *)v286, (__m128i *)&s1) )
  {
    a5 = &off_324270;
    v96 = (__int64 (__fastcall *(*)[13])())off_320B60;
    v97 = 0;
    while ( !(unsigned __int8)sub_BD100(s1, n, (*v96)[13]) )
    {
      if ( ++v97 == 9 )
        goto LABEL_142;
      v96 = *a5;
      a5 += 2;
    }
    *(&v299 + a3++) = v97;
  }
  a2 = (unsigned int)a3;
  v11 = v270;
  *(_DWORD *)(v270 - 28) = 0;
  if ( (_DWORD)a3 )
  {
    v201 = v300;
    v202 = &v299;
    a3 = (signed __int64)&v300[4 * (unsigned int)(a3 - 1)];
    while ( 1 )
    {
      v203 = (__int64 *)*v202;
      a4 = v203;
      v204 = off_324260[2 * (_QWORD)v203];
      if ( v204 != *(__int64 (__fastcall *(**)[13])())(v270 - 3920) )
      {
        a2 = *(unsigned int *)(v270 - 3960);
        if ( !sub_BAFB0(*(const char **)(v270 - 3968), a2, (const char *)(*v204)[14]) )
        {
          v205 = *(signed int *)(v270 - 28);
          *(_DWORD *)(v270 - 28) = v205 + 1;
          *(_DWORD *)(v270 + 4 * v205 - 64) = (_DWORD)a4;
        }
      }
      v202 = (int *)v201;
      if ( (char *)a3 == v201 )
        break;
      v201 += 4;
    }
  }
  if ( *(_BYTE *)(v270 - 3620) )
  {
    a2 = (__int64)"key-exchange algorithm";
    v39 = sub_4FF50(v244, (__int64)"key-exchange algorithm", **(_QWORD **)(v270 - 3928), *(_QWORD *)(v270 - 3928));
    *(_DWORD *)(v270 - 4128) = 1274;
    *(_DWORD *)(v270 - 3232) = v39;
    goto LABEL_61;
  }
LABEL_63:
  if ( !*(_BYTE *)(v11 - 3619) )
  {
LABEL_54:
    if ( *(_BYTE *)(v11 - 3618) )
    {
      a2 = (__int64)&unk_EBF95;
      v29 = sub_4FF50(v244, (__int64)&unk_EBF95, *(_QWORD *)(*(_QWORD *)(v11 - 3496) + 64LL), *(_QWORD *)(v11 - 3496));
      *(_DWORD *)(v11 - 4128) = 1341;
      *(_DWORD *)(v11 - 3232) = v29;
LABEL_37:
      if ( v29 < 0 )
        goto LABEL_10;
      if ( !v29 )
        goto LABEL_351;
    }
    if ( *(_BYTE *)(v11 - 3617) )
    {
      a2 = (__int64)"server-to-client cipher";
      v38 = sub_4FF50(
              v244,
              (__int64)"server-to-client cipher",
              *(_QWORD *)(*(_QWORD *)(v11 - 3536) + 64LL),
              *(_QWORD *)(v11 - 3536));
      *(_DWORD *)(v11 - 4128) = 1352;
      *(_DWORD *)(v11 - 3232) = v38;
LABEL_57:
      if ( v38 < 0 )
        goto LABEL_10;
      if ( !v38 )
      {
LABEL_351:
        sub_42660(*(_QWORD *)(v11 + 88), (__int64)"User aborted at cipher warning", (__int64)a4, (__int64)a5);
        goto LABEL_10;
      }
    }
    if ( *(_BYTE *)(v11 - 3227) )
    {
      *(_DWORD *)(v11 - 4128) = 1364;
LABEL_42:
      if ( !sub_50890(v244, (__int64)a5) )
        goto LABEL_10;
    }
    v30 = (**(__int64 (__fastcall ***)(_QWORD, __int64))(*(_QWORD *)(v11 - 3928) + 24LL))(
            *(_QWORD *)(*(_QWORD *)(v11 - 3928) + 24LL),
            a2);
    v31 = v30;
    if ( v30 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v30 + 8LL))(v30);
    v32 = *(char **)(v11 - 3736);
    v33 = *(void (__fastcall ***)(_QWORD, char *, signed __int64))(v31 + 8);
    *(_QWORD *)(v11 - 3760) = v31;
    sub_2EF40(v33, v32);
    sub_2EF40(
      *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v11 - 3760) + 8LL),
      *(char **)(v11 - 3728));
    sub_2EE80(
      *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v11 - 3760) + 8LL),
      *(char **)(*(_QWORD *)(v11 - 3560) + 8LL),
      *(_QWORD *)(*(_QWORD *)(v11 - 3560) + 16LL));
    sub_2EE80(
      *(void (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(v11 - 3760) + 8LL),
      *(char **)(*(_QWORD *)(v11 - 3552) + 8LL),
      *(_QWORD *)(*(_QWORD *)(v11 - 3552) + 16LL));
    *(_DWORD *)(v11 - 4124) = 0;
LABEL_21:
    LOBYTE(s1) = 0;
    sub_4D3E0(v244, &s1, (__int64)a4, (char *)a5);
    if ( (_BYTE)s1 )
      goto LABEL_10;
    if ( *(_DWORD *)(v11 - 4124) )
    {
      *(_DWORD *)(v11 - 4128) = 1382;
      goto LABEL_10;
    }
    if ( !*(_BYTE *)(v11 - 3235) )
    {
      v236 = v244;
      *(__m128i *)(v11 - 3904) = _mm_loadu_si128((const __m128i *)(v11 - 3352));
      v237 = *(_WORD *)(v244 + 888);
      *(__m128i *)(v236 + 240) = _mm_loadu_si128((const __m128i *)(v236 + 792));
      v238 = _mm_loadu_si128((const __m128i *)(v244 + 808));
      *(_WORD *)(v244 + 336) = v237;
      *(__m128i *)(v244 + 256) = v238;
      *(__m128i *)(v236 + 272) = _mm_loadu_si128((const __m128i *)(v236 + 824));
      *(__m128i *)(v236 + 288) = _mm_loadu_si128((const __m128i *)(v236 + 840));
      *(__m128i *)(v236 + 304) = _mm_loadu_si128((const __m128i *)(v236 + 856));
      *(__m128i *)(v244 + 320) = _mm_loadu_si128((const __m128i *)(v244 + 872));
      v239 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 - 3928) + 24LL) + 40LL);
      *(_DWORD *)(v11 - 3788) = v239;
      if ( (unsigned int)v239 > 0x72 )
        __assert_fail(
          "s->session_id_len <= sizeof(s->session_id)",
          "ssh2transport.c",
          0x572u,
          "ssh2_transport_process_queue");
      *(_BYTE *)(v11 - 3235) = 1;
    }
    v18 = (__int64 *)((*(__int64 (__fastcall **)(signed __int64, void **))(**(_QWORD **)(v11 + 8) + 24LL))(21LL, &s1)
                    + 64);
    sub_614E0(*(_QWORD *)(v11 + 24), v18);
    v19 = *(_QWORD *)(v11 - 3936);
    v20 = *(_QWORD *)(v11 - 3752);
    v21 = *(_QWORD *)(v11 + 8);
    *(_QWORD *)(v20 + 24) = v19;
    *(_BYTE *)(v20 + 17) = 0;
    *(_BYTE *)(v20 + 16) = v19 != 0;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v21 + 16LL))(v21, v18);
    a4 = (__int64 *)sub_BC650();
    a3 = sub_BC650();
    v22 = sub_BC650();
    v23 = *(_QWORD *)(v11 - 3496);
    if ( v23 )
    {
      a5 = (__int64 (__fastcall *(**)[13])())v244;
      sub_4F900(v244, a3, *(__int64 **)(v11 - 3584), v244 + 776, *(_BYTE *)(v11 - 3460) + 65, *(_DWORD *)(v23 + 72));
      sub_4F900(
        v244,
        (__int64)a4,
        *(__int64 **)(v11 - 3584),
        v244 + 776,
        *(_BYTE *)(v11 - 3460) + 67,
        *(_DWORD *)(*(_QWORD *)(v11 - 3496) + 80LL));
    }
    v24 = *(_QWORD *)(v11 - 3488);
    if ( v24 )
    {
      sub_4F900(v244, v22, *(__int64 **)(v11 - 3584), v244 + 776, *(_BYTE *)(v11 - 3460) + 69, *(_DWORD *)(v24 + 68));
      v24 = *(_QWORD *)(v11 - 3488);
    }
    sub_497F0(
      *(__int64 (__fastcall ****)())(v11 + 8),
      *(char **)(v11 - 3496),
      a4[1],
      *(_QWORD *)(a3 + 8),
      v24,
      *(_BYTE *)(v11 - 3480),
      *(_QWORD *)(v22 + 8),
      *(_QWORD *)(v11 - 3472),
      *(unsigned __int8 *)(v11 - 3464));
    sub_BC660((void **)a4);
    sub_BC660((void **)a3);
    sub_BC660((void **)v22);
    if ( !*(_BYTE *)(v11 - 3233) )
    {
      v25 = *(_BYTE *)(v11 - 3234) == 0;
      *(_BYTE *)(v11 - 3233) = 1;
      if ( !v25 )
      {
        v225 = sub_BC640();
        a3 = v225;
        if ( *(_QWORD *)(v11 - 3744) )
        {
          v226 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v225 + 24);
          sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v225 + 24), "server-sig-algs");
          a5 = (__int64 (__fastcall *(**)[13])())sub_BC640();
          v227 = 0LL;
          do
          {
            v228 = off_3249A0[v227++];
            sub_61E60((__int64)a5, (const char *)(*v228)[13]);
          }
          while ( v227 != 9 );
          sub_2EF70(v226, (__int64)a5);
          v229 = (*(__int64 (__fastcall **)(signed __int64, __int64 (__fastcall *(**)[13])()))(**(_QWORD **)(v11 + 8)
                                                                                             + 24LL))(
                   7LL,
                   a5);
          a4 = (__int64 *)(v229 + 96);
          v230 = v229;
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v229 + 96), 1);
          v231 = *(_QWORD *)(a3 + 8);
          v232 = *(_QWORD *)(a3 + 16);
          sub_2EC30((__int64 (**)(void))a4);
          sub_614E0(*(_QWORD *)(v11 + 24), (__int64 *)(v230 + 64));
        }
        sub_BC660((void **)a3);
      }
    }
    sub_61680(*(_QWORD **)(v11 + 24), *(_QWORD **)(v11 + 24), (_QWORD *)(v244 + 72));
    *(_DWORD *)(v11 - 4128) = 1491;
LABEL_31:
    v26 = (int *)sub_50890(v244, (__int64)a5);
    v27 = v26;
    if ( !v26 )
      goto LABEL_10;
    if ( *v26 != 21 )
    {
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 8LL),
        *v26);
      v28 = (unsigned int)*v27;
      sub_423C0(
        *(_QWORD *)(v11 + 88),
        (__int64)"Received unexpected packet when expecting SSH_MSG_NEWKEYS, type %d (%s)",
        (__int64)a4,
        (__int64)a5);
      goto LABEL_10;
    }
    v63 = *(_QWORD *)(v11 - 3936);
    v64 = *(_QWORD *)(v11 - 3752);
    *(_QWORD *)(v64 + 8) = v63;
    *(_BYTE *)(v64 + 1) = 0;
    *(_BYTE *)v64 = v63 != 0;
    a4 = (__int64 *)sub_BC650();
    a3 = sub_BC650();
    v65 = sub_BC650();
    v66 = *(_QWORD *)(v11 - 3536);
    if ( v66 )
    {
      a5 = (__int64 (__fastcall *(**)[13])())v244;
      sub_4F900(v244, a3, *(__int64 **)(v11 - 3584), v244 + 776, *(_BYTE *)(v11 - 3500) + 65, *(_DWORD *)(v66 + 72));
      sub_4F900(
        v244,
        (__int64)a4,
        *(__int64 **)(v11 - 3584),
        v244 + 776,
        *(_BYTE *)(v11 - 3500) + 67,
        *(_DWORD *)(*(_QWORD *)(v11 - 3536) + 80LL));
    }
    v67 = *(_QWORD *)(v11 - 3528);
    if ( v67 )
    {
      sub_4F900(v244, v65, *(__int64 **)(v11 - 3584), v244 + 776, *(_BYTE *)(v11 - 3500) + 69, *(_DWORD *)(v67 + 68));
      v67 = *(_QWORD *)(v11 - 3528);
    }
    sub_49A30(
      *(__int64 (__fastcall ****)())(v11 + 8),
      *(char **)(v11 - 3536),
      a4[1],
      *(_QWORD *)(a3 + 8),
      v67,
      *(_BYTE *)(v11 - 3520),
      *(_QWORD *)(v65 + 8),
      *(_QWORD *)(v11 - 3512),
      *(unsigned __int8 *)(v11 - 3504));
    sub_BC660((void **)a4);
    sub_BC660((void **)a3);
    sub_BC660((void **)v65);
    sub_330F0(*(_QWORD **)(v11 - 3584));
    v68 = *(_QWORD *)(v11 + 80);
    *(_QWORD *)(v11 - 3584) = 0LL;
    (*(void (**)(void))(*(_QWORD *)v68 + 40LL))();
    if ( *(_QWORD *)(v11 - 3696) )
    {
      v69 = sub_BC360((__int64)"%s");
      sub_2D3A0(*(_QWORD *)(v11 + 72), v69, (__int64)a4, (__int64)a5);
      *(_QWORD *)(v11 - 3696) = 0LL;
      goto LABEL_95;
    }
    *(_BYTE *)(v11 - 3720) = 0;
    *(_QWORD *)(v11 - 3704) = sub_B4D20();
    sub_4F500(v11, v244, 0LL);
    if ( *(_BYTE *)(v11 - 3688) )
      goto LABEL_87;
    if ( !*(_QWORD *)(v11 - 16) )
    {
      v60 = (*(__int64 (__fastcall **)(signed __int64, _QWORD))(**(_QWORD **)(v11 + 8) + 24LL))(5LL, 0LL);
      sub_2EF40(
        (void (__fastcall **)(_QWORD, char *, signed __int64))(v60 + 96),
        *(char **)(**(_QWORD **)(v11 - 4120) + 64LL));
      sub_614E0(*(_QWORD *)(v11 + 24), (__int64 *)(v60 + 64));
      *(_DWORD *)(v11 - 4128) = 1579;
LABEL_84:
      v61 = (_DWORD *)sub_50890(v244, (__int64)a5);
      if ( !v61 )
        goto LABEL_10;
      v62 = *(_QWORD *)(v11 - 4120);
      if ( *v61 != 6 )
      {
        v200 = *(_QWORD *)(*(_QWORD *)v62 + 64LL);
        sub_42500(
          *(_QWORD *)(v11 + 88),
          (__int64)"Server refused request to start '%s' protocol",
          (__int64)a4,
          (__int64)a5);
        goto LABEL_10;
      }
      goto LABEL_86;
    }
    *(_DWORD *)(v11 - 4128) = 1589;
LABEL_235:
    v173 = (int *)sub_50890(v244, (__int64)a5);
    v174 = v173;
    if ( !v173 )
      goto LABEL_10;
    if ( *v173 != 5 )
    {
      sub_621E0(
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 4LL),
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 144LL) + 8LL),
        *v173);
      v175 = (unsigned int)*v174;
      sub_423C0(
        *(_QWORD *)(v11 + 88),
        (__int64)"Received unexpected packet when expecting SERVICE_REQUEST, type %d (%s)",
        (__int64)a4,
        (__int64)a5);
      goto LABEL_10;
    }
    v212 = sub_2F1D0((__int64)(v173 + 12));
    a3 = v213;
    v214 = v213;
    if ( !(unsigned __int8)sub_BD100(v212, v213, *(void **)(**(_QWORD **)(v11 - 4120) + 64LL)) )
      goto LABEL_341;
    v215 = (*(__int64 (__fastcall **)(signed __int64, size_t))(**(_QWORD **)(v11 + 8) + 24LL))(6LL, v214);
    sub_2EF40(
      (void (__fastcall **)(_QWORD, char *, signed __int64))(v215 + 96),
      *(char **)(**(_QWORD **)(v11 - 4120) + 64LL));
    sub_614E0(*(_QWORD *)(v11 + 24), (__int64 *)(v215 + 64));
    v62 = *(_QWORD *)(v11 - 4120);
LABEL_86:
    *(_BYTE *)(v11 - 3688) = 1;
    sub_1BE20(v62 + 32);
LABEL_87:
    *(_DWORD *)(v11 - 3944) = 0;
LABEL_88:
    *(_DWORD *)(v11 - 4128) = 1619;
    goto LABEL_10;
  }
  a4 = 0LL;
  a3 = 1LL;
  if ( *(_DWORD *)(v11 - 28) <= 0 )
  {
    v36 = *(_QWORD *)(v11 - 3920);
  }
  else
  {
    do
    {
      v40 = 0;
      a5 = &off_324260[2 * *(signed int *)(v11 + 4 * a3 - 68)];
      do
      {
        v41 = sub_1F0A0(*(__int64 **)(v11 - 3976), 25, v40);
        if ( !v41 )
          break;
        if ( *((_DWORD *)a5 + 2) == v41 )
        {
          if ( a4 )
          {
            v34 = a4;
            a4 = (__int64 *)sub_BC160(
                              (char *)a4,
                              *(double *)a6.m128i_i64,
                              a7,
                              a8,
                              a9,
                              v42,
                              v43,
                              a10,
                              a11,
                              ",",
                              (**a5)[13],
                              0LL);
            sub_2F4D0(v34);
          }
          else
          {
            a4 = (__int64 *)sub_BC120((char *)(**a5)[13]);
          }
          break;
        }
        ++v40;
      }
      while ( v40 != 6 );
      v35 = a3++;
    }
    while ( *(_DWORD *)(v11 - 28) > v35 );
    v36 = *(_QWORD *)(v11 - 3920);
    a2 = *(_QWORD *)(v36 + 104);
    if ( a4 )
    {
      *(_DWORD *)(v11 - 3232) = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *, __int64 (__fastcall *)(__int64, int), __int64))(**(_QWORD **)(v11 + 80) + 80LL))(
                                  *(_QWORD *)(v11 + 80),
                                  a2,
                                  a4,
                                  sub_4F470,
                                  v244);
      sub_2F4D0(a4);
      goto LABEL_51;
    }
  }
  a2 = (__int64)"host key type";
  *(_DWORD *)(v11 - 3232) = sub_4FF50(v244, (__int64)"host key type", *(_QWORD *)(v36 + 104), v36);
LABEL_51:
  *(_DWORD *)(v11 - 4128) = 1330;
LABEL_52:
  v37 = *(_DWORD *)(v11 - 3232);
  if ( v37 >= 0 )
  {
    if ( v37 )
      goto LABEL_54;
    sub_42660(*(_QWORD *)(v11 + 88), (__int64)"User aborted at host key warning", (__int64)a4, (__int64)a5);
  }
LABEL_10:
  while ( 1 )
  {
    v14 = __readfsqword(0x28u);
    result = v14 ^ v307;
    if ( v14 == v307 )
      break;
LABEL_341:
    v241 = *(_QWORD *)(**(_QWORD **)(v11 - 4120) + 64LL);
    sub_BC2F0(a3);
    sub_423C0(
      *(_QWORD *)(v11 + 88),
      (__int64)"Client requested service '%.*s' when we only support '%s'",
      v241,
      (__int64)a5);
  }
  return result;
}

__int64 __fastcall sub_52AF0(__int64 a1)
{
  __int64 v1; // rbp
  __int64 result; // rax

  sub_33730(*(_QWORD *)(*(_QWORD *)(a1 + 368) + 8LL), *(__int64 **)(a1 + 544));
  v1 = *(_QWORD *)(a1 + 368);
  if ( *(_QWORD *)(*(_QWORD *)v1 + 40LL) > 0x72uLL )
    __assert_fail(
      "ssh_hash_alg(s->exhash)->hlen <= sizeof(s->exchange_hash)",
      "ssh2transport.c",
      0x44Du,
      "ssh2transport_finalise_exhash");
  (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)v1 + 24LL))(*(_QWORD *)(a1 + 368), a1 + 776);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 32LL))(v1);
  *(_QWORD *)(a1 + 368) = 0LL;
  return result;
}

signed __int64 __fastcall sub_52B70(__int64 (__fastcall ***a1)())
{
  __int64 v1; // rdx

  if ( *a1 != off_31F100 )
    __assert_fail("ppl->vt == &ssh2_transport_vtable", "ssh2transport.c", 0x7A4u, "ssh2_transport_get_session_id");
  if ( !*((_BYTE *)a1 - 3235) )
    __assert_fail("s->got_session_id", "ssh2transport.c", 0x7A7u, "ssh2_transport_get_session_id");
  v1 = *((signed int *)a1 - 947);
  return (signed __int64)(a1 - 488);
}

_QWORD *__fastcall sub_52BE0(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_31F100 )
    __assert_fail("ppl->vt == &ssh2_transport_vtable", "ssh2transport.c", 0x7AFu, "ssh2_transport_notify_auth_done");
  *(a1 - 494) = 0LL;
  *((_DWORD *)a1 - 986) = 4;
  return sub_1BE20((__int64)(a1 + 4));
}

__int64 sub_52C30()
{
  return 0LL;
}

void nullsub_26()
{
  ;
}

__int64 __fastcall sub_52C50(__int64 a1)
{
  return *(unsigned __int8 *)(a1 - 112);
}

__int64 __fastcall sub_52C60(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 504) + 48LL))();
}

_QWORD *__fastcall sub_52C70(__int64 a1)
{
  _QWORD *result; // rax

  if ( *(_BYTE *)(a1 - 112) )
    result = sub_1BE20(a1 + 32);
  return result;
}

_QWORD *__fastcall sub_52C90(_QWORD *a1, __int64 a2, int a3)
{
  a1[52] = 0LL;
  a1[35] = a2;
  a1[36] = a2;
  a1[37] = a3;
  return sub_1BE20((__int64)(a1 + 69));
}

unsigned __int64 __fastcall sub_52CC0(__int64 a1, __int64 a2)
{
  __int64 (**v2)(void); // rax
  unsigned __int64 result; // rax

  v2 = (__int64 (**)(void))(a2 + 24);
  if ( *(_BYTE *)(a1 + 616) < 0 )
    result = sub_2EC30(v2);
  else
    result = sub_2EF30(
               (void (__fastcall **)(_QWORD, char *, signed __int64))v2,
               *(char **)(a1 + 72),
               *(_QWORD *)(a1 + 80));
  return result;
}

__int64 __fastcall sub_52CF0(__int64 a1, char *a2)
{
  char *v2; // r13
  __int64 v3; // rbx
  signed __int64 v4; // rax
  void (__fastcall **v5)(_QWORD, char *, signed __int64); // rbp
  signed __int64 v6; // r12
  __int64 v7; // rsi
  bool v8; // cf
  bool v9; // zf
  const char *v10; // rdi
  signed __int64 v11; // rcx
  char *v12; // rsi
  __int64 v13; // rax
  __int64 v14; // rax
  void (__fastcall **v15)(_QWORD, char *, signed __int64); // rbp
  __int64 v16; // r12
  __int64 v18; // [rsp+0h] [rbp-58h]
  void *v19; // [rsp+8h] [rbp-50h]
  unsigned __int64 v20; // [rsp+10h] [rbp-48h]
  char *v21; // [rsp+18h] [rbp-40h]
  unsigned __int64 v22; // [rsp+28h] [rbp-30h]

  v2 = a2;
  v3 = a1;
  v22 = __readfsqword(0x28u);
  v4 = sub_BC640();
  v5 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v4 + 24);
  v6 = v4;
  sub_2EF30((void (__fastcall **)(_QWORD, char *, signed __int64))(v4 + 24), *(char **)(a1 + 72), *(_QWORD *)(a1 + 80));
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v5, 50);
  sub_2EF40(v5, *(char **)(a1 + 216));
  sub_2EF40(v5, *(char **)(**(_QWORD **)(a1 + 16) + 64LL));
  sub_2EF40(v5, a2);
  v7 = *(_QWORD *)(a1 + 104);
  v19 = *(void **)v6;
  v18 = *(_QWORD *)(v6 + 16);
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, unsigned __int64 *))(*(_QWORD *)(v7 + 8) + 72LL))(
    *(_QWORD *)(v7 + 8),
    *(_QWORD *)(v7 + 24),
    &v18,
    &v20);
  sub_BC660((void **)v6);
  v10 = "gssapi-with-mic";
  v11 = 16LL;
  v12 = v2;
  do
  {
    if ( !v11 )
      break;
    v8 = (unsigned __int8)*v12 < *v10;
    v9 = *v12++ == *v10++;
    --v11;
  }
  while ( v9 );
  v13 = **(_QWORD **)(v3 + 528);
  if ( (!v8 && !v9) == v8 )
  {
    v16 = (*(__int64 (__fastcall **)(signed __int64, char *))(v13 + 24))(66LL, v12);
    v15 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v16 + 96);
  }
  else
  {
    v14 = (*(__int64 (__fastcall **)(signed __int64, char *))(v13 + 24))(50LL, v12);
    v15 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v14 + 96);
    v16 = v14;
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v14 + 96), *(char **)(v3 + 216));
    sub_2EF40(v15, *(char **)(**(_QWORD **)(v3 + 16) + 64LL));
    sub_2EF40(v15, v2);
  }
  sub_2EE80(v15, v21, v20);
  return v16;
}

_DWORD *__fastcall sub_52E50(__int64 a1)
{
  __int64 v1; // rbp
  __int64 i; // rbx
  _DWORD *result; // rax
  unsigned __int64 v4; // rdx
  __int64 (**v5)(void); // r14
  __int64 v6; // rax
  __int64 (**v7)(void); // rdi
  __int64 v8; // r12

  v1 = a1 + 424;
  for ( i = a1;
        ;
        (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(i + 536) + 48LL))(
          *(_QWORD *)(i + 536),
          *(_QWORD *)(i + 536),
          1LL) )
  {
    result = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(i + 536) + 48LL))(
                         *(_QWORD *)(i + 536),
                         *(_QWORD *)(i + 536),
                         0LL);
    if ( !result || *result != 53 )
      break;
    if ( !*(_BYTE *)(i + 32) )
      continue;
    sub_2F1D0((__int64)(result + 12));
    if ( 0x20000 - sub_BCD00(v1) < v4 )
      v8 = 0x20000 - sub_BCD00(v1);
    if ( *(_BYTE *)(i + 496) )
    {
      v7 = *(__int64 (***)(void))(i + 488);
    }
    else
    {
      v5 = (__int64 (**)(void))(i + 472);
      v6 = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(i + 600) + 128LL))(
             *(_QWORD *)(i + 600),
             i + 472,
             0LL);
      *(_QWORD *)(i + 488) = v6;
      if ( !v6 )
      {
        *(_BYTE *)(i + 496) = 1;
        goto LABEL_15;
      }
      sub_87B00(v6);
      v7 = *(__int64 (***)(void))(i + 488);
      *(_BYTE *)(i + 496) = 1;
    }
    v5 = (__int64 (**)(void))(i + 472);
    if ( v7 )
    {
      sub_2EC30(v7);
      continue;
    }
LABEL_15:
    sub_2EC30(v5);
  }
  return result;
}

__int64 __fastcall sub_52F90(__int64 a1)
{
  sub_52E50(a1);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(*(_QWORD *)(a1 + 536) + 48LL))(
           *(_QWORD *)(a1 + 536),
           *(_QWORD *)(a1 + 536),
           1LL);
}

unsigned __int64 __fastcall sub_52FB0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  void *v3; // rdi
  __int64 v4; // rax
  __int64 v6; // rax
  int v7; // [rsp+Ch] [rbp-2Ch]
  __int64 v8; // [rsp+10h] [rbp-28h]
  unsigned __int64 v9; // [rsp+18h] [rbp-20h]

  v2 = a1;
  v3 = (void *)a1[35];
  v9 = __readfsqword(0x28u);
  sub_2F4D0(v3);
  v2[35] = 0LL;
  v4 = sub_B3E40((_QWORD *)a2, &v8, &v7, (__int64)sub_52C90, (__int64)v2);
  v2[52] = v4;
  if ( !v4 )
  {
    v6 = v8;
    v2[35] = v8;
    v2[36] = v6;
    v2[37] = v7;
    sub_1BE20((__int64)(v2 + 69));
  }
  return __readfsqword(0x28u) ^ v9;
}

void __fastcall sub_53060(__int64 a1)
{
  void *v1; // r13
  __int64 v2; // rbx
  __int64 (***v3)(void); // rdi
  char *v4; // rdi
  unsigned __int64 v5; // rbp
  __int64 v6; // r12
  int *v7; // rdi
  void **v8; // rdi
  __int64 v9; // rdi
  __int64 v10; // rdi

  v1 = (void *)(a1 - 520);
  v2 = a1;
  sub_BCCA0(a1 - 520 + 424);
  v3 = *(__int64 (****)(void))(a1 - 504);
  if ( v3 )
    sub_62630(v3);
  v4 = *(char **)(v2 - 168);
  if ( v4 )
  {
    if ( *(_QWORD *)(v2 - 176) )
    {
      v5 = 0LL;
      do
      {
        v6 = v5++;
        v6 *= 32LL;
        sub_BC660(*(void ***)&v4[v6]);
        sub_BC660(*(void ***)(*(_QWORD *)(v2 - 168) + v6 + 8));
        v4 = *(char **)(v2 - 168);
      }
      while ( *(_QWORD *)(v2 - 176) > v5 );
    }
    sub_2F4D0(v4);
  }
  sub_2F4D0(*(void **)(v2 - 240));
  v7 = *(int **)(v2 - 104);
  if ( v7 )
    sub_B3D10(v7);
  sub_B4E60(*(void ***)(v2 - 496));
  sub_2F4D0(*(void **)(v2 - 464));
  sub_2F4D0(*(void **)(v2 - 296));
  sub_2F4D0(*(void **)(v2 - 480));
  sub_2F4D0(*(void **)(v2 - 472));
  sub_2F4D0(*(void **)(v2 - 248));
  sub_2F4D0(*(void **)(v2 - 256));
  v8 = *(void ***)(v2 - 272);
  if ( v8 )
    sub_BC660(v8);
  sub_BC660(*(void ***)(v2 - 336));
  v9 = *(_QWORD *)(v2 - 32);
  if ( v9 )
    sub_87AE0(v9);
  v10 = *(_QWORD *)(v2 - 16);
  if ( v10 )
    sub_87AE0(v10);
  sub_2F4D0(v1);
}

unsigned __int64 __fastcall sub_531B0(char a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r12
  char *v7; // rbp
  void (__fastcall **v8)(_QWORD, char *, signed __int64); // rbx
  char *v9; // rax
  size_t v10; // rdx
  char *v12; // rax
  size_t v13; // rdx
  char *v14; // r15
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r13
  unsigned __int64 v17; // rdx
  signed __int64 v18; // rax
  signed __int64 v19; // rax
  void (__fastcall **v20)(_QWORD, __int64 *, signed __int64); // r12
  __int64 v21; // r15
  unsigned __int64 v22; // [rsp+0h] [rbp-A8h]
  __int64 v23; // [rsp+10h] [rbp-98h]
  __int64 v24; // [rsp+18h] [rbp-90h]
  __int64 v25; // [rsp+20h] [rbp-88h]
  int v26; // [rsp+28h] [rbp-80h]
  __int64 *v27; // [rsp+30h] [rbp-78h]
  __int64 v28; // [rsp+40h] [rbp-68h]
  __int64 v29; // [rsp+48h] [rbp-60h]
  __int64 v30; // [rsp+50h] [rbp-58h]
  int v31; // [rsp+58h] [rbp-50h]
  __int64 *v32; // [rsp+60h] [rbp-48h]
  unsigned __int64 v33; // [rsp+68h] [rbp-40h]

  v6 = a6;
  v7 = (char *)a5;
  v8 = (void (__fastcall **)(_QWORD, char *, signed __int64))(a2 + 96);
  v33 = __readfsqword(0x28u);
  v23 = a3;
  v25 = a4;
  v24 = 0LL;
  v26 = 0;
  v27 = &v23;
  v28 = a5;
  v30 = a6;
  v29 = 0LL;
  v31 = 0;
  v32 = &v28;
  if ( a1 & 0x10 )
  {
    v9 = sub_2F1D0((__int64)&v23);
    if ( (unsigned __int8)sub_BD100(v9, v10, "ssh-rsa") )
    {
      v12 = sub_2F1D0((__int64)v32);
      if ( (unsigned __int8)sub_BD100(v12, v13, "ssh-rsa") )
      {
        sub_2F1D0((__int64)v27);
        v14 = sub_2F1D0((__int64)v27);
        v16 = v15;
        sub_2F1D0((__int64)v32);
        if ( !*((_DWORD *)v27 + 6) && !*((_DWORD *)v32 + 6) && v16 )
        {
          if ( *v14 )
          {
LABEL_14:
            v22 = v17;
            if ( v17 < v16 )
            {
              v19 = sub_BC640();
              v20 = (void (__fastcall **)(_QWORD, __int64 *, signed __int64))(v19 + 24);
              v21 = v19;
              sub_2EC20((__int64 (**)(void))(v19 + 24));
              sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v20, v16);
              sub_2EC40(v20, v16 - v22, 0);
              sub_2EC30((__int64 (**)(void))v20);
              sub_2EF70(v8, v21);
              return __readfsqword(0x28u) ^ v33;
            }
          }
          else
          {
            v18 = (signed __int64)(v14 + 1);
            while ( --v16 )
            {
              if ( *(_BYTE *)(++v18 - 1) )
                goto LABEL_14;
            }
          }
        }
      }
    }
  }
  sub_2EF30(v8, v7, v6);
  return __readfsqword(0x28u) ^ v33;
}

void __fastcall sub_533A0(_QWORD *a1, int *a2)
{
  __int64 v2; // rbx
  __int64 (**v3)(void); // rbp
  int *v4; // rcx
  int v5; // edx

  v2 = sub_BC640();
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, signed __int64))(*(_QWORD *)*a1 + 136LL))(*a1, 1LL) )
  {
    v4 = a2;
    do
    {
      v5 = *v4;
      ++v4;
    }
    while ( !(~v5 & (v5 - 16843009) & 0x80808080) );
    v3 = (__int64 (**)(void))(v2 + 24);
    sub_2EC30((__int64 (**)(void))(v2 + 24));
  }
  else
  {
    v3 = (__int64 (**)(void))(v2 + 24);
    sub_BC720(v2, (__int64)"-- %s ", a2);
    while ( *(_QWORD *)(v2 + 16) <= 0x4DuLL )
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24), 45);
  }
  sub_2EC30(v3);
  (**(void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD))*a1)(
    *a1,
    1LL,
    *(_QWORD *)(v2 + 8),
    *(_QWORD *)(v2 + 16));
  sub_BC660((void **)v2);
}

unsigned __int64 __usercall sub_534A0@<rax>(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>)
{
  __int64 v3; // r15
  __int64 v4; // rbx
  signed int v5; // eax
  int v6; // eax
  unsigned __int64 result; // rax
  unsigned __int64 v8; // rt1
  int v9; // eax
  __int64 *v10; // rax
  __int64 *v11; // rbp
  const char *v12; // r12
  char *v13; // rax
  char *v14; // rax
  char *v15; // rax
  size_t v16; // rdx
  size_t v17; // r12
  _QWORD *v18; // rbp
  __int64 v19; // rbp
  char *v20; // rax
  char *v21; // rax
  char *v22; // rax
  int v23; // eax
  __int64 v24; // rax
  int v25; // esi
  unsigned int v26; // ebp
  __int64 v27; // rdx
  char *v28; // rax
  __int64 v29; // rsi
  __int64 v30; // rdi
  _DWORD *v31; // rax
  _DWORD *v32; // rbp
  char i; // al
  int *v34; // r14
  __int64 v35; // rbp
  int v36; // edx
  __int64 v37; // r8
  __int64 v38; // rax
  char v39; // dl
  unsigned __int64 v40; // rdx
  bool v41; // cf
  bool v42; // zf
  _BYTE *v43; // rdx
  const char *v44; // rdi
  signed __int64 v45; // rcx
  _BYTE *v46; // rsi
  __int64 v47; // rax
  char *v48; // rsi
  __int64 v49; // rax
  __int64 v50; // rdi
  char *v51; // rax
  __int64 v52; // rdi
  __int64 v53; // rax
  char *v54; // rsi
  __int64 v55; // rsi
  __int64 v56; // rdi
  __int64 *v57; // rax
  void *v58; // rbp
  int *v59; // rax
  int *v60; // rbp
  char *v61; // rax
  int v62; // eax
  __int64 v63; // rsi
  __int64 v64; // rax
  __int64 v65; // rdx
  char *v66; // rsi
  const char *v67; // rdi
  void **v68; // rdi
  unsigned __int64 v69; // rdx
  char *v70; // rsi
  char *v71; // rsi
  __int64 v72; // rax
  char *v73; // rsi
  char *v74; // rax
  __int64 v75; // rdx
  __int64 v76; // rsi
  int *v77; // rax
  char *v78; // rax
  __int64 (__fastcall ***v79)(); // rdi
  signed __int64 v80; // rax
  _BYTE **v81; // rdi
  __int64 v82; // rdx
  __int64 v83; // rax
  __int64 *v84; // rax
  __int64 v85; // rdx
  __int64 v86; // rax
  __int64 v87; // rax
  char *v88; // rsi
  char *v89; // rdx
  char *v90; // r12
  __int64 v91; // rax
  char *v92; // rsi
  __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // rdx
  __int64 v96; // rdx
  _BYTE *v97; // rax
  unsigned int v98; // edx
  unsigned int v99; // er12
  __int64 v100; // rdi
  __int64 *v101; // rax
  __int64 v102; // rax
  __int64 v103; // rdx
  __int64 v104; // rbp
  unsigned int v105; // eax
  signed __int64 v106; // rax
  __int64 *v107; // ST20_8
  int *v108; // rax
  int v109; // eax
  char *v110; // rax
  __int64 v111; // rax
  __int64 v112; // rax
  __int64 v113; // rbp
  unsigned __int64 v114; // r12
  unsigned int v115; // eax
  __int64 v116; // rax
  char *v117; // rsi
  __int64 v118; // rax
  __int64 v119; // rax
  void (__fastcall **v120)(_QWORD, char *, signed __int64); // rbp
  char *v121; // r12
  __int64 v122; // rax
  __int64 v123; // rax
  __int64 v124; // rcx
  signed __int64 v125; // rsi
  int v126; // eax
  int v127; // eax
  __int64 v128; // rdx
  __int64 v129; // rax
  const char *v130; // rdi
  __int64 v131; // rdi
  __int64 *v132; // rax
  const char *v133; // rbp
  const char *v134; // rax
  __int64 v135; // rax
  char *v136; // rsi
  char *v137; // rax
  __int64 v138; // rsi
  __int64 v139; // rdi
  __int64 v140; // r14
  __int64 v141; // rdx
  int v142; // eax
  const char *v143; // rdi
  char *v144; // rsi
  unsigned int v145; // eax
  char v146; // al
  char *v147; // rax
  __int64 v148; // rbp
  __int64 v149; // rax
  char *v150; // rax
  int v151; // ebp
  bool v152; // r12
  char *v153; // rax
  char *v154; // rax
  char *v155; // rbp
  __int64 v156; // rax
  size_t v157; // rax
  _QWORD *v158; // rax
  char *v159; // rax
  __int64 v160; // rdi
  char *v161; // rax
  __int64 v162; // rdi
  char *v163; // rax
  size_t v164; // rcx
  __int64 v165; // rdx
  __int64 v166; // rax
  __int64 v167; // rcx
  int v168; // eax
  unsigned int v169; // eax
  char *v170; // rax
  char *v171; // rax
  __int64 v172; // rdx
  char *v173; // rsi
  _QWORD *v174; // rbp
  __int64 v175; // rax
  void *v176; // r12
  __int64 v177; // rax
  char *v178; // rsi
  signed __int64 v179; // r12
  __int64 v180; // rax
  __int64 v181; // rcx
  signed __int64 v182; // rsi
  signed __int64 v183; // r14
  __int64 v184; // rdi
  const char *v185; // rdi
  __int64 v186; // rdx
  char *v187; // r12
  size_t v188; // rsi
  char *v189; // rax
  __int64 v190; // rdx
  char *v191; // rax
  __int64 v192; // rdx
  signed __int64 v193; // rax
  __int64 v194; // rdi
  char *v195; // rax
  char *v196; // rsi
  char *v197; // rax
  __int64 v198; // rax
  __int64 v199; // rdi
  __int64 v200; // rax
  char *v201; // rax
  void *v202; // rbp
  size_t v203; // rax
  char v204; // al
  _BYTE *v205; // rax
  _BYTE *v206; // rbp
  char *v207; // rax
  __int64 v208; // rsi
  char *v209; // rax
  char *v210; // rax
  char *v211; // rax
  __m128i v212; // xmm0
  __int64 v213; // rax
  __int64 v214; // rsi
  char *v215; // rsi
  __int64 v216; // rax
  char *v217; // rsi
  __int64 v218; // rax
  __int64 v219; // rdx
  __int64 v220; // r14
  char *v221; // rax
  __int64 v222; // rax
  char *v223; // rax
  void *v224; // rbp
  __int64 v225; // rax
  __int64 v226; // r14
  unsigned __int64 v227; // rbp
  __int64 v228; // rdi
  unsigned __int64 v229; // r12
  char *v230; // rax
  __int64 v231; // rax
  __int64 v232; // rdi
  __int64 v233; // rax
  __int64 v234; // rdi
  signed __int64 v235; // rax
  signed __int64 v236; // rbp
  __int64 v237; // rdi
  __int64 (**v238)(void); // rax
  __int64 v239; // r12
  signed __int64 v240; // rax
  __int64 *v241; // rbp
  __int64 v242; // rdi
  __int64 (**v243)(void); // rax
  __int64 v244; // r12
  char v245; // al
  _QWORD *v246; // rdx
  _BYTE *v247; // rax
  _BYTE *v248; // rbp
  char *v249; // rax
  __int64 v250; // rdx
  __int64 v251; // rsi
  char *v252; // rax
  char *v253; // rax
  __int64 v254; // rbx
  __int64 v255; // rbp
  signed __int64 *v256; // r13
  signed __int64 v257; // rax
  __int64 v258; // rdi
  __int64 v259; // r13
  signed __int64 v260; // rax
  __int64 v261; // rdi
  _QWORD *v262; // rbp
  __int64 v263; // rdx
  __int64 v264; // rax
  __int64 v265; // rdx
  __int64 v266; // rax
  char *v267; // r14
  unsigned __int64 v268; // rbp
  __int64 v269; // rax
  char v270; // al
  int v271; // eax
  char *v272; // rax
  __int64 v273; // rax
  __int64 v274; // rax
  unsigned __int64 v275; // rdx
  char *v276; // rsi
  char *v277; // rax
  char v278; // al
  char v279; // cl
  char *v280; // rsi
  char *v281; // rax
  __int64 v282; // [rsp-8h] [rbp-D0h]
  _DWORD *v283; // [rsp+8h] [rbp-C0h]
  char v284; // [rsp+8h] [rbp-C0h]
  __int64 *v285; // [rsp+10h] [rbp-B8h]
  char v286; // [rsp+10h] [rbp-B8h]
  __int64 v287; // [rsp+10h] [rbp-B8h]
  __int128 v288; // [rsp+18h] [rbp-B0h]
  char v289; // [rsp+18h] [rbp-B0h]
  char v290; // [rsp+20h] [rbp-A8h]
  __int64 v291; // [rsp+28h] [rbp-A0h]
  char *v292; // [rsp+40h] [rbp-88h]
  __int64 v293; // [rsp+48h] [rbp-80h]
  void *s1; // [rsp+50h] [rbp-78h]
  size_t n; // [rsp+58h] [rbp-70h]
  __int64 v296; // [rsp+60h] [rbp-68h]
  __int64 v297; // [rsp+68h] [rbp-60h]
  __int64 v298; // [rsp+70h] [rbp-58h]
  int v299; // [rsp+78h] [rbp-50h]
  __int64 *v300; // [rsp+80h] [rbp-48h]
  unsigned __int64 v301; // [rsp+88h] [rbp-40h]

  v3 = a1;
  v4 = a1 - 520;
  v301 = __readfsqword(0x28u);
  sub_52E50(a1 - 520);
  v5 = *(_DWORD *)(a1 - 520);
  if ( v5 == 1086 )
    goto LABEL_103;
  if ( v5 <= 1086 )
  {
    if ( v5 == 512 )
      goto LABEL_51;
    if ( v5 <= 512 )
    {
      switch ( v5 )
      {
        case 327:
          if ( *(_QWORD *)(a1 - 104) )
            goto LABEL_16;
          v128 = *(_QWORD *)(a1 - 232);
          v129 = *(_QWORD *)(a1 - 224);
          *(_QWORD *)(a1 - 208) = 0LL;
          *(_DWORD *)(a1 - 192) = 0;
          *(_QWORD *)(a1 - 184) = v4 + 304;
          *(_QWORD *)(a1 - 216) = v128;
          *(_QWORD *)(a1 - 200) = v129;
          sub_2F150(v4 + 304);
          v130 = "Failed to get reply from Pageant";
          if ( (unsigned __int8)sub_2F080(*(_QWORD *)(v3 - 184)) == 12 )
          {
            v226 = sub_2F150(*(_QWORD *)(v3 - 184));
            v227 = *(_QWORD *)(v3 - 208);
            v228 = *(_QWORD *)(v3 - 184);
            if ( !v226 )
            {
              sub_2F3E0(v228, *(_QWORD *)(v3 - 208));
              *(_QWORD *)(v3 - 176) = 0LL;
              *(_QWORD *)(v3 - 168) = sub_2F450(0LL, 0x20uLL, 0LL);
              a2 = sub_BC360((__int64)"Pageant has %zu SSH-2 keys", 0LL);
              sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
              if ( *(_QWORD *)(v3 - 272) )
                goto LABEL_342;
              goto LABEL_343;
            }
            v229 = 0LL;
            while ( 1 )
            {
              sub_2F1D0(v228);
              sub_2F1D0(*(_QWORD *)(v3 - 184));
              v228 = *(_QWORD *)(v3 - 184);
              if ( *(_DWORD *)(v228 + 24) )
                break;
              if ( v226 == ++v229 )
              {
                sub_2F3E0(v228, v227);
                *(_QWORD *)(v3 - 176) = v226;
                v253 = (char *)sub_2F450(v226, 0x20uLL, 0LL);
                v287 = v4;
                *(_QWORD *)(v3 - 168) = v253;
                v254 = 0LL;
                while ( 1 )
                {
                  v255 = v254++;
                  v255 *= 32LL;
                  v256 = (signed __int64 *)&v253[v255];
                  v257 = sub_BC640();
                  v258 = *(_QWORD *)(v3 - 184);
                  *v256 = v257;
                  sub_2F1D0(v258);
                  sub_2EC30((__int64 (**)(void))(*(_QWORD *)(*(_QWORD *)(v3 - 168) + v255) + 24LL));
                  v259 = *(_QWORD *)(v3 - 168);
                  v260 = sub_BC640();
                  v261 = *(_QWORD *)(v3 - 184);
                  a3 = v255 + v259;
                  *(_QWORD *)(a3 + 8) = v260;
                  sub_2F1D0(v261);
                  sub_2EC30((__int64 (**)(void))(*(_QWORD *)(*(_QWORD *)(v3 - 168) + v255 + 8) + 24LL));
                  v262 = (_QWORD *)(*(_QWORD *)(v3 - 168) + v255);
                  v263 = *(_QWORD *)(*v262 + 16LL);
                  v264 = *(_QWORD *)(*v262 + 8LL);
                  v297 = 0LL;
                  v299 = 0;
                  v300 = &v296;
                  v296 = v264;
                  v298 = v263;
                  v262[2] = sub_2F1D0((__int64)&v296);
                  v262[3] = v265;
                  if ( v254 == v229 )
                    break;
                  v253 = *(char **)(v3 - 168);
                }
                v4 = v287;
                a2 = sub_BC360((__int64)"Pageant has %zu SSH-2 keys", v229);
                sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
                v266 = *(_QWORD *)(v3 - 272);
                if ( v266 )
                {
                  v267 = *(char **)(v266 + 16);
                  a3 = *(_QWORD *)(v266 + 8);
                  v268 = 0LL;
                  while ( 1 )
                  {
                    a2 = v267;
                    v269 = *(_QWORD *)(*(_QWORD *)(v3 - 168) + 32 * v268);
                    if ( sub_BD140((const void *)a3, (__int64)v267, *(const void **)(v269 + 8), *(_QWORD *)(v269 + 16)) )
                      break;
                    if ( ++v268 == v229 )
                      goto LABEL_342;
                  }
                  if ( v229 > v268 )
                  {
                    a2 = sub_BC360((__int64)"Pageant key #%zu matches configured key file", v268);
                    sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
                    *(_QWORD *)(v3 - 160) = v268;
                    *(_QWORD *)(v3 - 152) = v268 + 1;
                    goto LABEL_112;
                  }
LABEL_342:
                  a2 = sub_BC360((__int64)"Configured key file not in Pageant", a2);
                  sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
                  *(_QWORD *)(v3 - 160) = 0LL;
                  *(_QWORD *)(v3 - 152) = 0LL;
                  goto LABEL_112;
                }
LABEL_343:
                *(_QWORD *)(v3 - 160) = 0LL;
                *(_QWORD *)(v3 - 152) = v226;
                goto LABEL_112;
              }
            }
            v130 = "Pageant's response was truncated";
          }
          a2 = sub_BC360((__int64)v130, a2);
          sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
LABEL_112:
          *(_BYTE *)(v3 - 280) = 0;
          goto LABEL_113;
        case 462:
          v127 = *(_DWORD *)(a1 - 424);
          *(_BYTE *)(a1 - 112) = 0;
          goto LABEL_174;
        case 0:
          v79 = *(__int64 (__fastcall ****)())(a1 - 512);
          *(_BYTE *)(v3 - 406) = 0;
          *(_BYTE *)(v3 - 405) = 0;
          *(_QWORD *)(v3 - 272) = 0LL;
          v80 = sub_52B70(v79);
          v81 = *(_BYTE ***)(v3 - 496);
          *(_QWORD *)(v3 - 448) = v80;
          *(_QWORD *)(v3 - 440) = v82;
          if ( !sub_B4E50(v81) )
          {
            v149 = sub_B4E20(*(_QWORD *)(v3 - 496));
            v150 = sub_BC360((__int64)"Reading key file \"%s\"", v149);
            sub_2D3A0(*(_QWORD *)(v3 + 72), v150, a3, v3);
            v151 = sub_7BB00(*(_QWORD *)(v3 - 496));
            v152 = v151 == 3;
            if ( (unsigned int)(v151 - 9) <= 1 || v152 )
            {
              v193 = sub_BC640();
              v194 = *(_QWORD *)(v3 - 496);
              *(_QWORD *)(v3 - 272) = v193;
              if ( (unsigned __int8)sub_7AA40(v194, (_QWORD *)(v4 + 264), v193 + 24, (char ***)(v4 + 272), (char **)&s1) )
              {
                *(_BYTE *)(v3 - 264) = v152;
                if ( v151 != 3 )
                {
                  v195 = sub_BC360((__int64)"Key file contains public key only", v4 + 264);
                  sub_2D3A0(*(_QWORD *)(v3 + 72), v195, a3, v3);
                }
                a2 = 0LL;
                *(_BYTE *)(v3 - 263) = sub_7AC70(*(_QWORD *)(v3 - 496), 0LL);
              }
              else
              {
                v223 = sub_BC360((__int64)"Unable to load key (%s)", s1);
                sub_2D3A0(*(_QWORD *)(v3 + 72), v223, a3, v3);
                v224 = s1;
                v225 = sub_B4E20(*(_QWORD *)(v3 - 496));
                a2 = sub_BC360((__int64)"Unable to load key file \"%s\" (%s)\r\n", v225, v224);
                sub_62710(v3, a2);
                sub_BC660(*(void ***)(v3 - 272));
                *(_QWORD *)(v3 - 272) = 0LL;
              }
            }
            else
            {
              v153 = sub_7BB90(v151);
              v154 = sub_BC360((__int64)"Unable to use this key file (%s)", v153);
              sub_2D3A0(*(_QWORD *)(v3 + 72), v154, a3, v3);
              v155 = sub_7BB90(v151);
              v156 = sub_B4E20(*(_QWORD *)(v3 - 496));
              a2 = sub_BC360((__int64)"Unable to use key file \"%s\" (%s)\r\n", v156, v155);
              sub_62710(v3, a2);
              *(_QWORD *)(v3 - 272) = 0LL;
            }
          }
          if ( *(_BYTE *)(v3 - 487) && (unsigned __int8)sub_B3CE0() )
          {
            v147 = sub_BC360((__int64)"Pageant is running. Requesting keys.", a2);
            sub_2D3A0(*(_QWORD *)(v3 + 72), v147, a3, v3);
            v148 = sub_BC7E0();
            sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v148 + 24), 11);
            a2 = (char *)v148;
            sub_52FB0((_QWORD *)v4, v148);
            sub_BC660((void **)v148);
            *(_DWORD *)(v3 - 520) = 327;
            goto LABEL_16;
          }
          goto LABEL_112;
      }
    }
    else
    {
      if ( v5 == 806 )
      {
        if ( *(_QWORD *)(a1 - 104) )
          goto LABEL_16;
        if ( *(_QWORD *)(a1 - 232) )
        {
          v65 = *(_QWORD *)(a1 - 224);
          v296 = *(_QWORD *)(a1 - 232);
          v297 = 0LL;
          v299 = 0;
          v300 = &v296;
          v298 = v65;
          sub_2F150((__int64)&v296);
          if ( (unsigned __int8)sub_2F080((__int64)v300) == 14 )
          {
            a3 = (__int64)sub_2F1D0((__int64)v300);
            v220 = v219;
            if ( !*((_DWORD *)v300 + 6) )
            {
              v221 = sub_BC360((__int64)"Sending Pageant's response", a2);
              sub_2D3A0(*(_QWORD *)(a1 + 72), v221, a3, a1);
              v222 = *(_QWORD *)(*(_QWORD *)(a1 - 168) + 32LL * *(_QWORD *)(a1 - 160));
              sub_531B0(
                *(_DWORD *)(a1 + 96),
                *(_QWORD *)(a1 - 120),
                *(_QWORD *)(v222 + 8),
                *(_QWORD *)(v222 + 16),
                a3,
                v220);
              a2 = (char *)(*(_QWORD *)(a1 - 120) + 64LL);
              sub_614E0(*(_QWORD *)(a1 + 24), (__int64 *)a2);
              *(_DWORD *)(a1 - 432) = 1;
              *(_BYTE *)(a1 - 111) = 0;
              goto LABEL_96;
            }
          }
          v66 = sub_BC360((__int64)"Pageant refused signing request", a2);
          sub_2D3A0(*(_QWORD *)(a1 + 72), v66, a3, a1);
          v67 = "Pageant failed to provide a signature\r\n";
        }
        else
        {
          v66 = sub_BC360((__int64)"Pageant failed to respond to signing request", a2);
          sub_2D3A0(*(_QWORD *)(a1 + 72), v66, a3, a1);
          v67 = "Pageant failed to respond to signing request\r\n";
        }
        a2 = sub_BC360((__int64)v67, v66);
        sub_62710(v3, a2);
        v68 = *(void ***)(v3 - 120);
        *(_BYTE *)(v3 - 340) = 1;
        sub_61840(v68);
        goto LABEL_96;
      }
      if ( v5 <= 806 )
      {
        if ( v5 == 759 )
          goto LABEL_153;
      }
      else
      {
        if ( v5 == 892 )
          goto LABEL_76;
        if ( v5 == 937 )
        {
          v9 = *(_DWORD *)(a1 - 424);
          *(_BYTE *)(a1 - 112) = 0;
          goto LABEL_25;
        }
      }
    }
    goto LABEL_109;
  }
  if ( v5 == 1462 )
    goto LABEL_44;
  if ( v5 > 1462 )
  {
    if ( v5 == 1558 )
      goto LABEL_81;
    if ( v5 <= 1558 )
    {
      if ( v5 == 1509 )
      {
        v126 = *(_DWORD *)(a1 - 424);
        *(_BYTE *)(a1 - 112) = 0;
        goto LABEL_160;
      }
    }
    else
    {
      if ( v5 == 1628 )
      {
        v23 = *(_DWORD *)(a1 - 424);
        *(_BYTE *)(a1 - 112) = 0;
        goto LABEL_167;
      }
      if ( v5 == 1697 )
        goto LABEL_35;
    }
    goto LABEL_109;
  }
  if ( v5 == 1203 )
  {
LABEL_85:
    v59 = (int *)sub_52F90(v4);
    v60 = v59;
    if ( !v59 )
      goto LABEL_16;
    if ( *v59 == 51 )
    {
LABEL_87:
      v61 = sub_BC360((__int64)"GSSAPI authentication failed", a2);
      sub_2D3A0(*(_QWORD *)(v3 + 72), v61, a3, v3);
      *(_DWORD *)(v3 - 344) = 6;
      goto LABEL_88;
    }
    sub_621E0(
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 144LL) + 4LL),
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 144LL) + 8LL),
      *v59);
    v172 = (unsigned int)*v60;
    a2 = "Received unexpected packet after SSH_MSG_USERAUTH_GSSAPI_ERRTOK (expected SSH_MSG_USERAUTH_FAILURE): type %d (%s)";
    sub_423C0(
      *(_QWORD *)(v3 + 88),
      (__int64)"Received unexpected packet after SSH_MSG_USERAUTH_GSSAPI_ERRTOK (expected SSH_MSG_USERAUTH_FAILURE): type %d (%s)",
      a3,
      v3);
    goto LABEL_16;
  }
  if ( v5 <= 1203 )
  {
    if ( v5 == 1188 )
      goto LABEL_147;
    goto LABEL_109;
  }
  if ( v5 == 1279 )
    goto LABEL_134;
  if ( v5 != 1422 )
  {
LABEL_109:
    *(_DWORD *)(a1 - 520) = 0;
    goto LABEL_16;
  }
  v6 = *(_DWORD *)(a1 - 424);
  *(_BYTE *)(a1 - 112) = 0;
  while ( 1 )
  {
    if ( v6 < 0 )
    {
      while ( sub_BCD00(*(_QWORD *)(v3 + 64)) )
      {
        a2 = *(char **)(v3 - 320);
        v6 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
               *(_QWORD *)(v3 + 80),
               a2,
               *(_QWORD *)(v3 + 64));
        *(_DWORD *)(v3 - 424) = v6;
        if ( v6 >= 0 )
          goto LABEL_39;
      }
      v6 = *(_DWORD *)(v3 - 424);
      if ( v6 < 0 )
      {
        *(_BYTE *)(v3 - 112) = 1;
        *(_DWORD *)(v3 - 520) = 1422;
        goto LABEL_16;
      }
    }
LABEL_39:
    if ( !v6 )
    {
      sub_31C50(*(_QWORD *)(v3 - 320));
      (*(void (__fastcall **)(_QWORD, const char *, signed __int64))(**(_QWORD **)(v3 + 8) + 32LL))(
        *(_QWORD *)(v3 + 8),
        "Unable to authenticate",
        13LL);
      a2 = "User aborted during keyboard-interactive authentication";
      sub_42660(*(_QWORD *)(v3 + 88), (__int64)"User aborted during keyboard-interactive authentication", a3, v3);
      goto LABEL_16;
    }
    v24 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v3 + 8) + 24LL))(61LL, a2);
    v25 = *(_DWORD *)(v3 - 312);
    *(_QWORD *)(v3 - 120) = v24;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v24 + 96), v25);
    if ( *(_DWORD *)(v3 - 312) )
    {
      v26 = 0;
      do
      {
        v27 = v26++;
        v28 = (char *)sub_31C30(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 - 320) + 56LL) + 8 * v27));
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), v28);
      }
      while ( *(_DWORD *)(v3 - 312) > v26 );
    }
    v29 = *(_QWORD *)(v3 - 120);
    v30 = *(_QWORD *)(v3 + 24);
    *(_QWORD *)(v29 + 24) = 256LL;
    a2 = (char *)(v29 + 64);
    sub_614E0(v30, (__int64 *)a2);
    sub_31C50(*(_QWORD *)(v3 - 320));
    *(_DWORD *)(v3 - 520) = 1462;
LABEL_44:
    v31 = (_DWORD *)sub_52F90(v4);
    v32 = v31;
    if ( !v31 )
      goto LABEL_16;
    if ( *v31 != 60 )
      break;
LABEL_137:
    a3 = (__int64)(v32 + 12);
    sub_2F1D0((__int64)(v32 + 12));
    *(_QWORD *)&v288 = v95;
    sub_2F1D0((__int64)(v32 + 12));
    *((_QWORD *)&v288 + 1) = v96;
    sub_2F1D0((__int64)(v32 + 12));
    v97 = sub_31B10();
    *(_QWORD *)(v3 - 320) = v97;
    *v97 = 1;
    v97[1] = 1;
    v98 = sub_2F150((__int64)(v32 + 12));
    *(_DWORD *)(v3 - 312) = v98;
    if ( v98 )
    {
      v99 = 0;
      v283 = v32;
      v291 = v4;
      while ( 1 )
      {
        *(_BYTE *)(v3 - 111) = 0;
        sub_2F1D0(a3);
        v104 = v103;
        LOBYTE(v105) = sub_2F0C0(a3);
        v4 = v105;
        if ( v283[18] )
          break;
        v106 = sub_BC640();
        if ( v104 )
        {
          v100 = *(_QWORD *)(v3 - 16);
          v285 = (__int64 *)v106;
          if ( v100 )
          {
            sub_87AD0(v100, v106 + 24);
            sub_2EC30(*(__int64 (***)(void))(v3 - 16));
            sub_87AD0(*(_QWORD *)(v3 - 16), 0LL);
          }
          else
          {
            sub_2EC30((__int64 (**)(void))(v106 + 24));
          }
          v101 = v285;
        }
        else
        {
          v107 = (__int64 *)v106;
          sub_2EC30((__int64 (**)(void))(v106 + 24));
          v101 = v107;
        }
        ++v99;
        v102 = sub_BC6B0(v101);
        sub_31B70(*(_QWORD **)(v3 - 320), v102, v4);
        v98 = *(_DWORD *)(v3 - 312);
        if ( v98 <= v99 )
        {
          v4 = v291;
          goto LABEL_285;
        }
      }
      a2 = "Server sent truncated SSH_MSG_USERAUTH_INFO_REQUEST packet";
      sub_423C0(*(_QWORD *)(v3 + 88), (__int64)"Server sent truncated SSH_MSG_USERAUTH_INFO_REQUEST packet", a3, v3);
      goto LABEL_16;
    }
LABEL_285:
    if ( !*(_BYTE *)(v3 - 7) && *(_QWORD *)(v3 - 16) )
    {
      if ( v288 == 0 && !v98 )
      {
        v236 = sub_BC640();
        goto LABEL_329;
      }
      sub_533A0((_QWORD *)(v3 + 80), (int *)"Keyboard-interactive authentication prompts from server:");
      v234 = *(_QWORD *)(v3 + 80);
      *(_BYTE *)(v3 - 7) = 1;
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v234 + 136LL))(v234, 0LL);
    }
    v235 = sub_BC640();
    v236 = v235;
    if ( (_QWORD)v288 )
    {
      v237 = *(_QWORD *)(v3 - 16);
      v238 = (__int64 (**)(void))(v235 + 24);
      if ( v237 )
      {
        sub_87AD0(v237, (__int64)v238);
        sub_2EC30(*(__int64 (***)(void))(v3 - 16));
        sub_87AD0(*(_QWORD *)(v3 - 16), 0LL);
      }
      else
      {
        sub_2EC30(v238);
      }
      v239 = *(_QWORD *)(v3 - 320);
      *(_BYTE *)(v239 + 16) = 1;
      goto LABEL_294;
    }
LABEL_329:
    sub_2EC30((__int64 (**)(void))(v236 + 24));
    v239 = *(_QWORD *)(v3 - 320);
    *(_BYTE *)(v239 + 16) = 0;
LABEL_294:
    *(_QWORD *)(v239 + 8) = sub_BC6B0((__int64 *)v236);
    v240 = sub_BC640();
    v241 = (__int64 *)v240;
    if ( *((_QWORD *)&v288 + 1) )
    {
      v242 = *(_QWORD *)(v3 - 16);
      v243 = (__int64 (**)(void))(v240 + 24);
      if ( v242 )
      {
        sub_87AD0(v242, (__int64)v243);
        sub_2EC30(*(__int64 (***)(void))(v3 - 16));
        sub_87AD0(*(_QWORD *)(v3 - 16), 0LL);
      }
      else
      {
        sub_2EC30(v243);
      }
      v244 = *(_QWORD *)(v3 - 320);
      *(_BYTE *)(v244 + 32) = 1;
    }
    else
    {
      v244 = *(_QWORD *)(v3 - 320);
      *(_BYTE *)(v244 + 32) = 0;
    }
    if ( v241[2] )
      *(_QWORD *)(v244 + 24) = sub_BC6B0(v241);
    else
      sub_BC660((void **)v241);
    a2 = *(char **)(v3 - 320);
    v6 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
           *(_QWORD *)(v3 + 80),
           a2,
           0LL);
    *(_DWORD *)(v3 - 424) = v6;
  }
  if ( *(_BYTE *)(v3 - 7) )
  {
    (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v3 + 80) + 136LL))(*(_QWORD *)(v3 + 80), 1LL);
    sub_533A0((_QWORD *)(v3 + 80), (int *)"End of keyboard-interactive prompts from server");
  }
  a2 = (char *)(v32 + 4);
  sub_61540(*(__int64 **)(v3 + 16), (__int64 *)v32 + 2);
  for ( i = *(_BYTE *)(v3 - 340); ; i = *(_BYTE *)(v3 - 340) )
  {
LABEL_49:
    while ( i )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v35 = v4 + 424;
          *(_BYTE *)(v3 - 340) = 0;
          v34 = 0LL;
          if ( sub_BCD00(v4 + 424) )
            goto LABEL_53;
LABEL_191:
          v37 = *(_QWORD *)(v3 + 8);
          v39 = *(_BYTE *)(v3 - 407);
          v38 = *(_QWORD *)(v37 + 144);
LABEL_60:
          *(_DWORD *)(v38 + 8) = 0;
          if ( v39 )
          {
LABEL_61:
            if ( !*(_BYTE *)(v3 - 405) )
            {
              *(_DWORD *)(v3 - 432) = 5;
              *(_BYTE *)(v3 - 405) = 1;
              *(_DWORD *)(v38 + 8) = 3;
              v196 = *(char **)(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 8LL);
              if ( v196 )
              {
                v196 = sub_BC360((__int64)"%s");
                sub_2D3A0(*(_QWORD *)(v3 + 72), v196, a3, v3);
              }
              v197 = sub_BC360((__int64)"Trying gssapi-keyex...", v196);
              sub_2D3A0(*(_QWORD *)(v3 + 72), v197, a3, v3);
              v198 = sub_52CF0(v4, "gssapi-keyex");
              v199 = *(_QWORD *)(v3 + 24);
              *(_QWORD *)(v3 - 120) = v198;
              sub_614E0(v199, (__int64 *)(v198 + 64));
              v200 = *(_QWORD *)(v3 - 416);
              a2 = (char *)(v200 + 24);
              (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v200 + 8) + 64LL))(*(_QWORD *)(v200 + 8), v200 + 24);
              *(_QWORD *)(*(_QWORD *)(v3 - 416) + 24LL) = 0LL;
              i = *(_BYTE *)(v3 - 340);
              goto LABEL_49;
            }
          }
LABEL_62:
          if ( !*(_BYTE *)(v3 - 427) )
            break;
          if ( !*(_BYTE *)(v3 - 419) )
          {
            v40 = *(_QWORD *)(v3 - 160);
            if ( v40 < *(_QWORD *)(v3 - 152) )
            {
              v212 = _mm_loadu_si128((const __m128i *)(32 * v40 + *(_QWORD *)(v3 - 168) + 16));
              *(_DWORD *)(v3 - 128) = 0;
              *(__m128i *)(v3 - 144) = v212;
              v42 = (unsigned __int8)sub_BD100((void *)v212.m128i_i64[0], *(_QWORD *)(v3 - 136), "ssh-rsa") == 0;
              v213 = *(_QWORD *)(v3 + 8);
              if ( !v42 )
              {
                if ( *(_BYTE *)(v213 + 221) )
                {
                  *(_QWORD *)(v3 - 136) = 12LL;
                  *(_DWORD *)(v3 - 128) = 4;
                  *(_QWORD *)(v3 - 144) = "rsa-sha2-512";
                }
                else if ( *(_BYTE *)(v213 + 220) )
                {
                  *(_QWORD *)(v3 - 136) = 12LL;
                  *(_DWORD *)(v3 - 128) = 2;
                  *(_QWORD *)(v3 - 144) = "rsa-sha2-256";
                }
              }
              v214 = *(_QWORD *)(v3 - 160);
              *(_DWORD *)(*(_QWORD *)(v213 + 144) + 8LL) = 1;
              v215 = sub_BC360((__int64)"Trying Pageant key #%zu", v214);
              sub_2D3A0(*(_QWORD *)(v3 + 72), v215, a3, v3);
              v216 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v3 + 8) + 24LL))(50LL, v215);
              v217 = *(char **)(v3 - 304);
              *(_QWORD *)(v3 - 120) = v216;
              sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v216 + 96), v217);
              sub_2EF40(
                (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
              sub_2EF40(
                (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                "publickey");
              sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 0);
              sub_2EF30(
                (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                *(char **)(v3 - 144),
                *(_QWORD *)(v3 - 136));
              v218 = *(_QWORD *)(*(_QWORD *)(v3 - 168) + 32LL * *(_QWORD *)(v3 - 160));
              sub_2EF30(
                (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                *(char **)(v218 + 8),
                *(_QWORD *)(v218 + 16));
              a2 = (char *)(*(_QWORD *)(v3 - 120) + 64LL);
              sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)a2);
              *(_DWORD *)(v3 - 432) = 3;
              *(_DWORD *)(v3 - 520) = 759;
LABEL_153:
              v111 = sub_52F90(v4);
              if ( !v111 )
                goto LABEL_16;
              if ( *(_DWORD *)v111 == 60 )
              {
                v112 = *(_QWORD *)(*(_QWORD *)(v3 - 168) + 32LL * *(_QWORD *)(v3 - 160) + 8);
                v113 = *(_QWORD *)(v112 + 8);
                v114 = *(_QWORD *)(v112 + 16);
                if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v3 + 80) + 144LL))(
                       *(_QWORD *)(v3 + 80),
                       a2) )
                {
                  v115 = sub_BC2F0(v114);
                  a2 = sub_BC360((__int64)"Authenticating with public key \"%.*s\" from agent\r\n", v115, v113);
                  sub_62710(v3, a2);
                }
                v116 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v3 + 8) + 24LL))(50LL, a2);
                v117 = *(char **)(v3 - 304);
                *(_QWORD *)(v3 - 120) = v116;
                sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v116 + 96), v117);
                sub_2EF40(
                  (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                  *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
                sub_2EF40(
                  (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                  "publickey");
                sub_2ED00(
                  (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL),
                  1);
                sub_2EF30(
                  (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                  *(char **)(v3 - 144),
                  *(_QWORD *)(v3 - 136));
                v118 = *(_QWORD *)(*(_QWORD *)(v3 - 168) + 32LL * *(_QWORD *)(v3 - 160));
                sub_2EF30(
                  (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
                  *(char **)(v118 + 8),
                  *(_QWORD *)(v118 + 16));
                v119 = sub_BC7E0();
                v120 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v119 + 24);
                v121 = (char *)v119;
                sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v119 + 24), 13);
                v122 = *(_QWORD *)(*(_QWORD *)(v3 - 168) + 32LL * *(_QWORD *)(v3 - 160));
                sub_2EF30(v120, *(char **)(v122 + 8), *(_QWORD *)(v122 + 16));
                a3 = sub_BC640();
                sub_52CC0(v4, a3);
                v123 = *(_QWORD *)(v3 - 120);
                v124 = *(_QWORD *)(v123 + 8);
                v125 = *(_QWORD *)(v123 + 32) + 5LL;
                sub_2EC20((__int64 (**)(void))(a3 + 24));
                sub_2EF70(v120, a3);
                sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v120, *(_DWORD *)(v3 - 128));
                a2 = v121;
                sub_52FB0((_QWORD *)v4, (__int64)v121);
                sub_BC660((void **)v121);
                *(_DWORD *)(v3 - 520) = 806;
                goto LABEL_16;
              }
              a2 = (char *)(v111 + 16);
              sub_61540(*(__int64 **)(v3 + 16), (__int64 *)(v111 + 16));
LABEL_96:
              v69 = *(_QWORD *)(v3 - 160) + 1LL;
              v41 = v69 < *(_QWORD *)(v3 - 152);
              i = *(_BYTE *)(v3 - 340);
              *(_QWORD *)(v3 - 160) = v69;
              if ( !v41 )
                *(_BYTE *)(v3 - 419) = 1;
              goto LABEL_49;
            }
          }
          if ( !*(_QWORD *)(v3 - 272) )
            break;
          if ( !*(_BYTE *)(v3 - 264) )
            break;
          v41 = 0;
          v42 = *(_BYTE *)(v3 - 420) == 0;
          if ( *(_BYTE *)(v3 - 420) )
            break;
          v43 = *(_BYTE **)(v3 - 256);
          v44 = "ssh-rsa";
          *(_DWORD *)(v38 + 8) = 1;
          v45 = 8LL;
          *(_BYTE *)(v3 - 420) = 1;
          v46 = v43;
          do
          {
            if ( !v45 )
              break;
            v41 = *v46 < (const unsigned __int8)*v44;
            v42 = *v46++ == *v44++;
            --v45;
          }
          while ( v42 );
          if ( (!v41 && !v42) == v41 )
          {
            if ( *(_BYTE *)(v37 + 221) )
            {
              sub_2F4D0(v43);
              v272 = sub_BC120("rsa-sha2-512");
              *(_DWORD *)(v3 - 128) = 4;
              *(_QWORD *)(v3 - 256) = v272;
              v37 = *(_QWORD *)(v3 + 8);
            }
            else if ( *(_BYTE *)(v37 + 220) )
            {
              sub_2F4D0(v43);
              v277 = sub_BC120("rsa-sha2-256");
              *(_DWORD *)(v3 - 128) = 2;
              *(_QWORD *)(v3 - 256) = v277;
              v37 = *(_QWORD *)(v3 + 8);
            }
          }
          v47 = (*(__int64 (__fastcall **)(signed __int64, _BYTE *))(*(_QWORD *)v37 + 24LL))(50LL, v46);
          v48 = *(char **)(v3 - 304);
          *(_QWORD *)(v3 - 120) = v47;
          sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v47 + 96), v48);
          sub_2EF40(
            (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
            *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
          sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), "publickey");
          sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 0);
          sub_2EF40(
            (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
            *(char **)(v3 - 256));
          sub_2EE80(
            (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
            **(char ***)(v3 - 272),
            *(_QWORD *)(*(_QWORD *)(v3 - 272) + 16LL));
          sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)(*(_QWORD *)(v3 - 120) + 64LL));
          a2 = sub_BC360((__int64)"Offered public key");
          sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
          *(_DWORD *)(v3 - 520) = 892;
LABEL_76:
          v49 = sub_52F90(v4);
          if ( !v49 )
            goto LABEL_16;
          if ( *(_DWORD *)v49 != 60 )
          {
            a2 = (char *)(v49 + 16);
            sub_61540(*(__int64 **)(v3 + 16), (__int64 *)(v49 + 16));
            *(_DWORD *)(v3 - 432) = 2;
            i = *(_BYTE *)(v3 - 340);
            goto LABEL_49;
          }
          v173 = sub_BC360((__int64)"Offer of public key accepted", a2);
          sub_2D3A0(*(_QWORD *)(v3 + 72), v173, a3, v3);
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v3 + 80) + 144LL))(
                 *(_QWORD *)(v3 + 80),
                 v173) )
          {
            v210 = sub_BC360((__int64)"Authenticating with public key \"%s\"\r\n", *(_QWORD *)(v3 - 248));
            sub_62710(v3, v210);
          }
          while ( 1 )
          {
            if ( !*(_BYTE *)(v3 - 263) )
            {
              v174 = sub_7A080((char **)&s1, *(_QWORD *)(v3 - 496), 0LL, (unsigned __int8 *)v3);
              if ( v174 == (_QWORD *)&unk_326440 )
                goto LABEL_189;
              goto LABEL_236;
            }
            v205 = sub_31B10();
            *(_QWORD *)(v3 - 320) = v205;
            *v205 = 0;
            v205[1] = 0;
            v206 = v205;
            v207 = sub_BC120("SSH key passphrase");
            v208 = *(_QWORD *)(v3 - 248);
            *((_QWORD *)v206 + 1) = v207;
            v209 = sub_BC360((__int64)"Passphrase for key \"%s\": ", v208);
            sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v209, 0);
            a2 = *(char **)(v3 - 320);
            v9 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                   *(_QWORD *)(v3 + 80),
                   a2,
                   0LL);
            *(_DWORD *)(v3 - 424) = v9;
LABEL_25:
            if ( v9 < 0 )
            {
              while ( sub_BCD00(*(_QWORD *)(v3 + 64)) )
              {
                a2 = *(char **)(v3 - 320);
                v9 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                       *(_QWORD *)(v3 + 80),
                       a2,
                       *(_QWORD *)(v3 + 64));
                *(_DWORD *)(v3 - 424) = v9;
                if ( v9 >= 0 )
                  goto LABEL_217;
              }
              v9 = *(_DWORD *)(v3 - 424);
              if ( v9 < 0 )
              {
                *(_BYTE *)(v3 - 112) = 1;
                *(_DWORD *)(v3 - 520) = 937;
                goto LABEL_16;
              }
            }
LABEL_217:
            v160 = *(_QWORD *)(v3 - 320);
            if ( !v9 )
            {
              sub_31C50(v160);
              (*(void (__fastcall **)(_QWORD, const char *, signed __int64))(**(_QWORD **)(v3 + 8) + 32LL))(
                *(_QWORD *)(v3 + 8),
                "Unable to authenticate",
                13LL);
              a2 = "User aborted at passphrase prompt";
              sub_42660(*(_QWORD *)(v3 + 88), (__int64)"User aborted at passphrase prompt", a3, v3);
              goto LABEL_16;
            }
            v187 = sub_31C40(**(_QWORD **)(v160 + 56));
            sub_31C50(*(_QWORD *)(v3 - 320));
            v174 = sub_7A080((char **)&s1, *(_QWORD *)(v3 - 496), v187, (unsigned __int8 *)v3);
            if ( !v187 )
              break;
            v188 = strlen(v187);
            sub_BD070(v187, v188);
            sub_2F4D0(v187);
            if ( v174 != (_QWORD *)&unk_326440 )
              goto LABEL_236;
            v189 = sub_BC360((__int64)"Wrong passphrase\r\n", v188);
            sub_62710(v3, v189);
          }
          if ( v174 == (_QWORD *)&unk_326440 )
          {
LABEL_189:
            a2 = sub_BC360((__int64)"Unable to load private key (%s)\r\n", s1);
            sub_62710(v3, a2);
            continue;
          }
LABEL_236:
          if ( !v174 )
            goto LABEL_189;
          v175 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v174 + 32LL))(*v174, 0LL);
          v176 = (void *)v175;
          if ( !v175 )
          {
            v177 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v3 + 8) + 24LL))(50LL);
            v178 = *(char **)(v3 - 304);
            *(_QWORD *)(v3 - 120) = v177;
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v177 + 96), v178);
            sub_2EF40(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
              *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), "publickey");
            sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 1);
            sub_2EF40(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
              *(char **)(v3 - 256));
            v179 = sub_BC640();
            (*(void (__fastcall **)(_QWORD, signed __int64))(*(_QWORD *)*v174 + 56LL))(*v174, v179 + 24);
            sub_2EE80(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
              *(char **)v179,
              *(_QWORD *)(v179 + 16));
            a3 = sub_BC640();
            sub_52CC0(v4, a3);
            v180 = *(_QWORD *)(v3 - 120);
            v181 = *(_QWORD *)(v180 + 8);
            v182 = *(_QWORD *)(v180 + 32) + 5LL;
            sub_2EC20((__int64 (**)(void))(a3 + 24));
            v183 = sub_BC640();
            (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, signed __int64))(*(_QWORD *)*v174 + 40LL))(
              *v174,
              *(_QWORD *)(a3 + 8),
              *(_QWORD *)(a3 + 16),
              *(unsigned int *)(v3 - 128),
              v183 + 24);
            sub_BC660((void **)a3);
            sub_531B0(
              *(_DWORD *)(v3 + 96),
              *(_QWORD *)(v3 - 120),
              *(_QWORD *)(v179 + 8),
              *(_QWORD *)(v179 + 16),
              *(_QWORD *)(v183 + 8),
              *(_QWORD *)(v183 + 16));
            sub_BC660((void **)v179);
            sub_BC660((void **)v183);
            sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)(*(_QWORD *)(v3 - 120) + 64LL));
            a2 = sub_BC360((__int64)"Sent public key signature");
            sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
            v184 = *v174;
            *(_DWORD *)(v3 - 432) = 1;
            (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v184 + 24LL))(v184, a2);
            sub_2F4D0((void *)v174[1]);
            sub_2F4D0(v174);
            *(_BYTE *)(v3 - 111) = 0;
            i = *(_BYTE *)(v3 - 340);
            goto LABEL_49;
          }
          a2 = sub_BC360((__int64)"Cannot use this private key (%s)\r\n", v175);
          sub_62710(v3, a2);
          (*(void (__fastcall **)(_QWORD, char *))(*(_QWORD *)*v174 + 24LL))(*v174, a2);
          sub_2F4D0((void *)v174[1]);
          sub_2F4D0(v174);
          sub_2F4D0(v176);
        }
        if ( !*(_BYTE *)(v3 - 408) || *(_BYTE *)(v3 - 406) )
          break;
        *(_DWORD *)(v3 - 432) = 5;
        *(_BYTE *)(v3 - 406) = 1;
        *(_DWORD *)(v38 + 8) = 3;
        v70 = *(char **)(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 8LL);
        if ( v70 )
        {
          v70 = sub_BC360((__int64)"%s");
          sub_2D3A0(*(_QWORD *)(v3 + 72), v70, a3, v3);
        }
        v71 = sub_BC360((__int64)"Trying gssapi-with-mic...", v70);
        sub_2D3A0(*(_QWORD *)(v3 + 72), v71, a3, v3);
        v72 = (*(__int64 (__fastcall **)(signed __int64, char *))(**(_QWORD **)(v3 + 8) + 24LL))(50LL, v71);
        v73 = *(char **)(v3 - 304);
        *(_QWORD *)(v3 - 120) = v72;
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v72 + 96), v73);
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          "gssapi-with-mic");
        v74 = sub_BC360((__int64)"Attempting GSSAPI authentication", "gssapi-with-mic");
        sub_2D3A0(*(_QWORD *)(v3 + 72), v74, a3, v3);
        (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 16LL))(
          *(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL),
          v4 + 128);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 1);
        sub_2ED90(
          (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL),
          *(_DWORD *)(v3 - 392) + 2);
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), 6);
        sub_2ECE0(
          (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          *(_BYTE *)(v3 - 392));
        v75 = *(_QWORD *)(v3 - 392);
        v76 = *(_QWORD *)(v3 - 384);
        sub_2EC20((__int64 (**)(void))(*(_QWORD *)(v3 - 120) + 96LL));
        a2 = (char *)(*(_QWORD *)(v3 - 120) + 64LL);
        sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)a2);
        *(_DWORD *)(v3 - 520) = 1086;
LABEL_103:
        v77 = (int *)sub_52F90(v4);
        v60 = v77;
        if ( !v77 )
          goto LABEL_16;
        if ( *v77 != 60 )
        {
          v78 = sub_BC360((__int64)"GSSAPI authentication request refused", a2);
          sub_2D3A0(*(_QWORD *)(v3 + 72), v78, a3, v3);
          a2 = (char *)(v60 + 4);
          sub_61540(*(__int64 **)(v3 + 16), (__int64 *)v60 + 2);
          i = *(_BYTE *)(v3 - 340);
          goto LABEL_49;
        }
        v163 = sub_2F1D0((__int64)(v77 + 12));
        v164 = *(_QWORD *)(v3 - 392);
        *(_QWORD *)(v3 - 368) = v163;
        *(_QWORD *)(v3 - 376) = v165;
        if ( v164 + 2 != v165 || *v163 != 6 || v164 != v163[1] || memcmp(v163 + 2, *(const void **)(v3 - 384), v164) )
        {
          v185 = "GSSAPI authentication - wrong response from server";
LABEL_240:
          a2 = sub_BC360((__int64)v185);
          sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
          i = *(_BYTE *)(v3 - 340);
          goto LABEL_49;
        }
        v166 = *(_QWORD *)(v3 - 416);
        v167 = *(_QWORD *)(v166 + 8);
        if ( !*(_QWORD *)(v166 + 16) )
        {
          v271 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(v167 + 24))(
                   *(_QWORD *)(v166 + 8),
                   *(_QWORD *)(v3 - 472),
                   v166 + 16);
          *(_DWORD *)(v3 - 344) = v271;
          if ( v271 )
          {
            v185 = "GSSAPI import name failed - Bad service name";
            if ( v271 != 3 )
              v185 = "GSSAPI import name failed";
            goto LABEL_240;
          }
          v166 = *(_QWORD *)(v3 - 416);
          v167 = *(_QWORD *)(v166 + 8);
        }
        v168 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v167 + 56))(v167, v166 + 24, 0LL);
        *(_DWORD *)(v3 - 344) = v168;
        if ( !v168 )
        {
          *(_QWORD *)(v3 - 376) = 0LL;
          *(_QWORD *)(v3 - 368) = 0LL;
          *(_QWORD *)(v3 - 360) = 0LL;
          *(_QWORD *)(v3 - 352) = 0LL;
          while ( 1 )
          {
            v169 = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD, _QWORD, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 40LL))(
                     *(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL),
                     *(_QWORD *)(v3 - 416) + 24LL,
                     *(_QWORD *)(*(_QWORD *)(v3 - 416) + 16LL),
                     *(unsigned __int8 *)(v3 - 453),
                     v4 + 144,
                     v4 + 160,
                     0LL,
                     0LL);
            *(_DWORD *)(v3 - 344) = v169;
            if ( v169 > 1 )
              break;
            a2 = sub_BC360((__int64)"GSSAPI authentication initialised", v282);
            sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
            if ( *(_QWORD *)(v3 - 360) )
            {
              v273 = *(_QWORD *)(v3 + 8);
              *(_BYTE *)(v3 - 111) = 0;
              v274 = (*(__int64 (__fastcall **)(signed __int64, char *))(*(_QWORD *)v273 + 24LL))(61LL, a2);
              v275 = *(_QWORD *)(v3 - 360);
              v276 = *(char **)(v3 - 352);
              *(_QWORD *)(v3 - 120) = v274;
              sub_2EE80((void (__fastcall **)(_QWORD, char *, signed __int64))(v274 + 96), v276, v275);
              sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)(*(_QWORD *)(v3 - 120) + 64LL));
              a2 = (char *)(v4 + 160);
              (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 48LL))(
                *(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL),
                v4 + 160);
            }
            v62 = *(_DWORD *)(v3 - 344);
            if ( v62 != 1 )
              goto LABEL_89;
            *(_DWORD *)(v3 - 520) = 1188;
LABEL_147:
            v108 = (int *)sub_52F90(v4);
            v60 = v108;
            if ( !v108 )
              goto LABEL_16;
            v109 = *v108;
            if ( v109 == 65 )
            {
              *(_DWORD *)(v3 - 520) = 1203;
              goto LABEL_85;
            }
            if ( v109 == 51 )
              goto LABEL_87;
            if ( v109 != 61 )
            {
              v110 = sub_BC360((__int64)"GSSAPI authentication - bad server response", a2);
              sub_2D3A0(*(_QWORD *)(v3 + 72), v110, a3, v3);
              *(_DWORD *)(v3 - 344) = 6;
              goto LABEL_90;
            }
            *(_QWORD *)(v3 - 368) = sub_2F1D0((__int64)(v60 + 12));
            v62 = *(_DWORD *)(v3 - 344);
            *(_QWORD *)(v3 - 376) = v192;
            if ( v62 != 1 )
              goto LABEL_89;
          }
          v170 = sub_BC360((__int64)"GSSAPI authentication initialisation failed", v282);
          sub_2D3A0(*(_QWORD *)(v3 + 72), v170, a3, v3);
          if ( !(*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL) + 96LL))(
                  *(_QWORD *)(*(_QWORD *)(v3 - 416) + 8LL),
                  *(_QWORD *)(*(_QWORD *)(v3 - 416) + 24LL),
                  v4 + 128) )
          {
            v171 = sub_BC360((__int64)"%s", *(_QWORD *)(v3 - 384));
            sub_2D3A0(*(_QWORD *)(v3 + 72), v171, a3, v3);
            sub_2F4D0(*(void **)(v3 - 384));
          }
LABEL_88:
          a2 = (char *)(v60 + 4);
          sub_61540(*(__int64 **)(v3 + 16), (__int64 *)v60 + 2);
          v62 = *(_DWORD *)(v3 - 344);
LABEL_89:
          if ( v62 )
          {
LABEL_90:
            v63 = *(_QWORD *)(v3 - 416);
            v64 = *(_QWORD *)(v63 + 8);
            a2 = (char *)(v63 + 24);
            (*(void (__fastcall **)(__int64, char *))(v64 + 64))(v64, a2);
            i = *(_BYTE *)(v3 - 340);
          }
          else
          {
            v230 = sub_BC360((__int64)"GSSAPI authentication loop finished OK", a2);
            sub_2D3A0(*(_QWORD *)(v3 + 72), v230, a3, v3);
            v231 = sub_52CF0(v4, "gssapi-with-mic");
            v232 = *(_QWORD *)(v3 + 24);
            *(_QWORD *)(v3 - 120) = v231;
            sub_614E0(v232, (__int64 *)(v231 + 64));
            v233 = *(_QWORD *)(v3 - 416);
            a2 = (char *)(v233 + 24);
            (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v233 + 8) + 64LL))(*(_QWORD *)(v233 + 8), v233 + 24);
            i = *(_BYTE *)(v3 - 340);
          }
          goto LABEL_49;
        }
        a2 = sub_BC360((__int64)"GSSAPI authentication failed to get credentials");
        sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
      }
      if ( !*(_BYTE *)(v3 - 425) || *(_BYTE *)(v3 - 328) )
      {
        if ( !*(_BYTE *)(v3 - 426) )
        {
          (*(void (__fastcall **)(__int64, const char *, signed __int64))(*(_QWORD *)v37 + 32LL))(
            v37,
            "No supported authentication methods available",
            14LL);
          a2 = "No supported authentication methods available (server sent: %s)";
          v186 = **(_QWORD **)(v3 - 336);
          sub_42500(
            *(_QWORD *)(v3 + 88),
            (__int64)"No supported authentication methods available (server sent: %s)",
            a3,
            v3);
          goto LABEL_16;
        }
        *(_BYTE *)(v3 - 111) = 0;
        *(_DWORD *)(v38 + 8) = 2;
        v247 = sub_31B10();
        *(_QWORD *)(v3 - 320) = v247;
        *v247 = 1;
        v247[1] = 0;
        v248 = v247;
        v249 = sub_BC120("SSH password");
        v250 = *(_QWORD *)(v3 - 480);
        v251 = *(_QWORD *)(v3 - 304);
        *((_QWORD *)v248 + 1) = v249;
        v252 = sub_BC360((__int64)"%s@%s's password: ", v251, v250);
        sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v252, 0);
        a2 = *(char **)(v3 - 320);
        v126 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                 *(_QWORD *)(v3 + 80),
                 a2,
                 0LL);
        *(_DWORD *)(v3 - 424) = v126;
LABEL_160:
        if ( v126 < 0 )
        {
          while ( sub_BCD00(*(_QWORD *)(v3 + 64)) )
          {
            a2 = *(char **)(v3 - 320);
            v126 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                     *(_QWORD *)(v3 + 80),
                     a2,
                     *(_QWORD *)(v3 + 64));
            *(_DWORD *)(v3 - 424) = v126;
            if ( v126 >= 0 )
              goto LABEL_79;
          }
          v126 = *(_DWORD *)(v3 - 424);
          if ( v126 < 0 )
          {
            *(_BYTE *)(v3 - 112) = 1;
            *(_DWORD *)(v3 - 520) = 1509;
            goto LABEL_16;
          }
        }
LABEL_79:
        v50 = *(_QWORD *)(v3 - 320);
        if ( !v126 )
        {
          sub_31C50(v50);
          (*(void (__fastcall **)(_QWORD, const char *, signed __int64))(**(_QWORD **)(v3 + 8) + 32LL))(
            *(_QWORD *)(v3 + 8),
            "Unable to authenticate",
            13LL);
          a2 = "User aborted during password authentication";
          sub_42660(*(_QWORD *)(v3 + 88), (__int64)"User aborted during password authentication", a3, v3);
          goto LABEL_16;
        }
        v51 = sub_31C40(**(_QWORD **)(v50 + 56));
        v52 = *(_QWORD *)(v3 - 320);
        *(_QWORD *)(v3 - 288) = v51;
        sub_31C50(v52);
        v53 = (*(__int64 (__fastcall **)(signed __int64))(**(_QWORD **)(v3 + 8) + 24LL))(50LL);
        v54 = *(char **)(v3 - 304);
        *(_QWORD *)(v3 - 120) = v53;
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v53 + 96), v54);
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), "password");
        sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 0);
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          *(char **)(v3 - 288));
        v55 = *(_QWORD *)(v3 - 120);
        v56 = *(_QWORD *)(v3 + 24);
        *(_QWORD *)(v55 + 24) = 256LL;
        sub_614E0(v56, (__int64 *)(v55 + 64));
        a2 = sub_BC360((__int64)"Sent password");
        sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
        *(_DWORD *)(v3 - 432) = 4;
        *(_DWORD *)(v3 - 520) = 1558;
LABEL_81:
        v57 = (__int64 *)sub_52F90(v4);
        v11 = v57;
        if ( !v57 )
          goto LABEL_16;
        v12 = "Server requested password change";
        if ( *(_DWORD *)v57 == 60 )
        {
          do
          {
            v13 = sub_BC360((__int64)"%s", v12);
            sub_2D3A0(*(_QWORD *)(v3 + 72), v13, a3, v3);
            v14 = sub_BC360((__int64)"%s\r\n", v12);
            sub_62710(v3, v14);
            v15 = sub_2F1D0((__int64)(v11 + 6));
            v17 = v16;
            a3 = (__int64)v15;
            v18 = sub_31B10();
            *(_QWORD *)(v3 - 320) = v18;
            *(_BYTE *)v18 = 1;
            *((_BYTE *)v18 + 1) = 0;
            v18[1] = sub_BC120(aNew);
            v19 = *(_QWORD *)(v3 - 320);
            *(_QWORD *)(v19 + 24) = sub_BD360((void *)a3, v17);
            *(_BYTE *)(*(_QWORD *)(v3 - 320) + 32LL) = 1;
            v20 = sub_BC120("Current password (blank for previously entered password): ");
            sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v20, 0);
            v21 = sub_BC120("Enter new password: ");
            sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v21, 0);
            v22 = sub_BC120("Confirm new password: ");
            sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v22, 0);
            while ( 1 )
            {
              a2 = *(char **)(v3 - 320);
              v23 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                      *(_QWORD *)(v3 + 80),
                      a2,
                      0LL);
              *(_DWORD *)(v3 - 424) = v23;
LABEL_167:
              if ( v23 < 0 )
              {
                while ( sub_BCD00(*(_QWORD *)(v3 + 64)) )
                {
                  a2 = *(char **)(v3 - 320);
                  v23 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                          *(_QWORD *)(v3 + 80),
                          a2,
                          *(_QWORD *)(v3 + 64));
                  *(_DWORD *)(v3 - 424) = v23;
                  if ( v23 >= 0 )
                    goto LABEL_183;
                }
                v23 = *(_DWORD *)(v3 - 424);
                if ( v23 < 0 )
                {
                  *(_BYTE *)(v3 - 112) = 1;
                  *(_DWORD *)(v3 - 520) = 1628;
                  goto LABEL_16;
                }
              }
LABEL_183:
              v131 = *(_QWORD *)(v3 - 320);
              if ( !v23 )
              {
                sub_31C50(v131);
                v4 = *(_QWORD *)(v3 - 288);
                v157 = strlen(*(const char **)(v3 - 288));
                sub_BD070((void *)v4, v157);
                sub_2F4D0(*(void **)(v3 - 288));
                (*(void (__fastcall **)(_QWORD, const char *, signed __int64))(**(_QWORD **)(v3 + 8) + 32LL))(
                  *(_QWORD *)(v3 + 8),
                  "Unable to authenticate",
                  13LL);
                a2 = "User aborted during password changing";
                sub_42660(*(_QWORD *)(v3 + 88), (__int64)"User aborted during password changing", a3, v3);
                goto LABEL_16;
              }
              v132 = *(__int64 **)(v131 + 56);
              if ( ***(_BYTE ***)(*v132 + 16) )
              {
                v202 = *(void **)(v3 - 288);
                v203 = strlen(*(const char **)(v3 - 288));
                sub_BD070(v202, v203);
                sub_2F4D0(*(void **)(v3 - 288));
                *(_QWORD *)(v3 - 288) = sub_31C40(**(_QWORD **)(*(_QWORD *)(v3 - 320) + 56LL));
                v132 = *(__int64 **)(*(_QWORD *)(v3 - 320) + 56LL);
              }
              v133 = (const char *)sub_31C30(v132[2]);
              v134 = (const char *)sub_31C30(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 - 320) + 56LL) + 8LL));
              if ( !strcmp(v134, v133) )
                break;
              v201 = sub_BC360((__int64)"Passwords do not match\r\n", v133);
              sub_62710(v3, v201);
            }
            v135 = (*(__int64 (__fastcall **)(signed __int64, const char *))(**(_QWORD **)(v3 + 8) + 24LL))(50LL, v133);
            v136 = *(char **)(v3 - 304);
            *(_QWORD *)(v3 - 120) = v135;
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v135 + 96), v136);
            sub_2EF40(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
              *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), "password");
            sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(*(_QWORD *)(v3 - 120) + 96LL), 1);
            sub_2EF40(
              (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
              *(char **)(v3 - 288));
            v137 = (char *)sub_31C30(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 - 320) + 56LL) + 8LL));
            sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), v137);
            sub_31C50(*(_QWORD *)(v3 - 320));
            v138 = *(_QWORD *)(v3 - 120);
            v139 = *(_QWORD *)(v3 + 24);
            *(_QWORD *)(v138 + 24) = 256LL;
            sub_614E0(v139, (__int64 *)(v138 + 64));
            a2 = sub_BC360((__int64)"Sent new password");
            sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
            *(_DWORD *)(v3 - 520) = 1697;
LABEL_35:
            v10 = (__int64 *)sub_52F90(v4);
            v11 = v10;
            if ( !v10 )
              goto LABEL_16;
            v12 = "Server rejected new password";
          }
          while ( *(_DWORD *)v10 == 60 );
        }
        sub_61540(*(__int64 **)(v3 + 16), v11 + 2);
        v58 = *(void **)(v3 - 288);
        a2 = (char *)strlen(*(const char **)(v3 - 288));
        sub_BD070(v58, (size_t)a2);
        sub_2F4D0(*(void **)(v3 - 288));
        i = *(_BYTE *)(v3 - 340);
      }
      else
      {
        *(_DWORD *)(v3 - 432) = 6;
        *(_DWORD *)(v38 + 8) = 4;
        v91 = (*(__int64 (__fastcall **)(signed __int64, char *))(*(_QWORD *)v37 + 24LL))(50LL, a2);
        v92 = *(char **)(v3 - 304);
        *(_QWORD *)(v3 - 120) = v91;
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v91 + 96), v92);
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
        sub_2EF40(
          (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
          "keyboard-interactive");
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), &locale);
        sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), &locale);
        sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)(*(_QWORD *)(v3 - 120) + 64LL));
        a2 = sub_BC360((__int64)"Attempting keyboard-interactive authentication");
        sub_2D3A0(*(_QWORD *)(v3 + 72), a2, a3, v3);
        if ( !*(_BYTE *)(v3 - 8) )
        {
          a2 = 0LL;
          v93 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(**(_QWORD **)(v3 + 80) + 128LL))(
                  *(_QWORD *)(v3 + 80),
                  0LL,
                  1LL);
          *(_QWORD *)(v3 - 16) = v93;
          if ( v93 )
            sub_87B00(v93);
          *(_BYTE *)(v3 - 8) = 1;
        }
        *(_DWORD *)(v3 - 520) = 1279;
LABEL_134:
        v94 = sub_52F90(v4);
        v32 = (_DWORD *)v94;
        if ( !v94 )
          goto LABEL_16;
        if ( *(_DWORD *)v94 == 60 )
        {
          *(_BYTE *)(v3 - 7) = 0;
          goto LABEL_137;
        }
        a2 = (char *)(v94 + 16);
        sub_61540(*(__int64 **)(v3 + 16), (__int64 *)(v94 + 16));
        *(_DWORD *)(v3 - 432) = 7;
        *(_BYTE *)(v3 - 328) = 1;
        i = *(_BYTE *)(v3 - 340);
      }
    }
    *(_DWORD *)(v3 - 520) = 512;
LABEL_51:
    v34 = (int *)sub_52F90(v4);
    if ( !v34 )
      goto LABEL_16;
    v35 = v4 + 424;
    if ( sub_BCD00(v4 + 424) )
    {
LABEL_53:
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v3 + 80) + 144LL))(
             *(_QWORD *)(v3 + 80),
             a2)
        || (*(unsigned __int8 (**)(void))(**(_QWORD **)(v3 + 80) + 152LL))() )
      {
        if ( *(_QWORD *)(v3 - 32) )
        {
          sub_533A0((_QWORD *)(v3 + 80), (int *)"Pre-authentication banner message from server:");
          a2 = 0LL;
          (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 80) + 136LL))(*(_QWORD *)(v3 + 80), 0LL);
        }
        a3 = 0LL;
        while ( sub_BCD00(v35) )
        {
          a3 = sub_BCF00(v35);
          v90 = v89;
          (***(void (__fastcall ****)(_QWORD, signed __int64, __int64, char *))(v3 + 80))(
            *(_QWORD *)(v3 + 80),
            1LL,
            a3,
            v89);
          a2 = v90;
          LOBYTE(a3) = v90[a3 - 1] != 10;
          sub_BCE20(v35, (unsigned __int64)v90);
        }
        sub_BCCA0(v35);
        if ( (_BYTE)a3 )
        {
          a2 = (_BYTE *)(&::n + 1);
          (***(void (__fastcall ****)(_QWORD, signed __int64, char *, signed __int64))(v3 + 80))(
            *(_QWORD *)(v3 + 80),
            1LL,
            "\r\n",
            2LL);
        }
        if ( *(_QWORD *)(v3 - 32) )
        {
          (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(v3 + 80) + 136LL))(*(_QWORD *)(v3 + 80), 1LL);
          a2 = "End of banner message from server";
          sub_533A0((_QWORD *)(v3 + 80), (int *)"End of banner message from server");
        }
      }
      if ( v34 )
        goto LABEL_56;
      goto LABEL_191;
    }
LABEL_56:
    v36 = *v34;
    if ( *v34 == 52 )
    {
      v191 = sub_BC360((__int64)"Access granted", a2);
      sub_2D3A0(*(_QWORD *)(v3 + 72), v191, a3, v3);
      if ( *(_BYTE *)(v3 - 486) && *(_BYTE *)(v3 - 111) )
      {
        a2 = "Authentication was trivial! Abandoning session as specified in configuration.";
        sub_423C0(
          *(_QWORD *)(v3 + 88),
          (__int64)"Authentication was trivial! Abandoning session as specified in configuration.",
          a3,
          v3);
      }
      else
      {
        sub_52BE0(*(__int64 (__fastcall ****)())(v3 - 512));
        a2 = *(char **)(v3 - 504);
        *(_QWORD *)(v3 - 504) = 0LL;
        sub_626A0(v3, a2);
      }
      goto LABEL_16;
    }
    if ( v36 != 51 )
      break;
    v140 = (__int64)(v34 + 12);
    v292 = sub_2F1D0(v140);
    v293 = v141;
    if ( sub_2F0C0(v140) )
    {
      a2 = sub_BC360((__int64)"Further authentication required\r\n", a2);
      sub_62710(v3, a2);
      v143 = "Further authentication required";
      goto LABEL_270;
    }
    v142 = *(_DWORD *)(v3 - 432);
    if ( !v142 )
      goto LABEL_201;
    if ( (unsigned int)(v142 - 2) <= 1 )
    {
      if ( v142 != 2 )
        goto LABEL_269;
      goto LABEL_353;
    }
    if ( v142 == 1 )
    {
      a2 = sub_BC360((__int64)"Server refused public-key signature despite accepting key!\r\n", a2);
      sub_62710(v3, a2);
      v143 = "Server refused public-key signature despite accepting key!";
      goto LABEL_270;
    }
    v143 = "Server refused keyboard-interactive authentication";
    switch ( v142 )
    {
      case 7:
        goto LABEL_270;
      case 5:
        goto LABEL_201;
      case 6:
        v280 = sub_BC360((__int64)"Keyboard-interactive authentication failed", a2);
        sub_2D3A0(*(_QWORD *)(v3 + 72), v280, a3, v3);
        v281 = sub_BC360((__int64)"Access denied\r\n", v280);
        sub_62710(v3, v281);
LABEL_201:
        a3 = 0LL;
        sub_BC590(*(__int64 **)(v3 - 336), 0LL);
        sub_2EC30((__int64 (**)(void))(*(_QWORD *)(v3 - 336) + 24LL));
        v289 = 0;
        v290 = 0;
        v286 = 0;
        v284 = 0;
        while ( 1 )
        {
          a2 = (char *)&s1;
          if ( !(unsigned __int8)sub_61EA0((__m128i *)&v292, (__m128i *)&s1) )
            break;
          v145 = sub_BD100(s1, n, "publickey");
          if ( (_BYTE)v145 )
          {
            a3 = v145;
          }
          else
          {
            v204 = sub_BD100(s1, n, "password");
            if ( v204 )
            {
              v284 = v204;
            }
            else
            {
              v245 = sub_BD100(s1, n, "keyboard-interactive");
              if ( v245 )
              {
                v286 = v245;
              }
              else
              {
                v270 = sub_BD100(s1, n, "gssapi-with-mic");
                if ( v270 )
                {
                  v290 = v270;
                }
                else
                {
                  v278 = sub_BD100(s1, n, "gssapi-keyex");
                  v279 = v289;
                  if ( v278 )
                    v279 = v278;
                  v289 = v279;
                }
              }
            }
          }
        }
        *(_BYTE *)(v3 - 427) = a3;
        *(_BYTE *)(v3 - 426) = v284;
        *(_BYTE *)(v3 - 425) = *(_BYTE *)(v3 - 456) & v286;
        v146 = *(_BYTE *)(v3 - 454) & v289;
        if ( *(_BYTE *)(v3 - 455) && v290 )
        {
          v246 = *(_QWORD **)(v3 - 416);
          if ( *(_DWORD *)(*v246 + 8LL) <= 0 )
          {
            *(_BYTE *)(v3 - 408) = 0;
LABEL_208:
            v37 = *(_QWORD *)(v3 + 8);
            *(_BYTE *)(v3 - 407) = 0;
            v38 = *(_QWORD *)(v37 + 144);
            *(_DWORD *)(v38 + 8) = 0;
            goto LABEL_62;
          }
          *(_BYTE *)(v3 - 408) = 1;
          if ( !v146 )
            goto LABEL_208;
        }
        else
        {
          *(_BYTE *)(v3 - 408) = 0;
          if ( !v146 )
            goto LABEL_208;
          v246 = *(_QWORD **)(v3 - 416);
          if ( *(_DWORD *)(*v246 + 8LL) <= 0 )
            goto LABEL_208;
        }
        if ( !v246[3] )
          goto LABEL_208;
        v37 = *(_QWORD *)(v3 + 8);
        *(_BYTE *)(v3 - 407) = 1;
        v38 = *(_QWORD *)(v37 + 144);
        *(_DWORD *)(v38 + 8) = 0;
        goto LABEL_61;
    }
    if ( v142 != 4 )
      __assert_fail("s->type == AUTH_TYPE_PASSWORD", "ssh2userauth.c", 0x27Cu, "ssh2_userauth_process_queue");
    v144 = sub_BC360((__int64)"Password authentication failed", a2);
    sub_2D3A0(*(_QWORD *)(v3 + 72), v144, a3, v3);
    a2 = sub_BC360((__int64)"Access denied\r\n", v144);
    sub_62710(v3, a2);
    if ( !*(_BYTE *)(v3 - 485) )
      goto LABEL_201;
LABEL_113:
    v83 = *(_QWORD *)(v3 - 464);
    *(_QWORD *)(v3 - 304) = v83;
    if ( v83 )
    {
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(v3 + 80) + 144LL))(
             *(_QWORD *)(v3 + 80),
             a2)
        || (*(unsigned __int8 (**)(void))(**(_QWORD **)(v3 + 80) + 152LL))() )
      {
        a2 = sub_BC360((__int64)"Using username \"%s\".\r\n", *(_QWORD *)(v3 - 304));
        sub_62710(v3, a2);
      }
    }
    else
    {
      v158 = sub_31B10();
      *(_QWORD *)(v3 - 320) = v158;
      *(_BYTE *)v158 = 1;
      *((_BYTE *)v158 + 1) = 0;
      v158[1] = sub_BC120("SSH login name");
      v159 = sub_BC120("login as: ");
      sub_31B70(*(_QWORD **)(v3 - 320), (__int64)v159, 1);
      a2 = *(char **)(v3 - 320);
      v127 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
               *(_QWORD *)(v3 + 80),
               a2,
               0LL);
      *(_DWORD *)(v3 - 424) = v127;
LABEL_174:
      if ( v127 < 0 )
      {
        while ( sub_BCD00(*(_QWORD *)(v3 + 64)) )
        {
          a2 = *(char **)(v3 - 320);
          v127 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v3 + 80) + 16LL))(
                   *(_QWORD *)(v3 + 80),
                   a2,
                   *(_QWORD *)(v3 + 64));
          *(_DWORD *)(v3 - 424) = v127;
          if ( v127 >= 0 )
            goto LABEL_219;
        }
        v127 = *(_DWORD *)(v3 - 424);
        if ( v127 < 0 )
        {
          *(_BYTE *)(v3 - 112) = 1;
          *(_DWORD *)(v3 - 520) = 462;
          goto LABEL_16;
        }
      }
LABEL_219:
      if ( !v127 )
      {
        sub_31C50(*(_QWORD *)(v3 - 320));
        a2 = "No username provided";
        sub_42660(*(_QWORD *)(v3 + 88), (__int64)"No username provided", a3, v3);
        goto LABEL_16;
      }
      sub_2F4D0(*(void **)(v3 - 296));
      v161 = sub_31C40(**(_QWORD **)(*(_QWORD *)(v3 - 320) + 56LL));
      v162 = *(_QWORD *)(v3 - 320);
      *(_QWORD *)(v3 - 296) = v161;
      *(_QWORD *)(v3 - 304) = v161;
      sub_31C50(v162);
    }
    v84 = *(__int64 **)(v3 + 8);
    *(_BYTE *)(v3 - 280) = 1;
    v85 = v84[18];
    v86 = *v84;
    *(_DWORD *)(v85 + 8) = 0;
    v87 = (*(__int64 (__fastcall **)(signed __int64, char *))(v86 + 24))(50LL, a2);
    v88 = *(char **)(v3 - 304);
    *(_QWORD *)(v3 - 120) = v87;
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v87 + 96), v88);
    sub_2EF40(
      (void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL),
      *(char **)(**(_QWORD **)(v3 - 504) + 64LL));
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v3 - 120) + 96LL), "none");
    a2 = (char *)(*(_QWORD *)(v3 - 120) + 64LL);
    sub_614E0(*(_QWORD *)(v3 + 24), (__int64 *)a2);
    *(_DWORD *)(v3 - 432) = 0;
    *(_BYTE *)(v3 - 420) = 0;
    *(_BYTE *)(v3 - 328) = 0;
    *(_BYTE *)(v3 - 419) = 0;
  }
  v37 = *(_QWORD *)(v3 + 8);
  v38 = *(_QWORD *)(v37 + 144);
  if ( *(_DWORD *)(v3 - 432) == 5 )
  {
    v39 = *(_BYTE *)(v3 - 407);
    goto LABEL_60;
  }
  sub_621E0(*(_DWORD *)(v38 + 4), *(_DWORD *)(v38 + 8), v36);
  v190 = (unsigned int)*v34;
  a2 = "Received unexpected packet in response to authentication request, type %d (%s)";
  sub_423C0(
    *(_QWORD *)(v3 + 88),
    (__int64)"Received unexpected packet in response to authentication request, type %d (%s)",
    a3,
    v3);
LABEL_16:
  v8 = __readfsqword(0x28u);
  result = v8 ^ v301;
  if ( v8 != v301 )
  {
LABEL_353:
    a2 = sub_BC360((__int64)"Server refused our key\r\n", a2);
    sub_62710(v3, a2);
LABEL_269:
    v143 = "Server refused our key";
LABEL_270:
    v211 = sub_BC360((__int64)v143, a2);
    sub_2D3A0(*(_QWORD *)(v3 + 72), v211, a3, v3);
    goto LABEL_201;
  }
  return result;
}

_QWORD *__fastcall sub_56370(__int64 a1, char *a2, char *a3, __int64 a4, char a5, char a6, char a7, char *a8, char a9, char a10, char a11, char a12, char a13, __int64 a14)
{
  char *v14; // ST08_8
  char v15; // ST24_1
  char v16; // ST20_1
  char **v17; // ST10_8
  _QWORD *v18; // rax
  _QWORD *v19; // rbx

  v14 = a3;
  v15 = a5;
  v16 = a6;
  v17 = (char **)a4;
  v18 = sub_2F450(1uLL, 0x270uLL, 0LL);
  v19 = v18;
  *v18 = 0LL;
  v18[77] = 0LL;
  memset(
    (void *)((unsigned __int64)(v18 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v18 - (((_DWORD)v18 + 8) & 0xFFFFFFF8) + 624) >> 3));
  v18[65] = off_324300;
  v18[2] = a1;
  v18[5] = sub_BC120(a2);
  v19[6] = sub_BC120(v14);
  v19[3] = sub_B4E10(v17);
  *((_BYTE *)v19 + 32) = v15;
  *((_BYTE *)v19 + 33) = v16;
  *((_BYTE *)v19 + 34) = a7;
  v19[7] = sub_BC120(a8);
  *((_BYTE *)v19 + 67) = a13;
  *((_BYTE *)v19 + 35) = a9;
  *((_BYTE *)v19 + 64) = a10;
  *((_BYTE *)v19 + 65) = a11;
  *((_BYTE *)v19 + 66) = a12;
  v19[13] = a14;
  v19[23] = sub_BC640();
  *((_BYTE *)v19 + 409) = 1;
  sub_BCC70(v19 + 53);
  sub_2F430(v19 + 58, (__int64)(v19 + 53));
  return v19 + 65;
}

void __fastcall sub_564E0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 512) = a2;
}

signed __int64 __fastcall sub_564F0(__int64 a1, unsigned __int64 *a2)
{
  signed __int64 result; // rax

  *(_QWORD *)(a1 - 88) = _byteswap_uint64(a2[1]);
  *(_QWORD *)(a1 - 80) = _byteswap_uint64(*a2);
  result = a1 - 8;
  *(_QWORD *)(a1 - 8) = a1 - 8;
  return result;
}

bool sub_56510()
{
  _RAX = 1LL;
  __asm { cpuid }
  return (_RCX & 0x2080000) == 34078720;
}

__int64 __fastcall sub_56530(__int64 a1)
{
  __int64 (***v1)(void); // rsi
  __int64 (**v2)(void); // rdi
  __int64 result; // rax
  bool v4; // al
  __int64 (**v5)(void); // rdi

  v1 = *(__int64 (****)(void))(a1 + 104);
  if ( byte_326199 )
  {
    v2 = v1[1];
    if ( !byte_326198 )
      v2 = *v1;
    result = (*v2)();
  }
  else
  {
    v4 = sub_56510();
    v5 = v1[1];
    if ( !v4 )
      v5 = *v1;
    byte_326198 = v4;
    byte_326199 = 1;
    result = (*v5)();
  }
  return result;
}

void __fastcall sub_56580(__int64 a1, const __m128i *a2)
{
  *(__m128i *)(a1 - 24) = _mm_loadu_si128(a2);
}

void __fastcall sub_56590(__int64 a1, const __m128i *a2)
{
  *(__m128i *)(a1 - 88) = _mm_loadu_si128(a2);
}

void __fastcall sub_565A0(__int64 a1)
{
  sub_BD070((void *)(a1 - 1296), 0x518uLL);
  sub_2F4D0((void *)(a1 - 1296));
}

void __fastcall sub_565C0(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 - 8);
  sub_BD070((void *)(a1 - 504), 0x200uLL);
  sub_2F4D0(v1);
}

char *__fastcall sub_565E0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x518uLL, 0LL);
  v1[162] = a1;
  return (char *)(v1 + 162);
}

unsigned __int64 __fastcall sub_56610(__int64 a1)
{
  char v1; // al
  void *v2; // rax
  unsigned __int64 v3; // rdx

  v1 = byte_326198;
  if ( !byte_326199 )
  {
    v1 = sub_56510();
    byte_326199 = 1;
    byte_326198 = v1;
  }
  if ( !v1 )
    return 0LL;
  v2 = sub_2F450(0x20FuLL, 1uLL, 0LL);
  v3 = ((unsigned __int64)v2 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  *(_QWORD *)(v3 + 496) = v2;
  *(_QWORD *)(v3 + 504) = a1;
  return v3 + 504;
}

void __fastcall sub_56680(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v17; // xmm0

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      v5 = _mm_loadu_si128((const __m128i *)(a2 - 16));
      _XMM0 = _mm_xor_si128(_mm_load_si128((const __m128i *)(_RDI - 264)), v5);
      __asm
      {
        aesdec  xmm0, xmmword ptr [rdi-0F8h]
        aesdec  xmm0, xmmword ptr [rdi-0E8h]
        aesdec  xmm0, xmmword ptr [rdi-0D8h]
        aesdec  xmm0, xmmword ptr [rdi-0C8h]
        aesdec  xmm0, xmmword ptr [rdi-0B8h]
        aesdec  xmm0, xmmword ptr [rdi-0A8h]
        aesdec  xmm0, xmmword ptr [rdi-98h]
        aesdec  xmm0, xmmword ptr [rdi-88h]
        aesdec  xmm0, xmmword ptr [rdi-78h]
        aesdeclast xmm0, xmmword ptr [rdi-68h]
      }
      v17 = _mm_xor_si128(_XMM0, v4);
      v4 = v5;
      *(__m128i *)(a2 - 16) = v17;
      *(__m128i *)(_RDI - 24) = v5;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56720(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v19; // xmm0

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      v5 = _mm_loadu_si128((const __m128i *)(a2 - 16));
      _XMM0 = _mm_xor_si128(_mm_load_si128((const __m128i *)(_RDI - 264)), v5);
      __asm
      {
        aesdec  xmm0, xmmword ptr [rdi-0F8h]
        aesdec  xmm0, xmmword ptr [rdi-0E8h]
        aesdec  xmm0, xmmword ptr [rdi-0D8h]
        aesdec  xmm0, xmmword ptr [rdi-0C8h]
        aesdec  xmm0, xmmword ptr [rdi-0B8h]
        aesdec  xmm0, xmmword ptr [rdi-0A8h]
        aesdec  xmm0, xmmword ptr [rdi-98h]
        aesdec  xmm0, xmmword ptr [rdi-88h]
        aesdec  xmm0, xmmword ptr [rdi-78h]
        aesdec  xmm0, xmmword ptr [rdi-68h]
        aesdec  xmm0, xmmword ptr [rdi-58h]
        aesdeclast xmm0, xmmword ptr [rdi-48h]
      }
      v19 = _mm_xor_si128(_XMM0, v4);
      v4 = v5;
      *(__m128i *)(a2 - 16) = v19;
      *(__m128i *)(_RDI - 24) = v5;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_567D0(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v21; // xmm0

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      v5 = _mm_loadu_si128((const __m128i *)(a2 - 16));
      _XMM0 = _mm_xor_si128(_mm_load_si128((const __m128i *)(_RDI - 264)), v5);
      __asm
      {
        aesdec  xmm0, xmmword ptr [rdi-0F8h]
        aesdec  xmm0, xmmword ptr [rdi-0E8h]
        aesdec  xmm0, xmmword ptr [rdi-0D8h]
        aesdec  xmm0, xmmword ptr [rdi-0C8h]
        aesdec  xmm0, xmmword ptr [rdi-0B8h]
        aesdec  xmm0, xmmword ptr [rdi-0A8h]
        aesdec  xmm0, xmmword ptr [rdi-98h]
        aesdec  xmm0, xmmword ptr [rdi-88h]
        aesdec  xmm0, xmmword ptr [rdi-78h]
        aesdec  xmm0, xmmword ptr [rdi-68h]
        aesdec  xmm0, xmmword ptr [rdi-58h]
        aesdec  xmm0, xmmword ptr [rdi-48h]
        aesdec  xmm0, xmmword ptr [rdi-38h]
        aesdeclast xmm0, xmmword ptr [rdi-28h]
      }
      v21 = _mm_xor_si128(_XMM0, v4);
      v4 = v5;
      *(__m128i *)(a2 - 16) = v21;
      *(__m128i *)(_RDI - 24) = v5;
    }
    while ( v3 > a2 );
  }
}

unsigned __int64 __fastcall sub_56890(__int64 a1, __int64 a2)
{
  int v2; // eax
  int v3; // ebx
  unsigned __int64 v4; // rbx
  signed __int64 v5; // r9
  unsigned int v6; // er10
  unsigned __int64 v7; // rcx
  int v8; // er8
  unsigned __int64 v9; // rdx
  int v12; // eax
  __int64 v13; // rdx
  __int64 *v14; // rax
  __int64 v15; // rdx
  __m128i v16; // xmm1
  signed __int64 v17; // rbp
  __int64 v19; // rax
  __int64 v23; // [rsp+0h] [rbp-138h]
  unsigned __int64 v24; // [rsp+F8h] [rbp-40h]

  v24 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 76LL);
  v3 = v2 + 31;
  if ( v2 >= 0 )
    v3 = *(_DWORD *)(*(_QWORD *)a1 + 76LL);
  v4 = v3 >> 5;
  v5 = 4 * (v4 + 7);
  if ( v5 )
  {
    v6 = 0;
    v7 = 0LL;
    do
    {
      while ( v4 > v7 )
      {
        *((_DWORD *)&v23 + v7) = *(_DWORD *)(a2 + 4 * v7);
        if ( v5 == ++v7 )
          goto LABEL_12;
      }
      v8 = *((_DWORD *)&v23 + v7 - 1);
      v9 = v7 % v4;
      if ( v4 != 8 || (v7 & 7) != 4 )
      {
        if ( !v9 )
          goto LABEL_9;
      }
      else
      {
        _XMM0 = _mm_insert_epi32((__m128i)0LL, v8, 1);
        __asm { aeskeygenassist xmm0, xmm0, 0 }
        if ( !v9 )
        {
LABEL_9:
          _XMM0 = _mm_insert_epi32((__m128i)0LL, v8, 1);
          __asm { aeskeygenassist xmm0, xmm0, 0 }
          v12 = _mm_extract_epi32(_XMM0, 1);
          if ( v6 > 9 )
            __assert_fail("rconpos < lenof(key_setup_round_constants)", "sshaes.c", 0x556u, "aes_ni_key_expand");
          v13 = v6++;
          v8 = v12 ^ byte_ED028[v13];
          goto LABEL_11;
        }
        v8 = _mm_cvtsi128_si32(_XMM0);
      }
LABEL_11:
      *((_DWORD *)&v23 + v7) = *((_DWORD *)&v23 + v7 - v4) ^ v8;
      ++v7;
    }
    while ( v5 != v7 );
  }
LABEL_12:
  v14 = &v23;
  v15 = a1 - 504;
  do
  {
    v16 = _mm_cvtsi32_si128(*((_DWORD *)v14 + 2));
    v14 += 2;
    v15 += 16LL;
    *(__m128i *)(v15 - 16) = _mm_unpacklo_epi64(
                               _mm_insert_epi32(_mm_cvtsi32_si128(*((_DWORD *)v14 - 4)), *((_DWORD *)v14 - 3), 1),
                               _mm_insert_epi32(v16, *((_DWORD *)v14 - 1), 1));
  }
  while ( &v23 + 2 * v4 + 14 != v14 );
  v17 = 16 * v4 + a1 - 504 + 240;
  sub_BD070(&v23, 0xF0uLL);
  _XMM0 = _mm_load_si128((const __m128i *)(a1 - 504));
  v19 = 0LL;
  while ( 1 )
  {
    ++v19;
    *(__m128i *)(v17 + 96) = _XMM0;
    if ( v4 + 7 == v19 )
      break;
    _XMM0 = _mm_load_si128((const __m128i *)(a1 - 504 + 16 * v19));
    if ( v4 + 6 - v19 )
      __asm { aesimc  xmm0, xmm0 }
    v17 -= 16LL;
  }
  return __readfsqword(0x28u) ^ v24;
}

void __fastcall sub_56AB0(__int64 a1, const __m128i *a2)
{
  *(__m128i *)(a1 - 24) = _mm_shuffle_epi8(_mm_loadu_si128(a2), (__m128i)xmmword_ED040);
}

void __fastcall sub_56AD0(__int64 _RDI, const __m128i *a2, int a3)
{
  const __m128i *v3; // rdx
  __m128i v4; // xmm0
  __m128i v5; // xmm3
  __m128i v6; // xmm2
  __m128i v7; // xmm6
  __m128i v19; // xmm0

  v3 = (const __m128i *)((char *)a2 + a3);
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    v5 = _mm_load_si128((const __m128i *)&xmmword_ED040);
    v6 = _mm_load_si128((const __m128i *)&xmmword_ED050);
    do
    {
      v7 = _mm_loadu_si128(a2);
      ++a2;
      _XMM0 = _mm_xor_si128(_mm_shuffle_epi8(v4, v5), *(__m128i *)(_RDI - 504));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenclast xmm0, xmmword ptr [rdi-158h]
      }
      a2[-1] = _mm_xor_si128(_XMM0, v7);
      v19 = _mm_add_epi64(_mm_load_si128((const __m128i *)(_RDI - 24)), v6);
      v4 = _mm_sub_epi64(v19, _mm_unpacklo_epi64((__m128i)0LL, _mm_cmpeq_epi64(v19, (__m128i)0LL)));
      *(__m128i *)(_RDI - 24) = v4;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56BB0(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    _XMM0 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      _XMM0 = _mm_xor_si128(_mm_xor_si128(_XMM0, *(__m128i *)(_RDI - 504)), _mm_loadu_si128((const __m128i *)(a2 - 16)));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenclast xmm0, xmmword ptr [rdi-158h]
      }
      *(__m128i *)(a2 - 16) = _XMM0;
      *(__m128i *)(_RDI - 24) = _XMM0;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56C50(__int64 _RDI, const __m128i *a2, int a3)
{
  const __m128i *v3; // rdx
  __m128i v4; // xmm0
  __m128i v5; // xmm3
  __m128i v6; // xmm2
  __m128i v7; // xmm6
  __m128i v21; // xmm0

  v3 = (const __m128i *)((char *)a2 + a3);
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    v5 = _mm_load_si128((const __m128i *)&xmmword_ED040);
    v6 = _mm_load_si128((const __m128i *)&xmmword_ED050);
    do
    {
      v7 = _mm_loadu_si128(a2);
      ++a2;
      _XMM0 = _mm_xor_si128(_mm_shuffle_epi8(v4, v5), *(__m128i *)(_RDI - 504));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenc  xmm0, xmmword ptr [rdi-158h]
        aesenc  xmm0, xmmword ptr [rdi-148h]
        aesenclast xmm0, xmmword ptr [rdi-138h]
      }
      a2[-1] = _mm_xor_si128(_XMM0, v7);
      v21 = _mm_add_epi64(_mm_load_si128((const __m128i *)(_RDI - 24)), v6);
      v4 = _mm_sub_epi64(v21, _mm_unpacklo_epi64((__m128i)0LL, _mm_cmpeq_epi64(v21, (__m128i)0LL)));
      *(__m128i *)(_RDI - 24) = v4;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56D40(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    _XMM0 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      _XMM0 = _mm_xor_si128(_mm_xor_si128(_XMM0, *(__m128i *)(_RDI - 504)), _mm_loadu_si128((const __m128i *)(a2 - 16)));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenc  xmm0, xmmword ptr [rdi-158h]
        aesenc  xmm0, xmmword ptr [rdi-148h]
        aesenclast xmm0, xmmword ptr [rdi-138h]
      }
      *(__m128i *)(a2 - 16) = _XMM0;
      *(__m128i *)(_RDI - 24) = _XMM0;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56E00(__int64 _RDI, const __m128i *a2, int a3)
{
  const __m128i *v3; // rdx
  __m128i v4; // xmm0
  __m128i v5; // xmm3
  __m128i v6; // xmm2
  __m128i v7; // xmm6
  __m128i v23; // xmm0

  v3 = (const __m128i *)((char *)a2 + a3);
  if ( a2 < v3 )
  {
    v4 = _mm_load_si128((const __m128i *)(_RDI - 24));
    v5 = _mm_load_si128((const __m128i *)&xmmword_ED040);
    v6 = _mm_load_si128((const __m128i *)&xmmword_ED050);
    do
    {
      v7 = _mm_loadu_si128(a2);
      ++a2;
      _XMM0 = _mm_xor_si128(_mm_shuffle_epi8(v4, v5), *(__m128i *)(_RDI - 504));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenc  xmm0, xmmword ptr [rdi-158h]
        aesenc  xmm0, xmmword ptr [rdi-148h]
        aesenc  xmm0, xmmword ptr [rdi-138h]
        aesenc  xmm0, xmmword ptr [rdi-128h]
        aesenclast xmm0, xmmword ptr [rdi-118h]
      }
      a2[-1] = _mm_xor_si128(_XMM0, v7);
      v23 = _mm_add_epi64(_mm_load_si128((const __m128i *)(_RDI - 24)), v6);
      v4 = _mm_sub_epi64(v23, _mm_unpacklo_epi64((__m128i)0LL, _mm_cmpeq_epi64(v23, (__m128i)0LL)));
      *(__m128i *)(_RDI - 24) = v4;
    }
    while ( v3 > a2 );
  }
}

void __fastcall sub_56F00(__int64 _RDI, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // rdx

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    _XMM0 = _mm_load_si128((const __m128i *)(_RDI - 24));
    do
    {
      a2 += 16LL;
      _XMM0 = _mm_xor_si128(_mm_xor_si128(_XMM0, *(__m128i *)(_RDI - 504)), _mm_loadu_si128((const __m128i *)(a2 - 16)));
      __asm
      {
        aesenc  xmm0, xmmword ptr [rdi-1E8h]
        aesenc  xmm0, xmmword ptr [rdi-1D8h]
        aesenc  xmm0, xmmword ptr [rdi-1C8h]
        aesenc  xmm0, xmmword ptr [rdi-1B8h]
        aesenc  xmm0, xmmword ptr [rdi-1A8h]
        aesenc  xmm0, xmmword ptr [rdi-198h]
        aesenc  xmm0, xmmword ptr [rdi-188h]
        aesenc  xmm0, xmmword ptr [rdi-178h]
        aesenc  xmm0, xmmword ptr [rdi-168h]
        aesenc  xmm0, xmmword ptr [rdi-158h]
        aesenc  xmm0, xmmword ptr [rdi-148h]
        aesenc  xmm0, xmmword ptr [rdi-138h]
        aesenc  xmm0, xmmword ptr [rdi-128h]
        aesenclast xmm0, xmmword ptr [rdi-118h]
      }
      *(__m128i *)(a2 - 16) = _XMM0;
      *(__m128i *)(_RDI - 24) = _XMM0;
    }
    while ( v3 > a2 );
  }
}

unsigned __int64 __fastcall sub_56FD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  signed __int64 v4; // r11
  int v5; // ebp
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdi
  __int64 v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  signed __int64 v12; // rdx
  signed __int64 v13; // rdx
  signed __int64 v14; // rcx
  signed __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  __int64 v18; // rdx
  int v19; // ecx
  unsigned __int64 v20; // rax
  _WORD *v21; // rdx
  __int64 v22; // rsi
  __int64 v24; // rax
  __int64 v25; // rax
  __int128 *v26; // rsi
  unsigned __int16 v27; // dx
  int v28; // edx
  unsigned __int16 v29; // ST5A_2
  unsigned __int16 v30; // ST1E_2
  __int16 v31; // ST7C_2
  unsigned __int16 v32; // ST58_2
  int v33; // er12
  unsigned __int16 v34; // ST5E_2
  unsigned __int16 v35; // ST5C_2
  int v36; // eax
  int v37; // er14
  int v38; // ecx
  int v39; // eax
  int v40; // er12
  unsigned __int16 v41; // ST7A_2
  unsigned __int16 v42; // si
  __int16 v43; // ST80_2
  int v44; // edx
  unsigned __int16 v45; // ST60_2
  int v46; // er15
  int v47; // ebx
  __int16 v48; // ST62_2
  __int16 v49; // ST82_2
  int v50; // er8
  int v51; // er12
  int v52; // er8
  int v53; // esi
  int v54; // er14
  int v55; // esi
  int v56; // er9
  int v57; // eax
  int v58; // er9
  int v59; // er10
  int v60; // eax
  int v61; // er10
  int v62; // ebx
  int v63; // esi
  int v64; // er12
  int v65; // ebx
  int v66; // er8
  int v67; // er14
  int v68; // er9
  int v69; // er10
  int v70; // eax
  int v71; // esi
  __int16 v72; // ST64_2
  int v73; // edx
  int v74; // er14
  __int16 v75; // ST78_2
  __int16 v76; // ST1A_2
  __int16 v77; // ST5E_2
  unsigned __int16 v78; // ST58_2
  __int16 v79; // ST56_2
  __int16 v80; // ST62_2
  int v81; // er15
  int v82; // er12
  int v83; // er10
  __int16 v84; // ST7A_2
  int v85; // esi
  int v86; // ebx
  int v87; // er14
  int v88; // er10
  int v89; // ebx
  int v90; // er10
  int v91; // er8
  unsigned __int64 v92; // rcx
  int v93; // eax
  unsigned __int64 v94; // [rsp+0h] [rbp-100h]
  unsigned __int64 v95; // [rsp+18h] [rbp-E8h]
  signed __int64 v96; // [rsp+20h] [rbp-E0h]
  __int64 v97; // [rsp+28h] [rbp-D8h]
  unsigned __int64 v98; // [rsp+30h] [rbp-D0h]
  int v99; // [rsp+48h] [rbp-B8h]
  char v100; // [rsp+4Dh] [rbp-B3h]
  unsigned int v101; // [rsp+64h] [rbp-9Ch]
  __int64 v102; // [rsp+88h] [rbp-78h]
  unsigned __int16 v103; // [rsp+98h] [rbp-68h]
  unsigned __int16 v104; // [rsp+9Ah] [rbp-66h]
  unsigned __int16 v105; // [rsp+9Ch] [rbp-64h]
  unsigned __int16 v106; // [rsp+9Eh] [rbp-62h]
  unsigned __int16 v107; // [rsp+A0h] [rbp-60h]
  unsigned __int16 v108; // [rsp+A2h] [rbp-5Eh]
  unsigned __int16 v109; // [rsp+A4h] [rbp-5Ch]
  unsigned __int16 v110; // [rsp+A6h] [rbp-5Ah]
  __int128 v111; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v112; // [rsp+C0h] [rbp-40h]

  v112 = __readfsqword(0x28u);
  v102 = a1;
  v97 = a2;
  v94 = (unsigned __int64)*(signed int *)(*(_QWORD *)a1 + 76LL) >> 5;
  *(_DWORD *)(a1 - 96) = v94 + 6;
  v2 = a1;
  v3 = a1 - 1296;
  v4 = v3 + 960;
  v96 = v3 + 960;
  *(_QWORD *)(v2 - 336) = 0LL;
  *(_QWORD *)(v2 - 104) = 0LL;
  memset(
    (void *)((v3 + 968) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((_DWORD)v3 + 960 - (((_DWORD)v3 + 968) & 0xFFFFFFF8) + 240) >> 3));
  v111 = 0LL;
  if ( 4 * (_DWORD)v94 == -28 )
  {
    sub_BD070(&v111, 0x10uLL);
    sub_BD070(&v103, 0x10uLL);
    return __readfsqword(0x28u) ^ v112;
  }
  v5 = 0;
  v100 = 0;
  v99 = 0;
  v101 = 0;
  v6 = *((_QWORD *)&v111 + 1) ^ (*((_QWORD *)&v111 + 1) ^ (*((_QWORD *)&v111 + 1) >> 7)) & 0xAA00AA00AA00AALL ^ (((*((_QWORD *)&v111 + 1) ^ (*((_QWORD *)&v111 + 1) >> 7)) & 0xAA00AA00AA00AALL) << 7);
  v7 = (v6 ^ (v6 >> 14)) & 0xCCCC0000CCCCLL ^ v6 ^ (((v6 ^ (v6 >> 14)) & 0xCCCC0000CCCCLL) << 14);
  v8 = 0LL;
  v9 = ((unsigned int)v7 ^ (unsigned int)(v7 >> 28)) & 0xF0F0F0F0;
  v98 = v9 ^ v7 ^ (v9 << 28);
  do
  {
    if ( v94 > v8 )
    {
      v100 = 1;
      v99 = *(_DWORD *)(v97 + 4 * v8);
      v10 = ((unsigned __int64)HIBYTE(v99) << 24) | (unsigned __int8)v99 | (unsigned __int16)v99 & 0xFF00 | ((unsigned __int64)BYTE2(v99) << 16);
      v11 = (v10 ^ (v10 >> 7)) & 0xAA00AA00AA00AALL ^ v10 ^ (((v10 ^ (v10 >> 7)) & 0xAA00AA00AA00AALL) << 7);
      v12 = (v11 ^ (v11 >> 14)) & 0xCCCC0000CCCCLL;
      v17 = ((unsigned __int64)((((_DWORD)v12 << 14) ^ (unsigned int)v12 ^ (unsigned int)v11) & 0xF0F0F0F0) << 28) ^ (((_DWORD)v12 << 14) ^ (unsigned int)v12 ^ (unsigned int)v11) & 0xF0F0F0F0 ^ (v12 << 14) ^ v12 ^ v11;
      v13 = (v98 ^ (v17 >> 8)) & 0xFF00FF00FF00FFLL;
      v14 = v13;
      v15 = v98 ^ v13;
      v104 = v15;
      v16 = v17 ^ (v14 << 8);
      LOBYTE(v17) = v16;
      v105 = WORD1(v16);
      v103 = v16;
      v109 = HIWORD(v16);
      v107 = WORD2(v16);
      v106 = WORD1(v15);
      v110 = HIWORD(v15);
      v108 = WORD2(v15);
      goto LABEL_5;
    }
    v24 = 0LL;
    do
    {
      *(&v103 + v24) = (signed int)*(unsigned __int16 *)(v96 + 16LL * ((unsigned int)(v8 - 1) >> 2) + 2 * v24) >> 4 * ((v8 - 1) & 3);
      ++v24;
    }
    while ( v24 != 8 );
    v95 = v8 % v94;
    if ( !(v8 % v94) )
    {
      v26 = (__int128 *)&v103;
      do
      {
        v27 = *(_WORD *)v26;
        v26 = (__int128 *)((char *)v26 + 2);
        *((_WORD *)v26 - 1) = ((unsigned __int8)(v27 >> 1) | (unsigned __int8)(8 * v27)) & 0xF;
      }
      while ( &v111 != v26 );
      v95 = 0LL;
LABEL_29:
      v28 = v109 ^ v108;
      v29 = v28 ^ v103 ^ v107;
      v30 = v110 ^ v104 ^ v105 ^ v107;
      v31 = v28 ^ v103 ^ v104;
      v32 = v28 ^ v103;
      v33 = v110 ^ v107;
      v34 = v31 ^ v110 ^ v105;
      v35 = v110 ^ v28 ^ v103;
      v36 = v30 ^ v106;
      v37 = v36 ^ v109;
      v38 = v36 ^ v105;
      v39 = v33;
      v40 = v37 ^ v33;
      v41 = v39;
      v42 = v28 ^ v38;
      v43 = v40;
      v44 = v40 ^ v28;
      v45 = v42;
      v46 = (unsigned __int16)(v38 & v30);
      v47 = (unsigned __int16)(v44 & (v110 ^ v104));
      v48 = v103 ^ v40;
      LOWORD(v40) = v40 ^ v42;
      v49 = v40;
      v50 = v39 & ~v37;
      v51 = v50 ^ (unsigned __int16)(v40 & (v105 ^ v107));
      v52 = (unsigned __int16)(v42 & (v110 ^ v105)) ^ v50;
      v53 = v46 ^ v37 ^ (v38 ^ v103) & v34;
      v54 = v29;
      LOWORD(v54) = v103 & v29;
      v55 = v51 ^ v53;
      v56 = v54 ^ (unsigned __int16)(v110 ^ v105);
      LOWORD(v56) = v45 ^ v56;
      v57 = ~v104 & v32;
      LOWORD(v57) = v110 ^ v104 ^ v57;
      v58 = v52 ^ v46 ^ v56;
      v59 = v35;
      LOWORD(v59) = v48 & v35;
      v60 = v51 ^ v47 ^ v44 ^ v57;
      v61 = v52 ^ v59 ^ v44 ^ v110 ^ v47;
      v62 = v55;
      v63 = v60 & v55;
      v64 = v58 ^ v62;
      v65 = v63 ^ v61;
      v66 = v58 ^ (v63 ^ v61) & v64;
      v67 = (v63 ^ v58) & (v61 ^ v60);
      v68 = v67 ^ v61;
      v69 = (v67 ^ v63) & v61;
      v70 = v69 ^ v68 ^ v60;
      v71 = v64 ^ v66 & (v69 ^ v65);
      v72 = v71 ^ v70;
      v73 = (v71 ^ v66) & v44;
      v74 = v68 ^ v66 ^ v71 ^ v70;
      v75 = v68 & v103;
      v76 = (v110 ^ v104) & (v71 ^ v66);
      v77 = v70 & v34;
      v78 = v71 & v32;
      v79 = v74 & (v105 ^ v107);
      v80 = v66 & v48;
      v81 = (unsigned __int16)(v74 & (v105 ^ v107)) ^ (v68 ^ v66) & v41;
      v82 = (unsigned __int16)(v68 & v103);
      LOWORD(v82) = v76 ^ v82;
      v83 = (unsigned __int16)(v74 & v49);
      v84 = v31 & v71 ^ v80;
      v85 = v73 ^ (unsigned __int16)(v38 & (v70 ^ v68));
      v86 = v45;
      LOWORD(v86) = v72 & v45;
      LOWORD(v73) = v83 ^ v43 & (v68 ^ v66) ^ v73;
      LOWORD(v66) = v35 & v66;
      v87 = v85 ^ v82;
      v88 = v86 ^ v83;
      v89 = v81 ^ v78;
      v90 = v89 ^ v88;
      LOWORD(v82) = v89 ^ v77 ^ v30 & (v70 ^ v68);
      v91 = v90 ^ v87 ^ v66;
      LOWORD(v81) = v87 ^ v81;
      LOWORD(v87) = v110 ^ v105;
      LOWORD(v70) = v82 ^ (v38 ^ v103) & v70;
      v103 = ~(v84 ^ v81);
      v107 = v70 ^ v85;
      v110 = v73 ^ v82;
      v105 = v91 ^ v77 ^ v29 & v68;
      v109 = ~(v73 ^ v78 ^ v70 ^ v85);
      v106 = v80 ^ v75 ^ v70;
      v108 = ~(v91 ^ v73 ^ v78 ^ v79 ^ v72 & v87);
      v104 = ~(v90 ^ v84 ^ v76);
      if ( !(v8 % v94) )
      {
        if ( v101 > 9 )
        {
          if ( v100 )
            LODWORD(v111) = v99;
          __assert_fail("rconpos < lenof(key_setup_round_constants)", "sshaes.c", 0x39Du, "aes_sliced_key_setup");
        }
        v92 = v95;
        v93 = byte_ED028[v101];
        do
        {
          *(&v103 + v92) ^= (v93 >> v92) & 1;
          ++v92;
        }
        while ( v92 != 8 );
        ++v101;
      }
      goto LABEL_23;
    }
    if ( v94 == 8 && (v8 & 7) == 4 )
      goto LABEL_29;
LABEL_23:
    v25 = 0LL;
    do
    {
      *(&v103 + v25) ^= (signed int)*(unsigned __int16 *)(v96 + 16LL * ((unsigned int)(v8 - v94) >> 2) + 2 * v25) >> 4 * ((v8 - v94) & 3);
      ++v25;
    }
    while ( v25 != 8 );
    LOBYTE(v17) = v103;
LABEL_5:
    v18 = 0LL;
    v19 = v5;
    while ( 1 )
    {
      *(_WORD *)(v4 + v18) |= (v17 & 0xF) << v5;
      v18 += 2LL;
      if ( v18 == 16 )
        break;
      LOWORD(v17) = *(unsigned __int16 *)((char *)&v103 + v18);
    }
    v5 += 4;
    if ( v19 == 12 )
    {
      v4 += 16LL;
      v5 = 0;
    }
    ++v8;
  }
  while ( 4 * (_DWORD)v94 + 28 != v8 );
  if ( v100 )
    LODWORD(v111) = v99;
  sub_BD070(&v111, 0x10uLL);
  sub_BD070(&v103, 0x10uLL);
  v20 = 8 * (v8 >> 2);
  if ( v20 <= 8 )
  {
    if ( v20 )
      goto LABEL_16;
  }
  else
  {
    v21 = (_WORD *)(v102 - 320);
    do
    {
      *v21 = ~*v21;
      v21[1] = ~v21[1];
      v21[5] = ~v21[5];
      v21[6] = ~v21[6];
      v21 += 8;
    }
    while ( (_WORD *)(v102 + 16 * (v8 >> 2) - 336) != v21 );
LABEL_16:
    v22 = 0LL;
    do
    {
      *(_QWORD *)(v102 + 8 * v22 - 1296) = 281479271743489LL * *(unsigned __int16 *)(v102 + 2 * v22 - 336);
      ++v22;
    }
    while ( v22 != v20 );
  }
  return __readfsqword(0x28u) ^ v112;
}

unsigned __int64 __fastcall sub_57940(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // rax
  signed __int64 v5; // r8
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rax
  __int64 v8; // r13
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  unsigned __int64 v11; // rax
  signed __int64 v12; // rdi
  signed __int64 v13; // r13
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rsi
  int v16; // er15
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // rcx
  int v19; // er13
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rsi
  signed __int64 v22; // rbx
  unsigned __int64 v23; // rdi
  int v24; // edx
  signed __int64 v25; // rdx
  int v26; // ebx
  int v27; // eax
  int v28; // er15
  int v29; // edx
  int v30; // ebx
  int v31; // ecx
  int v32; // er12
  int v33; // er10
  __int16 v34; // ST0E_2
  int v35; // er14
  int v36; // er8
  __int16 v37; // ST20_2
  unsigned __int16 v38; // ST10_2
  __int16 v39; // ST12_2
  __int16 v40; // ST22_2
  unsigned __int16 v41; // ST14_2
  int v42; // er11
  __int16 v43; // ST16_2
  __int16 v44; // dx
  int v45; // er11
  unsigned __int16 v46; // r13
  __int16 v47; // r9
  __int16 v48; // ST18_2
  __int16 v49; // si
  int v50; // edx
  int v51; // ebp
  int v52; // ecx
  int v53; // er15
  __int16 v54; // si
  __int16 v55; // ST26_2
  unsigned __int16 v56; // ST0C_2
  __int16 v57; // r13
  __int16 v58; // ST1C_2
  __int16 v59; // ST24_2
  int v60; // er14
  int v61; // esi
  int v62; // er13
  int v63; // esi
  int v64; // er10
  int v65; // er9
  int v66; // er11
  int v67; // eax
  int v68; // er10
  int v69; // er9
  int v70; // er13
  int v71; // edi
  int v72; // er11
  int v73; // er9
  int v74; // esi
  int v75; // er9
  int v76; // er10
  int v77; // ebp
  int v78; // edi
  int v79; // er14
  int v80; // eax
  int v81; // er10
  int v82; // er13
  __int16 v83; // ST1A_2
  int v84; // edi
  int v85; // ebx
  int v86; // er13
  __int16 v87; // ST1C_2
  int v88; // er8
  unsigned __int16 v89; // ST0E_2
  int v90; // er14
  int v91; // ecx
  int v92; // er15
  int v93; // edi
  int v94; // er12
  __int16 v95; // ST16_2
  int v96; // esi
  int v97; // esi
  int v98; // er13
  int v99; // er10
  int v100; // edx
  int v101; // ecx
  int v102; // er9
  int v103; // er12
  int v104; // er8
  int v105; // er9
  int v106; // er14
  int v107; // er11
  int v108; // edi
  int v109; // er10
  int v110; // edi
  int v111; // eax
  int v112; // er14
  int v113; // edx
  int v114; // esi
  int v115; // ebp
  int v116; // eax
  int v117; // ecx
  int v118; // er11
  int v119; // ecx
  int v120; // er10
  unsigned int v121; // er12
  int v122; // ecx
  int v123; // er9
  int v124; // er12
  int v125; // edi
  int v126; // edi
  int v127; // er12
  int v128; // esi
  int v129; // er12
  int v130; // er12
  int v131; // esi
  int v132; // er15
  int v133; // ebp
  int v134; // esi
  int v135; // ebp
  int v136; // ebp
  int v137; // esi
  int v138; // eax
  unsigned int v139; // esi
  int v140; // er8
  int v141; // er10
  int v142; // eax
  int v143; // er15
  int v144; // er11
  int v145; // edx
  int v146; // edi
  int v147; // eax
  int v148; // edi
  int v149; // eax
  int v150; // edi
  int v151; // esi
  int v152; // er9
  int v153; // er11
  int v154; // er8
  int v155; // er14
  int v156; // esi
  unsigned __int16 v157; // ST10_2
  int v158; // er13
  int v159; // er9
  unsigned __int16 v160; // ST0C_2
  int v161; // ebx
  int v162; // er14
  int v163; // er13
  unsigned int v164; // eax
  int v165; // er14
  int v166; // er14
  int v167; // er13
  int v168; // er13
  int v169; // ecx
  unsigned int v170; // edx
  int v171; // er9
  int v172; // er11
  int v173; // er9
  int v174; // er15
  int v175; // er15
  int v176; // esi
  int v177; // esi
  int v178; // ebx
  int v179; // er8
  int v180; // er8
  int v181; // edx
  int v182; // edx
  unsigned __int16 v183; // ST12_2
  int v184; // er14
  int v185; // edx
  int v186; // eax
  int v187; // er13
  int v188; // eax
  int v189; // edx
  int v190; // edx
  int v191; // ebp
  int v192; // er11
  int v193; // ecx
  int v194; // er11
  int v195; // er10
  int v196; // ecx
  int v197; // er15
  int v198; // edi
  int v199; // ebp
  int v200; // ecx
  int v201; // edi
  int v202; // esi
  int v203; // edi
  int v204; // er10
  int v205; // esi
  int v206; // er14
  int v207; // edi
  int v208; // ebx
  int v209; // ecx
  int v210; // er12
  int v211; // ebx
  int v212; // er10
  __int16 v213; // ST10_2
  int v214; // er8
  int v215; // er9
  __int16 v216; // ST20_2
  __int16 v217; // ST12_2
  __int16 v218; // ST22_2
  __int16 v219; // ST14_2
  __int16 v220; // ax
  int v221; // er14
  int v222; // er11
  int v223; // er13
  int v224; // esi
  int v225; // er14
  int v226; // ebp
  unsigned __int16 v227; // ST18_2
  unsigned __int16 v228; // ST1C_2
  __int16 v229; // ST16_2
  int v230; // er12
  __int16 v231; // ax
  __int16 v232; // ST0C_2
  int v233; // er11
  __int16 v234; // ST24_2
  int v235; // er9
  int v236; // ecx
  int v237; // er14
  int v238; // edx
  __int16 v239; // ST1E_2
  int v240; // er10
  int v241; // esi
  int v242; // eax
  int v243; // esi
  int v244; // eax
  int v245; // edx
  int v246; // eax
  int v247; // ecx
  int v248; // er15
  int v249; // esi
  int v250; // er15
  int v251; // edi
  int v252; // er10
  int v253; // er9
  int v254; // eax
  int v255; // ecx
  int v256; // edx
  int v257; // er9
  __int16 v258; // ST0E_2
  int v259; // esi
  int v260; // ecx
  int v261; // er8
  __int16 v262; // ST1A_2
  int v263; // er12
  int v264; // edi
  unsigned __int16 v265; // ST16_2
  __int16 v266; // ST10_2
  int v267; // esi
  int v268; // ebx
  int v269; // er13
  int v270; // ecx
  int v271; // er8
  int v272; // er12
  int v273; // er14
  int v274; // edi
  int v275; // edx
  int v276; // er13
  int v277; // ebp
  int v278; // ecx
  int v279; // ecx
  int v280; // ecx
  int v281; // ebp
  unsigned __int64 v282; // rdx
  unsigned __int64 v283; // r9
  signed __int64 v284; // rdi
  unsigned __int64 v285; // rdx
  unsigned __int64 v286; // r9
  __int64 v287; // rcx
  unsigned __int64 v288; // r9
  __int64 v289; // rsi
  __int64 v290; // rcx
  unsigned __int64 v291; // rsi
  unsigned __int64 v292; // rdx
  signed __int64 v293; // rsi
  unsigned __int64 v294; // rax
  unsigned __int64 result; // rax
  _WORD *v296; // [rsp+0h] [rbp-68h]
  unsigned __int16 v297; // [rsp+Eh] [rbp-5Ah]
  _WORD *v298; // [rsp+28h] [rbp-40h]
  __int64 v299; // [rsp+30h] [rbp-38h]

  v299 = a1;
  v3 = (((*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL) << 7) ^ *a2 ^ (*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL;
  v4 = a2[1] ^ (a2[1] ^ (a2[1] >> 7)) & 0xAA00AA00AA00AALL ^ (((a2[1] ^ (a2[1] >> 7)) & 0xAA00AA00AA00AALL) << 7);
  v5 = (v3 ^ (v3 >> 14)) & 0xCCCC0000CCCCLL;
  v6 = v5 ^ v3;
  v5 <<= 14;
  v7 = (((v4 ^ (v4 >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v4 ^ (v4 >> 14)) & 0xCCCC0000CCCCLL ^ v4;
  v8 = ((unsigned int)v6 ^ (unsigned int)v5 ^ (unsigned int)((v6 ^ v5) >> 28)) & 0xF0F0F0F0;
  v9 = (v8 << 28) ^ v8 ^ v6 ^ v5;
  v10 = ((unsigned int)v7 ^ (unsigned int)(v7 >> 28)) & 0xF0F0F0F0;
  v11 = (v10 << 28) ^ v10 ^ v7;
  v12 = (v11 ^ (v9 >> 8)) & 0xFF00FF00FF00FFLL;
  v13 = v12;
  v14 = v11 ^ v12;
  v15 = (v13 << 8) ^ v9;
  v16 = v14 ^ *(unsigned __int16 *)(a3 + 962);
  v17 = v14 >> 16;
  v18 = v14 >> 32;
  LOWORD(v17) = *(_WORD *)(a3 + 966) ^ WORD1(v14);
  v297 = v15 ^ *(_WORD *)(a3 + 960);
  LOWORD(v18) = *(_WORD *)(a3 + 970) ^ WORD2(v14);
  v19 = (v15 >> 16) ^ *(unsigned __int16 *)(a3 + 964);
  v20 = v15 >> 32;
  v21 = v15 >> 48;
  LOWORD(v20) = *(_WORD *)(a3 + 968) ^ v20;
  LOWORD(v21) = *(_WORD *)(a3 + 972) ^ v21;
  v23 = v14 >> 48;
  v22 = a3 + 976;
  LOWORD(v23) = *(_WORD *)(a3 + 974) ^ v23;
  v24 = *(_DWORD *)(a3 + 1200);
  v296 = (_WORD *)v22;
  if ( v24 != 1 )
  {
    v25 = v22 + 16 * ((unsigned int)(v24 - 2) + 1LL);
    v26 = v20;
    v27 = v16;
    v298 = (_WORD *)v25;
    v28 = v26;
    v29 = v19;
    do
    {
      v30 = v297;
      v31 = v21 ^ v18;
      v32 = v27 ^ v23;
      v33 = v29 ^ v23;
      v34 = v28 ^ v29;
      v35 = v27 ^ v23 ^ v28 ^ v29;
      v36 = v31 ^ v30;
      v37 = v27 ^ v23 ^ v28 ^ v29;
      v38 = v29 ^ v23;
      v39 = v31 ^ v30 ^ v28;
      v40 = v31 ^ v30 ^ v27;
      v41 = v31 ^ v30 ^ v23;
      v42 = v35 ^ v17;
      v43 = v40 ^ v29 ^ v23;
      v44 = v42 ^ v29;
      v45 = v21 ^ v42;
      v46 = v44 ^ v31;
      v47 = v44 ^ v30;
      v48 = v44;
      v49 = v44 ^ v31;
      v50 = v28 ^ v23;
      v51 = v45 ^ v28 ^ v23;
      v52 = v51 ^ v31;
      v53 = v51 ^ v30;
      v54 = v51 ^ v49;
      v55 = v51;
      v56 = v46;
      v57 = v54;
      LOWORD(v33) = v56 & v33;
      v58 = v54;
      v59 = v47;
      v60 = (unsigned __int16)(v35 & v48);
      v61 = v50 & ~v45;
      v62 = v61 ^ (unsigned __int16)(v57 & v34);
      v63 = v33 ^ v61;
      v64 = v62 ^ v60 ^ v45 ^ (unsigned __int16)(v47 & v43);
      v65 = (unsigned __int16)(v30 & v39) ^ v38;
      LOWORD(v65) = v56 ^ v65;
      v66 = v64;
      v67 = v62 ^ v52 & v32 ^ v52 ^ v32 ^ v36 & ~v27;
      v68 = v67 & v64;
      v69 = v63 ^ v60 ^ v65;
      v70 = v69 ^ v66;
      v71 = v63 ^ v52 ^ v23 ^ v52 & v32 ^ (v51 ^ v30) & v41;
      v72 = v69 ^ (v68 ^ v71) & (v69 ^ v66);
      v73 = (v71 ^ v67) & (v68 ^ v69);
      v74 = v73 ^ v71;
      v75 = v68 ^ v73;
      v76 = v68 ^ v71;
      v77 = v74;
      v78 = v75 & v71;
      v79 = v74;
      v80 = v78 ^ v74 ^ v67;
      v81 = v70 ^ v72 & (v78 ^ v76);
      v82 = v30;
      v83 = v81 ^ v80;
      HIWORD(v75) = HIWORD(v74) ^ HIWORD(v72);
      v84 = v81 ^ v72;
      v85 = v74 ^ v72 ^ v81 ^ v80;
      LOWORD(v74) = v85 & v58;
      v86 = v77 & v82;
      LOWORD(v85) = v34 & v85;
      v87 = v74;
      v88 = v81 & v36;
      v89 = v86;
      LOWORD(v81) = v40 & v81;
      v90 = v80 ^ v79;
      v91 = v84 & v52;
      v92 = v72 & v53;
      v93 = v32 & v84;
      v94 = v86;
      v95 = v80 & v43;
      v96 = (v77 ^ v72) & (unsigned __int16)v50;
      LOWORD(v75) = v55 & (v77 ^ v72);
      LOWORD(v72) = v41 & v72;
      v97 = v85 ^ v96;
      v98 = v97 ^ v88;
      v99 = v92 ^ v81;
      v100 = v91 ^ (unsigned __int16)(v90 & v48);
      v101 = v75 ^ v91;
      v102 = v56;
      LOWORD(v101) = v87 ^ v101;
      v103 = v100 ^ v93 ^ v94;
      LOWORD(v102) = v87 ^ v83 & v56;
      LOWORD(v90) = v95 ^ v37 & v90;
      v104 = v101 ^ v88;
      v105 = v98 ^ v102;
      v106 = v98 ^ v90;
      v107 = v105 ^ v103 ^ v72;
      LOWORD(v80) = v59 & v80;
      v108 = v99 ^ v93;
      v109 = v103 ^ v97 ^ v99;
      HIWORD(v97) = HIWORD(v109);
      LOWORD(v77) = v95 ^ v39 & v77;
      v110 = v105 ^ v108;
      LOWORD(v97) = (unsigned __int16)v109 >> 8;
      HIWORD(v105) = HIWORD(v110);
      v111 = v106 ^ v80;
      v112 = v101 ^ v106;
      v113 = v111 ^ v100;
      v114 = v109 ^ v97;
      LOWORD(v114) = v114 & 0xCC;
      v115 = v107 ^ v77;
      LOWORD(v98) = v113 ^ v104;
      v116 = v92 ^ v89 ^ v111;
      v117 = v38;
      LOWORD(v117) = v83 & v38;
      v118 = v117 ^ v85 ^ v104 ^ v107;
      v119 = (v114 << 8) ^ v114 ^ v109;
      v120 = v119 << 12;
      v121 = v119 & 0xFFFF5555;
      LOWORD(v120) = ((_WORD)v119 << 12) & 0xA000;
      LOWORD(v119) = ((unsigned __int16)v119 >> 4) & 0xAAA;
      HIWORD(v104) = HIWORD(v118);
      v122 = v120 | v121 | v119;
      LOWORD(v105) = (unsigned __int16)v110 >> 8;
      v123 = v110 ^ v105;
      LOWORD(v123) = v123 & 0xCC;
      v124 = v123;
      v125 = v123 ^ v110;
      HIWORD(v123) = HIWORD(v112);
      v126 = (v124 << 8) ^ v125;
      v127 = v126;
      v128 = v126;
      v126 <<= 12;
      LOWORD(v128) = v128 & 0x5555;
      LOWORD(v126) = v126 & 0xA000;
      LOWORD(v127) = ((unsigned __int16)v127 >> 4) & 0xAAA;
      v129 = v128 | v127;
      HIWORD(v128) = HIWORD(v115);
      LOWORD(v128) = (unsigned __int16)v115 >> 8;
      v130 = v126 | v129;
      v131 = v115 ^ v128;
      LOWORD(v131) = v131 & 0xCC;
      v132 = v131 ^ v115 ^ (v131 << 8);
      v133 = v132;
      v134 = v132;
      v132 <<= 12;
      LOWORD(v134) = v134 & 0x5555;
      LOWORD(v132) = v132 & 0xA000;
      LOWORD(v133) = ((unsigned __int16)v133 >> 4) & 0xAAA;
      v135 = v134 | v133;
      HIWORD(v134) = HIWORD(v116);
      LOWORD(v134) = (unsigned __int16)v116 >> 8;
      v136 = v132 | v135;
      v137 = v116 ^ v134;
      LOWORD(v137) = v137 & 0xCC;
      v138 = (v137 << 8) ^ v137 ^ v116;
      HIWORD(v120) = HIWORD(v138);
      LOWORD(v120) = (unsigned __int16)v138 >> 4;
      v139 = v138 & 0xFFFF5555;
      v138 <<= 12;
      LOWORD(v120) = v120 & 0xAAA;
      LOWORD(v138) = v138 & 0xA000;
      LOWORD(v104) = (unsigned __int16)v118 >> 8;
      v140 = v118 ^ v104;
      v141 = v138 | v139 | v120;
      HIWORD(v138) = HIWORD(v113);
      LOWORD(v140) = v140 & 0xCC;
      LOWORD(v138) = (unsigned __int16)v113 >> 8;
      v142 = v113 ^ v138;
      v143 = 8 * v141;
      LOWORD(v142) = v142 & 0xCC;
      v144 = (v140 << 8) ^ v140 ^ v118;
      HIWORD(v139) = HIWORD(v144);
      v145 = (v142 << 8) ^ v142 ^ v113;
      LOWORD(v139) = ((unsigned __int16)v144 >> 4) & 0xAAA;
      v146 = v145;
      v147 = v145;
      v145 <<= 12;
      LOWORD(v147) = v147 & 0x5555;
      LOWORD(v145) = v145 & 0xA000;
      LOWORD(v146) = ((unsigned __int16)v146 >> 4) & 0xAAA;
      v148 = v147 | v146;
      v149 = v144;
      v144 <<= 12;
      LOWORD(v149) = v149 & 0x5555;
      LOWORD(v144) = v144 & 0xA000;
      v150 = v145 | v148;
      v151 = v144 | v149 | v139;
      LOWORD(v123) = (unsigned __int16)v112 >> 8;
      v152 = v112 ^ v123;
      v153 = 8 * v130;
      LOWORD(v152) = v152 & 0xCC;
      v154 = v151;
      v155 = v152 ^ v112;
      v156 = 8 * v150;
      v157 = v154;
      LOWORD(v98) = ((unsigned __int8)((v98 ^ BYTE1(v98)) & 0xCC) << 8) ^ ((unsigned __int8)v98 ^ BYTE1(v98)) & 0xCC ^ v98;
      LOWORD(v85) = ((_WORD)v98 << 12) & 0xA000 | v98 & 0x5555 | ((unsigned __int16)v98 >> 4) & 0xAAA;
      v158 = v152;
      v159 = 8 * v136;
      v160 = v85;
      v161 = 8 * v154;
      v162 = v155 ^ (v158 << 8);
      v163 = v162 << 12;
      v164 = v162 & 0xFFFF5555;
      LOWORD(v163) = ((_WORD)v162 << 12) & 0xA000;
      LOWORD(v162) = ((unsigned __int16)v162 >> 4) & 0xAAA;
      v165 = v164 | v162;
      HIWORD(v164) = HIWORD(v122);
      v166 = v163 | v165;
      v167 = 8 * v122;
      LOWORD(v164) = ((unsigned __int16)v122 >> 1) & 0x7777;
      LOWORD(v167) = 8 * v122 & 0x8888;
      v168 = v164 | v167;
      HIWORD(v164) = HIWORD(v130);
      v169 = v168 ^ v122;
      LOWORD(v153) = 8 * v130 & 0x8888;
      LOWORD(v164) = (unsigned __int16)v130 >> 1;
      v170 = v164;
      HIWORD(v164) = HIWORD(v136);
      LOWORD(v159) = 8 * v136 & 0x8888;
      LOWORD(v143) = 8 * v141 & 0x8888;
      LOWORD(v170) = v170 & 0x7777;
      LOWORD(v164) = ((unsigned __int16)v136 >> 1) & 0x7777;
      LOWORD(v156) = 8 * v150 & 0x8888;
      v171 = v164 | v159;
      HIWORD(v164) = HIWORD(v141);
      LOWORD(v161) = 8 * v154 & 0x8888;
      v172 = v130 ^ (v170 | v153);
      LOWORD(v164) = ((unsigned __int16)v141 >> 1) & 0x7777;
      v173 = v136 ^ v171;
      v174 = v164 | v143;
      HIWORD(v164) = HIWORD(v150);
      v175 = v141 ^ v174;
      LOWORD(v164) = ((unsigned __int16)v150 >> 1) & 0x7777;
      v176 = v164 | v156;
      HIWORD(v164) = HIWORD(v154);
      v177 = v150 ^ v176;
      LOWORD(v164) = ((unsigned __int16)v154 >> 1) & 0x7777;
      v178 = v154 ^ (v164 | v161);
      v179 = 8 * v160;
      LOWORD(v179) = 8 * v160 & 0x8888;
      HIWORD(v164) = HIWORD(v166);
      v180 = v160 ^ ((v160 >> 1) & 0x7777 | v179);
      v181 = 8 * v166;
      LOWORD(v181) = 8 * v166 & 0x8888;
      LOWORD(v164) = ((unsigned __int16)v166 >> 1) & 0x7777;
      v182 = v164 | v181;
      v183 = v182;
      v184 = v182 ^ v166;
      v185 = 4 * v172;
      LOWORD(v185) = 4 * v172 & 0xCCCC;
      LOWORD(v164) = v184 ^ *v296 ^ v168 ^ (4 * v169 & 0xCCCC | ((unsigned __int16)v169 >> 2) & 0x3333);
      HIWORD(v168) = HIWORD(v172);
      LOWORD(v168) = (unsigned __int16)v172 >> 2;
      v297 = v164;
      v186 = v168;
      v187 = 4 * v173;
      LOWORD(v186) = v186 & 0x3333;
      v188 = v185 | v186;
      LOWORD(v187) = 4 * v173 & 0xCCCC;
      LOWORD(v130) = v296[1] ^ v130;
      v189 = v172 ^ v169 ^ v130;
      HIWORD(v169) = HIWORD(v173);
      LOWORD(v136) = v296[2] ^ v136;
      LOWORD(v169) = (unsigned __int16)v173 >> 2;
      LOWORD(v141) = v296[3] ^ v141;
      v27 = v184 ^ v189 ^ v188;
      v190 = v169;
      HIWORD(v169) = HIWORD(v175);
      LOWORD(v190) = v190 & 0x3333;
      v191 = v172 ^ v136;
      v192 = 4 * v175;
      LOWORD(v169) = ((unsigned __int16)v175 >> 2) & 0x3333;
      LOWORD(v192) = 4 * v175 & 0xCCCC;
      v29 = v173 ^ v191 ^ (v187 | v190);
      HIWORD(v191) = HIWORD(v177);
      v193 = v192 | v169;
      LOWORD(v150) = v296[4] ^ v150;
      v194 = v184 ^ v141;
      v195 = 4 * v180;
      LOWORD(v191) = ((unsigned __int16)v177 >> 2) & 0x3333;
      LOWORD(v195) = 4 * v180 & 0xCCCC;
      LODWORD(v17) = v193 ^ v175 ^ v173 ^ v194;
      v196 = 4 * v177;
      v197 = v184 ^ v150 ^ v175;
      v198 = 4 * v178;
      LOWORD(v196) = 4 * v177 & 0xCCCC;
      v199 = v196 | v191;
      HIWORD(v196) = HIWORD(v178);
      LOWORD(v198) = 4 * v178 & 0xCCCC;
      v28 = v199 ^ v177 ^ v197;
      LOWORD(v196) = ((unsigned __int16)v178 >> 2) & 0x3333;
      v200 = v198 | v196;
      v201 = v157;
      LOWORD(v201) = v296[5] ^ v157;
      v202 = v201 ^ v177;
      v203 = 4 * v184;
      LOWORD(v184) = ((unsigned __int16)v184 >> 2) & 0x3333;
      LODWORD(v18) = v178 ^ v202 ^ v200;
      HIWORD(v202) = HIWORD(v180);
      LOWORD(v203) = v203 & 0xCCCC;
      LOWORD(v202) = ((unsigned __int16)v180 >> 2) & 0x3333;
      v204 = v202 | v195;
      v205 = v160;
      LOWORD(v205) = v296[6] ^ v160;
      LODWORD(v21) = v180 ^ v205 ^ v178 ^ v204;
      v206 = v203 | v184;
      v207 = v183;
      LOWORD(v207) = v296[7] ^ v183;
      v296 += 8;
      LODWORD(v23) = v207 ^ v180 ^ v206;
    }
    while ( v296 != v298 );
    v208 = v28;
    v19 = v29;
    v16 = v27;
    LODWORD(v20) = v208;
  }
  v209 = v21 ^ v18;
  v210 = v20 ^ v23;
  v211 = v16 ^ v23;
  v212 = v23 ^ v19;
  v213 = v20 ^ v19;
  v214 = v209 ^ v297;
  v215 = v16 ^ v23 ^ v20 ^ v19;
  v216 = v16 ^ v23 ^ v20 ^ v19;
  v217 = v209 ^ v297 ^ v20;
  v218 = v16 ^ v209 ^ v297;
  v219 = v209 ^ v297 ^ v23;
  v220 = v218 ^ v23 ^ v19;
  v221 = v19;
  v222 = v215 ^ v17;
  v223 = v210;
  v224 = v222 ^ v21;
  v225 = v222 ^ v221;
  v226 = v224 ^ v210;
  v227 = v225;
  v228 = v210;
  v229 = v220;
  v230 = v224 ^ v210 ^ v209;
  v231 = v225 ^ v297;
  v232 = v225 ^ v209;
  v233 = v226 ^ v225 ^ v209;
  v234 = v225 ^ v297;
  v235 = (unsigned __int16)(v215 & v225);
  v236 = v223 & ~v224;
  v237 = v236 ^ (unsigned __int16)(v233 & v213);
  v238 = v212;
  LOWORD(v212) = v232 & v212;
  v239 = v238;
  v240 = v236 ^ v212;
  LOWORD(v223) = v226 ^ v297;
  v241 = (unsigned __int16)(v231 & v229) ^ v235 ^ v224;
  v242 = v297;
  LOWORD(v242) = v217 & v297;
  v243 = v237 ^ v241;
  v244 = v238 ^ v242;
  LOWORD(v244) = v232 ^ v244;
  v245 = v237 ^ v230 & v211 ^ v230 ^ v211 ^ v214 & ~v16;
  v246 = v240 ^ v235 ^ v244;
  v247 = v240 ^ (unsigned __int16)((v226 ^ v297) & v219) ^ v230 ^ v23 ^ v230 & (v16 ^ v23);
  v248 = v243;
  v249 = v245 & v243;
  v250 = v246 ^ v248;
  v251 = v249 ^ v247;
  v252 = v246 ^ (v249 ^ v247) & v250;
  v253 = (v249 ^ v246) & (v247 ^ v245);
  v254 = v253 ^ v247;
  v255 = (v253 ^ v249) & v247;
  v256 = v255 ^ v254 ^ v245;
  v257 = v250 ^ v252 & (v255 ^ v251);
  HIWORD(v226) = HIWORD(v254) ^ HIWORD(v252);
  LOWORD(v250) = v257 ^ v256;
  v258 = v254 & v297;
  v259 = v254 ^ v252 ^ v257 ^ v256;
  v260 = (v257 ^ v252) & v230;
  v261 = v257 & v214;
  v262 = v252 & v223;
  HIWORD(v237) = HIWORD(v256) ^ HIWORD(v254);
  v263 = v259 & v233;
  LOWORD(v259) = v213 & v259;
  v264 = v211 & (v257 ^ v252);
  v265 = v256 & v229;
  v266 = v259;
  LOWORD(v257) = v252 & v223 ^ v218 & v257;
  LOWORD(v226) = v226 & (v254 ^ v252);
  v267 = v259 ^ (v254 ^ v252) & v228;
  LOWORD(v237) = v216 & (v256 ^ v254);
  v268 = v267 ^ v261;
  v269 = v260 ^ (v256 ^ v254) & v227;
  v270 = v263 ^ v226 ^ v260;
  v271 = v270 ^ v261;
  v272 = v268 ^ (unsigned __int16)(v250 & v232) ^ v263;
  v273 = v268 ^ v265 ^ v237;
  LOWORD(v252) = v272 ^ v269 ^ v264 ^ v258 ^ v219 & v252;
  LOWORD(v256) = v234 & v256;
  LOWORD(v267) = v269 ^ v264 ^ v258 ^ v267;
  v274 = v272 ^ v257 ^ v264;
  v275 = v273 ^ v256;
  LOWORD(v273) = v270 ^ v273;
  v276 = v275 ^ v269;
  LOWORD(v254) = v252 ^ v265 ^ v217 & v254;
  v277 = v276 ^ v271;
  LOWORD(v271) = v266 ^ v250 & v239 ^ v271;
  LOWORD(v270) = ((unsigned __int8)(v257 ^ v267) ^ ((unsigned __int16)(v257 ^ v267) >> 8)) & 0xCC ^ v257 ^ v267 ^ ((unsigned __int8)((v257 ^ v267 ^ ((unsigned __int16)(v257 ^ v267) >> 8)) & 0xCC) << 8);
  HIWORD(v270) = HIWORD(v274);
  LOWORD(v267) = ((_WORD)v270 << 12) & 0xA000 | v270 & 0x5555 | ((unsigned __int16)v270 >> 4) & 0xAAA;
  LOWORD(v270) = (unsigned __int16)v274 >> 8;
  v278 = v274 ^ v270;
  LOWORD(v278) = v278 & 0xCC;
  v279 = v278 ^ v274 ^ (v278 << 8);
  LOWORD(v254) = ((unsigned __int8)((v254 ^ BYTE1(v254)) & 0xCC) << 8) ^ ((unsigned __int8)v254 ^ BYTE1(v254)) & 0xCC ^ v254;
  LOWORD(v274) = v279 & 0x5555 | ((unsigned __int16)v279 >> 4) & 0xAAA;
  LOWORD(v272) = ((_WORD)v279 << 12) & 0xA000;
  LOWORD(v257) = ((_WORD)v254 << 12) & 0xA000 | v254 & 0x5555 | ((unsigned __int16)v254 >> 4) & 0xAAA;
  LOWORD(v254) = ((unsigned __int8)(v262 ^ v258 ^ v275) ^ ((unsigned __int16)(v262 ^ v258 ^ v275) >> 8)) & 0xCC ^ v262 ^ v258 ^ v275 ^ ((unsigned __int8)((v262 ^ v258 ^ v275 ^ ((unsigned __int16)(v262 ^ v258 ^ v275) >> 8)) & 0xCC) << 8);
  LOWORD(v275) = ((_WORD)v254 << 12) & 0xA000 | v254 & 0x5555 | ((unsigned __int16)v254 >> 4) & 0xAAA;
  LOWORD(v254) = ((unsigned __int8)v276 ^ BYTE1(v276)) & 0xCC ^ v276 ^ ((unsigned __int8)((v276 ^ BYTE1(v276)) & 0xCC) << 8);
  LOWORD(v252) = ((unsigned __int8)((v271 ^ v252 ^ ((unsigned __int16)(v271 ^ v252) >> 8)) & 0xCC) << 8) ^ ((unsigned __int8)(v271 ^ v252) ^ ((unsigned __int16)(v271 ^ v252) >> 8)) & 0xCC ^ v271 ^ v252;
  HIWORD(v279) = HIWORD(v277);
  LOWORD(v279) = (unsigned __int16)v277 >> 8;
  v280 = v277 ^ v279;
  LOWORD(v280) = v280 & 0xCC;
  v281 = (v280 << 8) ^ v280 ^ v277;
  LOWORD(v280) = ((unsigned __int8)v273 ^ BYTE1(v273)) & 0xCC;
  v282 = (unsigned __int16)(v296[1] ^ (v272 | v274)) | (((((unsigned __int16)(v296[5] ^ (v252 & 0x5555 | ((unsigned __int16)v252 >> 4) & 0xAAA | ((_WORD)v252 << 12) & 0xA000)) | ((unsigned __int64)(unsigned __int16)(v296[7] ^ ((((unsigned __int16)((_WORD)v280 << 8) ^ (unsigned __int16)(v280 ^ v273)) << 12) & 0xA000 | (((_WORD)v280 << 8) ^ v280 ^ v273) & 0x5555 | ((unsigned __int16)(((_WORD)v280 << 8) ^ v280 ^ v273) >> 4) & 0xAAA)) << 16)) << 16) | (unsigned __int16)(v296[3] ^ v275)) << 16);
  v283 = (unsigned __int16)(*v296 ^ v267) | ((((((unsigned __int64)(unsigned __int16)(v296[6] ^ (((_WORD)v281 << 12) & 0xA000 | v281 & 0x5555 | ((unsigned __int16)v281 >> 4) & 0xAAA)) << 16) | (unsigned __int16)(v296[4] ^ (((_WORD)v254 << 12) & 0xA000 | v254 & 0x5555 | ((unsigned __int16)v254 >> 4) & 0xAAA))) << 16) | (unsigned __int16)(v296[2] ^ v257)) << 16);
  v284 = (v282 ^ (v283 >> 8)) & 0xFF00FF00FF00FFLL;
  v285 = v284 ^ v282;
  v286 = (v284 << 8) ^ v283;
  v287 = ((unsigned int)v286 ^ (unsigned int)(v286 >> 28)) & 0xF0F0F0F0;
  v288 = v287 ^ v286;
  v289 = v287 << 28;
  v290 = ((unsigned int)v285 ^ (unsigned int)(v285 >> 28)) & 0xF0F0F0F0;
  v291 = (((v288 ^ v289 ^ ((v288 ^ v289) >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v288 ^ v289 ^ ((v288 ^ v289) >> 14)) & 0xCCCC0000CCCCLL ^ v288 ^ v289;
  v292 = (((v290 ^ v285 ^ (v290 << 28) ^ ((v290 ^ v285 ^ (v290 << 28)) >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v290 ^ v285 ^ (v290 << 28) ^ ((v290 ^ v285 ^ (v290 << 28)) >> 14)) & 0xCCCC0000CCCCLL ^ v290 ^ v285 ^ (v290 << 28);
  v293 = (((v291 ^ (v291 >> 7)) & 0xAA00AA00AA00AALL) << 7) ^ (v291 ^ (v291 >> 7)) & 0xAA00AA00AA00AALL ^ v291;
  v294 = (v292 ^ (v292 >> 7)) & 0xAA00AA00AA00AALL ^ v292 ^ (((v292 ^ (v292 >> 7)) & 0xAA00AA00AA00AALL) << 7);
  *(_WORD *)v299 = v293;
  *(_BYTE *)(v299 + 2) = BYTE2(v293);
  *(_BYTE *)(v299 + 3) = BYTE3(v293);
  *(_BYTE *)(v299 + 4) = BYTE4(v293);
  *(_BYTE *)(v299 + 5) = BYTE5(v293);
  *(_BYTE *)(v299 + 7) = HIBYTE(v293);
  *(_BYTE *)(v299 + 6) = BYTE6(v293);
  *(_WORD *)(v299 + 8) = v294;
  *(_BYTE *)(v299 + 10) = BYTE2(v294);
  *(_BYTE *)(v299 + 11) = BYTE3(v294);
  *(_BYTE *)(v299 + 12) = BYTE4(v294);
  *(_BYTE *)(v299 + 13) = BYTE5(v294);
  result = v294 >> 56;
  *(_BYTE *)(v299 + 15) = result;
  *(_BYTE *)(v299 + 14) = ((v292 ^ (v292 >> 7)) & 0xAA00AA00AA00AALL ^ v292 ^ (((v292 ^ (v292 >> 7)) & 0xAA00AA00AA00AALL) << 7)) >> 48;
  return result;
}

unsigned __int64 __fastcall sub_58830(__int64 a1, __m128i *a2, int a3)
{
  unsigned __int64 v3; // r12
  __m128i *v4; // r14
  unsigned __int64 v5; // rax
  char v6; // dh^5
  __int64 v7; // rax
  unsigned __int64 v8; // rax
  unsigned __int64 result; // rax

  v3 = (unsigned __int64)a2->m128i_u64 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    do
    {
      v5 = v4->m128i_i64[0] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 85) << 24) | *(unsigned __int8 *)(a1 - 88) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 87) << 8));
      *(_BYTE *)(a1 - 88) ^= LOBYTE(v4->m128i_i64[0]);
      *(_BYTE *)(a1 - 87) = BYTE1(v5);
      *(_BYTE *)(a1 - 86) = BYTE2(v5);
      *(_BYTE *)(a1 - 85) = BYTE3(v5);
      *(_BYTE *)(a1 - 84) = BYTE4(v5);
      *(_BYTE *)(a1 - 83) = BYTE5(v5);
      v6 = BYTE6(v5);
      *(_BYTE *)(a1 - 81) = HIBYTE(v5);
      v7 = *(unsigned __int8 *)(a1 - 79);
      *(_BYTE *)(a1 - 82) = v6;
      ++v4;
      v8 = v4[-1].m128i_i64[1] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 77) << 24) | *(unsigned __int8 *)(a1 - 80) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 78) << 16) | (v7 << 8));
      *(_WORD *)(a1 - 80) = v8;
      *(_BYTE *)(a1 - 78) = BYTE2(v8);
      *(_BYTE *)(a1 - 77) = BYTE3(v8);
      *(_BYTE *)(a1 - 76) = BYTE4(v8);
      *(_BYTE *)(a1 - 75) = BYTE5(v8);
      *(_BYTE *)(a1 - 74) = BYTE6(v8);
      *(_BYTE *)(a1 - 73) = HIBYTE(v8);
      result = sub_57940(a1 - 1296 + 1208, (_QWORD *)(a1 - 1296 + 1208), a1 - 1296);
      v4[-1] = _mm_loadu_si128((const __m128i *)(a1 - 88));
    }
    while ( v3 > (unsigned __int64)v4 );
  }
  return result;
}

unsigned __int64 __fastcall sub_589D0(__int64 a1, __m128i *a2, int a3)
{
  unsigned __int64 v3; // r12
  __m128i *v4; // r14
  unsigned __int64 v5; // rax
  char v6; // dh^5
  __int64 v7; // rax
  unsigned __int64 v8; // rax
  unsigned __int64 result; // rax

  v3 = (unsigned __int64)a2->m128i_u64 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    do
    {
      v5 = v4->m128i_i64[0] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 85) << 24) | *(unsigned __int8 *)(a1 - 88) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 87) << 8));
      *(_BYTE *)(a1 - 88) ^= LOBYTE(v4->m128i_i64[0]);
      *(_BYTE *)(a1 - 87) = BYTE1(v5);
      *(_BYTE *)(a1 - 86) = BYTE2(v5);
      *(_BYTE *)(a1 - 85) = BYTE3(v5);
      *(_BYTE *)(a1 - 84) = BYTE4(v5);
      *(_BYTE *)(a1 - 83) = BYTE5(v5);
      v6 = BYTE6(v5);
      *(_BYTE *)(a1 - 81) = HIBYTE(v5);
      v7 = *(unsigned __int8 *)(a1 - 79);
      *(_BYTE *)(a1 - 82) = v6;
      ++v4;
      v8 = v4[-1].m128i_i64[1] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 77) << 24) | *(unsigned __int8 *)(a1 - 80) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 78) << 16) | (v7 << 8));
      *(_WORD *)(a1 - 80) = v8;
      *(_BYTE *)(a1 - 78) = BYTE2(v8);
      *(_BYTE *)(a1 - 77) = BYTE3(v8);
      *(_BYTE *)(a1 - 76) = BYTE4(v8);
      *(_BYTE *)(a1 - 75) = BYTE5(v8);
      *(_BYTE *)(a1 - 74) = BYTE6(v8);
      *(_BYTE *)(a1 - 73) = HIBYTE(v8);
      result = sub_57940(a1 - 1296 + 1208, (_QWORD *)(a1 - 1296 + 1208), a1 - 1296);
      v4[-1] = _mm_loadu_si128((const __m128i *)(a1 - 88));
    }
    while ( v3 > (unsigned __int64)v4 );
  }
  return result;
}

unsigned __int64 __fastcall sub_58B70(__int64 a1, __m128i *a2, int a3)
{
  unsigned __int64 v3; // r12
  __m128i *v4; // r14
  unsigned __int64 v5; // rax
  char v6; // dh^5
  __int64 v7; // rax
  unsigned __int64 v8; // rax
  unsigned __int64 result; // rax

  v3 = (unsigned __int64)a2->m128i_u64 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    do
    {
      v5 = v4->m128i_i64[0] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 85) << 24) | *(unsigned __int8 *)(a1 - 88) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 87) << 8));
      *(_BYTE *)(a1 - 88) ^= LOBYTE(v4->m128i_i64[0]);
      *(_BYTE *)(a1 - 87) = BYTE1(v5);
      *(_BYTE *)(a1 - 86) = BYTE2(v5);
      *(_BYTE *)(a1 - 85) = BYTE3(v5);
      *(_BYTE *)(a1 - 84) = BYTE4(v5);
      *(_BYTE *)(a1 - 83) = BYTE5(v5);
      v6 = BYTE6(v5);
      *(_BYTE *)(a1 - 81) = HIBYTE(v5);
      v7 = *(unsigned __int8 *)(a1 - 79);
      *(_BYTE *)(a1 - 82) = v6;
      ++v4;
      v8 = v4[-1].m128i_i64[1] ^ (((unsigned __int64)*(unsigned __int8 *)(a1 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 77) << 24) | *(unsigned __int8 *)(a1 - 80) | ((unsigned __int64)*(unsigned __int8 *)(a1 - 78) << 16) | (v7 << 8));
      *(_WORD *)(a1 - 80) = v8;
      *(_BYTE *)(a1 - 78) = BYTE2(v8);
      *(_BYTE *)(a1 - 77) = BYTE3(v8);
      *(_BYTE *)(a1 - 76) = BYTE4(v8);
      *(_BYTE *)(a1 - 75) = BYTE5(v8);
      *(_BYTE *)(a1 - 74) = BYTE6(v8);
      *(_BYTE *)(a1 - 73) = HIBYTE(v8);
      result = sub_57940(a1 - 1296 + 1208, (_QWORD *)(a1 - 1296 + 1208), a1 - 1296);
      v4[-1] = _mm_loadu_si128((const __m128i *)(a1 - 88));
    }
    while ( v3 > (unsigned __int64)v4 );
  }
  return result;
}

unsigned __int64 __fastcall sub_58D10(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rcx
  signed __int64 v5; // rdx
  signed __int64 v6; // rdi
  signed __int64 v7; // rdx
  _QWORD *v8; // r8
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdi
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rdi
  signed __int64 v15; // rcx
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rdx
  __int64 v18; // r9
  unsigned __int64 v19; // r10
  __int64 v20; // r12
  __int64 v21; // rbp
  __int64 v22; // rbx
  __int64 v23; // r11
  unsigned __int64 v24; // rdi
  __int64 v25; // r15
  signed __int64 v26; // rcx
  unsigned __int64 v27; // rdx
  signed __int64 v28; // rax
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // rax
  unsigned __int64 v32; // rdx
  __int64 v33; // r15
  unsigned __int64 v34; // rax
  signed __int64 v35; // r15
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // rdx
  int v38; // eax
  _QWORD *v39; // r14
  __int64 v40; // r9
  __int64 v41; // rbp
  __int64 v42; // r12
  __int64 v43; // rbx
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // rcx
  __int64 v46; // r8
  __int64 v47; // ST08_8
  unsigned __int64 v48; // ST10_8
  __int64 v49; // rcx
  __int64 v50; // r15
  __int64 v51; // r9
  __int64 v52; // ST38_8
  __int64 v53; // ST28_8
  unsigned __int64 v54; // rsi
  __int64 v55; // r10
  __int64 v56; // rcx
  __int64 v57; // ST48_8
  __int64 v58; // rax
  __int64 v59; // r14
  __int64 v60; // ST40_8
  __int64 v61; // ST90_8
  __int64 v62; // rdx
  __int64 v63; // ST30_8
  __int64 v64; // r13
  __int64 v65; // ST00_8
  __int64 v66; // rdx
  __int64 v67; // rbp
  __int64 v68; // ST20_8
  __int64 v69; // rdi
  __int64 v70; // ST88_8
  __int64 v71; // ST18_8
  __int64 v72; // rbx
  __int64 v73; // r10
  __int64 v74; // r9
  __int64 v75; // rdi
  __int64 v76; // r11
  __int64 v77; // rbp
  __int64 v78; // r14
  __int64 v79; // rdi
  __int64 v80; // r11
  __int64 v81; // rbx
  __int64 v82; // r8
  __int64 v83; // r9
  __int64 v84; // r13
  __int64 v85; // r11
  __int64 v86; // r14
  __int64 v87; // r12
  __int64 v88; // rbx
  __int64 v89; // ST58_8
  __int64 v90; // ST50_8
  __int64 v91; // r10
  __int64 v92; // rdi
  __int64 v93; // r12
  __int64 v94; // r11
  __int64 v95; // ST68_8
  __int64 v96; // ST60_8
  __int64 v97; // r10
  __int64 v98; // rbp
  __int64 v99; // rdi
  __int64 v100; // r12
  __int64 v101; // rsi
  __int64 v102; // r9
  __int64 v103; // rbp
  __int64 v104; // rcx
  __int64 v105; // ST08_8
  __int64 v106; // ST30_8
  __int64 v107; // rdx
  __int64 v108; // r15
  __int64 v109; // rdx
  unsigned __int64 v110; // ST10_8
  __int64 v111; // rax
  unsigned __int64 v112; // r14
  unsigned __int64 v113; // rdx
  __int64 v114; // r13
  unsigned __int64 v115; // ST18_8
  __int64 v116; // rbx
  unsigned __int64 v117; // r10
  unsigned __int64 v118; // r13
  unsigned __int64 v119; // r15
  unsigned __int64 v120; // rbp
  signed __int64 v121; // rcx
  unsigned __int64 v122; // rdx
  unsigned __int64 v123; // r9
  unsigned __int64 v124; // r15
  unsigned __int64 v125; // rdi
  unsigned __int64 v126; // rbp
  signed __int64 v127; // rdx
  unsigned __int64 v128; // r10
  unsigned __int64 v129; // rsi
  signed __int64 v130; // rcx
  unsigned __int64 v131; // rax
  unsigned __int64 v132; // r13
  unsigned __int64 v133; // rcx
  unsigned __int64 v134; // rdx
  __int64 v135; // r15
  unsigned __int64 v136; // rbx
  unsigned __int64 v137; // r11
  unsigned __int64 v138; // r14
  unsigned __int64 v139; // rbp
  unsigned __int64 v140; // r15
  unsigned __int64 v141; // r9
  unsigned __int64 v142; // rdi
  unsigned __int64 v143; // r8
  unsigned __int64 v144; // r9
  unsigned __int64 v145; // r15
  unsigned __int64 v146; // ST48_8
  unsigned __int64 v147; // ST38_8
  unsigned __int64 v148; // rbx
  unsigned __int64 v149; // ST40_8
  unsigned __int64 v150; // rax
  unsigned __int64 v151; // rsi
  unsigned __int64 v152; // rcx
  unsigned __int64 v153; // rdx
  unsigned __int128 v154; // ST18_16
  unsigned __int64 v155; // rbp
  unsigned __int64 v156; // r11
  unsigned __int64 v157; // r10
  unsigned __int64 v158; // r15
  unsigned __int64 v159; // rdi
  unsigned __int64 v160; // ST00_8
  unsigned __int64 v161; // r8
  unsigned __int64 v162; // ST28_8
  unsigned __int64 v163; // r13
  unsigned __int64 v164; // rbx
  unsigned __int64 v165; // r9
  unsigned __int64 v166; // ST58_8
  unsigned __int64 v167; // ST60_8
  unsigned __int64 v168; // r13
  unsigned __int64 v169; // ST70_8
  unsigned __int64 v170; // ST30_8
  unsigned __int64 v171; // ST78_8
  unsigned __int64 v172; // ST80_8
  unsigned __int64 v173; // ST88_8
  unsigned __int64 v174; // ST90_8
  unsigned __int64 v175; // rcx
  unsigned __int64 v176; // r8
  unsigned __int64 v177; // ST98_8
  unsigned __int64 v178; // r15
  unsigned __int64 v179; // rbp
  unsigned __int64 v180; // STA0_8
  unsigned __int64 v181; // STA8_8
  __int64 v182; // r11
  unsigned __int64 v183; // r9
  unsigned __int64 v184; // r10
  unsigned __int64 v185; // STB8_8
  unsigned __int64 v186; // r14
  unsigned __int64 v187; // rdi
  unsigned __int64 v188; // rsi
  unsigned __int64 v189; // rdx
  unsigned __int64 v190; // r12
  unsigned __int64 v191; // r13
  unsigned __int64 v192; // r8
  unsigned __int64 v193; // rax
  unsigned __int64 v194; // rsi
  unsigned __int64 v195; // ST30_8
  unsigned __int64 v196; // rbp
  unsigned __int64 v197; // rdx
  unsigned __int64 v198; // r11
  unsigned __int64 v199; // rsi
  unsigned __int64 v200; // ST00_8
  __int64 v201; // rax
  unsigned __int64 v202; // r12
  unsigned __int64 v203; // rcx
  unsigned __int64 v204; // ST40_8
  unsigned __int64 v205; // ST48_8
  unsigned __int64 v206; // r10
  unsigned __int64 v207; // ST50_8
  unsigned __int64 v208; // ST60_8
  __int64 v209; // ST58_8
  unsigned __int64 v210; // ST68_8
  unsigned __int64 v211; // ST80_8
  unsigned __int64 v212; // rbp
  unsigned __int64 v213; // r14
  unsigned __int64 v214; // rax
  unsigned __int64 v215; // r8
  unsigned __int64 v216; // rdx
  unsigned __int64 v217; // rax
  __int64 v218; // rbx
  unsigned __int64 v219; // ST38_8
  unsigned __int64 v220; // rdi
  unsigned __int64 v221; // ST70_8
  unsigned __int64 v222; // r15
  unsigned __int64 v223; // ST78_8
  unsigned __int64 v224; // rdi
  unsigned __int64 v225; // r13
  unsigned __int64 v226; // rax
  unsigned __int64 v227; // r8
  unsigned __int64 v228; // r13
  __int64 v229; // rbp
  unsigned __int64 v230; // rbx
  unsigned __int64 v231; // rax
  unsigned __int64 v232; // rdi
  unsigned __int64 v233; // r8
  unsigned __int64 v234; // rdx
  unsigned __int64 v235; // r15
  unsigned __int64 v236; // r13
  unsigned __int64 v237; // r9
  unsigned __int64 v238; // rbp
  unsigned __int64 v239; // rdx
  unsigned __int64 v240; // rbx
  __int64 v241; // r8
  unsigned __int64 v242; // r10
  unsigned __int64 v243; // r13
  unsigned __int64 v244; // rax
  unsigned __int64 v245; // r15
  unsigned __int64 v246; // ST88_8
  unsigned __int64 v247; // ST70_8
  unsigned __int64 v248; // ST28_8
  unsigned __int64 v249; // rdx
  __int64 v250; // ST30_8
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // r11
  unsigned __int64 v253; // rsi
  unsigned __int64 v254; // r8
  unsigned __int64 v255; // rax
  unsigned __int64 v256; // r12
  unsigned __int64 v257; // ST40_8
  unsigned __int64 v258; // r9
  unsigned __int64 v259; // r12
  __int64 v260; // ST50_8
  unsigned __int64 v261; // rax
  __int64 v262; // r10
  unsigned __int64 v263; // rax
  unsigned __int64 v264; // rbp
  __int64 v265; // ST58_8
  unsigned __int64 v266; // r10
  unsigned __int64 v267; // r15
  unsigned __int64 v268; // r9
  unsigned __int64 v269; // rax
  unsigned __int64 v270; // r13
  unsigned __int64 v271; // rbx
  unsigned __int64 v272; // r13
  unsigned __int64 v273; // r11
  signed __int64 v274; // rsi
  unsigned __int64 v275; // rcx
  unsigned __int64 v276; // rax
  unsigned __int64 v277; // r8
  unsigned __int64 v278; // rax
  unsigned __int64 v279; // rdx
  unsigned __int64 v280; // r13
  unsigned __int64 v281; // r9
  __int64 v282; // r12
  unsigned __int64 v283; // r8
  unsigned __int64 v284; // r9
  unsigned __int64 v285; // rdi
  unsigned __int64 v286; // r10
  unsigned __int64 v287; // rsi
  unsigned __int64 result; // rax
  unsigned __int64 v289; // rdx
  unsigned __int64 v290; // r15
  unsigned __int64 v291; // rbx
  unsigned __int64 v292; // rcx
  unsigned __int64 v293; // rbp
  unsigned __int64 v294; // rcx
  unsigned __int64 v295; // r11
  __int64 v296; // rbx
  unsigned __int64 v297; // rbp
  __int64 v298; // r11
  unsigned __int64 v299; // rcx
  unsigned __int64 v300; // r11
  unsigned __int64 v301; // rbx
  signed __int64 v302; // rcx
  unsigned __int64 v303; // rbp
  unsigned __int64 v304; // rcx
  __int64 v305; // [rsp+0h] [rbp-128h]
  unsigned __int64 v306; // [rsp+0h] [rbp-128h]
  _QWORD *v307; // [rsp+8h] [rbp-120h]
  __int128 v308; // [rsp+18h] [rbp-110h]
  int v309; // [rsp+78h] [rbp-B0h]
  signed __int64 v310; // [rsp+80h] [rbp-A8h]
  signed __int64 v311; // [rsp+C0h] [rbp-68h]
  signed __int64 v312; // [rsp+D0h] [rbp-58h]
  __int64 v313; // [rsp+E0h] [rbp-48h]
  _QWORD *v314; // [rsp+E8h] [rbp-40h]
  __int64 v315; // [rsp+F0h] [rbp-38h]

  v3 = a2[1];
  *(_QWORD *)&v308 = a3;
  v313 = a1;
  v4 = (((*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL) << 7) ^ *a2 ^ (*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL;
  v5 = (v3 ^ (v3 >> 7)) & 0xAA00AA00AA00AALL;
  v6 = v5;
  v7 = v3 ^ v5;
  v8 = a2;
  v9 = (v4 ^ (v4 >> 14)) & 0xCCCC0000CCCCLL ^ v4 ^ (((v4 ^ (v4 >> 14)) & 0xCCCC0000CCCCLL) << 14);
  v10 = (v7 ^ (v6 << 7) ^ ((v7 ^ (unsigned __int64)(v6 << 7)) >> 14)) & 0xCCCC0000CCCCLL ^ v7 ^ (v6 << 7) ^ (((v7 ^ (v6 << 7) ^ ((v7 ^ (unsigned __int64)(v6 << 7)) >> 14)) & 0xCCCC0000CCCCLL) << 14);
  v11 = ((unsigned int)v9 ^ (unsigned int)(v9 >> 28)) & 0xF0F0F0F0;
  v12 = v11 ^ v9 ^ (v11 << 28);
  v13 = ((unsigned int)v10 ^ (unsigned int)(v10 >> 28)) & 0xF0F0F0F0;
  v14 = v13 ^ v10 ^ (v13 << 28);
  v15 = (v14 ^ (v12 >> 8)) & 0xFF00FF00FF00FFLL;
  v16 = v15 ^ v14;
  v17 = (v15 << 8) ^ v12;
  v18 = (unsigned __int16)v17;
  v19 = v17 >> 48;
  v20 = (unsigned __int16)v16;
  v305 = WORD1(v17);
  v21 = WORD2(v17);
  v22 = WORD1(v16);
  v23 = WORD2(v16);
  v24 = v16 >> 48;
  do
  {
    v8 += 2;
    v25 = v8[1];
    v26 = (*v8 ^ (*v8 >> 7)) & 0xAA00AA00AA00AALL;
    v27 = *v8 ^ v26 ^ (v26 << 7);
    v28 = (v25 ^ (v8[1] >> 7)) & 0xAA00AA00AA00AALL;
    v29 = (((v27 ^ (v27 >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v27 ^ (v27 >> 14)) & 0xCCCC0000CCCCLL ^ v27;
    v30 = (((v25 ^ v28 ^ (v28 << 7) ^ ((v25 ^ v28 ^ (unsigned __int64)(v28 << 7)) >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v25 ^ v28 ^ (v28 << 7) ^ ((v25 ^ v28 ^ (unsigned __int64)(v28 << 7)) >> 14)) & 0xCCCC0000CCCCLL ^ v25 ^ v28 ^ (v28 << 7);
    v31 = ((unsigned int)v29 ^ (unsigned int)(v29 >> 28)) & 0xF0F0F0F0;
    v32 = (v31 << 28) ^ v31 ^ v29;
    v33 = ((unsigned int)v30 ^ (unsigned int)(v30 >> 28)) & 0xF0F0F0F0;
    v34 = v33 ^ v30 ^ (v33 << 28);
    v35 = (v34 ^ (v32 >> 8)) & 0xFF00FF00FF00FFLL;
    v36 = v35 ^ v34;
    v37 = (v35 << 8) ^ v32;
    v18 |= (unsigned __int64)(unsigned __int16)v37 << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v305 |= (unsigned __int64)WORD1(v37) << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v19 |= v37 >> 48 << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v21 |= (unsigned __int64)WORD2(v37) << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v20 |= (unsigned __int64)(unsigned __int16)v36 << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v22 |= (unsigned __int64)WORD1(v36) << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v23 |= (unsigned __int64)WORD2(v36) << ((unsigned __int8)v8 - (unsigned __int8)a2);
    v24 |= v36 >> 48 << ((unsigned __int8)v8 - (unsigned __int8)a2);
  }
  while ( v8 != a2 + 6 );
  v38 = *(_DWORD *)(v308 + 1200);
  v309 = v38;
  v39 = (_QWORD *)(v308 + 8LL * (unsigned int)(8 * v38));
  v40 = *v39 ^ v18;
  v41 = v39[4] ^ v21;
  v42 = v39[1] ^ v20;
  v43 = v39[3] ^ v22;
  v44 = v39[7] ^ v24;
  v45 = v41 ^ v39[6] ^ v19;
  v310 = v308 + 8LL * (unsigned int)(8 * v38);
  v46 = v23 ^ v39[5];
  v47 = v43 ^ v40;
  v48 = v45;
  v49 = v45 ^ v42 ^ v40;
  v50 = v41 ^ v43 ^ v40;
  v51 = v49;
  v52 = v50 ^ v42;
  v53 = v41 ^ v43 ^ v49;
  v54 = v44 ^ v41 ^ v39[6] ^ v19;
  v55 = v44 ^ v53;
  v56 = v46 ^ v49;
  v57 = v54 ^ v43;
  v58 = v55 ^ v39[2] ^ v305;
  v59 = v41 ^ v43;
  v60 = v54 ^ v41;
  v61 = v55 ^ v43;
  v62 = v58 ^ v56 ^ v41 ^ v43;
  v63 = v41 ^ v44;
  v64 = (v56 ^ v50) & (v50 ^ v42);
  v65 = v62;
  v66 = v54 ^ v62;
  v67 = v66 & (v55 ^ v43);
  v68 = v59;
  v69 = v59 & ~v58;
  v70 = v66 ^ v56 ^ v50;
  v71 = v51;
  v72 = v69 ^ v70 & (v54 ^ v43);
  v73 = v69 ^ ~v47 & v60;
  v74 = v73 ^ v67 ^ v47 ^ v65 & v51;
  v75 = v72 ^ v67 ^ v58 ^ v54 & v63;
  v76 = v59 ^ v46;
  v77 = v74 ^ v75;
  v78 = v72 ^ v64 ^ v56 ^ v50 & v48 ^ v42;
  v79 = v78 & v75;
  v80 = v73 ^ v64 ^ v56 & v53 ^ v76;
  v81 = v79 ^ v80;
  v82 = v74 ^ (v79 ^ v80) & v77;
  v83 = (v80 ^ v78) & (v79 ^ v74);
  v84 = v83 ^ v80;
  v85 = (v79 ^ v83) & v80;
  v86 = v85 ^ v84 ^ v78;
  v87 = v81;
  v88 = v86 ^ v84;
  v89 = v86 & v54;
  v90 = (v86 ^ v84) & v66;
  v91 = v77 ^ v82 & (v85 ^ v87);
  v92 = v91 ^ v82;
  v93 = v91 ^ v86;
  v94 = v91 & v50;
  v95 = (v91 ^ v82) & (v56 ^ v50);
  v96 = v84 & v65;
  v97 = v48 & v91;
  v98 = v93;
  v99 = v52 & v92;
  v100 = v84 ^ v82;
  v101 = v98 & (v60 ^ v47);
  v102 = v84 ^ v82 ^ v98;
  v103 = v60 & v98;
  v104 = v82 & v56;
  v105 = v63 & v86;
  v106 = v84 & v71;
  v107 = v102 & v57 ^ v99 ^ v101 ^ v97 ^ (v84 ^ v82) & v58;
  v108 = v107 ^ v90;
  v109 = v95 ^ v107;
  v110 = v108 ^ v84 & v65;
  v111 = v109 ^ v94;
  v112 = v104 ^ v109;
  v113 = v109 ^ v94 ^ v101 ^ v70 & v102;
  v114 = v111 ^ v105 ^ v89 ^ v53 & v82 ^ (v65 ^ v71) & v84;
  v115 = v114 ^ v97;
  v116 = v103 ^ v106 ^ v61 & v88;
  v117 = v116 ^ v68 & v100;
  v118 = v99 ^ v102 & v57 ^ v116 ^ v114;
  v119 = v104 ^ v89 ^ v94 ^ v108;
  v120 = v113 ^ v102 & v57 ^ v95 ^ v90 ^ v105 ^ v106 ^ v96 ^ v104 ^ v103;
  v121 = (v117 ^ (v117 >> 8)) & 0xCC00CC00CC00CCLL;
  v306 = ((v121 << 8) ^ v121 ^ v117) & 0x5555555555555555LL | (((v121 << 8) ^ v121 ^ v117) >> 12) & 0xA000A000A000ALL | 16 * ((v121 << 8) ^ v121 ^ v117) & 0xAAA0AAA0AAA0AAA0LL;
  v122 = (((v113 ^ (v113 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v113 ^ (v113 >> 8)) & 0xCC00CC00CC00CCLL ^ v113;
  v123 = v122 & 0x5555555555555555LL | (v122 >> 12) & 0xA000A000A000ALL | 16 * v122 & 0xAAA0AAA0AAA0AAA0LL;
  v124 = (((v119 ^ (v119 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v119 ^ (v119 >> 8)) & 0xCC00CC00CC00CCLL ^ v119;
  v125 = v124 & 0x5555555555555555LL | (v124 >> 12) & 0xA000A000A000ALL | 16 * v124 & 0xAAA0AAA0AAA0AAA0LL;
  v126 = (((v120 ^ (v120 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v120 ^ (v120 >> 8)) & 0xCC00CC00CC00CCLL ^ v120;
  v127 = (v110 ^ (v110 >> 8)) & 0xCC00CC00CC00CCLL;
  v128 = v126 & 0x5555555555555555LL | (v126 >> 12) & 0xA000A000A000ALL | 16 * v126 & 0xAAA0AAA0AAA0AAA0LL;
  v129 = (v110 ^ v127 ^ (v127 << 8)) & 0x5555555555555555LL | ((v110 ^ v127 ^ (v127 << 8)) >> 12) & 0xA000A000A000ALL | 16 * (v110 ^ v127 ^ (v127 << 8)) & 0xAAA0AAA0AAA0AAA0LL;
  v130 = (v115 ^ (v115 >> 8)) & 0xCC00CC00CC00CCLL;
  v131 = (v115 ^ v130 ^ (v130 << 8)) & 0x5555555555555555LL | ((v115 ^ v130 ^ (v130 << 8)) >> 12) & 0xA000A000A000ALL | 16 * (v115 ^ v130 ^ (v130 << 8)) & 0xAAA0AAA0AAA0AAA0LL;
  v132 = (((v118 ^ (v118 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v118 ^ (v118 >> 8)) & 0xCC00CC00CC00CCLL ^ v118;
  v133 = v132 & 0x5555555555555555LL | (v132 >> 12) & 0xA000A000A000ALL | 16 * v132 & 0xAAA0AAA0AAA0AAA0LL;
  v134 = (v112 ^ (v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL ^ (((v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) & 0x5555555555555555LL | ((v112 ^ (v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL ^ (((v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) >> 12) & 0xA000A000A000ALL | 16 * (v112 ^ (v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL ^ (((v112 ^ (v112 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) & 0xAAA0AAA0AAA0AAA0LL;
  v314 = (_QWORD *)(v310 - 64);
  if ( v309 != 1 )
  {
    v135 = (unsigned int)(v309 - 2);
    v312 = 2814792717434890LL;
    v136 = v306;
    v315 = v135;
    v307 = (_QWORD *)(v310 - 64);
    v137 = v126 & 0x5555555555555555LL | (v126 >> 12) & 0xA000A000A000ALL | 16 * v126 & 0xAAA0AAA0AAA0AAA0LL;
    v138 = v125;
    v139 = v131;
    v311 = v310 - (v135 << 6) - 128;
    v140 = v123;
    v141 = v134;
    do
    {
      v142 = v140 ^ v307[1];
      v143 = v307[4] ^ v129;
      v144 = v307[7] ^ v141;
      v145 = v137 ^ v307[3];
      v146 = v136 ^ *v307;
      v147 = v138 ^ v307[2];
      v148 = v133 ^ v307[6];
      v149 = v145;
      v150 = v139 ^ v307[5];
      v151 = v144 ^ v145;
      v152 = v142;
      v153 = v144 ^ v146;
      v154 = __PAIR__(v148, v142);
      v155 = v142 ^ v146;
      v156 = v144 ^ v147;
      v157 = v144 ^ v148;
      v158 = v148 ^ v142;
      v159 = v150 ^ v148;
      v160 = v143;
      v161 = v150 ^ v143;
      v162 = v144;
      v163 = v150 ^ v148 ^ v144 ^ v146;
      v164 = v144 ^ v147 ^ v148;
      v165 = v164 ^ v161 ^ v151;
      v166 = v158;
      v167 = v163 ^ ((v163 >> 1) & 0x7777777777777777LL | 8 * v163 & 0x8888888888888888LL);
      v168 = v150 ^ v155 ^ (((v150 ^ v155) >> 1) & 0x7777777777777777LL | 8 * (v150 ^ v155) & 0x8888888888888888LL);
      v169 = (((v157 ^ v153 ^ v152 ^ v147) >> 1) & 0x7777777777777777LL | 8 * (v157 ^ v153 ^ v152 ^ v147) & 0x8888888888888888LL) ^ v157 ^ v153 ^ v152 ^ v147;
      v170 = v158 ^ v153 ^ v156 ^ v150 ^ v149 ^ (((v158 ^ v153 ^ v156 ^ v150 ^ v149) >> 1) & 0x7777777777777777LL | 8 * (v158 ^ v153 ^ v156 ^ v150 ^ v149) & 0x8888888888888888LL);
      v171 = v165 ^ v158 ^ (((v165 ^ v158) >> 1) & 0x7777777777777777LL | 8 * (v165 ^ v158) & 0x8888888888888888LL);
      v172 = v165 ^ ((v165 >> 1) & 0x7777777777777777LL | 8 * v165 & 0x8888888888888888LL);
      v173 = v160 ^ v151 ^ v159 ^ (((v160 ^ v151 ^ v159) >> 1) & 0x7777777777777777LL | 8 * (v160 ^ v151 ^ v159) & 0x8888888888888888LL);
      v174 = v157 ^ v161 ^ (((v157 ^ v161) >> 1) & 0x7777777777777777LL | 8 * (v157 ^ v161) & 0x8888888888888888LL);
      v175 = v162 ^ ((v162 >> 1) & 0x7777777777777777LL | 8 * v162 & 0x8888888888888888LL);
      v176 = v153 ^ ((v153 >> 1) & 0x7777777777777777LL | 8 * v153 & 0x8888888888888888LL);
      v177 = v154 ^ (((unsigned __int64)v154 >> 1) & 0x7777777777777777LL | 8 * v154 & 0x8888888888888888LL);
      v178 = v156 ^ ((v156 >> 1) & 0x7777777777777777LL | 8 * v156 & 0x8888888888888888LL);
      v179 = v151 ^ ((v151 >> 1) & 0x7777777777777777LL | 8 * v151 & 0x8888888888888888LL);
      v180 = v160 ^ ((v160 >> 1) & 0x7777777777777777LL | 8 * v160 & 0x8888888888888888LL);
      v181 = v150 ^ ((v150 >> 1) & 0x7777777777777777LL | 8 * v150 & 0x8888888888888888LL);
      v182 = *((_QWORD *)&v154 + 1);
      v183 = v182 ^ ((*((_QWORD *)&v154 + 1) >> 2) & 0x3333333333333333LL | 4 * v182 & 0xCCCCCCCCCCCCCCCCLL);
      v184 = ((v157 >> 2) & 0x3333333333333333LL | 4 * v157 & 0xCCCCCCCCCCCCCCCCLL) ^ v157;
      v185 = v153 ^ ((v153 >> 2) & 0x3333333333333333LL | 4 * v153 & 0xCCCCCCCCCCCCCCCCLL);
      v186 = v166 ^ ((v166 >> 2) & 0x3333333333333333LL | 4 * v166 & 0xCCCCCCCCCCCCCCCCLL);
      v187 = v164 ^ ((v164 >> 2) & 0x3333333333333333LL | 4 * v164 & 0xCCCCCCCCCCCCCCCCLL);
      v188 = ((v151 >> 2) & 0x3333333333333333LL | 4 * v151 & 0xCCCCCCCCCCCCCCCCLL) ^ v151;
      v189 = v150 ^ ((v150 >> 2) & 0x3333333333333333LL | 4 * v150 & 0xCCCCCCCCCCCCCCCCLL);
      v190 = ((v167 >> 2) & 0x3333333333333333LL | 4 * v167 & 0xCCCCCCCCCCCCCCCCLL) ^ ((v175 >> 2) & 0x3333333333333333LL | 4 * v175 & 0xCCCCCCCCCCCCCCCCLL) ^ v167 ^ v146 ^ ((v183 >> 1) & 0x7777777777777777LL | 8 * v183 & 0x8888888888888888LL);
      *(_QWORD *)&v154 = ((v168 >> 2) & 0x3333333333333333LL | 4 * v168 & 0xCCCCCCCCCCCCCCCCLL) ^ (8 * v184 & 0x8888888888888888LL | (v184 >> 1) & 0x7777777777777777LL) ^ v168 ^ v154 ^ (4 * v176 & 0xCCCCCCCCCCCCCCCCLL | (v176 >> 2) & 0x3333333333333333LL);
      v191 = ((v186 >> 1) & 0x7777777777777777LL | 8 * v186 & 0x8888888888888888LL) ^ v149 ^ v170 ^ (4 * v178 & 0xCCCCCCCCCCCCCCCCLL | (v178 >> 2) & 0x3333333333333333LL) ^ ((v170 >> 2) & 0x3333333333333333LL | 4 * v170 & 0xCCCCCCCCCCCCCCCCLL);
      v192 = (8 * v187 & 0x8888888888888888LL | (v187 >> 1) & 0x7777777777777777LL) ^ v160 ^ v171 ^ (4 * v179 & 0xCCCCCCCCCCCCCCCCLL | (v179 >> 2) & 0x3333333333333333LL) ^ (4 * v171 & 0xCCCCCCCCCCCCCCCCLL | (v171 >> 2) & 0x3333333333333333LL);
      v193 = (8 * v188 & 0x8888888888888888LL | (v188 >> 1) & 0x7777777777777777LL) ^ v172 ^ ((v180 >> 2) & 0x3333333333333333LL | 4 * v180 & 0xCCCCCCCCCCCCCCCCLL) ^ v150;
      v194 = v182 ^ ((*((_QWORD *)&v154 + 1) >> 1) & 0x7777777777777777LL | 8 * v182 & 0x8888888888888888LL);
      v195 = ((v172 >> 2) & 0x3333333333333333LL | 4 * v172 & 0xCCCCCCCCCCCCCCCCLL) ^ v193;
      v196 = ((v189 >> 1) & 0x7777777777777777LL | 8 * v189 & 0x8888888888888888LL) ^ ((v194 >> 2) & 0x3333333333333333LL | 4 * v194 & 0xCCCCCCCCCCCCCCCCLL) ^ v174 ^ v162 ^ (4 * v174 & 0xCCCCCCCCCCCCCCCCLL | (v174 >> 2) & 0x3333333333333333LL);
      v197 = v160 ^ ((v160 >> 2) & 0x3333333333333333LL | 4 * v160 & 0xCCCCCCCCCCCCCCCCLL);
      v198 = v192 ^ ((v173 >> 2) & 0x3333333333333333LL | 4 * v173 & 0xCCCCCCCCCCCCCCCCLL) ^ *((_QWORD *)&v154 + 1) ^ v173 ^ (4 * v181 & 0xCCCCCCCCCCCCCCCCLL | (v181 >> 2) & 0x3333333333333333LL) ^ (8 * v197 & 0x8888888888888888LL | (v197 >> 1) & 0x7777777777777777LL);
      v199 = v198 ^ v196;
      v200 = v191 ^ v190;
      *((_QWORD *)&v154 + 1) = v192 ^ v191;
      v201 = v190 ^ v154;
      v202 = v192 ^ v191 ^ v190;
      v203 = v198 ^ v201 ^ v195;
      v204 = v198 ^ v201;
      v205 = v192 ^ v191 ^ v198 ^ v201;
      v206 = v196 ^ v205;
      v207 = v192 ^ v196;
      v208 = v198 ^ v196 ^ v192;
      v209 = v202 ^ v154;
      v210 = v198 ^ v196 ^ v191;
      v211 = v196 ^ v205 ^ v191;
      v212 = v192 ^ v191;
      v213 = v206 ^ v169 ^ ((v177 >> 2) & 0x3333333333333333LL | 4 * v177 & 0xCCCCCCCCCCCCCCCCLL) ^ v147 ^ (8 * v185 & 0x8888888888888888LL | (v185 >> 1) & 0x7777777777777777LL) ^ (4 * v169 & 0xCCCCCCCCCCCCCCCCLL | (v169 >> 2) & 0x3333333333333333LL);
      v214 = v213 ^ v203 ^ v192 ^ v191;
      v215 = (v192 ^ v191) & ~v213;
      v216 = v214;
      v217 = v199 ^ v214;
      v218 = (v202 ^ v154) & (v203 ^ v202);
      v219 = v216;
      v220 = v217 ^ v203 ^ v202;
      v221 = v217;
      v222 = v211 & v217;
      v223 = v220;
      v224 = v215 ^ v220 & (v199 ^ v191);
      v225 = v215 ^ v208 & ~v200;
      v226 = v224 ^ v211 & v217 ^ v213 ^ v199 & v207;
      v227 = v225 ^ v222 ^ v200 ^ v216 & v204;
      v228 = v225 ^ v218 ^ v212 ^ v195 ^ v203 & v205;
      v229 = v224 ^ v218 ^ v154 ^ v203 ^ v202 & v198;
      v230 = v227 ^ v226;
      v231 = v229 & v226;
      v232 = v227 ^ (v231 ^ v228) & v230;
      v233 = (v228 ^ v229) & (v231 ^ v227);
      v234 = v231 ^ v228;
      v235 = v233 ^ v228;
      v236 = (v231 ^ v233) & v228;
      v237 = v235;
      v238 = v236 ^ v235 ^ v229;
      v239 = v230 ^ v232 & (v236 ^ v234);
      v240 = v235 ^ v232;
      v241 = v239 ^ v238;
      v242 = v239 ^ v232;
      v243 = v238 ^ v235;
      v244 = (v238 ^ v235) & v221;
      v245 = v235 ^ v232 ^ v239 ^ v238;
      *(_QWORD *)&v154 = v244;
      v246 = v238 & v199;
      v247 = v239 & v202;
      v248 = (v239 ^ v232) & (v203 ^ v202);
      v249 = v198 & v239;
      v250 = v237 & v219;
      v251 = v232 & v203;
      v252 = v245 & v210;
      v253 = v241 & (v208 ^ v200);
      v254 = v208 & v241;
      v255 = v249 ^ (v237 ^ v232) & v213;
      v256 = v219 ^ v204;
      v257 = v237 & v204;
      v258 = v256 & v237;
      v259 = v238 & v207;
      v260 = v242 & v209;
      v261 = v245 & v210 ^ v242 & v209 ^ v253 ^ v255;
      v262 = v261 ^ v154;
      v263 = v248 ^ v261;
      v264 = v262 ^ v250;
      v265 = v262;
      v266 = v251 ^ v263;
      v267 = v263 ^ v247 ^ v253 ^ v223 & v245;
      v268 = v263 ^ v247 ^ v259 ^ v246 ^ v205 & v232 ^ v258;
      v269 = v265 ^ v247 ^ v251 ^ v246;
      v270 = v254 ^ v257 ^ v211 & v243;
      v271 = v270 ^ *((_QWORD *)&v154 + 1) & v240;
      v272 = v268 ^ v260 ^ v252 ^ v270;
      v273 = v267 ^ v248 ^ v154 ^ v259 ^ v257 ^ v250 ^ v251 ^ v254 ^ v252;
      v274 = (v271 ^ (v271 >> 8)) & 0xCC00CC00CC00CCLL;
      v136 = (v274 ^ v271 ^ (v274 << 8)) & 0x5555555555555555LL | 16 * (v274 ^ v271 ^ (v274 << 8)) & 0xAAA0AAA0AAA0AAA0LL | v312 & ((v274 ^ v271 ^ (v274 << 8)) >> 12);
      v275 = (v267 ^ (v267 >> 8)) & 0xCC00CC00CC00CCLL ^ v267 ^ (((v267 ^ (v267 >> 8)) & 0xCC00CC00CC00CCLL) << 8);
      v140 = v275 & 0x5555555555555555LL | 16 * v275 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v275 >> 12);
      v276 = (((v269 ^ (v269 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v269 ^ (v269 >> 8)) & 0xCC00CC00CC00CCLL ^ v269;
      v138 = v276 & 0x5555555555555555LL | 16 * v276 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v276 >> 12);
      v277 = (v273 ^ (v273 >> 8)) & 0xCC00CC00CC00CCLL ^ v273 ^ (((v273 ^ (v273 >> 8)) & 0xCC00CC00CC00CCLL) << 8);
      v137 = v277 & 0x5555555555555555LL | 16 * v277 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v277 >> 12);
      v278 = v264 ^ (v264 ^ (v264 >> 8)) & 0xCC00CC00CC00CCLL ^ (((v264 ^ (v264 >> 8)) & 0xCC00CC00CC00CCLL) << 8);
      v129 = v278 & 0x5555555555555555LL | 16 * v278 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v278 >> 12);
      v279 = (((v268 ^ v249 ^ ((v268 ^ v249) >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v268 ^ v249 ^ ((v268 ^ v249) >> 8)) & 0xCC00CC00CC00CCLL ^ v268 ^ v249;
      v139 = v279 & 0x5555555555555555LL | 16 * v279 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v279 >> 12);
      v307 -= 8;
      v280 = (((v272 ^ (v272 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v272 ^ (v272 >> 8)) & 0xCC00CC00CC00CCLL ^ v272;
      v133 = v280 & 0x5555555555555555LL | 16 * v280 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v280 >> 12);
      v281 = (((v266 ^ (v266 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ v266 ^ (v266 ^ (v266 >> 8)) & 0xCC00CC00CC00CCLL;
      v141 = v281 & 0x5555555555555555LL | 16 * v281 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v281 >> 12);
    }
    while ( v307 != (_QWORD *)v311 );
    v134 = v141;
    v306 = v136;
    v125 = v138;
    v123 = v140;
    v131 = v139;
    v128 = v277 & 0x5555555555555555LL | 16 * v277 & 0xAAA0AAA0AAA0AAA0LL | v312 & (v277 >> 12);
    v314 += 8 * ~v315;
  }
  v282 = v313;
  v283 = *v314 ^ v306;
  v284 = v314[1] ^ v123;
  v285 = v314[2] ^ v125;
  v286 = v314[3] ^ v128;
  v287 = v314[4] ^ v129;
  result = v314[5] ^ v131;
  v289 = v314[7] ^ v134;
  v290 = v314[6] ^ v133;
  do
  {
    v291 = (unsigned __int16)(v284 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(v286 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(result >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (unsigned __int64)((unsigned int)(v289 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) << 16)) << 16)) << 16);
    v292 = (v291 ^ (((unsigned __int16)(v283 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(v285 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(v287 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (unsigned __int64)((unsigned int)(v290 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) << 16)) << 16)) << 16)) >> 8)) & 0xFF00FF00FF00FFLL;
    v293 = v292;
    v294 = v291 ^ v292;
    v295 = (v293 << 8) ^ ((unsigned __int16)(v283 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(v285 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (((unsigned __int16)(v287 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) | (unsigned __int64)((unsigned int)(v290 >> ((unsigned __int8)v282 - (unsigned __int8)v313)) << 16)) << 16)) << 16));
    v296 = ((unsigned int)v295 ^ (unsigned int)(v295 >> 28)) & 0xF0F0F0F0;
    v297 = v296 ^ v295 ^ (v296 << 28);
    v298 = ((unsigned int)v294 ^ (unsigned int)(v294 >> 28)) & 0xF0F0F0F0;
    v299 = (v298 << 28) ^ v298 ^ v294;
    v300 = (v297 ^ (v297 >> 14)) & 0xCCCC0000CCCCLL ^ v297 ^ (((v297 ^ (v297 >> 14)) & 0xCCCC0000CCCCLL) << 14);
    v301 = (v299 ^ (v299 >> 14)) & 0xCCCC0000CCCCLL ^ v299 ^ (((v299 ^ (v299 >> 14)) & 0xCCCC0000CCCCLL) << 14);
    v302 = (v300 ^ (v300 >> 7)) & 0xAA00AA00AA00AALL;
    v303 = v302 ^ v300 ^ (v302 << 7);
    *(_WORD *)v282 = v303;
    v304 = (v301 ^ (v301 >> 7)) & 0xAA00AA00AA00AALL ^ v301 ^ (((v301 ^ (v301 >> 7)) & 0xAA00AA00AA00AALL) << 7);
    *(_BYTE *)(v282 + 8) = v304;
    v282 += 16LL;
    *(_BYTE *)(v282 - 14) = BYTE2(v303);
    *(_BYTE *)(v282 - 13) = BYTE3(v303);
    *(_BYTE *)(v282 - 12) = BYTE4(v303);
    *(_BYTE *)(v282 - 11) = BYTE5(v303);
    *(_BYTE *)(v282 - 9) = HIBYTE(v303);
    *(_BYTE *)(v282 - 10) = BYTE6(v303);
    *(_BYTE *)(v282 - 7) = BYTE1(v304);
    *(_BYTE *)(v282 - 6) = BYTE2(v304);
    *(_BYTE *)(v282 - 5) = BYTE3(v304);
    *(_BYTE *)(v282 - 4) = BYTE4(v304);
    *(_BYTE *)(v282 - 3) = BYTE5(v304);
    *(_BYTE *)(v282 - 1) = HIBYTE(v304);
    *(_BYTE *)(v282 - 2) = v304 >> 48;
  }
  while ( v282 != v313 + 64 );
  return result;
}

unsigned __int64 __fastcall sub_5A4D0(__int64 a1, __int64 a2, int a3)
{
  int v3; // er14
  unsigned __int64 v4; // r14
  __int64 v5; // r13
  __int64 v6; // rbp
  signed __int64 v7; // r15
  __int128 *v8; // rcx
  __int64 v9; // rsi
  unsigned __int64 v10; // rax
  char v11; // di^6
  __int64 v12; // rax
  unsigned __int64 v13; // rax
  __int64 v15; // [rsp+0h] [rbp-90h]
  __int128 v16; // [rsp+8h] [rbp-88h]
  __int128 v17; // [rsp+18h] [rbp-78h]
  __int128 v18; // [rsp+28h] [rbp-68h]
  __int128 v19; // [rsp+38h] [rbp-58h]
  unsigned __int64 v20; // [rsp+50h] [rbp-40h]

  v3 = a3 + 15;
  v20 = __readfsqword(0x28u);
  if ( a3 >= 0 )
    v3 = a3;
  v4 = v3 >> 4;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0LL;
  v19 = 0LL;
  if ( v4 )
  {
    v5 = a1;
    v6 = a2;
    v15 = a1 - 1296;
    do
    {
      v7 = 4LL;
      if ( v4 <= 4 )
        v7 = v4;
      __memcpy_chk(&v16, v6, 16 * v7, 64LL);
      sub_58D10((__int64)&v16, &v16, v15);
      v8 = &v16;
      v9 = v6;
      do
      {
        v10 = *(_QWORD *)v8 ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 85) << 24) | *(unsigned __int8 *)(v5 - 88) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 87) << 8));
        *(_BYTE *)v8 ^= *(_BYTE *)(v5 - 88);
        *((_BYTE *)v8 + 1) = BYTE1(v10);
        *((_BYTE *)v8 + 2) = BYTE2(v10);
        *((_BYTE *)v8 + 3) = BYTE3(v10);
        *((_BYTE *)v8 + 4) = BYTE4(v10);
        *((_BYTE *)v8 + 5) = BYTE5(v10);
        v11 = BYTE6(v10);
        *((_BYTE *)v8 + 7) = HIBYTE(v10);
        v12 = *(unsigned __int8 *)(v5 - 79);
        *((_BYTE *)v8 + 6) = v11;
        v9 += 16LL;
        ++v8;
        v13 = *((_QWORD *)v8 - 1) ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 77) << 24) | *(unsigned __int8 *)(v5 - 80) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 78) << 16) | (v12 << 8));
        *((_WORD *)v8 - 4) = v13;
        *((_BYTE *)v8 - 6) = BYTE2(v13);
        *((_BYTE *)v8 - 5) = BYTE3(v13);
        *((_BYTE *)v8 - 4) = BYTE4(v13);
        *((_BYTE *)v8 - 3) = BYTE5(v13);
        *((_BYTE *)v8 - 2) = BYTE6(v13);
        *((_BYTE *)v8 - 1) = HIBYTE(v13);
        *(__m128i *)(v5 - 88) = _mm_loadu_si128((const __m128i *)(v9 - 16));
        *(__m128i *)(v9 - 16) = _mm_load_si128((const __m128i *)v8 - 1);
      }
      while ( v9 != v6 + 16 * v7 );
      v4 -= v7;
      v6 = v9;
    }
    while ( v4 );
  }
  sub_BD070(&v16, 0x40uLL);
  return __readfsqword(0x28u) ^ v20;
}

unsigned __int64 __fastcall sub_5A740(__int64 a1, __int64 a2, int a3)
{
  int v3; // er14
  unsigned __int64 v4; // r14
  __int64 v5; // r13
  __int64 v6; // rbp
  signed __int64 v7; // r15
  __int128 *v8; // rcx
  __int64 v9; // rsi
  unsigned __int64 v10; // rax
  char v11; // di^6
  __int64 v12; // rax
  unsigned __int64 v13; // rax
  __int64 v15; // [rsp+0h] [rbp-90h]
  __int128 v16; // [rsp+8h] [rbp-88h]
  __int128 v17; // [rsp+18h] [rbp-78h]
  __int128 v18; // [rsp+28h] [rbp-68h]
  __int128 v19; // [rsp+38h] [rbp-58h]
  unsigned __int64 v20; // [rsp+50h] [rbp-40h]

  v3 = a3 + 15;
  v20 = __readfsqword(0x28u);
  if ( a3 >= 0 )
    v3 = a3;
  v4 = v3 >> 4;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0LL;
  v19 = 0LL;
  if ( v4 )
  {
    v5 = a1;
    v6 = a2;
    v15 = a1 - 1296;
    do
    {
      v7 = 4LL;
      if ( v4 <= 4 )
        v7 = v4;
      __memcpy_chk(&v16, v6, 16 * v7, 64LL);
      sub_58D10((__int64)&v16, &v16, v15);
      v8 = &v16;
      v9 = v6;
      do
      {
        v10 = *(_QWORD *)v8 ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 85) << 24) | *(unsigned __int8 *)(v5 - 88) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 87) << 8));
        *(_BYTE *)v8 ^= *(_BYTE *)(v5 - 88);
        *((_BYTE *)v8 + 1) = BYTE1(v10);
        *((_BYTE *)v8 + 2) = BYTE2(v10);
        *((_BYTE *)v8 + 3) = BYTE3(v10);
        *((_BYTE *)v8 + 4) = BYTE4(v10);
        *((_BYTE *)v8 + 5) = BYTE5(v10);
        v11 = BYTE6(v10);
        *((_BYTE *)v8 + 7) = HIBYTE(v10);
        v12 = *(unsigned __int8 *)(v5 - 79);
        *((_BYTE *)v8 + 6) = v11;
        v9 += 16LL;
        ++v8;
        v13 = *((_QWORD *)v8 - 1) ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 77) << 24) | *(unsigned __int8 *)(v5 - 80) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 78) << 16) | (v12 << 8));
        *((_WORD *)v8 - 4) = v13;
        *((_BYTE *)v8 - 6) = BYTE2(v13);
        *((_BYTE *)v8 - 5) = BYTE3(v13);
        *((_BYTE *)v8 - 4) = BYTE4(v13);
        *((_BYTE *)v8 - 3) = BYTE5(v13);
        *((_BYTE *)v8 - 2) = BYTE6(v13);
        *((_BYTE *)v8 - 1) = HIBYTE(v13);
        *(__m128i *)(v5 - 88) = _mm_loadu_si128((const __m128i *)(v9 - 16));
        *(__m128i *)(v9 - 16) = _mm_load_si128((const __m128i *)v8 - 1);
      }
      while ( v9 != v6 + 16 * v7 );
      v4 -= v7;
      v6 = v9;
    }
    while ( v4 );
  }
  sub_BD070(&v16, 0x40uLL);
  return __readfsqword(0x28u) ^ v20;
}

unsigned __int64 __fastcall sub_5A9B0(__int64 a1, __int64 a2, int a3)
{
  int v3; // er14
  unsigned __int64 v4; // r14
  __int64 v5; // r13
  __int64 v6; // rbp
  signed __int64 v7; // r15
  __int128 *v8; // rcx
  __int64 v9; // rsi
  unsigned __int64 v10; // rax
  char v11; // di^6
  __int64 v12; // rax
  unsigned __int64 v13; // rax
  __int64 v15; // [rsp+0h] [rbp-90h]
  __int128 v16; // [rsp+8h] [rbp-88h]
  __int128 v17; // [rsp+18h] [rbp-78h]
  __int128 v18; // [rsp+28h] [rbp-68h]
  __int128 v19; // [rsp+38h] [rbp-58h]
  unsigned __int64 v20; // [rsp+50h] [rbp-40h]

  v3 = a3 + 15;
  v20 = __readfsqword(0x28u);
  if ( a3 >= 0 )
    v3 = a3;
  v4 = v3 >> 4;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0LL;
  v19 = 0LL;
  if ( v4 )
  {
    v5 = a1;
    v6 = a2;
    v15 = a1 - 1296;
    do
    {
      v7 = 4LL;
      if ( v4 <= 4 )
        v7 = v4;
      __memcpy_chk(&v16, v6, 16 * v7, 64LL);
      sub_58D10((__int64)&v16, &v16, v15);
      v8 = &v16;
      v9 = v6;
      do
      {
        v10 = *(_QWORD *)v8 ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 81) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 82) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 83) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 84) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 85) << 24) | *(unsigned __int8 *)(v5 - 88) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 86) << 16) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 87) << 8));
        *(_BYTE *)v8 ^= *(_BYTE *)(v5 - 88);
        *((_BYTE *)v8 + 1) = BYTE1(v10);
        *((_BYTE *)v8 + 2) = BYTE2(v10);
        *((_BYTE *)v8 + 3) = BYTE3(v10);
        *((_BYTE *)v8 + 4) = BYTE4(v10);
        *((_BYTE *)v8 + 5) = BYTE5(v10);
        v11 = BYTE6(v10);
        *((_BYTE *)v8 + 7) = HIBYTE(v10);
        v12 = *(unsigned __int8 *)(v5 - 79);
        *((_BYTE *)v8 + 6) = v11;
        v9 += 16LL;
        ++v8;
        v13 = *((_QWORD *)v8 - 1) ^ (((unsigned __int64)*(unsigned __int8 *)(v5 - 73) << 56) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 74) << 48) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 75) << 40) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 76) << 32) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 77) << 24) | *(unsigned __int8 *)(v5 - 80) | ((unsigned __int64)*(unsigned __int8 *)(v5 - 78) << 16) | (v12 << 8));
        *((_WORD *)v8 - 4) = v13;
        *((_BYTE *)v8 - 6) = BYTE2(v13);
        *((_BYTE *)v8 - 5) = BYTE3(v13);
        *((_BYTE *)v8 - 4) = BYTE4(v13);
        *((_BYTE *)v8 - 3) = BYTE5(v13);
        *((_BYTE *)v8 - 2) = BYTE6(v13);
        *((_BYTE *)v8 - 1) = HIBYTE(v13);
        *(__m128i *)(v5 - 88) = _mm_loadu_si128((const __m128i *)(v9 - 16));
        *(__m128i *)(v9 - 16) = _mm_load_si128((const __m128i *)v8 - 1);
      }
      while ( v9 != v6 + 16 * v7 );
      v4 -= v7;
      v6 = v9;
    }
    while ( v4 );
  }
  sub_BD070(&v16, 0x40uLL);
  return __readfsqword(0x28u) ^ v20;
}

unsigned __int64 __fastcall sub_5AC20(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdi
  __int64 v9; // rcx
  unsigned __int64 v10; // rcx
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  signed __int64 v13; // rbx
  unsigned __int64 v14; // rdi
  __int64 v15; // r9
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // r8
  __int64 v19; // rax
  __int64 v20; // r13
  unsigned __int64 v21; // rdi
  __int64 v22; // r14
  signed __int64 v23; // r11
  unsigned __int64 v24; // r12
  signed __int64 v25; // rcx
  unsigned __int64 v26; // r12
  unsigned __int64 v27; // rcx
  __int64 v28; // r11
  unsigned __int64 v29; // r12
  __int64 v30; // r14
  unsigned __int64 v31; // r11
  signed __int64 v32; // r14
  unsigned __int64 v33; // r11
  unsigned __int64 v34; // r12
  unsigned __int64 v35; // r9
  unsigned __int64 v36; // rax
  __int64 v37; // rcx
  unsigned __int64 v38; // rdi
  unsigned __int64 v39; // r15
  signed __int64 v40; // rbx
  unsigned __int64 v41; // r11
  unsigned __int64 v42; // rsi
  int v43; // edx
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // r14
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // r10
  unsigned __int64 v49; // rbx
  unsigned __int64 v50; // r8
  unsigned __int64 v51; // r13
  unsigned __int64 v52; // rdi
  unsigned __int64 v53; // rbp
  unsigned __int64 v54; // ST30_8
  unsigned __int64 v55; // r11
  unsigned __int64 v56; // rdx
  unsigned __int64 v57; // rsi
  unsigned __int64 v58; // ST38_8
  unsigned __int64 v59; // ST28_8
  unsigned __int64 v60; // r11
  unsigned __int64 v61; // ST40_8
  unsigned __int64 v62; // r10
  unsigned __int64 v63; // r15
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // r12
  unsigned __int64 v67; // ST20_8
  unsigned __int64 v68; // r15
  unsigned __int64 v69; // ST68_8
  unsigned __int64 v70; // rdi
  unsigned __int64 v71; // ST58_8
  unsigned __int64 v72; // r11
  unsigned __int64 v73; // rbp
  unsigned __int64 v74; // ST48_8
  unsigned __int64 v75; // ST50_8
  unsigned __int64 v76; // rdx
  unsigned __int64 v77; // r10
  unsigned __int64 v78; // ST18_8
  unsigned __int64 v79; // ST70_8
  unsigned __int64 v80; // rsi
  unsigned __int64 v81; // ST60_8
  unsigned __int64 v82; // r15
  unsigned __int64 v83; // r11
  unsigned __int64 v84; // rdi
  unsigned __int64 v85; // r9
  unsigned __int64 v86; // rax
  unsigned __int64 v87; // rdx
  unsigned __int64 v88; // rbx
  unsigned __int64 v89; // rdi
  unsigned __int64 v90; // r15
  unsigned __int64 v91; // r14
  unsigned __int64 v92; // r11
  unsigned __int64 v93; // r9
  unsigned __int64 v94; // rbx
  unsigned __int64 v95; // rdx
  unsigned __int64 v96; // rax
  unsigned __int64 v97; // r10
  unsigned __int64 v98; // r15
  unsigned __int64 v99; // rdx
  unsigned __int64 v100; // ST00_8
  unsigned __int64 v101; // rcx
  unsigned __int64 v102; // rdi
  unsigned __int64 v103; // r8
  unsigned __int64 v104; // r12
  __int64 v105; // rsi
  unsigned __int64 v106; // rdx
  __int64 v107; // ST10_8
  unsigned __int64 v108; // ST28_8
  unsigned __int64 v109; // ST40_8
  unsigned __int64 v110; // rsi
  unsigned __int64 v111; // rdx
  unsigned __int64 v112; // r13
  unsigned __int64 v113; // r10
  unsigned __int64 v114; // rcx
  unsigned __int64 v115; // rbp
  unsigned __int64 v116; // r14
  unsigned __int64 v117; // r8
  __int64 v118; // r9
  unsigned __int64 v119; // r11
  unsigned __int64 v120; // rdi
  unsigned __int64 v121; // r10
  unsigned __int64 v122; // rax
  unsigned __int64 v123; // r14
  unsigned __int64 v124; // rcx
  unsigned __int64 v125; // rbx
  unsigned __int64 v126; // rax
  unsigned __int64 v127; // r13
  signed __int64 v128; // rsi
  unsigned __int64 v129; // r8
  unsigned __int64 v130; // r11
  unsigned __int64 v131; // rdi
  unsigned __int64 v132; // ST00_8
  unsigned __int64 v133; // rbx
  unsigned __int64 v134; // ST18_8
  unsigned __int64 v135; // rax
  unsigned __int64 v136; // ST20_8
  unsigned __int64 v137; // rcx
  unsigned __int64 v138; // r10
  unsigned __int64 v139; // r8
  unsigned __int64 v140; // rdi
  unsigned __int64 v141; // r13
  unsigned __int64 v142; // r8
  unsigned __int64 v143; // r14
  unsigned __int64 v144; // r13
  unsigned __int64 v145; // rbp
  unsigned __int64 v146; // r11
  unsigned __int64 v147; // rsi
  unsigned __int64 v148; // r14
  unsigned __int64 v149; // rcx
  unsigned __int64 v150; // rbx
  unsigned __int64 v151; // r12
  unsigned __int64 v152; // r9
  unsigned __int64 v153; // r15
  unsigned __int64 v154; // r13
  unsigned __int64 v155; // r15
  unsigned __int64 v156; // rdx
  unsigned __int64 v157; // rcx
  unsigned __int64 v158; // r14
  unsigned __int64 v159; // r8
  unsigned __int64 v160; // ST10_8
  unsigned __int64 v161; // r12
  unsigned __int64 v162; // ST20_8
  unsigned __int64 v163; // ST30_8
  unsigned __int64 v164; // r11
  unsigned __int64 v165; // ST38_8
  unsigned __int64 v166; // rbx
  unsigned __int64 v167; // r13
  unsigned __int64 v168; // rax
  unsigned __int64 v169; // r15
  unsigned __int64 v170; // r10
  unsigned __int64 v171; // r14
  unsigned __int64 v172; // ST40_8
  unsigned __int64 v173; // ST18_8
  unsigned __int64 v174; // r11
  unsigned __int64 v175; // rax
  unsigned __int64 v176; // rsi
  unsigned __int64 v177; // rdx
  unsigned __int64 v178; // r14
  unsigned __int64 v179; // ST58_8
  unsigned __int64 v180; // r9
  unsigned __int64 v181; // ST70_8
  unsigned __int64 v182; // r12
  unsigned __int64 v183; // ST68_8
  unsigned __int64 v184; // ST50_8
  unsigned __int64 v185; // r9
  unsigned __int64 v186; // ST48_8
  unsigned __int64 v187; // rsi
  unsigned __int64 v188; // rcx
  unsigned __int64 v189; // ST60_8
  unsigned __int64 v190; // r14
  unsigned __int64 v191; // r10
  unsigned __int64 v192; // ST28_8
  unsigned __int64 v193; // rbp
  unsigned __int64 v194; // r15
  unsigned __int64 v195; // rsi
  unsigned __int64 v196; // rax
  unsigned __int64 v197; // rdx
  unsigned __int64 v198; // rcx
  unsigned __int64 v199; // rbp
  unsigned __int64 v200; // rsi
  unsigned __int64 v201; // rbp
  unsigned __int64 v202; // rdi
  unsigned __int64 v203; // r10
  unsigned __int64 v204; // r9
  unsigned __int64 v205; // rax
  unsigned __int64 v206; // rcx
  unsigned __int64 v207; // rdx
  __int64 v208; // r9
  unsigned __int64 v209; // r14
  __int64 v210; // ST00_8
  unsigned __int64 v211; // rcx
  unsigned __int64 v212; // rsi
  unsigned __int64 v213; // r8
  unsigned __int64 v214; // ST40_8
  unsigned __int64 v215; // rdi
  __int64 v216; // r12
  unsigned __int64 v217; // rbx
  unsigned __int64 v218; // r15
  unsigned __int64 v219; // ST28_8
  unsigned __int64 v220; // ST20_8
  unsigned __int64 v221; // rsi
  unsigned __int64 v222; // r9
  unsigned __int64 v223; // r13
  unsigned __int64 v224; // r11
  __int64 v225; // rcx
  unsigned __int64 v226; // r15
  unsigned __int64 v227; // r8
  unsigned __int64 v228; // r10
  unsigned __int64 v229; // rdx
  unsigned __int64 v230; // r13
  unsigned __int64 v231; // rbx
  unsigned __int64 v232; // rax
  unsigned __int64 v233; // r10
  unsigned __int64 v234; // rcx
  unsigned __int64 v235; // rsi
  unsigned __int64 v236; // rdi
  unsigned __int64 v237; // rax
  signed __int64 v238; // ST28_8
  unsigned __int64 v239; // r15
  unsigned __int64 v240; // rdx
  unsigned __int64 v241; // rbx
  unsigned __int64 v242; // rax
  unsigned __int64 v243; // r9
  signed __int64 v244; // r12
  signed __int64 v245; // rcx
  signed __int64 v246; // r13
  unsigned __int64 v247; // r12
  unsigned __int64 v248; // r15
  unsigned __int64 v249; // r10
  unsigned __int64 v250; // r14
  unsigned __int64 v251; // rbp
  __int64 v252; // rdi
  unsigned __int64 v253; // r9
  unsigned __int64 v254; // r8
  unsigned __int64 v255; // rsi
  unsigned __int64 v256; // rax
  unsigned __int64 v257; // rcx
  unsigned __int64 v258; // rax
  unsigned __int64 v259; // rdx
  __int64 v260; // rsi
  unsigned __int64 v261; // rcx
  __int64 v262; // rdx
  unsigned __int64 v263; // rax
  unsigned __int64 v264; // rdx
  unsigned __int64 v265; // rsi
  signed __int64 v266; // rax
  unsigned __int64 v267; // rcx
  unsigned __int64 v268; // rax
  unsigned __int64 result; // rax
  __int64 v270; // [rsp+0h] [rbp-B8h]
  unsigned __int64 v271; // [rsp+0h] [rbp-B8h]
  unsigned __int64 v272; // [rsp+0h] [rbp-B8h]
  unsigned __int64 v273; // [rsp+8h] [rbp-B0h]
  _QWORD *v274; // [rsp+8h] [rbp-B0h]
  unsigned __int64 v275; // [rsp+10h] [rbp-A8h]
  signed __int64 v276; // [rsp+78h] [rbp-40h]
  __int64 v277; // [rsp+80h] [rbp-38h]

  v3 = a2;
  v4 = a2[1];
  v277 = a1;
  v5 = (((*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL) << 7) ^ *a2 ^ (*a2 ^ (*a2 >> 7)) & 0xAA00AA00AA00AALL;
  v6 = v4 ^ (v4 ^ (v4 >> 7)) & 0xAA00AA00AA00AALL ^ (((v4 ^ (v4 >> 7)) & 0xAA00AA00AA00AALL) << 7);
  v7 = (v5 ^ (v5 >> 14)) & 0xCCCC0000CCCCLL ^ v5 ^ (((v5 ^ (v5 >> 14)) & 0xCCCC0000CCCCLL) << 14);
  v8 = (v6 ^ (v6 >> 14)) & 0xCCCC0000CCCCLL ^ v6 ^ (((v6 ^ (v6 >> 14)) & 0xCCCC0000CCCCLL) << 14);
  v9 = ((unsigned int)v7 ^ (unsigned int)(v7 >> 28)) & 0xF0F0F0F0;
  v10 = v9 ^ v7 ^ (v9 << 28);
  v11 = ((unsigned int)v8 ^ (unsigned int)(v8 >> 28)) & 0xF0F0F0F0;
  v12 = v11 ^ v8 ^ (v11 << 28);
  v13 = (v12 ^ (v10 >> 8)) & 0xFF00FF00FF00FFLL;
  v14 = v13 ^ v12;
  v15 = (unsigned __int16)v14;
  v16 = (v13 << 8) ^ v10;
  v270 = (unsigned __int16)v16;
  v273 = v16 >> 48;
  v17 = WORD1(v16);
  v18 = WORD2(v14);
  v19 = WORD2(v16);
  v20 = WORD1(v14);
  v21 = v14 >> 48;
  do
  {
    v3 += 2;
    v22 = v3[1];
    v23 = (*v3 ^ (*v3 >> 7)) & 0xAA00AA00AA00AALL;
    v24 = *v3 ^ v23 ^ (v23 << 7);
    v25 = (v22 ^ (v3[1] >> 7)) & 0xAA00AA00AA00AALL;
    v26 = (((v24 ^ (v24 >> 14)) & 0xCCCC0000CCCCLL) << 14) ^ (v24 ^ (v24 >> 14)) & 0xCCCC0000CCCCLL ^ v24;
    v27 = (v22 ^ v25 ^ (v25 << 7) ^ ((v22 ^ v25 ^ (unsigned __int64)(v25 << 7)) >> 14)) & 0xCCCC0000CCCCLL ^ v22 ^ v25 ^ (v25 << 7) ^ (((v22 ^ v25 ^ (v25 << 7) ^ ((v22 ^ v25 ^ (unsigned __int64)(v25 << 7)) >> 14)) & 0xCCCC0000CCCCLL) << 14);
    v28 = ((unsigned int)v26 ^ (unsigned int)(v26 >> 28)) & 0xF0F0F0F0;
    v29 = (v28 << 28) ^ v28 ^ v26;
    v30 = ((unsigned int)v27 ^ (unsigned int)(v27 >> 28)) & 0xF0F0F0F0;
    v31 = v30 ^ v27 ^ (v30 << 28);
    v32 = (v31 ^ (v29 >> 8)) & 0xFF00FF00FF00FFLL;
    v33 = v32 ^ v31;
    v34 = (v32 << 8) ^ v29;
    v270 |= (unsigned __int64)(unsigned __int16)v34 << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v17 |= (unsigned __int64)WORD1(v34) << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v273 |= v34 >> 48 << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v15 |= (unsigned __int64)(unsigned __int16)v33 << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v19 |= (unsigned __int64)WORD2(v34) << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v20 |= (unsigned __int64)WORD1(v33) << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v18 |= (unsigned __int64)WORD2(v33) << ((unsigned __int8)v3 - (unsigned __int8)a2);
    v21 |= v33 >> 48 << ((unsigned __int8)v3 - (unsigned __int8)a2);
  }
  while ( v3 != a2 + 6 );
  v35 = *(_QWORD *)(a3 + 8) ^ v15;
  v36 = *(_QWORD *)(a3 + 32) ^ v19;
  v37 = *(_QWORD *)(a3 + 40);
  v38 = *(_QWORD *)(a3 + 56) ^ v21;
  v39 = *(_QWORD *)(a3 + 16) ^ v17;
  v40 = a3 + 64;
  v275 = *(_QWORD *)a3 ^ v270;
  v41 = v20 ^ *(_QWORD *)(a3 + 24);
  v42 = *(_QWORD *)(a3 + 48) ^ v273;
  v43 = *(_DWORD *)(a3 + 1200);
  v44 = v18 ^ v37;
  v271 = v35;
  v274 = (_QWORD *)v40;
  if ( v43 != 1 )
  {
    v45 = v38;
    v276 = v40 + (((unsigned int)(v43 - 2) + 1LL) << 6);
    v46 = v39;
    do
    {
      v47 = v42 ^ v44;
      v48 = v36 ^ v46;
      v49 = v45 ^ v46;
      v50 = v47 ^ v275;
      v51 = v45 ^ v271;
      v52 = v45 ^ v271 ^ v36 ^ v46;
      v53 = v47 ^ v275 ^ v271;
      v54 = v47 ^ v275 ^ v36;
      v55 = v52 ^ v41;
      v56 = v55 ^ v46;
      v57 = v55 ^ v42;
      v58 = v45 ^ v47 ^ v275;
      v59 = v48;
      v60 = v57 ^ v45 ^ v36;
      v61 = v53 ^ v49;
      v62 = v52;
      v63 = v56 ^ v47;
      v64 = v45 ^ v36;
      v65 = v60 ^ v47;
      v66 = v60 ^ v275;
      v67 = v63;
      v68 = v60 ^ v63;
      v69 = v60;
      v70 = v56 ^ v275;
      v71 = v53;
      v72 = v56 & v62;
      v73 = v56;
      v74 = v64;
      v75 = v62;
      v76 = v64 & ~v57;
      v77 = v72;
      v78 = v49;
      v79 = v68;
      v80 = v72 ^ v57;
      v81 = v70;
      v82 = v76 ^ v68 & v59;
      v83 = v76 ^ v67 & v49;
      v84 = v82 ^ v80 ^ v70 & v61;
      v85 = v83 ^ v77 ^ v67 ^ v49 ^ v54 & v275;
      v86 = v82 ^ v65 & v51 ^ v65 ^ v51 ^ v50 & ~v271;
      v87 = v83 ^ v66 & v58 ^ v65 ^ v45 ^ v65 & (v45 ^ v271);
      v88 = v84;
      v89 = v86 & v84;
      v90 = v85 ^ v88;
      v91 = v89 ^ v83 ^ v66 & v58 ^ v65 ^ v45 ^ v65 & (v45 ^ v271);
      v92 = v85 ^ v91 & (v85 ^ v88);
      v93 = (v87 ^ v86) & (v89 ^ v85);
      v94 = v93 ^ v87;
      v95 = (v89 ^ v93) & v87;
      v96 = v95 ^ v94 ^ v86;
      v97 = v90 ^ v92 & (v91 ^ v95);
      v98 = v97 ^ v96;
      v99 = v94 ^ v92 ^ v97 ^ v96;
      v100 = v94 & v275;
      v101 = (v97 ^ v92) & v65;
      v102 = v51 & (v97 ^ v92);
      v103 = v97 & v50;
      v104 = v92 & v66;
      v105 = v99 & v79;
      v106 = v59 & v99;
      v107 = v105;
      v108 = v106;
      v109 = v96 & v61;
      v110 = v106 ^ (v94 ^ v92) & v74;
      v111 = v101 ^ (v96 ^ v94) & v73;
      v112 = v110 ^ v103;
      v113 = v104 ^ v71 & v97;
      v114 = v107 ^ v69 & (v94 ^ v92) ^ v101;
      v115 = v111 ^ v102 ^ v100;
      v116 = v110 ^ v103 ^ v109 ^ v75 & (v96 ^ v94);
      v117 = v114 ^ v103;
      v118 = v112 ^ v107 ^ v98 & v67;
      v119 = v118 ^ v115 ^ v58 & v92;
      v120 = v113 ^ v102;
      v121 = v115 ^ v110 ^ v113;
      v122 = v116 ^ v81 & v96;
      v123 = v114 ^ v116;
      v124 = v122 ^ v111;
      v125 = v119 ^ v109 ^ v54 & v94;
      v126 = v100 ^ v104 ^ v122;
      v127 = v124 ^ v117;
      v128 = (v121 ^ (v121 >> 8)) & 0xCC00CC00CC00CCLL;
      v129 = v119 ^ v108 ^ v98 & v78 ^ v117;
      v130 = ((v128 << 8) ^ v128 ^ v121) & 0x5555555555555555LL | (((v128 << 8) ^ v128 ^ v121) << 12) & 0xA000A000A000A000LL | (((v128 << 8) ^ v128 ^ v121) >> 4) & 0xAAA0AAA0AAA0AAALL;
      v131 = (((v118 ^ v120 ^ ((v118 ^ v120) >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v118 ^ v120 ^ ((v118 ^ v120) >> 8)) & 0xCC00CC00CC00CCLL ^ v118 ^ v120;
      v132 = v131 & 0x5555555555555555LL | (v131 << 12) & 0xA000A000A000A000LL | (v131 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v133 = (((v125 ^ (v125 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v125 ^ (v125 >> 8)) & 0xCC00CC00CC00CCLL ^ v125;
      v135 = (((v126 ^ (v126 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v126 ^ (v126 >> 8)) & 0xCC00CC00CC00CCLL ^ v126;
      v136 = v135 & 0x5555555555555555LL | (v135 << 12) & 0xA000A000A000A000LL | (v135 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v137 = (((v124 ^ (v124 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v124 ^ (v124 >> 8)) & 0xCC00CC00CC00CCLL ^ v124;
      v138 = v137 & 0x5555555555555555LL | (v137 << 12) & 0xA000A000A000A000LL | (v137 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v139 = (((v129 ^ (v129 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v129 ^ (v129 >> 8)) & 0xCC00CC00CC00CCLL ^ v129;
      v140 = v139 & 0x5555555555555555LL | (v139 << 12) & 0xA000A000A000A000LL | (v139 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v141 = (((v127 ^ (v127 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v127 ^ (v127 >> 8)) & 0xCC00CC00CC00CCLL ^ v127;
      v142 = v141 & 0x5555555555555555LL | (v141 << 12) & 0xA000A000A000A000LL | (v141 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v134 = v133 & 0x5555555555555555LL | (v133 << 12) & 0xA000A000A000A000LL | (v133 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v143 = (((v123 ^ (v123 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v123 ^ (v123 >> 8)) & 0xCC00CC00CC00CCLL ^ v123;
      v144 = v143 & 0x5555555555555555LL | (v143 << 12) & 0xA000A000A000A000LL | (v143 >> 4) & 0xAAA0AAA0AAA0AAALL;
      v145 = (v130 >> 1) & 0x7777777777777777LL | 8 * v130 & 0x8888888888888888LL;
      v146 = v145 ^ v130;
      v147 = v132 ^ ((v132 >> 1) & 0x7777777777777777LL | 8 * v132 & 0x8888888888888888LL);
      v148 = v134 ^ ((v134 >> 1) & 0x7777777777777777LL | 8 * v134 & 0x8888888888888888LL);
      v149 = v136 ^ ((v136 >> 1) & 0x7777777777777777LL | 8 * v136 & 0x8888888888888888LL);
      v150 = v138 ^ ((v138 >> 1) & 0x7777777777777777LL | 8 * v138 & 0x8888888888888888LL);
      v151 = v140 ^ ((v140 >> 1) & 0x7777777777777777LL | 8 * v140 & 0x8888888888888888LL);
      v152 = v142 ^ ((v142 >> 1) & 0x7777777777777777LL | 8 * v142 & 0x8888888888888888LL);
      v153 = (v144 >> 1) & 0x7777777777777777LL | 8 * v144 & 0x8888888888888888LL;
      v154 = v153 ^ v144;
      v275 = v154 ^ *v274 ^ v145 ^ (4 * v146 & 0xCCCCCCCCCCCCCCCCLL | (v146 >> 2) & 0x3333333333333333LL);
      v271 = v154 ^ v147 ^ v274[1] ^ v132 ^ v146 ^ (4 * v147 & 0xCCCCCCCCCCCCCCCCLL | (v147 >> 2) & 0x3333333333333333LL);
      v46 = v148 ^ v147 ^ v274[2] ^ v134 ^ (4 * v148 & 0xCCCCCCCCCCCCCCCCLL | (v148 >> 2) & 0x3333333333333333LL);
      v41 = v149 ^ v148 ^ v154 ^ v274[3] ^ v136 ^ (4 * v149 & 0xCCCCCCCCCCCCCCCCLL | (v149 >> 2) & 0x3333333333333333LL);
      v36 = v150 ^ v149 ^ v154 ^ v274[4] ^ v138 ^ (4 * v150 & 0xCCCCCCCCCCCCCCCCLL | (v150 >> 2) & 0x3333333333333333LL);
      v44 = v151 ^ v274[5] ^ v140 ^ v150 ^ (4 * v151 & 0xCCCCCCCCCCCCCCCCLL | (v151 >> 2) & 0x3333333333333333LL);
      v42 = v152 ^ v274[6] ^ v142 ^ v151 ^ (4 * v152 & 0xCCCCCCCCCCCCCCCCLL | (v152 >> 2) & 0x3333333333333333LL);
      v155 = v274[7] ^ v153;
      v274 += 8;
      v45 = v155 ^ v152 ^ (4 * v154 & 0xCCCCCCCCCCCCCCCCLL | (v154 >> 2) & 0x3333333333333333LL);
    }
    while ( v274 != (_QWORD *)v276 );
    v39 = v46;
    v38 = v45;
  }
  v156 = v275;
  v157 = v42 ^ v44;
  v158 = v38 ^ v36;
  v159 = v157 ^ v275;
  v160 = v38 ^ v39;
  v161 = v38 ^ v271 ^ v36 ^ v39;
  v162 = v36 ^ v39;
  v163 = v159 ^ v36;
  v164 = v161 ^ v41;
  v165 = v38 ^ v159;
  v166 = v164 ^ v39;
  v167 = v42 ^ v164;
  v168 = v159 ^ v271 ^ v38 ^ v39;
  v169 = v164 ^ v39 ^ v157;
  v170 = v158;
  v171 = v42 ^ v164 ^ v158;
  v172 = v168;
  v173 = v169;
  v174 = v171 ^ v156;
  v175 = v156;
  v176 = v156;
  v177 = v171;
  v178 = v169 ^ v171;
  v179 = v159 ^ v271;
  v180 = v161;
  v181 = v178;
  v182 = v177 ^ v157;
  v183 = v177;
  v184 = v180;
  v185 = v166 & v180;
  v186 = v170;
  v187 = v166 ^ v176;
  v188 = v170 & ~v167;
  v189 = v187;
  v190 = v188 ^ v178 & v162;
  v191 = v188 ^ v160 & v169;
  v192 = v38 ^ v271;
  v193 = v182 & (v38 ^ v271);
  v194 = v175;
  v195 = v190 ^ v185 ^ v167 ^ v187 & v172;
  v196 = v191 ^ v185 ^ v173 ^ v160 ^ v163 & v175;
  v197 = v190 ^ v193 ^ v182 ^ v38 ^ v271 ^ v159 & ~v271;
  v198 = v191 ^ v174 & (v38 ^ v159) ^ v182 ^ v38 ^ v193;
  v199 = v195;
  v200 = v197 & v195;
  v201 = v196 ^ v199;
  v202 = v200 ^ v198;
  v203 = v196 ^ (v200 ^ v198) & v201;
  v204 = (v200 ^ v196) & (v198 ^ v197);
  v205 = v204 ^ v198;
  v206 = (v204 ^ v200) & v198;
  v207 = v206 ^ v205 ^ v197;
  v208 = v201 ^ v203 & (v206 ^ v202);
  v209 = v208 ^ v207;
  v210 = v205 & v194;
  v211 = (v208 ^ v203) & v182;
  v212 = v205 ^ v203 ^ v208 ^ v207;
  v213 = v208 & v159;
  v214 = v207 & v172;
  v215 = v192 & (v208 ^ v203);
  v216 = v212 & v181;
  v217 = v211 ^ (v207 ^ v205) & v166;
  v218 = v162 & v212;
  v219 = v218;
  v220 = v203 & v174;
  v221 = v218 ^ (v205 ^ v203) & v186;
  v222 = v203 & v174 ^ v179 & v208;
  v223 = v221 ^ v213 ^ v214 ^ v184 & (v207 ^ v205);
  v224 = v217 ^ v215 ^ v210;
  v225 = v216 ^ v183 & (v205 ^ v203) ^ v211;
  v226 = v221 ^ v213 ^ v216 ^ v209 & v173;
  v227 = v225 ^ v213;
  v228 = v226 ^ v224 ^ v165 & v203;
  v229 = v223 ^ v189 & v207;
  v230 = v225 ^ v223;
  v231 = v229 ^ v217;
  v232 = v228 ^ v214 ^ v163 & v205;
  v233 = v219 ^ v209 & v160 ^ v227 ^ v228;
  v234 = v231 ^ v227;
  v235 = (((v222 ^ v224 ^ v221 ^ ((v222 ^ v224 ^ v221) >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v222 ^ v224 ^ v221 ^ ((v222 ^ v224 ^ v221) >> 8)) & 0xCC00CC00CC00CCLL ^ v222 ^ v224 ^ v221;
  v236 = (((v226 ^ v222 ^ v215 ^ ((v226 ^ v222 ^ v215) >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v226 ^ v222 ^ v215 ^ ((v226 ^ v222 ^ v215) >> 8)) & 0xCC00CC00CC00CCLL ^ v226 ^ v222 ^ v215;
  v237 = (((v232 ^ (v232 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v232 ^ (v232 >> 8)) & 0xCC00CC00CC00CCLL ^ v232;
  v238 = v237 & 0x5555555555555555LL;
  v239 = (v237 >> 4) & 0xAAA0AAA0AAA0AAALL | (v237 << 12) & 0xA000A000A000A000LL;
  v240 = (((v220 ^ v210 ^ v229 ^ ((v220 ^ v210 ^ v229) >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v220 ^ v210 ^ v229 ^ ((v220 ^ v210 ^ v229) >> 8)) & 0xCC00CC00CC00CCLL ^ v220 ^ v210 ^ v229;
  v241 = (((v231 ^ (v231 >> 8)) & 0xCC00CC00CC00CCLL) << 8) ^ (v231 ^ (v231 >> 8)) & 0xCC00CC00CC00CCLL ^ v231;
  v242 = (v234 ^ (v234 >> 8)) & 0xCC00CC00CC00CCLL ^ v234 ^ (((v234 ^ (v234 >> 8)) & 0xCC00CC00CC00CCLL) << 8);
  v243 = (v242 << 12) & 0xA000A000A000A000LL | (v242 >> 4) & 0xAAA0AAA0AAA0AAALL;
  v244 = (v230 ^ (v230 >> 8)) & 0xCC00CC00CC00CCLL;
  v245 = v244;
  v246 = v244 ^ v230;
  v247 = v274[1] ^ (v236 & 0x5555555555555555LL | (v236 << 12) & 0xA000A000A000A000LL | (v236 >> 4) & 0xAAA0AAA0AAA0AAALL);
  v248 = v274[2] ^ (v238 | v239);
  v272 = *v274 ^ (v235 & 0x5555555555555555LL | (v235 << 12) & 0xA000A000A000A000LL | (v235 >> 4) & 0xAAA0AAA0AAA0AAALL);
  v249 = v274[5] ^ (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL ^ v233 ^ (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) & 0x5555555555555555LL | (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL ^ v233 ^ (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) << 12) & 0xA000A000A000A000LL | (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL ^ v233 ^ (((v233 ^ (v233 >> 8)) & 0xCC00CC00CC00CCLL) << 8)) >> 4) & 0xAAA0AAA0AAA0AAALL);
  v250 = v274[3] ^ ((v240 >> 4) & 0xAAA0AAA0AAA0AAALL | (v240 << 12) & 0xA000A000A000A000LL | v240 & 0x5555555555555555LL);
  v251 = (v241 & 0x5555555555555555LL | (v241 >> 4) & 0xAAA0AAA0AAA0AAALL | (v241 << 12) & 0xA000A000A000A000LL) ^ v274[4];
  v252 = v277;
  v253 = v274[6] ^ (v242 & 0x5555555555555555LL | v243);
  v254 = v274[7] ^ (((v246 ^ (unsigned __int64)(v245 << 8)) >> 4) & 0xAAA0AAA0AAA0AAALL | ((v246 ^ (v245 << 8)) << 12) & 0xA000A000A000A000LL | (v246 ^ (v245 << 8)) & 0x5555555555555555LL);
  do
  {
    v255 = (unsigned __int16)(v247 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v250 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v249 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (unsigned __int64)((unsigned int)(v254 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) << 16)) << 16)) << 16);
    v256 = (v255 ^ (((unsigned __int16)(v272 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v248 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v251 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (unsigned __int64)((unsigned int)(v253 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) << 16)) << 16)) << 16)) >> 8)) & 0xFF00FF00FF00FFLL;
    v257 = v256;
    v258 = v255 ^ v256;
    v259 = (v257 << 8) ^ ((unsigned __int16)(v272 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v248 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (((unsigned __int16)(v251 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) | (unsigned __int64)((unsigned int)(v253 >> ((unsigned __int8)v252 - (unsigned __int8)v277)) << 16)) << 16)) << 16));
    v260 = ((unsigned int)v259 ^ (unsigned int)(v259 >> 28)) & 0xF0F0F0F0;
    v261 = v260 ^ v259 ^ (v260 << 28);
    v262 = ((unsigned int)v258 ^ (unsigned int)(v258 >> 28)) & 0xF0F0F0F0;
    v263 = (v262 << 28) ^ v262 ^ v258;
    v264 = (v261 ^ (v261 >> 14)) & 0xCCCC0000CCCCLL ^ v261 ^ (((v261 ^ (v261 >> 14)) & 0xCCCC0000CCCCLL) << 14);
    v265 = (v263 ^ (v263 >> 14)) & 0xCCCC0000CCCCLL ^ v263 ^ (((v263 ^ (v263 >> 14)) & 0xCCCC0000CCCCLL) << 14);
    v266 = (v264 ^ (v264 >> 7)) & 0xAA00AA00AA00AALL;
    v267 = v266 ^ v264 ^ (v266 << 7);
    *(_WORD *)v252 = v267;
    v268 = (v265 ^ (v265 >> 7)) & 0xAA00AA00AA00AALL ^ v265 ^ (((v265 ^ (v265 >> 7)) & 0xAA00AA00AA00AALL) << 7);
    *(_BYTE *)(v252 + 8) = v268;
    v252 += 16LL;
    *(_BYTE *)(v252 - 14) = BYTE2(v267);
    *(_BYTE *)(v252 - 13) = BYTE3(v267);
    *(_BYTE *)(v252 - 12) = BYTE4(v267);
    *(_BYTE *)(v252 - 11) = BYTE5(v267);
    *(_BYTE *)(v252 - 9) = HIBYTE(v267);
    *(_BYTE *)(v252 - 10) = BYTE6(v267);
    *(_BYTE *)(v252 - 7) = BYTE1(v268);
    *(_BYTE *)(v252 - 6) = BYTE2(v268);
    *(_BYTE *)(v252 - 5) = BYTE3(v268);
    *(_BYTE *)(v252 - 4) = BYTE4(v268);
    *(_BYTE *)(v252 - 3) = BYTE5(v268);
    result = v268 >> 56;
    *(_BYTE *)(v252 - 1) = result;
    *(_BYTE *)(v252 - 2) = ((v265 ^ (v265 >> 7)) & 0xAA00AA00AA00AALL ^ v265 ^ (((v265 ^ (v265 >> 7)) & 0xAA00AA00AA00AALL) << 7)) >> 48;
  }
  while ( v252 != v277 + 64 );
  return result;
}

void __fastcall sub_5BDD0(__int64 a1, _QWORD *a2, int a3)
{
  unsigned __int64 v3; // r12
  _QWORD *v4; // rbx
  _QWORD *v5; // r9
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  signed __int64 v9; // rdx
  _BYTE *v10; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r13
  __int64 v14; // ST08_8
  signed __int64 v15; // ST00_8

  v3 = (unsigned __int64)a2 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    v5 = *(_QWORD **)(a1 - 8);
    v6 = a1 - 1296;
    do
    {
      if ( (_QWORD *)(a1 - 8) == v5 )
      {
        v9 = *(_QWORD *)(a1 - 88);
        v10 = (_BYTE *)(v6 + 1224);
        do
        {
          v10[15] = v9;
          v10[14] = BYTE1(v9);
          v10[13] = BYTE2(v9);
          v10[12] = BYTE3(v9);
          v10[11] = BYTE4(v9);
          v10[10] = BYTE5(v9);
          v10[8] = HIBYTE(v9);
          v10[9] = BYTE6(v9);
          v11 = *(_QWORD *)(a1 - 80);
          v10[7] = v11;
          v10[6] = BYTE1(v11);
          v10[5] = BYTE2(v11);
          v10[4] = BYTE3(v11);
          v10[3] = BYTE4(v11);
          v10[2] = BYTE5(v11);
          *v10 = HIBYTE(v11);
          v10[1] = BYTE6(v11);
          v12 = *(_QWORD *)(a1 - 88);
          v13 = v12;
          v9 = v12 + 1;
          *(_QWORD *)(a1 - 88) = v9;
          v10 += 16;
          *(_QWORD *)(a1 - 80) += (v13 + (unsigned __int128)1uLL) >> 64;
        }
        while ( v10 < (_BYTE *)v5 );
        v14 = v6;
        v15 = v6 + 1224;
        sub_5AC20(v6 + 1224, (_QWORD *)(v6 + 1224), v6);
        v6 = v14;
        *(_QWORD *)(a1 - 8) = v15;
        v5 = (_QWORD *)v15;
      }
      v7 = *v4 ^ *v5;
      v4 += 2;
      *((_WORD *)v4 - 8) = v7;
      *((_BYTE *)v4 - 14) = BYTE2(v7);
      *((_BYTE *)v4 - 13) = BYTE3(v7);
      *((_BYTE *)v4 - 12) = BYTE4(v7);
      *((_BYTE *)v4 - 11) = BYTE5(v7);
      *((_BYTE *)v4 - 9) = HIBYTE(v7);
      *((_BYTE *)v4 - 10) = BYTE6(v7);
      v8 = *(v4 - 1) ^ v5[1];
      *((_WORD *)v4 - 4) = v8;
      *((_BYTE *)v4 - 6) = BYTE2(v8);
      *((_BYTE *)v4 - 5) = BYTE3(v8);
      *((_BYTE *)v4 - 4) = BYTE4(v8);
      *((_BYTE *)v4 - 3) = BYTE5(v8);
      *((_BYTE *)v4 - 1) = HIBYTE(v8);
      *((_BYTE *)v4 - 2) = BYTE6(v8);
      v5 = (_QWORD *)(*(_QWORD *)(a1 - 8) + 16LL);
      *(_QWORD *)(a1 - 8) = v5;
    }
    while ( v3 > (unsigned __int64)v4 );
  }
}

void __fastcall sub_5BFF0(__int64 a1, _QWORD *a2, int a3)
{
  unsigned __int64 v3; // r12
  _QWORD *v4; // rbx
  _QWORD *v5; // r9
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  signed __int64 v9; // rdx
  _BYTE *v10; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r13
  __int64 v14; // ST08_8
  signed __int64 v15; // ST00_8

  v3 = (unsigned __int64)a2 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    v5 = *(_QWORD **)(a1 - 8);
    v6 = a1 - 1296;
    do
    {
      if ( (_QWORD *)(a1 - 8) == v5 )
      {
        v9 = *(_QWORD *)(a1 - 88);
        v10 = (_BYTE *)(v6 + 1224);
        do
        {
          v10[15] = v9;
          v10[14] = BYTE1(v9);
          v10[13] = BYTE2(v9);
          v10[12] = BYTE3(v9);
          v10[11] = BYTE4(v9);
          v10[10] = BYTE5(v9);
          v10[8] = HIBYTE(v9);
          v10[9] = BYTE6(v9);
          v11 = *(_QWORD *)(a1 - 80);
          v10[7] = v11;
          v10[6] = BYTE1(v11);
          v10[5] = BYTE2(v11);
          v10[4] = BYTE3(v11);
          v10[3] = BYTE4(v11);
          v10[2] = BYTE5(v11);
          *v10 = HIBYTE(v11);
          v10[1] = BYTE6(v11);
          v12 = *(_QWORD *)(a1 - 88);
          v13 = v12;
          v9 = v12 + 1;
          *(_QWORD *)(a1 - 88) = v9;
          v10 += 16;
          *(_QWORD *)(a1 - 80) += (v13 + (unsigned __int128)1uLL) >> 64;
        }
        while ( v10 < (_BYTE *)v5 );
        v14 = v6;
        v15 = v6 + 1224;
        sub_5AC20(v6 + 1224, (_QWORD *)(v6 + 1224), v6);
        v6 = v14;
        *(_QWORD *)(a1 - 8) = v15;
        v5 = (_QWORD *)v15;
      }
      v7 = *v4 ^ *v5;
      v4 += 2;
      *((_WORD *)v4 - 8) = v7;
      *((_BYTE *)v4 - 14) = BYTE2(v7);
      *((_BYTE *)v4 - 13) = BYTE3(v7);
      *((_BYTE *)v4 - 12) = BYTE4(v7);
      *((_BYTE *)v4 - 11) = BYTE5(v7);
      *((_BYTE *)v4 - 9) = HIBYTE(v7);
      *((_BYTE *)v4 - 10) = BYTE6(v7);
      v8 = *(v4 - 1) ^ v5[1];
      *((_WORD *)v4 - 4) = v8;
      *((_BYTE *)v4 - 6) = BYTE2(v8);
      *((_BYTE *)v4 - 5) = BYTE3(v8);
      *((_BYTE *)v4 - 4) = BYTE4(v8);
      *((_BYTE *)v4 - 3) = BYTE5(v8);
      *((_BYTE *)v4 - 1) = HIBYTE(v8);
      *((_BYTE *)v4 - 2) = BYTE6(v8);
      v5 = (_QWORD *)(*(_QWORD *)(a1 - 8) + 16LL);
      *(_QWORD *)(a1 - 8) = v5;
    }
    while ( v3 > (unsigned __int64)v4 );
  }
}

void __fastcall sub_5C210(__int64 a1, _QWORD *a2, int a3)
{
  unsigned __int64 v3; // r12
  _QWORD *v4; // rbx
  _QWORD *v5; // r9
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  signed __int64 v9; // rdx
  _BYTE *v10; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r13
  __int64 v14; // ST08_8
  signed __int64 v15; // ST00_8

  v3 = (unsigned __int64)a2 + a3;
  if ( (unsigned __int64)a2 < v3 )
  {
    v4 = a2;
    v5 = *(_QWORD **)(a1 - 8);
    v6 = a1 - 1296;
    do
    {
      if ( (_QWORD *)(a1 - 8) == v5 )
      {
        v9 = *(_QWORD *)(a1 - 88);
        v10 = (_BYTE *)(v6 + 1224);
        do
        {
          v10[15] = v9;
          v10[14] = BYTE1(v9);
          v10[13] = BYTE2(v9);
          v10[12] = BYTE3(v9);
          v10[11] = BYTE4(v9);
          v10[10] = BYTE5(v9);
          v10[8] = HIBYTE(v9);
          v10[9] = BYTE6(v9);
          v11 = *(_QWORD *)(a1 - 80);
          v10[7] = v11;
          v10[6] = BYTE1(v11);
          v10[5] = BYTE2(v11);
          v10[4] = BYTE3(v11);
          v10[3] = BYTE4(v11);
          v10[2] = BYTE5(v11);
          *v10 = HIBYTE(v11);
          v10[1] = BYTE6(v11);
          v12 = *(_QWORD *)(a1 - 88);
          v13 = v12;
          v9 = v12 + 1;
          *(_QWORD *)(a1 - 88) = v9;
          v10 += 16;
          *(_QWORD *)(a1 - 80) += (v13 + (unsigned __int128)1uLL) >> 64;
        }
        while ( v10 < (_BYTE *)v5 );
        v14 = v6;
        v15 = v6 + 1224;
        sub_5AC20(v6 + 1224, (_QWORD *)(v6 + 1224), v6);
        v6 = v14;
        *(_QWORD *)(a1 - 8) = v15;
        v5 = (_QWORD *)v15;
      }
      v7 = *v4 ^ *v5;
      v4 += 2;
      *((_WORD *)v4 - 8) = v7;
      *((_BYTE *)v4 - 14) = BYTE2(v7);
      *((_BYTE *)v4 - 13) = BYTE3(v7);
      *((_BYTE *)v4 - 12) = BYTE4(v7);
      *((_BYTE *)v4 - 11) = BYTE5(v7);
      *((_BYTE *)v4 - 9) = HIBYTE(v7);
      *((_BYTE *)v4 - 10) = BYTE6(v7);
      v8 = *(v4 - 1) ^ v5[1];
      *((_WORD *)v4 - 4) = v8;
      *((_BYTE *)v4 - 6) = BYTE2(v8);
      *((_BYTE *)v4 - 5) = BYTE3(v8);
      *((_BYTE *)v4 - 4) = BYTE4(v8);
      *((_BYTE *)v4 - 3) = BYTE5(v8);
      *((_BYTE *)v4 - 1) = HIBYTE(v8);
      *((_BYTE *)v4 - 2) = BYTE6(v8);
      v5 = (_QWORD *)(*(_QWORD *)(a1 - 8) + 16LL);
      *(_QWORD *)(a1 - 8) = v5;
    }
    while ( v3 > (unsigned __int64)v4 );
  }
}

__int64 __fastcall sub_5C430(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  unsigned __int8 v3; // r9
  int v4; // ebp
  __int64 v5; // rax
  signed __int64 v6; // r10
  int v7; // er11
  signed __int64 v8; // rdx
  int v9; // ebx
  char *v10; // rcx
  char v11; // al
  char *v12; // r8
  __int64 result; // rax

  v3 = a1[1];
  v4 = *a1;
  if ( a3 > 0 )
  {
    v5 = (unsigned int)(a3 - 1);
    v6 = (signed __int64)(a1 + 2);
    v7 = *a1;
    v8 = (signed __int64)&a2[v5 + 1];
    v9 = v5;
    do
    {
      v10 = (char *)(v6 + (unsigned __int8)++v7);
      v11 = *v10;
      v3 += *v10;
      v12 = (char *)(v6 + v3);
      *v10 = *v12;
      *v12 = v11;
      result = *(unsigned __int8 *)(v6 + (unsigned __int8)(*v10 + v11));
      *a2++ ^= result;
    }
    while ( a2 != (_BYTE *)v8 );
    v4 += v9 + 1;
  }
  *a1 = v4;
  a1[1] = v3;
  return result;
}

void nullsub_27()
{
  ;
}

__int64 __fastcall sub_5C4B0(__int64 a1, _BYTE *a2, int a3)
{
  return sub_5C430((unsigned __int8 *)(a1 - 264), a2, a3);
}

char *__fastcall sub_5C4C0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x110uLL, 0LL);
  v1[33] = a1;
  return (char *)(v1 + 33);
}

void __fastcall sub_5C4F0(__int64 a1)
{
  sub_BD070((void *)(a1 - 264), 0x110uLL);
  sub_2F4D0((void *)(a1 - 264));
}

void __fastcall sub_5C510(__int64 a1, __int64 a2)
{
  unsigned int v2; // er9
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // rax
  unsigned __int8 v6; // dl
  char v7; // si
  _BYTE *v8; // rcx
  _QWORD *v9; // rbp
  __int64 v10; // [rsp+0h] [rbp-128h]
  unsigned __int64 v11; // [rsp+108h] [rbp-20h]

  v11 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 80LL);
  if ( v2 > 0x100 )
    __assert_fail("keybytes <= 256", "ssharcf.c", 0x28u, "arcfour_setkey");
  *(_BYTE *)(a1 - 263) = 0;
  *(_BYTE *)(a1 - 264) = 0;
  v3 = 0LL;
  v4 = a1 - 264 + 2;
  do
  {
    *(_BYTE *)(v4 + v3) = v3;
    *((_BYTE *)&v10 + v3) = *(_BYTE *)(a2 + (unsigned int)v3 % v2);
    ++v3;
  }
  while ( v3 != 256 );
  v5 = 0LL;
  v6 = 0;
  do
  {
    v7 = *(_BYTE *)(v4 + v5);
    v6 += *(_BYTE *)(v4 + v5) + *((_BYTE *)&v10 + v5);
    v8 = (_BYTE *)(v4 + v6);
    *(_BYTE *)(v4 + v5++) = *v8;
    *v8 = v7;
  }
  while ( v5 != 256 );
  v9 = sub_2F450(0x600uLL, 1uLL, 0LL);
  *v9 = 0LL;
  v9[191] = 0LL;
  memset(
    (void *)((unsigned __int64)(v9 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v9 - (((_DWORD)v9 + 8) & 0xFFFFFFF8) + 1536) >> 3));
  sub_5C430((unsigned __int8 *)(a1 - 264), v9, 1536);
  sub_BD070(v9, 0x600uLL);
  if ( __readfsqword(0x28u) == v11 )
    sub_2F4D0(v9);
}

__int64 __fastcall sub_5C660(unsigned int a1)
{
  unsigned int v1; // ebx
  bool v2; // cf
  bool v3; // zf
  unsigned int v4; // edi
  _QWORD *v5; // rax
  __int64 v6; // rbp
  __int64 (__fastcall **v7)(_QWORD, __int16 *, signed __int64); // rax
  __int64 result; // rax
  __int16 v9; // [rsp+4h] [rbp-24h]
  char v10; // [rsp+6h] [rbp-22h]
  char v11; // [rsp+7h] [rbp-21h]
  unsigned __int64 v12; // [rsp+8h] [rbp-20h]

  v1 = a1;
  v12 = __readfsqword(0x28u);
  v2 = a1 < 0x40;
  v3 = a1 == 64;
  v4 = 64;
  if ( v2 || v3 )
    v4 = v1;
  v5 = sub_5EFE0(v4);
  v6 = (__int64)v5;
  v7 = (__int64 (__fastcall **)(_QWORD, __int16 *, signed __int64))v5[1];
  v9 = v1;
  v10 = BYTE2(v1);
  v11 = HIBYTE(v1);
  result = (*v7)(v7, &v9, 4LL);
  if ( __readfsqword(0x28u) == v12 )
    result = v6;
  return result;
}

unsigned __int64 __fastcall sub_5C6E0(__int64 (***a1)(void), unsigned int a2, __int64 a3)
{
  __int64 (***v3)(void); // r15
  unsigned int v4; // er12
  __int64 v5; // rbp
  unsigned int v6; // edi
  __int64 v8; // [rsp+0h] [rbp-98h]
  __m128i v9[4]; // [rsp+10h] [rbp-88h]
  unsigned __int64 v10; // [rsp+58h] [rbp-40h]

  v3 = a1;
  v10 = __readfsqword(0x28u);
  v8 = a3;
  if ( a2 > 0x40 )
  {
    v4 = a2 - 32;
    v5 = a3;
    while ( 1 )
    {
      v5 += 32LL;
      ((void (__fastcall *)(__int64 (***)(void), __m128i *))(*v3)[3])(v3, v9);
      ((void (__fastcall *)(__int64 (***)(void)))(*v3)[4])(v3);
      v6 = 64;
      *(__m128i *)(v5 - 32) = _mm_load_si128(v9);
      *(__m128i *)(v5 - 16) = _mm_load_si128(&v9[1]);
      if ( v4 <= 0x40 )
        v6 = v4;
      v3 = (__int64 (***)(void))sub_5EFE0(v6);
      sub_2EC20(v3[1]);
      sub_BD070(v9, 0x40uLL);
      if ( v4 == a2 - 32 - ((a2 - 65) & 0xFFFFFFE0) )
        break;
      v4 -= 32;
    }
    v8 += 32 * (((a2 - 65) >> 5) + 1LL);
  }
  ((void (__fastcall *)(__int64 (***)(void), __int64))(*v3)[3])(v3, v8);
  ((void (__fastcall *)(__int64 (***)(void)))(*v3)[4])(v3);
  return __readfsqword(0x28u) ^ v10;
}

unsigned __int64 __fastcall sub_5C7F0(void (__fastcall **a1)(_QWORD, __int16 *, signed __int64), __int16 *a2, unsigned __int64 a3)
{
  signed __int64 v3; // rbx
  __int16 v5; // [rsp+4h] [rbp-24h]
  char v6; // [rsp+6h] [rbp-22h]
  char v7; // [rsp+7h] [rbp-21h]
  unsigned __int64 v8; // [rsp+8h] [rbp-20h]

  v8 = __readfsqword(0x28u);
  if ( a3 >> 31 > 1 )
    __assert_fail("(pl.len >> 31) < 2", "sshargon2.c", 0x23u, "BinarySink_put_stringpl_le");
  v3 = a3;
  v5 = a3;
  v6 = BYTE2(a3);
  v7 = BYTE3(a3);
  (*a1)(a1, &v5, 4LL);
  (*a1)(a1, a2, v3);
  return __readfsqword(0x28u) ^ v8;
}

unsigned __int64 __fastcall sub_5C8A0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  char *v4; // r12
  char *v5; // r11
  __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // r8
  signed __int64 v10; // rdx
  __int64 v11; // rsi
  __int64 v12; // rax
  signed __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // r8
  signed __int64 v16; // rdi
  __int64 v17; // rcx
  signed __int64 v18; // ST20_8
  __int64 v19; // ST28_8
  unsigned __int64 v20; // rdi
  __int64 v21; // rdx
  signed __int64 v22; // rax
  __int64 v23; // r9
  __int64 v24; // rcx
  signed __int64 v25; // r9
  __int64 v26; // ST10_8
  __int64 v27; // rdi
  signed __int64 v28; // ST18_8
  __int64 v29; // rcx
  unsigned __int64 v30; // r10
  __int64 v31; // rdx
  signed __int64 v32; // rax
  __int64 v33; // rdi
  signed __int64 v34; // rbx
  __int64 v35; // ST08_8
  signed __int64 v36; // r13
  __int64 v37; // rax
  __int64 v38; // rdi
  unsigned __int64 v39; // r15
  __int64 v40; // rdx
  signed __int64 v41; // rbp
  signed __int64 v42; // r14
  __int64 v43; // rax
  unsigned __int64 v44; // r10
  __int64 v45; // r15
  __int64 v46; // rdx
  signed __int64 v47; // rbp
  __int64 v48; // rax
  signed __int64 v49; // rsi
  __int64 v50; // rdx
  signed __int64 v51; // r13
  __int64 v52; // rcx
  signed __int64 v53; // r14
  __int64 v54; // rdx
  signed __int64 v55; // rsi
  signed __int64 v56; // r9
  __int64 v57; // r8
  signed __int64 v58; // rbp
  __int64 v59; // rdi
  signed __int64 v60; // rdx
  __int64 v61; // r8
  signed __int64 v62; // rdx
  signed __int64 v63; // rbx
  __int64 v64; // rdx
  signed __int64 v65; // rcx
  __int64 v66; // rax
  signed __int64 v67; // rbx
  __int64 v68; // rdx
  signed __int64 v69; // rdx
  signed __int64 v70; // r10
  __int64 v71; // rax
  signed __int64 v72; // rcx
  signed __int64 v73; // r10
  __int64 v74; // r10
  signed __int64 v75; // r10
  char *v76; // r9
  char *v77; // r15
  __int64 v78; // rax
  __int64 v79; // rax
  unsigned __int64 v80; // rcx
  __int64 v81; // r8
  signed __int64 v82; // rdx
  __int64 v83; // rsi
  __int64 v84; // rax
  signed __int64 v85; // rsi
  __int64 v86; // rcx
  __int64 v87; // r8
  signed __int64 v88; // rdi
  __int64 v89; // rcx
  signed __int64 v90; // ST20_8
  __int64 v91; // ST28_8
  unsigned __int64 v92; // rdi
  __int64 v93; // rdx
  signed __int64 v94; // rax
  __int64 v95; // r10
  __int64 v96; // rcx
  signed __int64 v97; // r10
  __int64 v98; // ST10_8
  __int64 v99; // rdi
  signed __int64 v100; // r11
  __int64 v101; // rax
  signed __int64 v102; // ST18_8
  __int64 v103; // rcx
  unsigned __int64 v104; // r11
  signed __int64 v105; // rbp
  __int64 v106; // rdx
  signed __int64 v107; // rax
  __int64 v108; // rdi
  unsigned __int64 v109; // rbx
  __int64 v110; // ST08_8
  signed __int64 v111; // r12
  __int64 v112; // rax
  __int64 v113; // rdi
  unsigned __int64 v114; // r14
  __int64 v115; // rdx
  signed __int64 v116; // rbp
  signed __int64 v117; // r13
  __int64 v118; // rax
  unsigned __int64 v119; // r11
  __int64 v120; // r14
  __int64 v121; // rdx
  signed __int64 v122; // rbp
  __int64 v123; // rax
  signed __int64 v124; // rsi
  __int64 v125; // rdx
  signed __int64 v126; // r12
  __int64 v127; // rcx
  signed __int64 v128; // r13
  __int64 v129; // rdx
  signed __int64 v130; // rsi
  signed __int64 v131; // r10
  __int64 v132; // r8
  signed __int64 v133; // rbp
  __int64 v134; // rdi
  signed __int64 v135; // rdx
  __int64 v136; // r8
  signed __int64 v137; // rdx
  signed __int64 v138; // rbx
  __int64 v139; // rdx
  signed __int64 v140; // rcx
  __int64 v141; // rax
  signed __int64 v142; // rbx
  __int64 v143; // rdx
  signed __int64 v144; // rdx
  signed __int64 v145; // r11
  __int64 v146; // rax
  signed __int64 v147; // rcx
  signed __int64 v148; // r11
  __int64 v149; // r11
  signed __int64 v150; // r11
  _QWORD *v151; // rdi
  __int64 v152; // rdx
  __int64 v153; // rax
  __int64 v154; // rax
  _QWORD *v156; // [rsp+50h] [rbp-C58h]
  char v157[1024]; // [rsp+60h] [rbp-C48h]
  char v158; // [rsp+460h] [rbp-848h]
  char v159[128]; // [rsp+860h] [rbp-448h]
  char v160; // [rsp+8E0h] [rbp-3C8h]
  unsigned __int64 v161; // [rsp+C68h] [rbp-40h]

  v156 = a1;
  v161 = __readfsqword(0x28u);
  v3 = 0LL;
  do
  {
    *(_QWORD *)&v157[v3] = *(_QWORD *)(a2 + v3) ^ *(_QWORD *)(a3 + v3);
    v3 += 8LL;
  }
  while ( v3 != 1024 );
  v4 = &v158;
  v5 = v157;
  do
  {
    v6 = 0LL;
    do
    {
      *(_QWORD *)&v4[v6] = *(_QWORD *)&v5[v6];
      *(_QWORD *)&v4[v6 + 8] = *(_QWORD *)&v5[v6 + 8];
      v6 += 16LL;
    }
    while ( v6 != 128 );
    v7 = *((_QWORD *)v4 + 4);
    v8 = v7 + *(_QWORD *)v4 + 2 * (unsigned int)*((_QWORD *)v4 + 4) * (unsigned __int64)(unsigned int)*(_QWORD *)v4;
    v9 = __ROL8__(v8 ^ *((_QWORD *)v4 + 12), 32);
    v10 = v9 + *((_QWORD *)v4 + 8) + (unsigned int)v9 * 2LL * (unsigned int)*((_QWORD *)v4 + 8);
    v11 = (_DWORD)v7 + *(_DWORD *)v4 + 2 * (unsigned int)*((_QWORD *)v4 + 4) * (unsigned int)*(_QWORD *)v4;
    v12 = __ROR8__(v10 ^ v7, 24);
    v13 = v12 + v8 + (unsigned int)v12 * 2 * v11;
    v14 = (_DWORD)v9 + *((_DWORD *)v4 + 16) + (unsigned int)v9 * 2 * (unsigned int)*((_QWORD *)v4 + 8);
    v15 = __ROR8__(v13 ^ v9, 16);
    v16 = (unsigned int)v15 * 2 * v14 + v15 + v10;
    v17 = *((_QWORD *)v4 + 5);
    v18 = v16;
    v19 = __ROL8__(v16 ^ v12, 1);
    v20 = v17 + *((_QWORD *)v4 + 1) + 2 * (unsigned int)v17 * (unsigned __int64)(unsigned int)*((_QWORD *)v4 + 1);
    v21 = __ROL8__(v20 ^ *((_QWORD *)v4 + 13), 32);
    v22 = v21 + *((_QWORD *)v4 + 9) + (unsigned int)v21 * 2LL * (unsigned int)*((_QWORD *)v4 + 9);
    v23 = (_DWORD)v17 + *((_DWORD *)v4 + 2) + 2 * (unsigned int)v17 * (unsigned int)*((_QWORD *)v4 + 1);
    v24 = __ROR8__(v22 ^ v17, 24);
    v25 = v24 + v20 + (unsigned int)v24 * 2 * v23;
    v26 = __ROR8__(v25 ^ v21, 16);
    v27 = *((_QWORD *)v4 + 6);
    v28 = (unsigned int)v26 * 2LL * (unsigned int)v22 + v26 + v22;
    v29 = __ROL8__(v28 ^ v24, 1);
    v30 = v27
        + *((_QWORD *)v4 + 2)
        + 2 * (unsigned int)*((_QWORD *)v4 + 6) * (unsigned __int64)(unsigned int)*((_QWORD *)v4 + 2);
    v31 = __ROL8__(v30 ^ *((_QWORD *)v4 + 14), 32);
    v32 = v31 + *((_QWORD *)v4 + 10) + 2LL * (unsigned int)*((_QWORD *)v4 + 10) * (unsigned int)v31;
    v33 = __ROR8__(v32 ^ v27, 24);
    v34 = v33 + v30 + 2LL * (unsigned int)v30 * (unsigned int)v33;
    v35 = __ROR8__(v34 ^ v31, 16);
    v36 = v35 + v32 + 2LL * (unsigned int)v32 * (unsigned int)v35;
    v37 = *((_QWORD *)v4 + 7);
    v38 = __ROL8__(v36 ^ v33, 1);
    v39 = v37
        + *((_QWORD *)v4 + 3)
        + 2 * (unsigned int)*((_QWORD *)v4 + 3) * (unsigned __int64)(unsigned int)*((_QWORD *)v4 + 7);
    v40 = __ROL8__(v39 ^ *((_QWORD *)v4 + 15), 32);
    v41 = 2LL
        * ((_DWORD)v37 + *((_DWORD *)v4 + 6) + 2 * (unsigned int)*((_QWORD *)v4 + 3) * (unsigned int)*((_QWORD *)v4 + 7));
    v42 = v40 + *((_QWORD *)v4 + 11) + 2LL * (unsigned int)*((_QWORD *)v4 + 11) * (unsigned int)v40;
    v43 = __ROR8__(v42 ^ v37, 24);
    v44 = v43 + v39 + v41 * (unsigned int)v43;
    v45 = (_DWORD)v40 + *((_DWORD *)v4 + 22) + 2 * (unsigned int)*((_QWORD *)v4 + 11) * (unsigned int)v40;
    v46 = __ROR8__(v44 ^ v40, 16);
    v47 = v46 + v42 + 2 * v45 * (unsigned int)v46;
    v48 = __ROL8__(v47 ^ v43, 1);
    v49 = 2LL * (unsigned int)v13 * (unsigned int)v29 + v29 + v13;
    v50 = __ROL8__(v49 ^ v46, 32);
    v51 = 2LL * (unsigned int)v36 * (unsigned int)v50 + v50 + v36;
    v52 = __ROR8__(v51 ^ v29, 24);
    v53 = v52 + v49 + 2LL * (unsigned int)v49 * (unsigned int)v52;
    *(_QWORD *)v4 = v53;
    v54 = __ROR8__(v53 ^ v50, 16);
    *((_QWORD *)v4 + 15) = v54;
    v55 = v54 + v51 + (unsigned int)v54 * 2LL * (unsigned int)v51;
    *((_QWORD *)v4 + 10) = v55;
    *((_QWORD *)v4 + 5) = __ROL8__(v52 ^ v55, 1);
    v56 = 2LL * (unsigned int)v25 * (unsigned int)v38 + v38 + v25;
    v57 = __ROL8__(v56 ^ v15, 32);
    v58 = 2LL * (unsigned int)v47 * (unsigned int)v57 + v57 + v47;
    v59 = __ROR8__(v58 ^ v38, 24);
    v60 = v59 + v56 + 2LL * (unsigned int)v56 * (unsigned int)v59;
    *((_QWORD *)v4 + 1) = v60;
    v61 = __ROR8__(v60 ^ v57, 16);
    *((_QWORD *)v4 + 12) = v61;
    v62 = v61 + v58 + 2LL * (unsigned int)v58 * (unsigned int)v61;
    *((_QWORD *)v4 + 11) = v62;
    *((_QWORD *)v4 + 6) = __ROL8__(v62 ^ v59, 1);
    v63 = (unsigned int)v48 * 2LL * (unsigned int)v34 + v48 + v34;
    v64 = __ROL8__(v63 ^ v26, 32);
    v65 = v64 + v18 + (unsigned int)v64 * 2LL * (unsigned int)v18;
    v66 = __ROR8__(v65 ^ v48, 24);
    v67 = (unsigned int)v66 * 2LL * (unsigned int)v63 + v66 + v63;
    *((_QWORD *)v4 + 2) = v67;
    v68 = __ROR8__(v67 ^ v64, 16);
    *((_QWORD *)v4 + 13) = v68;
    v69 = (unsigned int)v68 * 2LL * (unsigned int)v65 + v65 + v68;
    *((_QWORD *)v4 + 8) = v69;
    *((_QWORD *)v4 + 7) = __ROL8__(v69 ^ v66, 1);
    v70 = (unsigned int)v19 * 2LL * (unsigned int)v44 + v19 + v44;
    v4 += 128;
    v5 += 128;
    v71 = __ROL8__(v70 ^ v35, 32);
    v72 = v71 + v28 + (unsigned int)v71 * 2LL * (unsigned int)v28;
    v73 = (unsigned int)__ROR8__(v72 ^ v19, 24) * 2LL * (unsigned int)v70 + __ROR8__(v72 ^ v19, 24) + v70;
    *((_QWORD *)v4 - 13) = v73;
    v74 = __ROR8__(v71 ^ v73, 16);
    *((_QWORD *)v4 - 2) = v74;
    v75 = (unsigned int)v74 * 2LL * (unsigned int)v72 + v72 + v74;
    *((_QWORD *)v4 - 7) = v75;
    *((_QWORD *)v4 - 12) = __ROL8__(v75 ^ __ROR8__(v72 ^ v19, 24), 1);
  }
  while ( v159 != v4 );
  v76 = &v158;
  v77 = v159;
  do
  {
    v78 = 0LL;
    do
    {
      *(_QWORD *)&v77[v78] = *(_QWORD *)&v76[v78];
      *(_QWORD *)&v77[v78 + 8] = *(_QWORD *)&v76[v78 + 8];
      v78 += 128LL;
    }
    while ( v78 != 1024 );
    v79 = *((_QWORD *)v77 + 32);
    v80 = v79
        + *(_QWORD *)v77
        + 2 * (unsigned int)*((_QWORD *)v77 + 32) * (unsigned __int64)(unsigned int)*(_QWORD *)v77;
    v81 = __ROL8__(v80 ^ *((_QWORD *)v77 + 96), 32);
    v82 = v81 + *((_QWORD *)v77 + 64) + (unsigned int)v81 * 2LL * (unsigned int)*((_QWORD *)v77 + 64);
    v83 = (_DWORD)v79 + *(_DWORD *)v77 + 2 * (unsigned int)*((_QWORD *)v77 + 32) * (unsigned int)*(_QWORD *)v77;
    v84 = __ROR8__(v82 ^ v79, 24);
    v85 = v84 + v80 + (unsigned int)v84 * 2 * v83;
    v86 = (_DWORD)v81 + *((_DWORD *)v77 + 128) + (unsigned int)v81 * 2 * (unsigned int)*((_QWORD *)v77 + 64);
    v87 = __ROR8__(v85 ^ v81, 16);
    v88 = (unsigned int)v87 * 2 * v86 + v87 + v82;
    v89 = *((_QWORD *)v77 + 33);
    v90 = v88;
    v91 = __ROL8__(v88 ^ v84, 1);
    v92 = v89 + *((_QWORD *)v77 + 1) + 2 * (unsigned int)v89 * (unsigned __int64)(unsigned int)*((_QWORD *)v77 + 1);
    v93 = __ROL8__(v92 ^ *((_QWORD *)v77 + 97), 32);
    v94 = v93 + *((_QWORD *)v77 + 65) + (unsigned int)v93 * 2LL * (unsigned int)*((_QWORD *)v77 + 65);
    v95 = (_DWORD)v89 + *((_DWORD *)v77 + 2) + 2 * (unsigned int)v89 * (unsigned int)*((_QWORD *)v77 + 1);
    v96 = __ROR8__(v94 ^ v89, 24);
    v97 = v96 + v92 + (unsigned int)v96 * 2 * v95;
    v98 = __ROR8__(v97 ^ v93, 16);
    v99 = *((_QWORD *)v77 + 48);
    v100 = (unsigned int)v98 * 2LL * (unsigned int)v94 + v98 + v94;
    v101 = *((_QWORD *)v77 + 16);
    v102 = v100;
    v103 = __ROL8__(v100 ^ v96, 1);
    v104 = v99 + v101 + 2 * (unsigned int)v99 * (unsigned __int64)(unsigned int)v101;
    v105 = 2LL * (unsigned int)(v99 + v101 + 2 * v99 * v101);
    v106 = __ROL8__(v104 ^ *((_QWORD *)v77 + 112), 32);
    v107 = v106 + *((_QWORD *)v77 + 80) + 2LL * (unsigned int)*((_QWORD *)v77 + 80) * (unsigned int)v106;
    v108 = __ROR8__(v107 ^ v99, 24);
    v109 = v108 + v104 + v105 * (unsigned int)v108;
    v110 = __ROR8__(v109 ^ v106, 16);
    v111 = v110 + v107 + 2LL * (unsigned int)v107 * (unsigned int)v110;
    v112 = *((_QWORD *)v77 + 49);
    v113 = __ROL8__(v111 ^ v108, 1);
    v114 = v112
         + *((_QWORD *)v77 + 17)
         + 2 * (unsigned int)*((_QWORD *)v77 + 17) * (unsigned __int64)(unsigned int)*((_QWORD *)v77 + 49);
    v115 = __ROL8__(v114 ^ *((_QWORD *)v77 + 113), 32);
    v116 = 2LL
         * ((_DWORD)v112
          + *((_DWORD *)v77 + 34)
          + 2 * (unsigned int)*((_QWORD *)v77 + 17) * (unsigned int)*((_QWORD *)v77 + 49));
    v117 = v115 + *((_QWORD *)v77 + 81) + 2LL * (unsigned int)*((_QWORD *)v77 + 81) * (unsigned int)v115;
    v118 = __ROR8__(v117 ^ v112, 24);
    v119 = v118 + v114 + v116 * (unsigned int)v118;
    v120 = (_DWORD)v115 + *((_DWORD *)v77 + 162) + 2 * (unsigned int)*((_QWORD *)v77 + 81) * (unsigned int)v115;
    v121 = __ROR8__(v119 ^ v115, 16);
    v122 = v121 + v117 + 2 * v120 * (unsigned int)v121;
    v123 = __ROL8__(v122 ^ v118, 1);
    v124 = 2LL * (unsigned int)v85 * (unsigned int)v103 + v103 + v85;
    v125 = __ROL8__(v124 ^ v121, 32);
    v126 = 2LL * (unsigned int)v111 * (unsigned int)v125 + v125 + v111;
    v127 = __ROR8__(v126 ^ v103, 24);
    v128 = v127 + v124 + 2LL * (unsigned int)v124 * (unsigned int)v127;
    *(_QWORD *)v77 = v128;
    v129 = __ROR8__(v128 ^ v125, 16);
    *((_QWORD *)v77 + 113) = v129;
    v130 = v129 + v126 + (unsigned int)v129 * 2LL * (unsigned int)v126;
    *((_QWORD *)v77 + 80) = v130;
    *((_QWORD *)v77 + 33) = __ROL8__(v127 ^ v130, 1);
    v131 = 2LL * (unsigned int)v97 * (unsigned int)v113 + v113 + v97;
    v132 = __ROL8__(v131 ^ v87, 32);
    v133 = 2LL * (unsigned int)v122 * (unsigned int)v132 + v132 + v122;
    v134 = __ROR8__(v133 ^ v113, 24);
    v135 = v134 + v131 + 2LL * (unsigned int)v131 * (unsigned int)v134;
    *((_QWORD *)v77 + 1) = v135;
    v136 = __ROR8__(v135 ^ v132, 16);
    *((_QWORD *)v77 + 96) = v136;
    v137 = v136 + v133 + 2LL * (unsigned int)v133 * (unsigned int)v136;
    *((_QWORD *)v77 + 81) = v137;
    *((_QWORD *)v77 + 48) = __ROL8__(v137 ^ v134, 1);
    v138 = (unsigned int)v123 * 2LL * (unsigned int)v109 + v123 + v109;
    v139 = __ROL8__(v138 ^ v98, 32);
    v140 = v139 + v90 + (unsigned int)v139 * 2LL * (unsigned int)v90;
    v141 = __ROR8__(v140 ^ v123, 24);
    v142 = (unsigned int)v141 * 2LL * (unsigned int)v138 + v141 + v138;
    *((_QWORD *)v77 + 16) = v142;
    v143 = __ROR8__(v142 ^ v139, 16);
    *((_QWORD *)v77 + 97) = v143;
    v144 = (unsigned int)v143 * 2LL * (unsigned int)v140 + v140 + v143;
    *((_QWORD *)v77 + 64) = v144;
    *((_QWORD *)v77 + 49) = __ROL8__(v144 ^ v141, 1);
    v145 = (unsigned int)v91 * 2LL * (unsigned int)v119 + v91 + v119;
    v77 += 16;
    v76 += 16;
    v146 = __ROL8__(v145 ^ v110, 32);
    v147 = v146 + v102 + (unsigned int)v146 * 2LL * (unsigned int)v102;
    v148 = (unsigned int)__ROR8__(v147 ^ v91, 24) * 2LL * (unsigned int)v145 + __ROR8__(v147 ^ v91, 24) + v145;
    *((_QWORD *)v77 + 15) = v148;
    v149 = __ROR8__(v146 ^ v148, 16);
    *((_QWORD *)v77 + 110) = v149;
    v150 = (unsigned int)v149 * 2LL * (unsigned int)v147 + v147 + v149;
    *((_QWORD *)v77 + 63) = v150;
    *((_QWORD *)v77 + 30) = __ROL8__(v150 ^ __ROR8__(v147 ^ v91, 24), 1);
  }
  while ( v77 != &v160 );
  v151 = v156;
  v152 = 0LL;
  do
  {
    v153 = *(_QWORD *)&v159[v152] ^ *(_QWORD *)&v157[v152];
    v152 += 8LL;
    v154 = *v151 ^ v153;
    ++v151;
    *((_WORD *)v151 - 4) = v154;
    *((_BYTE *)v151 - 6) = BYTE2(v154);
    *((_BYTE *)v151 - 5) = BYTE3(v154);
    *((_BYTE *)v151 - 4) = BYTE4(v154);
    *((_BYTE *)v151 - 3) = BYTE5(v154);
    *((_BYTE *)v151 - 1) = HIBYTE(v154);
    *((_BYTE *)v151 - 2) = BYTE6(v154);
  }
  while ( v152 != 1024 );
  sub_BD070(v157, 0x400uLL);
  sub_BD070(&v158, 0x400uLL);
  sub_BD070(v159, 0x400uLL);
  return __readfsqword(0x28u) ^ v161;
}

unsigned __int64 __fastcall sub_5D290(unsigned int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, __int16 *a7, unsigned __int64 a8, __int16 *a9, unsigned __int64 a10, __int16 *a11, unsigned __int64 a12, __int16 *a13, unsigned __int64 a14)
{
  unsigned int v14; // er14
  unsigned int v15; // ebp
  _QWORD *v16; // rax
  _QWORD *v17; // rbx
  void (__fastcall **v18)(_QWORD, int *, signed __int64); // rax
  void (__fastcall **v19)(_QWORD, int *, signed __int64); // rdi
  void (__fastcall **v20)(_QWORD, int *, signed __int64); // rax
  void (__fastcall **v21)(_QWORD, int *, signed __int64); // rax
  void (__fastcall **v22)(_QWORD, int *, signed __int64); // rax
  unsigned __int64 v23; // r14
  void (__fastcall **v24)(_QWORD, int *, signed __int64); // rdi
  __int64 v25; // r12
  __int64 v26; // r13
  char *v27; // rbp
  __int64 v28; // r14
  __int64 (***v29)(void); // r15
  __int64 (**v30)(void); // r8
  __int64 (**v31)(void); // r8
  char v32; // dh^2
  __int64 v33; // r13
  __int64 v34; // r15
  __int64 (***v35)(void); // r14
  __int64 (**v36)(void); // r8
  __int64 (**v37)(void); // r8
  char v38; // dh^2
  bool v39; // di
  __int64 (***v40)(void); // rbp
  unsigned __int64 v41; // r15
  __int64 v42; // rcx
  unsigned int v43; // eax
  int *v44; // rdx
  int v45; // edi
  signed int v46; // esi
  unsigned __int64 v47; // r11
  unsigned int v48; // ebx
  unsigned __int64 v49; // r11
  signed __int64 v50; // rdx
  signed __int64 v51; // r11
  signed __int64 v52; // rax
  char *v53; // rbp
  __int64 v54; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v56; // rt1
  int *v57; // [rsp+0h] [rbp-11B8h]
  char *v58; // [rsp+8h] [rbp-11B0h]
  unsigned int v59; // [rsp+18h] [rbp-11A0h]
  unsigned int v60; // [rsp+1Ch] [rbp-119Ch]
  int *v61; // [rsp+20h] [rbp-1198h]
  int v62; // [rsp+28h] [rbp-1190h]
  __int64 v63; // [rsp+30h] [rbp-1188h]
  bool v64; // [rsp+30h] [rbp-1188h]
  unsigned __int64 v65; // [rsp+40h] [rbp-1178h]
  __int64 v66; // [rsp+48h] [rbp-1170h]
  unsigned __int64 v67; // [rsp+50h] [rbp-1168h]
  unsigned int v68; // [rsp+58h] [rbp-1160h]
  unsigned int v69; // [rsp+5Ch] [rbp-115Ch]
  char v70; // [rsp+80h] [rbp-1138h]
  __int64 v71; // [rsp+88h] [rbp-1130h]
  char v72; // [rsp+90h] [rbp-1128h]
  unsigned __int64 v73; // [rsp+98h] [rbp-1120h]
  char v74; // [rsp+A3h] [rbp-1115h]
  char v75; // [rsp+A4h] [rbp-1114h]
  __int16 v76; // [rsp+A5h] [rbp-1113h]
  char v77; // [rsp+A7h] [rbp-1111h]
  char v78; // [rsp+A8h] [rbp-1110h]
  char v79; // [rsp+B0h] [rbp-1108h]
  char v80; // [rsp+B8h] [rbp-1100h]
  char v81; // [rsp+C0h] [rbp-10F8h]
  char v82; // [rsp+C1h] [rbp-10F7h]
  char v83; // [rsp+C2h] [rbp-10F6h]
  __int16 v84; // [rsp+C3h] [rbp-10F5h]
  __int16 v85; // [rsp+C5h] [rbp-10F3h]
  char v86; // [rsp+C7h] [rbp-10F1h]
  unsigned __int64 v87; // [rsp+C8h] [rbp-10F0h]
  unsigned __int64 v88; // [rsp+D0h] [rbp-10E8h]
  unsigned __int64 v89; // [rsp+D8h] [rbp-10E0h]
  __int64 v90; // [rsp+E0h] [rbp-10D8h]
  __int64 v91; // [rsp+E8h] [rbp-10D0h]
  int v92; // [rsp+F0h] [rbp-10C8h]
  unsigned int v93; // [rsp+F4h] [rbp-10C4h]
  signed __int64 v94; // [rsp+F8h] [rbp-10C0h]
  __int64 v95; // [rsp+100h] [rbp-10B8h]
  __int16 v96; // [rsp+108h] [rbp-10B0h]
  bool v97; // [rsp+10Ah] [rbp-10AEh]
  bool v98; // [rsp+10Bh] [rbp-10ADh]
  unsigned int v99; // [rsp+10Ch] [rbp-10ACh]
  size_t v100; // [rsp+110h] [rbp-10A8h]
  __int64 v101; // [rsp+118h] [rbp-10A0h]
  int v102; // [rsp+120h] [rbp-1098h]
  int v103[255]; // [rsp+124h] [rbp-1094h]
  char v104; // [rsp+520h] [rbp-C98h]
  char v105; // [rsp+920h] [rbp-898h]
  char v106; // [rsp+921h] [rbp-897h]
  __int16 v107; // [rsp+922h] [rbp-896h]
  char v108; // [rsp+928h] [rbp-890h]
  char v109; // [rsp+929h] [rbp-88Fh]
  char v110; // [rsp+92Ah] [rbp-88Eh]
  char v111; // [rsp+92Bh] [rbp-88Dh]
  char v112; // [rsp+930h] [rbp-888h]
  char v113; // [rsp+938h] [rbp-880h]
  char v114; // [rsp+939h] [rbp-87Fh]
  __int16 v115; // [rsp+93Ah] [rbp-87Eh]
  char v116; // [rsp+93Ch] [rbp-87Ch]
  __int16 v117; // [rsp+93Dh] [rbp-87Bh]
  char v118; // [rsp+93Fh] [rbp-879h]
  char v119; // [rsp+940h] [rbp-878h]
  char v120; // [rsp+941h] [rbp-877h]
  __int16 v121; // [rsp+942h] [rbp-876h]
  char v122; // [rsp+948h] [rbp-870h]
  char v123; // [rsp+949h] [rbp-86Fh]
  char v124; // [rsp+94Ah] [rbp-86Eh]
  char v125; // [rsp+94Bh] [rbp-86Dh]
  char v126; // [rsp+950h] [rbp-868h]
  char v127; // [rsp+951h] [rbp-867h]
  char v128; // [rsp+952h] [rbp-866h]
  char v129; // [rsp+953h] [rbp-865h]
  char v130; // [rsp+D20h] [rbp-498h]
  int v131; // [rsp+112Ch] [rbp-8Ch]
  int v132; // [rsp+1130h] [rbp-88h]
  unsigned __int64 v133; // [rsp+1178h] [rbp-40h]

  v14 = a4;
  v15 = a3;
  v59 = a1;
  v60 = a5;
  v62 = a12;
  v99 = a2;
  LOBYTE(v61) = (_BYTE)a11;
  v101 = a6;
  v133 = __readfsqword(0x28u);
  v16 = sub_5EFE0(0x40u);
  v17 = v16;
  v88 = a1;
  v18 = (void (__fastcall **)(_QWORD, int *, signed __int64))v16[1];
  v132 = a1;
  (*v18)(v18, &v132, 4LL);
  v19 = (void (__fastcall **)(_QWORD, int *, signed __int64))v17[1];
  v132 = a2;
  (*v19)(v19, &v132, 4LL);
  v20 = (void (__fastcall **)(_QWORD, int *, signed __int64))v17[1];
  HIBYTE(v132) = HIBYTE(v15);
  LOWORD(v132) = v15;
  BYTE2(v132) = BYTE2(v15);
  (*v20)(v20, &v132, 4LL);
  v21 = (void (__fastcall **)(_QWORD, int *, signed __int64))v17[1];
  v95 = v14;
  v81 = v14;
  LOWORD(v132) = v14;
  HIBYTE(v132) = HIBYTE(v14);
  BYTE2(v132) = BYTE2(v14);
  (*v21)(v21, &v132, 4LL);
  v22 = (void (__fastcall **)(_QWORD, int *, signed __int64))v17[1];
  v57 = &v132;
  v132 = 19;
  (*v22)(v22, &v132, 4LL);
  v23 = v60;
  v24 = (void (__fastcall **)(_QWORD, int *, signed __int64))v17[1];
  v77 = v60;
  LOWORD(v132) = __PAIR__(BYTE1(v23), (unsigned __int8)v60);
  HIWORD(v132) = HIWORD(v60);
  (*v24)(v24, &v132, 4LL);
  sub_5C7F0((void (__fastcall **)(_QWORD, __int16 *, signed __int64))v17[1], a7, a8);
  sub_5C7F0((void (__fastcall **)(_QWORD, __int16 *, signed __int64))v17[1], a9, a10);
  sub_5C7F0((void (__fastcall **)(_QWORD, __int16 *, signed __int64))v17[1], a11, a12);
  sub_5C7F0((void (__fastcall **)(_QWORD, __int16 *, signed __int64))v17[1], a13, a14);
  (*(void (__fastcall **)(_QWORD *, int *))(*v17 + 24LL))(v17, &v132);
  (*(void (__fastcall **)(_QWORD *))(*v17 + 32LL))(v17);
  v25 = v88;
  v93 = v15 / (4 * v59);
  v26 = 4LL * (v15 / (4 * v59));
  v73 = v26 * v88;
  v27 = (char *)sub_2F450(v26 * v88, 0x400uLL, 0LL);
  v58 = v27;
  v100 = v26 * v88 << 10;
  memset(v27, 0, v100);
  if ( v88 )
  {
    v63 = v26;
    v62 = v60;
    v61 = &v131;
    v28 = 0LL;
    do
    {
      v29 = (__int64 (***)(void))sub_5C660(0x400u);
      sub_2EC20(v29[1]);
      v30 = v29[1];
      v131 = 0;
      ((void (__fastcall *)(__int64 (**)(void), int *, signed __int64))*v30)(v30, &v131, 4LL);
      v31 = v29[1];
      LOWORD(v131) = v28;
      BYTE2(v131) = BYTE2(v28);
      v32 = BYTE3(v28);
      ++v28;
      HIBYTE(v131) = v32;
      ((void (__fastcall *)(__int64 (**)(void), int *, signed __int64))*v31)(v31, &v131, 4LL);
      sub_5C6E0(v29, 0x400u, (__int64)v27);
      v27 += 1024;
    }
    while ( v88 != v28 );
    v33 = 0LL;
    v34 = v28;
    v25 = (__int64)&v58[1024 * v88];
    do
    {
      v35 = (__int64 (***)(void))sub_5C660(0x400u);
      sub_2EC20(v35[1]);
      v36 = v35[1];
      v131 = 1;
      ((void (__fastcall *)(__int64 (**)(void), int *, signed __int64))*v36)(v36, &v131, 4LL);
      v37 = v35[1];
      LOWORD(v131) = v33;
      BYTE2(v131) = BYTE2(v33);
      v38 = BYTE3(v33);
      ++v33;
      HIBYTE(v131) = v38;
      ((void (__fastcall *)(__int64 (**)(void), int *, signed __int64))*v37)(v37, &v131, 4LL);
      sub_5C6E0(v35, 0x400u, v25);
      v25 += 1024LL;
    }
    while ( v33 != v34 );
    v23 = v60;
    v26 = v63;
  }
  v64 = v60 == 0;
  if ( !v95 )
    goto LABEL_35;
  v66 = 0LL;
  v67 = 2LL;
  v85 = WORD1(v73);
  v80 = BYTE1(v73);
  v96 = *(_WORD *)((char *)&v73 + 5);
  v86 = BYTE4(v73);
  v87 = v73 >> 56;
  v84 = WORD1(v95);
  v79 = BYTE1(v95);
  v78 = BYTE1(v23);
  v82 = BYTE2(v23);
  v83 = BYTE3(v23);
  v98 = v60 == 2;
  v65 = v88 << 10;
LABEL_9:
  v91 = 0LL;
  v69 = 0;
  v71 = 0LL;
  v76 = WORD1(v66);
  v72 = BYTE1(v66);
  v97 = v98 && v66 == 0;
  v68 = v26 - 1;
LABEL_10:
  v39 = v64;
  v92 = v71;
  if ( v97 && (_DWORD)v71 == 2 )
    v39 = v97 && (_DWORD)v71 == 2;
  v64 = v39;
  if ( v88 )
  {
    v25 = 0LL;
    v60 = v93 * (((_BYTE)v71 + 1) & 3);
    v90 = v67 + v91;
    v94 = v26 - 1;
    v89 = (v67 + v91) * v88;
LABEL_14:
    if ( v93 <= v67 )
      goto LABEL_32;
    v57 = (int *)v25;
    v70 = BYTE1(v25);
    v74 = BYTE2(v25);
    v75 = BYTE3(v25);
    LOBYTE(v61) = v92 != 0 || v66 != 0;
    v62 = v60 - 1;
    v40 = (__int64 (***)(void))&v58[1024 * (v89 + v25)];
    v25 = v90;
    v23 = v67;
    v41 = v26;
LABEL_23:
    v48 = v25 - 1;
    if ( !v25 )
      v48 = v68;
    v26 = (__int64)&v58[1024 * ((_QWORD)v57 + v48 * v59)];
    if ( v64 )
    {
      v42 = *(unsigned int *)v26;
      v43 = *(_DWORD *)(v26 + 4);
      if ( !(_BYTE)v61 )
      {
LABEL_30:
        v45 = (signed int)v57;
        v47 = v41;
        v46 = -1;
        goto LABEL_22;
      }
    }
    else
    {
      v49 = v23 & 0x7F;
      if ( v23 == v67 || !(v23 & 0x7F) )
      {
        memset(&v105, 0, 0x400uLL);
        v105 = v66;
        v106 = v72;
        v107 = v76;
        v108 = (char)v57;
        v109 = v70;
        v110 = v74;
        v111 = v75;
        v112 = v71;
        v113 = v73;
        v114 = v80;
        v115 = v85;
        v116 = v86;
        v117 = v96;
        v119 = v81;
        v118 = v87;
        v121 = v84;
        v120 = v79;
        v122 = v77;
        v124 = v82;
        v123 = v78;
        v125 = v83;
        v50 = (v23 >> 7) + 1;
        v126 = (v23 >> 7) + 1;
        v127 = BYTE1(v50);
        v129 = BYTE3(v50);
        v128 = ((unsigned int)(v23 >> 7) + 1) >> 16;
        memset(&v104, 0, 0x400uLL);
        sub_5C8A0(&v104, (__int64)&v104, (__int64)&v105);
        memset(&v102, 0, 0x400uLL);
        sub_5C8A0(&v102, (__int64)&v102, (__int64)&v104);
        v49 = v23 & 0x7F;
      }
      v51 = 2 * v49;
      v42 = *(unsigned int *)((char *)&v102 + v51 * 4);
      v43 = v103[v51];
      if ( !(_BYTE)v61 )
        goto LABEL_30;
    }
    v44 = (int *)(v43 % v59);
    v45 = v43 % v59;
    if ( v66 )
    {
      v46 = v62;
      v47 = v41 - v60;
      goto LABEL_19;
    }
    goto LABEL_42;
  }
  while ( 1 )
  {
    ++v71;
    v69 += v93;
    v91 += v93;
    v67 = 0LL;
    if ( v71 != 4 )
      goto LABEL_10;
    if ( v95 != ++v66 )
      goto LABEL_9;
LABEL_35:
    qmemcpy(&v130, &v58[v88 * ((v26 << 10) - 1024)], 0x400uLL);
    if ( v88 > 1 )
    {
      v52 = v88 * (v26 - 1);
      v25 = (__int64)&v58[1024 * (v52 + 1)];
      v53 = &v58[1024 * (v88 + v52)];
      do
      {
        v54 = v25;
        v25 += 1024LL;
        sub_BD620((__int64)&v130, (__int64)&v130, v54, 0);
      }
      while ( (char *)v25 != v53 );
    }
    v41 = v99;
    v40 = (__int64 (***)(void))sub_5C660(v99);
    sub_2EC20(v40[1]);
    sub_5C6E0(v40, v99, v101);
    sub_BD070(&v102, 0x400uLL);
    sub_BD070(&v104, 0x400uLL);
    sub_BD070(&v105, 0x400uLL);
    sub_BD070(&v130, 0x400uLL);
    v48 = (unsigned int)v58;
    sub_BD070(v58, v100);
    v45 = (signed int)v58;
    sub_2F4D0(v58);
    v56 = __readfsqword(0x28u);
    result = v56 ^ v133;
    if ( v56 == v133 )
      return result;
LABEL_42:
    v47 = v41;
    v46 = -1;
LABEL_19:
    if ( v57 != v44 )
    {
      if ( v23 )
        v48 = v69;
      else
        v48 = (v94 + (unsigned __int64)(unsigned int)v25) % v41;
    }
LABEL_22:
    ++v23;
    ++v25;
    sub_5C8A0(
      v40,
      v26,
      (__int64)&v58[1024
                  * ((unsigned int)(v46
                                  + (v48 + v47) % v41
                                  - ((unsigned int)((v48 + v47) % v41) * ((unsigned __int64)(v42 * v42) >> 32) >> 32))
                   % v41
                   * v59
                   + v45)]);
    v40 = (__int64 (***)(void))((char *)v40 + v65);
    if ( v93 != v23 )
      goto LABEL_23;
    v25 = (__int64)v57;
    v26 = v41;
LABEL_32:
    if ( v88 != ++v25 )
      goto LABEL_14;
  }
}

unsigned __int64 __fastcall sub_5DF90(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, __int64 a6, __m128i a10, __int128 a7, __int128 a8, __int128 a9, __m128i a11)
{
  unsigned int v11; // er13
  unsigned int v12; // ebp
  int v13; // ebx
  char *v14; // rax
  __m128i v15; // xmm2
  __m128i v16; // xmm1
  __m128i v17; // xmm0
  __m128i v19; // [rsp+0h] [rbp-68h]
  __m128i v20; // [rsp+10h] [rbp-58h]
  __m128i v21; // [rsp+20h] [rbp-48h]
  __m128i v22; // [rsp+30h] [rbp-38h]

  v11 = a3;
  v12 = a4;
  v13 = a5;
  v22 = _mm_loadu_si128((const __m128i *)&a7);
  v21 = _mm_loadu_si128((const __m128i *)&a8);
  v20 = _mm_loadu_si128((const __m128i *)&a9);
  v19 = _mm_loadu_si128(&a11);
  v14 = sub_BC510(a6, a5);
  v15 = _mm_load_si128(&v20);
  v16 = _mm_load_si128(&v21);
  v17 = _mm_load_si128(&v22);
  a11 = _mm_load_si128(&v19);
  return sub_5D290(
           v12,
           v13,
           a2,
           v11,
           a1,
           (__int64)v14,
           (__int16 *)v17.m128i_i64[0],
           v17.m128i_u64[1],
           (__int16 *)v16.m128i_i64[0],
           v16.m128i_u64[1],
           (__int16 *)v15.m128i_i64[0],
           v15.m128i_u64[1],
           (__int16 *)a11.m128i_i64[0],
           a11.m128i_u64[1]);
}

unsigned int *__fastcall sub_5E040(__int64 a1, __int64 a2, int a3, unsigned int *a4, unsigned int a5, unsigned int a6, __int16 *a7, unsigned __int64 a8, __int16 *a9, unsigned __int64 a10, __int16 *a11, unsigned __int64 a12, __int16 *a13, unsigned __int64 a14, __int64 a15)
{
  int v15; // er15
  unsigned int v16; // ebx
  unsigned int v17; // ebp
  unsigned __int64 v18; // r12
  int v19; // eax
  __int64 v20; // r13
  char *v21; // rax
  unsigned int *result; // rax
  unsigned __int64 v23; // [rsp+0h] [rbp-58h]
  unsigned int v24; // [rsp+14h] [rbp-44h]
  unsigned int *v25; // [rsp+18h] [rbp-40h]

  v15 = a6;
  v16 = 1;
  v17 = 1;
  v25 = a4;
  v24 = a5;
  v23 = a6;
  v18 = 1000 * a3 / 0x3E8u;
  while ( 1 )
  {
    v20 = sub_B4D20();
    v21 = sub_BC510(a15, v23);
    sub_5D290(v24, v15, a2, v16, a1, (__int64)v21, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( v18 <= sub_B4D20() - v20 || ~v16 < v17 )
      break;
    sub_BC590((__int64 *)a15, 0LL);
    v19 = v17 + v16;
    v17 = v16;
    v16 = v19;
  }
  result = v25;
  *v25 = v16;
  return result;
}

__int64 __fastcall sub_5E150(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = sub_56530((__int64)&off_31F420);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 24LL))(v2, a1);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 16LL))(v2, a2);
  return v2;
}

__int64 __fastcall sub_5E190(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx

  v2 = sub_63960((__int64)off_320440);
  (*(void (__fastcall **)(signed __int64, __int64))(*(_QWORD *)v2 + 24LL))(v2, a1);
  (*(void (__fastcall **)(signed __int64, __int64))(*(_QWORD *)v2 + 16LL))(v2, a2);
  return v2;
}

__int64 __fastcall sub_5E1D0(__int64 a1)
{
  int v1; // er8
  signed int v2; // ecx
  unsigned int v3; // eax
  __int64 *v4; // rdx
  int v5; // esi
  signed __int64 v6; // rbp
  __int64 v8; // [rsp+0h] [rbp-28h]
  unsigned __int64 v9; // [rsp+8h] [rbp-20h]

  v1 = 0;
  v2 = 0;
  v9 = __readfsqword(0x28u);
  v3 = 0;
  v4 = &v8;
  do
  {
    if ( v2 <= 6 )
    {
      v2 += 8;
      v5 = *(unsigned __int8 *)(a1 + v1++);
      v3 = v5 | (v3 << 8);
    }
    v2 -= 7;
    v4 = (__int64 *)((char *)v4 + 1);
    *((_BYTE *)v4 - 1) = 2 * (v3 >> v2);
    v3 &= ~(127 << v2);
  }
  while ( &v9 != (unsigned __int64 *)v4 );
  v6 = sub_63930((__int64)off_320560);
  (*(void (__fastcall **)(signed __int64, __int64 *))(*(_QWORD *)v6 + 24LL))(v6, &v8);
  sub_BD070(&v8, 8uLL);
  (*(void (__fastcall **)(signed __int64, __int64 *))(*(_QWORD *)v6 + 16LL))(v6, &v8);
  return v6;
}

__int64 __fastcall sub_5E290(const __m128i *a1)
{
  signed __int64 v1; // rbx
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // [rsp+8h] [rbp-40h]
  __m128i v5; // [rsp+10h] [rbp-38h]
  __int64 v6; // [rsp+20h] [rbp-28h]
  unsigned __int64 v7; // [rsp+28h] [rbp-20h]

  v7 = __readfsqword(0x28u);
  v1 = sub_639C0((__int64)off_320320);
  v2 = a1->m128i_i64[0];
  v5 = _mm_loadu_si128(a1);
  v6 = v2;
  (*(void (__fastcall **)(signed __int64, __m128i *))(*(_QWORD *)v1 + 24LL))(v1, &v5);
  sub_BD070(&v5, 0x18uLL);
  v4 = 0LL;
  result = (*(__int64 (__fastcall **)(signed __int64, __int64 *))(*(_QWORD *)v1 + 16LL))(v1, &v4);
  if ( __readfsqword(0x28u) == v7 )
    result = v1;
  return result;
}

__int64 __fastcall sub_5E320(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // er12
  __int64 v5; // rbp
  __int64 v6; // rbx

  v4 = a4;
  v5 = a3;
  v6 = sub_5E150(a1, a2);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 32LL))(v6, v5, v4);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
}

__int64 __fastcall sub_5E360(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // er12
  __int64 v5; // rbp
  __int64 v6; // rbx

  v4 = a4;
  v5 = a3;
  v6 = sub_5E150(a1, a2);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 40LL))(v6, v5, v4);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
}

__int64 __fastcall sub_5E3A0(const __m128i *a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rbx

  v3 = a3;
  v4 = sub_5E290(a1);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 40LL))(v4, a2, v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
}

__int64 __fastcall sub_5E3E0(const __m128i *a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rbx

  v3 = a3;
  v4 = sub_5E290(a1);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 32LL))(v4, a2, v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
}

__int64 __fastcall sub_5E4A0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rbx

  v3 = a3;
  v4 = sub_5E1D0(a1);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 32LL))(v4, a2, v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
}

__int64 __fastcall sub_5E4E0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rbx

  v3 = a3;
  v4 = sub_5E1D0(a1);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v4 + 40LL))(v4, a2, v3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
}

__int64 __fastcall sub_5E520(__int64 (**a1)(void), __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rax
  __int64 (***v6)(void); // rbx

  v4 = a4;
  v5 = (*a1)();
  v6 = (__int64 (***)(void))v5;
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
  sub_2EC30(v6[1]);
  ((void (__fastcall *)(__int64 (***)(void), __int64))(*v6)[3])(v6, v4);
  return ((__int64 (__fastcall *)(__int64 (***)(void)))(*v6)[4])(v6);
}

__int64 __fastcall sub_5E580(__int64 (__fastcall **a1)(_QWORD, _QWORD), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r15
  __int64 v7; // rbp
  __int64 (***v8)(void); // rbx

  v6 = a3;
  v7 = a6;
  v8 = (__int64 (***)(void))(*a1)(a1, 0LL);
  ((void (__fastcall *)(__int64 (***)(void), __int64, __int64))(*v8)[2])(v8, a2, v6);
  ((void (__fastcall *)(__int64 (***)(void)))(*v8)[3])(v8);
  sub_2EC30(v8[1]);
  ((void (__fastcall *)(__int64 (***)(void), __int64))(*v8)[4])(v8, v7);
  return ((__int64 (__fastcall *)(__int64 (***)(void)))(*v8)[1])(v8);
}

signed __int64 __fastcall sub_5E600(__int64 a1)
{
  __m128i v1; // xmm0
  int v2; // eax
  signed __int64 result; // rax
  __m128i v4; // xmm0

  *(_QWORD *)(a1 - 40) = 0LL;
  v1 = _mm_loadu_si128((const __m128i *)((char *)&xmmword_ED220 + 8));
  *(_QWORD *)(a1 - 24) = 0LL;
  *(_QWORD *)(a1 - 32) = 0LL;
  *(_QWORD *)(a1 - 184) = 6620516959819538809LL;
  v2 = *(_DWORD *)(a1 - 176);
  *(__m128i *)(a1 - 232) = v1;
  result = v2 ^ 0x1010000u ^ 0x6A09E667F3BCC908LL;
  v4 = _mm_loadu_si128((const __m128i *)((char *)&xmmword_ED230 + 8));
  *(_QWORD *)(a1 - 240) = result;
  *(__m128i *)(a1 - 216) = v4;
  *(__m128i *)(a1 - 200) = _mm_loadu_si128((const __m128i *)&xmmword_ED248);
  return result;
}

signed __int64 __fastcall sub_5E680(__m128i *a1, const __m128i *a2)
{
  signed __int64 result; // rax

  a1[-15] = _mm_loadu_si128(a2 - 15);
  result = (signed __int64)a1[-1].m128i_i64;
  a1[-14] = _mm_loadu_si128(a2 - 14);
  a1[-13] = _mm_loadu_si128(a2 - 13);
  a1[-12] = _mm_loadu_si128(a2 - 12);
  a1[-11] = _mm_loadu_si128(a2 - 11);
  a1[-10] = _mm_loadu_si128(a2 - 10);
  a1[-9] = _mm_loadu_si128(a2 - 9);
  a1[-8] = _mm_loadu_si128(a2 - 8);
  a1[-7] = _mm_loadu_si128(a2 - 7);
  a1[-6] = _mm_loadu_si128(a2 - 6);
  a1[-5] = _mm_loadu_si128(a2 - 5);
  a1[-4] = _mm_loadu_si128(a2 - 4);
  a1[-3] = _mm_loadu_si128(a2 - 3);
  a1[-2] = _mm_loadu_si128(a2 - 2);
  a1[-1] = _mm_loadu_si128(a2 - 1);
  *a1 = _mm_loadu_si128(a2);
  a1[-1].m128i_i64[1] = result;
  a1->m128i_i64[1] = result;
  return result;
}

void __fastcall sub_5E750(__int64 a1)
{
  sub_BD070((void *)(a1 - 240), 0x100uLL);
  sub_2F4D0((void *)(a1 - 240));
}

_QWORD *__fastcall sub_5E770(unsigned int a1)
{
  char *v1; // rax
  signed __int64 v2; // rdx
  _QWORD *result; // rax

  if ( a1 > 0x40 )
    __assert_fail("hashlen <= ssh_blake2b.hlen", "sshblake2.c", 0x78u, "blake2b_new_inner");
  v1 = (char *)sub_2F450(1uLL, 0x100uLL, 0LL);
  v2 = (signed __int64)(v1 + 224);
  *((_DWORD *)v1 + 16) = a1;
  result = v1 + 240;
  *result = off_31FCC0;
  *(result - 2) = sub_5EDF0;
  *(result - 1) = v2;
  result[1] = v2;
  return result;
}

_QWORD *__fastcall sub_5E7E0(__int64 a1)
{
  return sub_5E770(*(_QWORD *)(a1 + 40));
}

unsigned __int64 __fastcall sub_5E7F0(const __m128i *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rax
  __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __m128i v8; // xmm0
  signed __int64 v9; // r12
  __int128 *v10; // r15
  __int64 v11; // rbp
  signed __int64 v12; // r8
  __int64 v13; // rax
  __int64 v14; // r14
  signed __int64 v15; // r9
  signed __int64 v16; // rdi
  unsigned __int64 v17; // r10
  signed __int64 v18; // rbx
  __int64 v19; // r13
  __m128i v20; // xmm0
  __int64 v21; // r11
  unsigned __int8 v22; // si
  __int64 v23; // rbp
  __int64 v24; // rcx
  unsigned __int64 v25; // r10
  __int64 v26; // r9
  __int64 v27; // rax
  __int64 v28; // rbp
  __int64 v29; // rdx
  signed __int64 v30; // rdi
  __int64 v31; // rcx
  unsigned __int64 v32; // rbx
  __int64 v33; // r10
  __int64 v34; // r9
  unsigned __int64 v35; // ST38_8
  __int64 v36; // rdx
  __int64 v37; // ST40_8
  __int64 v38; // ST48_8
  __int64 v39; // r10
  __int64 v40; // r8
  __int64 v41; // rax
  __int64 v42; // rdi
  __int64 v43; // r14
  __int64 v44; // r8
  __int64 v45; // rax
  __int64 v46; // r12
  __int64 v47; // r14
  __int64 v48; // rsi
  __int64 v49; // r11
  __int64 v50; // rbx
  __int64 v51; // rdi
  __int64 v52; // rsi
  __int64 v53; // r11
  __int64 v54; // rbx
  __int64 v55; // rbp
  __int64 v56; // rdi
  __int64 v57; // r11
  __int64 v58; // r12
  __int64 v59; // r10
  __int64 v60; // r11
  __int64 v61; // r12
  __int64 v62; // r9
  __int64 v63; // rcx
  __int64 v64; // rbx
  __int64 v65; // r14
  __int64 v66; // r10
  __int64 v67; // r8
  __int64 v68; // rdx
  __int64 v69; // r10
  __int64 v70; // rdi
  __int64 v71; // rsi
  __int64 v72; // r12
  __int64 v73; // rdi
  __int64 v74; // rax
  __int64 v75; // rsi
  __int64 v76; // r10
  __int64 i; // rax
  __int64 v79; // [rsp+0h] [rbp-1B8h]
  __int64 v80; // [rsp+8h] [rbp-1B0h]
  __int64 v81; // [rsp+10h] [rbp-1A8h]
  __int64 v82; // [rsp+18h] [rbp-1A0h]
  __int64 v83; // [rsp+20h] [rbp-198h]
  __int64 v84; // [rsp+28h] [rbp-190h]
  __int64 v85; // [rsp+30h] [rbp-188h]
  unsigned __int8 v86; // [rsp+54h] [rbp-164h]
  unsigned __int8 v87; // [rsp+55h] [rbp-163h]
  unsigned __int8 v88; // [rsp+56h] [rbp-162h]
  unsigned __int8 v89; // [rsp+57h] [rbp-161h]
  unsigned __int8 v90; // [rsp+58h] [rbp-160h]
  unsigned __int8 v91; // [rsp+59h] [rbp-15Fh]
  unsigned __int8 v92; // [rsp+5Ah] [rbp-15Eh]
  unsigned __int8 v93; // [rsp+5Bh] [rbp-15Dh]
  unsigned __int8 v94; // [rsp+5Ch] [rbp-15Ch]
  unsigned __int8 v95; // [rsp+5Dh] [rbp-15Bh]
  unsigned __int8 v96; // [rsp+5Eh] [rbp-15Ah]
  unsigned __int8 v97; // [rsp+5Fh] [rbp-159h]
  const __m128i *v98; // [rsp+60h] [rbp-158h]
  __int64 v99[16]; // [rsp+70h] [rbp-148h]
  __m128i v100; // [rsp+F0h] [rbp-C8h]
  __m128i v101; // [rsp+100h] [rbp-B8h]
  __m128i v102; // [rsp+110h] [rbp-A8h]
  __m128i v103; // [rsp+120h] [rbp-98h]
  __m128i v104; // [rsp+130h] [rbp-88h]
  __m128i v105; // [rsp+140h] [rbp-78h]
  __int64 v106; // [rsp+150h] [rbp-68h]
  unsigned __int64 v107; // [rsp+158h] [rbp-60h]
  __m128i v108; // [rsp+160h] [rbp-58h]
  unsigned __int64 v109; // [rsp+178h] [rbp-40h]

  v98 = a1;
  v109 = __readfsqword(0x28u);
  v5 = 0LL;
  do
  {
    v99[v5] = *(_QWORD *)(a2 + v5 * 8);
    ++v5;
  }
  while ( v5 != 16 );
  v6 = a4 ^ 0x510E527FADE682D1LL;
  v7 = a3 ^ 0x9B05688C2B3E6C1FLL;
  v8 = _mm_loadu_si128(a1);
  v9 = -(signed __int64)a5 ^ 0x1F83D9ABFB41BD6BLL;
  v106 = v6;
  v107 = v7;
  v10 = (__int128 *)&unk_ED170;
  v100 = v8;
  v11 = v8.m128i_i64[0];
  v12 = 3LL;
  v101 = _mm_loadu_si128(a1 + 1);
  v84 = v101.m128i_i64[1];
  v85 = v101.m128i_i64[0];
  v102 = _mm_loadu_si128(a1 + 2);
  v13 = v102.m128i_i64[0];
  v103 = _mm_loadu_si128(a1 + 3);
  v80 = v8.m128i_i64[1];
  v14 = v103.m128i_i64[0];
  v15 = 2LL;
  v81 = v103.m128i_i64[1];
  v104 = _mm_load_si128((const __m128i *)&xmmword_ED220);
  v16 = v104.m128i_i64[1];
  v17 = v104.m128i_i64[0];
  v18 = 1LL;
  v105 = _mm_load_si128((const __m128i *)&xmmword_ED230);
  v82 = v105.m128i_i64[0];
  v19 = 0LL;
  v20 = _mm_load_si128((const __m128i *)((char *)&xmmword_ED248 + 8));
  v108 = v20;
  v108.m128i_i64[0] = v9;
  v83 = v20.m128i_i64[1];
  v79 = v105.m128i_i64[1];
  v96 = 5;
  v95 = 14;
  v94 = 15;
  v93 = 12;
  v92 = 13;
  v91 = 10;
  v90 = 11;
  v89 = 8;
  v88 = 9;
  v87 = 6;
  v86 = 7;
  v21 = v102.m128i_i64[1];
  v97 = 4;
  while ( 1 )
  {
    v23 = v13 + v99[v19] + v11;
    v24 = __ROL8__(v23 ^ v6, 32);
    v25 = v24 + v17;
    v26 = v21 + v99[v15] + v80;
    v27 = __ROR8__(v25 ^ v13, 24);
    v28 = v27 + v99[v18] + v23;
    v29 = __ROL8__(v26 ^ v7, 32);
    v30 = v29 + v16;
    v31 = __ROR8__(v28 ^ v24, 16);
    v32 = v31 + v25;
    v33 = __ROR8__(v30 ^ v21, 24);
    v34 = v33 + v99[v12] + v26;
    v35 = v32;
    v36 = __ROR8__(v34 ^ v29, 16);
    v37 = __ROL8__(v32 ^ v27, 1);
    v38 = v36 + v30;
    v39 = __ROL8__((v36 + v30) ^ v33, 1);
    v40 = v85 + v14 + v99[v97];
    v41 = __ROL8__(v40 ^ v9, 32);
    v42 = v41 + v82;
    v43 = __ROR8__((v41 + v82) ^ v14, 24);
    v44 = v43 + v99[v96] + v40;
    v45 = __ROR8__(v44 ^ v41, 16);
    v46 = v45 + v42;
    v47 = __ROL8__((v45 + v42) ^ v43, 1);
    v48 = v81 + v99[v87] + v84;
    v49 = __ROL8__(v48 ^ v83, 32);
    v50 = v49 + v79;
    v51 = __ROR8__((v49 + v79) ^ v81, 24);
    v52 = v51 + v99[v86] + v48;
    v53 = __ROR8__(v52 ^ v49, 16);
    v54 = v53 + v50;
    v55 = v39 + v99[v89] + v28;
    v56 = __ROL8__(v54 ^ v51, 1);
    v57 = __ROL8__(v55 ^ v53, 32);
    v58 = v57 + v46;
    v59 = __ROR8__(v58 ^ v39, 24);
    v11 = v59 + v99[v88] + v55;
    v60 = __ROR8__(v11 ^ v57, 16);
    v61 = v60 + v58;
    v83 = v60;
    v82 = v61;
    v21 = __ROL8__(v61 ^ v59, 1);
    v62 = v47 + v99[v91] + v34;
    v63 = __ROL8__(v62 ^ v31, 32);
    v64 = v63 + v54;
    v65 = __ROR8__(v64 ^ v47, 24);
    v66 = v99[v90] + v62 + v65;
    v80 = v66;
    v6 = __ROR8__(v66 ^ v63, 16);
    v79 = v6 + v64;
    v14 = __ROL8__((v6 + v64) ^ v65, 1);
    v67 = v56 + v99[v93] + v44;
    v68 = __ROL8__(v67 ^ v36, 32);
    v69 = v35 + v68;
    v70 = __ROR8__((v35 + v68) ^ v56, 24);
    v85 = v70 + v99[v92] + v67;
    v7 = __ROR8__(v85 ^ v68, 16);
    v17 = v7 + v69;
    v81 = __ROL8__(v17 ^ v70, 1);
    v71 = v37 + v99[v95] + v52;
    v72 = __ROL8__(v71 ^ v45, 32);
    v73 = v38 + v72;
    v74 = __ROR8__((v38 + v72) ^ v37, 24);
    v84 = v99[v94] + v71 + v74;
    v9 = __ROR8__(v84 ^ v72, 16);
    v16 = v9 + v73;
    v13 = __ROL8__(v16 ^ v74, 1);
    if ( v10 == &xmmword_ED220 )
      break;
    v22 = *((_BYTE *)v10 + 5);
    v18 = *((unsigned __int8 *)v10 + 1);
    ++v10;
    v19 = *((unsigned __int8 *)v10 - 16);
    v12 = *((unsigned __int8 *)v10 - 13);
    v15 = *((unsigned __int8 *)v10 - 14);
    v96 = v22;
    v97 = *((_BYTE *)v10 - 12);
    v86 = *((_BYTE *)v10 - 9);
    v87 = *((_BYTE *)v10 - 10);
    v88 = *((_BYTE *)v10 - 7);
    v89 = *((_BYTE *)v10 - 8);
    v90 = *((_BYTE *)v10 - 5);
    v91 = *((_BYTE *)v10 - 6);
    v92 = *((_BYTE *)v10 - 3);
    v93 = *((_BYTE *)v10 - 4);
    v94 = *((_BYTE *)v10 - 1);
    v95 = *((_BYTE *)v10 - 2);
  }
  v102.m128i_i64[0] = v13;
  v75 = v17;
  v104.m128i_i64[1] = v16;
  v106 = v6;
  v104.m128i_i64[0] = v17;
  v107 = v7;
  v76 = v11;
  v100.m128i_i64[1] = v80;
  v100.m128i_i64[0] = v11;
  v102.m128i_i64[1] = v21;
  v103.m128i_i64[0] = v14;
  v108.m128i_i64[0] = v9;
  v101.m128i_i64[0] = v85;
  v105.m128i_i64[0] = v82;
  v101.m128i_i64[1] = v84;
  v103.m128i_i64[1] = v81;
  v108.m128i_i64[1] = v83;
  v105.m128i_i64[1] = v6 + v64;
  for ( i = 0LL; ; v75 = v104.m128i_i64[i] )
  {
    v98->m128i_i64[i] ^= v75 ^ v76;
    ++i;
    if ( i == 8 )
      break;
    v76 = v100.m128i_i64[i];
  }
  sub_BD070(&v100, 0x80uLL);
  sub_BD070(v99, 0x80uLL);
  return __readfsqword(0x28u) ^ v109;
}

void __fastcall sub_5EDF0(__int64 a1, char *a2, size_t a3)
{
  __int64 v3; // r14
  char *v4; // r13
  size_t v5; // r15
  __int64 v6; // rbp
  size_t v7; // rax
  void *v8; // rdi
  size_t v9; // rbx
  const void *v10; // rsi
  unsigned __int8 v11; // cf
  size_t v12; // rbx
  const __m128i *v13; // [rsp+0h] [rbp-40h]

  if ( a3 )
  {
    v3 = a1;
    v4 = a2;
    v5 = a3;
    v6 = a1 - 224 + 68;
    v7 = *(_QWORD *)(a1 - 24);
    v13 = (const __m128i *)(a1 - 224);
    do
    {
      if ( v7 == 128 )
      {
        v9 = 128LL;
        sub_5E7F0(v13, v6, *(_QWORD *)(v3 - 16), *(_QWORD *)(v3 - 8), 0);
        *(_QWORD *)(v3 - 24) = 0LL;
        v8 = (void *)v6;
      }
      else
      {
        v8 = (void *)(v6 + v7);
        v9 = 128 - v7;
      }
      v10 = v4;
      if ( v5 <= v9 )
        v9 = v5;
      v5 -= v9;
      v4 += v9;
      memcpy(v8, v10, v9);
      v7 = v9 + *(_QWORD *)(v3 - 24);
      v11 = __CFADD__(*(_QWORD *)(v3 - 8), v9);
      v12 = *(_QWORD *)(v3 - 8) + v9;
      *(_QWORD *)(v3 - 24) = v7;
      *(_QWORD *)(v3 - 16) += v11;
      *(_QWORD *)(v3 - 8) = v12;
    }
    while ( v5 );
  }
}

unsigned __int64 __fastcall sub_5EED0(__int64 a1, void *a2)
{
  __int64 v2; // r12
  const __m128i *v3; // rbx
  __int64 v4; // rdi
  __int64 *v5; // rdi
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 v9; // [rsp+0h] [rbp-B8h]
  __int64 v10; // [rsp+40h] [rbp-78h]
  unsigned __int64 v11; // [rsp+88h] [rbp-30h]

  v2 = a1;
  v3 = (const __m128i *)(a1 - 240);
  v4 = *(_QWORD *)(a1 - 40);
  v11 = __readfsqword(0x28u);
  memset((char *)v3[4].m128i_i64 + v4 + 4, 0, 128 - v4);
  sub_5E7F0(v3, (__int64)v3[4].m128i_i64 + 4, *(_QWORD *)(v2 - 32), *(_QWORD *)(v2 - 24), 1u);
  v5 = (__int64 *)v3;
  v6 = &v9;
  do
  {
    v7 = *v5;
    ++v6;
    ++v5;
    *((_WORD *)v6 - 4) = v7;
    *((_BYTE *)v6 - 6) = BYTE2(v7);
    *((_BYTE *)v6 - 5) = BYTE3(v7);
    *((_BYTE *)v6 - 4) = BYTE4(v7);
    *((_BYTE *)v6 - 3) = BYTE5(v7);
    *((_BYTE *)v6 - 1) = HIBYTE(v7);
    *((_BYTE *)v6 - 2) = BYTE6(v7);
  }
  while ( v6 != &v10 );
  memcpy(a2, &v9, *(unsigned int *)(v2 - 176));
  sub_BD070(&v9, 0x80uLL);
  return __readfsqword(0x28u) ^ v11;
}

_QWORD *__fastcall sub_5EFE0(unsigned int a1)
{
  _QWORD *v1; // rbx

  v1 = sub_5E770(a1);
  (*(void (__fastcall **)(_QWORD *))(*v1 + 8LL))(v1);
  return v1;
}

signed __int64 __fastcall sub_5F000(int a1, int a2, unsigned int *a3, _DWORD *a4)
{
  signed __int64 result; // rax
  unsigned int *v5; // r14
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // er10
  unsigned int v10; // ebx
  unsigned int v11; // ebp
  unsigned int v12; // esi
  unsigned int v13; // ebx
  unsigned int v14; // er11
  unsigned int v15; // ebx
  unsigned int v16; // er10
  unsigned int v17; // edi
  unsigned int v18; // ebx
  unsigned int v19; // esi
  unsigned int v20; // ebx
  __int64 v21; // rdx
  int v22; // edi
  __int64 v23; // r10
  int v24; // ebx
  unsigned int v25; // esi
  int v26; // edi

  result = (signed __int64)(a4 + 768);
  v5 = a3;
  v6 = a1 ^ a4[1024];
  v7 = (a4[(unsigned __int8)v6 + 768] + (a4[BYTE1(v6) + 512] ^ (a4[BYTE2(v6) + 256] + a4[v6 >> 24]))) ^ a4[1025] ^ a2;
  v8 = (a4[(unsigned __int8)v7 + 768] + (a4[BYTE1(v7) + 512] ^ (a4[BYTE2(v7) + 256] + a4[v7 >> 24]))) ^ a4[1026] ^ v6;
  v9 = a4[1027] ^ v7 ^ (a4[(unsigned __int8)v8 + 768] + (a4[BYTE1(v8) + 512] ^ (a4[BYTE2(v8) + 256] + a4[v8 >> 24])));
  v10 = (a4[(unsigned __int8)v9 + 768] + (a4[BYTE1(v9) + 512] ^ (a4[BYTE2(v9) + 256] + a4[v9 >> 24]))) ^ a4[1028] ^ v8;
  v11 = a4[1029] ^ v9 ^ (a4[(unsigned __int8)v10 + 768] + (a4[BYTE1(v10) + 512] ^ (a4[BYTE2(v10) + 256] + a4[v10 >> 24])));
  v12 = a4[1030] ^ v10 ^ (a4[(unsigned __int8)v11 + 768]
                        + (a4[BYTE1(v11) + 512] ^ (a4[BYTE2(v11) + 256] + a4[v11 >> 24])));
  v13 = a4[1031] ^ v11 ^ (a4[(unsigned __int8)v12 + 768]
                        + (a4[BYTE1(v12) + 512] ^ (a4[BYTE2(v12) + 256] + a4[v12 >> 24])));
  v14 = a4[1032] ^ v12 ^ (a4[(unsigned __int8)v13 + 768]
                        + (a4[BYTE1(v13) + 512] ^ (a4[BYTE2(v13) + 256] + a4[v13 >> 24])));
  v15 = (a4[(unsigned __int8)v14 + 768] + (a4[BYTE1(v14) + 512] ^ (a4[BYTE2(v14) + 256] + a4[v14 >> 24]))) ^ a4[1033] ^ v13;
  v16 = a4[1034] ^ v14 ^ (a4[(unsigned __int8)v15 + 768]
                        + (a4[BYTE1(v15) + 512] ^ (a4[BYTE2(v15) + 256] + a4[v15 >> 24])));
  v17 = a4[1035] ^ v15 ^ (a4[(unsigned __int8)v16 + 768]
                        + (a4[BYTE1(v16) + 512] ^ (a4[BYTE2(v16) + 256] + a4[v16 >> 24])));
  v18 = a4[1036] ^ v16 ^ (a4[(unsigned __int8)v17 + 768]
                        + (a4[BYTE1(v17) + 512] ^ (a4[BYTE2(v17) + 256] + a4[v17 >> 24])));
  v19 = a4[1037] ^ v17 ^ (a4[(unsigned __int8)v18 + 768]
                        + (a4[BYTE1(v18) + 512] ^ (a4[BYTE2(v18) + 256] + a4[v18 >> 24])));
  v20 = (a4[(unsigned __int8)v19 + 768] + (a4[BYTE1(v19) + 512] ^ (a4[BYTE2(v19) + 256] + a4[v19 >> 24]))) ^ a4[1038] ^ v18;
  v21 = BYTE1(v20);
  v22 = a4[BYTE2(v20) + 256] + a4[v20 >> 24];
  v23 = (unsigned __int8)v20;
  v24 = a4[1040] ^ v20;
  v25 = (a4[v23 + 768] + (a4[v21 + 512] ^ v22)) ^ a4[1039] ^ v19;
  v26 = a4[(unsigned __int8)v25 + 768] + (a4[BYTE1(v25) + 512] ^ (a4[BYTE2(v25) + 256] + a4[v25 >> 24]));
  *v5 = a4[1041] ^ v25;
  v5[1] = v26 ^ v24;
  return result;
}

signed __int64 __fastcall sub_5F330(int a1, int a2, unsigned int *a3, _DWORD *a4)
{
  signed __int64 result; // rax
  unsigned int *v5; // r14
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // er10
  unsigned int v10; // ebx
  unsigned int v11; // ebp
  unsigned int v12; // esi
  unsigned int v13; // ebx
  unsigned int v14; // er11
  unsigned int v15; // ebx
  unsigned int v16; // er10
  unsigned int v17; // edi
  unsigned int v18; // ebx
  unsigned int v19; // esi
  unsigned int v20; // ebx
  __int64 v21; // rdx
  int v22; // edi
  __int64 v23; // r10
  int v24; // ebx
  unsigned int v25; // esi
  int v26; // edi

  result = (signed __int64)(a4 + 768);
  v5 = a3;
  v6 = a1 ^ a4[1041];
  v7 = (a4[(unsigned __int8)v6 + 768] + (a4[BYTE1(v6) + 512] ^ (a4[BYTE2(v6) + 256] + a4[v6 >> 24]))) ^ a4[1040] ^ a2;
  v8 = (a4[(unsigned __int8)v7 + 768] + (a4[BYTE1(v7) + 512] ^ (a4[BYTE2(v7) + 256] + a4[v7 >> 24]))) ^ a4[1039] ^ v6;
  v9 = a4[1038] ^ v7 ^ (a4[(unsigned __int8)v8 + 768] + (a4[BYTE1(v8) + 512] ^ (a4[BYTE2(v8) + 256] + a4[v8 >> 24])));
  v10 = (a4[(unsigned __int8)v9 + 768] + (a4[BYTE1(v9) + 512] ^ (a4[BYTE2(v9) + 256] + a4[v9 >> 24]))) ^ a4[1037] ^ v8;
  v11 = a4[1036] ^ v9 ^ (a4[(unsigned __int8)v10 + 768] + (a4[BYTE1(v10) + 512] ^ (a4[BYTE2(v10) + 256] + a4[v10 >> 24])));
  v12 = a4[1035] ^ v10 ^ (a4[(unsigned __int8)v11 + 768]
                        + (a4[BYTE1(v11) + 512] ^ (a4[BYTE2(v11) + 256] + a4[v11 >> 24])));
  v13 = a4[1034] ^ v11 ^ (a4[(unsigned __int8)v12 + 768]
                        + (a4[BYTE1(v12) + 512] ^ (a4[BYTE2(v12) + 256] + a4[v12 >> 24])));
  v14 = a4[1033] ^ v12 ^ (a4[(unsigned __int8)v13 + 768]
                        + (a4[BYTE1(v13) + 512] ^ (a4[BYTE2(v13) + 256] + a4[v13 >> 24])));
  v15 = (a4[(unsigned __int8)v14 + 768] + (a4[BYTE1(v14) + 512] ^ (a4[BYTE2(v14) + 256] + a4[v14 >> 24]))) ^ a4[1032] ^ v13;
  v16 = a4[1031] ^ v14 ^ (a4[(unsigned __int8)v15 + 768]
                        + (a4[BYTE1(v15) + 512] ^ (a4[BYTE2(v15) + 256] + a4[v15 >> 24])));
  v17 = a4[1030] ^ v15 ^ (a4[(unsigned __int8)v16 + 768]
                        + (a4[BYTE1(v16) + 512] ^ (a4[BYTE2(v16) + 256] + a4[v16 >> 24])));
  v18 = a4[1029] ^ v16 ^ (a4[(unsigned __int8)v17 + 768]
                        + (a4[BYTE1(v17) + 512] ^ (a4[BYTE2(v17) + 256] + a4[v17 >> 24])));
  v19 = a4[1028] ^ v17 ^ (a4[(unsigned __int8)v18 + 768]
                        + (a4[BYTE1(v18) + 512] ^ (a4[BYTE2(v18) + 256] + a4[v18 >> 24])));
  v20 = (a4[(unsigned __int8)v19 + 768] + (a4[BYTE1(v19) + 512] ^ (a4[BYTE2(v19) + 256] + a4[v19 >> 24]))) ^ a4[1027] ^ v18;
  v21 = BYTE1(v20);
  v22 = a4[BYTE2(v20) + 256] + a4[v20 >> 24];
  v23 = (unsigned __int8)v20;
  v24 = a4[1025] ^ v20;
  v25 = (a4[v23 + 768] + (a4[v21 + 512] ^ v22)) ^ a4[1026] ^ v19;
  v26 = a4[(unsigned __int8)v25 + 768] + (a4[BYTE1(v25) + 512] ^ (a4[BYTE2(v25) + 256] + a4[v25 >> 24]));
  *v5 = a4[1024] ^ v25;
  v5[1] = v26 ^ v24;
  return result;
}

__int64 __fastcall sub_5F660(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 - 8) = *a2;
  result = (unsigned int)a2[1];
  *(_DWORD *)(a1 - 4) = result;
  return result;
}

__int64 __fastcall sub_5F670(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 - 8) = _byteswap_ulong(*a2);
  result = _byteswap_ulong(a2[1]);
  *(_DWORD *)(a1 - 4) = result;
  return result;
}

__int64 __fastcall sub_5F680(__int64 a1, int *a2, int a3)
{
  int v3; // er15
  int v4; // ebp
  int *v5; // rbx
  int v6; // er13
  int v7; // er12
  int v8; // edx
  int v9; // eax
  bool v10; // zf
  __int64 result; // rax
  unsigned __int64 v12; // rt1
  signed __int64 v13; // [rsp+10h] [rbp-58h]
  int v14; // [rsp+20h] [rbp-48h]
  int v15; // [rsp+24h] [rbp-44h]
  unsigned __int64 v16; // [rsp+28h] [rbp-40h]

  v16 = __readfsqword(0x28u);
  if ( a3 & 7 )
    goto LABEL_11;
  v3 = *(_DWORD *)(a1 - 8);
  v4 = *(_DWORD *)(a1 - 4);
  if ( a3 <= 0 )
  {
    v7 = *(_DWORD *)(a1 - 4);
    v6 = *(_DWORD *)(a1 - 8);
  }
  else
  {
    v5 = a2;
    v13 = (signed __int64)&a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v6 = *v5;
      v7 = v5[1];
      v5 += 2;
      sub_5F330(v6, v7, (unsigned int *)&v14, (_DWORD *)(a1 - 4176));
      v8 = v3 ^ v14;
      v9 = v4 ^ v15;
      v3 = v6;
      *((_WORD *)v5 - 4) = v8;
      *((_WORD *)v5 - 2) = v9;
      *((_BYTE *)v5 - 5) = HIBYTE(v8);
      *((_BYTE *)v5 - 6) = BYTE2(v8);
      *((_BYTE *)v5 - 2) = BYTE2(v9);
      *((_BYTE *)v5 - 1) = HIBYTE(v9);
      v4 = v7;
    }
    while ( (int *)v13 != v5 );
  }
  v12 = __readfsqword(0x28u);
  result = v12 ^ v16;
  v10 = v12 == v16;
  *(_DWORD *)(a1 - 8) = v6;
  *(_DWORD *)(a1 - 4) = v7;
  if ( !v10 )
LABEL_11:
    __assert_fail("(len & 7) == 0", "sshblowf.c", 0x161u, "blowfish_lsb_decrypt_cbc");
  return result;
}

unsigned __int64 __fastcall sub_5F7B0(__int64 a1, _DWORD *a2, int a3)
{
  __int64 v3; // r14
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // rbp
  _DWORD *v7; // rbx
  signed __int64 v8; // r13
  int v9; // eax
  int v10; // edi
  int v12; // [rsp+0h] [rbp-38h]
  int v13; // [rsp+4h] [rbp-34h]
  unsigned __int64 v14; // [rsp+8h] [rbp-30h]

  v14 = __readfsqword(0x28u);
  if ( a3 & 7 )
    __assert_fail("(len & 7) == 0", "sshblowf.c", 0x133u, "blowfish_lsb_encrypt_cbc");
  v3 = a1;
  v4 = *(_DWORD *)(a1 - 8);
  v5 = *(_DWORD *)(a1 - 4);
  if ( a3 > 0 )
  {
    v6 = (_DWORD *)(a1 - 4176);
    v7 = a2;
    v8 = (signed __int64)&a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v9 = v7[1] ^ v5;
      v10 = *v7;
      v7 += 2;
      sub_5F000(v4 ^ v10, v9, (unsigned int *)&v12, v6);
      v4 = v12;
      v5 = v13;
      *((_WORD *)v7 - 4) = v12;
      *((_WORD *)v7 - 2) = v5;
      *((_BYTE *)v7 - 6) = BYTE2(v4);
      *((_BYTE *)v7 - 5) = HIBYTE(v4);
      *((_BYTE *)v7 - 2) = BYTE2(v5);
      *((_BYTE *)v7 - 1) = HIBYTE(v5);
    }
    while ( (_DWORD *)v8 != v7 );
  }
  *(_DWORD *)(v3 - 4) = v5;
  *(_DWORD *)(v3 - 8) = v4;
  return __readfsqword(0x28u) ^ v14;
}

__int64 __fastcall sub_5F8A0(__int64 a1, unsigned int *a2, int a3)
{
  int v3; // er15
  int v4; // ebp
  unsigned int *v5; // rbx
  unsigned int v6; // er9
  unsigned int v7; // er8
  int v8; // er13
  int v9; // er12
  int v10; // edx
  int v11; // eax
  bool v12; // zf
  __int64 result; // rax
  unsigned __int64 v14; // rt1
  signed __int64 v15; // [rsp+10h] [rbp-58h]
  int v16; // [rsp+20h] [rbp-48h]
  int v17; // [rsp+24h] [rbp-44h]
  unsigned __int64 v18; // [rsp+28h] [rbp-40h]

  v18 = __readfsqword(0x28u);
  if ( a3 & 7 )
    goto LABEL_11;
  v3 = *(_DWORD *)(a1 - 8);
  v4 = *(_DWORD *)(a1 - 4);
  if ( a3 <= 0 )
  {
    v9 = *(_DWORD *)(a1 - 4);
    v8 = *(_DWORD *)(a1 - 8);
  }
  else
  {
    v5 = a2;
    v15 = (signed __int64)&a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v6 = *v5;
      v7 = v5[1];
      v5 += 2;
      v8 = _byteswap_ulong(v6);
      v9 = _byteswap_ulong(v7);
      sub_5F330(v8, v9, (unsigned int *)&v16, (_DWORD *)(a1 - 4176));
      v10 = v3 ^ v16;
      v11 = v4 ^ v17;
      v3 = v8;
      *((_BYTE *)v5 - 5) = v10;
      *((_BYTE *)v5 - 6) = BYTE1(v10);
      *((_BYTE *)v5 - 1) = v11;
      *((_BYTE *)v5 - 2) = BYTE1(v11);
      *((_BYTE *)v5 - 8) = HIBYTE(v10);
      *((_BYTE *)v5 - 7) = BYTE2(v10);
      *((_BYTE *)v5 - 3) = BYTE2(v11);
      *((_BYTE *)v5 - 4) = HIBYTE(v11);
      v4 = v9;
    }
    while ( (unsigned int *)v15 != v5 );
  }
  v14 = __readfsqword(0x28u);
  result = v14 ^ v18;
  v12 = v14 == v18;
  *(_DWORD *)(a1 - 8) = v8;
  *(_DWORD *)(a1 - 4) = v9;
  if ( !v12 )
LABEL_11:
    __assert_fail("(len & 7) == 0", "sshblowf.c", 0x199u, "blowfish_msb_decrypt_cbc");
  return result;
}

unsigned __int64 __fastcall sub_5F9D0(__int64 a1, unsigned int *a2, int a3)
{
  __int64 v3; // r14
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // rbp
  unsigned int *v7; // rbx
  signed __int64 v8; // r13
  unsigned int v9; // edi
  unsigned int v10; // esi
  int v12; // [rsp+0h] [rbp-38h]
  int v13; // [rsp+4h] [rbp-34h]
  unsigned __int64 v14; // [rsp+8h] [rbp-30h]

  v14 = __readfsqword(0x28u);
  if ( a3 & 7 )
    __assert_fail("(len & 7) == 0", "sshblowf.c", 0x17Du, "blowfish_msb_encrypt_cbc");
  v3 = a1;
  v4 = *(_DWORD *)(a1 - 8);
  v5 = *(_DWORD *)(a1 - 4);
  if ( a3 > 0 )
  {
    v6 = (_DWORD *)(a1 - 4176);
    v7 = a2;
    v8 = (signed __int64)&a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v9 = *v7;
      v10 = v7[1];
      v7 += 2;
      sub_5F000(v4 ^ _byteswap_ulong(v9), v5 ^ _byteswap_ulong(v10), (unsigned int *)&v12, v6);
      v4 = v12;
      v5 = v13;
      *((_BYTE *)v7 - 5) = v12;
      *((_BYTE *)v7 - 6) = BYTE1(v4);
      *((_BYTE *)v7 - 1) = v5;
      *((_BYTE *)v7 - 2) = BYTE1(v5);
      *((_BYTE *)v7 - 7) = BYTE2(v4);
      *((_BYTE *)v7 - 8) = HIBYTE(v4);
      *((_BYTE *)v7 - 3) = BYTE2(v5);
      *((_BYTE *)v7 - 4) = HIBYTE(v5);
    }
    while ( (unsigned int *)v8 != v7 );
  }
  *(_DWORD *)(v3 - 4) = v5;
  *(_DWORD *)(v3 - 8) = v4;
  return __readfsqword(0x28u) ^ v14;
}

__int64 __fastcall sub_5FAC0(__int64 a1, __int64 a2, int a3)
{
  int v3; // ebp
  int v4; // er13
  __int64 v5; // rbx
  unsigned int v6; // er14
  unsigned __int32 v7; // eax
  char v8; // dh^1
  unsigned int v9; // eax
  unsigned __int32 v10; // eax
  bool v11; // zf
  __int64 result; // rax
  unsigned __int64 v13; // rt1
  int v14; // [rsp+10h] [rbp-48h]
  int v15; // [rsp+14h] [rbp-44h]
  unsigned __int64 v16; // [rsp+18h] [rbp-40h]

  v16 = __readfsqword(0x28u);
  if ( a3 & 7 )
    goto LABEL_11;
  v3 = *(_DWORD *)(a1 - 8);
  v4 = *(_DWORD *)(a1 - 4);
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = v4 + ((unsigned int)(a3 - 1) >> 3) + 1;
    do
    {
      sub_5F000(v3, v4, (unsigned int *)&v14, (_DWORD *)(a1 - 4176));
      v7 = v14 ^ _byteswap_ulong(*(_DWORD *)v5);
      v8 = BYTE2(v7);
      *(_BYTE *)(v5 + 3) = v7;
      *(_BYTE *)(v5 + 2) = BYTE1(v7);
      *(_BYTE *)v5 = HIBYTE(v7);
      v9 = *(_DWORD *)(v5 + 4);
      *(_BYTE *)(v5 + 1) = v8;
      v10 = v15 ^ _byteswap_ulong(v9);
      *(_BYTE *)(v5 + 7) = v10;
      *(_BYTE *)(v5 + 6) = BYTE1(v10);
      v11 = v4++ == -1;
      *(_BYTE *)(v5 + 5) = BYTE2(v10);
      *(_BYTE *)(v5 + 4) = HIBYTE(v10);
      if ( v11 )
        ++v3;
      v5 += 8LL;
    }
    while ( v6 != v4 );
  }
  v13 = __readfsqword(0x28u);
  result = v13 ^ v16;
  v11 = v13 == v16;
  *(_DWORD *)(a1 - 8) = v3;
  *(_DWORD *)(a1 - 4) = v4;
  if ( !v11 )
LABEL_11:
    __assert_fail("(len & 7) == 0", "sshblowf.c", 0x1B5u, "blowfish_msb_sdctr");
  return result;
}

char *__fastcall sub_5FBD0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x1058uLL, 0LL);
  v1[522] = a1;
  return (char *)(v1 + 522);
}

void __fastcall sub_5FC00(__int64 a1)
{
  sub_BD070((void *)(a1 - 4176), 0x1058uLL);
  sub_2F4D0((void *)(a1 - 4176));
}

__int64 __fastcall sub_5FCF0(__int64 a1)
{
  __int64 v1; // rax
  signed int i; // edx
  __int64 result; // rax
  signed int v4; // er8
  signed int v5; // esi
  signed int v6; // ecx
  signed int v7; // edx

  v1 = 0LL;
  for ( i = 608135816; ; i = *(_DWORD *)((char *)&unk_EE3A0 + v1) )
  {
    *(_DWORD *)(a1 + v1 + 4096) = i;
    v1 += 4LL;
    if ( v1 == 72 )
      break;
  }
  result = 0LL;
  v4 = 976866871;
  v5 = -381855128;
  v6 = 1266315497;
  v7 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(a1 + result) = v7;
    *(_DWORD *)(a1 + result + 1024) = v6;
    *(_DWORD *)(a1 + result + 2048) = v5;
    *(_DWORD *)(a1 + result + 3072) = v4;
    result += 4LL;
    if ( result == 1024 )
      break;
    v7 = *(_DWORD *)((char *)&unk_EDFA0 + result);
    v6 = *(_DWORD *)((char *)&unk_EDBA0 + result);
    v5 = *(_DWORD *)((char *)&unk_ED7A0 + result);
    v4 = *(_DWORD *)((char *)&unk_ED3A0 + result);
  }
  return result;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

unsigned __int64 __usercall sub_60150@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  signed __int64 v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // r12
  int v7; // ecx
  signed __int64 v8; // r8
  int v9; // edi
  int v10; // ebp
  int v11; // er11
  int v12; // edx
  int v13; // eax
  int v14; // ebp
  int v15; // er11
  __int64 v16; // rbp
  int v17; // esi
  int j; // edi
  char v19; // cl
  int v20; // er11
  int v21; // eax
  _DWORD *v22; // r12
  signed int v23; // ebp
  int k; // edi
  char v25; // cl
  int v26; // er11
  int v27; // eax
  int l; // edi
  char v29; // cl
  int v30; // er10
  int v31; // eax
  signed __int64 v32; // r12
  int m; // edi
  char v34; // cl
  int v35; // er10
  int v36; // eax
  int n; // edi
  char v38; // cl
  int v39; // er10
  int v40; // eax
  __int64 v42; // rcx
  signed __int64 v43; // rdi
  signed int v44; // er8
  __int16 v45; // dx
  __int64 i; // rax
  __int64 v47; // rax
  signed int v48; // er11
  signed int v49; // er10
  signed int v50; // er9
  signed int v51; // er8
  __int64 v52; // rbx
  __int64 v53; // rbp
  __int64 v54; // r12
  __int64 v55; // r13
  _DWORD *v56; // [rsp+0h] [rbp-70h]
  signed __int64 v57; // [rsp+10h] [rbp-60h]
  __int64 v58; // [rsp+24h] [rbp-4Ch]
  unsigned __int8 v59; // [rsp+2Fh] [rbp-41h]
  unsigned __int64 v60; // [rsp+30h] [rbp-40h]
  __int64 v61; // [rsp+40h] [rbp-30h]
  __int64 v62; // [rsp+48h] [rbp-28h]
  __int64 v63; // [rsp+50h] [rbp-20h]
  __int64 v64; // [rsp+58h] [rbp-18h]
  __int64 v65; // [rsp+60h] [rbp-10h]
  __int64 v66; // [rsp+68h] [rbp-8h]

  v42 = a1;
  v43 = a1 - 4176;
  v44 = 608135816;
  v45 = *(_WORD *)(*(_QWORD *)(v43 + 4176) + 80LL);
  for ( i = 0LL; ; v44 = *(_DWORD *)((char *)&unk_EE3A0 + i) )
  {
    *(_DWORD *)(v42 + i - 80) = v44;
    i += 4LL;
    if ( i == 72 )
      break;
  }
  v47 = 0LL;
  v48 = 976866871;
  v49 = -381855128;
  v50 = 1266315497;
  v51 = -785314906;
  while ( 1 )
  {
    *(_DWORD *)(v42 + v47 - 4176) = v51;
    *(_DWORD *)(v42 + v47 - 3152) = v50;
    *(_DWORD *)(v42 + v47 - 2128) = v49;
    *(_DWORD *)(v42 + v47 - 1104) = v48;
    v47 += 4LL;
    if ( v47 == 1024 )
      break;
    v51 = *(_DWORD *)((char *)&unk_EDFA0 + v47);
    v50 = *(_DWORD *)((char *)&unk_EDBA0 + v47);
    v49 = *(_DWORD *)((char *)&unk_ED7A0 + v47);
    v48 = *(_DWORD *)((char *)&unk_ED3A0 + v47);
  }
  v52 = v63;
  v53 = v64;
  v54 = v65;
  v55 = v66;
  v66 = a4;
  v65 = a3;
  v64 = v55;
  v63 = v54;
  v4 = v43 + 1024;
  v62 = v53;
  v61 = v52;
  v5 = v43 + 3072;
  v6 = v43 + 4096;
  v56 = (_DWORD *)v43;
  v60 = __readfsqword(0x28u);
  v57 = v43 + 2048;
  v59 = 0;
  v7 = v45;
  v8 = v43 + 4096;
  v9 = 0;
  do
  {
    v8 += 4LL;
    v10 = *(_DWORD *)(v8 - 4) ^ (*(unsigned __int8 *)(a2 + v9 % v7) << 24);
    *(_DWORD *)(v8 - 4) = v10;
    v11 = *(unsigned __int8 *)(a2 + (v9 + 1) % v7);
    v12 = (v9 + 2) % v7;
    v13 = v9 + 3;
    v9 += 4;
    v14 = (v11 << 16) ^ v10;
    *(_DWORD *)(v8 - 4) = v14;
    v15 = v14 ^ (*(unsigned __int8 *)(a2 + v12) << 8);
    *(_DWORD *)(v8 - 4) = v15;
    *(_DWORD *)(v8 - 4) = *(unsigned __int8 *)(a2 + v13 % v7) ^ v15;
  }
  while ( v9 != 72 );
  v58 = 0LL;
  v16 = 0LL;
  v17 = 0;
  do
  {
    for ( j = 0; ; v17 = *((_DWORD *)&v58 + (j >> 2)) )
    {
      v19 = ~(_BYTE)j;
      v20 = j++ >> 2;
      *((_DWORD *)&v58 + v20) = (v59 << 8 * (v19 & 3)) ^ v17;
      if ( j == 8 )
        break;
    }
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v21 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v6 + v16) = v58;
    *(_DWORD *)(v6 + v16 + 4) = v21;
    v16 += 8LL;
  }
  while ( v16 != 72 );
  v22 = v56;
  v23 = 72;
  do
  {
    for ( k = 0; ; v17 = *((_DWORD *)&v58 + (k >> 2)) )
    {
      v25 = ~(_BYTE)k;
      v26 = k++ >> 2;
      *((_DWORD *)&v58 + v26) = (v59 << 8 * (v25 & 3)) ^ v17;
      if ( k == 8 )
        break;
    }
    v23 += 8;
    v22 += 2;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v27 = HIDWORD(v58);
    v17 = v58;
    *(v22 - 2) = v58;
    *(v22 - 1) = v27;
  }
  while ( v23 != 1096 );
  do
  {
    for ( l = 0; ; v17 = *((_DWORD *)&v58 + (l >> 2)) )
    {
      v29 = ~(_BYTE)l;
      v30 = l++ >> 2;
      *((_DWORD *)&v58 + v30) = (v59 << 8 * (v29 & 3)) ^ v17;
      if ( l == 8 )
        break;
    }
    v23 += 8;
    v4 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v31 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v4 - 8) = v58;
    *(_DWORD *)(v4 - 4) = v31;
  }
  while ( v23 != 2120 );
  v32 = v57;
  do
  {
    for ( m = 0; ; v17 = *((_DWORD *)&v58 + (m >> 2)) )
    {
      v34 = ~(_BYTE)m;
      v35 = m++ >> 2;
      *((_DWORD *)&v58 + v35) = (v59 << 8 * (v34 & 3)) ^ v17;
      if ( m == 8 )
        break;
    }
    v23 += 8;
    v32 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v36 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v32 - 8) = v58;
    *(_DWORD *)(v32 - 4) = v36;
  }
  while ( v23 != 3144 );
  do
  {
    for ( n = 0; ; v17 = *((_DWORD *)&v58 + (n >> 2)) )
    {
      v38 = ~(_BYTE)n;
      v39 = n++ >> 2;
      *((_DWORD *)&v58 + v39) = (v59 << 8 * (v38 & 3)) ^ v17;
      if ( n == 8 )
        break;
    }
    v23 += 8;
    v5 += 8LL;
    sub_5F000(v58, SHIDWORD(v58), (unsigned int *)&v58, v56);
    v40 = HIDWORD(v58);
    v17 = v58;
    *(_DWORD *)(v5 - 8) = v58;
    *(_DWORD *)(v5 - 4) = v40;
  }
  while ( v23 != 4168 );
  return __readfsqword(0x28u) ^ v60;
}

__int64 __fastcall sub_60250(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 3684054920433006693LL;
  *(_QWORD *)(a1 + 8) = 7719281312240119090LL;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 28) = a2[3];
  *(_DWORD *)(a1 + 32) = a2[4];
  *(_DWORD *)(a1 + 36) = a2[5];
  *(_DWORD *)(a1 + 40) = a2[6];
  result = (unsigned int)a2[7];
  *(_DWORD *)(a1 + 128) = 64;
  *(_DWORD *)(a1 + 44) = result;
  return result;
}

__int64 __fastcall sub_602B0(__int64 a1, unsigned int *a2)
{
  unsigned int v2; // eax
  __int64 result; // rax

  *(_QWORD *)(a1 + 48) = 0LL;
  *(_DWORD *)(a1 + 56) = _byteswap_ulong(*a2);
  v2 = a2[1];
  *(_DWORD *)(a1 + 128) = 64;
  result = _byteswap_ulong(v2);
  *(_DWORD *)(a1 + 60) = result;
  return result;
}

unsigned __int64 __fastcall sub_602E0(_QWORD *a1, unsigned __int8 *a2, int a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rdi
  unsigned int i; // er8
  __int64 v6; // rax
  char v7; // cl
  int v8; // er9
  int v9; // eax
  unsigned __int64 v10; // r9
  __int64 v11; // r13
  unsigned __int64 v12; // rbp
  __int64 v13; // rcx
  __int64 v14; // r8
  unsigned __int8 v15; // cf
  unsigned __int64 v16; // rcx
  unsigned __int128 v17; // kr10_16
  __int64 v18; // r13
  unsigned __int128 v19; // ST00_16
  unsigned __int128 v20; // ax
  unsigned __int64 v21; // rdi
  unsigned __int128 v22; // kr50_16
  unsigned __int128 v23; // kr70_16
  unsigned __int64 v24; // r9
  __int64 v25; // r10
  unsigned __int64 v26; // r8
  __int64 v27; // rdi
  unsigned __int64 v28; // rsi
  unsigned __int64 v29; // rcx
  signed __int64 v30; // kr40_8
  unsigned __int128 v31; // krB0_16
  unsigned __int128 v32; // krC0_16
  unsigned __int128 v33; // krD0_16
  __int64 v35; // [rsp+20h] [rbp-58h]
  unsigned __int64 v36; // [rsp+28h] [rbp-50h]
  __int64 v37; // [rsp+30h] [rbp-48h]
  unsigned __int64 v38; // [rsp+38h] [rbp-40h]

  v3 = a1;
  v38 = __readfsqword(0x28u);
  v35 = 0LL;
  v36 = 0LL;
  v37 = 0LL;
  if ( a3 > 0 )
  {
    v4 = 0LL;
    for ( i = 0; ; v4 = *(&v35 + (i >> 3)) )
    {
      v6 = *a2;
      v7 = i & 7;
      v8 = (signed int)i++ >> 3;
      ++a2;
      *(&v35 + v8) = v4 | (v6 << 8 * v7);
      if ( a3 == i )
        break;
    }
  }
  v9 = a3 + 7;
  v10 = v3[6];
  v11 = v3[7];
  if ( a3 >= 0 )
    v9 = a3;
  v12 = v3[4];
  *(&v35 + (v9 >> 3)) |= 1LL << 8 * ((char)a3 % 8);
  v13 = v3[5];
  v14 = v13 + v35;
  v15 = __CFADD__(v13, v35);
  v16 = v3[2];
  v17 = v36 + (unsigned __int128)v10 + v15;
  v18 = *((_QWORD *)&v17 + 1) + v37 + v11;
  v19 = (unsigned __int64)v14 * (unsigned __int128)(unsigned __int64)v3[2];
  v20 = (unsigned __int64)v3[3] * (unsigned __int128)(unsigned __int64)v14;
  v21 = *((_QWORD *)&v20 + 1) + __CFADD__((_QWORD)v20, *((_QWORD *)&v19 + 1));
  v22 = ((unsigned __int64)(*((_OWORD *)v3 + 1) * v14) >> 64) + (unsigned __int64)v17 * (unsigned __int128)v16;
  v23 = (unsigned __int64)v3[3] * (unsigned __int128)(unsigned __int64)v17
      + *((unsigned __int64 *)&v22 + 1)
      + (unsigned __int128)(v12 * v14 + v21);
  v25 = (*((unsigned __int64 *)&v23 + 1)
       + ((v21 + v12 * (unsigned __int128)(unsigned __int64)v14) >> 64)
       + v12 * (unsigned __int128)(unsigned __int64)v17) >> 64;
  v24 = *((_QWORD *)&v23 + 1) + ((v21 + v12 * (unsigned __int128)(unsigned __int64)v14) >> 64) + v12 * v17;
  v26 = v18 * v16 + v23;
  v27 = ((unsigned __int64)v3[3] * (unsigned __int128)(unsigned __int64)v18
       + v24
       + (((unsigned __int64)v23 + (unsigned __int64)v18 * (unsigned __int128)v16) >> 64)) >> 64;
  v28 = v3[3] * v18 + v24 + (((unsigned __int64)v23 + (unsigned __int64)v18 * (unsigned __int128)v16) >> 64);
  v29 = v27 + v12 * v18 + v25;
  v30 = 5 * ((v28 << 62) | (v26 >> 2));
  v31 = (((unsigned __int64)v30 + (unsigned __int128)(unsigned __int64)v19) >> 64)
      + (unsigned __int64)v22
      + (unsigned __int64)(__PAIR__(((v27 + v12 * v18 + v25) << 62) | (v28 >> 2), (v28 << 62) | (v26 >> 2)) * 5 >> 64);
  v32 = 25 * (v29 >> 4) + (unsigned __int128)(unsigned __int64)(v30 + v19);
  v3[5] = v32;
  v33 = *((unsigned __int64 *)&v32 + 1) + (unsigned __int128)(unsigned __int64)v31;
  v3[6] = v33;
  v3[7] = *((_QWORD *)&v33 + 1)
        + *((_QWORD *)&v31 + 1)
        + ((5 * (unsigned __int128)(((v27 + v12 * v18 + v25) << 62) | (v28 >> 2))
          + (5 * (unsigned __int128)((v28 << 62) | (v26 >> 2)) >> 64)) >> 64)
        + (v26 & 3)
        + 5 * ((v29 >> 2) & 3);
  return __readfsqword(0x28u) ^ v38;
}

signed __int64 __fastcall sub_605C0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a2 + 8) = a1;
  *(_QWORD *)(a2 + 16) = a2 - 16;
  return a2 + 8;
}

void nullsub_28()
{
  ;
}

void nullsub_29()
{
  ;
}

unsigned __int64 __fastcall sub_60600(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  int v4; // edx
  unsigned __int8 *v5; // rdi
  __int64 v6; // r8
  int i; // edx
  __int64 v8; // rax
  char v9; // cl
  int v10; // esi
  __int64 v11; // rdx
  __int64 v12; // r11
  signed __int64 v13; // rcx
  signed __int64 v14; // rdx
  unsigned __int128 v15; // kr10_16
  signed __int64 v16; // rax
  unsigned __int64 v17; // r8
  signed __int64 v18; // kr00_8
  __int64 v19; // r11
  __int64 v20; // rdi
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // rdx
  __int64 v23; // rax
  unsigned __int8 v24; // cf
  __int64 v25; // r11
  int j; // eax
  char v27; // cl
  __int64 v29; // [rsp+0h] [rbp-48h]
  __int64 v30; // [rsp+8h] [rbp-40h]
  __int64 v31; // [rsp+10h] [rbp-38h]
  unsigned __int64 v32; // [rsp+18h] [rbp-30h]

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 - 32);
  v32 = __readfsqword(0x28u);
  if ( v4 )
    sub_602E0((_QWORD *)(a1 - 112), (unsigned __int8 *)(a1 - 48), v4);
  v29 = 0LL;
  v30 = 0LL;
  v5 = (unsigned __int8 *)(a1 - 112);
  v31 = 0LL;
  v6 = 0LL;
  for ( i = 0; ; v6 = *(&v29 + (i >> 3)) )
  {
    v8 = *v5;
    v9 = i & 7;
    v10 = i++ >> 3;
    ++v5;
    *(&v29 + v10) = v6 | (v8 << 8 * v9);
    if ( i == 16 )
      break;
  }
  v11 = *(_QWORD *)(v2 - 72);
  v12 = v11;
  v13 = 5LL * (*(_QWORD *)(v2 - 56) >> 2);
  v14 = v13 + v11;
  v15 = __CFADD__(v13, v12) + (unsigned __int128)*(unsigned __int64 *)(v2 - 64);
  v16 = *((_QWORD *)&v15 + 1) + (*(_QWORD *)(v2 - 56) & 3LL);
  v17 = 5 * ((v16 + (unsigned __int64)__CFADD__((_QWORD)v15, __CFADD__(v14, 5LL))) >> 2);
  v18 = v14;
  v19 = v29;
  *(_QWORD *)(v2 - 72) = v14 + v17;
  v20 = ((unsigned __int64)v15 + (((unsigned __int64)v14 + (unsigned __int128)v17) >> 64)) >> 64;
  v21 = v15 + (((unsigned __int64)v14 + (unsigned __int128)v17) >> 64);
  v22 = v14 + v17 + v19;
  v23 = ((_BYTE)v20 + (_BYTE)v16) & 3;
  v24 = __CFADD__(v19, v18 + v17);
  v25 = v30;
  *(_QWORD *)(v2 - 56) = v23;
  *(_QWORD *)(v2 - 64) = v21;
  v29 = v22;
  v30 = v21 + v25 + v24;
  v31 += ((__PAIR__(__CFADD__(v25, v24), v21) + v25 + (unsigned __int64)v24) >> 64) + v23;
  for ( j = 0; ; v22 = *(&v29 + (j >> 3)) )
  {
    v27 = j++;
    *(_BYTE *)(++v3 - 1) = v22 >> 8 * (v27 & 7u);
    if ( j == 16 )
      break;
  }
  return __readfsqword(0x28u) ^ v32;
}

const char *sub_607E0()
{
  return "Poly1305";
}

void nullsub_30()
{
  ;
}

__int64 __fastcall sub_60800(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  _DWORD *v3; // rcx

  sub_60250(a1 - 384, (_DWORD *)(a2 + 32));
  return sub_60250(v2 + 132, v3);
}

void __fastcall sub_60830(__int64 a1)
{
  *(_DWORD *)(a1 - 128) = 0;
  *(_QWORD *)(a1 - 124) = 0LL;
  *(_DWORD *)(a1 - 32) = 0;
  *(_QWORD *)(a1 - 72) = 0LL;
  *(_QWORD *)(a1 - 64) = 0LL;
  *(_OWORD *)(a1 - 112) = 0LL;
  *(_QWORD *)(a1 - 56) = 0LL;
}

void __fastcall sub_60870(__int64 a1)
{
  sub_BD070((void *)(a1 - 384), 0x84uLL);
  sub_BD070((void *)(a1 - 384 + 132), 0x84uLL);
  sub_BD070((void *)(a1 - 384 + 280), 0x58uLL);
  sub_2F4D0((void *)(a1 - 384));
}

__int64 *__fastcall sub_608B0(__int64 a1)
{
  char *v1; // rax
  __int64 *result; // rax

  v1 = (char *)sub_2F450(1uLL, 0x198uLL, 0LL);
  *((_DWORD *)v1 + 90) = 0;
  *((_QWORD *)v1 + 40) = 0LL;
  *((_QWORD *)v1 + 47) = v1 + 368;
  *((_QWORD *)v1 + 41) = 0LL;
  result = (__int64 *)(v1 + 384);
  *(result - 2) = (__int64)sub_60D90;
  *(result - 6) = 0LL;
  *(_OWORD *)(result - 13) = 0LL;
  *result = a1;
  return result;
}

unsigned __int64 __fastcall sub_60920(const __m128i *a1)
{
  const __m128i *v1; // rax
  int v2; // er13
  int v3; // er10
  int v4; // er11
  int v5; // er8
  int v6; // ebp
  __int32 v7; // ebx
  __int32 v8; // esi
  __int32 v9; // er15
  int v10; // edi
  int v11; // er9
  int v12; // er12
  __int32 v13; // edx
  __int32 v14; // ecx
  __int32 v15; // er14
  int v16; // eax
  int v17; // er13
  int v18; // er11
  int v19; // er10
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // edi
  int v24; // er9
  int v25; // er12
  int v26; // ebp
  int v27; // ebx
  int v28; // esi
  int v29; // er13
  int v30; // er11
  int v31; // er10
  int v32; // eax
  int v33; // ecx
  int v34; // edi
  int v35; // er9
  int v36; // ST0C_4
  int v37; // ebp
  int v38; // ebx
  int v39; // edx
  int v40; // er8
  int v41; // er13
  int v42; // ST10_4
  int v43; // er12
  int v44; // edi
  int v45; // esi
  int v46; // er11
  int v47; // er9
  int v48; // eax
  int v49; // er15
  int v50; // er8
  int v51; // edi
  int v52; // er9
  int v53; // edi
  int v54; // er15
  int v55; // er9
  int v56; // er12
  int v57; // ebx
  int v58; // er10
  int v59; // esi
  int v60; // er8
  int v61; // ecx
  int v62; // edx
  int v63; // esi
  int v64; // er9
  int v65; // edi
  int v66; // ebp
  int v67; // er15
  __int64 v68; // rax
  __m128i *v69; // rcx
  signed __int64 v70; // rdx
  int v71; // eax
  int v72; // eax
  int v74; // [rsp+8h] [rbp-A0h]
  signed int v75; // [rsp+14h] [rbp-94h]
  const __m128i *v76; // [rsp+18h] [rbp-90h]
  __m128i v77; // [rsp+20h] [rbp-88h]
  __m128i v78; // [rsp+30h] [rbp-78h]
  __m128i v79; // [rsp+40h] [rbp-68h]
  __m128i v80; // [rsp+50h] [rbp-58h]
  __int64 v81; // [rsp+60h] [rbp-48h]
  unsigned __int64 v82; // [rsp+68h] [rbp-40h]

  v1 = a1;
  v76 = a1;
  v75 = 10;
  v77 = _mm_loadu_si128(a1);
  v2 = _mm_cvtsi128_si32(v77);
  v3 = v77.m128i_i32[2];
  v4 = v77.m128i_i32[1];
  v82 = __readfsqword(0x28u);
  v5 = v77.m128i_i32[3];
  v78 = _mm_loadu_si128(a1 + 1);
  v6 = _mm_cvtsi128_si32(v78);
  v8 = v78.m128i_i32[2];
  v7 = v78.m128i_i32[1];
  v9 = v78.m128i_i32[3];
  v79 = _mm_loadu_si128(a1 + 2);
  v10 = _mm_cvtsi128_si32(v79);
  v12 = v79.m128i_i32[2];
  v11 = v79.m128i_i32[1];
  v80 = _mm_loadu_si128(v1 + 3);
  v13 = v80.m128i_i32[2];
  v14 = v80.m128i_i32[1];
  v15 = v80.m128i_i32[3];
  v74 = v79.m128i_i32[3];
  v16 = _mm_cvtsi128_si32(v80);
  do
  {
    v17 = v6 + v2;
    v18 = v7 + v4;
    v19 = v8 + v3;
    v20 = __ROL4__(v17 ^ v16, 16);
    v21 = __ROL4__(v18 ^ v14, 16);
    v22 = __ROL4__(v19 ^ v13, 16);
    v23 = v20 + v10;
    v24 = v21 + v11;
    v25 = v22 + v12;
    v26 = __ROL4__(v23 ^ v6, 12);
    v27 = __ROL4__(v24 ^ v7, 12);
    v28 = __ROL4__(v25 ^ v8, 12);
    v29 = v26 + v17;
    v30 = v27 + v18;
    v31 = v28 + v19;
    v32 = __ROL4__(v29 ^ v20, 8);
    v33 = __ROL4__(v30 ^ v21, 8);
    v34 = v32 + v23;
    v35 = v33 + v24;
    v36 = v34;
    v37 = __ROL4__(v34 ^ v26, 7);
    v38 = __ROL4__(v35 ^ v27, 7);
    v39 = __ROL4__(v31 ^ v22, 8);
    v40 = v9 + v5;
    v41 = v38 + v29;
    v42 = v35;
    v43 = v39 + v25;
    v44 = __ROL4__(v40 ^ v15, 16);
    v45 = __ROL4__(v43 ^ v28, 7);
    v46 = v45 + v30;
    v47 = v44 + v74;
    v48 = __ROL4__(v46 ^ v32, 16);
    v49 = __ROL4__((v44 + v74) ^ v9, 12);
    v50 = v49 + v40;
    v51 = __ROL4__(v50 ^ v44, 8);
    v52 = v51 + v47;
    v53 = __ROL4__(v41 ^ v51, 16);
    v54 = v52 ^ v49;
    v55 = v48 + v52;
    v56 = v53 + v43;
    v54 = __ROL4__(v54, 7);
    v57 = __ROL4__(v56 ^ v38, 12);
    v2 = v57 + v41;
    v15 = __ROL4__(v2 ^ v53, 8);
    v12 = v15 + v56;
    v7 = __ROL4__(v12 ^ v57, 7);
    v58 = v54 + v31;
    v59 = __ROL4__(v55 ^ v45, 12);
    v60 = v37 + v50;
    v4 = v59 + v46;
    v61 = __ROL4__(v58 ^ v33, 16);
    v62 = __ROL4__(v60 ^ v39, 16);
    v16 = __ROL4__(v4 ^ v48, 8);
    v63 = (v55 + v16) ^ v59;
    v74 = v55 + v16;
    v64 = v62 + v42;
    v8 = __ROL4__(v63, 7);
    v65 = v61 + v36;
    v66 = __ROL4__((v62 + v42) ^ v37, 12);
    v5 = v66 + v60;
    v67 = __ROL4__((v61 + v36) ^ v54, 12);
    v3 = v67 + v58;
    v13 = __ROL4__(v5 ^ v62, 8);
    v11 = v13 + v64;
    v14 = __ROL4__(v3 ^ v61, 8);
    v10 = v14 + v65;
    v6 = __ROL4__(v11 ^ v66, 7);
    v9 = __ROL4__(v10 ^ v67, 7);
    --v75;
  }
  while ( v75 );
  v80.m128i_i32[0] = v16;
  v79.m128i_i64[0] = __PAIR__(v11, v10);
  v77.m128i_i64[0] = __PAIR__(v4, v2);
  v78.m128i_i64[0] = __PAIR__(v7, v6);
  v68 = 0LL;
  *(__int64 *)((char *)v80.m128i_i64 + 4) = __PAIR__(v13, v14);
  v77.m128i_i64[1] = __PAIR__(v5, v3);
  v78.m128i_i64[1] = __PAIR__(v9, v8);
  v79.m128i_i64[1] = __PAIR__(v74, v12);
  v80.m128i_i32[3] = v15;
  while ( 1 )
  {
    v77.m128i_i32[v68] = *(_DWORD *)((char *)v76->m128i_i64 + v68 * 4) + v2;
    ++v68;
    if ( v68 == 16 )
      break;
    v2 = v77.m128i_i32[v68];
  }
  v69 = &v77;
  v70 = (signed __int64)v76[4].m128i_i64;
  do
  {
    v71 = v69->m128i_i64[0];
    v69 = (__m128i *)((char *)v69 + 4);
    v70 += 4LL;
    *(_WORD *)(v70 - 4) = v71;
    *(_BYTE *)(v70 - 2) = BYTE2(v71);
    *(_BYTE *)(v70 - 1) = HIBYTE(v71);
  }
  while ( &v81 != (__int64 *)v69 );
  v76[8].m128i_i32[0] = 0;
  sub_BD070(&v77, 0x40uLL);
  v72 = v76[3].m128i_i32[0] + 1;
  v76[3].m128i_i32[0] = v72;
  if ( !v72 )
    ++v76[3].m128i_i32[1];
  return __readfsqword(0x28u) ^ v82;
}

void __fastcall sub_60C30(const __m128i *a1, __int64 a2, int a3)
{
  int v3; // er12
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  signed __int64 v7; // rsi

  if ( a3 )
  {
    v3 = a3;
    v4 = a1[8].m128i_i32[0];
    v5 = a2;
    do
    {
      do
      {
        if ( (signed int)v4 <= 63 )
          break;
        sub_60920(a1);
        v4 = a1[8].m128i_i32[0];
      }
      while ( (signed int)v4 > 63 );
      v6 = (unsigned int)(v3 - 1);
      v7 = v5 + v6 + 1;
      while ( 1 )
      {
        ++v5;
        v3 = v6;
        a1[8].m128i_i32[0] = v4 + 1;
        *(_BYTE *)(v5 - 1) ^= a1[4].m128i_u8[v4];
        v4 = a1[8].m128i_i32[0];
        if ( (signed int)v4 > 63 )
          break;
        if ( v7 == v5 )
          return;
        LODWORD(v6) = v6 - 1;
      }
    }
    while ( (_DWORD)v6 );
  }
}

unsigned __int64 __fastcall sub_60CB0(__int64 a1, __int64 a2, int a3, int a4)
{
  int v4; // er12
  __int64 v5; // r8
  void *v6; // rcx
  int v8; // [rsp+0h] [rbp-28h]
  __int16 v9; // [rsp+4h] [rbp-24h]
  char v10; // [rsp+6h] [rbp-22h]
  char v11; // [rsp+7h] [rbp-21h]
  unsigned __int64 v12; // [rsp+8h] [rbp-20h]

  v4 = a3;
  v12 = __readfsqword(0x28u);
  v9 = a4;
  v8 = 0;
  v11 = HIBYTE(a4);
  v10 = BYTE2(a4);
  sub_602B0(a1 - 384, (unsigned int *)&v8);
  sub_602B0(a1 - 384 + 132, (unsigned int *)&v8);
  ++*(_DWORD *)(v5 - 204);
  sub_BD070(v6, 8uLL);
  sub_60C30((const __m128i *)(a1 - 384), a2, v4);
  return __readfsqword(0x28u) ^ v12;
}

unsigned __int64 __fastcall sub_60D60(__int64 a1, __int64 a2, int a3, int a4)
{
  return sub_60CB0(a1, a2, a3, a4);
}

void __fastcall sub_60D70(__int64 a1, __int64 a2, int a3)
{
  sub_60C30((const __m128i *)(a1 - 252), a2, a3);
}

void __fastcall sub_60D80(__int64 a1, __int64 a2, int a3)
{
  sub_60C30((const __m128i *)(a1 - 252), a2, a3);
}

unsigned __int64 __fastcall sub_60D90(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbp
  _QWORD *v5; // rbx
  signed int v6; // eax
  __int64 v7; // rdx
  unsigned int *v8; // rsi
  const __m128i *v9; // rdi
  __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 *v12; // r8
  __int64 v13; // r9
  signed __int64 v14; // rcx
  int v15; // eax
  __int64 v16; // rdx
  char v17; // cl
  int v18; // esi
  __m128i v19; // xmm0
  int v20; // er13
  signed int v21; // edx
  int v22; // edi
  __int64 v23; // rax
  unsigned int v24; // er13
  signed __int64 v25; // rbp
  unsigned __int8 *v26; // rsi
  signed __int64 v28; // rcx
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  char *v31; // rbx
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // rcx
  __int64 v34; // [rsp+0h] [rbp-58h]
  unsigned __int64 v35; // [rsp+8h] [rbp-50h]
  unsigned __int64 v36; // [rsp+18h] [rbp-40h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v36 = __readfsqword(0x28u);
  v6 = *(_DWORD *)(a1 - 104);
  if ( v6 > 3 )
  {
    if ( v6 != 4 )
      goto LABEL_10;
  }
  else
  {
    if ( !a3 )
      return __readfsqword(0x28u) ^ v36;
    v7 = a1 + 7 - v6 - a3;
    while ( 1 )
    {
      v5 = (_QWORD *)((char *)v5 + 1);
      ++v6;
      *(_BYTE *)(v7 + v4-- - 100) = *((_BYTE *)v5 - 1);
      *(_DWORD *)(a1 - 104) = v6;
      if ( v6 == 4 )
        break;
      if ( !v4 )
        return __readfsqword(0x28u) ^ v36;
    }
  }
  v8 = (unsigned int *)(a1 - 368 + 268);
  v9 = (const __m128i *)(a1 - 368 + 132);
  sub_602B0((__int64)v9, v8);
  ++*(_DWORD *)(v3 - 104);
  sub_60920(v9);
  v10 = *(_QWORD *)(v3 - 172);
  v11 = *(_QWORD *)(v3 - 164);
  *(_QWORD *)(v3 - 72) = 0LL;
  *(_QWORD *)(v3 - 64) = 0LL;
  v12 = &v34;
  *(_QWORD *)(v3 - 56) = 0LL;
  v13 = 0LL;
  v34 = v10;
  v35 = v11;
  BYTE3(v34) = BYTE3(v10) & 0xF;
  BYTE4(v34) = BYTE4(v10) & 0xFC;
  HIBYTE(v34) = HIBYTE(v10) & 0xF;
  LOBYTE(v35) = v11 & 0xFC;
  BYTE3(v35) = BYTE3(v11) & 0xF;
  v14 = (v11 >> 56) & 0xF;
  BYTE4(v35) = BYTE4(v11) & 0xFC;
  v15 = 0;
  HIBYTE(v35) = v14;
  while ( 1 )
  {
    v16 = *(unsigned __int8 *)v12;
    v17 = v15 & 7;
    v18 = v15++ >> 3;
    v12 = (__int64 *)((char *)v12 + 1);
    *(_QWORD *)(v3 + 8LL * v18 - 72) = v13 | (v16 << 8 * v17);
    if ( v15 == 16 )
      break;
    v13 = *(_QWORD *)(v3 + 8LL * (v15 >> 3) - 72);
  }
  sub_BD070(&v34, 0x10uLL);
  v19 = _mm_loadu_si128((const __m128i *)(v3 - 156));
  *(_DWORD *)(v3 - 108) = 64;
  *(__m128i *)(v3 - 88) = v19;
LABEL_10:
  if ( v4 )
  {
    v20 = v4;
    v21 = *(_DWORD *)(v3 - 8);
    if ( v21 )
    {
      if ( v21 <= 15 )
      {
        if ( !(_DWORD)v4 )
          return __readfsqword(0x28u) ^ v36;
        v22 = v21 + v4 - 16;
        v23 = v21 + 1;
        while ( 1 )
        {
          v5 = (_QWORD *)((char *)v5 + 1);
          *(_DWORD *)(v3 - 8) = v23;
          --v20;
          v21 = v23;
          *(_BYTE *)(v3 - 1 + v23 - 24) = *((_BYTE *)v5 - 1);
          if ( v20 == v22 )
            break;
          ++v23;
          if ( !v20 )
            return __readfsqword(0x28u) ^ v36;
        }
      }
      if ( v21 == 16 )
      {
        sub_602E0((_QWORD *)(v3 - 88), (unsigned __int8 *)(v3 - 24), 16);
        *(_DWORD *)(v3 - 8) = 0;
      }
    }
    if ( v20 > 15 )
    {
      v24 = v20 - 16;
      v25 = (signed __int64)&v5[2 * ((v24 >> 4) + 1LL)];
      do
      {
        v26 = (unsigned __int8 *)v5;
        v5 += 2;
        sub_602E0((_QWORD *)(v3 - 88), v26, 16);
      }
      while ( v5 != (_QWORD *)v25 );
      v20 = v24 - 16 * (v24 >> 4);
    }
    if ( v20 )
    {
      v28 = v3 - 88 + 64;
      if ( (unsigned __int64)v20 >= 8 )
      {
        v29 = (v3 - 88 + 72) & 0xFFFFFFFFFFFFFFF8LL;
        *(_QWORD *)(v3 - 24) = *v5;
        *(_QWORD *)(v28 + v20 - 8) = *(_QWORD *)((char *)v5 + v20 - 8);
        v30 = v28 - v29;
        v31 = (char *)v5 - v30;
        if ( ((v30 + v20) & 0xFFFFFFFFFFFFFFF8LL) >= 8 )
        {
          v32 = (v30 + v20) & 0xFFFFFFFFFFFFFFF8LL;
          v33 = 0LL;
          do
          {
            *(_QWORD *)(v29 + v33) = *(_QWORD *)&v31[v33];
            v33 += 8LL;
          }
          while ( v33 < v32 );
        }
      }
      else if ( v20 & 4 )
      {
        *(_DWORD *)(v3 - 24) = *(_DWORD *)v5;
        *(_DWORD *)(v28 + v20 - 4) = *(_DWORD *)((char *)v5 + v20 - 4);
      }
      else if ( v20 )
      {
        *(_BYTE *)(v3 - 24) = *(_BYTE *)v5;
        if ( v20 & 2 )
          *(_WORD *)(v28 + v20 - 2) = *(_WORD *)((char *)v5 + v20 - 2);
      }
      *(_DWORD *)(v3 - 8) = v20;
    }
  }
  return __readfsqword(0x28u) ^ v36;
}

__int64 sub_610E0()
{
  return 0LL;
}

signed __int64 sub_610F0()
{
  return 1LL;
}

__int64 __fastcall sub_61100(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 8LL))();
}

__int64 __fastcall sub_61110(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 16LL))();
}

void sub_61120()
{
  void **i; // rdi

  for ( i = (void **)off_3260A0; off_3260A0 != &off_3260A0; i = (void **)off_3260A0 )
  {
    off_3260A0 = *i;
    sub_2F4D0(i - 2);
  }
  off_3260A8 = &off_3260A0;
}

void *__fastcall sub_61160(__int64 a1, const void *a2, int a3)
{
  size_t v3; // rbp
  char *v4; // rax
  void *result; // rax
  size_t v6; // rbp

  v3 = a3;
  v4 = (char *)sub_2F4F0(*(void **)(a1 - 64), (unsigned __int64 *)(a1 - 56), 1uLL, *(_QWORD *)(a1 - 88), a3, 1);
  *(_QWORD *)(a1 - 64) = v4;
  result = memcpy(&v4[*(_QWORD *)(a1 - 88)], a2, v3);
  v6 = *(_QWORD *)(a1 - 88) + v3;
  *(_QWORD *)(a1 - 88) = v6;
  *(_QWORD *)(a1 - 16) = v6;
  return result;
}

void __fastcall sub_611C0(_QWORD *a1)
{
  _QWORD *v1; // rbx

  v1 = (_QWORD *)a1[20];
  (*(void (**)(void))(*a1 + 8LL))();
  sub_42130(v1);
}

__int64 __fastcall sub_611E0(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( *((_BYTE *)a1 + 24) )
  {
    *(_QWORD *)(result + 8) = a1[1];
    *(_QWORD *)a1[1] = result;
  }
  else
  {
    if ( result )
      __assert_fail("!node->next", "sshcommon.c", 0x1Au, "pq_ensure_unlinked");
    if ( a1[1] )
      __assert_fail("!node->prev", "sshcommon.c", 0x1Bu, "pq_ensure_unlinked");
  }
  return result;
}

signed __int64 __fastcall sub_61250(void **a1, void ***a2, char a3)
{
  void **v3; // rbx
  _QWORD *v5; // rax
  unsigned __int64 v6; // rax
  void *v7; // rdx
  __int64 v8; // rax
  bool v9; // zf

  v3 = *a2;
  if ( a1 == *a2 )
    return 0LL;
  if ( a3 )
  {
    v5 = *v3;
    v5[1] = v3[1];
    *(_QWORD *)v3[1] = v5;
    v6 = (unsigned __int64)a1[4];
    v7 = v3[2];
    if ( v6 < (unsigned __int64)v7 )
      __assert_fail("pqb->total_size >= node->formal_size", "sshcommon.c", 0x55u, "pq_unlink_common");
    v8 = v6 - (_QWORD)v7;
    v9 = *a1 == a1;
    a1[4] = (void *)v8;
    if ( v9 )
    {
      if ( v8 )
        sub_1AE73();
    }
    v3[1] = off_3260A8;
    *v3 = &off_3260A0;
    off_3260A8 = v3;
    *(_QWORD *)v3[1] = v3;
    *((_BYTE *)v3 + 24) = 1;
    sub_1BE20((__int64)&off_326080);
  }
  return (signed __int64)(v3 - 2);
}

__int64 (__fastcall **__fastcall sub_61300(__int64 (__fastcall ***a1)()))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_324360;
  if ( *a1 != off_324360 )
    __assert_fail("chan->vt == &zombiechan_channelvt", "sshcommon.c", 0x15Fu, "zombiechan_set_input_wanted");
  return result;
}

__int64 __fastcall sub_61340(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_324360 )
    __assert_fail("chan->vt == &zombiechan_channelvt", "sshcommon.c", 0x159u, "zombiechan_send");
  return 0LL;
}

__int64 (__fastcall **__fastcall sub_61380(__int64 (__fastcall ***a1)()))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_324360;
  if ( *a1 != off_324360 )
    __assert_fail("chan->vt == &zombiechan_channelvt", "sshcommon.c", 0x153u, "zombiechan_open_failure");
  return result;
}

__int64 (__fastcall **__fastcall sub_613C0(__int64 (__fastcall ***a1)()))()
{
  __int64 (__fastcall **result)(); // rax

  result = off_324360;
  if ( *a1 != off_324360 )
    __assert_fail("chan->vt == &zombiechan_channelvt", "sshcommon.c", 0x14Eu, "zombiechan_do_nothing");
  return result;
}

void __fastcall sub_61400(__int64 (__fastcall ***a1)())
{
  if ( *a1 != off_324360 )
    __assert_fail("chan->vt == &zombiechan_channelvt", "sshcommon.c", 0x148u, "zombiechan_free");
  sub_2F4D0(a1);
}

signed __int64 __fastcall sub_61440(__int64 *a1, __int64 **a2, char a3)
{
  __int64 *v3; // rax
  __int64 v5; // rdx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  bool v9; // zf

  v3 = *a2;
  if ( a1 == *a2 )
    return 0LL;
  if ( !a3 )
    return (signed __int64)(v3 - 8);
  v5 = *v3;
  *(_QWORD *)(v5 + 8) = v3[1];
  *(_QWORD *)v3[1] = v5;
  v6 = a1[4];
  v7 = v3[2];
  if ( v6 < v7 )
    __assert_fail("pqb->total_size >= node->formal_size", "sshcommon.c", 0x55u, "pq_unlink_common");
  v8 = v6 - v7;
  v9 = *a1 == (_QWORD)a1;
  a1[4] = v8;
  if ( v9 )
  {
    if ( v8 )
      sub_1AE73();
  }
  *v3 = 0LL;
  v3[1] = 0LL;
  return (signed __int64)(v3 - 8);
}

__int64 __fastcall sub_614E0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rbp
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 result; // rax

  v2 = a1;
  sub_611E0(a2);
  v3 = *(_QWORD *)(a1 + 8);
  *a2 = a1;
  v4 = *(_QWORD *)(a1 + 40);
  a2[1] = v3;
  *(_QWORD *)(v2 + 8) = a2;
  *(_QWORD *)a2[1] = a2;
  result = a2[2];
  *(_QWORD *)(v2 + 32) += result;
  if ( v4 )
    result = (__int64)sub_1BE20(v4);
  return result;
}

__int64 __fastcall sub_61540(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // rbp
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 result; // rax

  v2 = a1;
  sub_611E0(a2);
  v3 = *a1;
  a2[1] = (__int64)a1;
  v4 = a1[5];
  *a2 = v3;
  *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)a2[1] = a2;
  result = a2[2];
  v2[4] += result;
  if ( v4 )
    result = (__int64)sub_1BE20(v4);
  return result;
}

signed __int64 (__fastcall *__fastcall sub_615A0(_QWORD *a1))(void **a1, void ***a2, char a3)
{
  signed __int64 (__fastcall *result)(void **, void ***, char); // rax

  result = sub_61250;
  a1[5] = 0LL;
  a1[1] = a1;
  *a1 = a1;
  a1[4] = 0LL;
  a1[6] = sub_61250;
  return result;
}

signed __int64 (__fastcall *__fastcall sub_615D0(_QWORD *a1))(__int64 *a1, __int64 **a2, char a3)
{
  signed __int64 (__fastcall *result)(__int64 *, __int64 **, char); // rax

  result = sub_61440;
  a1[5] = 0LL;
  a1[1] = a1;
  *a1 = a1;
  a1[4] = 0LL;
  a1[6] = sub_61440;
  return result;
}

__int64 __fastcall sub_61600(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 40) = 0LL;
  do
    result = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(a1 + 48))(a1, a1, 1LL);
  while ( result );
  return result;
}

__int64 __fastcall sub_61630(__int64 a1)
{
  __int64 result; // rax
  void *v2; // rbx

  *(_QWORD *)(a1 + 40) = 0LL;
  while ( 1 )
  {
    result = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(a1 + 48))(a1, a1, 1LL);
    v2 = (void *)result;
    if ( !result )
      break;
    sub_2F4D0(*(void **)(result + 32));
    sub_2F4D0(v2);
  }
  return result;
}

_QWORD *__fastcall sub_61680(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rax
  _QWORD *v5; // rdi
  _QWORD *v6; // rcx
  _QWORD *v7; // r8
  __int64 v8; // rbp
  _QWORD *result; // rax
  __int64 v10; // rdi

  v3 = a1;
  v4 = a2[4] + a3[4];
  v5 = (_QWORD *)*a2;
  v6 = (_QWORD *)*a3;
  v7 = (_QWORD *)a3[1];
  *a2 = a2;
  v8 = v4;
  result = (_QWORD *)a2[1];
  if ( v5 == a2 )
    v5 = 0LL;
  a2[1] = a2;
  a3[1] = a3;
  *a3 = a3;
  a3[4] = 0LL;
  a2[4] = 0LL;
  if ( a2 == result )
    result = 0LL;
  if ( v6 == a3 )
    v6 = 0LL;
  if ( a3 == v7 )
    v7 = 0LL;
  if ( result )
    *result = v6;
  else
    v5 = v6;
  if ( v6 )
    v6[1] = result;
  else
    v7 = result;
  if ( (_QWORD *)*v3 != v3 )
    __assert_fail("qdest->end.next == &qdest->end", "sshcommon.c", 0xD5u, "pq_base_concatenate");
  if ( v3 != (_QWORD *)v3[1] )
    __assert_fail("qdest->end.prev == &qdest->end", "sshcommon.c", 0xD6u, "pq_base_concatenate");
  if ( v5 )
  {
    if ( !v7 )
      __assert_fail("tail2", "sshcommon.c", 0xE0u, "pq_base_concatenate");
    *v3 = v5;
    v3[1] = v7;
    v5[1] = v3;
    v10 = v3[5];
    *v7 = v3;
    if ( v10 )
      result = sub_1BE20(v10);
  }
  else if ( v7 )
  {
    __assert_fail("!tail2", "sshcommon.c", 0xDEu, "pq_base_concatenate");
  }
  v3[4] = v8;
  return result;
}

_QWORD *sub_617D0()
{
  _QWORD *result; // rax

  result = sub_2F450(1uLL, 0x70uLL, 0LL);
  result[4] = 0LL;
  result[1] = 0LL;
  result[5] = 0LL;
  result[12] = sub_61160;
  result[13] = result + 12;
  *((_DWORD *)result + 12) = 0;
  result[7] = 0LL;
  result[9] = 0LL;
  result[8] = 0LL;
  *((_BYTE *)result + 88) = 0;
  return result;
}

void __fastcall sub_61840(void **a1)
{
  sub_2F4D0(a1[4]);
  sub_2F4D0(a1);
}

_DWORD *sub_61860()
{
  _DWORD *result; // rax

  result = sub_2F450(1uLL, 0x10uLL, 0LL);
  result[2] = 0;
  *(_QWORD *)result = off_324360;
  return result;
}

_QWORD *__fastcall sub_61890(_QWORD *a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r13
  const char *v4; // rbp
  __int64 (__fastcall **v5)(); // rbx
  _BYTE *v6; // rax
  const char *v7; // r14
  char *v8; // rbp
  signed int v9; // eax
  _BOOL8 v10; // r15
  __int64 v11; // rdx
  char v12; // al
  __int64 v13; // rax
  __int64 v14; // r8
  _QWORD *result; // rax
  char v16[12]; // [rsp+24h] [rbp-564h]
  __int64 v17; // [rsp+30h] [rbp-558h]
  char v18; // [rsp+130h] [rbp-458h]
  char v19; // [rsp+131h] [rbp-457h]
  int v20[256]; // [rsp+134h] [rbp-454h]
  unsigned __int64 v21; // [rsp+534h] [rbp-54h]
  unsigned __int64 v22; // [rsp+548h] [rbp-40h]

  v3 = a3;
  v4 = "INTR";
  v5 = (__int64 (__fastcall **)())&unk_31FFC8;
  v22 = __readfsqword(0x28u);
  memset(&v17, 0, 0x508uLL);
  HIDWORD(v21) = 0;
  while ( 1 )
  {
    v6 = (_BYTE *)sub_1F2F0(v3, 54, (__int64)v4);
    if ( !v6 )
      goto LABEL_16;
    if ( *v6 == 65 )
    {
      v7 = (const char *)(*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a2 + 48LL))(a2, v4);
      v8 = (char *)v7;
    }
    else
    {
      if ( *v6 != 86 )
        goto LABEL_16;
      v7 = v6 + 1;
      v8 = 0LL;
    }
    if ( v7 )
    {
      v9 = *((_DWORD *)v5 + 1);
      if ( v9 )
      {
        if ( v9 != 1 )
          __assert_fail("false && \"Bad mode->type\"", "sshcommon.c", 0x1DDu, "get_ttymodes_from_conf");
        LODWORD(v10) = 1;
        if ( strcasecmp(v7, "yes") )
        {
          if ( strcasecmp(v7, "on") )
          {
            if ( strcasecmp(v7, "true") )
            {
              if ( strcasecmp(v7, "+") )
              {
                LODWORD(v10) = 0;
                if ( strcasecmp(v7, "no") )
                {
                  if ( strcasecmp(v7, "off") && strcasecmp(v7, "false") && strcasecmp(v7, "-") )
                    v10 = (unsigned int)strtol(v7, 0LL, 10) != 0;
                }
              }
            }
          }
        }
      }
      else
      {
        LODWORD(v10) = 255;
        if ( *v7 )
        {
          *(_QWORD *)&v16[4] = 0LL;
          v12 = sub_BBFA0(v7, (char **)&v16[4]);
          if ( !*(_QWORD *)&v16[4] )
            v12 = *v7;
          LODWORD(v10) = v12;
        }
      }
      v11 = *(signed int *)v5;
      *((_BYTE *)&v17 + v11) = 1;
      v20[v11] = v10;
    }
    sub_2F4D0(v8);
LABEL_16:
    v5 += 2;
    if ( v5 == off_320328 )
      break;
    v4 = (const char *)*(v5 - 1);
  }
  *(_QWORD *)v16 = 164926744204800LL;
  v13 = sub_1F170(v3, 53);
  __isoc99_sscanf(v13, "%u,%u", v16, &v16[4], v14);
  v18 = 1;
  v19 = 1;
  v21 = __PAIR__(*(unsigned int *)v16, *(unsigned int *)&v16[4]);
  *a1 = v17;
  *(_QWORD *)((char *)a1 + 1284) = v21;
  result = a1;
  qmemcpy(
    (void *)((unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    (const void *)((char *)&v17 - ((char *)a1 - ((unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
    8LL * (((unsigned int)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 1292) >> 3));
  return result;
}

_QWORD *__fastcall sub_61BA0(_QWORD *a1, __int64 a2, int a3)
{
  _QWORD *v3; // r14
  int v4; // er13
  unsigned __int8 v5; // al
  signed __int64 v6; // rbx
  __int64 v7; // rdi
  _QWORD *result; // rax
  __int64 v9; // [rsp+0h] [rbp-548h]
  int v10[256]; // [rsp+104h] [rbp-444h]
  __int64 v11; // [rsp+504h] [rbp-44h]
  unsigned __int64 v12; // [rsp+518h] [rbp-30h]

  v3 = a1;
  v4 = a3;
  v12 = __readfsqword(0x28u);
  memset(&v9, 0, 0x508uLL);
  HIDWORD(v11) = 0;
  while ( 1 )
  {
    v5 = sub_2F080(*(_QWORD *)(a2 + 32));
    if ( (unsigned __int8)(v5 - 1) > 0x9Eu )
      break;
    if ( v4 == 1 )
    {
      if ( v5 == -64 )
      {
        v6 = 256LL;
        goto LABEL_12;
      }
      if ( v5 == -63 )
      {
        v6 = 257LL;
LABEL_12:
        v7 = *(_QWORD *)(a2 + 32);
        *((_BYTE *)&v9 + v6) = 1;
        goto LABEL_13;
      }
    }
    else
    {
      if ( v5 == -128 )
      {
        v6 = 256LL;
        goto LABEL_7;
      }
      if ( v5 == -127 )
      {
        v6 = 257LL;
LABEL_7:
        v7 = *(_QWORD *)(a2 + 32);
        *((_BYTE *)&v9 + v6) = 1;
        goto LABEL_8;
      }
    }
    v6 = v5;
    v7 = *(_QWORD *)(a2 + 32);
    *((_BYTE *)&v9 + v5) = 1;
    if ( v4 == 1 )
    {
LABEL_13:
      if ( v5 > 0x7Fu )
        goto LABEL_8;
      v10[v6] = (unsigned __int8)sub_2F080(v7);
    }
    else
    {
LABEL_8:
      v10[v6] = sub_2F150(v7);
    }
  }
  *v3 = v9;
  *(_QWORD *)((char *)v3 + 1284) = v11;
  result = v3;
  qmemcpy(
    (void *)((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    (const void *)((char *)&v9 - ((char *)v3 - ((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
    8LL * (((unsigned int)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 1292) >> 3));
  return result;
}

__int64 __fastcall sub_61CE0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, __int64 a39)
{
  int v39; // er14
  __int64 v40; // r13
  __int64 v41; // rbx
  __int64 (__fastcall **v42)(_QWORD, char *, signed __int64); // rdi
  char v43; // si
  int v44; // ebp

  v39 = a2;
  v40 = a1;
  v41 = 0LL;
  v42 = *(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8);
  do
  {
    while ( 1 )
    {
      if ( !*((_BYTE *)&a7 + v41) )
        goto LABEL_6;
      v44 = *((_DWORD *)&a39 + v41 + 1);
      if ( (_DWORD)v41 != 256 )
        break;
      v43 = -128;
      if ( v39 == 1 )
      {
        sub_2ECE0(v42, 192);
        goto LABEL_5;
      }
LABEL_4:
      sub_2ECE0(v42, v43);
LABEL_5:
      sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(v40 + 8), v44);
      v42 = *(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v40 + 8);
LABEL_6:
      if ( ++v41 == 258 )
        return sub_2ECE0(v42, 0);
    }
    if ( (_DWORD)v41 == 257 )
    {
      v43 = -127;
      if ( v39 == 1 )
      {
        sub_2ECE0(v42, 193);
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    sub_2ECE0(v42, v41);
    if ( (unsigned int)(v41 - 1) > 0x7E || v39 != 1 )
      goto LABEL_5;
    ++v41;
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v40 + 8), v44);
    v42 = *(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v40 + 8);
  }
  while ( v41 != 258 );
  return sub_2ECE0(v42, 0);
}

__int64 __fastcall sub_61DD0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+0h] [rbp-48h]
  int v4; // [rsp+8h] [rbp-40h]
  unsigned __int64 v5; // [rsp+28h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  sub_9B200((__int64)&v3, (_QWORD *)a1);
  while ( 1 )
  {
    result = (unsigned int)(v4 + 256);
    if ( !v3 )
      break;
    if ( *(_DWORD *)(v3 + a2) == (_DWORD)result )
      sub_9B0A0((__int64)&v3, 1);
    else
      sub_9B0A0((__int64)&v3, -1);
  }
  return result;
}

__int64 __fastcall sub_61E60(__int64 a1, const char *a2)
{
  if ( *(_QWORD *)(a1 + 16) )
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), 44);
  strlen(a2);
  return sub_2EC20((__int64 (**)(void))(a1 + 24));
}

signed __int64 __fastcall sub_61EA0(__m128i *a1, __m128i *a2)
{
  size_t v2; // rdx
  _BYTE *v3; // rbx
  _BYTE *v4; // rax
  signed __int64 v5; // rax
  signed __int64 result; // rax

  v2 = a1->m128i_i64[1];
  if ( !v2 )
    return 0LL;
  v3 = (_BYTE *)a1->m128i_i64[0];
  while ( *v3 == 44 )
  {
    --v2;
    a1->m128i_i64[0] = (__int64)++v3;
    a1->m128i_i64[1] = v2;
    if ( !v2 )
      return 0LL;
  }
  v4 = memchr(v3, 44, v2);
  if ( v4 )
  {
    v5 = v4 - v3;
    a2->m128i_i64[0] = (__int64)v3;
    a2->m128i_i64[1] = v5;
    a1->m128i_i64[0] += v5 + 1;
    a1->m128i_i64[1] += ~v5;
    result = 1LL;
  }
  else
  {
    result = 1LL;
    *a2 = _mm_loadu_si128(a1);
    a1->m128i_i64[1] = 0LL;
  }
  return result;
}

const char *__fastcall sub_61F60(int a1)
{
  const char *result; // rax

  result = "SSH1_MSG_DISCONNECT";
  if ( a1 != 1 )
  {
    result = "SSH1_SMSG_PUBLIC_KEY";
    if ( a1 != 2 )
    {
      result = "SSH1_CMSG_SESSION_KEY";
      if ( a1 != 3 )
      {
        result = "SSH1_CMSG_USER";
        if ( a1 != 4 )
        {
          result = "SSH1_CMSG_AUTH_RSA";
          if ( a1 != 6 )
          {
            result = "SSH1_SMSG_AUTH_RSA_CHALLENGE";
            if ( a1 != 7 )
            {
              result = "SSH1_CMSG_AUTH_RSA_RESPONSE";
              if ( a1 != 8 )
              {
                result = "SSH1_CMSG_AUTH_PASSWORD";
                if ( a1 != 9 )
                {
                  result = "SSH1_CMSG_REQUEST_PTY";
                  if ( a1 != 10 )
                  {
                    result = "SSH1_CMSG_WINDOW_SIZE";
                    if ( a1 != 11 )
                    {
                      result = "SSH1_CMSG_EXEC_SHELL";
                      if ( a1 != 12 )
                      {
                        result = "SSH1_CMSG_EXEC_CMD";
                        if ( a1 != 13 )
                        {
                          result = "SSH1_SMSG_SUCCESS";
                          if ( a1 != 14 )
                          {
                            result = "SSH1_SMSG_FAILURE";
                            if ( a1 != 15 )
                            {
                              result = "SSH1_CMSG_STDIN_DATA";
                              if ( a1 != 16 )
                              {
                                result = "SSH1_SMSG_STDOUT_DATA";
                                if ( a1 != 17 )
                                {
                                  result = "SSH1_SMSG_STDERR_DATA";
                                  if ( a1 != 18 )
                                  {
                                    result = "SSH1_CMSG_EOF";
                                    if ( a1 != 19 )
                                    {
                                      result = "SSH1_SMSG_EXIT_STATUS";
                                      if ( a1 != 20 )
                                      {
                                        result = "SSH1_MSG_CHANNEL_OPEN_CONFIRMATION";
                                        if ( a1 != 21 )
                                        {
                                          result = "SSH1_MSG_CHANNEL_OPEN_FAILURE";
                                          if ( a1 != 22 )
                                          {
                                            result = "SSH1_MSG_CHANNEL_DATA";
                                            if ( a1 != 23 )
                                            {
                                              result = "SSH1_MSG_CHANNEL_CLOSE";
                                              if ( a1 != 24 )
                                              {
                                                result = "SSH1_MSG_CHANNEL_CLOSE_CONFIRMATION";
                                                if ( a1 != 25 )
                                                {
                                                  result = "SSH1_SMSG_X11_OPEN";
                                                  if ( a1 != 27 )
                                                  {
                                                    result = "SSH1_CMSG_PORT_FORWARD_REQUEST";
                                                    if ( a1 != 28 )
                                                    {
                                                      result = "SSH1_MSG_PORT_OPEN";
                                                      if ( a1 != 29 )
                                                      {
                                                        result = "SSH1_CMSG_AGENT_REQUEST_FORWARDING";
                                                        if ( a1 != 30 )
                                                        {
                                                          result = "SSH1_SMSG_AGENT_OPEN";
                                                          if ( a1 != 31 )
                                                          {
                                                            result = "SSH1_MSG_IGNORE";
                                                            if ( a1 != 32 )
                                                            {
                                                              result = "SSH1_CMSG_EXIT_CONFIRMATION";
                                                              if ( a1 != 33 )
                                                              {
                                                                result = "SSH1_CMSG_X11_REQUEST_FORWARDING";
                                                                if ( a1 != 34 )
                                                                {
                                                                  result = "SSH1_CMSG_AUTH_RHOSTS_RSA";
                                                                  if ( a1 != 35 )
                                                                  {
                                                                    result = "SSH1_MSG_DEBUG";
                                                                    if ( a1 != 36 )
                                                                    {
                                                                      result = "SSH1_CMSG_REQUEST_COMPRESSION";
                                                                      if ( a1 != 37 )
                                                                      {
                                                                        result = "SSH1_CMSG_AUTH_TIS";
                                                                        if ( a1 != 39 )
                                                                        {
                                                                          result = "SSH1_SMSG_AUTH_TIS_CHALLENGE";
                                                                          if ( a1 != 40 )
                                                                          {
                                                                            result = "SSH1_CMSG_AUTH_TIS_RESPONSE";
                                                                            if ( a1 != 41 )
                                                                            {
                                                                              result = "SSH1_CMSG_AUTH_CCARD";
                                                                              if ( a1 != 70 )
                                                                              {
                                                                                result = "SSH1_SMSG_AUTH_CCARD_CHALLENGE";
                                                                                if ( a1 != 71 )
                                                                                {
                                                                                  result = "SSH1_CMSG_AUTH_CCARD_RESPONSE";
                                                                                  if ( a1 != 72 )
                                                                                    result = "unknown";
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const char *__fastcall sub_621E0(int a1, int a2, int a3)
{
  const char *result; // rax
  bool v4; // cl
  bool v5; // r8
  bool v6; // r9
  bool v7; // r8
  bool v8; // r10
  bool v9; // r11
  bool v10; // bl
  bool v11; // r8
  bool v12; // r8
  bool v13; // di
  bool v14; // di
  bool v15; // cl
  bool v16; // r8
  bool v17; // cl

  result = "SSH2_MSG_DISCONNECT";
  if ( a3 != 1 )
  {
    result = "SSH2_MSG_IGNORE";
    if ( a3 != 2 )
    {
      result = "SSH2_MSG_UNIMPLEMENTED";
      if ( a3 != 3 )
      {
        result = "SSH2_MSG_DEBUG";
        if ( a3 != 4 )
        {
          result = "SSH2_MSG_SERVICE_REQUEST";
          if ( a3 != 5 )
          {
            result = "SSH2_MSG_SERVICE_ACCEPT";
            if ( a3 != 6 )
            {
              result = "SSH2_MSG_EXT_INFO";
              if ( a3 != 7 )
              {
                result = "SSH2_MSG_KEXINIT";
                if ( a3 != 20 )
                {
                  result = "SSH2_MSG_NEWKEYS";
                  if ( a3 != 21 )
                  {
                    v4 = a3 == 30;
                    v5 = a1 == 1;
                    if ( a3 != 30 || (result = "SSH2_MSG_KEXDH_INIT", !v5) )
                    {
                      v6 = a3 == 31;
                      if ( !v5 || (result = "SSH2_MSG_KEXDH_REPLY", !v6) )
                      {
                        v7 = a1 == 2;
                        if ( !v4 || (result = "SSH2_MSG_KEX_DH_GEX_REQUEST_OLD", !v7) )
                        {
                          v8 = a3 == 34;
                          if ( !v7 || (result = "SSH2_MSG_KEX_DH_GEX_REQUEST", !v8) )
                          {
                            if ( !v6 || (result = "SSH2_MSG_KEX_DH_GEX_GROUP", !v7) )
                            {
                              v9 = a3 == 32;
                              if ( !v7 || (result = "SSH2_MSG_KEX_DH_GEX_INIT", !v9) )
                              {
                                v10 = a3 == 33;
                                if ( !v7 || (result = "SSH2_MSG_KEX_DH_GEX_REPLY", !v10) )
                                {
                                  v11 = a1 == 4;
                                  if ( !v4 || (result = "SSH2_MSG_KEXGSS_INIT", !v11) )
                                  {
                                    if ( !v6 || (result = "SSH2_MSG_KEXGSS_CONTINUE", !v11) )
                                    {
                                      if ( !v9 || (result = "SSH2_MSG_KEXGSS_COMPLETE", !v11) )
                                      {
                                        if ( !v10 || (result = "SSH2_MSG_KEXGSS_HOSTKEY", !v11) )
                                        {
                                          if ( !v8 || (result = "SSH2_MSG_KEXGSS_ERROR", !v11) )
                                          {
                                            if ( a3 != 40 || (result = "SSH2_MSG_KEXGSS_GROUPREQ", !v11) )
                                            {
                                              if ( a3 != 41 || (result = "SSH2_MSG_KEXGSS_GROUP", !v11) )
                                              {
                                                v12 = a1 == 5;
                                                if ( !v4 || (result = "SSH2_MSG_KEXRSA_PUBKEY", !v12) )
                                                {
                                                  if ( !v6 || (result = "SSH2_MSG_KEXRSA_SECRET", !v12) )
                                                  {
                                                    if ( !v9 || (result = "SSH2_MSG_KEXRSA_DONE", !v12) )
                                                    {
                                                      v13 = a1 == 3;
                                                      if ( !v4 || (result = "SSH2_MSG_KEX_ECDH_INIT", !v13) )
                                                      {
                                                        if ( !v6 || (result = "SSH2_MSG_KEX_ECDH_REPLY", !v13) )
                                                        {
                                                          result = "SSH2_MSG_USERAUTH_REQUEST";
                                                          if ( a3 != 50 )
                                                          {
                                                            result = "SSH2_MSG_USERAUTH_FAILURE";
                                                            if ( a3 != 51 )
                                                            {
                                                              result = "SSH2_MSG_USERAUTH_SUCCESS";
                                                              if ( a3 != 52 )
                                                              {
                                                                result = "SSH2_MSG_USERAUTH_BANNER";
                                                                if ( a3 != 53 )
                                                                {
                                                                  v14 = a3 == 60;
                                                                  if ( a2 != 1
                                                                    || (result = "SSH2_MSG_USERAUTH_PK_OK", !v14) )
                                                                  {
                                                                    if ( a2 != 2
                                                                      || (result = "SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ",
                                                                          !v14) )
                                                                    {
                                                                      v15 = a2 == 4;
                                                                      if ( !v14
                                                                        || (result = "SSH2_MSG_USERAUTH_INFO_REQUEST",
                                                                            !v15) )
                                                                      {
                                                                        v16 = a3 == 61;
                                                                        if ( !v15
                                                                          || (result = "SSH2_MSG_USERAUTH_INFO_RESPONSE",
                                                                              !v16) )
                                                                        {
                                                                          v17 = a2 == 3;
                                                                          if ( !v14
                                                                            || (result = "SSH2_MSG_USERAUTH_GSSAPI_RESPONSE",
                                                                                !v17) )
                                                                          {
                                                                            if ( !v16
                                                                              || (result = "SSH2_MSG_USERAUTH_GSSAPI_TOKEN",
                                                                                  !v17) )
                                                                            {
                                                                              if ( a3 != 63
                                                                                || (result = "SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE",
                                                                                    !v17) )
                                                                              {
                                                                                if ( a3 != 64
                                                                                  || (result = "SSH2_MSG_USERAUTH_GSSAPI_ERROR",
                                                                                      !v17) )
                                                                                {
                                                                                  if ( a3 != 65
                                                                                    || (result = "SSH2_MSG_USERAUTH_GSSAPI_ERRTOK",
                                                                                        !v17) )
                                                                                  {
                                                                                    if ( a3 != 66
                                                                                      || (result = "SSH2_MSG_USERAUTH_GSSAPI_MIC",
                                                                                          !v17) )
                                                                                    {
                                                                                      result = "SSH2_MSG_GLOBAL_REQUEST";
                                                                                      if ( a3 != 80 )
                                                                                      {
                                                                                        result = "SSH2_MSG_REQUEST_SUCCESS";
                                                                                        if ( a3 != 81 )
                                                                                        {
                                                                                          result = "SSH2_MSG_REQUEST_FAILURE";
                                                                                          if ( a3 != 82 )
                                                                                          {
                                                                                            result = "SSH2_MSG_CHANNEL_OPEN";
                                                                                            if ( a3 != 90 )
                                                                                            {
                                                                                              result = "SSH2_MSG_CHANNEL_OPEN_CONFIRMATION";
                                                                                              if ( a3 != 91 )
                                                                                              {
                                                                                                result = "SSH2_MSG_CHANNEL_OPEN_FAILURE";
                                                                                                if ( a3 != 92 )
                                                                                                {
                                                                                                  result = "SSH2_MSG_CHANNEL_WINDOW_ADJUST";
                                                                                                  if ( a3 != 93 )
                                                                                                  {
                                                                                                    result = "SSH2_MSG_CHANNEL_DATA";
                                                                                                    if ( a3 != 94 )
                                                                                                    {
                                                                                                      result = "SSH2_MSG_CHANNEL_EXTENDED_DATA";
                                                                                                      if ( a3 != 95 )
                                                                                                      {
                                                                                                        result = "SSH2_MSG_CHANNEL_EOF";
                                                                                                        if ( a3 != 96 )
                                                                                                        {
                                                                                                          result = "SSH2_MSG_CHANNEL_CLOSE";
                                                                                                          if ( a3 != 97 )
                                                                                                          {
                                                                                                            result = "SSH2_MSG_CHANNEL_REQUEST";
                                                                                                            if ( a3 != 98 )
                                                                                                            {
                                                                                                              result = "SSH2_MSG_CHANNEL_SUCCESS";
                                                                                                              if ( a3 != 99 )
                                                                                                              {
                                                                                                                result = "unknown";
                                                                                                                if ( a3 == 100 )
                                                                                                                  result = "SSH2_MSG_CHANNEL_FAILURE";
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

__int64 __fastcall sub_62630(__int64 (***a1)(void))
{
  sub_1BCD0((__int64)a1);
  return (**a1)();
}

_QWORD *__fastcall sub_62650(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  a1[3] = a3;
  a1[2] = a2;
  *(_QWORD *)(a2 + 40) = a1 + 4;
  a1[4] = sub_61100;
  a1[5] = a1;
  result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a2 + 48))(a2, a2, 0LL);
  if ( result )
    result = sub_1BE20((__int64)(a1 + 4));
  return result;
}

_QWORD *__fastcall sub_626A0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdx
  _QWORD *v3; // rax
  __int64 v4; // rdx

  v2 = *(_QWORD *)(a1 + 24);
  a2[1] = *(_QWORD *)(a1 + 8);
  sub_62650(a2, *(_QWORD *)(a1 + 16), v2);
  v3 = *(_QWORD **)(a1 + 56);
  a2[8] = *(_QWORD *)(a1 + 64);
  v4 = *(_QWORD *)(a1 + 80);
  a2[7] = v3;
  a2[10] = v4;
  a2[11] = *(_QWORD *)(a1 + 88);
  *v3 = a2;
  sub_1BCD0(a1);
  (**(void (__fastcall ***)(__int64))a1)(a1);
  return sub_1BE20((__int64)(a2 + 4));
}

void __fastcall sub_62710(__int64 a1, char *a2)
{
  size_t v2; // rax

  v2 = strlen(a2);
  (***(void (__fastcall ****)(_QWORD, signed __int64, char *, size_t))(a1 + 80))(*(_QWORD *)(a1 + 80), 1LL, a2, v2);
  sub_2F4D0(a2);
}

__int64 __fastcall sub_62750(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 32LL);
}

signed __int64 __fastcall sub_62760(__int64 a1)
{
  signed __int64 result; // rax

  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = a1 + 32;
  *(_QWORD *)(a1 + 32) = a1 + 32;
  *(_QWORD *)(a1 + 176) = a1;
  *(_QWORD *)(a1 + 200) = a1;
  *(_QWORD *)(a1 + 80) = sub_61250;
  *(_QWORD *)(a1 + 96) = a1 + 88;
  *(_QWORD *)(a1 + 88) = a1 + 88;
  *(_QWORD *)(a1 + 136) = sub_61440;
  *(_QWORD *)(a1 + 168) = sub_611C0;
  *(_QWORD *)(a1 + 192) = sub_61110;
  result = a1 + 192;
  *(_QWORD *)(a1 + 128) = a1 + 192;
  return result;
}

__int64 __fastcall sub_627F0(__int64 (***a1)(void))
{
  sub_1BCD0((__int64)a1);
  return (**a1)();
}

__int64 __fastcall sub_62810(__int64 a1, char *a2, int a3)
{
  int v3; // er13
  __int64 v4; // rax
  void (__fastcall **v5)(_QWORD, char *, signed __int64); // r12
  __int64 v6; // rbp

  v3 = a3;
  v4 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)a1 + 24LL))(1LL);
  v5 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v4 + 96);
  v6 = v4;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v4 + 96), v3);
  sub_2EF40(v5, a2);
  sub_2EF40(v5, "en");
  return sub_614E0(a1 + 88, (__int64 *)(v6 + 64));
}

signed __int64 __fastcall sub_62870(__int64 a1, __int64 a2)
{
  signed int v2; // edx
  signed __int64 result; // rax
  int v4; // ecx
  __int64 v5; // r12

  v2 = *(_DWORD *)a2;
  result = 0LL;
  if ( *(_DWORD *)a2 <= 255 )
  {
    v4 = dword_EEF00[v2 >> 5];
    if ( !_bittest(&v4, v2) )
    {
      v5 = (*(__int64 (__fastcall **)(signed __int64))(*(_QWORD *)a1 + 24LL))(3LL);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 96), *(_QWORD *)(a2 + 8));
      sub_614E0(a1 + 88, (__int64 *)(v5 + 64));
      result = 1LL;
    }
  }
  return result;
}

signed __int64 __fastcall sub_628E0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 *v4; // rbp
  signed __int64 v5; // r12
  __int64 v6; // rbx
  char *v7; // rax
  signed __int64 result; // rax
  signed __int64 v9; // r13
  unsigned __int64 v10; // rbx
  _BYTE *v11; // rax
  _BYTE *v12; // r14
  char *v13; // r15
  __int64 v14; // rax
  __int64 v15; // rbx
  signed __int64 v16; // r12
  char *v17; // rdx
  signed int v18; // esi
  unsigned __int8 *v19; // rdi
  int v20; // [rsp+Ch] [rbp-3Ch]

  v3 = a3;
  v4 = a1;
  if ( !sub_1F430(a1, 192, 0) )
    return 0xFFFFFFFFLL;
  v5 = 0LL;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = *(_QWORD *)(a2 + 8 * v5);
      if ( v6 )
      {
        v7 = strrchr(*(const char **)(a2 + 8 * v5), 32);
        if ( v7 )
          v6 = (__int64)(v7 + 1);
        if ( sub_1F240(a1, 192, v6) )
          break;
      }
      if ( v5 == 1 )
        goto LABEL_8;
      v5 = 1LL;
    }
    result = 1LL;
  }
  else
  {
LABEL_8:
    result = 0LL;
    if ( v3 )
    {
      v9 = sub_BC640();
      (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v3 + 56LL))(v3, v9 + 24);
      v10 = (unsigned __int64)(0xAAAAAAAAAAAAAAABLL * (unsigned __int128)(unsigned __int64)(*(_QWORD *)(v9 + 16) + 2LL) >> 64) >> 1;
      v20 = 4 * v10;
      v11 = sub_2F450(v20 + 1, 1uLL, 0LL);
      v12 = v11;
      if ( (signed int)v10 > 0 )
      {
        v13 = v11;
        v14 = (unsigned int)(v10 - 1);
        v15 = 0LL;
        v16 = 3 * v14 + 3;
        do
        {
          v17 = v13;
          v13 += 4;
          v18 = *(_DWORD *)(v9 + 16) - v15;
          v19 = (unsigned __int8 *)(v15 + *(_QWORD *)(v9 + 8));
          v15 += 3LL;
          sub_BCA40(v19, v18, v17);
        }
        while ( v16 != v15 );
      }
      v12[v20] = 0;
      sub_BC660((void **)v9);
      if ( sub_1F240(v4, 192, (__int64)v12) )
      {
        sub_2F4D0(v12);
        result = 1LL;
      }
      else
      {
        sub_2F4D0(v12);
        result = 0LL;
      }
    }
  }
  return result;
}

signed __int64 __fastcall sub_62A70(__int64 a1, void (__fastcall *a2)(__int64, const char *, signed __int64, _QWORD), __int64 a3)
{
  if ( *(_BYTE *)(a1 + 96) & 1 )
    return 0LL;
  a2(a3, "IGNORE message", 2LL, 0LL);
  return 1LL;
}

int *__usercall sub_62AB0@<rax>(_QWORD *a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  int *result; // rax
  int v4; // edx
  char *v5; // r12
  unsigned __int64 v6; // rdx
  unsigned int v7; // eax
  char *v8; // rax
  unsigned __int64 v9; // rdx

  while ( 1 )
  {
    result = (int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1[2] + 48LL))(a1[2], a1[2], 0LL);
    if ( !result )
      break;
    v4 = *result;
    if ( *result != 32 )
    {
      if ( v4 != 36 )
      {
        if ( v4 != 1 )
          return 0LL;
        sub_2F1D0((__int64)(result + 12));
        sub_BC2F0(v9);
        sub_42140(a1[11], (__int64)"Remote side sent disconnect message:\n\"%.*s\"", a2, a3);
        return (_DWORD *)(&n + 1);
      }
      v5 = sub_2F1D0((__int64)(result + 12));
      v7 = sub_BC2F0(v6);
      v8 = sub_BC360((__int64)"Remote debug message: %.*s", v7, v5);
      sub_2D3A0(a1[9], v8, a2, a3);
    }
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64))(a1[2] + 48LL))(a1[2], a1[2], 1LL);
  }
  return result;
}

__int64 __fastcall sub_62B70(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // r12
  signed __int64 v6; // rax
  __int64 (***v7)(void); // rbp
  unsigned __int64 v8; // rax
  signed __int64 v9; // rbx
  unsigned __int64 v10; // rsi
  char v11; // al
  unsigned __int64 v12; // rax
  signed __int64 v13; // rbx
  unsigned __int64 v14; // rsi
  char v15; // al

  v4 = a3;
  v5 = a4;
  v6 = sub_76E90((__int64)off_320E40);
  v7 = (__int64 (***)(void))v6;
  if ( v6 )
    (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v6 + 8LL))(v6);
  v8 = (unsigned __int64)(sub_335B0(*(__int64 **)(v4 + 8)) + 7) >> 3;
  v9 = v8 - 1;
  if ( v8 )
  {
    do
    {
      v10 = v9--;
      v11 = sub_334D0(*(unsigned __int64 **)(v4 + 8), v10);
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v7[1], v11);
    }
    while ( v9 != -1 );
  }
  v12 = (unsigned __int64)(sub_335B0(*(__int64 **)(v5 + 8)) + 7) >> 3;
  v13 = v12 - 1;
  if ( v12 )
  {
    do
    {
      v14 = v13--;
      v15 = sub_334D0(*(unsigned __int64 **)(v5 + 8), v14);
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v7[1], v15);
    }
    while ( v13 != -1 );
  }
  sub_2EC20(v7[1]);
  ((void (__fastcall *)(__int64 (***)(void), __int64))(*v7)[3])(v7, a1);
  return ((__int64 (__fastcall *)(__int64 (***)(void)))(*v7)[4])(v7);
}

__int64 __fastcall sub_62C70(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  unsigned int v4; // ecx
  int v5; // er8
  unsigned int v6; // ecx

  if ( !a3 )
    return a1;
  v3 = a2 + a3;
  v4 = a1;
  do
  {
    v5 = ((unsigned __int8)v4 ^ *(_BYTE *)(++a2 - 1)) & 0xF;
    v6 = 69337088 * v5 ^ ((v4 ^ *(unsigned __int8 *)(a2 - 1)) >> 4) ^ 142868512 * v5 ^ 286330948 * v5;
    v4 = 69337088 * (v6 & 0xF) ^ 142868512 * (v6 & 0xF) ^ 286330948 * (v6 & 0xF) ^ (v6 >> 4);
  }
  while ( a2 != v3 );
  return v4;
}

__int64 __fastcall sub_62CF0(__int64 a1, __int64 a2)
{
  return sub_62C70(0, a1, a2);
}

bool __fastcall sub_62D20(_QWORD *a1, _QWORD *a2, unsigned int a3, _QWORD *a4)
{
  unsigned int v4; // eax
  _QWORD *v5; // rbx
  __int64 v6; // rbp
  unsigned __int64 v7; // rbp
  void *v8; // rsi
  unsigned int v9; // eax
  unsigned int v11; // eax

  v4 = 0;
  v5 = a2;
  v6 = a3;
  if ( a4 && *a1 == *a4 )
  {
    v11 = sub_62C70(0, (__int64)&unk_EF082, 4LL);
    v4 = sub_62C70(v11, (__int64)&unk_EF07E, 4LL);
  }
  v7 = (unsigned __int64)a2 + v6;
  if ( (unsigned __int64)a2 < v7 )
  {
    do
    {
      v8 = &unk_EF082;
      if ( *v5 != *a1 )
        v8 = &unk_EF07E;
      ++v5;
      v9 = sub_62C70(v4, (__int64)v8, 4LL);
      v4 = sub_62C70(v9, (__int64)&unk_EF07E, 4LL);
    }
    while ( (unsigned __int64)v5 < v7 );
  }
  return v4 == 0;
}

_DWORD *sub_62DD0()
{
  _DWORD *result; // rax

  result = sub_2F450(1uLL, 0x10uLL, 0LL);
  *(_QWORD *)result = 0LL;
  result[2] = 4096;
  return result;
}

void __fastcall sub_62E00(void **a1)
{
  if ( a1 )
  {
    sub_2F4D0(*a1);
    *a1 = 0LL;
    sub_2F4D0(a1);
  }
}

bool __fastcall sub_62E30(__int64 a1, unsigned int *a2, unsigned int a3, unsigned int *a4)
{
  unsigned int v4; // er13
  unsigned int v5; // er8
  unsigned int *v6; // r15
  unsigned int v7; // ecx
  __int64 v8; // r9
  void *v9; // rdi
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int *v12; // r12
  unsigned int *v13; // rbx
  unsigned int *v14; // rax
  unsigned int v16; // ST08_4
  _QWORD *v17; // ST00_8
  void *v18; // rax
  unsigned int v19; // ST08_4
  _QWORD *v20; // r9
  unsigned int v21; // er8
  __int64 v22; // rdi
  unsigned int *v23; // rbp
  int i; // edx
  unsigned int v25; // edx
  signed __int64 v26; // rbx
  _WORD *v27; // rcx
  int v28; // eax
  unsigned int v29; // ST08_4
  _QWORD *v30; // ST00_8
  void *v31; // rax
  __int64 v32; // [rsp+0h] [rbp-48h]
  unsigned int v33; // [rsp+0h] [rbp-48h]
  _QWORD *v34; // [rsp+8h] [rbp-40h]

  if ( a3 > 0x40000 || (v4 = a3, (v5 = a3 & 7) != 0) )
    __assert_fail(
      "!(len > (SSH_MAXBLOCKS * SSH_BLOCKSIZE) || len % SSH_BLOCKSIZE != 0)",
      "sshcrcda.c",
      0x70u,
      "detect_attack");
  v6 = a4;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = a1;
  v9 = *(void **)a1;
  v10 = 3 * (a3 >> 3) >> 1;
  if ( v7 >= v10 )
  {
    if ( v9 )
      goto LABEL_8;
    v11 = v7;
LABEL_39:
    *(_DWORD *)(v8 + 8) = v11;
    v29 = v5;
    v30 = (_QWORD *)v8;
    v31 = sub_2F450(v11, 2uLL, 0LL);
    v8 = (__int64)v30;
    v5 = v29;
    *v30 = v31;
LABEL_8:
    v12 = (unsigned int *)((char *)a2 + v4);
    if ( v4 <= 0x38 )
      goto LABEL_9;
LABEL_20:
    v19 = v5;
    v32 = v8;
    memset(*(void **)v8, 255, 2LL * *(unsigned int *)(v8 + 8));
    v20 = (_QWORD *)v32;
    v21 = v19;
    if ( v6 )
      *(_WORD *)(*(_QWORD *)v32 + 2LL * (_byteswap_ulong(*v6) & (*(_DWORD *)(v32 + 8) - 1))) = -2;
    if ( a2 < v12 )
    {
      v22 = *(_QWORD *)v32;
      v23 = a2;
      while ( 2 )
      {
        for ( i = _byteswap_ulong(*v23); ; i = v25 + 1 )
        {
          v25 = (*((_DWORD *)v20 + 2) - 1) & i;
          v26 = 2LL * v25;
          v27 = (_WORD *)(v22 + v26);
          v28 = *(unsigned __int16 *)(v22 + v26);
          if ( (_WORD)v28 == -1 )
            break;
          if ( (_WORD)v28 == -2 )
          {
            if ( !v6 )
              __assert_fail(off_EF01E, "sshcrcda.c", 0x9Au, "detect_attack");
            if ( *(_QWORD *)v23 == *(_QWORD *)v6 )
            {
LABEL_31:
              v34 = v20;
              v33 = v21;
              if ( sub_62D20(v23, a2, v4, v6) )
                return 1;
              v20 = v34;
              v21 = v33;
              v22 = *v34;
              v27 = (_WORD *)(*v34 + v26);
              break;
            }
          }
          else if ( *(_QWORD *)v23 == *(_QWORD *)((char *)a2 + (8 * v28 & 0x7FFF8)) )
          {
            goto LABEL_31;
          }
        }
        v23 += 2;
        *v27 = v21++;
        if ( v23 < v12 )
          continue;
        break;
      }
    }
    return 0;
  }
  v11 = v7;
  do
    v11 *= 4;
  while ( v11 < v10 );
  if ( !v9 )
    goto LABEL_39;
  if ( v7 >= v11 )
    goto LABEL_8;
  *(_DWORD *)(v8 + 8) = v11;
  v16 = v5;
  v17 = (_QWORD *)v8;
  v18 = sub_2F490(v9, v11, 2uLL);
  v8 = (__int64)v17;
  v12 = (unsigned int *)((char *)a2 + v4);
  v5 = v16;
  *v17 = v18;
  if ( v4 > 0x38 )
    goto LABEL_20;
LABEL_9:
  v13 = a2;
  if ( a2 >= v12 )
    return 0;
  while ( !v6 || *(_QWORD *)v13 != *(_QWORD *)v6 )
  {
    if ( a2 < v13 )
    {
      v14 = a2;
      while ( *(_QWORD *)v13 != *(_QWORD *)v14 )
      {
        v14 += 2;
        if ( v14 >= v13 )
          goto LABEL_17;
      }
      if ( sub_62D20(v13, a2, v4, v6) )
        return 1;
    }
LABEL_17:
    v13 += 2;
    if ( v13 >= v12 )
      return 0;
  }
  return sub_62D20(v13, a2, v4, v6);
}

__int64 __fastcall sub_630F0(int a1, int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // edx
  signed int v5; // er9
  unsigned int v6; // ebx
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // er14
  int v10; // er8
  unsigned int v11; // esi
  unsigned int v12; // er15
  int v13; // er8
  unsigned int v14; // edx
  signed int v15; // edi
  signed int v16; // ecx
  signed int v17; // er11
  int v18; // er13
  int v19; // ebp
  int v20; // er12
  int v21; // ebx
  signed int *v22; // rax
  int v23; // er15
  int v24; // er14
  int v25; // er10
  int v26; // er8
  int v27; // esi
  unsigned int v28; // eax
  unsigned int v29; // eax
  int v30; // eax
  unsigned int v31; // eax
  unsigned int v32; // eax
  int v34; // [rsp+0h] [rbp-44h]
  unsigned int v35; // [rsp+4h] [rbp-40h]
  unsigned int v36; // [rsp+8h] [rbp-3Ch]
  unsigned int v37; // [rsp+Ch] [rbp-38h]
  int v38; // [rsp+10h] [rbp-34h]

  v3 = a1 ^ a2;
  v4 = __ROL4__(a1, 4) ^ a3;
  v5 = 234941184;
  v6 = v4 & 0xFC00FC | 0xFF00FF00;
  v35 = v4 & 0xFC00FC | 0xFF00FF00;
  v7 = (v4 >> 8) & 0xFC00FC | 0xFF00FF00;
  v8 = v3 & 0xFC00FC | 0xFF00FF00;
  v9 = v7;
  v10 = (v3 >> 8) & 0xFC00FC;
  v11 = v6;
  v12 = v8;
  v10 |= 0xFF00FF00;
  v36 = v7;
  v37 = v8;
  v38 = v10;
  v13 = v10 - v6;
  v14 = v6;
  v15 = 2063609344;
  v16 = -167733504;
  v17 = -2097117952;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = (signed int *)&unk_EF160;
  v34 = v13;
  v23 = v12 - v11;
  v24 = v9 - v11;
  while ( 1 )
  {
    v22 += 4;
    v25 = v16 & (v24 + v14);
    v26 = v15 & (v23 + v14);
    v27 = v14 + v34;
    v21 ^= v14 & v17;
    v14 += 524296;
    v20 ^= v25;
    v19 ^= v26;
    v18 ^= v5 & v27;
    if ( v22 == (signed int *)"triple-DES inner-CBC" )
      break;
    v17 = *v22;
    v16 = v22[1];
    v15 = v22[2];
    v5 = v22[3];
  }
  v28 = ((16 * v19 & 15360 * ((v37 + 16777472) & 0x40004) ^ v19) >> 8) & 0xF000F0 | (16 * v18 & 15360
                                                                                              * ((v38 + 16777472) & 0x40004) ^ v18) & 0xF000F000 | ((16 * v20 & 15360 * ((v36 + 16777472) & 0x40004) ^ v20) >> 4) & 0xF000F00 | ((v21 ^ 16 * v21 & 15360 * ((v35 + 16777472) & 0x40004)) >> 12) & 0xF000F;
  v29 = 16 * ((v28 ^ (v28 >> 4)) & 0x7030702) ^ (v28 ^ (v28 >> 4)) & 0x7030702 ^ v28;
  v30 = (((v29 ^ (v29 >> 8)) & 0x4E009E) << 8) ^ (v29 ^ (v29 >> 8)) & 0x4E009E ^ v29;
  v31 = ((unsigned __int16)((v30 ^ HIWORD(v30)) & 0xD9D3) << 16) ^ ((unsigned __int16)v30 ^ HIWORD(v30)) & 0xD9D3 ^ v30;
  v32 = 16 * ((v31 ^ (v31 >> 4)) & 0x5040004) ^ (v31 ^ (v31 >> 4)) & 0x5040004 ^ v31;
  return 2 * ((v32 ^ (v32 >> 1)) & 0x4045015) ^ (v32 ^ (v32 >> 1)) & 0x4045015 ^ v32;
}

char *__fastcall sub_632F0(unsigned __int64 a1, __int64 a2)
{
  char *v2; // rax
  char v3; // cl
  unsigned __int64 v4; // r8
  int v5; // ecx
  __int64 v6; // r10
  signed __int64 v7; // r11
  unsigned __int64 v8; // r8
  __int64 v9; // rdx
  char v10; // cl
  char *i; // rax
  char v12; // cl
  __int64 v13; // rdx
  char *result; // rax

  v2 = (char *)&unk_EF120;
  v3 = 7;
  v4 = 0LL;
  while ( 1 )
  {
    ++v2;
    v4 *= 2LL;
    if ( v3 >= 0 )
      v4 |= (a1 >> v3) & 1;
    if ( v2 == (char *)&unk_EF120 + 60 )
      break;
    v3 = *v2;
  }
  LOBYTE(v5) = 1;
  v6 = 0LL;
  v7 = 64424509455LL;
  while ( 1 )
  {
    v8 = v4 << v5;
    v9 = 0LL;
    v10 = 46;
    v4 = v8 & 0xFFFFFFF0FFFFFFFLL | v7 & (v8 >> 28);
    for ( i = (char *)&unk_EF0C0; ; v10 = *i )
    {
      ++i;
      v9 *= 2LL;
      if ( v10 >= 0 )
        v9 |= (v4 >> v10) & 1;
      if ( i == (char *)dword_EF0E0 )
        break;
    }
    *(_DWORD *)(a2 + 4 * v6) = v9;
    v12 = 57;
    v13 = 0LL;
    for ( result = (char *)&unk_EF0A0; ; v12 = *result )
    {
      ++result;
      v13 *= 2LL;
      if ( v12 >= 0 )
        v13 |= (v4 >> v12) & 1;
      if ( result == (char *)&unk_EF0C0 )
        break;
    }
    *(_DWORD *)(a2 + 4 * v6++ + 64) = v13;
    if ( v6 == 16 )
      break;
    v5 = dword_EF0E0[v6];
  }
  return result;
}

unsigned __int64 __fastcall sub_63420(unsigned int *a1)
{
  return ((unsigned __int64)_byteswap_ulong(a1[1]) << 32) | _byteswap_ulong(*a1);
}

unsigned __int64 __fastcall sub_63440(__int64 a1)
{
  unsigned int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  int v6; // ecx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  unsigned int v10; // edi

  v1 = (HIDWORD(a1) ^ ((unsigned int)a1 >> 4)) & 0xF0F0F0F;
  v2 = v1 ^ HIDWORD(a1);
  LODWORD(a1) = 16 * v1 ^ a1;
  v3 = (unsigned __int16)(v1 ^ WORD2(a1) ^ WORD1(a1));
  v4 = v3;
  v5 = v2 ^ v3;
  v6 = a1 ^ (v4 << 16);
  v7 = (v6 ^ (v5 >> 2)) & 0x33333333;
  v8 = v7 ^ v6;
  v9 = v5 ^ 4 * v7;
  v10 = (v8 ^ ((v5 ^ 4 * v7) >> 8)) & 0xFF00FF;
  return (unsigned int)__ROR4__(2 * ((v9 ^ (v10 << 8) ^ ((v8 ^ v10) >> 1)) & 0x55555555) ^ v8 ^ v10, 1) | ((unsigned __int64)(unsigned int)__ROR4__((v9 ^ (v10 << 8) ^ ((v8 ^ v10) >> 1)) & 0x55555555 ^ v9 ^ (v10 << 8), 1) << 32);
}

__int64 __fastcall sub_634C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // r12
  __int64 v6; // rbx
  int v7; // er15
  int *v8; // rax
  __int64 v9; // rbx
  int v10; // er14
  int *v11; // rax
  __int64 v12; // rbx
  int v13; // er15
  int *v14; // rax
  __int64 v15; // rbx
  int v16; // er14
  int *v17; // rax
  __int64 v18; // rbx
  int v19; // er15
  int *v20; // rax
  __int64 v21; // rbx
  int v22; // er14
  int *v23; // rax
  __int64 v24; // rbx
  int v25; // er15
  int *v26; // rax
  __int64 v27; // rbx
  int v28; // er14
  int *v29; // rax
  __int64 v30; // rbx
  int v31; // er15
  int *v32; // rax
  __int64 v33; // rbx
  int v34; // er14
  int v35; // er15
  __int64 v36; // rbx
  int *v37; // rax
  __int64 v38; // rbx
  int v39; // er14
  int *v40; // rax
  __int64 v41; // rbx
  int v42; // er13
  int *v43; // rax
  __int64 v44; // rbx
  int v45; // er14
  __int64 v46; // r13

  v4 = a2;
  v5 = a4;
  v6 = a4 + a3;
  v7 = a1 ^ sub_630F0(SHIDWORD(a1), *(_DWORD *)(a2 + 4 * a3), *(_DWORD *)(a2 + 4 * a3 + 64));
  v8 = (int *)(a2 + 4 * v6);
  v9 = v5 + v6;
  v10 = (unsigned __int64)sub_630F0(v7, *v8, v8[16]) ^ HIDWORD(a1);
  v11 = (int *)(a2 + 4 * v9);
  v12 = v5 + v9;
  v13 = (unsigned __int64)sub_630F0(v10, *v11, v11[16]) ^ v7;
  v14 = (int *)(a2 + 4 * v12);
  v15 = v5 + v12;
  v16 = (unsigned __int64)sub_630F0(v13, *v14, v14[16]) ^ v10;
  v17 = (int *)(a2 + 4 * v15);
  v18 = v5 + v15;
  v19 = (unsigned __int64)sub_630F0(v16, *v17, v17[16]) ^ v13;
  v20 = (int *)(a2 + 4 * v18);
  v21 = v5 + v18;
  v22 = (unsigned __int64)sub_630F0(v19, *v20, v20[16]) ^ v16;
  v23 = (int *)(a2 + 4 * v21);
  v24 = v5 + v21;
  v25 = (unsigned __int64)sub_630F0(v22, *v23, v23[16]) ^ v19;
  v26 = (int *)(a2 + 4 * v24);
  v27 = v5 + v24;
  v28 = (unsigned __int64)sub_630F0(v25, *v26, v26[16]) ^ v22;
  v29 = (int *)(a2 + 4 * v27);
  v30 = v5 + v27;
  v31 = (unsigned __int64)sub_630F0(v28, *v29, v29[16]) ^ v25;
  v32 = (int *)(a2 + 4 * v30);
  v33 = v5 + v30;
  v34 = (unsigned __int64)sub_630F0(v31, *v32, v32[16]) ^ v28;
  v35 = (unsigned __int64)sub_630F0(v34, *(_DWORD *)(v4 + 4 * v33), *(_DWORD *)(v4 + 4 * v33 + 64)) ^ v31;
  v36 = v5 + v33;
  v37 = (int *)(a2 + 4 * v36);
  v38 = v5 + v36;
  v39 = (unsigned __int64)sub_630F0(v35, *v37, v37[16]) ^ v34;
  v40 = (int *)(a2 + 4 * v38);
  v41 = v5 + v38;
  v42 = v35 ^ (unsigned __int64)sub_630F0(v39, *v40, v40[16]);
  v43 = (int *)(a2 + 4 * v41);
  v44 = v5 + v41;
  v45 = (unsigned __int64)sub_630F0(v42, *v43, v43[16]) ^ v39;
  v46 = (unsigned int)sub_630F0(v45, *(_DWORD *)(a2 + 4 * v44), *(_DWORD *)(a2 + 4 * v44 + 64)) ^ v42;
  return (v46 << 32) | v45 ^ (unsigned int)sub_630F0(
                                             v46,
                                             *(_DWORD *)(v4 + 4 * (v5 + v44)),
                                             *(_DWORD *)(v4 + 4 * (v5 + v44) + 64));
}

char *__fastcall sub_63680(__int64 a1, unsigned __int64 *a2)
{
  return sub_632F0(_byteswap_uint64(*a2), a1 - 136);
}

unsigned __int64 __fastcall sub_636A0(__int64 a1, unsigned int *a2, int a3)
{
  __int64 v4; // rbp
  __int64 v5; // r13
  unsigned int *v6; // rbx
  __int64 v7; // r15
  __int64 v8; // r14
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  int v15; // edx
  int v16; // edi
  int v17; // ecx
  unsigned int *v18; // rdi
  int v19; // edx
  unsigned int v20; // ecx
  unsigned int v21; // esi
  unsigned __int64 v22; // rax
  int v23; // er10
  int v24; // er11
  int v25; // edx
  unsigned int *v26; // [rsp+8h] [rbp-50h]
  char v27; // [rsp+10h] [rbp-48h]
  char v28; // [rsp+11h] [rbp-47h]
  char v29; // [rsp+12h] [rbp-46h]
  char v30; // [rsp+13h] [rbp-45h]
  char v31; // [rsp+14h] [rbp-44h]
  char v32; // [rsp+15h] [rbp-43h]
  char v33; // [rsp+16h] [rbp-42h]
  char v34; // [rsp+17h] [rbp-41h]
  unsigned __int64 v35; // [rsp+18h] [rbp-40h]

  v35 = __readfsqword(0x28u);
  if ( a3 > 0 )
  {
    v4 = a1 - 392;
    v5 = a1;
    v6 = a2;
    v7 = a1 - 392 + 128;
    v8 = a1 - 392 + 256;
    v26 = &a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v9 = *(_QWORD *)(v5 - 8);
      v34 = *(_QWORD *)(v5 - 8);
      v33 = BYTE1(v9);
      v32 = BYTE2(v9);
      v31 = BYTE3(v9);
      v30 = BYTE4(v9);
      v29 = BYTE5(v9);
      v28 = BYTE6(v9);
      *(_QWORD *)(v5 - 8) = v9 + 1;
      v27 = HIBYTE(v9);
      v10 = sub_63420((unsigned int *)&v27);
      v11 = sub_63440(v10);
      v12 = sub_634C0(v11, v4, 0LL, 1LL);
      v13 = sub_634C0(v12, v7, 15LL, -1LL);
      v14 = sub_634C0(v13, v8, 0LL, 1LL);
      v15 = __ROL4__(v14, 1);
      v16 = (__ROL4__(HIDWORD(v14), 1) ^ (__ROL4__(v14, 1) >> 1)) & 0x55555555;
      v17 = 2 * v16;
      LODWORD(v14) = v16 ^ __ROL4__(HIDWORD(v14), 1);
      v18 = v6;
      v19 = v17 ^ v15;
      v20 = (v19 ^ ((unsigned int)v14 >> 8)) & 0xFF00FF;
      LODWORD(v14) = (v20 << 8) ^ v14;
      v6 += 2;
      v21 = 4 * ((v20 ^ v19 ^ ((unsigned int)v14 >> 2)) & 0x33333333) ^ v14 ^ (unsigned __int16)(4
                                                                                               * ((v20 ^ v19 ^ ((unsigned int)v14 >> 2)) & 0x3333) ^ v14 ^ (((v20 ^ v19 ^ ((unsigned int)v14 >> 2)) & 0x33333333) >> 16) ^ ((v20 ^ v19) >> 16));
      v22 = sub_63420(v18);
      v25 = 16 * v24 ^ v22 ^ v23;
      LODWORD(v22) = v24 ^ v21 ^ HIDWORD(v22);
      *((_BYTE *)v6 - 5) = v25;
      *((_BYTE *)v6 - 6) = BYTE1(v25);
      *((_BYTE *)v6 - 1) = v22;
      *((_BYTE *)v6 - 8) = HIBYTE(v25);
      *((_BYTE *)v6 - 2) = BYTE1(v22);
      *((_BYTE *)v6 - 7) = BYTE2(v25);
      *((_BYTE *)v6 - 3) = (v24 ^ v21 ^ HIDWORD(v22)) >> 16;
      *((_BYTE *)v6 - 4) = BYTE3(v22);
    }
    while ( v6 != v26 );
  }
  sub_BD070(&v27, 8uLL);
  return __readfsqword(0x28u) ^ v35;
}

void __fastcall sub_638B0(__int64 a1)
{
  sub_BD070((void *)(a1 - 136), 0x90uLL);
  sub_2F4D0((void *)(a1 - 136));
}

void __fastcall sub_638D0(__int64 a1)
{
  sub_BD070((void *)(a1 - 392), 0x190uLL);
  sub_2F4D0((void *)(a1 - 392));
}

void __fastcall sub_638F0(__int64 a1)
{
  sub_BD070((void *)(a1 - 392), 0x190uLL);
  sub_2F4D0((void *)(a1 - 392));
}

void __fastcall sub_63910(__int64 a1)
{
  sub_BD070((void *)(a1 - 408), 0x1A0uLL);
  sub_2F4D0((void *)(a1 - 408));
}

char *__fastcall sub_63930(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x90uLL, 0LL);
  v1[17] = a1;
  return (char *)(v1 + 17);
}

char *__fastcall sub_63960(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x190uLL, 0LL);
  v1[49] = a1;
  return (char *)(v1 + 49);
}

char *__fastcall sub_63990(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x190uLL, 0LL);
  v1[49] = a1;
  return (char *)(v1 + 49);
}

char *__fastcall sub_639C0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = sub_2F450(1uLL, 0x1A0uLL, 0LL);
  v1[51] = a1;
  return (char *)(v1 + 51);
}

char *__fastcall sub_639F0(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbp
  __int64 v3; // r12
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  __int64 v6; // rsi
  char *result; // rax

  v2 = a1 - 392;
  v3 = a2;
  v4 = 0LL;
  do
  {
    v5 = *(_QWORD *)(v3 + 8 * v4);
    v6 = v2;
    ++v4;
    v2 += 128LL;
    result = sub_632F0(_byteswap_uint64(v5), v6);
  }
  while ( v4 != 3 );
  return result;
}

char *__fastcall sub_63A30(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbp
  __int64 v3; // r12
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  __int64 v6; // rsi
  char *result; // rax

  v2 = a1 - 392;
  v3 = a2;
  v4 = 0LL;
  do
  {
    v5 = *(_QWORD *)(v3 + 8 * v4);
    v6 = v2;
    ++v4;
    v2 += 128LL;
    result = sub_632F0(_byteswap_uint64(v5), v6);
  }
  while ( v4 != 3 );
  return result;
}

char *__fastcall sub_63A70(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbp
  __int64 v3; // r12
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  __int64 v6; // rsi
  char *result; // rax

  v2 = a1 - 408;
  v3 = a2;
  v4 = 0LL;
  do
  {
    v5 = *(_QWORD *)(v3 + 8 * v4);
    v6 = v2;
    ++v4;
    v2 += 128LL;
    result = sub_632F0(_byteswap_uint64(v5), v6);
  }
  while ( v4 != 3 );
  return result;
}

unsigned __int64 __fastcall sub_63AB0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 result; // rax

  result = _byteswap_uint64(*a2);
  *(_QWORD *)(a1 - 8) = result;
  return result;
}

__int64 __fastcall sub_63AC0(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax

  result = _byteswap_ulong(a2[1]);
  *(_DWORD *)(a1 - 8) = _byteswap_ulong(*a2);
  *(_DWORD *)(a1 - 4) = result;
  return result;
}

__int64 __fastcall sub_63AD0(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax

  result = _byteswap_ulong(a2[1]);
  *(_DWORD *)(a1 - 8) = _byteswap_ulong(*a2);
  *(_DWORD *)(a1 - 4) = result;
  return result;
}

unsigned __int64 __fastcall sub_63AE0(__int64 a1, unsigned int *a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // r8

  result = sub_63440(((unsigned __int64)_byteswap_ulong(a2[1]) << 32) | _byteswap_ulong(*a2));
  *(_DWORD *)(v3 - 24) = result;
  *(_DWORD *)(v3 - 16) = result;
  *(_DWORD *)(v3 - 8) = result;
  *(_DWORD *)(v3 - 20) = HIDWORD(result);
  *(_DWORD *)(v3 - 12) = HIDWORD(result);
  *(_DWORD *)(v3 - 4) = HIDWORD(result);
  return result;
}

void __fastcall sub_63B20(__int64 a1, __int64 a2, int a3)
{
  signed int v3; // er9
  signed int v4; // er11
  unsigned __int32 v5; // ebx
  unsigned __int32 v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // esi
  unsigned int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // esi
  unsigned int v17; // ecx
  unsigned int v18; // eax
  unsigned int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  unsigned int v23; // edx
  unsigned int v24; // eax
  signed int v25; // edi
  int v26; // er12
  int v27; // er13
  int v28; // ebp
  unsigned int v29; // ecx
  unsigned int v30; // eax
  int v31; // ebx
  signed int v32; // ecx
  int v33; // esi
  unsigned int v34; // er14
  int v35; // er8
  int v36; // edx
  signed int *v37; // rax
  unsigned int v38; // ebx
  int v39; // er15
  int v40; // er14
  int v41; // er8
  int v42; // esi
  int v43; // er10
  signed int v44; // er9
  signed int v45; // er11
  signed int v46; // edi
  unsigned int v47; // edx
  int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  unsigned int v51; // eax
  int v52; // eax
  int v53; // er12
  int v54; // er13
  int v55; // ebp
  unsigned int v56; // edx
  unsigned int v57; // eax
  unsigned int v58; // ecx
  unsigned int v59; // eax
  int v60; // ebx
  signed int v61; // ecx
  int v62; // esi
  unsigned int v63; // er14
  int v64; // er8
  int v65; // edx
  signed int *v66; // rax
  unsigned int v67; // ebx
  int v68; // er15
  int v69; // er14
  int v70; // er8
  int v71; // esi
  int v72; // er10
  signed int v73; // er9
  signed int v74; // er11
  signed int v75; // edi
  unsigned int v76; // edx
  int v77; // eax
  unsigned int v78; // eax
  unsigned int v79; // eax
  unsigned int v80; // eax
  int v81; // eax
  int v82; // er12
  int v83; // er13
  int v84; // ebp
  unsigned int v85; // edx
  unsigned int v86; // eax
  unsigned int v87; // ecx
  unsigned int v88; // eax
  int v89; // ebx
  signed int v90; // ecx
  int v91; // esi
  unsigned int v92; // er14
  int v93; // er8
  int v94; // edx
  signed int *v95; // rax
  unsigned int v96; // ebx
  int v97; // er15
  int v98; // er14
  int v99; // er8
  int v100; // esi
  int v101; // er10
  signed int v102; // er9
  signed int v103; // er11
  signed int v104; // edi
  unsigned int v105; // edx
  int v106; // eax
  unsigned int v107; // eax
  unsigned int v108; // eax
  unsigned int v109; // eax
  int v110; // eax
  int v111; // er12
  int v112; // er13
  int v113; // ebp
  unsigned int v114; // edx
  unsigned int v115; // eax
  unsigned int v116; // ecx
  unsigned int v117; // eax
  int v118; // ebx
  signed int v119; // ecx
  int v120; // esi
  unsigned int v121; // er14
  int v122; // er8
  int v123; // edx
  signed int *v124; // rax
  unsigned int v125; // ebx
  int v126; // er15
  int v127; // er14
  int v128; // esi
  int v129; // er10
  signed int v130; // er9
  signed int v131; // er11
  signed int v132; // edi
  unsigned int v133; // edx
  int v134; // eax
  unsigned int v135; // eax
  unsigned int v136; // eax
  unsigned int v137; // eax
  int v138; // eax
  int v139; // er12
  int v140; // er13
  int v141; // ebp
  unsigned int v142; // edx
  unsigned int v143; // eax
  unsigned int v144; // ecx
  unsigned int v145; // eax
  int v146; // ebx
  signed int v147; // ecx
  int v148; // esi
  unsigned int v149; // er14
  int v150; // er8
  int v151; // edx
  signed int *v152; // rax
  unsigned int v153; // ebx
  int v154; // er15
  int v155; // er14
  int v156; // er8
  int v157; // esi
  int v158; // er10
  signed int v159; // er9
  signed int v160; // er11
  signed int v161; // edi
  unsigned int v162; // edx
  int v163; // eax
  unsigned int v164; // eax
  unsigned int v165; // eax
  unsigned int v166; // eax
  int v167; // eax
  int v168; // er12
  int v169; // er13
  int v170; // ebp
  unsigned int v171; // edx
  unsigned int v172; // eax
  unsigned int v173; // ecx
  unsigned int v174; // eax
  int v175; // ebx
  signed int v176; // ecx
  int v177; // esi
  unsigned int v178; // er14
  int v179; // er8
  int v180; // edx
  signed int *v181; // rax
  unsigned int v182; // ebx
  int v183; // er15
  int v184; // er14
  int v185; // esi
  int v186; // er10
  signed int v187; // er9
  signed int v188; // er11
  signed int v189; // edi
  unsigned int v190; // edx
  int v191; // eax
  unsigned int v192; // eax
  unsigned int v193; // eax
  unsigned int v194; // eax
  int v195; // eax
  int v196; // er12
  int v197; // er13
  int v198; // ebp
  unsigned int v199; // edx
  unsigned int v200; // eax
  unsigned int v201; // ecx
  unsigned int v202; // eax
  int v203; // ebx
  signed int v204; // ecx
  int v205; // esi
  unsigned int v206; // er14
  int v207; // er8
  int v208; // edx
  signed int *v209; // rax
  unsigned int v210; // ebx
  int v211; // er15
  int v212; // er14
  int v213; // er8
  int v214; // esi
  int v215; // er10
  signed int v216; // er9
  signed int v217; // er11
  signed int v218; // edi
  unsigned int v219; // edx
  int v220; // eax
  unsigned int v221; // eax
  unsigned int v222; // eax
  unsigned int v223; // eax
  int v224; // eax
  int v225; // er12
  int v226; // er13
  int v227; // ebp
  unsigned int v228; // edx
  unsigned int v229; // eax
  unsigned int v230; // ecx
  unsigned int v231; // eax
  int v232; // ebx
  signed int v233; // ecx
  int v234; // esi
  unsigned int v235; // er14
  int v236; // er8
  int v237; // edx
  signed int *v238; // rax
  unsigned int v239; // ebx
  int v240; // er15
  int v241; // er14
  int v242; // esi
  int v243; // er10
  signed int v244; // er9
  signed int v245; // er11
  signed int v246; // edi
  unsigned int v247; // edx
  int v248; // eax
  unsigned int v249; // eax
  unsigned int v250; // eax
  unsigned int v251; // eax
  int v252; // eax
  int v253; // er12
  int v254; // er13
  int v255; // ebp
  unsigned int v256; // edx
  unsigned int v257; // eax
  unsigned int v258; // ecx
  unsigned int v259; // eax
  int v260; // ebx
  signed int v261; // ecx
  int v262; // esi
  unsigned int v263; // er14
  int v264; // er8
  int v265; // edx
  signed int *v266; // rax
  unsigned int v267; // ebx
  int v268; // er15
  int v269; // er14
  int v270; // er8
  int v271; // esi
  int v272; // er10
  signed int v273; // er9
  signed int v274; // er11
  signed int v275; // edi
  unsigned int v276; // edx
  int v277; // eax
  unsigned int v278; // eax
  unsigned int v279; // eax
  unsigned int v280; // eax
  int v281; // eax
  int v282; // er12
  int v283; // er13
  int v284; // ebp
  unsigned int v285; // edx
  unsigned int v286; // eax
  unsigned int v287; // ecx
  unsigned int v288; // eax
  int v289; // ebx
  signed int v290; // ecx
  int v291; // esi
  unsigned int v292; // er14
  int v293; // er8
  int v294; // edx
  signed int *v295; // rax
  unsigned int v296; // ebx
  int v297; // er15
  int v298; // er14
  int v299; // esi
  int v300; // er10
  signed int v301; // er9
  signed int v302; // er11
  signed int v303; // edi
  unsigned int v304; // edx
  int v305; // eax
  unsigned int v306; // eax
  unsigned int v307; // eax
  unsigned int v308; // eax
  int v309; // eax
  int v310; // er12
  int v311; // er13
  int v312; // ebp
  unsigned int v313; // edx
  unsigned int v314; // eax
  unsigned int v315; // ecx
  unsigned int v316; // eax
  int v317; // ebx
  signed int v318; // ecx
  int v319; // esi
  unsigned int v320; // er14
  int v321; // er8
  int v322; // edx
  signed int *v323; // rax
  unsigned int v324; // ebx
  int v325; // er15
  int v326; // er14
  int v327; // er8
  int v328; // esi
  int v329; // er10
  signed int v330; // er9
  signed int v331; // er11
  signed int v332; // edi
  unsigned int v333; // edx
  int v334; // eax
  unsigned int v335; // eax
  unsigned int v336; // eax
  unsigned int v337; // eax
  int v338; // eax
  int v339; // er12
  int v340; // er13
  int v341; // ebp
  unsigned int v342; // edx
  unsigned int v343; // eax
  unsigned int v344; // ecx
  unsigned int v345; // eax
  int v346; // ebx
  signed int v347; // ecx
  int v348; // esi
  unsigned int v349; // er14
  int v350; // er8
  int v351; // edx
  signed int *v352; // rax
  unsigned int v353; // ebx
  int v354; // er15
  int v355; // er14
  int v356; // esi
  int v357; // er10
  signed int v358; // er9
  signed int v359; // er11
  signed int v360; // edi
  unsigned int v361; // edx
  int v362; // eax
  unsigned int v363; // eax
  unsigned int v364; // eax
  unsigned int v365; // eax
  int v366; // eax
  int v367; // er12
  int v368; // er13
  int v369; // ebp
  unsigned int v370; // edx
  unsigned int v371; // eax
  unsigned int v372; // ecx
  unsigned int v373; // eax
  int v374; // ebx
  signed int v375; // ecx
  int v376; // esi
  unsigned int v377; // er14
  int v378; // er8
  int v379; // edx
  signed int *v380; // rax
  unsigned int v381; // ebx
  int v382; // er15
  int v383; // er14
  int v384; // er8
  int v385; // esi
  int v386; // er10
  signed int v387; // er9
  signed int v388; // er11
  signed int v389; // edi
  unsigned int v390; // edx
  int v391; // eax
  unsigned int v392; // eax
  unsigned int v393; // eax
  unsigned int v394; // eax
  int v395; // eax
  int v396; // er12
  int v397; // er13
  int v398; // ebp
  unsigned int v399; // edx
  unsigned int v400; // eax
  unsigned int v401; // ecx
  unsigned int v402; // eax
  int v403; // ebx
  signed int v404; // ecx
  int v405; // esi
  unsigned int v406; // er14
  int v407; // er8
  int v408; // edx
  signed int *v409; // rax
  unsigned int v410; // ebx
  int v411; // er15
  int v412; // er14
  int v413; // esi
  int v414; // er10
  signed int v415; // er9
  signed int v416; // er11
  signed int v417; // edi
  unsigned int v418; // edx
  int v419; // eax
  unsigned int v420; // eax
  unsigned int v421; // eax
  unsigned int v422; // eax
  int v423; // eax
  int v424; // er12
  int v425; // er13
  int v426; // ebp
  unsigned int v427; // edx
  unsigned int v428; // eax
  unsigned int v429; // ecx
  unsigned int v430; // eax
  int v431; // ebx
  signed int v432; // ecx
  int v433; // esi
  unsigned int v434; // er14
  int v435; // er8
  int v436; // edx
  signed int *v437; // rax
  unsigned int v438; // ebx
  int v439; // er15
  int v440; // er14
  int v441; // er8
  int v442; // esi
  int v443; // er10
  signed int v444; // er9
  signed int v445; // er11
  signed int v446; // edi
  unsigned int v447; // edx
  int v448; // eax
  unsigned int v449; // eax
  unsigned int v450; // eax
  unsigned int v451; // eax
  int v452; // eax
  int v453; // er12
  int v454; // er13
  int v455; // ebp
  unsigned int v456; // edx
  unsigned int v457; // eax
  unsigned int v458; // ecx
  unsigned int v459; // eax
  int v460; // ebx
  signed int v461; // ecx
  int v462; // esi
  unsigned int v463; // er14
  int v464; // er8
  int v465; // edx
  signed int *v466; // rax
  unsigned int v467; // ebx
  int v468; // er15
  int v469; // er14
  int v470; // esi
  int v471; // er10
  unsigned int v472; // edx
  int v473; // eax
  unsigned int v474; // eax
  unsigned int v475; // eax
  unsigned int v476; // eax
  unsigned int v477; // eax
  int v478; // esi
  unsigned int v479; // edx
  int v480; // eax
  int v481; // ecx
  int v482; // esi
  int v483; // ecx
  unsigned int v484; // edx
  int v485; // eax
  int v486; // esi
  int v487; // eax
  int v488; // edx
  int v489; // esi
  int v490; // edx
  int v491; // ecx
  unsigned int v492; // eax
  int v493; // ecx
  int v494; // eax
  int v495; // [rsp+0h] [rbp-74h]
  int v496; // [rsp+0h] [rbp-74h]
  int v497; // [rsp+0h] [rbp-74h]
  int v498; // [rsp+0h] [rbp-74h]
  int v499; // [rsp+0h] [rbp-74h]
  int v500; // [rsp+0h] [rbp-74h]
  int v501; // [rsp+0h] [rbp-74h]
  int v502; // [rsp+0h] [rbp-74h]
  int v503; // [rsp+0h] [rbp-74h]
  __int64 v504; // [rsp+4h] [rbp-70h]
  __int64 v505; // [rsp+Ch] [rbp-68h]
  unsigned __int32 v506; // [rsp+14h] [rbp-60h]
  unsigned __int32 v507; // [rsp+18h] [rbp-5Ch]
  unsigned __int32 v508; // [rsp+1Ch] [rbp-58h]
  unsigned __int32 v509; // [rsp+20h] [rbp-54h]
  int v510; // [rsp+24h] [rbp-50h]
  int v511; // [rsp+24h] [rbp-50h]
  int v512; // [rsp+24h] [rbp-50h]
  int v513; // [rsp+24h] [rbp-50h]
  int v514; // [rsp+24h] [rbp-50h]
  int v515; // [rsp+24h] [rbp-50h]
  int v516; // [rsp+24h] [rbp-50h]
  int v517; // [rsp+24h] [rbp-50h]
  int v518; // [rsp+24h] [rbp-50h]
  int v519; // [rsp+28h] [rbp-4Ch]
  int v520; // [rsp+28h] [rbp-4Ch]
  int v521; // [rsp+28h] [rbp-4Ch]
  int v522; // [rsp+28h] [rbp-4Ch]
  int v523; // [rsp+28h] [rbp-4Ch]
  int v524; // [rsp+28h] [rbp-4Ch]
  int v525; // [rsp+28h] [rbp-4Ch]
  int v526; // [rsp+28h] [rbp-4Ch]
  int v527; // [rsp+2Ch] [rbp-48h]
  int v528; // [rsp+2Ch] [rbp-48h]
  int v529; // [rsp+2Ch] [rbp-48h]
  int v530; // [rsp+2Ch] [rbp-48h]
  int v531; // [rsp+2Ch] [rbp-48h]
  int v532; // [rsp+2Ch] [rbp-48h]
  int v533; // [rsp+2Ch] [rbp-48h]
  int v534; // [rsp+2Ch] [rbp-48h]
  int v535; // [rsp+2Ch] [rbp-48h]
  int v536; // [rsp+2Ch] [rbp-48h]
  int v537; // [rsp+2Ch] [rbp-48h]
  int v538; // [rsp+2Ch] [rbp-48h]
  int v539; // [rsp+2Ch] [rbp-48h]
  int v540; // [rsp+2Ch] [rbp-48h]
  int v541; // [rsp+2Ch] [rbp-48h]
  int v542; // [rsp+2Ch] [rbp-48h]
  unsigned int v543; // [rsp+30h] [rbp-44h]
  unsigned int v544; // [rsp+30h] [rbp-44h]
  unsigned int v545; // [rsp+30h] [rbp-44h]
  unsigned int v546; // [rsp+30h] [rbp-44h]
  unsigned int v547; // [rsp+30h] [rbp-44h]
  unsigned int v548; // [rsp+30h] [rbp-44h]
  unsigned int v549; // [rsp+30h] [rbp-44h]
  unsigned int v550; // [rsp+30h] [rbp-44h]
  unsigned int v551; // [rsp+30h] [rbp-44h]
  unsigned int v552; // [rsp+30h] [rbp-44h]
  unsigned int v553; // [rsp+30h] [rbp-44h]
  unsigned int v554; // [rsp+30h] [rbp-44h]
  unsigned int v555; // [rsp+30h] [rbp-44h]
  unsigned int v556; // [rsp+30h] [rbp-44h]
  unsigned int v557; // [rsp+30h] [rbp-44h]
  unsigned int v558; // [rsp+30h] [rbp-44h]
  unsigned int v559; // [rsp+34h] [rbp-40h]
  unsigned int v560; // [rsp+34h] [rbp-40h]
  unsigned int v561; // [rsp+34h] [rbp-40h]
  unsigned int v562; // [rsp+34h] [rbp-40h]
  unsigned int v563; // [rsp+34h] [rbp-40h]
  unsigned int v564; // [rsp+34h] [rbp-40h]
  unsigned int v565; // [rsp+34h] [rbp-40h]
  unsigned int v566; // [rsp+34h] [rbp-40h]
  unsigned int v567; // [rsp+34h] [rbp-40h]
  unsigned int v568; // [rsp+34h] [rbp-40h]
  unsigned int v569; // [rsp+34h] [rbp-40h]
  unsigned int v570; // [rsp+34h] [rbp-40h]
  unsigned int v571; // [rsp+34h] [rbp-40h]
  unsigned int v572; // [rsp+34h] [rbp-40h]
  unsigned int v573; // [rsp+34h] [rbp-40h]
  unsigned int v574; // [rsp+34h] [rbp-40h]
  unsigned int v575; // [rsp+38h] [rbp-3Ch]
  unsigned int v576; // [rsp+38h] [rbp-3Ch]
  unsigned int v577; // [rsp+38h] [rbp-3Ch]
  unsigned int v578; // [rsp+38h] [rbp-3Ch]
  unsigned int v579; // [rsp+38h] [rbp-3Ch]
  unsigned int v580; // [rsp+38h] [rbp-3Ch]
  unsigned int v581; // [rsp+38h] [rbp-3Ch]
  unsigned int v582; // [rsp+38h] [rbp-3Ch]
  unsigned int v583; // [rsp+38h] [rbp-3Ch]
  unsigned int v584; // [rsp+38h] [rbp-3Ch]
  unsigned int v585; // [rsp+38h] [rbp-3Ch]
  unsigned int v586; // [rsp+38h] [rbp-3Ch]
  unsigned int v587; // [rsp+38h] [rbp-3Ch]
  unsigned int v588; // [rsp+38h] [rbp-3Ch]
  unsigned int v589; // [rsp+38h] [rbp-3Ch]
  unsigned int v590; // [rsp+38h] [rbp-3Ch]
  signed __int64 v591; // [rsp+3Ch] [rbp-38h]

  v504 = a1;
  v505 = a2;
  if ( a3 > 0 )
  {
    v507 = *(_DWORD *)(a1 - 4);
    v506 = *(_DWORD *)(a1 - 8);
    v591 = a2 + 8LL * ((unsigned int)(a3 - 1) >> 3) + 8;
    do
    {
      v3 = 234941184;
      v4 = -2097117952;
      v5 = _byteswap_ulong(*(_DWORD *)v505);
      v508 = v5;
      v6 = _byteswap_ulong(*(_DWORD *)(v505 + 4));
      v509 = v6;
      v7 = (v6 ^ (v5 >> 4)) & 0xF0F0F0F;
      v8 = v7;
      v9 = v6 ^ v7;
      v10 = v5 ^ 16 * v8;
      v11 = (unsigned __int16)(v9 ^ HIWORD(v10));
      v12 = v11 ^ v9;
      v13 = (v11 << 16) ^ v10;
      v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
      v15 = v14 ^ v13;
      v16 = v12 ^ 4 * v14;
      v17 = (v15 ^ ((v12 ^ 4 * v14) >> 8)) & 0xFF00FF;
      v18 = v17;
      v19 = v15 ^ v17;
      v20 = v16 ^ (v18 << 8);
      v21 = (v20 ^ (v19 >> 1)) & 0x55555555;
      v22 = v21 ^ v20;
      v510 = __ROR4__(v19 ^ 2 * v21, 1);
      v519 = __ROR4__(v22, 1);
      v23 = __ROR4__(v22, 1) ^ *(_DWORD *)(v504 - 76);
      v24 = *(_DWORD *)(v504 - 12) ^ __ROL4__(v22, 3);
      v25 = 2063609344;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = v24;
      v30 = (v24 >> 8) & 0xFC00FC | 0xFF00FF00;
      v31 = v29 & 0xFC00FC;
      v32 = -167733504;
      v543 = v30;
      v31 |= 0xFF00FF00;
      v33 = v31;
      v34 = v23 & 0xFC00FC | 0xFF00FF00;
      v35 = v30 - v31;
      v527 = v31;
      v559 = v23 & 0xFC00FC | 0xFF00FF00;
      v575 = (v23 >> 8) & 0xFC00FC | 0xFF00FF00;
      v36 = v31;
      v37 = (signed int *)&unk_EF160;
      v38 = 0;
      v39 = v575 - v33;
      v40 = v34 - v33;
      v495 = v35;
      while ( 1 )
      {
        v37 += 4;
        v41 = v25 & (v40 + v36);
        v42 = v3 & (v39 + v36);
        v43 = v36 + v495;
        v38 ^= v36 & v4;
        v36 += 524296;
        v27 ^= v41;
        v26 ^= v42;
        v28 ^= v32 & v43;
        if ( v37 == (signed int *)"triple-DES inner-CBC" )
          break;
        v4 = *v37;
        v32 = v37[1];
        v25 = v37[2];
        v3 = v37[3];
      }
      v44 = 234941184;
      v45 = -2097117952;
      v46 = 2063609344;
      v47 = ((16 * v28 & 15360 * ((v543 + 16777472) & 0x40004) ^ v28) >> 4) & 0xF000F00 | ((16 * v38 & 15360 * ((v527 + 16777472) & 0x40004) ^ v38) >> 12) & 0xF000F | (v26 ^ 16 * v26 & 15360 * ((v575 + 16777472) & 0x40004)) & 0xF000F000 | ((v27 ^ 16 * v27 & 15360 * ((v559 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v48 = (v47 ^ (v47 >> 4)) & 0x7030702;
      v49 = (16 * v48 ^ v48 ^ v47 ^ ((16 * v48 ^ v48 ^ v47) >> 8)) & 0x4E009E ^ 16 * v48 ^ v48 ^ v47 ^ (((16 * v48 ^ v48 ^ v47 ^ ((16 * v48 ^ v48 ^ v47) >> 8)) & 0x4E009E) << 8);
      v50 = ((unsigned __int16)((v49 ^ HIWORD(v49)) & 0xD9D3) << 16) ^ ((unsigned __int16)v49 ^ HIWORD(v49)) & 0xD9D3 ^ v49;
      v51 = 16 * ((v50 ^ (v50 >> 4)) & 0x5040004) ^ (v50 ^ (v50 >> 4)) & 0x5040004 ^ v50;
      v52 = 2 * ((v51 ^ (v51 >> 1)) & 0x4045015) ^ (v51 ^ (v51 >> 1)) & 0x4045015 ^ v510 ^ v51;
      v53 = 0;
      v511 = v52;
      v54 = 0;
      v55 = 0;
      v56 = v52 ^ *(_DWORD *)(v504 - 80);
      v57 = *(_DWORD *)(v504 - 16) ^ __ROL4__(v52, 4);
      v58 = v57;
      v59 = (v57 >> 8) & 0xFC00FC | 0xFF00FF00;
      v60 = v58 & 0xFC00FC;
      v61 = -167733504;
      v544 = v59;
      v60 |= 0xFF00FF00;
      v62 = v60;
      v63 = v56 & 0xFC00FC | 0xFF00FF00;
      v64 = v59 - v60;
      v528 = v60;
      v560 = v56 & 0xFC00FC | 0xFF00FF00;
      v576 = (v56 >> 8) & 0xFC00FC | 0xFF00FF00;
      v65 = v60;
      v66 = (signed int *)&unk_EF160;
      v67 = 0;
      v68 = v576 - v62;
      v69 = v63 - v62;
      v496 = v64;
      while ( 1 )
      {
        v66 += 4;
        v70 = v46 & (v69 + v65);
        v71 = v44 & (v68 + v65);
        v72 = v65 + v496;
        v67 ^= v65 & v45;
        v65 += 524296;
        v54 ^= v70;
        v53 ^= v71;
        v55 ^= v61 & v72;
        if ( v66 == (signed int *)"triple-DES inner-CBC" )
          break;
        v45 = *v66;
        v61 = v66[1];
        v46 = v66[2];
        v44 = v66[3];
      }
      v73 = 234941184;
      v74 = -2097117952;
      v75 = 2063609344;
      v76 = ((16 * v55 & 15360 * ((v544 + 16777472) & 0x40004) ^ v55) >> 4) & 0xF000F00 | ((16 * v67 & 15360 * ((v528 + 16777472) & 0x40004) ^ v67) >> 12) & 0xF000F | (v53 ^ 16 * v53 & 15360 * ((v576 + 16777472) & 0x40004)) & 0xF000F000 | ((v54 ^ 16 * v54 & 15360 * ((v560 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v77 = (v76 ^ (v76 >> 4)) & 0x7030702;
      v78 = (16 * v77 ^ v77 ^ v76 ^ ((16 * v77 ^ v77 ^ v76) >> 8)) & 0x4E009E ^ 16 * v77 ^ v77 ^ v76 ^ (((16 * v77 ^ v77 ^ v76 ^ ((16 * v77 ^ v77 ^ v76) >> 8)) & 0x4E009E) << 8);
      v79 = ((unsigned __int16)((v78 ^ HIWORD(v78)) & 0xD9D3) << 16) ^ ((unsigned __int16)v78 ^ HIWORD(v78)) & 0xD9D3 ^ v78;
      v80 = 16 * ((v79 ^ (v79 >> 4)) & 0x5040004) ^ (v79 ^ (v79 >> 4)) & 0x5040004 ^ v79;
      v81 = 2 * ((v80 ^ (v80 >> 1)) & 0x4045015) ^ (v80 ^ (v80 >> 1)) & 0x4045015 ^ v519 ^ v80;
      v82 = 0;
      v520 = v81;
      v83 = 0;
      v84 = 0;
      v85 = v81 ^ *(_DWORD *)(v504 - 84);
      v86 = *(_DWORD *)(v504 - 20) ^ __ROL4__(v81, 4);
      v87 = v86;
      v88 = (v86 >> 8) & 0xFC00FC | 0xFF00FF00;
      v89 = v87 & 0xFC00FC;
      v90 = -167733504;
      v545 = v88;
      v89 |= 0xFF00FF00;
      v91 = v89;
      v92 = v85 & 0xFC00FC | 0xFF00FF00;
      v93 = v88 - v89;
      v529 = v89;
      v561 = v85 & 0xFC00FC | 0xFF00FF00;
      v577 = (v85 >> 8) & 0xFC00FC | 0xFF00FF00;
      v94 = v89;
      v95 = (signed int *)&unk_EF160;
      v96 = 0;
      v97 = v577 - v91;
      v98 = v92 - v91;
      v497 = v93;
      while ( 1 )
      {
        v95 += 4;
        v99 = v75 & (v98 + v94);
        v100 = v73 & (v97 + v94);
        v101 = v94 + v497;
        v96 ^= v94 & v74;
        v94 += 524296;
        v83 ^= v99;
        v82 ^= v100;
        v84 ^= v90 & v101;
        if ( v95 == (signed int *)"triple-DES inner-CBC" )
          break;
        v74 = *v95;
        v90 = v95[1];
        v75 = v95[2];
        v73 = v95[3];
      }
      v102 = 234941184;
      v103 = -2097117952;
      v104 = 2063609344;
      v105 = ((16 * v84 & 15360 * ((v545 + 16777472) & 0x40004) ^ v84) >> 4) & 0xF000F00 | ((16 * v96 & 15360 * ((v529 + 16777472) & 0x40004) ^ v96) >> 12) & 0xF000F | (v82 ^ 16 * v82 & 15360 * ((v577 + 16777472) & 0x40004)) & 0xF000F000 | ((v83 ^ 16 * v83 & 15360 * ((v561 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v106 = (v105 ^ (v105 >> 4)) & 0x7030702;
      v107 = (16 * v106 ^ v106 ^ v105 ^ ((16 * v106 ^ v106 ^ v105) >> 8)) & 0x4E009E ^ 16 * v106 ^ v106 ^ v105 ^ (((16 * v106 ^ v106 ^ v105 ^ ((16 * v106 ^ v106 ^ v105) >> 8)) & 0x4E009E) << 8);
      v108 = ((unsigned __int16)((v107 ^ HIWORD(v107)) & 0xD9D3) << 16) ^ ((unsigned __int16)v107 ^ HIWORD(v107)) & 0xD9D3 ^ v107;
      v109 = 16 * ((v108 ^ (v108 >> 4)) & 0x5040004) ^ (v108 ^ (v108 >> 4)) & 0x5040004 ^ v108;
      v110 = 2 * ((v109 ^ (v109 >> 1)) & 0x4045015) ^ (v109 ^ (v109 >> 1)) & 0x4045015 ^ v511 ^ v109;
      v111 = 0;
      v512 = v110;
      v112 = 0;
      v113 = 0;
      v114 = v110 ^ *(_DWORD *)(v504 - 88);
      v115 = *(_DWORD *)(v504 - 24) ^ __ROL4__(v110, 4);
      v116 = v115;
      v117 = (v115 >> 8) & 0xFC00FC | 0xFF00FF00;
      v118 = v116 & 0xFC00FC;
      v119 = -167733504;
      v546 = v117;
      v118 |= 0xFF00FF00;
      v120 = v118;
      v121 = v114 & 0xFC00FC | 0xFF00FF00;
      v122 = v117 - v118;
      v530 = v118;
      v562 = v114 & 0xFC00FC | 0xFF00FF00;
      v578 = (v114 >> 8) & 0xFC00FC | 0xFF00FF00;
      v123 = v118;
      v124 = (signed int *)&unk_EF160;
      v125 = 0;
      v126 = v578 - v120;
      v127 = v121 - v120;
      while ( 1 )
      {
        v124 += 4;
        v128 = v102 & (v126 + v123);
        v125 ^= v123 & v103;
        v129 = v123 + v122;
        v112 ^= v104 & (v127 + v123);
        v123 += 524296;
        v111 ^= v128;
        v113 ^= v119 & v129;
        if ( v124 == (signed int *)"triple-DES inner-CBC" )
          break;
        v103 = *v124;
        v119 = v124[1];
        v104 = v124[2];
        v102 = v124[3];
      }
      v130 = 234941184;
      v131 = -2097117952;
      v132 = 2063609344;
      v133 = ((16 * v113 & 15360 * ((v546 + 16777472) & 0x40004) ^ v113) >> 4) & 0xF000F00 | ((16 * v125 & 15360 * ((v530 + 16777472) & 0x40004) ^ v125) >> 12) & 0xF000F | (v111 ^ 16 * v111 & 15360 * ((v578 + 16777472) & 0x40004)) & 0xF000F000 | ((v112 ^ 16 * v112 & 15360 * ((v562 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v134 = (v133 ^ (v133 >> 4)) & 0x7030702;
      v135 = (16 * v134 ^ v134 ^ v133 ^ ((16 * v134 ^ v134 ^ v133) >> 8)) & 0x4E009E ^ 16 * v134 ^ v134 ^ v133 ^ (((16 * v134 ^ v134 ^ v133 ^ ((16 * v134 ^ v134 ^ v133) >> 8)) & 0x4E009E) << 8);
      v136 = ((unsigned __int16)((v135 ^ HIWORD(v135)) & 0xD9D3) << 16) ^ ((unsigned __int16)v135 ^ HIWORD(v135)) & 0xD9D3 ^ v135;
      v137 = 16 * ((v136 ^ (v136 >> 4)) & 0x5040004) ^ (v136 ^ (v136 >> 4)) & 0x5040004 ^ v136;
      v138 = 2 * ((v137 ^ (v137 >> 1)) & 0x4045015) ^ (v137 ^ (v137 >> 1)) & 0x4045015 ^ v520 ^ v137;
      v139 = 0;
      v521 = v138;
      v140 = 0;
      v141 = 0;
      v142 = v138 ^ *(_DWORD *)(v504 - 92);
      v143 = *(_DWORD *)(v504 - 28) ^ __ROL4__(v138, 4);
      v144 = v143;
      v145 = (v143 >> 8) & 0xFC00FC | 0xFF00FF00;
      v146 = v144 & 0xFC00FC;
      v147 = -167733504;
      v547 = v145;
      v146 |= 0xFF00FF00;
      v148 = v146;
      v149 = v142 & 0xFC00FC | 0xFF00FF00;
      v150 = v145 - v146;
      v531 = v146;
      v563 = v142 & 0xFC00FC | 0xFF00FF00;
      v579 = (v142 >> 8) & 0xFC00FC | 0xFF00FF00;
      v151 = v146;
      v152 = (signed int *)&unk_EF160;
      v153 = 0;
      v154 = v579 - v148;
      v155 = v149 - v148;
      v498 = v150;
      while ( 1 )
      {
        v152 += 4;
        v156 = v132 & (v155 + v151);
        v157 = v130 & (v154 + v151);
        v158 = v151 + v498;
        v153 ^= v151 & v131;
        v151 += 524296;
        v140 ^= v156;
        v139 ^= v157;
        v141 ^= v147 & v158;
        if ( v152 == (signed int *)"triple-DES inner-CBC" )
          break;
        v131 = *v152;
        v147 = v152[1];
        v132 = v152[2];
        v130 = v152[3];
      }
      v159 = 234941184;
      v160 = -2097117952;
      v161 = 2063609344;
      v162 = ((16 * v141 & 15360 * ((v547 + 16777472) & 0x40004) ^ v141) >> 4) & 0xF000F00 | ((16 * v153 & 15360 * ((v531 + 16777472) & 0x40004) ^ v153) >> 12) & 0xF000F | (v139 ^ 16 * v139 & 15360 * ((v579 + 16777472) & 0x40004)) & 0xF000F000 | ((v140 ^ 16 * v140 & 15360 * ((v563 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v163 = (v162 ^ (v162 >> 4)) & 0x7030702;
      v164 = (16 * v163 ^ v163 ^ v162 ^ ((16 * v163 ^ v163 ^ v162) >> 8)) & 0x4E009E ^ 16 * v163 ^ v163 ^ v162 ^ (((16 * v163 ^ v163 ^ v162 ^ ((16 * v163 ^ v163 ^ v162) >> 8)) & 0x4E009E) << 8);
      v165 = ((unsigned __int16)((v164 ^ HIWORD(v164)) & 0xD9D3) << 16) ^ ((unsigned __int16)v164 ^ HIWORD(v164)) & 0xD9D3 ^ v164;
      v166 = 16 * ((v165 ^ (v165 >> 4)) & 0x5040004) ^ (v165 ^ (v165 >> 4)) & 0x5040004 ^ v165;
      v167 = 2 * ((v166 ^ (v166 >> 1)) & 0x4045015) ^ (v166 ^ (v166 >> 1)) & 0x4045015 ^ v512 ^ v166;
      v168 = 0;
      v513 = v167;
      v169 = 0;
      v170 = 0;
      v171 = v167 ^ *(_DWORD *)(v504 - 96);
      v172 = *(_DWORD *)(v504 - 32) ^ __ROL4__(v167, 4);
      v173 = v172;
      v174 = (v172 >> 8) & 0xFC00FC | 0xFF00FF00;
      v175 = v173 & 0xFC00FC;
      v176 = -167733504;
      v548 = v174;
      v175 |= 0xFF00FF00;
      v177 = v175;
      v178 = v171 & 0xFC00FC | 0xFF00FF00;
      v179 = v174 - v175;
      v532 = v175;
      v564 = v171 & 0xFC00FC | 0xFF00FF00;
      v580 = (v171 >> 8) & 0xFC00FC | 0xFF00FF00;
      v180 = v175;
      v181 = (signed int *)&unk_EF160;
      v182 = 0;
      v183 = v580 - v177;
      v184 = v178 - v177;
      while ( 1 )
      {
        v181 += 4;
        v185 = v159 & (v183 + v180);
        v182 ^= v180 & v160;
        v186 = v180 + v179;
        v169 ^= v161 & (v184 + v180);
        v180 += 524296;
        v168 ^= v185;
        v170 ^= v176 & v186;
        if ( v181 == (signed int *)"triple-DES inner-CBC" )
          break;
        v160 = *v181;
        v176 = v181[1];
        v161 = v181[2];
        v159 = v181[3];
      }
      v187 = 234941184;
      v188 = -2097117952;
      v189 = 2063609344;
      v190 = ((16 * v170 & 15360 * ((v548 + 16777472) & 0x40004) ^ v170) >> 4) & 0xF000F00 | ((16 * v182 & 15360 * ((v532 + 16777472) & 0x40004) ^ v182) >> 12) & 0xF000F | (v168 ^ 16 * v168 & 15360 * ((v580 + 16777472) & 0x40004)) & 0xF000F000 | ((v169 ^ 16 * v169 & 15360 * ((v564 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v191 = (v190 ^ (v190 >> 4)) & 0x7030702;
      v192 = (16 * v191 ^ v191 ^ v190 ^ ((16 * v191 ^ v191 ^ v190) >> 8)) & 0x4E009E ^ 16 * v191 ^ v191 ^ v190 ^ (((16 * v191 ^ v191 ^ v190 ^ ((16 * v191 ^ v191 ^ v190) >> 8)) & 0x4E009E) << 8);
      v193 = ((unsigned __int16)((v192 ^ HIWORD(v192)) & 0xD9D3) << 16) ^ ((unsigned __int16)v192 ^ HIWORD(v192)) & 0xD9D3 ^ v192;
      v194 = 16 * ((v193 ^ (v193 >> 4)) & 0x5040004) ^ (v193 ^ (v193 >> 4)) & 0x5040004 ^ v193;
      v195 = 2 * ((v194 ^ (v194 >> 1)) & 0x4045015) ^ (v194 ^ (v194 >> 1)) & 0x4045015 ^ v521 ^ v194;
      v196 = 0;
      v522 = v195;
      v197 = 0;
      v198 = 0;
      v199 = v195 ^ *(_DWORD *)(v504 - 100);
      v200 = *(_DWORD *)(v504 - 36) ^ __ROL4__(v195, 4);
      v201 = v200;
      v202 = (v200 >> 8) & 0xFC00FC | 0xFF00FF00;
      v203 = v201 & 0xFC00FC;
      v204 = -167733504;
      v549 = v202;
      v203 |= 0xFF00FF00;
      v205 = v203;
      v206 = v199 & 0xFC00FC | 0xFF00FF00;
      v207 = v202 - v203;
      v533 = v203;
      v565 = v199 & 0xFC00FC | 0xFF00FF00;
      v581 = (v199 >> 8) & 0xFC00FC | 0xFF00FF00;
      v208 = v203;
      v209 = (signed int *)&unk_EF160;
      v210 = 0;
      v211 = v581 - v205;
      v212 = v206 - v205;
      v499 = v207;
      while ( 1 )
      {
        v209 += 4;
        v213 = v189 & (v212 + v208);
        v214 = v187 & (v211 + v208);
        v215 = v208 + v499;
        v210 ^= v208 & v188;
        v208 += 524296;
        v197 ^= v213;
        v196 ^= v214;
        v198 ^= v204 & v215;
        if ( v209 == (signed int *)"triple-DES inner-CBC" )
          break;
        v188 = *v209;
        v204 = v209[1];
        v189 = v209[2];
        v187 = v209[3];
      }
      v216 = 234941184;
      v217 = -2097117952;
      v218 = 2063609344;
      v219 = ((16 * v198 & 15360 * ((v549 + 16777472) & 0x40004) ^ v198) >> 4) & 0xF000F00 | ((16 * v210 & 15360 * ((v533 + 16777472) & 0x40004) ^ v210) >> 12) & 0xF000F | (v196 ^ 16 * v196 & 15360 * ((v581 + 16777472) & 0x40004)) & 0xF000F000 | ((v197 ^ 16 * v197 & 15360 * ((v565 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v220 = (v219 ^ (v219 >> 4)) & 0x7030702;
      v221 = (16 * v220 ^ v220 ^ v219 ^ ((16 * v220 ^ v220 ^ v219) >> 8)) & 0x4E009E ^ 16 * v220 ^ v220 ^ v219 ^ (((16 * v220 ^ v220 ^ v219 ^ ((16 * v220 ^ v220 ^ v219) >> 8)) & 0x4E009E) << 8);
      v222 = ((unsigned __int16)((v221 ^ HIWORD(v221)) & 0xD9D3) << 16) ^ ((unsigned __int16)v221 ^ HIWORD(v221)) & 0xD9D3 ^ v221;
      v223 = 16 * ((v222 ^ (v222 >> 4)) & 0x5040004) ^ (v222 ^ (v222 >> 4)) & 0x5040004 ^ v222;
      v224 = 2 * ((v223 ^ (v223 >> 1)) & 0x4045015) ^ (v223 ^ (v223 >> 1)) & 0x4045015 ^ v513 ^ v223;
      v225 = 0;
      v514 = v224;
      v226 = 0;
      v227 = 0;
      v228 = v224 ^ *(_DWORD *)(v504 - 104);
      v229 = *(_DWORD *)(v504 - 40) ^ __ROL4__(v224, 4);
      v230 = v229;
      v231 = (v229 >> 8) & 0xFC00FC | 0xFF00FF00;
      v232 = v230 & 0xFC00FC;
      v233 = -167733504;
      v550 = v231;
      v232 |= 0xFF00FF00;
      v234 = v232;
      v235 = v228 & 0xFC00FC | 0xFF00FF00;
      v236 = v231 - v232;
      v534 = v232;
      v566 = v228 & 0xFC00FC | 0xFF00FF00;
      v582 = (v228 >> 8) & 0xFC00FC | 0xFF00FF00;
      v237 = v232;
      v238 = (signed int *)&unk_EF160;
      v239 = 0;
      v240 = v582 - v234;
      v241 = v235 - v234;
      while ( 1 )
      {
        v238 += 4;
        v242 = v216 & (v240 + v237);
        v239 ^= v237 & v217;
        v243 = v237 + v236;
        v226 ^= v218 & (v241 + v237);
        v237 += 524296;
        v225 ^= v242;
        v227 ^= v233 & v243;
        if ( v238 == (signed int *)"triple-DES inner-CBC" )
          break;
        v217 = *v238;
        v233 = v238[1];
        v218 = v238[2];
        v216 = v238[3];
      }
      v244 = 234941184;
      v245 = -2097117952;
      v246 = 2063609344;
      v247 = ((16 * v227 & 15360 * ((v550 + 16777472) & 0x40004) ^ v227) >> 4) & 0xF000F00 | ((16 * v239 & 15360 * ((v534 + 16777472) & 0x40004) ^ v239) >> 12) & 0xF000F | (v225 ^ 16 * v225 & 15360 * ((v582 + 16777472) & 0x40004)) & 0xF000F000 | ((v226 ^ 16 * v226 & 15360 * ((v566 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v248 = (v247 ^ (v247 >> 4)) & 0x7030702;
      v249 = (16 * v248 ^ v248 ^ v247 ^ ((16 * v248 ^ v248 ^ v247) >> 8)) & 0x4E009E ^ 16 * v248 ^ v248 ^ v247 ^ (((16 * v248 ^ v248 ^ v247 ^ ((16 * v248 ^ v248 ^ v247) >> 8)) & 0x4E009E) << 8);
      v250 = ((unsigned __int16)((v249 ^ HIWORD(v249)) & 0xD9D3) << 16) ^ ((unsigned __int16)v249 ^ HIWORD(v249)) & 0xD9D3 ^ v249;
      v251 = 16 * ((v250 ^ (v250 >> 4)) & 0x5040004) ^ (v250 ^ (v250 >> 4)) & 0x5040004 ^ v250;
      v252 = 2 * ((v251 ^ (v251 >> 1)) & 0x4045015) ^ (v251 ^ (v251 >> 1)) & 0x4045015 ^ v522 ^ v251;
      v253 = 0;
      v523 = v252;
      v254 = 0;
      v255 = 0;
      v256 = v252 ^ *(_DWORD *)(v504 - 108);
      v257 = *(_DWORD *)(v504 - 44) ^ __ROL4__(v252, 4);
      v258 = v257;
      v259 = (v257 >> 8) & 0xFC00FC | 0xFF00FF00;
      v260 = v258 & 0xFC00FC;
      v261 = -167733504;
      v551 = v259;
      v260 |= 0xFF00FF00;
      v262 = v260;
      v263 = v256 & 0xFC00FC | 0xFF00FF00;
      v264 = v259 - v260;
      v535 = v260;
      v567 = v256 & 0xFC00FC | 0xFF00FF00;
      v583 = (v256 >> 8) & 0xFC00FC | 0xFF00FF00;
      v265 = v260;
      v266 = (signed int *)&unk_EF160;
      v267 = 0;
      v268 = v583 - v262;
      v269 = v263 - v262;
      v500 = v264;
      while ( 1 )
      {
        v266 += 4;
        v270 = v246 & (v269 + v265);
        v271 = v244 & (v268 + v265);
        v272 = v265 + v500;
        v267 ^= v265 & v245;
        v265 += 524296;
        v254 ^= v270;
        v253 ^= v271;
        v255 ^= v261 & v272;
        if ( v266 == (signed int *)"triple-DES inner-CBC" )
          break;
        v245 = *v266;
        v261 = v266[1];
        v246 = v266[2];
        v244 = v266[3];
      }
      v273 = 234941184;
      v274 = -2097117952;
      v275 = 2063609344;
      v276 = ((16 * v255 & 15360 * ((v551 + 16777472) & 0x40004) ^ v255) >> 4) & 0xF000F00 | ((16 * v267 & 15360 * ((v535 + 16777472) & 0x40004) ^ v267) >> 12) & 0xF000F | (v253 ^ 16 * v253 & 15360 * ((v583 + 16777472) & 0x40004)) & 0xF000F000 | ((v254 ^ 16 * v254 & 15360 * ((v567 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v277 = (v276 ^ (v276 >> 4)) & 0x7030702;
      v278 = (16 * v277 ^ v277 ^ v276 ^ ((16 * v277 ^ v277 ^ v276) >> 8)) & 0x4E009E ^ 16 * v277 ^ v277 ^ v276 ^ (((16 * v277 ^ v277 ^ v276 ^ ((16 * v277 ^ v277 ^ v276) >> 8)) & 0x4E009E) << 8);
      v279 = ((unsigned __int16)((v278 ^ HIWORD(v278)) & 0xD9D3) << 16) ^ ((unsigned __int16)v278 ^ HIWORD(v278)) & 0xD9D3 ^ v278;
      v280 = 16 * ((v279 ^ (v279 >> 4)) & 0x5040004) ^ (v279 ^ (v279 >> 4)) & 0x5040004 ^ v279;
      v281 = 2 * ((v280 ^ (v280 >> 1)) & 0x4045015) ^ (v280 ^ (v280 >> 1)) & 0x4045015 ^ v514 ^ v280;
      v282 = 0;
      v515 = v281;
      v283 = 0;
      v284 = 0;
      v285 = v281 ^ *(_DWORD *)(v504 - 112);
      v286 = *(_DWORD *)(v504 - 48) ^ __ROL4__(v281, 4);
      v287 = v286;
      v288 = (v286 >> 8) & 0xFC00FC | 0xFF00FF00;
      v289 = v287 & 0xFC00FC;
      v290 = -167733504;
      v552 = v288;
      v289 |= 0xFF00FF00;
      v291 = v289;
      v292 = v285 & 0xFC00FC | 0xFF00FF00;
      v293 = v288 - v289;
      v536 = v289;
      v568 = v285 & 0xFC00FC | 0xFF00FF00;
      v584 = (v285 >> 8) & 0xFC00FC | 0xFF00FF00;
      v294 = v289;
      v295 = (signed int *)&unk_EF160;
      v296 = 0;
      v297 = v584 - v291;
      v298 = v292 - v291;
      while ( 1 )
      {
        v295 += 4;
        v299 = v273 & (v297 + v294);
        v296 ^= v294 & v274;
        v300 = v294 + v293;
        v283 ^= v275 & (v298 + v294);
        v294 += 524296;
        v282 ^= v299;
        v284 ^= v290 & v300;
        if ( v295 == (signed int *)"triple-DES inner-CBC" )
          break;
        v274 = *v295;
        v290 = v295[1];
        v275 = v295[2];
        v273 = v295[3];
      }
      v301 = 234941184;
      v302 = -2097117952;
      v303 = 2063609344;
      v304 = ((16 * v284 & 15360 * ((v552 + 16777472) & 0x40004) ^ v284) >> 4) & 0xF000F00 | ((16 * v296 & 15360 * ((v536 + 16777472) & 0x40004) ^ v296) >> 12) & 0xF000F | (v282 ^ 16 * v282 & 15360 * ((v584 + 16777472) & 0x40004)) & 0xF000F000 | ((v283 ^ 16 * v283 & 15360 * ((v568 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v305 = (v304 ^ (v304 >> 4)) & 0x7030702;
      v306 = (16 * v305 ^ v305 ^ v304 ^ ((16 * v305 ^ v305 ^ v304) >> 8)) & 0x4E009E ^ 16 * v305 ^ v305 ^ v304 ^ (((16 * v305 ^ v305 ^ v304 ^ ((16 * v305 ^ v305 ^ v304) >> 8)) & 0x4E009E) << 8);
      v307 = ((unsigned __int16)((v306 ^ HIWORD(v306)) & 0xD9D3) << 16) ^ ((unsigned __int16)v306 ^ HIWORD(v306)) & 0xD9D3 ^ v306;
      v308 = 16 * ((v307 ^ (v307 >> 4)) & 0x5040004) ^ (v307 ^ (v307 >> 4)) & 0x5040004 ^ v307;
      v309 = 2 * ((v308 ^ (v308 >> 1)) & 0x4045015) ^ (v308 ^ (v308 >> 1)) & 0x4045015 ^ v523 ^ v308;
      v310 = 0;
      v524 = v309;
      v311 = 0;
      v312 = 0;
      v313 = v309 ^ *(_DWORD *)(v504 - 116);
      v314 = *(_DWORD *)(v504 - 52) ^ __ROL4__(v309, 4);
      v315 = v314;
      v316 = (v314 >> 8) & 0xFC00FC | 0xFF00FF00;
      v317 = v315 & 0xFC00FC;
      v318 = -167733504;
      v553 = v316;
      v317 |= 0xFF00FF00;
      v319 = v317;
      v320 = v313 & 0xFC00FC | 0xFF00FF00;
      v321 = v316 - v317;
      v537 = v317;
      v569 = v313 & 0xFC00FC | 0xFF00FF00;
      v585 = (v313 >> 8) & 0xFC00FC | 0xFF00FF00;
      v322 = v317;
      v323 = (signed int *)&unk_EF160;
      v324 = 0;
      v325 = v585 - v319;
      v326 = v320 - v319;
      v501 = v321;
      while ( 1 )
      {
        v323 += 4;
        v327 = v303 & (v326 + v322);
        v328 = v301 & (v325 + v322);
        v329 = v322 + v501;
        v324 ^= v322 & v302;
        v322 += 524296;
        v311 ^= v327;
        v310 ^= v328;
        v312 ^= v318 & v329;
        if ( v323 == (signed int *)"triple-DES inner-CBC" )
          break;
        v302 = *v323;
        v318 = v323[1];
        v303 = v323[2];
        v301 = v323[3];
      }
      v330 = 234941184;
      v331 = -2097117952;
      v332 = 2063609344;
      v333 = ((16 * v312 & 15360 * ((v553 + 16777472) & 0x40004) ^ v312) >> 4) & 0xF000F00 | ((16 * v324 & 15360 * ((v537 + 16777472) & 0x40004) ^ v324) >> 12) & 0xF000F | (v310 ^ 16 * v310 & 15360 * ((v585 + 16777472) & 0x40004)) & 0xF000F000 | ((v311 ^ 16 * v311 & 15360 * ((v569 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v334 = (v333 ^ (v333 >> 4)) & 0x7030702;
      v335 = (16 * v334 ^ v334 ^ v333 ^ ((16 * v334 ^ v334 ^ v333) >> 8)) & 0x4E009E ^ 16 * v334 ^ v334 ^ v333 ^ (((16 * v334 ^ v334 ^ v333 ^ ((16 * v334 ^ v334 ^ v333) >> 8)) & 0x4E009E) << 8);
      v336 = ((unsigned __int16)((v335 ^ HIWORD(v335)) & 0xD9D3) << 16) ^ ((unsigned __int16)v335 ^ HIWORD(v335)) & 0xD9D3 ^ v335;
      v337 = 16 * ((v336 ^ (v336 >> 4)) & 0x5040004) ^ (v336 ^ (v336 >> 4)) & 0x5040004 ^ v336;
      v338 = 2 * ((v337 ^ (v337 >> 1)) & 0x4045015) ^ (v337 ^ (v337 >> 1)) & 0x4045015 ^ v515 ^ v337;
      v339 = 0;
      v516 = v338;
      v340 = 0;
      v341 = 0;
      v342 = v338 ^ *(_DWORD *)(v504 - 120);
      v343 = *(_DWORD *)(v504 - 56) ^ __ROL4__(v338, 4);
      v344 = v343;
      v345 = (v343 >> 8) & 0xFC00FC | 0xFF00FF00;
      v346 = v344 & 0xFC00FC;
      v347 = -167733504;
      v554 = v345;
      v346 |= 0xFF00FF00;
      v348 = v346;
      v349 = v342 & 0xFC00FC | 0xFF00FF00;
      v350 = v345 - v346;
      v538 = v346;
      v570 = v342 & 0xFC00FC | 0xFF00FF00;
      v586 = (v342 >> 8) & 0xFC00FC | 0xFF00FF00;
      v351 = v346;
      v352 = (signed int *)&unk_EF160;
      v353 = 0;
      v354 = v586 - v348;
      v355 = v349 - v348;
      while ( 1 )
      {
        v352 += 4;
        v356 = v330 & (v354 + v351);
        v353 ^= v351 & v331;
        v357 = v351 + v350;
        v340 ^= v332 & (v355 + v351);
        v351 += 524296;
        v339 ^= v356;
        v341 ^= v347 & v357;
        if ( v352 == (signed int *)"triple-DES inner-CBC" )
          break;
        v331 = *v352;
        v347 = v352[1];
        v332 = v352[2];
        v330 = v352[3];
      }
      v358 = 234941184;
      v359 = -2097117952;
      v360 = 2063609344;
      v361 = ((16 * v341 & 15360 * ((v554 + 16777472) & 0x40004) ^ v341) >> 4) & 0xF000F00 | ((16 * v353 & 15360 * ((v538 + 16777472) & 0x40004) ^ v353) >> 12) & 0xF000F | (v339 ^ 16 * v339 & 15360 * ((v586 + 16777472) & 0x40004)) & 0xF000F000 | ((v340 ^ 16 * v340 & 15360 * ((v570 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v362 = (v361 ^ (v361 >> 4)) & 0x7030702;
      v363 = (16 * v362 ^ v362 ^ v361 ^ ((16 * v362 ^ v362 ^ v361) >> 8)) & 0x4E009E ^ 16 * v362 ^ v362 ^ v361 ^ (((16 * v362 ^ v362 ^ v361 ^ ((16 * v362 ^ v362 ^ v361) >> 8)) & 0x4E009E) << 8);
      v364 = ((unsigned __int16)((v363 ^ HIWORD(v363)) & 0xD9D3) << 16) ^ ((unsigned __int16)v363 ^ HIWORD(v363)) & 0xD9D3 ^ v363;
      v365 = 16 * ((v364 ^ (v364 >> 4)) & 0x5040004) ^ (v364 ^ (v364 >> 4)) & 0x5040004 ^ v364;
      v366 = 2 * ((v365 ^ (v365 >> 1)) & 0x4045015) ^ (v365 ^ (v365 >> 1)) & 0x4045015 ^ v524 ^ v365;
      v367 = 0;
      v525 = v366;
      v368 = 0;
      v369 = 0;
      v370 = v366 ^ *(_DWORD *)(v504 - 124);
      v371 = *(_DWORD *)(v504 - 60) ^ __ROL4__(v366, 4);
      v372 = v371;
      v373 = (v371 >> 8) & 0xFC00FC | 0xFF00FF00;
      v374 = v372 & 0xFC00FC;
      v375 = -167733504;
      v555 = v373;
      v374 |= 0xFF00FF00;
      v376 = v374;
      v377 = v370 & 0xFC00FC | 0xFF00FF00;
      v378 = v373 - v374;
      v539 = v374;
      v571 = v370 & 0xFC00FC | 0xFF00FF00;
      v587 = (v370 >> 8) & 0xFC00FC | 0xFF00FF00;
      v379 = v374;
      v380 = (signed int *)&unk_EF160;
      v381 = 0;
      v382 = v587 - v376;
      v383 = v377 - v376;
      v502 = v378;
      while ( 1 )
      {
        v380 += 4;
        v384 = v360 & (v383 + v379);
        v385 = v358 & (v382 + v379);
        v386 = v379 + v502;
        v381 ^= v379 & v359;
        v379 += 524296;
        v368 ^= v384;
        v367 ^= v385;
        v369 ^= v375 & v386;
        if ( v380 == (signed int *)"triple-DES inner-CBC" )
          break;
        v359 = *v380;
        v375 = v380[1];
        v360 = v380[2];
        v358 = v380[3];
      }
      v387 = 234941184;
      v388 = -2097117952;
      v389 = 2063609344;
      v390 = ((16 * v369 & 15360 * ((v555 + 16777472) & 0x40004) ^ v369) >> 4) & 0xF000F00 | ((16 * v381 & 15360 * ((v539 + 16777472) & 0x40004) ^ v381) >> 12) & 0xF000F | (v367 ^ 16 * v367 & 15360 * ((v587 + 16777472) & 0x40004)) & 0xF000F000 | ((v368 ^ 16 * v368 & 15360 * ((v571 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v391 = (v390 ^ (v390 >> 4)) & 0x7030702;
      v392 = (16 * v391 ^ v391 ^ v390 ^ ((16 * v391 ^ v391 ^ v390) >> 8)) & 0x4E009E ^ 16 * v391 ^ v391 ^ v390 ^ (((16 * v391 ^ v391 ^ v390 ^ ((16 * v391 ^ v391 ^ v390) >> 8)) & 0x4E009E) << 8);
      v393 = ((unsigned __int16)((v392 ^ HIWORD(v392)) & 0xD9D3) << 16) ^ ((unsigned __int16)v392 ^ HIWORD(v392)) & 0xD9D3 ^ v392;
      v394 = 16 * ((v393 ^ (v393 >> 4)) & 0x5040004) ^ (v393 ^ (v393 >> 4)) & 0x5040004 ^ v393;
      v395 = 2 * ((v394 ^ (v394 >> 1)) & 0x4045015) ^ (v394 ^ (v394 >> 1)) & 0x4045015 ^ v516 ^ v394;
      v396 = 0;
      v517 = v395;
      v397 = 0;
      v398 = 0;
      v399 = v395 ^ *(_DWORD *)(v504 - 128);
      v400 = *(_DWORD *)(v504 - 64) ^ __ROL4__(v395, 4);
      v401 = v400;
      v402 = (v400 >> 8) & 0xFC00FC | 0xFF00FF00;
      v403 = v401 & 0xFC00FC;
      v404 = -167733504;
      v556 = v402;
      v403 |= 0xFF00FF00;
      v405 = v403;
      v406 = v399 & 0xFC00FC | 0xFF00FF00;
      v407 = v402 - v403;
      v540 = v403;
      v572 = v399 & 0xFC00FC | 0xFF00FF00;
      v588 = (v399 >> 8) & 0xFC00FC | 0xFF00FF00;
      v408 = v403;
      v409 = (signed int *)&unk_EF160;
      v410 = 0;
      v411 = v588 - v405;
      v412 = v406 - v405;
      while ( 1 )
      {
        v409 += 4;
        v413 = v387 & (v411 + v408);
        v410 ^= v408 & v388;
        v414 = v408 + v407;
        v397 ^= v389 & (v412 + v408);
        v408 += 524296;
        v396 ^= v413;
        v398 ^= v404 & v414;
        if ( v409 == (signed int *)"triple-DES inner-CBC" )
          break;
        v388 = *v409;
        v404 = v409[1];
        v389 = v409[2];
        v387 = v409[3];
      }
      v415 = 234941184;
      v416 = -2097117952;
      v417 = 2063609344;
      v418 = ((16 * v398 & 15360 * ((v556 + 16777472) & 0x40004) ^ v398) >> 4) & 0xF000F00 | ((16 * v410 & 15360 * ((v540 + 16777472) & 0x40004) ^ v410) >> 12) & 0xF000F | (v396 ^ 16 * v396 & 15360 * ((v588 + 16777472) & 0x40004)) & 0xF000F000 | ((v397 ^ 16 * v397 & 15360 * ((v572 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v419 = (v418 ^ (v418 >> 4)) & 0x7030702;
      v420 = (16 * v419 ^ v419 ^ v418 ^ ((16 * v419 ^ v419 ^ v418) >> 8)) & 0x4E009E ^ 16 * v419 ^ v419 ^ v418 ^ (((16 * v419 ^ v419 ^ v418 ^ ((16 * v419 ^ v419 ^ v418) >> 8)) & 0x4E009E) << 8);
      v421 = ((unsigned __int16)((v420 ^ HIWORD(v420)) & 0xD9D3) << 16) ^ ((unsigned __int16)v420 ^ HIWORD(v420)) & 0xD9D3 ^ v420;
      v422 = 16 * ((v421 ^ (v421 >> 4)) & 0x5040004) ^ (v421 ^ (v421 >> 4)) & 0x5040004 ^ v421;
      v423 = 2 * ((v422 ^ (v422 >> 1)) & 0x4045015) ^ (v422 ^ (v422 >> 1)) & 0x4045015 ^ v525 ^ v422;
      v424 = 0;
      v526 = v423;
      v425 = 0;
      v426 = 0;
      v427 = v423 ^ *(_DWORD *)(v504 - 132);
      v428 = *(_DWORD *)(v504 - 68) ^ __ROL4__(v423, 4);
      v429 = v428;
      v430 = (v428 >> 8) & 0xFC00FC | 0xFF00FF00;
      v431 = v429 & 0xFC00FC;
      v432 = -167733504;
      v557 = v430;
      v431 |= 0xFF00FF00;
      v433 = v431;
      v434 = v427 & 0xFC00FC | 0xFF00FF00;
      v435 = v430 - v431;
      v541 = v431;
      v573 = v427 & 0xFC00FC | 0xFF00FF00;
      v589 = (v427 >> 8) & 0xFC00FC | 0xFF00FF00;
      v436 = v431;
      v437 = (signed int *)&unk_EF160;
      v438 = 0;
      v439 = v589 - v433;
      v440 = v434 - v433;
      v503 = v435;
      while ( 1 )
      {
        v437 += 4;
        v441 = v417 & (v440 + v436);
        v442 = v415 & (v439 + v436);
        v443 = v436 + v503;
        v438 ^= v436 & v416;
        v436 += 524296;
        v425 ^= v441;
        v424 ^= v442;
        v426 ^= v432 & v443;
        if ( v437 == (signed int *)"triple-DES inner-CBC" )
          break;
        v416 = *v437;
        v432 = v437[1];
        v417 = v437[2];
        v415 = v437[3];
      }
      v444 = 234941184;
      v445 = -2097117952;
      v446 = 2063609344;
      v447 = ((16 * v426 & 15360 * ((v557 + 16777472) & 0x40004) ^ v426) >> 4) & 0xF000F00 | ((16 * v438 & 15360 * ((v541 + 16777472) & 0x40004) ^ v438) >> 12) & 0xF000F | (v424 ^ 16 * v424 & 15360 * ((v589 + 16777472) & 0x40004)) & 0xF000F000 | ((v425 ^ 16 * v425 & 15360 * ((v573 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v448 = (v447 ^ (v447 >> 4)) & 0x7030702;
      v449 = (16 * v448 ^ v448 ^ v447 ^ ((16 * v448 ^ v448 ^ v447) >> 8)) & 0x4E009E ^ 16 * v448 ^ v448 ^ v447 ^ (((16 * v448 ^ v448 ^ v447 ^ ((16 * v448 ^ v448 ^ v447) >> 8)) & 0x4E009E) << 8);
      v450 = ((unsigned __int16)((v449 ^ HIWORD(v449)) & 0xD9D3) << 16) ^ ((unsigned __int16)v449 ^ HIWORD(v449)) & 0xD9D3 ^ v449;
      v451 = 16 * ((v450 ^ (v450 >> 4)) & 0x5040004) ^ (v450 ^ (v450 >> 4)) & 0x5040004 ^ v450;
      v452 = 2 * ((v451 ^ (v451 >> 1)) & 0x4045015) ^ (v451 ^ (v451 >> 1)) & 0x4045015 ^ v517 ^ v451;
      v453 = 0;
      v518 = v452;
      v454 = 0;
      v455 = 0;
      v456 = v452 ^ *(_DWORD *)(v504 - 136);
      v457 = *(_DWORD *)(v504 - 72) ^ __ROL4__(v452, 4);
      v458 = v457;
      v459 = (v457 >> 8) & 0xFC00FC | 0xFF00FF00;
      v460 = v458 & 0xFC00FC;
      v461 = -167733504;
      v558 = v459;
      v460 |= 0xFF00FF00;
      v462 = v460;
      v463 = v456 & 0xFC00FC | 0xFF00FF00;
      v464 = v459 - v460;
      v542 = v460;
      v574 = v456 & 0xFC00FC | 0xFF00FF00;
      v590 = (v456 >> 8) & 0xFC00FC | 0xFF00FF00;
      v465 = v460;
      v466 = (signed int *)&unk_EF160;
      v467 = 0;
      v468 = v590 - v462;
      v469 = v463 - v462;
      while ( 1 )
      {
        v466 += 4;
        v470 = v444 & (v468 + v465);
        v467 ^= v465 & v445;
        v471 = v465 + v464;
        v454 ^= v446 & (v469 + v465);
        v465 += 524296;
        v453 ^= v470;
        v455 ^= v461 & v471;
        if ( v466 == (signed int *)"triple-DES inner-CBC" )
          break;
        v445 = *v466;
        v461 = v466[1];
        v446 = v466[2];
        v444 = v466[3];
      }
      v472 = ((16 * v455 & 15360 * ((v558 + 16777472) & 0x40004) ^ v455) >> 4) & 0xF000F00 | ((16 * v467 & 15360 * ((v542 + 16777472) & 0x40004) ^ v467) >> 12) & 0xF000F | (v453 ^ 16 * v453 & 15360 * ((v590 + 16777472) & 0x40004)) & 0xF000F000 | ((v454 ^ 16 * v454 & 15360 * ((v574 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v473 = (v472 ^ (v472 >> 4)) & 0x7030702;
      v474 = (16 * v473 ^ v473 ^ v472 ^ ((16 * v473 ^ v473 ^ v472) >> 8)) & 0x4E009E ^ 16 * v473 ^ v473 ^ v472 ^ (((16 * v473 ^ v473 ^ v472 ^ ((16 * v473 ^ v473 ^ v472) >> 8)) & 0x4E009E) << 8);
      v475 = ((unsigned __int16)((v474 ^ HIWORD(v474)) & 0xD9D3) << 16) ^ ((unsigned __int16)v474 ^ HIWORD(v474)) & 0xD9D3 ^ v474;
      v476 = 16 * ((v475 ^ (v475 >> 4)) & 0x5040004) ^ (v475 ^ (v475 >> 4)) & 0x5040004 ^ v475;
      v477 = __ROL4__(2 * ((v476 ^ (v476 >> 1)) & 0x4045015) ^ (v476 ^ (v476 >> 1)) & 0x4045015 ^ v526 ^ v476, 1);
      v478 = (__ROL4__(v518, 1) ^ (v477 >> 1)) & 0x55555555;
      v479 = v478 ^ __ROL4__(v518, 1);
      v480 = 2 * v478 ^ v477;
      v481 = (v480 ^ (v479 >> 8)) & 0xFF00FF;
      v482 = v481;
      v483 = v480 ^ v481;
      v484 = (v482 << 8) ^ v479;
      v485 = (v483 ^ (v484 >> 2)) & 0x33333333;
      v486 = 4 * v485;
      v487 = v483 ^ v485;
      v488 = v486 ^ v484;
      v489 = (unsigned __int16)(v488 ^ HIWORD(v487));
      v490 = v489 ^ v488;
      v491 = v487 ^ (v489 << 16);
      v492 = (v490 ^ ((v487 ^ (unsigned int)(v489 << 16)) >> 4)) & 0xF0F0F0F;
      v493 = 16 * v492 ^ v506 ^ v491;
      v494 = v507 ^ v490 ^ v492;
      *(_BYTE *)(v505 + 3) = v493;
      *(_BYTE *)(v505 + 2) = BYTE1(v493);
      *(_BYTE *)(v505 + 7) = v494;
      *(_BYTE *)(v505 + 6) = BYTE1(v494);
      *(_BYTE *)(v505 + 1) = BYTE2(v493);
      *(_BYTE *)v505 = HIBYTE(v493);
      *(_BYTE *)(v505 + 4) = HIBYTE(v494);
      *(_BYTE *)(v505 + 5) = BYTE2(v494);
      *(_DWORD *)(v504 - 8) = v508;
      v506 = v508;
      *(_DWORD *)(v504 - 4) = v509;
      v507 = v509;
      v505 += 8LL;
    }
    while ( v505 != v591 );
  }
}

void __fastcall sub_65CD0(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  signed int v5; // er9
  signed int v6; // er11
  unsigned __int32 v7; // eax
  unsigned __int32 v8; // ecx
  int v9; // esi
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  unsigned int v13; // ecx
  int v14; // edx
  int v15; // esi
  int v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // edi
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // eax
  int v27; // er12
  signed int v28; // edi
  int v29; // ebp
  int v30; // er13
  unsigned int v31; // ecx
  unsigned int v32; // eax
  int v33; // ebx
  signed int v34; // ecx
  int v35; // esi
  unsigned int v36; // er14
  int v37; // er8
  int v38; // edx
  signed int *v39; // rax
  int v40; // ebx
  int v41; // er15
  int v42; // er14
  int v43; // er8
  int v44; // esi
  int v45; // er10
  signed int v46; // er9
  signed int v47; // er11
  signed int v48; // edi
  unsigned int v49; // eax
  unsigned int v50; // eax
  int v51; // eax
  unsigned int v52; // eax
  unsigned int v53; // eax
  int v54; // eax
  int v55; // er12
  int v56; // ebp
  int v57; // er13
  unsigned int v58; // edx
  unsigned int v59; // eax
  unsigned int v60; // ecx
  unsigned int v61; // eax
  int v62; // ebx
  signed int v63; // ecx
  int v64; // esi
  unsigned int v65; // er14
  int v66; // er8
  int v67; // edx
  signed int *v68; // rax
  int v69; // ebx
  int v70; // er15
  int v71; // er14
  int v72; // er8
  int v73; // esi
  int v74; // er10
  signed int v75; // er9
  signed int v76; // er11
  signed int v77; // edi
  unsigned int v78; // eax
  unsigned int v79; // eax
  int v80; // eax
  unsigned int v81; // eax
  unsigned int v82; // eax
  int v83; // eax
  int v84; // er12
  int v85; // ebp
  int v86; // er13
  unsigned int v87; // edx
  unsigned int v88; // eax
  unsigned int v89; // ecx
  unsigned int v90; // eax
  int v91; // ebx
  signed int v92; // ecx
  int v93; // esi
  unsigned int v94; // er14
  int v95; // er8
  int v96; // edx
  signed int *v97; // rax
  int v98; // ebx
  int v99; // er15
  int v100; // er14
  int v101; // er8
  int v102; // esi
  int v103; // er10
  signed int v104; // er9
  signed int v105; // er11
  signed int v106; // edi
  unsigned int v107; // eax
  unsigned int v108; // eax
  int v109; // eax
  unsigned int v110; // eax
  unsigned int v111; // eax
  int v112; // eax
  int v113; // er12
  int v114; // ebp
  int v115; // er13
  unsigned int v116; // edx
  unsigned int v117; // eax
  unsigned int v118; // ecx
  unsigned int v119; // eax
  int v120; // ebx
  signed int v121; // ecx
  int v122; // esi
  unsigned int v123; // er14
  int v124; // er8
  int v125; // edx
  signed int *v126; // rax
  int v127; // ebx
  int v128; // er15
  int v129; // er14
  int v130; // esi
  int v131; // er10
  signed int v132; // er9
  signed int v133; // er11
  signed int v134; // edi
  unsigned int v135; // eax
  unsigned int v136; // eax
  int v137; // eax
  unsigned int v138; // eax
  unsigned int v139; // eax
  int v140; // eax
  int v141; // er12
  int v142; // ebp
  int v143; // er13
  unsigned int v144; // edx
  unsigned int v145; // eax
  unsigned int v146; // ecx
  unsigned int v147; // eax
  int v148; // ebx
  signed int v149; // ecx
  int v150; // esi
  unsigned int v151; // er14
  int v152; // er8
  int v153; // edx
  signed int *v154; // rax
  int v155; // ebx
  int v156; // er15
  int v157; // er14
  int v158; // er8
  int v159; // esi
  int v160; // er10
  signed int v161; // er9
  signed int v162; // er11
  signed int v163; // edi
  unsigned int v164; // eax
  unsigned int v165; // eax
  int v166; // eax
  unsigned int v167; // eax
  unsigned int v168; // eax
  int v169; // eax
  int v170; // er12
  int v171; // ebp
  int v172; // er13
  unsigned int v173; // edx
  unsigned int v174; // eax
  unsigned int v175; // ecx
  unsigned int v176; // eax
  int v177; // ebx
  signed int v178; // ecx
  int v179; // esi
  unsigned int v180; // er14
  int v181; // er8
  int v182; // edx
  signed int *v183; // rax
  int v184; // ebx
  int v185; // er15
  int v186; // er14
  int v187; // esi
  int v188; // er10
  signed int v189; // er9
  signed int v190; // er11
  signed int v191; // edi
  unsigned int v192; // eax
  unsigned int v193; // eax
  int v194; // eax
  unsigned int v195; // eax
  unsigned int v196; // eax
  int v197; // eax
  int v198; // er12
  int v199; // ebp
  int v200; // er13
  unsigned int v201; // edx
  unsigned int v202; // eax
  unsigned int v203; // ecx
  unsigned int v204; // eax
  int v205; // ebx
  signed int v206; // ecx
  int v207; // esi
  unsigned int v208; // er14
  int v209; // er8
  int v210; // edx
  signed int *v211; // rax
  int v212; // ebx
  int v213; // er15
  int v214; // er14
  int v215; // er8
  int v216; // esi
  int v217; // er10
  signed int v218; // er9
  signed int v219; // er11
  signed int v220; // edi
  unsigned int v221; // eax
  unsigned int v222; // eax
  int v223; // eax
  unsigned int v224; // eax
  unsigned int v225; // eax
  int v226; // eax
  int v227; // er12
  int v228; // ebp
  int v229; // er13
  unsigned int v230; // edx
  unsigned int v231; // eax
  unsigned int v232; // ecx
  unsigned int v233; // eax
  int v234; // ebx
  signed int v235; // ecx
  int v236; // esi
  unsigned int v237; // er14
  int v238; // er8
  int v239; // edx
  signed int *v240; // rax
  int v241; // ebx
  int v242; // er15
  int v243; // er14
  int v244; // esi
  int v245; // er10
  signed int v246; // er9
  signed int v247; // er11
  signed int v248; // edi
  unsigned int v249; // eax
  unsigned int v250; // eax
  int v251; // eax
  unsigned int v252; // eax
  unsigned int v253; // eax
  int v254; // eax
  int v255; // er12
  int v256; // ebp
  int v257; // er13
  unsigned int v258; // edx
  unsigned int v259; // eax
  unsigned int v260; // ecx
  unsigned int v261; // eax
  int v262; // ebx
  signed int v263; // ecx
  int v264; // esi
  unsigned int v265; // er14
  int v266; // er8
  int v267; // edx
  signed int *v268; // rax
  int v269; // ebx
  int v270; // er15
  int v271; // er14
  int v272; // er8
  int v273; // esi
  int v274; // er10
  signed int v275; // er9
  signed int v276; // er11
  signed int v277; // edi
  unsigned int v278; // eax
  unsigned int v279; // eax
  int v280; // eax
  unsigned int v281; // eax
  unsigned int v282; // eax
  int v283; // eax
  int v284; // er12
  int v285; // ebp
  int v286; // er13
  unsigned int v287; // edx
  unsigned int v288; // eax
  unsigned int v289; // ecx
  unsigned int v290; // eax
  int v291; // ebx
  signed int v292; // ecx
  int v293; // esi
  unsigned int v294; // er14
  int v295; // er8
  int v296; // edx
  signed int *v297; // rax
  int v298; // ebx
  int v299; // er15
  int v300; // er14
  int v301; // esi
  int v302; // er10
  signed int v303; // er9
  signed int v304; // er11
  signed int v305; // edi
  unsigned int v306; // eax
  unsigned int v307; // eax
  int v308; // eax
  unsigned int v309; // eax
  unsigned int v310; // eax
  int v311; // eax
  int v312; // er12
  int v313; // ebp
  int v314; // er13
  unsigned int v315; // edx
  unsigned int v316; // eax
  unsigned int v317; // ecx
  unsigned int v318; // eax
  int v319; // ebx
  signed int v320; // ecx
  int v321; // esi
  unsigned int v322; // er14
  int v323; // er8
  int v324; // edx
  signed int *v325; // rax
  int v326; // ebx
  int v327; // er15
  int v328; // er14
  int v329; // er8
  int v330; // esi
  int v331; // er10
  signed int v332; // er9
  signed int v333; // er11
  signed int v334; // edi
  unsigned int v335; // eax
  unsigned int v336; // eax
  int v337; // eax
  unsigned int v338; // eax
  unsigned int v339; // eax
  int v340; // eax
  int v341; // er12
  int v342; // ebp
  int v343; // er13
  unsigned int v344; // edx
  unsigned int v345; // eax
  unsigned int v346; // ecx
  unsigned int v347; // eax
  int v348; // ebx
  signed int v349; // ecx
  int v350; // esi
  unsigned int v351; // er14
  int v352; // er8
  int v353; // edx
  signed int *v354; // rax
  int v355; // ebx
  int v356; // er15
  int v357; // er14
  int v358; // esi
  int v359; // er10
  signed int v360; // er9
  signed int v361; // er11
  signed int v362; // edi
  unsigned int v363; // eax
  unsigned int v364; // eax
  int v365; // eax
  unsigned int v366; // eax
  unsigned int v367; // eax
  int v368; // eax
  int v369; // er12
  int v370; // ebp
  int v371; // er13
  unsigned int v372; // edx
  unsigned int v373; // eax
  unsigned int v374; // ecx
  unsigned int v375; // eax
  int v376; // ebx
  signed int v377; // ecx
  int v378; // esi
  unsigned int v379; // er14
  int v380; // er8
  int v381; // edx
  signed int *v382; // rax
  int v383; // ebx
  int v384; // er15
  int v385; // er14
  int v386; // er8
  int v387; // esi
  int v388; // er10
  signed int v389; // er9
  signed int v390; // er11
  signed int v391; // edi
  unsigned int v392; // eax
  unsigned int v393; // eax
  int v394; // eax
  unsigned int v395; // eax
  unsigned int v396; // eax
  int v397; // eax
  int v398; // er12
  int v399; // ebp
  int v400; // er13
  unsigned int v401; // edx
  unsigned int v402; // eax
  unsigned int v403; // ecx
  unsigned int v404; // eax
  int v405; // ebx
  signed int v406; // ecx
  int v407; // esi
  unsigned int v408; // er14
  int v409; // er8
  int v410; // edx
  signed int *v411; // rax
  int v412; // ebx
  int v413; // er15
  int v414; // er14
  int v415; // esi
  int v416; // er10
  signed int v417; // er9
  signed int v418; // er11
  signed int v419; // edi
  unsigned int v420; // eax
  unsigned int v421; // eax
  int v422; // eax
  unsigned int v423; // eax
  unsigned int v424; // eax
  int v425; // eax
  int v426; // er12
  int v427; // ebp
  int v428; // er13
  unsigned int v429; // edx
  unsigned int v430; // eax
  unsigned int v431; // ecx
  unsigned int v432; // eax
  int v433; // ebx
  signed int v434; // ecx
  int v435; // esi
  unsigned int v436; // er14
  int v437; // er8
  int v438; // edx
  signed int *v439; // rax
  int v440; // ebx
  int v441; // er15
  int v442; // er14
  int v443; // er8
  int v444; // esi
  int v445; // er10
  signed int v446; // er9
  signed int v447; // er11
  signed int v448; // edi
  unsigned int v449; // eax
  unsigned int v450; // eax
  int v451; // eax
  unsigned int v452; // eax
  unsigned int v453; // eax
  int v454; // eax
  int v455; // er12
  int v456; // ebp
  int v457; // er13
  unsigned int v458; // edx
  unsigned int v459; // eax
  unsigned int v460; // ecx
  unsigned int v461; // eax
  int v462; // ebx
  signed int v463; // ecx
  int v464; // esi
  unsigned int v465; // er14
  int v466; // er8
  int v467; // edx
  signed int *v468; // rax
  int v469; // ebx
  int v470; // er15
  int v471; // er14
  int v472; // esi
  int v473; // er10
  __int64 v474; // rdi
  unsigned int v475; // eax
  unsigned int v476; // eax
  int v477; // eax
  unsigned int v478; // eax
  unsigned int v479; // eax
  unsigned int v480; // eax
  int v481; // esi
  unsigned int v482; // ecx
  int v483; // eax
  int v484; // edx
  int v485; // eax
  int v486; // esi
  unsigned int v487; // edx
  int v488; // eax
  int v489; // ecx
  int v490; // edx
  int v491; // ecx
  int v492; // esi
  unsigned int v493; // edx
  int v494; // [rsp+0h] [rbp-64h]
  int v495; // [rsp+0h] [rbp-64h]
  int v496; // [rsp+0h] [rbp-64h]
  int v497; // [rsp+0h] [rbp-64h]
  int v498; // [rsp+0h] [rbp-64h]
  int v499; // [rsp+0h] [rbp-64h]
  int v500; // [rsp+0h] [rbp-64h]
  int v501; // [rsp+0h] [rbp-64h]
  int v502; // [rsp+0h] [rbp-64h]
  __int64 v503; // [rsp+4h] [rbp-60h]
  __int64 v504; // [rsp+Ch] [rbp-58h]
  int v505; // [rsp+14h] [rbp-50h]
  int v506; // [rsp+14h] [rbp-50h]
  int v507; // [rsp+14h] [rbp-50h]
  int v508; // [rsp+14h] [rbp-50h]
  int v509; // [rsp+14h] [rbp-50h]
  int v510; // [rsp+14h] [rbp-50h]
  int v511; // [rsp+14h] [rbp-50h]
  int v512; // [rsp+14h] [rbp-50h]
  int v513; // [rsp+14h] [rbp-50h]
  int v514; // [rsp+18h] [rbp-4Ch]
  int v515; // [rsp+18h] [rbp-4Ch]
  int v516; // [rsp+18h] [rbp-4Ch]
  int v517; // [rsp+18h] [rbp-4Ch]
  int v518; // [rsp+18h] [rbp-4Ch]
  int v519; // [rsp+18h] [rbp-4Ch]
  int v520; // [rsp+18h] [rbp-4Ch]
  int v521; // [rsp+18h] [rbp-4Ch]
  int v522; // [rsp+1Ch] [rbp-48h]
  int v523; // [rsp+1Ch] [rbp-48h]
  int v524; // [rsp+1Ch] [rbp-48h]
  int v525; // [rsp+1Ch] [rbp-48h]
  int v526; // [rsp+1Ch] [rbp-48h]
  int v527; // [rsp+1Ch] [rbp-48h]
  int v528; // [rsp+1Ch] [rbp-48h]
  int v529; // [rsp+1Ch] [rbp-48h]
  int v530; // [rsp+1Ch] [rbp-48h]
  int v531; // [rsp+1Ch] [rbp-48h]
  int v532; // [rsp+1Ch] [rbp-48h]
  int v533; // [rsp+1Ch] [rbp-48h]
  int v534; // [rsp+1Ch] [rbp-48h]
  int v535; // [rsp+1Ch] [rbp-48h]
  int v536; // [rsp+1Ch] [rbp-48h]
  int v537; // [rsp+1Ch] [rbp-48h]
  unsigned int v538; // [rsp+20h] [rbp-44h]
  unsigned int v539; // [rsp+20h] [rbp-44h]
  unsigned int v540; // [rsp+20h] [rbp-44h]
  unsigned int v541; // [rsp+20h] [rbp-44h]
  unsigned int v542; // [rsp+20h] [rbp-44h]
  unsigned int v543; // [rsp+20h] [rbp-44h]
  unsigned int v544; // [rsp+20h] [rbp-44h]
  unsigned int v545; // [rsp+20h] [rbp-44h]
  unsigned int v546; // [rsp+20h] [rbp-44h]
  unsigned int v547; // [rsp+20h] [rbp-44h]
  unsigned int v548; // [rsp+20h] [rbp-44h]
  unsigned int v549; // [rsp+20h] [rbp-44h]
  unsigned int v550; // [rsp+20h] [rbp-44h]
  unsigned int v551; // [rsp+20h] [rbp-44h]
  unsigned int v552; // [rsp+20h] [rbp-44h]
  unsigned int v553; // [rsp+20h] [rbp-44h]
  unsigned int v554; // [rsp+24h] [rbp-40h]
  unsigned int v555; // [rsp+24h] [rbp-40h]
  unsigned int v556; // [rsp+24h] [rbp-40h]
  unsigned int v557; // [rsp+24h] [rbp-40h]
  unsigned int v558; // [rsp+24h] [rbp-40h]
  unsigned int v559; // [rsp+24h] [rbp-40h]
  unsigned int v560; // [rsp+24h] [rbp-40h]
  unsigned int v561; // [rsp+24h] [rbp-40h]
  unsigned int v562; // [rsp+24h] [rbp-40h]
  unsigned int v563; // [rsp+24h] [rbp-40h]
  unsigned int v564; // [rsp+24h] [rbp-40h]
  unsigned int v565; // [rsp+24h] [rbp-40h]
  unsigned int v566; // [rsp+24h] [rbp-40h]
  unsigned int v567; // [rsp+24h] [rbp-40h]
  unsigned int v568; // [rsp+24h] [rbp-40h]
  unsigned int v569; // [rsp+24h] [rbp-40h]
  unsigned int v570; // [rsp+28h] [rbp-3Ch]
  unsigned int v571; // [rsp+28h] [rbp-3Ch]
  unsigned int v572; // [rsp+28h] [rbp-3Ch]
  unsigned int v573; // [rsp+28h] [rbp-3Ch]
  unsigned int v574; // [rsp+28h] [rbp-3Ch]
  unsigned int v575; // [rsp+28h] [rbp-3Ch]
  unsigned int v576; // [rsp+28h] [rbp-3Ch]
  unsigned int v577; // [rsp+28h] [rbp-3Ch]
  unsigned int v578; // [rsp+28h] [rbp-3Ch]
  unsigned int v579; // [rsp+28h] [rbp-3Ch]
  unsigned int v580; // [rsp+28h] [rbp-3Ch]
  unsigned int v581; // [rsp+28h] [rbp-3Ch]
  unsigned int v582; // [rsp+28h] [rbp-3Ch]
  unsigned int v583; // [rsp+28h] [rbp-3Ch]
  unsigned int v584; // [rsp+28h] [rbp-3Ch]
  unsigned int v585; // [rsp+28h] [rbp-3Ch]
  signed __int64 v586; // [rsp+2Ch] [rbp-38h]

  v503 = a1;
  v504 = a2;
  if ( a3 > 0 )
  {
    v3 = *(_DWORD *)(a1 - 8);
    v4 = *(_DWORD *)(a1 - 4);
    v586 = a2 + 8LL * ((unsigned int)(a3 - 1) >> 3) + 8;
    do
    {
      v5 = 234941184;
      v6 = -2097117952;
      v7 = _byteswap_ulong(*(_DWORD *)v504) ^ v3;
      v8 = _byteswap_ulong(*(_DWORD *)(v504 + 4)) ^ v4;
      v9 = (v8 ^ (v7 >> 4)) & 0xF0F0F0F;
      v10 = v9 ^ v8;
      v11 = v7 ^ 16 * v9;
      v12 = (unsigned __int16)(v10 ^ ((v7 ^ 16 * v9) >> 16));
      v13 = v12 ^ v10;
      v14 = v11 ^ (v12 << 16);
      v15 = (v14 ^ (v13 >> 2)) & 0x33333333;
      v16 = v15 ^ v14;
      v17 = v13 ^ 4 * v15;
      v18 = v17;
      v19 = (v16 ^ (v17 >> 8)) & 0xFF00FF;
      v20 = v19;
      v21 = v16 ^ v19;
      v22 = v18 ^ (v20 << 8);
      v23 = (v22 ^ (v21 >> 1)) & 0x55555555;
      v24 = v23 ^ v22;
      v505 = __ROR4__(v21 ^ 2 * v23, 1);
      v514 = __ROR4__(v24, 1);
      v25 = __ROR4__(v24, 1) ^ *(_DWORD *)(v503 - 136);
      v26 = *(_DWORD *)(v503 - 72) ^ __ROL4__(v24, 3);
      v27 = 0;
      v28 = 2063609344;
      v29 = 0;
      v30 = 0;
      v31 = v26;
      v32 = (v26 >> 8) & 0xFC00FC | 0xFF00FF00;
      v33 = v31 & 0xFC00FC;
      v34 = -167733504;
      v538 = v32;
      v33 |= 0xFF00FF00;
      v35 = v33;
      v36 = v25 & 0xFC00FC | 0xFF00FF00;
      v37 = v32 - v33;
      v522 = v33;
      v554 = v25 & 0xFC00FC | 0xFF00FF00;
      v570 = (v25 >> 8) & 0xFC00FC | 0xFF00FF00;
      v38 = v33;
      v39 = (signed int *)&unk_EF160;
      v40 = 0;
      v41 = v570 - v35;
      v42 = v36 - v35;
      v494 = v37;
      while ( 1 )
      {
        v39 += 4;
        v43 = v28 & (v42 + v38);
        v44 = v5 & (v41 + v38);
        v45 = v38 + v494;
        v30 ^= v38 & v6;
        v38 += 524296;
        v40 ^= v43;
        v27 ^= v44;
        v29 ^= v34 & v45;
        if ( v39 == (signed int *)"triple-DES inner-CBC" )
          break;
        v6 = *v39;
        v34 = v39[1];
        v28 = v39[2];
        v5 = v39[3];
      }
      v46 = 234941184;
      v47 = -2097117952;
      v48 = 2063609344;
      v49 = ((16 * v40 & 15360 * ((v554 + 16777472) & 0x40004) ^ v40) >> 8) & 0xF000F0 | (16 * v27 & 15360 * ((v570 + 16777472) & 0x40004) ^ v27) & 0xF000F000 | ((16 * v29 & 15360 * ((v538 + 16777472) & 0x40004) ^ v29) >> 4) & 0xF000F00 | ((v30 ^ 16 * v30 & 15360 * ((v522 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v50 = 16 * ((v49 ^ (v49 >> 4)) & 0x7030702) ^ (v49 ^ (v49 >> 4)) & 0x7030702 ^ v49;
      v51 = (((v50 ^ (v50 >> 8)) & 0x4E009E) << 8) ^ (v50 ^ (v50 >> 8)) & 0x4E009E ^ v50;
      v52 = ((unsigned __int16)((v51 ^ HIWORD(v51)) & 0xD9D3) << 16) ^ ((unsigned __int16)v51 ^ HIWORD(v51)) & 0xD9D3 ^ v51;
      v53 = 16 * ((v52 ^ (v52 >> 4)) & 0x5040004) ^ (v52 ^ (v52 >> 4)) & 0x5040004 ^ v52;
      v54 = 2 * ((v53 ^ (v53 >> 1)) & 0x4045015) ^ (v53 ^ (v53 >> 1)) & 0x4045015 ^ v505 ^ v53;
      v55 = 0;
      v506 = v54;
      v56 = 0;
      v57 = 0;
      v58 = v54 ^ *(_DWORD *)(v503 - 132);
      v59 = *(_DWORD *)(v503 - 68) ^ __ROL4__(v54, 4);
      v60 = v59;
      v61 = (v59 >> 8) & 0xFC00FC | 0xFF00FF00;
      v62 = v60 & 0xFC00FC;
      v63 = -167733504;
      v539 = v61;
      v62 |= 0xFF00FF00;
      v64 = v62;
      v65 = v58 & 0xFC00FC | 0xFF00FF00;
      v66 = v61 - v62;
      v523 = v62;
      v555 = v58 & 0xFC00FC | 0xFF00FF00;
      v571 = (v58 >> 8) & 0xFC00FC | 0xFF00FF00;
      v67 = v62;
      v68 = (signed int *)&unk_EF160;
      v69 = 0;
      v70 = v571 - v64;
      v71 = v65 - v64;
      v495 = v66;
      while ( 1 )
      {
        v68 += 4;
        v72 = v48 & (v71 + v67);
        v73 = v46 & (v70 + v67);
        v74 = v67 + v495;
        v57 ^= v67 & v47;
        v67 += 524296;
        v69 ^= v72;
        v55 ^= v73;
        v56 ^= v63 & v74;
        if ( v68 == (signed int *)"triple-DES inner-CBC" )
          break;
        v47 = *v68;
        v63 = v68[1];
        v48 = v68[2];
        v46 = v68[3];
      }
      v75 = 234941184;
      v76 = -2097117952;
      v77 = 2063609344;
      v78 = ((16 * v69 & 15360 * ((v555 + 16777472) & 0x40004) ^ v69) >> 8) & 0xF000F0 | (16 * v55 & 15360 * ((v571 + 16777472) & 0x40004) ^ v55) & 0xF000F000 | ((16 * v56 & 15360 * ((v539 + 16777472) & 0x40004) ^ v56) >> 4) & 0xF000F00 | ((v57 ^ 16 * v57 & 15360 * ((v523 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v79 = 16 * ((v78 ^ (v78 >> 4)) & 0x7030702) ^ (v78 ^ (v78 >> 4)) & 0x7030702 ^ v78;
      v80 = (((v79 ^ (v79 >> 8)) & 0x4E009E) << 8) ^ (v79 ^ (v79 >> 8)) & 0x4E009E ^ v79;
      v81 = ((unsigned __int16)((v80 ^ HIWORD(v80)) & 0xD9D3) << 16) ^ ((unsigned __int16)v80 ^ HIWORD(v80)) & 0xD9D3 ^ v80;
      v82 = 16 * ((v81 ^ (v81 >> 4)) & 0x5040004) ^ (v81 ^ (v81 >> 4)) & 0x5040004 ^ v81;
      v83 = 2 * ((v82 ^ (v82 >> 1)) & 0x4045015) ^ (v82 ^ (v82 >> 1)) & 0x4045015 ^ v514 ^ v82;
      v84 = 0;
      v515 = v83;
      v85 = 0;
      v86 = 0;
      v87 = v83 ^ *(_DWORD *)(v503 - 128);
      v88 = *(_DWORD *)(v503 - 64) ^ __ROL4__(v83, 4);
      v89 = v88;
      v90 = (v88 >> 8) & 0xFC00FC | 0xFF00FF00;
      v91 = v89 & 0xFC00FC;
      v92 = -167733504;
      v540 = v90;
      v91 |= 0xFF00FF00;
      v93 = v91;
      v94 = v87 & 0xFC00FC | 0xFF00FF00;
      v95 = v90 - v91;
      v524 = v91;
      v556 = v87 & 0xFC00FC | 0xFF00FF00;
      v572 = (v87 >> 8) & 0xFC00FC | 0xFF00FF00;
      v96 = v91;
      v97 = (signed int *)&unk_EF160;
      v98 = 0;
      v99 = v572 - v93;
      v100 = v94 - v93;
      v496 = v95;
      while ( 1 )
      {
        v97 += 4;
        v101 = v77 & (v100 + v96);
        v102 = v75 & (v99 + v96);
        v103 = v96 + v496;
        v86 ^= v96 & v76;
        v96 += 524296;
        v98 ^= v101;
        v84 ^= v102;
        v85 ^= v92 & v103;
        if ( v97 == (signed int *)"triple-DES inner-CBC" )
          break;
        v76 = *v97;
        v92 = v97[1];
        v77 = v97[2];
        v75 = v97[3];
      }
      v104 = 234941184;
      v105 = -2097117952;
      v106 = 2063609344;
      v107 = ((16 * v98 & 15360 * ((v556 + 16777472) & 0x40004) ^ v98) >> 8) & 0xF000F0 | (16 * v84 & 15360 * ((v572 + 16777472) & 0x40004) ^ v84) & 0xF000F000 | ((16 * v85 & 15360 * ((v540 + 16777472) & 0x40004) ^ v85) >> 4) & 0xF000F00 | ((v86 ^ 16 * v86 & 15360 * ((v524 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v108 = 16 * ((v107 ^ (v107 >> 4)) & 0x7030702) ^ (v107 ^ (v107 >> 4)) & 0x7030702 ^ v107;
      v109 = (((v108 ^ (v108 >> 8)) & 0x4E009E) << 8) ^ (v108 ^ (v108 >> 8)) & 0x4E009E ^ v108;
      v110 = ((unsigned __int16)((v109 ^ HIWORD(v109)) & 0xD9D3) << 16) ^ ((unsigned __int16)v109 ^ HIWORD(v109)) & 0xD9D3 ^ v109;
      v111 = 16 * ((v110 ^ (v110 >> 4)) & 0x5040004) ^ (v110 ^ (v110 >> 4)) & 0x5040004 ^ v110;
      v112 = 2 * ((v111 ^ (v111 >> 1)) & 0x4045015) ^ (v111 ^ (v111 >> 1)) & 0x4045015 ^ v506 ^ v111;
      v113 = 0;
      v507 = v112;
      v114 = 0;
      v115 = 0;
      v116 = v112 ^ *(_DWORD *)(v503 - 124);
      v117 = *(_DWORD *)(v503 - 60) ^ __ROL4__(v112, 4);
      v118 = v117;
      v119 = (v117 >> 8) & 0xFC00FC | 0xFF00FF00;
      v120 = v118 & 0xFC00FC;
      v121 = -167733504;
      v541 = v119;
      v120 |= 0xFF00FF00;
      v122 = v120;
      v123 = v116 & 0xFC00FC | 0xFF00FF00;
      v124 = v119 - v120;
      v525 = v120;
      v557 = v116 & 0xFC00FC | 0xFF00FF00;
      v573 = (v116 >> 8) & 0xFC00FC | 0xFF00FF00;
      v125 = v120;
      v126 = (signed int *)&unk_EF160;
      v127 = 0;
      v128 = v573 - v122;
      v129 = v123 - v122;
      while ( 1 )
      {
        v126 += 4;
        v130 = v104 & (v128 + v125);
        v115 ^= v125 & v105;
        v131 = v125 + v124;
        v127 ^= v106 & (v129 + v125);
        v125 += 524296;
        v113 ^= v130;
        v114 ^= v121 & v131;
        if ( v126 == (signed int *)"triple-DES inner-CBC" )
          break;
        v105 = *v126;
        v121 = v126[1];
        v106 = v126[2];
        v104 = v126[3];
      }
      v132 = 234941184;
      v133 = -2097117952;
      v134 = 2063609344;
      v135 = ((16 * v127 & 15360 * ((v557 + 16777472) & 0x40004) ^ v127) >> 8) & 0xF000F0 | (16 * v113 & 15360 * ((v573 + 16777472) & 0x40004) ^ v113) & 0xF000F000 | ((16 * v114 & 15360 * ((v541 + 16777472) & 0x40004) ^ v114) >> 4) & 0xF000F00 | ((v115 ^ 16 * v115 & 15360 * ((v525 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v136 = 16 * ((v135 ^ (v135 >> 4)) & 0x7030702) ^ (v135 ^ (v135 >> 4)) & 0x7030702 ^ v135;
      v137 = (((v136 ^ (v136 >> 8)) & 0x4E009E) << 8) ^ (v136 ^ (v136 >> 8)) & 0x4E009E ^ v136;
      v138 = ((unsigned __int16)((v137 ^ HIWORD(v137)) & 0xD9D3) << 16) ^ ((unsigned __int16)v137 ^ HIWORD(v137)) & 0xD9D3 ^ v137;
      v139 = 16 * ((v138 ^ (v138 >> 4)) & 0x5040004) ^ (v138 ^ (v138 >> 4)) & 0x5040004 ^ v138;
      v140 = 2 * ((v139 ^ (v139 >> 1)) & 0x4045015) ^ (v139 ^ (v139 >> 1)) & 0x4045015 ^ v515 ^ v139;
      v141 = 0;
      v516 = v140;
      v142 = 0;
      v143 = 0;
      v144 = v140 ^ *(_DWORD *)(v503 - 120);
      v145 = *(_DWORD *)(v503 - 56) ^ __ROL4__(v140, 4);
      v146 = v145;
      v147 = (v145 >> 8) & 0xFC00FC | 0xFF00FF00;
      v148 = v146 & 0xFC00FC;
      v149 = -167733504;
      v542 = v147;
      v148 |= 0xFF00FF00;
      v150 = v148;
      v151 = v144 & 0xFC00FC | 0xFF00FF00;
      v152 = v147 - v148;
      v526 = v148;
      v558 = v144 & 0xFC00FC | 0xFF00FF00;
      v574 = (v144 >> 8) & 0xFC00FC | 0xFF00FF00;
      v153 = v148;
      v154 = (signed int *)&unk_EF160;
      v155 = 0;
      v156 = v574 - v150;
      v157 = v151 - v150;
      v497 = v152;
      while ( 1 )
      {
        v154 += 4;
        v158 = v134 & (v157 + v153);
        v159 = v132 & (v156 + v153);
        v160 = v153 + v497;
        v143 ^= v153 & v133;
        v153 += 524296;
        v155 ^= v158;
        v141 ^= v159;
        v142 ^= v149 & v160;
        if ( v154 == (signed int *)"triple-DES inner-CBC" )
          break;
        v133 = *v154;
        v149 = v154[1];
        v134 = v154[2];
        v132 = v154[3];
      }
      v161 = 234941184;
      v162 = -2097117952;
      v163 = 2063609344;
      v164 = ((16 * v155 & 15360 * ((v558 + 16777472) & 0x40004) ^ v155) >> 8) & 0xF000F0 | (16 * v141 & 15360 * ((v574 + 16777472) & 0x40004) ^ v141) & 0xF000F000 | ((16 * v142 & 15360 * ((v542 + 16777472) & 0x40004) ^ v142) >> 4) & 0xF000F00 | ((v143 ^ 16 * v143 & 15360 * ((v526 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v165 = 16 * ((v164 ^ (v164 >> 4)) & 0x7030702) ^ (v164 ^ (v164 >> 4)) & 0x7030702 ^ v164;
      v166 = (((v165 ^ (v165 >> 8)) & 0x4E009E) << 8) ^ (v165 ^ (v165 >> 8)) & 0x4E009E ^ v165;
      v167 = ((unsigned __int16)((v166 ^ HIWORD(v166)) & 0xD9D3) << 16) ^ ((unsigned __int16)v166 ^ HIWORD(v166)) & 0xD9D3 ^ v166;
      v168 = 16 * ((v167 ^ (v167 >> 4)) & 0x5040004) ^ (v167 ^ (v167 >> 4)) & 0x5040004 ^ v167;
      v169 = 2 * ((v168 ^ (v168 >> 1)) & 0x4045015) ^ (v168 ^ (v168 >> 1)) & 0x4045015 ^ v507 ^ v168;
      v170 = 0;
      v508 = v169;
      v171 = 0;
      v172 = 0;
      v173 = v169 ^ *(_DWORD *)(v503 - 116);
      v174 = *(_DWORD *)(v503 - 52) ^ __ROL4__(v169, 4);
      v175 = v174;
      v176 = (v174 >> 8) & 0xFC00FC | 0xFF00FF00;
      v177 = v175 & 0xFC00FC;
      v178 = -167733504;
      v543 = v176;
      v177 |= 0xFF00FF00;
      v179 = v177;
      v180 = v173 & 0xFC00FC | 0xFF00FF00;
      v181 = v176 - v177;
      v527 = v177;
      v559 = v173 & 0xFC00FC | 0xFF00FF00;
      v575 = (v173 >> 8) & 0xFC00FC | 0xFF00FF00;
      v182 = v177;
      v183 = (signed int *)&unk_EF160;
      v184 = 0;
      v185 = v575 - v179;
      v186 = v180 - v179;
      while ( 1 )
      {
        v183 += 4;
        v187 = v161 & (v185 + v182);
        v172 ^= v182 & v162;
        v188 = v182 + v181;
        v184 ^= v163 & (v186 + v182);
        v182 += 524296;
        v170 ^= v187;
        v171 ^= v178 & v188;
        if ( v183 == (signed int *)"triple-DES inner-CBC" )
          break;
        v162 = *v183;
        v178 = v183[1];
        v163 = v183[2];
        v161 = v183[3];
      }
      v189 = 234941184;
      v190 = -2097117952;
      v191 = 2063609344;
      v192 = ((16 * v184 & 15360 * ((v559 + 16777472) & 0x40004) ^ v184) >> 8) & 0xF000F0 | (16 * v170 & 15360 * ((v575 + 16777472) & 0x40004) ^ v170) & 0xF000F000 | ((16 * v171 & 15360 * ((v543 + 16777472) & 0x40004) ^ v171) >> 4) & 0xF000F00 | ((v172 ^ 16 * v172 & 15360 * ((v527 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v193 = 16 * ((v192 ^ (v192 >> 4)) & 0x7030702) ^ (v192 ^ (v192 >> 4)) & 0x7030702 ^ v192;
      v194 = (((v193 ^ (v193 >> 8)) & 0x4E009E) << 8) ^ (v193 ^ (v193 >> 8)) & 0x4E009E ^ v193;
      v195 = ((unsigned __int16)((v194 ^ HIWORD(v194)) & 0xD9D3) << 16) ^ ((unsigned __int16)v194 ^ HIWORD(v194)) & 0xD9D3 ^ v194;
      v196 = 16 * ((v195 ^ (v195 >> 4)) & 0x5040004) ^ (v195 ^ (v195 >> 4)) & 0x5040004 ^ v195;
      v197 = 2 * ((v196 ^ (v196 >> 1)) & 0x4045015) ^ (v196 ^ (v196 >> 1)) & 0x4045015 ^ v516 ^ v196;
      v198 = 0;
      v517 = v197;
      v199 = 0;
      v200 = 0;
      v201 = v197 ^ *(_DWORD *)(v503 - 112);
      v202 = *(_DWORD *)(v503 - 48) ^ __ROL4__(v197, 4);
      v203 = v202;
      v204 = (v202 >> 8) & 0xFC00FC | 0xFF00FF00;
      v205 = v203 & 0xFC00FC;
      v206 = -167733504;
      v544 = v204;
      v205 |= 0xFF00FF00;
      v207 = v205;
      v208 = v201 & 0xFC00FC | 0xFF00FF00;
      v209 = v204 - v205;
      v528 = v205;
      v560 = v201 & 0xFC00FC | 0xFF00FF00;
      v576 = (v201 >> 8) & 0xFC00FC | 0xFF00FF00;
      v210 = v205;
      v211 = (signed int *)&unk_EF160;
      v212 = 0;
      v213 = v576 - v207;
      v214 = v208 - v207;
      v498 = v209;
      while ( 1 )
      {
        v211 += 4;
        v215 = v191 & (v214 + v210);
        v216 = v189 & (v213 + v210);
        v217 = v210 + v498;
        v200 ^= v210 & v190;
        v210 += 524296;
        v212 ^= v215;
        v198 ^= v216;
        v199 ^= v206 & v217;
        if ( v211 == (signed int *)"triple-DES inner-CBC" )
          break;
        v190 = *v211;
        v206 = v211[1];
        v191 = v211[2];
        v189 = v211[3];
      }
      v218 = 234941184;
      v219 = -2097117952;
      v220 = 2063609344;
      v221 = ((16 * v212 & 15360 * ((v560 + 16777472) & 0x40004) ^ v212) >> 8) & 0xF000F0 | (16 * v198 & 15360 * ((v576 + 16777472) & 0x40004) ^ v198) & 0xF000F000 | ((16 * v199 & 15360 * ((v544 + 16777472) & 0x40004) ^ v199) >> 4) & 0xF000F00 | ((v200 ^ 16 * v200 & 15360 * ((v528 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v222 = 16 * ((v221 ^ (v221 >> 4)) & 0x7030702) ^ (v221 ^ (v221 >> 4)) & 0x7030702 ^ v221;
      v223 = (((v222 ^ (v222 >> 8)) & 0x4E009E) << 8) ^ (v222 ^ (v222 >> 8)) & 0x4E009E ^ v222;
      v224 = ((unsigned __int16)((v223 ^ HIWORD(v223)) & 0xD9D3) << 16) ^ ((unsigned __int16)v223 ^ HIWORD(v223)) & 0xD9D3 ^ v223;
      v225 = 16 * ((v224 ^ (v224 >> 4)) & 0x5040004) ^ (v224 ^ (v224 >> 4)) & 0x5040004 ^ v224;
      v226 = 2 * ((v225 ^ (v225 >> 1)) & 0x4045015) ^ (v225 ^ (v225 >> 1)) & 0x4045015 ^ v508 ^ v225;
      v227 = 0;
      v509 = v226;
      v228 = 0;
      v229 = 0;
      v230 = v226 ^ *(_DWORD *)(v503 - 108);
      v231 = *(_DWORD *)(v503 - 44) ^ __ROL4__(v226, 4);
      v232 = v231;
      v233 = (v231 >> 8) & 0xFC00FC | 0xFF00FF00;
      v234 = v232 & 0xFC00FC;
      v235 = -167733504;
      v545 = v233;
      v234 |= 0xFF00FF00;
      v236 = v234;
      v237 = v230 & 0xFC00FC | 0xFF00FF00;
      v238 = v233 - v234;
      v529 = v234;
      v561 = v230 & 0xFC00FC | 0xFF00FF00;
      v577 = (v230 >> 8) & 0xFC00FC | 0xFF00FF00;
      v239 = v234;
      v240 = (signed int *)&unk_EF160;
      v241 = 0;
      v242 = v577 - v236;
      v243 = v237 - v236;
      while ( 1 )
      {
        v240 += 4;
        v244 = v218 & (v242 + v239);
        v229 ^= v239 & v219;
        v245 = v239 + v238;
        v241 ^= v220 & (v243 + v239);
        v239 += 524296;
        v227 ^= v244;
        v228 ^= v235 & v245;
        if ( v240 == (signed int *)"triple-DES inner-CBC" )
          break;
        v219 = *v240;
        v235 = v240[1];
        v220 = v240[2];
        v218 = v240[3];
      }
      v246 = 234941184;
      v247 = -2097117952;
      v248 = 2063609344;
      v249 = ((16 * v241 & 15360 * ((v561 + 16777472) & 0x40004) ^ v241) >> 8) & 0xF000F0 | (16 * v227 & 15360 * ((v577 + 16777472) & 0x40004) ^ v227) & 0xF000F000 | ((16 * v228 & 15360 * ((v545 + 16777472) & 0x40004) ^ v228) >> 4) & 0xF000F00 | ((v229 ^ 16 * v229 & 15360 * ((v529 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v250 = 16 * ((v249 ^ (v249 >> 4)) & 0x7030702) ^ (v249 ^ (v249 >> 4)) & 0x7030702 ^ v249;
      v251 = (((v250 ^ (v250 >> 8)) & 0x4E009E) << 8) ^ (v250 ^ (v250 >> 8)) & 0x4E009E ^ v250;
      v252 = ((unsigned __int16)((v251 ^ HIWORD(v251)) & 0xD9D3) << 16) ^ ((unsigned __int16)v251 ^ HIWORD(v251)) & 0xD9D3 ^ v251;
      v253 = 16 * ((v252 ^ (v252 >> 4)) & 0x5040004) ^ (v252 ^ (v252 >> 4)) & 0x5040004 ^ v252;
      v254 = 2 * ((v253 ^ (v253 >> 1)) & 0x4045015) ^ (v253 ^ (v253 >> 1)) & 0x4045015 ^ v517 ^ v253;
      v255 = 0;
      v518 = v254;
      v256 = 0;
      v257 = 0;
      v258 = v254 ^ *(_DWORD *)(v503 - 104);
      v259 = *(_DWORD *)(v503 - 40) ^ __ROL4__(v254, 4);
      v260 = v259;
      v261 = (v259 >> 8) & 0xFC00FC | 0xFF00FF00;
      v262 = v260 & 0xFC00FC;
      v263 = -167733504;
      v546 = v261;
      v262 |= 0xFF00FF00;
      v264 = v262;
      v265 = v258 & 0xFC00FC | 0xFF00FF00;
      v266 = v261 - v262;
      v530 = v262;
      v562 = v258 & 0xFC00FC | 0xFF00FF00;
      v578 = (v258 >> 8) & 0xFC00FC | 0xFF00FF00;
      v267 = v262;
      v268 = (signed int *)&unk_EF160;
      v269 = 0;
      v270 = v578 - v264;
      v271 = v265 - v264;
      v499 = v266;
      while ( 1 )
      {
        v268 += 4;
        v272 = v248 & (v271 + v267);
        v273 = v246 & (v270 + v267);
        v274 = v267 + v499;
        v257 ^= v267 & v247;
        v267 += 524296;
        v269 ^= v272;
        v255 ^= v273;
        v256 ^= v263 & v274;
        if ( v268 == (signed int *)"triple-DES inner-CBC" )
          break;
        v247 = *v268;
        v263 = v268[1];
        v248 = v268[2];
        v246 = v268[3];
      }
      v275 = 234941184;
      v276 = -2097117952;
      v277 = 2063609344;
      v278 = ((16 * v269 & 15360 * ((v562 + 16777472) & 0x40004) ^ v269) >> 8) & 0xF000F0 | (16 * v255 & 15360 * ((v578 + 16777472) & 0x40004) ^ v255) & 0xF000F000 | ((16 * v256 & 15360 * ((v546 + 16777472) & 0x40004) ^ v256) >> 4) & 0xF000F00 | ((v257 ^ 16 * v257 & 15360 * ((v530 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v279 = 16 * ((v278 ^ (v278 >> 4)) & 0x7030702) ^ (v278 ^ (v278 >> 4)) & 0x7030702 ^ v278;
      v280 = (((v279 ^ (v279 >> 8)) & 0x4E009E) << 8) ^ (v279 ^ (v279 >> 8)) & 0x4E009E ^ v279;
      v281 = ((unsigned __int16)((v280 ^ HIWORD(v280)) & 0xD9D3) << 16) ^ ((unsigned __int16)v280 ^ HIWORD(v280)) & 0xD9D3 ^ v280;
      v282 = 16 * ((v281 ^ (v281 >> 4)) & 0x5040004) ^ (v281 ^ (v281 >> 4)) & 0x5040004 ^ v281;
      v283 = 2 * ((v282 ^ (v282 >> 1)) & 0x4045015) ^ (v282 ^ (v282 >> 1)) & 0x4045015 ^ v509 ^ v282;
      v284 = 0;
      v510 = v283;
      v285 = 0;
      v286 = 0;
      v287 = v283 ^ *(_DWORD *)(v503 - 100);
      v288 = *(_DWORD *)(v503 - 36) ^ __ROL4__(v283, 4);
      v289 = v288;
      v290 = (v288 >> 8) & 0xFC00FC | 0xFF00FF00;
      v291 = v289 & 0xFC00FC;
      v292 = -167733504;
      v547 = v290;
      v291 |= 0xFF00FF00;
      v293 = v291;
      v294 = v287 & 0xFC00FC | 0xFF00FF00;
      v295 = v290 - v291;
      v531 = v291;
      v563 = v287 & 0xFC00FC | 0xFF00FF00;
      v579 = (v287 >> 8) & 0xFC00FC | 0xFF00FF00;
      v296 = v291;
      v297 = (signed int *)&unk_EF160;
      v298 = 0;
      v299 = v579 - v293;
      v300 = v294 - v293;
      while ( 1 )
      {
        v297 += 4;
        v301 = v275 & (v299 + v296);
        v286 ^= v296 & v276;
        v302 = v296 + v295;
        v298 ^= v277 & (v300 + v296);
        v296 += 524296;
        v284 ^= v301;
        v285 ^= v292 & v302;
        if ( v297 == (signed int *)"triple-DES inner-CBC" )
          break;
        v276 = *v297;
        v292 = v297[1];
        v277 = v297[2];
        v275 = v297[3];
      }
      v303 = 234941184;
      v304 = -2097117952;
      v305 = 2063609344;
      v306 = ((16 * v298 & 15360 * ((v563 + 16777472) & 0x40004) ^ v298) >> 8) & 0xF000F0 | (16 * v284 & 15360 * ((v579 + 16777472) & 0x40004) ^ v284) & 0xF000F000 | ((16 * v285 & 15360 * ((v547 + 16777472) & 0x40004) ^ v285) >> 4) & 0xF000F00 | ((v286 ^ 16 * v286 & 15360 * ((v531 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v307 = 16 * ((v306 ^ (v306 >> 4)) & 0x7030702) ^ (v306 ^ (v306 >> 4)) & 0x7030702 ^ v306;
      v308 = (((v307 ^ (v307 >> 8)) & 0x4E009E) << 8) ^ (v307 ^ (v307 >> 8)) & 0x4E009E ^ v307;
      v309 = ((unsigned __int16)((v308 ^ HIWORD(v308)) & 0xD9D3) << 16) ^ ((unsigned __int16)v308 ^ HIWORD(v308)) & 0xD9D3 ^ v308;
      v310 = 16 * ((v309 ^ (v309 >> 4)) & 0x5040004) ^ (v309 ^ (v309 >> 4)) & 0x5040004 ^ v309;
      v311 = 2 * ((v310 ^ (v310 >> 1)) & 0x4045015) ^ (v310 ^ (v310 >> 1)) & 0x4045015 ^ v518 ^ v310;
      v312 = 0;
      v519 = v311;
      v313 = 0;
      v314 = 0;
      v315 = v311 ^ *(_DWORD *)(v503 - 96);
      v316 = *(_DWORD *)(v503 - 32) ^ __ROL4__(v311, 4);
      v317 = v316;
      v318 = (v316 >> 8) & 0xFC00FC | 0xFF00FF00;
      v319 = v317 & 0xFC00FC;
      v320 = -167733504;
      v548 = v318;
      v319 |= 0xFF00FF00;
      v321 = v319;
      v322 = v315 & 0xFC00FC | 0xFF00FF00;
      v323 = v318 - v319;
      v532 = v319;
      v564 = v315 & 0xFC00FC | 0xFF00FF00;
      v580 = (v315 >> 8) & 0xFC00FC | 0xFF00FF00;
      v324 = v319;
      v325 = (signed int *)&unk_EF160;
      v326 = 0;
      v327 = v580 - v321;
      v328 = v322 - v321;
      v500 = v323;
      while ( 1 )
      {
        v325 += 4;
        v329 = v305 & (v328 + v324);
        v330 = v303 & (v327 + v324);
        v331 = v324 + v500;
        v314 ^= v324 & v304;
        v324 += 524296;
        v326 ^= v329;
        v312 ^= v330;
        v313 ^= v320 & v331;
        if ( v325 == (signed int *)"triple-DES inner-CBC" )
          break;
        v304 = *v325;
        v320 = v325[1];
        v305 = v325[2];
        v303 = v325[3];
      }
      v332 = 234941184;
      v333 = -2097117952;
      v334 = 2063609344;
      v335 = ((16 * v326 & 15360 * ((v564 + 16777472) & 0x40004) ^ v326) >> 8) & 0xF000F0 | (16 * v312 & 15360 * ((v580 + 16777472) & 0x40004) ^ v312) & 0xF000F000 | ((16 * v313 & 15360 * ((v548 + 16777472) & 0x40004) ^ v313) >> 4) & 0xF000F00 | ((v314 ^ 16 * v314 & 15360 * ((v532 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v336 = 16 * ((v335 ^ (v335 >> 4)) & 0x7030702) ^ (v335 ^ (v335 >> 4)) & 0x7030702 ^ v335;
      v337 = (((v336 ^ (v336 >> 8)) & 0x4E009E) << 8) ^ (v336 ^ (v336 >> 8)) & 0x4E009E ^ v336;
      v338 = ((unsigned __int16)((v337 ^ HIWORD(v337)) & 0xD9D3) << 16) ^ ((unsigned __int16)v337 ^ HIWORD(v337)) & 0xD9D3 ^ v337;
      v339 = 16 * ((v338 ^ (v338 >> 4)) & 0x5040004) ^ (v338 ^ (v338 >> 4)) & 0x5040004 ^ v338;
      v340 = 2 * ((v339 ^ (v339 >> 1)) & 0x4045015) ^ (v339 ^ (v339 >> 1)) & 0x4045015 ^ v510 ^ v339;
      v341 = 0;
      v511 = v340;
      v342 = 0;
      v343 = 0;
      v344 = v340 ^ *(_DWORD *)(v503 - 92);
      v345 = *(_DWORD *)(v503 - 28) ^ __ROL4__(v340, 4);
      v346 = v345;
      v347 = (v345 >> 8) & 0xFC00FC | 0xFF00FF00;
      v348 = v346 & 0xFC00FC;
      v349 = -167733504;
      v549 = v347;
      v348 |= 0xFF00FF00;
      v350 = v348;
      v351 = v344 & 0xFC00FC | 0xFF00FF00;
      v352 = v347 - v348;
      v533 = v348;
      v565 = v344 & 0xFC00FC | 0xFF00FF00;
      v581 = (v344 >> 8) & 0xFC00FC | 0xFF00FF00;
      v353 = v348;
      v354 = (signed int *)&unk_EF160;
      v355 = 0;
      v356 = v581 - v350;
      v357 = v351 - v350;
      while ( 1 )
      {
        v354 += 4;
        v358 = v332 & (v356 + v353);
        v343 ^= v353 & v333;
        v359 = v353 + v352;
        v355 ^= v334 & (v357 + v353);
        v353 += 524296;
        v341 ^= v358;
        v342 ^= v349 & v359;
        if ( v354 == (signed int *)"triple-DES inner-CBC" )
          break;
        v333 = *v354;
        v349 = v354[1];
        v334 = v354[2];
        v332 = v354[3];
      }
      v360 = 234941184;
      v361 = -2097117952;
      v362 = 2063609344;
      v363 = ((16 * v355 & 15360 * ((v565 + 16777472) & 0x40004) ^ v355) >> 8) & 0xF000F0 | (16 * v341 & 15360 * ((v581 + 16777472) & 0x40004) ^ v341) & 0xF000F000 | ((16 * v342 & 15360 * ((v549 + 16777472) & 0x40004) ^ v342) >> 4) & 0xF000F00 | ((v343 ^ 16 * v343 & 15360 * ((v533 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v364 = 16 * ((v363 ^ (v363 >> 4)) & 0x7030702) ^ (v363 ^ (v363 >> 4)) & 0x7030702 ^ v363;
      v365 = (((v364 ^ (v364 >> 8)) & 0x4E009E) << 8) ^ (v364 ^ (v364 >> 8)) & 0x4E009E ^ v364;
      v366 = ((unsigned __int16)((v365 ^ HIWORD(v365)) & 0xD9D3) << 16) ^ ((unsigned __int16)v365 ^ HIWORD(v365)) & 0xD9D3 ^ v365;
      v367 = 16 * ((v366 ^ (v366 >> 4)) & 0x5040004) ^ (v366 ^ (v366 >> 4)) & 0x5040004 ^ v366;
      v368 = 2 * ((v367 ^ (v367 >> 1)) & 0x4045015) ^ (v367 ^ (v367 >> 1)) & 0x4045015 ^ v519 ^ v367;
      v369 = 0;
      v520 = v368;
      v370 = 0;
      v371 = 0;
      v372 = v368 ^ *(_DWORD *)(v503 - 88);
      v373 = *(_DWORD *)(v503 - 24) ^ __ROL4__(v368, 4);
      v374 = v373;
      v375 = (v373 >> 8) & 0xFC00FC | 0xFF00FF00;
      v376 = v374 & 0xFC00FC;
      v377 = -167733504;
      v550 = v375;
      v376 |= 0xFF00FF00;
      v378 = v376;
      v379 = v372 & 0xFC00FC | 0xFF00FF00;
      v380 = v375 - v376;
      v534 = v376;
      v566 = v372 & 0xFC00FC | 0xFF00FF00;
      v582 = (v372 >> 8) & 0xFC00FC | 0xFF00FF00;
      v381 = v376;
      v382 = (signed int *)&unk_EF160;
      v383 = 0;
      v384 = v582 - v378;
      v385 = v379 - v378;
      v501 = v380;
      while ( 1 )
      {
        v382 += 4;
        v386 = v362 & (v385 + v381);
        v387 = v360 & (v384 + v381);
        v388 = v381 + v501;
        v371 ^= v381 & v361;
        v381 += 524296;
        v383 ^= v386;
        v369 ^= v387;
        v370 ^= v377 & v388;
        if ( v382 == (signed int *)"triple-DES inner-CBC" )
          break;
        v361 = *v382;
        v377 = v382[1];
        v362 = v382[2];
        v360 = v382[3];
      }
      v389 = 234941184;
      v390 = -2097117952;
      v391 = 2063609344;
      v392 = ((16 * v383 & 15360 * ((v566 + 16777472) & 0x40004) ^ v383) >> 8) & 0xF000F0 | (16 * v369 & 15360 * ((v582 + 16777472) & 0x40004) ^ v369) & 0xF000F000 | ((16 * v370 & 15360 * ((v550 + 16777472) & 0x40004) ^ v370) >> 4) & 0xF000F00 | ((v371 ^ 16 * v371 & 15360 * ((v534 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v393 = 16 * ((v392 ^ (v392 >> 4)) & 0x7030702) ^ (v392 ^ (v392 >> 4)) & 0x7030702 ^ v392;
      v394 = (((v393 ^ (v393 >> 8)) & 0x4E009E) << 8) ^ (v393 ^ (v393 >> 8)) & 0x4E009E ^ v393;
      v395 = ((unsigned __int16)((v394 ^ HIWORD(v394)) & 0xD9D3) << 16) ^ ((unsigned __int16)v394 ^ HIWORD(v394)) & 0xD9D3 ^ v394;
      v396 = 16 * ((v395 ^ (v395 >> 4)) & 0x5040004) ^ (v395 ^ (v395 >> 4)) & 0x5040004 ^ v395;
      v397 = 2 * ((v396 ^ (v396 >> 1)) & 0x4045015) ^ (v396 ^ (v396 >> 1)) & 0x4045015 ^ v511 ^ v396;
      v398 = 0;
      v512 = v397;
      v399 = 0;
      v400 = 0;
      v401 = v397 ^ *(_DWORD *)(v503 - 84);
      v402 = *(_DWORD *)(v503 - 20) ^ __ROL4__(v397, 4);
      v403 = v402;
      v404 = (v402 >> 8) & 0xFC00FC | 0xFF00FF00;
      v405 = v403 & 0xFC00FC;
      v406 = -167733504;
      v551 = v404;
      v405 |= 0xFF00FF00;
      v407 = v405;
      v408 = v401 & 0xFC00FC | 0xFF00FF00;
      v409 = v404 - v405;
      v535 = v405;
      v567 = v401 & 0xFC00FC | 0xFF00FF00;
      v583 = (v401 >> 8) & 0xFC00FC | 0xFF00FF00;
      v410 = v405;
      v411 = (signed int *)&unk_EF160;
      v412 = 0;
      v413 = v583 - v407;
      v414 = v408 - v407;
      while ( 1 )
      {
        v411 += 4;
        v415 = v389 & (v413 + v410);
        v400 ^= v410 & v390;
        v416 = v410 + v409;
        v412 ^= v391 & (v414 + v410);
        v410 += 524296;
        v398 ^= v415;
        v399 ^= v406 & v416;
        if ( v411 == (signed int *)"triple-DES inner-CBC" )
          break;
        v390 = *v411;
        v406 = v411[1];
        v391 = v411[2];
        v389 = v411[3];
      }
      v417 = 234941184;
      v418 = -2097117952;
      v419 = 2063609344;
      v420 = ((16 * v412 & 15360 * ((v567 + 16777472) & 0x40004) ^ v412) >> 8) & 0xF000F0 | (16 * v398 & 15360 * ((v583 + 16777472) & 0x40004) ^ v398) & 0xF000F000 | ((16 * v399 & 15360 * ((v551 + 16777472) & 0x40004) ^ v399) >> 4) & 0xF000F00 | ((v400 ^ 16 * v400 & 15360 * ((v535 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v421 = 16 * ((v420 ^ (v420 >> 4)) & 0x7030702) ^ (v420 ^ (v420 >> 4)) & 0x7030702 ^ v420;
      v422 = (((v421 ^ (v421 >> 8)) & 0x4E009E) << 8) ^ (v421 ^ (v421 >> 8)) & 0x4E009E ^ v421;
      v423 = ((unsigned __int16)((v422 ^ HIWORD(v422)) & 0xD9D3) << 16) ^ ((unsigned __int16)v422 ^ HIWORD(v422)) & 0xD9D3 ^ v422;
      v424 = 16 * ((v423 ^ (v423 >> 4)) & 0x5040004) ^ (v423 ^ (v423 >> 4)) & 0x5040004 ^ v423;
      v425 = 2 * ((v424 ^ (v424 >> 1)) & 0x4045015) ^ (v424 ^ (v424 >> 1)) & 0x4045015 ^ v520 ^ v424;
      v426 = 0;
      v521 = v425;
      v427 = 0;
      v428 = 0;
      v429 = v425 ^ *(_DWORD *)(v503 - 80);
      v430 = *(_DWORD *)(v503 - 16) ^ __ROL4__(v425, 4);
      v431 = v430;
      v432 = (v430 >> 8) & 0xFC00FC | 0xFF00FF00;
      v433 = v431 & 0xFC00FC;
      v434 = -167733504;
      v552 = v432;
      v433 |= 0xFF00FF00;
      v435 = v433;
      v436 = v429 & 0xFC00FC | 0xFF00FF00;
      v437 = v432 - v433;
      v536 = v433;
      v568 = v429 & 0xFC00FC | 0xFF00FF00;
      v584 = (v429 >> 8) & 0xFC00FC | 0xFF00FF00;
      v438 = v433;
      v439 = (signed int *)&unk_EF160;
      v440 = 0;
      v441 = v584 - v435;
      v442 = v436 - v435;
      v502 = v437;
      while ( 1 )
      {
        v439 += 4;
        v443 = v419 & (v442 + v438);
        v444 = v417 & (v441 + v438);
        v445 = v438 + v502;
        v428 ^= v438 & v418;
        v438 += 524296;
        v440 ^= v443;
        v426 ^= v444;
        v427 ^= v434 & v445;
        if ( v439 == (signed int *)"triple-DES inner-CBC" )
          break;
        v418 = *v439;
        v434 = v439[1];
        v419 = v439[2];
        v417 = v439[3];
      }
      v446 = 234941184;
      v447 = -2097117952;
      v448 = 2063609344;
      v449 = ((16 * v440 & 15360 * ((v568 + 16777472) & 0x40004) ^ v440) >> 8) & 0xF000F0 | (16 * v426 & 15360 * ((v584 + 16777472) & 0x40004) ^ v426) & 0xF000F000 | ((16 * v427 & 15360 * ((v552 + 16777472) & 0x40004) ^ v427) >> 4) & 0xF000F00 | ((v428 ^ 16 * v428 & 15360 * ((v536 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v450 = 16 * ((v449 ^ (v449 >> 4)) & 0x7030702) ^ (v449 ^ (v449 >> 4)) & 0x7030702 ^ v449;
      v451 = (((v450 ^ (v450 >> 8)) & 0x4E009E) << 8) ^ (v450 ^ (v450 >> 8)) & 0x4E009E ^ v450;
      v452 = ((unsigned __int16)((v451 ^ HIWORD(v451)) & 0xD9D3) << 16) ^ ((unsigned __int16)v451 ^ HIWORD(v451)) & 0xD9D3 ^ v451;
      v453 = 16 * ((v452 ^ (v452 >> 4)) & 0x5040004) ^ (v452 ^ (v452 >> 4)) & 0x5040004 ^ v452;
      v454 = 2 * ((v453 ^ (v453 >> 1)) & 0x4045015) ^ (v453 ^ (v453 >> 1)) & 0x4045015 ^ v512 ^ v453;
      v455 = 0;
      v513 = v454;
      v456 = 0;
      v457 = 0;
      v458 = v454 ^ *(_DWORD *)(v503 - 76);
      v459 = *(_DWORD *)(v503 - 12) ^ __ROL4__(v454, 4);
      v460 = v459;
      v461 = (v459 >> 8) & 0xFC00FC | 0xFF00FF00;
      v462 = v460 & 0xFC00FC;
      v463 = -167733504;
      v553 = v461;
      v462 |= 0xFF00FF00;
      v464 = v462;
      v465 = v458 & 0xFC00FC | 0xFF00FF00;
      v466 = v461 - v462;
      v537 = v462;
      v569 = v458 & 0xFC00FC | 0xFF00FF00;
      v585 = (v458 >> 8) & 0xFC00FC | 0xFF00FF00;
      v467 = v462;
      v468 = (signed int *)&unk_EF160;
      v469 = 0;
      v470 = v585 - v464;
      v471 = v465 - v464;
      while ( 1 )
      {
        v468 += 4;
        v472 = v446 & (v470 + v467);
        v457 ^= v467 & v447;
        v473 = v467 + v466;
        v469 ^= v448 & (v471 + v467);
        v467 += 524296;
        v455 ^= v472;
        v456 ^= v463 & v473;
        if ( v468 == (signed int *)"triple-DES inner-CBC" )
          break;
        v447 = *v468;
        v463 = v468[1];
        v448 = v468[2];
        v446 = v468[3];
      }
      v474 = v504;
      v475 = ((16 * v469 & 15360 * ((v569 + 16777472) & 0x40004) ^ v469) >> 8) & 0xF000F0 | (16 * v455 & 15360 * ((v585 + 16777472) & 0x40004) ^ v455) & 0xF000F000 | ((16 * v456 & 15360 * ((v553 + 16777472) & 0x40004) ^ v456) >> 4) & 0xF000F00 | ((v457 ^ 16 * v457 & 15360 * ((v537 + 16777472) & 0x40004u)) >> 12) & 0xF000F;
      v476 = 16 * ((v475 ^ (v475 >> 4)) & 0x7030702) ^ (v475 ^ (v475 >> 4)) & 0x7030702 ^ v475;
      v477 = (((v476 ^ (v476 >> 8)) & 0x4E009E) << 8) ^ (v476 ^ (v476 >> 8)) & 0x4E009E ^ v476;
      v478 = ((unsigned __int16)((v477 ^ HIWORD(v477)) & 0xD9D3) << 16) ^ ((unsigned __int16)v477 ^ HIWORD(v477)) & 0xD9D3 ^ v477;
      v479 = 16 * ((v478 ^ (v478 >> 4)) & 0x5040004) ^ (v478 ^ (v478 >> 4)) & 0x5040004 ^ v478;
      v480 = __ROL4__(2 * ((v479 ^ (v479 >> 1)) & 0x4045015) ^ (v479 ^ (v479 >> 1)) & 0x4045015 ^ v521 ^ v479, 1);
      v481 = (__ROL4__(v513, 1) ^ (v480 >> 1)) & 0x55555555;
      v482 = v481 ^ __ROL4__(v513, 1);
      v483 = 2 * v481 ^ v480;
      v484 = (v483 ^ (v482 >> 8)) & 0xFF00FF;
      v485 = v484 ^ v483;
      v486 = v482 ^ (v484 << 8);
      v487 = (v485 ^ ((v482 ^ (v484 << 8)) >> 2)) & 0x33333333;
      v488 = v487 ^ v485;
      v489 = v486 ^ 4 * v487;
      v490 = (unsigned __int16)(v489 ^ HIWORD(v488));
      v491 = v490 ^ v489;
      v492 = v488 ^ (v490 << 16);
      v493 = (v491 ^ ((v488 ^ (unsigned int)(v490 << 16)) >> 4)) & 0xF0F0F0F;
      v4 = v493 ^ v491;
      *(_BYTE *)(v504 + 7) = v4;
      *(_BYTE *)(v504 + 6) = BYTE1(v4);
      v3 = v492 ^ 16 * v493;
      *(_BYTE *)(v504 + 3) = v492 ^ 16 * v493;
      *(_BYTE *)(v504 + 2) = BYTE1(v3);
      *(_BYTE *)(v504 + 1) = BYTE2(v3);
      *(_BYTE *)v504 = (v492 ^ 16 * v493) >> 24;
      *(_BYTE *)(v504 + 5) = BYTE2(v4);
      v504 += 8LL;
      *(_BYTE *)(v474 + 4) = HIBYTE(v4);
      *(_DWORD *)(v503 - 8) = v3;
      *(_DWORD *)(v503 - 4) = v4;
    }
    while ( v504 != v586 );
  }
}

void __fastcall sub_67E70(__int64 a1, __int64 a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // er12
  unsigned int v6; // ebp
  unsigned int v7; // er13
  unsigned __int64 v8; // rax
  signed int v9; // er9
  signed int v10; // edi
  signed int v11; // er11
  unsigned int v12; // edx
  int v13; // ecx
  int v14; // ebx
  signed int v15; // ecx
  int v16; // esi
  unsigned int v17; // er14
  int v18; // er8
  int v19; // edx
  signed int *v20; // rax
  int v21; // ebx
  int v22; // er15
  int v23; // er14
  int v24; // er8
  int v25; // esi
  int v26; // er10
  signed int v27; // er9
  signed int v28; // er11
  signed int v29; // edi
  unsigned int v30; // eax
  unsigned int v31; // eax
  int v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // eax
  int v36; // er12
  int v37; // ebp
  unsigned int v38; // er13
  unsigned int v39; // edx
  unsigned int v40; // eax
  unsigned int v41; // ecx
  unsigned int v42; // eax
  int v43; // ebx
  signed int v44; // ecx
  int v45; // esi
  unsigned int v46; // er14
  int v47; // er8
  int v48; // edx
  signed int *v49; // rax
  int v50; // ebx
  int v51; // er15
  int v52; // er14
  int v53; // er8
  int v54; // esi
  int v55; // er10
  signed int v56; // er9
  signed int v57; // er11
  signed int v58; // edi
  unsigned int v59; // eax
  unsigned int v60; // eax
  int v61; // eax
  unsigned int v62; // eax
  unsigned int v63; // eax
  int v64; // eax
  int v65; // er12
  int v66; // ebp
  unsigned int v67; // er13
  unsigned int v68; // edx
  unsigned int v69; // eax
  unsigned int v70; // ecx
  unsigned int v71; // eax
  int v72; // ebx
  signed int v73; // ecx
  int v74; // esi
  unsigned int v75; // er14
  int v76; // er8
  int v77; // edx
  signed int *v78; // rax
  int v79; // ebx
  int v80; // er15
  int v81; // er14
  int v82; // er8
  int v83; // esi
  int v84; // er10
  signed int v85; // er9
  signed int v86; // er11
  signed int v87; // edi
  unsigned int v88; // eax
  unsigned int v89; // eax
  int v90; // eax
  unsigned int v91; // eax
  unsigned int v92; // eax
  int v93; // eax
  int v94; // er12
  int v95; // ebp
  unsigned int v96; // er13
  unsigned int v97; // edx
  unsigned int v98; // eax
  unsigned int v99; // ecx
  unsigned int v100; // eax
  int v101; // ebx
  signed int v102; // ecx
  int v103; // esi
  unsigned int v104; // er14
  int v105; // er8
  int v106; // edx
  signed int *v107; // rax
  int v108; // ebx
  int v109; // er15
  int v110; // er14
  int v111; // er8
  int v112; // esi
  int v113; // er10
  signed int v114; // er9
  signed int v115; // er11
  signed int v116; // edi
  unsigned int v117; // eax
  unsigned int v118; // eax
  int v119; // eax
  unsigned int v120; // eax
  unsigned int v121; // eax
  int v122; // eax
  int v123; // er12
  int v124; // ebp
  unsigned int v125; // er13
  unsigned int v126; // edx
  unsigned int v127; // eax
  unsigned int v128; // ecx
  unsigned int v129; // eax
  int v130; // ebx
  signed int v131; // ecx
  int v132; // esi
  unsigned int v133; // er14
  int v134; // er8
  int v135; // edx
  signed int *v136; // rax
  int v137; // ebx
  int v138; // er15
  int v139; // er14
  int v140; // esi
  int v141; // er10
  signed int v142; // er9
  signed int v143; // er11
  signed int v144; // edi
  unsigned int v145; // eax
  unsigned int v146; // eax
  int v147; // eax
  unsigned int v148; // eax
  unsigned int v149; // eax
  int v150; // eax
  int v151; // er12
  int v152; // ebp
  unsigned int v153; // er13
  unsigned int v154; // edx
  unsigned int v155; // eax
  unsigned int v156; // ecx
  unsigned int v157; // eax
  int v158; // ebx
  signed int v159; // ecx
  int v160; // esi
  unsigned int v161; // er14
  int v162; // er8
  int v163; // edx
  signed int *v164; // rax
  int v165; // ebx
  int v166; // er15
  int v167; // er14
  int v168; // er8
  int v169; // esi
  int v170; // er10
  signed int v171; // er9
  signed int v172; // er11
  signed int v173; // edi
  unsigned int v174; // eax
  unsigned int v175; // eax
  int v176; // eax
  unsigned int v177; // eax
  unsigned int v178; // eax
  int v179; // eax
  int v180; // er12
  int v181; // ebp
  unsigned int v182; // er13
  unsigned int v183; // edx
  unsigned int v184; // eax
  unsigned int v185; // ecx
  unsigned int v186; // eax
  int v187; // ebx
  signed int v188; // ecx
  int v189; // esi
  unsigned int v190; // er14
  int v191; // er8
  int v192; // edx
  signed int *v193; // rax
  int v194; // ebx
  int v195; // er15
  int v196; // er14
  int v197; // esi
  int v198; // er10
  signed int v199; // er9
  signed int v200; // er11
  signed int v201; // edi
  unsigned int v202; // eax
  unsigned int v203; // eax
  int v204; // eax
  unsigned int v205; // eax
  unsigned int v206; // eax
  int v207; // eax
  int v208; // er12
  int v209; // ebp
  unsigned int v210; // er13
  unsigned int v211; // edx
  unsigned int v212; // eax
  unsigned int v213; // ecx
  unsigned int v214; // eax
  int v215; // ebx
  signed int v216; // ecx
  int v217; // esi
  unsigned int v218; // er14
  int v219; // er8
  int v220; // edx
  signed int *v221; // rax
  int v222; // ebx
  int v223; // er15
  int v224; // er14
  int v225; // er8
  int v226; // esi
  int v227; // er10
  signed int v228; // er9
  signed int v229; // er11
  signed int v230; // edi
  unsigned int v231; // eax
  unsigned int v232; // eax
  int v233; // eax
  unsigned int v234; // eax
  unsigned int v235; // eax
  int v236; // eax
  int v237; // er12
  int v238; // ebp
  unsigned int v239; // er13
  unsigned int v240; // edx
  unsigned int v241; // eax
  unsigned int v242; // ecx
  unsigned int v243; // eax
  int v244; // ebx
  signed int v245; // ecx
  int v246; // esi
  unsigned int v247; // er14
  int v248; // er8
  int v249; // edx
  signed int *v250; // rax
  int v251; // ebx
  int v252; // er15
  int v253; // er14
  int v254; // esi
  int v255; // er10
  signed int v256; // er9
  signed int v257; // er11
  signed int v258; // edi
  unsigned int v259; // eax
  unsigned int v260; // eax
  int v261; // eax
  unsigned int v262; // eax
  unsigned int v263; // eax
  int v264; // eax
  int v265; // er12
  int v266; // ebp
  unsigned int v267; // er13
  unsigned int v268; // edx
  unsigned int v269; // eax
  unsigned int v270; // ecx
  unsigned int v271; // eax
  int v272; // ebx
  signed int v273; // ecx
  int v274; // esi
  unsigned int v275; // er14
  int v276; // er8
  int v277; // edx
  signed int *v278; // rax
  int v279; // ebx
  int v280; // er15
  int v281; // er14
  int v282; // er8
  int v283; // esi
  int v284; // er10
  signed int v285; // er9
  signed int v286; // er11
  signed int v287; // edi
  unsigned int v288; // eax
  unsigned int v289; // eax
  int v290; // eax
  unsigned int v291; // eax
  unsigned int v292; // eax
  int v293; // eax
  int v294; // er12
  int v295; // ebp
  unsigned int v296; // er13
  unsigned int v297; // edx
  unsigned int v298; // eax
  unsigned int v299; // ecx
  unsigned int v300; // eax
  int v301; // ebx
  signed int v302; // ecx
  int v303; // esi
  unsigned int v304; // er14
  int v305; // er8
  int v306; // edx
  signed int *v307; // rax
  int v308; // ebx
  int v309; // er15
  int v310; // er14
  int v311; // esi
  int v312; // er10
  signed int v313; // er9
  signed int v314; // er11
  signed int v315; // edi
  unsigned int v316; // eax
  unsigned int v317; // eax
  int v318; // eax
  unsigned int v319; // eax
  unsigned int v320; // eax
  int v321; // eax
  int v322; // er12
  int v323; // ebp
  unsigned int v324; // er13
  unsigned int v325; // edx
  unsigned int v326; // eax
  unsigned int v327; // ecx
  unsigned int v328; // eax
  int v329; // ebx
  signed int v330; // ecx
  int v331; // esi
  unsigned int v332; // er14
  int v333; // er8
  int v334; // edx
  signed int *v335; // rax
  int v336; // ebx
  int v337; // er15
  int v338; // er14
  int v339; // er8
  int v340; // esi
  int v341; // er10
  signed int v342; // er9
  signed int v343; // er11
  signed int v344; // edi
  unsigned int v345; // eax
  unsigned int v346; // eax
  int v347; // eax
  unsigned int v348; // eax
  unsigned int v349; // eax
  int v350; // eax
  int v351; // er12
  int v352; // ebp
  unsigned int v353; // er13
  unsigned int v354; // edx
  unsigned int v355; // eax
  unsigned int v356; // ecx
  unsigned int v357; // eax
  int v358; // ebx
  signed int v359; // ecx
  int v360; // esi
  unsigned int v361; // er14
  int v362; // er8
  int v363; // edx
  signed int *v364; // rax
  int v365; // ebx
  int v366; // er15
  int v367; // er14
  int v368; // esi
  int v369; // er10
  signed int v370; // er9
  signed int v371; // er11
  signed int v372; // edi
  unsigned int v373; // eax
  unsigned int v374; // eax
  int v375; // eax
  unsigned int v376; // eax
  unsigned int v377; // eax
  int v378; // eax
  int v379; // er12
  int v380; // ebp
  unsigned int v381; // er13
  unsigned int v382; // edx
  unsigned int v383; // eax
  unsigned int v384; // ecx
  unsigned int v385; // eax
  int v386; // ebx
  signed int v387; // ecx
  int v388; // esi
  unsigned int v389; // er14
  int v390; // er8
  int v391; // edx
  signed int *v392; // rax
  int v393; // ebx
  int v394; // er15
  int v395; // er14
  int v396; // er8
  int v397; // esi
  int v398; // er10
  signed int v399; // er9
  signed int v400; // er11
  signed int v401; // edi
  unsigned int v402; // eax
  unsigned int v403; // eax
  int v404; // eax
  unsigned int v405; // eax
  unsigned int v406; // eax
  int v407; // eax
  int v408; // er12
  int v409; // ebp
  unsigned int v410; // er13
  unsigned int v411; // edx
  unsigned int v412; // eax
  unsigned int v413; // ecx
  unsigned int v414; // eax
  int v415; // ebx
  signed int v416; // ecx
  int v417; // esi
  unsigned int v418; // er14
  int v419; // er8
  int v420; // edx
  signed int *v421; // rax
  int v422; // ebx
  int v423; // er15
  int v424; // er14
  int v425; // esi
  int v426; // er10
  signed int v427; // er9
  signed int v428; // er11
  signed int v429; // edi
  unsigned int v430; // eax
  unsigned int v431; // eax
  int v432; // eax
  unsigned int v433; // eax
  unsigned int v434; // eax
  int v435; // eax
  int v436; // er12
  int v437; // ebp
  unsigned int v438; // er13
  unsigned int v439; // edx
  unsigned int v440; // eax
  unsigned int v441; // ecx
  unsigned int v442; // eax
  int v443; // ebx
  signed int v444; // ecx
  int v445; // esi
  unsigned int v446; // er14
  int v447; // er8
  int v448; // edx
  signed int *v449; // rax
  int v450; // ebx
  int v451; // er15
  int v452; // er14
  int v453; // er8
  int v454; // esi
  int v455; // er10
  unsigned int v456; // eax
  int v457; // edx
  unsigned int v458; // eax
  unsigned int v459; // eax
  unsigned int v460; // eax
  int v461; // er12
  unsigned int v462; // ebp
  unsigned __int64 v463; // rax
  signed int v464; // er9
  signed int v465; // edi
  signed int v466; // er11
  unsigned int v467; // er13
  unsigned int v468; // edx
  int v469; // ecx
  int v470; // ebx
  signed int v471; // ecx
  int v472; // esi
  unsigned int v473; // er14
  int v474; // er8
  int v475; // edx
  signed int *v476; // rax
  int v477; // ebx
  int v478; // er15
  int v479; // er14
  int v480; // esi
  int v481; // er10
  __int64 v482; // r14
  unsigned int v483; // eax
  unsigned int v484; // eax
  int v485; // eax
  unsigned int v486; // eax
  unsigned int v487; // eax
  int v488; // ebx
  int v489; // er12
  unsigned int v490; // er13
  int v491; // ebp
  int v492; // ebx
  int v493; // ebp
  int v494; // ebp
  signed int v495; // er9
  signed int v496; // edi
  unsigned int v497; // eax
  signed int v498; // er11
  unsigned int v499; // edx
  int v500; // ebp
  unsigned int v501; // ecx
  unsigned int v502; // eax
  int v503; // ebx
  signed int v504; // ecx
  int v505; // esi
  int v506; // er8
  int v507; // edx
  signed int *v508; // rax
  int v509; // ebx
  int v510; // er15
  int v511; // er14
  int v512; // er8
  int v513; // esi
  int v514; // er10
  signed int v515; // er9
  signed int v516; // er11
  signed int v517; // edi
  unsigned int v518; // eax
  unsigned int v519; // eax
  int v520; // eax
  unsigned int v521; // eax
  unsigned int v522; // eax
  int v523; // eax
  int v524; // er12
  int v525; // ebp
  unsigned int v526; // er13
  unsigned int v527; // edx
  unsigned int v528; // eax
  unsigned int v529; // ecx
  unsigned int v530; // eax
  int v531; // ebx
  signed int v532; // ecx
  int v533; // esi
  unsigned int v534; // er14
  int v535; // er8
  int v536; // edx
  signed int *v537; // rax
  int v538; // ebx
  int v539; // er15
  int v540; // er14
  int v541; // esi
  int v542; // er10
  signed int v543; // er9
  signed int v544; // er11
  signed int v545; // edi
  unsigned int v546; // eax
  unsigned int v547; // eax
  int v548; // eax
  unsigned int v549; // eax
  unsigned int v550; // eax
  int v551; // eax
  int v552; // er12
  int v553; // ebp
  unsigned int v554; // er13
  unsigned int v555; // edx
  unsigned int v556; // eax
  unsigned int v557; // ecx
  unsigned int v558; // eax
  int v559; // ebx
  signed int v560; // ecx
  int v561; // esi
  unsigned int v562; // er14
  int v563; // er8
  int v564; // edx
  signed int *v565; // rax
  int v566; // ebx
  int v567; // er15
  int v568; // er14
  int v569; // er8
  int v570; // esi
  int v571; // er10
  signed int v572; // er9
  signed int v573; // er11
  signed int v574; // edi
  unsigned int v575; // eax
  unsigned int v576; // eax
  int v577; // eax
  unsigned int v578; // eax
  unsigned int v579; // eax
  int v580; // eax
  int v581; // er12
  int v582; // ebp
  unsigned int v583; // er13
  unsigned int v584; // edx
  unsigned int v585; // eax
  unsigned int v586; // ecx
  unsigned int v587; // eax
  int v588; // ebx
  signed int v589; // ecx
  int v590; // esi
  unsigned int v591; // er14
  int v592; // er8
  int v593; // edx
  signed int *v594; // rax
  int v595; // ebx
  int v596; // er15
  int v597; // er14
  int v598; // esi
  int v599; // er10
  signed int v600; // er9
  signed int v601; // er11
  signed int v602; // edi
  unsigned int v603; // eax
  unsigned int v604; // eax
  int v605; // eax
  unsigned int v606; // eax
  unsigned int v607; // eax
  int v608; // eax
  int v609; // er12
  int v610; // ebp
  unsigned int v611; // er13
  unsigned int v612; // edx
  unsigned int v613; // eax
  unsigned int v614; // ecx
  unsigned int v615; // eax
  int v616; // ebx
  signed int v617; // ecx
  int v618; // esi
  unsigned int v619; // er14
  int v620; // er8
  int v621; // edx
  signed int *v622; // rax
  int v623; // ebx
  int v624; // er15
  int v625; // er14
  int v626; // er8
  int v627; // esi
  int v628; // er10
  signed int v629; // er9
  signed int v630; // er11
  signed int v631; // edi
  unsigned int v632; // eax
  unsigned int v633; // eax
  int v634; // eax
  unsigned int v635; // eax
  unsigned int v636; // eax
  int v637; // eax
  int v638; // er12
  int v639; // ebp
  unsigned int v640; // er13
  unsigned int v641; // edx
  unsigned int v642; // eax
  unsigned int v643; // ecx
  unsigned int v644; // eax
  int v645; // ebx
  signed int v646; // ecx
  int v647; // esi
  unsigned int v648; // er14
  int v649; // er8
  int v650; // edx
  signed int *v651; // rax
  int v652; // ebx
  int v653; // er15
  int v654; // er14
  int v655; // esi
  int v656; // er10
  signed int v657; // er9
  signed int v658; // er11
  signed int v659; // edi
  unsigned int v660; // eax
  unsigned int v661; // eax
  int v662; // eax
  unsigned int v663; // eax
  unsigned int v664; // eax
  int v665; // eax
  int v666; // er12
  int v667; // ebp
  unsigned int v668; // er13
  unsigned int v669; // edx
  unsigned int v670; // eax
  unsigned int v671; // ecx
  unsigned int v672; // eax
  int v673; // ebx
  signed int v674; // ecx
  int v675; // esi
  unsigned int v676; // er14
  int v677; // er8
  int v678; // edx
  signed int *v679; // rax
  int v680; // ebx
  int v681; // er15
  int v682; // er14
  int v683; // er8
  int v684; // esi
  int v685; // er10
  signed int v686; // er9
  signed int v687; // er11
  signed int v688; // edi
  unsigned int v689; // eax
  unsigned int v690; // eax
  int v691; // eax
  unsigned int v692; // eax
  unsigned int v693; // eax
  int v694; // eax
  int v695; // er12
  int v696; // ebp
  unsigned int v697; // er13
  unsigned int v698; // edx
  unsigned int v699; // eax
  unsigned int v700; // ecx
  unsigned int v701; // eax
  int v702; // ebx
  signed int v703; // ecx
  int v704; // esi
  unsigned int v705; // er14
  int v706; // er8
  int v707; // edx
  signed int *v708; // rax
  int v709; // ebx
  int v710; // er15
  int v711; // er14
  int v712; // esi
  int v713; // er10
  signed int v714; // er9
  signed int v715; // er11
  signed int v716; // edi
  unsigned int v717; // eax
  unsigned int v718; // eax
  int v719; // eax
  unsigned int v720; // eax
  unsigned int v721; // eax
  int v722; // eax
  int v723; // er12
  int v724; // ebp
  unsigned int v725; // er13
  unsigned int v726; // edx
  unsigned int v727; // eax
  unsigned int v728; // ecx
  unsigned int v729; // eax
  int v730; // ebx
  signed int v731; // ecx
  int v732; // esi
  unsigned int v733; // er14
  int v734; // er8
  int v735; // edx
  signed int *v736; // rax
  int v737; // ebx
  int v738; // er15
  int v739; // er14
  int v740; // er8
  int v741; // esi
  int v742; // er10
  signed int v743; // er9
  signed int v744; // er11
  signed int v745; // edi
  unsigned int v746; // eax
  unsigned int v747; // eax
  int v748; // eax
  unsigned int v749; // eax
  unsigned int v750; // eax
  int v751; // eax
  int v752; // er12
  int v753; // ebp
  unsigned int v754; // er13
  unsigned int v755; // edx
  unsigned int v756; // eax
  unsigned int v757; // ecx
  unsigned int v758; // eax
  int v759; // ebx
  signed int v760; // ecx
  int v761; // esi
  unsigned int v762; // er14
  int v763; // er8
  int v764; // edx
  signed int *v765; // rax
  int v766; // ebx
  int v767; // er15
  int v768; // er14
  int v769; // esi
  int v770; // er10
  unsigned int v771; // eax
  int v772; // edx
  unsigned int v773; // eax
  unsigned int v774; // eax
  unsigned int v775; // eax
  unsigned int v776; // eax
  int v777; // esi
  int v778; // eax
  unsigned int v779; // edx
  int v780; // eax
  unsigned int v781; // esi
  int v782; // edx
  int v783; // eax
  int v784; // ecx
  int v785; // edx
  int v786; // ecx
  unsigned int v787; // eax
  int v788; // edx
  __int64 v789; // rdi
  int v790; // [rsp+4h] [rbp-74h]
  int v791; // [rsp+4h] [rbp-74h]
  int v792; // [rsp+4h] [rbp-74h]
  int v793; // [rsp+4h] [rbp-74h]
  int v794; // [rsp+4h] [rbp-74h]
  int v795; // [rsp+4h] [rbp-74h]
  int v796; // [rsp+4h] [rbp-74h]
  int v797; // [rsp+4h] [rbp-74h]
  int v798; // [rsp+4h] [rbp-74h]
  int v799; // [rsp+4h] [rbp-74h]
  int v800; // [rsp+4h] [rbp-74h]
  int v801; // [rsp+4h] [rbp-74h]
  int v802; // [rsp+4h] [rbp-74h]
  int v803; // [rsp+4h] [rbp-74h]
  int v804; // [rsp+4h] [rbp-74h]
  __int64 v805; // [rsp+8h] [rbp-70h]
  __int64 v806; // [rsp+10h] [rbp-68h]
  __int64 v807; // [rsp+18h] [rbp-60h]
  int v808; // [rsp+18h] [rbp-60h]
  int v809; // [rsp+18h] [rbp-60h]
  int v810; // [rsp+18h] [rbp-60h]
  int v811; // [rsp+18h] [rbp-60h]
  int v812; // [rsp+18h] [rbp-60h]
  int v813; // [rsp+18h] [rbp-60h]
  int v814; // [rsp+18h] [rbp-60h]
  int v815; // [rsp+18h] [rbp-60h]
  int v816; // [rsp+18h] [rbp-60h]
  int v817; // [rsp+18h] [rbp-60h]
  int v818; // [rsp+18h] [rbp-60h]
  int v819; // [rsp+18h] [rbp-60h]
  int v820; // [rsp+18h] [rbp-60h]
  int v821; // [rsp+18h] [rbp-60h]
  int v822; // [rsp+18h] [rbp-60h]
  int v823; // [rsp+20h] [rbp-58h]
  int v824; // [rsp+20h] [rbp-58h]
  int v825; // [rsp+20h] [rbp-58h]
  int v826; // [rsp+20h] [rbp-58h]
  int v827; // [rsp+20h] [rbp-58h]
  int v828; // [rsp+20h] [rbp-58h]
  int v829; // [rsp+20h] [rbp-58h]
  int v830; // [rsp+20h] [rbp-58h]
  int v831; // [rsp+20h] [rbp-58h]
  int v832; // [rsp+20h] [rbp-58h]
  int v833; // [rsp+20h] [rbp-58h]
  int v834; // [rsp+20h] [rbp-58h]
  int v835; // [rsp+20h] [rbp-58h]
  int v836; // [rsp+20h] [rbp-58h]
  int v837; // [rsp+20h] [rbp-58h]
  int v838; // [rsp+24h] [rbp-54h]
  unsigned int v839; // [rsp+24h] [rbp-54h]
  int v840; // [rsp+24h] [rbp-54h]
  int v841; // [rsp+24h] [rbp-54h]
  int v842; // [rsp+24h] [rbp-54h]
  int v843; // [rsp+24h] [rbp-54h]
  int v844; // [rsp+24h] [rbp-54h]
  int v845; // [rsp+24h] [rbp-54h]
  int v846; // [rsp+24h] [rbp-54h]
  int v847; // [rsp+24h] [rbp-54h]
  int v848; // [rsp+24h] [rbp-54h]
  int v849; // [rsp+24h] [rbp-54h]
  int v850; // [rsp+24h] [rbp-54h]
  int v851; // [rsp+24h] [rbp-54h]
  int v852; // [rsp+24h] [rbp-54h]
  int v853; // [rsp+24h] [rbp-54h]
  int v854; // [rsp+24h] [rbp-54h]
  int v855; // [rsp+24h] [rbp-54h]
  int v856; // [rsp+24h] [rbp-54h]
  int v857; // [rsp+24h] [rbp-54h]
  int v858; // [rsp+24h] [rbp-54h]
  int v859; // [rsp+24h] [rbp-54h]
  int v860; // [rsp+24h] [rbp-54h]
  int v861; // [rsp+24h] [rbp-54h]
  int v862; // [rsp+24h] [rbp-54h]
  int v863; // [rsp+24h] [rbp-54h]
  int v864; // [rsp+24h] [rbp-54h]
  unsigned int v865; // [rsp+28h] [rbp-50h]
  unsigned int v866; // [rsp+28h] [rbp-50h]
  unsigned int v867; // [rsp+28h] [rbp-50h]
  unsigned int v868; // [rsp+28h] [rbp-50h]
  unsigned int v869; // [rsp+28h] [rbp-50h]
  unsigned int v870; // [rsp+28h] [rbp-50h]
  unsigned int v871; // [rsp+28h] [rbp-50h]
  unsigned int v872; // [rsp+28h] [rbp-50h]
  unsigned int v873; // [rsp+28h] [rbp-50h]
  unsigned int v874; // [rsp+28h] [rbp-50h]
  unsigned int v875; // [rsp+28h] [rbp-50h]
  unsigned int v876; // [rsp+28h] [rbp-50h]
  unsigned int v877; // [rsp+28h] [rbp-50h]
  unsigned int v878; // [rsp+28h] [rbp-50h]
  unsigned int v879; // [rsp+28h] [rbp-50h]
  unsigned int v880; // [rsp+28h] [rbp-50h]
  unsigned int v881; // [rsp+28h] [rbp-50h]
  unsigned int v882; // [rsp+28h] [rbp-50h]
  unsigned int v883; // [rsp+28h] [rbp-50h]
  unsigned int v884; // [rsp+28h] [rbp-50h]
  unsigned int v885; // [rsp+28h] [rbp-50h]
  unsigned int v886; // [rsp+28h] [rbp-50h]
  unsigned int v887; // [rsp+28h] [rbp-50h]
  unsigned int v888; // [rsp+28h] [rbp-50h]
  unsigned int v889; // [rsp+28h] [rbp-50h]
  unsigned int v890; // [rsp+28h] [rbp-50h]
  unsigned int v891; // [rsp+28h] [rbp-50h]
  unsigned int v892; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v893; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v894; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v895; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v896; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v897; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v898; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v899; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v900; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v901; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v902; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v903; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v904; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v905; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v906; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v907; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v908; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v909; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v910; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v911; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v912; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v913; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v914; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v915; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v916; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v917; // [rsp+2Ch] [rbp-4Ch]
  unsigned int v918; // [rsp+2Ch] [rbp-4Ch]
  int v919; // [rsp+30h] [rbp-48h]
  unsigned int v920; // [rsp+30h] [rbp-48h]
  unsigned int v921; // [rsp+30h] [rbp-48h]
  unsigned int v922; // [rsp+30h] [rbp-48h]
  unsigned int v923; // [rsp+30h] [rbp-48h]
  unsigned int v924; // [rsp+30h] [rbp-48h]
  unsigned int v925; // [rsp+30h] [rbp-48h]
  unsigned int v926; // [rsp+30h] [rbp-48h]
  unsigned int v927; // [rsp+30h] [rbp-48h]
  unsigned int v928; // [rsp+30h] [rbp-48h]
  unsigned int v929; // [rsp+30h] [rbp-48h]
  unsigned int v930; // [rsp+30h] [rbp-48h]
  unsigned int v931; // [rsp+30h] [rbp-48h]
  unsigned int v932; // [rsp+30h] [rbp-48h]
  unsigned int v933; // [rsp+30h] [rbp-48h]
  int v934; // [rsp+30h] [rbp-48h]
  unsigned int v935; // [rsp+30h] [rbp-48h]
  unsigned int v936; // [rsp+30h] [rbp-48h]
  unsigned int v937; // [rsp+30h] [rbp-48h]
  unsigned int v938; // [rsp+30h] [rbp-48h]
  unsigned int v939; // [rsp+30h] [rbp-48h]
  unsigned int v940; // [rsp+30h] [rbp-48h]
  unsigned int v941; // [rsp+30h] [rbp-48h]
  unsigned int v942; // [rsp+30h] [rbp-48h]
  unsigned int v943; // [rsp+30h] [rbp-48h]
  unsigned int v944; // [rsp+30h] [rbp-48h]
  signed __int64 v945; // [rsp+38h] [rbp-40h]
  __int64 v946; // [rsp+40h] [rbp-38h]

  v805 = a1;
  v806 = a2;
  if ( a3 > 0 )
  {
    v3 = *(_DWORD *)(a1 - 8);
    v4 = *(_DWORD *)(a1 - 4);
    v946 = a1 - 264;
    v945 = a2 + 8LL * ((unsigned int)(a3 - 1) >> 3) + 8;
    do
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = sub_63440(((unsigned __int64)(_byteswap_ulong(*(_DWORD *)(v806 + 4)) ^ v4) << 32) | _byteswap_ulong(*(_DWORD *)v806) ^ v3);
      v808 = v8;
      v8 >>= 32;
      v919 = v8;
      v9 = 234941184;
      v10 = 2063609344;
      v11 = -2097117952;
      v12 = v8 ^ *(_DWORD *)(v805 - 392);
      LODWORD(v8) = *(_DWORD *)(v805 - 328) ^ __ROL4__(v8, 4);
      v13 = v8;
      LODWORD(v8) = ((unsigned int)v8 >> 8) & 0xFC00FC | 0xFF00FF00;
      v14 = v13 & 0xFC00FC;
      v15 = -167733504;
      v838 = v8;
      v14 |= 0xFF00FF00;
      v16 = v14;
      v17 = v12 & 0xFC00FC | 0xFF00FF00;
      v18 = v8 - v14;
      v823 = v14;
      v865 = v12 & 0xFC00FC | 0xFF00FF00;
      v892 = (v12 >> 8) & 0xFC00FC | 0xFF00FF00;
      v19 = v14;
      v20 = (signed int *)&unk_EF160;
      v21 = 0;
      v22 = v892 - v16;
      v23 = v17 - v16;
      v790 = v18;
      while ( 1 )
      {
        v20 += 4;
        v24 = v10 & (v23 + v19);
        v25 = v9 & (v22 + v19);
        v26 = v19 + v790;
        v7 ^= v19 & v11;
        v19 += 524296;
        v21 ^= v24;
        v5 ^= v25;
        v6 ^= v15 & v26;
        if ( v20 == (signed int *)"triple-DES inner-CBC" )
          break;
        v11 = *v20;
        v15 = v20[1];
        v10 = v20[2];
        v9 = v20[3];
      }
      v27 = 234941184;
      v28 = -2097117952;
      v29 = 2063609344;
      v30 = ((16 * v21 & 15360 * ((v865 + 16777472) & 0x40004) ^ v21) >> 8) & 0xF000F0 | (16 * v5 & 15360 * ((v892 + 16777472) & 0x40004) ^ v5) & 0xF000F000 | ((16 * v6 & 15360 * ((v838 + 16777472) & 0x40004) ^ v6) >> 4) & 0xF000F00 | ((16 * v7 & 15360 * ((v823 + 16777472) & 0x40004) ^ v7) >> 12) & 0xF000F;
      v31 = 16 * ((v30 ^ (v30 >> 4)) & 0x7030702) ^ (v30 ^ (v30 >> 4)) & 0x7030702 ^ v30;
      v32 = (((v31 ^ (v31 >> 8)) & 0x4E009E) << 8) ^ (v31 ^ (v31 >> 8)) & 0x4E009E ^ v31;
      v33 = ((unsigned __int16)((v32 ^ HIWORD(v32)) & 0xD9D3) << 16) ^ ((unsigned __int16)v32 ^ HIWORD(v32)) & 0xD9D3 ^ v32;
      v34 = 16 * ((v33 ^ (v33 >> 4)) & 0x5040004) ^ (v33 ^ (v33 >> 4)) & 0x5040004 ^ v33;
      v35 = 2 * ((v34 ^ (v34 >> 1)) & 0x4045015) ^ (v34 ^ (v34 >> 1)) & 0x4045015 ^ v808 ^ v34;
      v36 = 0;
      v809 = v35;
      v37 = 0;
      v38 = 0;
      v39 = v35 ^ *(_DWORD *)(v805 - 388);
      v40 = *(_DWORD *)(v805 - 324) ^ __ROL4__(v35, 4);
      v41 = v40;
      v42 = (v40 >> 8) & 0xFC00FC | 0xFF00FF00;
      v43 = v41 & 0xFC00FC;
      v44 = -167733504;
      v839 = v42;
      v43 |= 0xFF00FF00;
      v45 = v43;
      v46 = v39 & 0xFC00FC | 0xFF00FF00;
      v47 = v42 - v43;
      v824 = v43;
      v866 = v39 & 0xFC00FC | 0xFF00FF00;
      v893 = (v39 >> 8) & 0xFC00FC | 0xFF00FF00;
      v48 = v43;
      v49 = (signed int *)&unk_EF160;
      v50 = 0;
      v51 = v893 - v45;
      v52 = v46 - v45;
      v791 = v47;
      while ( 1 )
      {
        v49 += 4;
        v53 = v29 & (v52 + v48);
        v54 = v27 & (v51 + v48);
        v55 = v48 + v791;
        v38 ^= v48 & v28;
        v48 += 524296;
        v50 ^= v53;
        v36 ^= v54;
        v37 ^= v44 & v55;
        if ( v49 == (signed int *)"triple-DES inner-CBC" )
          break;
        v28 = *v49;
        v44 = v49[1];
        v29 = v49[2];
        v27 = v49[3];
      }
      v56 = 234941184;
      v57 = -2097117952;
      v58 = 2063609344;
      v59 = ((16 * v50 & 15360 * ((v866 + 16777472) & 0x40004) ^ v50) >> 8) & 0xF000F0 | (16 * v36 & 15360 * ((v893 + 16777472) & 0x40004) ^ v36) & 0xF000F000 | ((16 * v37 & 15360 * ((v839 + 16777472) & 0x40004) ^ v37) >> 4) & 0xF000F00 | ((16 * v38 & 15360 * ((v824 + 16777472) & 0x40004) ^ v38) >> 12) & 0xF000F;
      v60 = 16 * ((v59 ^ (v59 >> 4)) & 0x7030702) ^ (v59 ^ (v59 >> 4)) & 0x7030702 ^ v59;
      v61 = (((v60 ^ (v60 >> 8)) & 0x4E009E) << 8) ^ (v60 ^ (v60 >> 8)) & 0x4E009E ^ v60;
      v62 = ((unsigned __int16)((v61 ^ HIWORD(v61)) & 0xD9D3) << 16) ^ ((unsigned __int16)v61 ^ HIWORD(v61)) & 0xD9D3 ^ v61;
      v63 = 16 * ((v62 ^ (v62 >> 4)) & 0x5040004) ^ (v62 ^ (v62 >> 4)) & 0x5040004 ^ v62;
      v64 = 2 * ((v63 ^ (v63 >> 1)) & 0x4045015) ^ (v63 ^ (v63 >> 1)) & 0x4045015 ^ v919 ^ v63;
      v65 = 0;
      v825 = v64;
      v66 = 0;
      v67 = 0;
      v68 = v64 ^ *(_DWORD *)(v805 - 384);
      v69 = *(_DWORD *)(v805 - 320) ^ __ROL4__(v64, 4);
      v70 = v69;
      v71 = (v69 >> 8) & 0xFC00FC | 0xFF00FF00;
      v72 = v70 & 0xFC00FC;
      v73 = -167733504;
      v867 = v71;
      v72 |= 0xFF00FF00;
      v74 = v72;
      v75 = v68 & 0xFC00FC | 0xFF00FF00;
      v76 = v71 - v72;
      v840 = v72;
      v894 = v68 & 0xFC00FC | 0xFF00FF00;
      v920 = (v68 >> 8) & 0xFC00FC | 0xFF00FF00;
      v77 = v72;
      v78 = (signed int *)&unk_EF160;
      v79 = 0;
      v80 = v920 - v74;
      v81 = v75 - v74;
      v792 = v76;
      while ( 1 )
      {
        v78 += 4;
        v82 = v58 & (v81 + v77);
        v83 = v56 & (v80 + v77);
        v84 = v77 + v792;
        v67 ^= v77 & v57;
        v77 += 524296;
        v79 ^= v82;
        v65 ^= v83;
        v66 ^= v73 & v84;
        if ( v78 == (signed int *)"triple-DES inner-CBC" )
          break;
        v57 = *v78;
        v73 = v78[1];
        v58 = v78[2];
        v56 = v78[3];
      }
      v85 = 234941184;
      v86 = -2097117952;
      v87 = 2063609344;
      v88 = ((16 * v79 & 15360 * ((v894 + 16777472) & 0x40004) ^ v79) >> 8) & 0xF000F0 | (16 * v65 & 15360 * ((v920 + 16777472) & 0x40004) ^ v65) & 0xF000F000 | ((16 * v66 & 15360 * ((v867 + 16777472) & 0x40004) ^ v66) >> 4) & 0xF000F00 | ((16 * v67 & 15360 * ((v840 + 16777472) & 0x40004) ^ v67) >> 12) & 0xF000F;
      v89 = 16 * ((v88 ^ (v88 >> 4)) & 0x7030702) ^ (v88 ^ (v88 >> 4)) & 0x7030702 ^ v88;
      v90 = (((v89 ^ (v89 >> 8)) & 0x4E009E) << 8) ^ (v89 ^ (v89 >> 8)) & 0x4E009E ^ v89;
      v91 = ((unsigned __int16)((v90 ^ HIWORD(v90)) & 0xD9D3) << 16) ^ ((unsigned __int16)v90 ^ HIWORD(v90)) & 0xD9D3 ^ v90;
      v92 = 16 * ((v91 ^ (v91 >> 4)) & 0x5040004) ^ (v91 ^ (v91 >> 4)) & 0x5040004 ^ v91;
      v93 = 2 * ((v92 ^ (v92 >> 1)) & 0x4045015) ^ (v92 ^ (v92 >> 1)) & 0x4045015 ^ v809 ^ v92;
      v94 = 0;
      v810 = v93;
      v95 = 0;
      v96 = 0;
      v97 = v93 ^ *(_DWORD *)(v805 - 380);
      v98 = *(_DWORD *)(v805 - 316) ^ __ROL4__(v93, 4);
      v99 = v98;
      v100 = (v98 >> 8) & 0xFC00FC | 0xFF00FF00;
      v101 = v99 & 0xFC00FC;
      v102 = -167733504;
      v868 = v100;
      v101 |= 0xFF00FF00;
      v103 = v101;
      v104 = v97 & 0xFC00FC | 0xFF00FF00;
      v105 = v100 - v101;
      v841 = v101;
      v895 = v97 & 0xFC00FC | 0xFF00FF00;
      v921 = (v97 >> 8) & 0xFC00FC | 0xFF00FF00;
      v106 = v101;
      v107 = (signed int *)&unk_EF160;
      v108 = 0;
      v109 = v921 - v103;
      v110 = v104 - v103;
      v793 = v105;
      while ( 1 )
      {
        v107 += 4;
        v111 = v87 & (v110 + v106);
        v112 = v85 & (v109 + v106);
        v113 = v106 + v793;
        v96 ^= v106 & v86;
        v106 += 524296;
        v108 ^= v111;
        v94 ^= v112;
        v95 ^= v102 & v113;
        if ( v107 == (signed int *)"triple-DES inner-CBC" )
          break;
        v86 = *v107;
        v102 = v107[1];
        v87 = v107[2];
        v85 = v107[3];
      }
      v114 = 234941184;
      v115 = -2097117952;
      v116 = 2063609344;
      v117 = ((16 * v108 & 15360 * ((v895 + 16777472) & 0x40004) ^ v108) >> 8) & 0xF000F0 | (16 * v94 & 15360 * ((v921 + 16777472) & 0x40004) ^ v94) & 0xF000F000 | ((16 * v95 & 15360 * ((v868 + 16777472) & 0x40004) ^ v95) >> 4) & 0xF000F00 | ((16 * v96 & 15360 * ((v841 + 16777472) & 0x40004) ^ v96) >> 12) & 0xF000F;
      v118 = 16 * ((v117 ^ (v117 >> 4)) & 0x7030702) ^ (v117 ^ (v117 >> 4)) & 0x7030702 ^ v117;
      v119 = (((v118 ^ (v118 >> 8)) & 0x4E009E) << 8) ^ (v118 ^ (v118 >> 8)) & 0x4E009E ^ v118;
      v120 = ((unsigned __int16)((v119 ^ HIWORD(v119)) & 0xD9D3) << 16) ^ ((unsigned __int16)v119 ^ HIWORD(v119)) & 0xD9D3 ^ v119;
      v121 = 16 * ((v120 ^ (v120 >> 4)) & 0x5040004) ^ (v120 ^ (v120 >> 4)) & 0x5040004 ^ v120;
      v122 = 2 * ((v121 ^ (v121 >> 1)) & 0x4045015) ^ (v121 ^ (v121 >> 1)) & 0x4045015 ^ v825 ^ v121;
      v123 = 0;
      v826 = v122;
      v124 = 0;
      v125 = 0;
      v126 = v122 ^ *(_DWORD *)(v805 - 376);
      v127 = *(_DWORD *)(v805 - 312) ^ __ROL4__(v122, 4);
      v128 = v127;
      v129 = (v127 >> 8) & 0xFC00FC | 0xFF00FF00;
      v130 = v128 & 0xFC00FC;
      v131 = -167733504;
      v869 = v129;
      v130 |= 0xFF00FF00;
      v132 = v130;
      v133 = v126 & 0xFC00FC | 0xFF00FF00;
      v134 = v129 - v130;
      v842 = v130;
      v896 = v126 & 0xFC00FC | 0xFF00FF00;
      v922 = (v126 >> 8) & 0xFC00FC | 0xFF00FF00;
      v135 = v130;
      v136 = (signed int *)&unk_EF160;
      v137 = 0;
      v138 = v922 - v132;
      v139 = v133 - v132;
      while ( 1 )
      {
        v136 += 4;
        v140 = v114 & (v138 + v135);
        v125 ^= v135 & v115;
        v141 = v135 + v134;
        v137 ^= v116 & (v139 + v135);
        v135 += 524296;
        v123 ^= v140;
        v124 ^= v131 & v141;
        if ( v136 == (signed int *)"triple-DES inner-CBC" )
          break;
        v115 = *v136;
        v131 = v136[1];
        v116 = v136[2];
        v114 = v136[3];
      }
      v142 = 234941184;
      v143 = -2097117952;
      v144 = 2063609344;
      v145 = ((16 * v137 & 15360 * ((v896 + 16777472) & 0x40004) ^ v137) >> 8) & 0xF000F0 | (16 * v123 & 15360 * ((v922 + 16777472) & 0x40004) ^ v123) & 0xF000F000 | ((16 * v124 & 15360 * ((v869 + 16777472) & 0x40004) ^ v124) >> 4) & 0xF000F00 | ((16 * v125 & 15360 * ((v842 + 16777472) & 0x40004) ^ v125) >> 12) & 0xF000F;
      v146 = 16 * ((v145 ^ (v145 >> 4)) & 0x7030702) ^ (v145 ^ (v145 >> 4)) & 0x7030702 ^ v145;
      v147 = (((v146 ^ (v146 >> 8)) & 0x4E009E) << 8) ^ (v146 ^ (v146 >> 8)) & 0x4E009E ^ v146;
      v148 = ((unsigned __int16)((v147 ^ HIWORD(v147)) & 0xD9D3) << 16) ^ ((unsigned __int16)v147 ^ HIWORD(v147)) & 0xD9D3 ^ v147;
      v149 = 16 * ((v148 ^ (v148 >> 4)) & 0x5040004) ^ (v148 ^ (v148 >> 4)) & 0x5040004 ^ v148;
      v150 = 2 * ((v149 ^ (v149 >> 1)) & 0x4045015) ^ (v149 ^ (v149 >> 1)) & 0x4045015 ^ v810 ^ v149;
      v151 = 0;
      v811 = v150;
      v152 = 0;
      v153 = 0;
      v154 = v150 ^ *(_DWORD *)(v805 - 372);
      v155 = *(_DWORD *)(v805 - 308) ^ __ROL4__(v150, 4);
      v156 = v155;
      v157 = (v155 >> 8) & 0xFC00FC | 0xFF00FF00;
      v158 = v156 & 0xFC00FC;
      v159 = -167733504;
      v870 = v157;
      v158 |= 0xFF00FF00;
      v160 = v158;
      v161 = v154 & 0xFC00FC | 0xFF00FF00;
      v162 = v157 - v158;
      v843 = v158;
      v897 = v154 & 0xFC00FC | 0xFF00FF00;
      v923 = (v154 >> 8) & 0xFC00FC | 0xFF00FF00;
      v163 = v158;
      v164 = (signed int *)&unk_EF160;
      v165 = 0;
      v166 = v923 - v160;
      v167 = v161 - v160;
      v794 = v162;
      while ( 1 )
      {
        v164 += 4;
        v168 = v144 & (v167 + v163);
        v169 = v142 & (v166 + v163);
        v170 = v163 + v794;
        v153 ^= v163 & v143;
        v163 += 524296;
        v165 ^= v168;
        v151 ^= v169;
        v152 ^= v159 & v170;
        if ( v164 == (signed int *)"triple-DES inner-CBC" )
          break;
        v143 = *v164;
        v159 = v164[1];
        v144 = v164[2];
        v142 = v164[3];
      }
      v171 = 234941184;
      v172 = -2097117952;
      v173 = 2063609344;
      v174 = ((16 * v165 & 15360 * ((v897 + 16777472) & 0x40004) ^ v165) >> 8) & 0xF000F0 | (16 * v151 & 15360 * ((v923 + 16777472) & 0x40004) ^ v151) & 0xF000F000 | ((16 * v152 & 15360 * ((v870 + 16777472) & 0x40004) ^ v152) >> 4) & 0xF000F00 | ((16 * v153 & 15360 * ((v843 + 16777472) & 0x40004) ^ v153) >> 12) & 0xF000F;
      v175 = 16 * ((v174 ^ (v174 >> 4)) & 0x7030702) ^ (v174 ^ (v174 >> 4)) & 0x7030702 ^ v174;
      v176 = (((v175 ^ (v175 >> 8)) & 0x4E009E) << 8) ^ (v175 ^ (v175 >> 8)) & 0x4E009E ^ v175;
      v177 = ((unsigned __int16)((v176 ^ HIWORD(v176)) & 0xD9D3) << 16) ^ ((unsigned __int16)v176 ^ HIWORD(v176)) & 0xD9D3 ^ v176;
      v178 = 16 * ((v177 ^ (v177 >> 4)) & 0x5040004) ^ (v177 ^ (v177 >> 4)) & 0x5040004 ^ v177;
      v179 = 2 * ((v178 ^ (v178 >> 1)) & 0x4045015) ^ (v178 ^ (v178 >> 1)) & 0x4045015 ^ v826 ^ v178;
      v180 = 0;
      v827 = v179;
      v181 = 0;
      v182 = 0;
      v183 = v179 ^ *(_DWORD *)(v805 - 368);
      v184 = *(_DWORD *)(v805 - 304) ^ __ROL4__(v179, 4);
      v185 = v184;
      v186 = (v184 >> 8) & 0xFC00FC | 0xFF00FF00;
      v187 = v185 & 0xFC00FC;
      v188 = -167733504;
      v871 = v186;
      v187 |= 0xFF00FF00;
      v189 = v187;
      v190 = v183 & 0xFC00FC | 0xFF00FF00;
      v191 = v186 - v187;
      v844 = v187;
      v898 = v183 & 0xFC00FC | 0xFF00FF00;
      v924 = (v183 >> 8) & 0xFC00FC | 0xFF00FF00;
      v192 = v187;
      v193 = (signed int *)&unk_EF160;
      v194 = 0;
      v195 = v924 - v189;
      v196 = v190 - v189;
      while ( 1 )
      {
        v193 += 4;
        v197 = v171 & (v195 + v192);
        v182 ^= v192 & v172;
        v198 = v192 + v191;
        v194 ^= v173 & (v196 + v192);
        v192 += 524296;
        v180 ^= v197;
        v181 ^= v188 & v198;
        if ( v193 == (signed int *)"triple-DES inner-CBC" )
          break;
        v172 = *v193;
        v188 = v193[1];
        v173 = v193[2];
        v171 = v193[3];
      }
      v199 = 234941184;
      v200 = -2097117952;
      v201 = 2063609344;
      v202 = ((16 * v194 & 15360 * ((v898 + 16777472) & 0x40004) ^ v194) >> 8) & 0xF000F0 | (16 * v180 & 15360 * ((v924 + 16777472) & 0x40004) ^ v180) & 0xF000F000 | ((16 * v181 & 15360 * ((v871 + 16777472) & 0x40004) ^ v181) >> 4) & 0xF000F00 | ((16 * v182 & 15360 * ((v844 + 16777472) & 0x40004) ^ v182) >> 12) & 0xF000F;
      v203 = 16 * ((v202 ^ (v202 >> 4)) & 0x7030702) ^ (v202 ^ (v202 >> 4)) & 0x7030702 ^ v202;
      v204 = (((v203 ^ (v203 >> 8)) & 0x4E009E) << 8) ^ (v203 ^ (v203 >> 8)) & 0x4E009E ^ v203;
      v205 = ((unsigned __int16)((v204 ^ HIWORD(v204)) & 0xD9D3) << 16) ^ ((unsigned __int16)v204 ^ HIWORD(v204)) & 0xD9D3 ^ v204;
      v206 = 16 * ((v205 ^ (v205 >> 4)) & 0x5040004) ^ (v205 ^ (v205 >> 4)) & 0x5040004 ^ v205;
      v207 = 2 * ((v206 ^ (v206 >> 1)) & 0x4045015) ^ (v206 ^ (v206 >> 1)) & 0x4045015 ^ v811 ^ v206;
      v208 = 0;
      v812 = v207;
      v209 = 0;
      v210 = 0;
      v211 = v207 ^ *(_DWORD *)(v805 - 364);
      v212 = *(_DWORD *)(v805 - 300) ^ __ROL4__(v207, 4);
      v213 = v212;
      v214 = (v212 >> 8) & 0xFC00FC | 0xFF00FF00;
      v215 = v213 & 0xFC00FC;
      v216 = -167733504;
      v872 = v214;
      v215 |= 0xFF00FF00;
      v217 = v215;
      v218 = v211 & 0xFC00FC | 0xFF00FF00;
      v219 = v214 - v215;
      v845 = v215;
      v899 = v211 & 0xFC00FC | 0xFF00FF00;
      v925 = (v211 >> 8) & 0xFC00FC | 0xFF00FF00;
      v220 = v215;
      v221 = (signed int *)&unk_EF160;
      v222 = 0;
      v223 = v925 - v217;
      v224 = v218 - v217;
      v795 = v219;
      while ( 1 )
      {
        v221 += 4;
        v225 = v201 & (v224 + v220);
        v226 = v199 & (v223 + v220);
        v227 = v220 + v795;
        v210 ^= v220 & v200;
        v220 += 524296;
        v222 ^= v225;
        v208 ^= v226;
        v209 ^= v216 & v227;
        if ( v221 == (signed int *)"triple-DES inner-CBC" )
          break;
        v200 = *v221;
        v216 = v221[1];
        v201 = v221[2];
        v199 = v221[3];
      }
      v228 = 234941184;
      v229 = -2097117952;
      v230 = 2063609344;
      v231 = ((16 * v222 & 15360 * ((v899 + 16777472) & 0x40004) ^ v222) >> 8) & 0xF000F0 | (16 * v208 & 15360 * ((v925 + 16777472) & 0x40004) ^ v208) & 0xF000F000 | ((16 * v209 & 15360 * ((v872 + 16777472) & 0x40004) ^ v209) >> 4) & 0xF000F00 | ((16 * v210 & 15360 * ((v845 + 16777472) & 0x40004) ^ v210) >> 12) & 0xF000F;
      v232 = 16 * ((v231 ^ (v231 >> 4)) & 0x7030702) ^ (v231 ^ (v231 >> 4)) & 0x7030702 ^ v231;
      v233 = (((v232 ^ (v232 >> 8)) & 0x4E009E) << 8) ^ (v232 ^ (v232 >> 8)) & 0x4E009E ^ v232;
      v234 = ((unsigned __int16)((v233 ^ HIWORD(v233)) & 0xD9D3) << 16) ^ ((unsigned __int16)v233 ^ HIWORD(v233)) & 0xD9D3 ^ v233;
      v235 = 16 * ((v234 ^ (v234 >> 4)) & 0x5040004) ^ (v234 ^ (v234 >> 4)) & 0x5040004 ^ v234;
      v236 = 2 * ((v235 ^ (v235 >> 1)) & 0x4045015) ^ (v235 ^ (v235 >> 1)) & 0x4045015 ^ v827 ^ v235;
      v237 = 0;
      v828 = v236;
      v238 = 0;
      v239 = 0;
      v240 = v236 ^ *(_DWORD *)(v805 - 360);
      v241 = *(_DWORD *)(v805 - 296) ^ __ROL4__(v236, 4);
      v242 = v241;
      v243 = (v241 >> 8) & 0xFC00FC | 0xFF00FF00;
      v244 = v242 & 0xFC00FC;
      v245 = -167733504;
      v873 = v243;
      v244 |= 0xFF00FF00;
      v246 = v244;
      v247 = v240 & 0xFC00FC | 0xFF00FF00;
      v248 = v243 - v244;
      v846 = v244;
      v900 = v240 & 0xFC00FC | 0xFF00FF00;
      v926 = (v240 >> 8) & 0xFC00FC | 0xFF00FF00;
      v249 = v244;
      v250 = (signed int *)&unk_EF160;
      v251 = 0;
      v252 = v926 - v246;
      v253 = v247 - v246;
      while ( 1 )
      {
        v250 += 4;
        v254 = v228 & (v252 + v249);
        v239 ^= v249 & v229;
        v255 = v249 + v248;
        v251 ^= v230 & (v253 + v249);
        v249 += 524296;
        v237 ^= v254;
        v238 ^= v245 & v255;
        if ( v250 == (signed int *)"triple-DES inner-CBC" )
          break;
        v229 = *v250;
        v245 = v250[1];
        v230 = v250[2];
        v228 = v250[3];
      }
      v256 = 234941184;
      v257 = -2097117952;
      v258 = 2063609344;
      v259 = ((16 * v251 & 15360 * ((v900 + 16777472) & 0x40004) ^ v251) >> 8) & 0xF000F0 | (16 * v237 & 15360 * ((v926 + 16777472) & 0x40004) ^ v237) & 0xF000F000 | ((16 * v238 & 15360 * ((v873 + 16777472) & 0x40004) ^ v238) >> 4) & 0xF000F00 | ((16 * v239 & 15360 * ((v846 + 16777472) & 0x40004) ^ v239) >> 12) & 0xF000F;
      v260 = 16 * ((v259 ^ (v259 >> 4)) & 0x7030702) ^ (v259 ^ (v259 >> 4)) & 0x7030702 ^ v259;
      v261 = (((v260 ^ (v260 >> 8)) & 0x4E009E) << 8) ^ (v260 ^ (v260 >> 8)) & 0x4E009E ^ v260;
      v262 = ((unsigned __int16)((v261 ^ HIWORD(v261)) & 0xD9D3) << 16) ^ ((unsigned __int16)v261 ^ HIWORD(v261)) & 0xD9D3 ^ v261;
      v263 = 16 * ((v262 ^ (v262 >> 4)) & 0x5040004) ^ (v262 ^ (v262 >> 4)) & 0x5040004 ^ v262;
      v264 = 2 * ((v263 ^ (v263 >> 1)) & 0x4045015) ^ (v263 ^ (v263 >> 1)) & 0x4045015 ^ v812 ^ v263;
      v265 = 0;
      v813 = v264;
      v266 = 0;
      v267 = 0;
      v268 = v264 ^ *(_DWORD *)(v805 - 356);
      v269 = *(_DWORD *)(v805 - 292) ^ __ROL4__(v264, 4);
      v270 = v269;
      v271 = (v269 >> 8) & 0xFC00FC | 0xFF00FF00;
      v272 = v270 & 0xFC00FC;
      v273 = -167733504;
      v874 = v271;
      v272 |= 0xFF00FF00;
      v274 = v272;
      v275 = v268 & 0xFC00FC | 0xFF00FF00;
      v276 = v271 - v272;
      v847 = v272;
      v901 = v268 & 0xFC00FC | 0xFF00FF00;
      v927 = (v268 >> 8) & 0xFC00FC | 0xFF00FF00;
      v277 = v272;
      v278 = (signed int *)&unk_EF160;
      v279 = 0;
      v280 = v927 - v274;
      v281 = v275 - v274;
      v796 = v276;
      while ( 1 )
      {
        v278 += 4;
        v282 = v258 & (v281 + v277);
        v283 = v256 & (v280 + v277);
        v284 = v277 + v796;
        v267 ^= v277 & v257;
        v277 += 524296;
        v279 ^= v282;
        v265 ^= v283;
        v266 ^= v273 & v284;
        if ( v278 == (signed int *)"triple-DES inner-CBC" )
          break;
        v257 = *v278;
        v273 = v278[1];
        v258 = v278[2];
        v256 = v278[3];
      }
      v285 = 234941184;
      v286 = -2097117952;
      v287 = 2063609344;
      v288 = ((16 * v279 & 15360 * ((v901 + 16777472) & 0x40004) ^ v279) >> 8) & 0xF000F0 | (16 * v265 & 15360 * ((v927 + 16777472) & 0x40004) ^ v265) & 0xF000F000 | ((16 * v266 & 15360 * ((v874 + 16777472) & 0x40004) ^ v266) >> 4) & 0xF000F00 | ((16 * v267 & 15360 * ((v847 + 16777472) & 0x40004) ^ v267) >> 12) & 0xF000F;
      v289 = 16 * ((v288 ^ (v288 >> 4)) & 0x7030702) ^ (v288 ^ (v288 >> 4)) & 0x7030702 ^ v288;
      v290 = (((v289 ^ (v289 >> 8)) & 0x4E009E) << 8) ^ (v289 ^ (v289 >> 8)) & 0x4E009E ^ v289;
      v291 = ((unsigned __int16)((v290 ^ HIWORD(v290)) & 0xD9D3) << 16) ^ ((unsigned __int16)v290 ^ HIWORD(v290)) & 0xD9D3 ^ v290;
      v292 = 16 * ((v291 ^ (v291 >> 4)) & 0x5040004) ^ (v291 ^ (v291 >> 4)) & 0x5040004 ^ v291;
      v293 = 2 * ((v292 ^ (v292 >> 1)) & 0x4045015) ^ (v292 ^ (v292 >> 1)) & 0x4045015 ^ v828 ^ v292;
      v294 = 0;
      v829 = v293;
      v295 = 0;
      v296 = 0;
      v297 = v293 ^ *(_DWORD *)(v805 - 352);
      v298 = *(_DWORD *)(v805 - 288) ^ __ROL4__(v293, 4);
      v299 = v298;
      v300 = (v298 >> 8) & 0xFC00FC | 0xFF00FF00;
      v301 = v299 & 0xFC00FC;
      v302 = -167733504;
      v875 = v300;
      v301 |= 0xFF00FF00;
      v303 = v301;
      v304 = v297 & 0xFC00FC | 0xFF00FF00;
      v305 = v300 - v301;
      v848 = v301;
      v902 = v297 & 0xFC00FC | 0xFF00FF00;
      v928 = (v297 >> 8) & 0xFC00FC | 0xFF00FF00;
      v306 = v301;
      v307 = (signed int *)&unk_EF160;
      v308 = 0;
      v309 = v928 - v303;
      v310 = v304 - v303;
      while ( 1 )
      {
        v307 += 4;
        v311 = v285 & (v309 + v306);
        v296 ^= v306 & v286;
        v312 = v306 + v305;
        v308 ^= v287 & (v310 + v306);
        v306 += 524296;
        v294 ^= v311;
        v295 ^= v302 & v312;
        if ( v307 == (signed int *)"triple-DES inner-CBC" )
          break;
        v286 = *v307;
        v302 = v307[1];
        v287 = v307[2];
        v285 = v307[3];
      }
      v313 = 234941184;
      v314 = -2097117952;
      v315 = 2063609344;
      v316 = ((16 * v308 & 15360 * ((v902 + 16777472) & 0x40004) ^ v308) >> 8) & 0xF000F0 | (16 * v294 & 15360 * ((v928 + 16777472) & 0x40004) ^ v294) & 0xF000F000 | ((16 * v295 & 15360 * ((v875 + 16777472) & 0x40004) ^ v295) >> 4) & 0xF000F00 | ((16 * v296 & 15360 * ((v848 + 16777472) & 0x40004) ^ v296) >> 12) & 0xF000F;
      v317 = 16 * ((v316 ^ (v316 >> 4)) & 0x7030702) ^ (v316 ^ (v316 >> 4)) & 0x7030702 ^ v316;
      v318 = (((v317 ^ (v317 >> 8)) & 0x4E009E) << 8) ^ (v317 ^ (v317 >> 8)) & 0x4E009E ^ v317;
      v319 = ((unsigned __int16)((v318 ^ HIWORD(v318)) & 0xD9D3) << 16) ^ ((unsigned __int16)v318 ^ HIWORD(v318)) & 0xD9D3 ^ v318;
      v320 = 16 * ((v319 ^ (v319 >> 4)) & 0x5040004) ^ (v319 ^ (v319 >> 4)) & 0x5040004 ^ v319;
      v321 = 2 * ((v320 ^ (v320 >> 1)) & 0x4045015) ^ (v320 ^ (v320 >> 1)) & 0x4045015 ^ v813 ^ v320;
      v322 = 0;
      v814 = v321;
      v323 = 0;
      v324 = 0;
      v325 = v321 ^ *(_DWORD *)(v805 - 348);
      v326 = *(_DWORD *)(v805 - 284) ^ __ROL4__(v321, 4);
      v327 = v326;
      v328 = (v326 >> 8) & 0xFC00FC | 0xFF00FF00;
      v329 = v327 & 0xFC00FC;
      v330 = -167733504;
      v876 = v328;
      v329 |= 0xFF00FF00;
      v331 = v329;
      v332 = v325 & 0xFC00FC | 0xFF00FF00;
      v333 = v328 - v329;
      v849 = v329;
      v903 = v325 & 0xFC00FC | 0xFF00FF00;
      v929 = (v325 >> 8) & 0xFC00FC | 0xFF00FF00;
      v334 = v329;
      v335 = (signed int *)&unk_EF160;
      v336 = 0;
      v337 = v929 - v331;
      v338 = v332 - v331;
      v797 = v333;
      while ( 1 )
      {
        v335 += 4;
        v339 = v315 & (v338 + v334);
        v340 = v313 & (v337 + v334);
        v341 = v334 + v797;
        v324 ^= v334 & v314;
        v334 += 524296;
        v336 ^= v339;
        v322 ^= v340;
        v323 ^= v330 & v341;
        if ( v335 == (signed int *)"triple-DES inner-CBC" )
          break;
        v314 = *v335;
        v330 = v335[1];
        v315 = v335[2];
        v313 = v335[3];
      }
      v342 = 234941184;
      v343 = -2097117952;
      v344 = 2063609344;
      v345 = ((16 * v336 & 15360 * ((v903 + 16777472) & 0x40004) ^ v336) >> 8) & 0xF000F0 | (16 * v322 & 15360 * ((v929 + 16777472) & 0x40004) ^ v322) & 0xF000F000 | ((16 * v323 & 15360 * ((v876 + 16777472) & 0x40004) ^ v323) >> 4) & 0xF000F00 | ((16 * v324 & 15360 * ((v849 + 16777472) & 0x40004) ^ v324) >> 12) & 0xF000F;
      v346 = 16 * ((v345 ^ (v345 >> 4)) & 0x7030702) ^ (v345 ^ (v345 >> 4)) & 0x7030702 ^ v345;
      v347 = (((v346 ^ (v346 >> 8)) & 0x4E009E) << 8) ^ (v346 ^ (v346 >> 8)) & 0x4E009E ^ v346;
      v348 = ((unsigned __int16)((v347 ^ HIWORD(v347)) & 0xD9D3) << 16) ^ ((unsigned __int16)v347 ^ HIWORD(v347)) & 0xD9D3 ^ v347;
      v349 = 16 * ((v348 ^ (v348 >> 4)) & 0x5040004) ^ (v348 ^ (v348 >> 4)) & 0x5040004 ^ v348;
      v350 = 2 * ((v349 ^ (v349 >> 1)) & 0x4045015) ^ (v349 ^ (v349 >> 1)) & 0x4045015 ^ v829 ^ v349;
      v351 = 0;
      v830 = v350;
      v352 = 0;
      v353 = 0;
      v354 = v350 ^ *(_DWORD *)(v805 - 344);
      v355 = *(_DWORD *)(v805 - 280) ^ __ROL4__(v350, 4);
      v356 = v355;
      v357 = (v355 >> 8) & 0xFC00FC | 0xFF00FF00;
      v358 = v356 & 0xFC00FC;
      v359 = -167733504;
      v877 = v357;
      v358 |= 0xFF00FF00;
      v360 = v358;
      v361 = v354 & 0xFC00FC | 0xFF00FF00;
      v362 = v357 - v358;
      v850 = v358;
      v904 = v354 & 0xFC00FC | 0xFF00FF00;
      v930 = (v354 >> 8) & 0xFC00FC | 0xFF00FF00;
      v363 = v358;
      v364 = (signed int *)&unk_EF160;
      v365 = 0;
      v366 = v930 - v360;
      v367 = v361 - v360;
      while ( 1 )
      {
        v364 += 4;
        v368 = v342 & (v366 + v363);
        v353 ^= v363 & v343;
        v369 = v363 + v362;
        v365 ^= v344 & (v367 + v363);
        v363 += 524296;
        v351 ^= v368;
        v352 ^= v359 & v369;
        if ( v364 == (signed int *)"triple-DES inner-CBC" )
          break;
        v343 = *v364;
        v359 = v364[1];
        v344 = v364[2];
        v342 = v364[3];
      }
      v370 = 234941184;
      v371 = -2097117952;
      v372 = 2063609344;
      v373 = ((16 * v365 & 15360 * ((v904 + 16777472) & 0x40004) ^ v365) >> 8) & 0xF000F0 | (16 * v351 & 15360 * ((v930 + 16777472) & 0x40004) ^ v351) & 0xF000F000 | ((16 * v352 & 15360 * ((v877 + 16777472) & 0x40004) ^ v352) >> 4) & 0xF000F00 | ((16 * v353 & 15360 * ((v850 + 16777472) & 0x40004) ^ v353) >> 12) & 0xF000F;
      v374 = 16 * ((v373 ^ (v373 >> 4)) & 0x7030702) ^ (v373 ^ (v373 >> 4)) & 0x7030702 ^ v373;
      v375 = (((v374 ^ (v374 >> 8)) & 0x4E009E) << 8) ^ (v374 ^ (v374 >> 8)) & 0x4E009E ^ v374;
      v376 = ((unsigned __int16)((v375 ^ HIWORD(v375)) & 0xD9D3) << 16) ^ ((unsigned __int16)v375 ^ HIWORD(v375)) & 0xD9D3 ^ v375;
      v377 = 16 * ((v376 ^ (v376 >> 4)) & 0x5040004) ^ (v376 ^ (v376 >> 4)) & 0x5040004 ^ v376;
      v378 = 2 * ((v377 ^ (v377 >> 1)) & 0x4045015) ^ (v377 ^ (v377 >> 1)) & 0x4045015 ^ v814 ^ v377;
      v379 = 0;
      v815 = v378;
      v380 = 0;
      v381 = 0;
      v382 = v378 ^ *(_DWORD *)(v805 - 340);
      v383 = *(_DWORD *)(v805 - 276) ^ __ROL4__(v378, 4);
      v384 = v383;
      v385 = (v383 >> 8) & 0xFC00FC | 0xFF00FF00;
      v386 = v384 & 0xFC00FC;
      v387 = -167733504;
      v878 = v385;
      v386 |= 0xFF00FF00;
      v388 = v386;
      v389 = v382 & 0xFC00FC | 0xFF00FF00;
      v390 = v385 - v386;
      v851 = v386;
      v905 = v382 & 0xFC00FC | 0xFF00FF00;
      v931 = (v382 >> 8) & 0xFC00FC | 0xFF00FF00;
      v391 = v386;
      v392 = (signed int *)&unk_EF160;
      v393 = 0;
      v394 = v931 - v388;
      v395 = v389 - v388;
      v798 = v390;
      while ( 1 )
      {
        v392 += 4;
        v396 = v372 & (v395 + v391);
        v397 = v370 & (v394 + v391);
        v398 = v391 + v798;
        v381 ^= v391 & v371;
        v391 += 524296;
        v393 ^= v396;
        v379 ^= v397;
        v380 ^= v387 & v398;
        if ( v392 == (signed int *)"triple-DES inner-CBC" )
          break;
        v371 = *v392;
        v387 = v392[1];
        v372 = v392[2];
        v370 = v392[3];
      }
      v399 = 234941184;
      v400 = -2097117952;
      v401 = 2063609344;
      v402 = ((16 * v393 & 15360 * ((v905 + 16777472) & 0x40004) ^ v393) >> 8) & 0xF000F0 | (16 * v379 & 15360 * ((v931 + 16777472) & 0x40004) ^ v379) & 0xF000F000 | ((16 * v380 & 15360 * ((v878 + 16777472) & 0x40004) ^ v380) >> 4) & 0xF000F00 | ((16 * v381 & 15360 * ((v851 + 16777472) & 0x40004) ^ v381) >> 12) & 0xF000F;
      v403 = 16 * ((v402 ^ (v402 >> 4)) & 0x7030702) ^ (v402 ^ (v402 >> 4)) & 0x7030702 ^ v402;
      v404 = (((v403 ^ (v403 >> 8)) & 0x4E009E) << 8) ^ (v403 ^ (v403 >> 8)) & 0x4E009E ^ v403;
      v405 = ((unsigned __int16)((v404 ^ HIWORD(v404)) & 0xD9D3) << 16) ^ ((unsigned __int16)v404 ^ HIWORD(v404)) & 0xD9D3 ^ v404;
      v406 = 16 * ((v405 ^ (v405 >> 4)) & 0x5040004) ^ (v405 ^ (v405 >> 4)) & 0x5040004 ^ v405;
      v407 = 2 * ((v406 ^ (v406 >> 1)) & 0x4045015) ^ (v406 ^ (v406 >> 1)) & 0x4045015 ^ v830 ^ v406;
      v408 = 0;
      v831 = v407;
      v409 = 0;
      v410 = 0;
      v411 = v407 ^ *(_DWORD *)(v805 - 336);
      v412 = *(_DWORD *)(v805 - 272) ^ __ROL4__(v407, 4);
      v413 = v412;
      v414 = (v412 >> 8) & 0xFC00FC | 0xFF00FF00;
      v415 = v413 & 0xFC00FC;
      v416 = -167733504;
      v879 = v414;
      v415 |= 0xFF00FF00;
      v417 = v415;
      v418 = v411 & 0xFC00FC | 0xFF00FF00;
      v419 = v414 - v415;
      v852 = v415;
      v906 = v411 & 0xFC00FC | 0xFF00FF00;
      v932 = (v411 >> 8) & 0xFC00FC | 0xFF00FF00;
      v420 = v415;
      v421 = (signed int *)&unk_EF160;
      v422 = 0;
      v423 = v932 - v417;
      v424 = v418 - v417;
      while ( 1 )
      {
        v421 += 4;
        v425 = v399 & (v423 + v420);
        v410 ^= v420 & v400;
        v426 = v420 + v419;
        v422 ^= v401 & (v424 + v420);
        v420 += 524296;
        v408 ^= v425;
        v409 ^= v416 & v426;
        if ( v421 == (signed int *)"triple-DES inner-CBC" )
          break;
        v400 = *v421;
        v416 = v421[1];
        v401 = v421[2];
        v399 = v421[3];
      }
      v427 = 234941184;
      v428 = -2097117952;
      v429 = 2063609344;
      v430 = ((16 * v422 & 15360 * ((v906 + 16777472) & 0x40004) ^ v422) >> 8) & 0xF000F0 | (16 * v408 & 15360 * ((v932 + 16777472) & 0x40004) ^ v408) & 0xF000F000 | ((16 * v409 & 15360 * ((v879 + 16777472) & 0x40004) ^ v409) >> 4) & 0xF000F00 | ((16 * v410 & 15360 * ((v852 + 16777472) & 0x40004) ^ v410) >> 12) & 0xF000F;
      v431 = 16 * ((v430 ^ (v430 >> 4)) & 0x7030702) ^ (v430 ^ (v430 >> 4)) & 0x7030702 ^ v430;
      v432 = (((v431 ^ (v431 >> 8)) & 0x4E009E) << 8) ^ (v431 ^ (v431 >> 8)) & 0x4E009E ^ v431;
      v433 = ((unsigned __int16)((v432 ^ HIWORD(v432)) & 0xD9D3) << 16) ^ ((unsigned __int16)v432 ^ HIWORD(v432)) & 0xD9D3 ^ v432;
      v434 = 16 * ((v433 ^ (v433 >> 4)) & 0x5040004) ^ (v433 ^ (v433 >> 4)) & 0x5040004 ^ v433;
      v435 = 2 * ((v434 ^ (v434 >> 1)) & 0x4045015) ^ (v434 ^ (v434 >> 1)) & 0x4045015 ^ v815 ^ v434;
      v436 = 0;
      LODWORD(v807) = v435;
      v437 = 0;
      v438 = 0;
      v439 = v435 ^ *(_DWORD *)(v805 - 332);
      v440 = *(_DWORD *)(v805 - 268) ^ __ROL4__(v435, 4);
      v441 = v440;
      v442 = (v440 >> 8) & 0xFC00FC | 0xFF00FF00;
      v443 = v441 & 0xFC00FC;
      v444 = -167733504;
      v880 = v442;
      v443 |= 0xFF00FF00;
      v445 = v443;
      v446 = v439 & 0xFC00FC | 0xFF00FF00;
      v447 = v442 - v443;
      v853 = v443;
      v907 = v439 & 0xFC00FC | 0xFF00FF00;
      v933 = (v439 >> 8) & 0xFC00FC | 0xFF00FF00;
      v448 = v443;
      v449 = (signed int *)&unk_EF160;
      v450 = 0;
      v451 = v933 - v445;
      v452 = v446 - v445;
      v799 = v447;
      while ( 1 )
      {
        v449 += 4;
        v453 = v429 & (v452 + v448);
        v454 = v427 & (v451 + v448);
        v455 = v448 + v799;
        v438 ^= v448 & v428;
        v448 += 524296;
        v450 ^= v453;
        v436 ^= v454;
        v437 ^= v444 & v455;
        if ( v449 == (signed int *)"triple-DES inner-CBC" )
          break;
        v428 = *v449;
        v444 = v449[1];
        v429 = v449[2];
        v427 = v449[3];
      }
      v456 = ((16 * v450 & 15360 * ((v907 + 16777472) & 0x40004) ^ v450) >> 8) & 0xF000F0 | (16 * v436 & 15360 * ((v933 + 16777472) & 0x40004) ^ v436) & 0xF000F000 | ((16 * v437 & 15360 * ((v880 + 16777472) & 0x40004) ^ v437) >> 4) & 0xF000F00 | ((16 * v438 & 15360 * ((v853 + 16777472) & 0x40004) ^ v438) >> 12) & 0xF000F;
      v457 = (v456 ^ (v456 >> 4)) & 0x7030702;
      v458 = (((16 * v457 ^ v457 ^ v456 ^ ((16 * v457 ^ v457 ^ v456) >> 8)) & 0x4E009E) << 8) ^ (16 * v457 ^ v457 ^ v456 ^ ((16 * v457 ^ v457 ^ v456) >> 8)) & 0x4E009E ^ 16 * v457 ^ v457 ^ v456;
      v459 = ((unsigned __int16)((v458 ^ HIWORD(v458)) & 0xD9D3) << 16) ^ ((unsigned __int16)v458 ^ HIWORD(v458)) & 0xD9D3 ^ v458;
      v460 = 16 * ((v459 ^ (v459 >> 4)) & 0x5040004) ^ (v459 ^ (v459 >> 4)) & 0x5040004 ^ v459;
      v461 = 0;
      v462 = 0;
      v463 = sub_634C0(
               (v807 << 32) | 2 * ((v460 ^ (v460 >> 1)) & 0x4045015) ^ (v460 ^ (v460 >> 1)) & 0x4045015 ^ v460 ^ v831,
               v946,
               15LL,
               -1LL);
      v816 = v463;
      v463 >>= 32;
      v934 = v463;
      v464 = 234941184;
      v465 = 2063609344;
      v466 = -2097117952;
      v467 = 0;
      v468 = v463 ^ *(_DWORD *)(v805 - 136);
      LODWORD(v463) = *(_DWORD *)(v805 - 72) ^ __ROL4__(v463, 4);
      v469 = v463;
      LODWORD(v463) = ((unsigned int)v463 >> 8) & 0xFC00FC | 0xFF00FF00;
      v470 = v469 & 0xFC00FC;
      v471 = -167733504;
      v854 = v463;
      v470 |= 0xFF00FF00;
      v472 = v470;
      v473 = v468 & 0xFC00FC | 0xFF00FF00;
      v474 = v463 - v470;
      v832 = v470;
      v881 = v468 & 0xFC00FC | 0xFF00FF00;
      v908 = (v468 >> 8) & 0xFC00FC | 0xFF00FF00;
      v475 = v470;
      v476 = (signed int *)&unk_EF160;
      v477 = 0;
      v478 = v908 - v472;
      v479 = v473 - v472;
      while ( 1 )
      {
        v476 += 4;
        v480 = v464 & (v478 + v475);
        v467 ^= v475 & v466;
        v481 = v475 + v474;
        v477 ^= v465 & (v479 + v475);
        v475 += 524296;
        v461 ^= v480;
        v462 ^= v471 & v481;
        if ( v476 == (signed int *)"triple-DES inner-CBC" )
          break;
        v466 = *v476;
        v471 = v476[1];
        v465 = v476[2];
        v464 = v476[3];
      }
      v482 = v805;
      v483 = ((16 * v477 & 15360 * ((v881 + 16777472) & 0x40004) ^ v477) >> 8) & 0xF000F0 | (16 * v461 & 15360 * ((v908 + 16777472) & 0x40004) ^ v461) & 0xF000F000 | ((16 * v462 & 15360 * ((v854 + 16777472) & 0x40004) ^ v462) >> 4) & 0xF000F00 | ((16 * v467 & 15360 * ((v832 + 16777472) & 0x40004) ^ v467) >> 12) & 0xF000F;
      v484 = 16 * ((v483 ^ (v483 >> 4)) & 0x7030702) ^ (v483 ^ (v483 >> 4)) & 0x7030702 ^ v483;
      v485 = (((v484 ^ (v484 >> 8)) & 0x4E009E) << 8) ^ (v484 ^ (v484 >> 8)) & 0x4E009E ^ v484;
      v486 = ((unsigned __int16)((v485 ^ HIWORD(v485)) & 0xD9D3) << 16) ^ ((unsigned __int16)v485 ^ HIWORD(v485)) & 0xD9D3 ^ v485;
      v487 = 16 * ((v486 ^ (v486 >> 4)) & 0x5040004) ^ (v486 ^ (v486 >> 4)) & 0x5040004 ^ v486;
      v488 = 2 * ((v487 ^ (v487 >> 1)) & 0x4045015) ^ (v487 ^ (v487 >> 1)) & 0x4045015 ^ v487 ^ v816;
      v489 = 0;
      v490 = 0;
      v491 = (unsigned __int64)sub_630F0(v488, *(_DWORD *)(v805 - 132), *(_DWORD *)(v805 - 68)) ^ v934;
      v492 = (unsigned __int64)sub_630F0(v491, *(_DWORD *)(v482 - 128), *(_DWORD *)(v482 - 64)) ^ v488;
      v493 = (unsigned __int64)sub_630F0(v492, *(_DWORD *)(v482 - 124), *(_DWORD *)(v482 - 60)) ^ v491;
      v817 = (unsigned __int64)sub_630F0(v493, *(_DWORD *)(v482 - 120), *(_DWORD *)(v482 - 56)) ^ v492;
      v494 = (unsigned __int64)sub_630F0(v817, *(_DWORD *)(v482 - 116), *(_DWORD *)(v482 - 52)) ^ v493;
      v495 = 234941184;
      v833 = v494;
      v496 = 2063609344;
      v497 = *(_DWORD *)(v805 - 48) ^ __ROL4__(v494, 4);
      v498 = -2097117952;
      v499 = v494 ^ *(_DWORD *)(v805 - 112);
      v500 = 0;
      v501 = v497;
      v502 = (v497 >> 8) & 0xFC00FC | 0xFF00FF00;
      v503 = v501 & 0xFC00FC;
      v504 = -167733504;
      v882 = v502;
      v503 |= 0xFF00FF00;
      v505 = v503;
      LODWORD(v482) = v499 & 0xFC00FC | 0xFF00FF00;
      v506 = v502 - v503;
      v855 = v503;
      v909 = v499 & 0xFC00FC | 0xFF00FF00;
      v935 = (v499 >> 8) & 0xFC00FC | 0xFF00FF00;
      v507 = v503;
      v508 = (signed int *)&unk_EF160;
      v509 = 0;
      v510 = v935 - v505;
      v511 = v482 - v505;
      v800 = v506;
      while ( 1 )
      {
        v508 += 4;
        v512 = v496 & (v511 + v507);
        v513 = v495 & (v510 + v507);
        v514 = v507 + v800;
        v490 ^= v507 & v498;
        v507 += 524296;
        v509 ^= v512;
        v489 ^= v513;
        v500 ^= v504 & v514;
        if ( v508 == (signed int *)"triple-DES inner-CBC" )
          break;
        v498 = *v508;
        v504 = v508[1];
        v496 = v508[2];
        v495 = v508[3];
      }
      v515 = 234941184;
      v516 = -2097117952;
      v517 = 2063609344;
      v518 = ((16 * v509 & 15360 * ((v909 + 16777472) & 0x40004) ^ v509) >> 8) & 0xF000F0 | (16 * v489 & 15360 * ((v935 + 16777472) & 0x40004) ^ v489) & 0xF000F000 | ((16 * v500 & 15360 * ((v882 + 16777472) & 0x40004) ^ v500) >> 4) & 0xF000F00 | ((16 * v490 & 15360 * ((v855 + 16777472) & 0x40004) ^ v490) >> 12) & 0xF000F;
      v519 = 16 * ((v518 ^ (v518 >> 4)) & 0x7030702) ^ (v518 ^ (v518 >> 4)) & 0x7030702 ^ v518;
      v520 = (((v519 ^ (v519 >> 8)) & 0x4E009E) << 8) ^ (v519 ^ (v519 >> 8)) & 0x4E009E ^ v519;
      v521 = ((unsigned __int16)((v520 ^ HIWORD(v520)) & 0xD9D3) << 16) ^ ((unsigned __int16)v520 ^ HIWORD(v520)) & 0xD9D3 ^ v520;
      v522 = 16 * ((v521 ^ (v521 >> 4)) & 0x5040004) ^ (v521 ^ (v521 >> 4)) & 0x5040004 ^ v521;
      v523 = 2 * ((v522 ^ (v522 >> 1)) & 0x4045015) ^ (v522 ^ (v522 >> 1)) & 0x4045015 ^ v817 ^ v522;
      v524 = 0;
      v818 = v523;
      v525 = 0;
      v526 = 0;
      v527 = v523 ^ *(_DWORD *)(v805 - 108);
      v528 = *(_DWORD *)(v805 - 44) ^ __ROL4__(v523, 4);
      v529 = v528;
      v530 = (v528 >> 8) & 0xFC00FC | 0xFF00FF00;
      v531 = v529 & 0xFC00FC;
      v532 = -167733504;
      v883 = v530;
      v531 |= 0xFF00FF00;
      v533 = v531;
      v534 = v527 & 0xFC00FC | 0xFF00FF00;
      v535 = v530 - v531;
      v856 = v531;
      v910 = v527 & 0xFC00FC | 0xFF00FF00;
      v936 = (v527 >> 8) & 0xFC00FC | 0xFF00FF00;
      v536 = v531;
      v537 = (signed int *)&unk_EF160;
      v538 = 0;
      v539 = v936 - v533;
      v540 = v534 - v533;
      while ( 1 )
      {
        v537 += 4;
        v541 = v515 & (v539 + v536);
        v526 ^= v536 & v516;
        v542 = v536 + v535;
        v538 ^= v517 & (v540 + v536);
        v536 += 524296;
        v524 ^= v541;
        v525 ^= v532 & v542;
        if ( v537 == (signed int *)"triple-DES inner-CBC" )
          break;
        v516 = *v537;
        v532 = v537[1];
        v517 = v537[2];
        v515 = v537[3];
      }
      v543 = 234941184;
      v544 = -2097117952;
      v545 = 2063609344;
      v546 = ((16 * v538 & 15360 * ((v910 + 16777472) & 0x40004) ^ v538) >> 8) & 0xF000F0 | (16 * v524 & 15360 * ((v936 + 16777472) & 0x40004) ^ v524) & 0xF000F000 | ((16 * v525 & 15360 * ((v883 + 16777472) & 0x40004) ^ v525) >> 4) & 0xF000F00 | ((16 * v526 & 15360 * ((v856 + 16777472) & 0x40004) ^ v526) >> 12) & 0xF000F;
      v547 = 16 * ((v546 ^ (v546 >> 4)) & 0x7030702) ^ (v546 ^ (v546 >> 4)) & 0x7030702 ^ v546;
      v548 = (((v547 ^ (v547 >> 8)) & 0x4E009E) << 8) ^ (v547 ^ (v547 >> 8)) & 0x4E009E ^ v547;
      v549 = ((unsigned __int16)((v548 ^ HIWORD(v548)) & 0xD9D3) << 16) ^ ((unsigned __int16)v548 ^ HIWORD(v548)) & 0xD9D3 ^ v548;
      v550 = 16 * ((v549 ^ (v549 >> 4)) & 0x5040004) ^ (v549 ^ (v549 >> 4)) & 0x5040004 ^ v549;
      v551 = 2 * ((v550 ^ (v550 >> 1)) & 0x4045015) ^ (v550 ^ (v550 >> 1)) & 0x4045015 ^ v833 ^ v550;
      v552 = 0;
      v834 = v551;
      v553 = 0;
      v554 = 0;
      v555 = v551 ^ *(_DWORD *)(v805 - 104);
      v556 = *(_DWORD *)(v805 - 40) ^ __ROL4__(v551, 4);
      v557 = v556;
      v558 = (v556 >> 8) & 0xFC00FC | 0xFF00FF00;
      v559 = v557 & 0xFC00FC;
      v560 = -167733504;
      v884 = v558;
      v559 |= 0xFF00FF00;
      v561 = v559;
      v562 = v555 & 0xFC00FC | 0xFF00FF00;
      v563 = v558 - v559;
      v857 = v559;
      v911 = v555 & 0xFC00FC | 0xFF00FF00;
      v937 = (v555 >> 8) & 0xFC00FC | 0xFF00FF00;
      v564 = v559;
      v565 = (signed int *)&unk_EF160;
      v566 = 0;
      v567 = v937 - v561;
      v568 = v562 - v561;
      v801 = v563;
      while ( 1 )
      {
        v565 += 4;
        v569 = v545 & (v568 + v564);
        v570 = v543 & (v567 + v564);
        v571 = v564 + v801;
        v554 ^= v564 & v544;
        v564 += 524296;
        v566 ^= v569;
        v552 ^= v570;
        v553 ^= v560 & v571;
        if ( v565 == (signed int *)"triple-DES inner-CBC" )
          break;
        v544 = *v565;
        v560 = v565[1];
        v545 = v565[2];
        v543 = v565[3];
      }
      v572 = 234941184;
      v573 = -2097117952;
      v574 = 2063609344;
      v575 = ((16 * v566 & 15360 * ((v911 + 16777472) & 0x40004) ^ v566) >> 8) & 0xF000F0 | (16 * v552 & 15360 * ((v937 + 16777472) & 0x40004) ^ v552) & 0xF000F000 | ((16 * v553 & 15360 * ((v884 + 16777472) & 0x40004) ^ v553) >> 4) & 0xF000F00 | ((16 * v554 & 15360 * ((v857 + 16777472) & 0x40004) ^ v554) >> 12) & 0xF000F;
      v576 = 16 * ((v575 ^ (v575 >> 4)) & 0x7030702) ^ (v575 ^ (v575 >> 4)) & 0x7030702 ^ v575;
      v577 = (((v576 ^ (v576 >> 8)) & 0x4E009E) << 8) ^ (v576 ^ (v576 >> 8)) & 0x4E009E ^ v576;
      v578 = ((unsigned __int16)((v577 ^ HIWORD(v577)) & 0xD9D3) << 16) ^ ((unsigned __int16)v577 ^ HIWORD(v577)) & 0xD9D3 ^ v577;
      v579 = 16 * ((v578 ^ (v578 >> 4)) & 0x5040004) ^ (v578 ^ (v578 >> 4)) & 0x5040004 ^ v578;
      v580 = 2 * ((v579 ^ (v579 >> 1)) & 0x4045015) ^ (v579 ^ (v579 >> 1)) & 0x4045015 ^ v818 ^ v579;
      v581 = 0;
      v819 = v580;
      v582 = 0;
      v583 = 0;
      v584 = v580 ^ *(_DWORD *)(v805 - 100);
      v585 = *(_DWORD *)(v805 - 36) ^ __ROL4__(v580, 4);
      v586 = v585;
      v587 = (v585 >> 8) & 0xFC00FC | 0xFF00FF00;
      v588 = v586 & 0xFC00FC;
      v589 = -167733504;
      v885 = v587;
      v588 |= 0xFF00FF00;
      v590 = v588;
      v591 = v584 & 0xFC00FC | 0xFF00FF00;
      v592 = v587 - v588;
      v858 = v588;
      v912 = v584 & 0xFC00FC | 0xFF00FF00;
      v938 = (v584 >> 8) & 0xFC00FC | 0xFF00FF00;
      v593 = v588;
      v594 = (signed int *)&unk_EF160;
      v595 = 0;
      v596 = v938 - v590;
      v597 = v591 - v590;
      while ( 1 )
      {
        v594 += 4;
        v598 = v572 & (v596 + v593);
        v583 ^= v593 & v573;
        v599 = v593 + v592;
        v595 ^= v574 & (v597 + v593);
        v593 += 524296;
        v581 ^= v598;
        v582 ^= v589 & v599;
        if ( v594 == (signed int *)"triple-DES inner-CBC" )
          break;
        v573 = *v594;
        v589 = v594[1];
        v574 = v594[2];
        v572 = v594[3];
      }
      v600 = 234941184;
      v601 = -2097117952;
      v602 = 2063609344;
      v603 = ((16 * v595 & 15360 * ((v912 + 16777472) & 0x40004) ^ v595) >> 8) & 0xF000F0 | (16 * v581 & 15360 * ((v938 + 16777472) & 0x40004) ^ v581) & 0xF000F000 | ((16 * v582 & 15360 * ((v885 + 16777472) & 0x40004) ^ v582) >> 4) & 0xF000F00 | ((16 * v583 & 15360 * ((v858 + 16777472) & 0x40004) ^ v583) >> 12) & 0xF000F;
      v604 = 16 * ((v603 ^ (v603 >> 4)) & 0x7030702) ^ (v603 ^ (v603 >> 4)) & 0x7030702 ^ v603;
      v605 = (((v604 ^ (v604 >> 8)) & 0x4E009E) << 8) ^ (v604 ^ (v604 >> 8)) & 0x4E009E ^ v604;
      v606 = ((unsigned __int16)((v605 ^ HIWORD(v605)) & 0xD9D3) << 16) ^ ((unsigned __int16)v605 ^ HIWORD(v605)) & 0xD9D3 ^ v605;
      v607 = 16 * ((v606 ^ (v606 >> 4)) & 0x5040004) ^ (v606 ^ (v606 >> 4)) & 0x5040004 ^ v606;
      v608 = 2 * ((v607 ^ (v607 >> 1)) & 0x4045015) ^ (v607 ^ (v607 >> 1)) & 0x4045015 ^ v834 ^ v607;
      v609 = 0;
      v835 = v608;
      v610 = 0;
      v611 = 0;
      v612 = v608 ^ *(_DWORD *)(v805 - 96);
      v613 = *(_DWORD *)(v805 - 32) ^ __ROL4__(v608, 4);
      v614 = v613;
      v615 = (v613 >> 8) & 0xFC00FC | 0xFF00FF00;
      v616 = v614 & 0xFC00FC;
      v617 = -167733504;
      v886 = v615;
      v616 |= 0xFF00FF00;
      v618 = v616;
      v619 = v612 & 0xFC00FC | 0xFF00FF00;
      v620 = v615 - v616;
      v859 = v616;
      v913 = v612 & 0xFC00FC | 0xFF00FF00;
      v939 = (v612 >> 8) & 0xFC00FC | 0xFF00FF00;
      v621 = v616;
      v622 = (signed int *)&unk_EF160;
      v623 = 0;
      v624 = v939 - v618;
      v625 = v619 - v618;
      v802 = v620;
      while ( 1 )
      {
        v622 += 4;
        v626 = v602 & (v625 + v621);
        v627 = v600 & (v624 + v621);
        v628 = v621 + v802;
        v611 ^= v621 & v601;
        v621 += 524296;
        v623 ^= v626;
        v609 ^= v627;
        v610 ^= v617 & v628;
        if ( v622 == (signed int *)"triple-DES inner-CBC" )
          break;
        v601 = *v622;
        v617 = v622[1];
        v602 = v622[2];
        v600 = v622[3];
      }
      v629 = 234941184;
      v630 = -2097117952;
      v631 = 2063609344;
      v632 = ((16 * v623 & 15360 * ((v913 + 16777472) & 0x40004) ^ v623) >> 8) & 0xF000F0 | (16 * v609 & 15360 * ((v939 + 16777472) & 0x40004) ^ v609) & 0xF000F000 | ((16 * v610 & 15360 * ((v886 + 16777472) & 0x40004) ^ v610) >> 4) & 0xF000F00 | ((16 * v611 & 15360 * ((v859 + 16777472) & 0x40004) ^ v611) >> 12) & 0xF000F;
      v633 = 16 * ((v632 ^ (v632 >> 4)) & 0x7030702) ^ (v632 ^ (v632 >> 4)) & 0x7030702 ^ v632;
      v634 = (((v633 ^ (v633 >> 8)) & 0x4E009E) << 8) ^ (v633 ^ (v633 >> 8)) & 0x4E009E ^ v633;
      v635 = ((unsigned __int16)((v634 ^ HIWORD(v634)) & 0xD9D3) << 16) ^ ((unsigned __int16)v634 ^ HIWORD(v634)) & 0xD9D3 ^ v634;
      v636 = 16 * ((v635 ^ (v635 >> 4)) & 0x5040004) ^ (v635 ^ (v635 >> 4)) & 0x5040004 ^ v635;
      v637 = 2 * ((v636 ^ (v636 >> 1)) & 0x4045015) ^ (v636 ^ (v636 >> 1)) & 0x4045015 ^ v819 ^ v636;
      v638 = 0;
      v820 = v637;
      v639 = 0;
      v640 = 0;
      v641 = v637 ^ *(_DWORD *)(v805 - 92);
      v642 = *(_DWORD *)(v805 - 28) ^ __ROL4__(v637, 4);
      v643 = v642;
      v644 = (v642 >> 8) & 0xFC00FC | 0xFF00FF00;
      v645 = v643 & 0xFC00FC;
      v646 = -167733504;
      v887 = v644;
      v645 |= 0xFF00FF00;
      v647 = v645;
      v648 = v641 & 0xFC00FC | 0xFF00FF00;
      v649 = v644 - v645;
      v860 = v645;
      v914 = v641 & 0xFC00FC | 0xFF00FF00;
      v940 = (v641 >> 8) & 0xFC00FC | 0xFF00FF00;
      v650 = v645;
      v651 = (signed int *)&unk_EF160;
      v652 = 0;
      v653 = v940 - v647;
      v654 = v648 - v647;
      while ( 1 )
      {
        v651 += 4;
        v655 = v629 & (v653 + v650);
        v640 ^= v650 & v630;
        v656 = v650 + v649;
        v652 ^= v631 & (v654 + v650);
        v650 += 524296;
        v638 ^= v655;
        v639 ^= v646 & v656;
        if ( v651 == (signed int *)"triple-DES inner-CBC" )
          break;
        v630 = *v651;
        v646 = v651[1];
        v631 = v651[2];
        v629 = v651[3];
      }
      v657 = 234941184;
      v658 = -2097117952;
      v659 = 2063609344;
      v660 = ((16 * v652 & 15360 * ((v914 + 16777472) & 0x40004) ^ v652) >> 8) & 0xF000F0 | (16 * v638 & 15360 * ((v940 + 16777472) & 0x40004) ^ v638) & 0xF000F000 | ((16 * v639 & 15360 * ((v887 + 16777472) & 0x40004) ^ v639) >> 4) & 0xF000F00 | ((16 * v640 & 15360 * ((v860 + 16777472) & 0x40004) ^ v640) >> 12) & 0xF000F;
      v661 = 16 * ((v660 ^ (v660 >> 4)) & 0x7030702) ^ (v660 ^ (v660 >> 4)) & 0x7030702 ^ v660;
      v662 = (((v661 ^ (v661 >> 8)) & 0x4E009E) << 8) ^ (v661 ^ (v661 >> 8)) & 0x4E009E ^ v661;
      v663 = ((unsigned __int16)((v662 ^ HIWORD(v662)) & 0xD9D3) << 16) ^ ((unsigned __int16)v662 ^ HIWORD(v662)) & 0xD9D3 ^ v662;
      v664 = 16 * ((v663 ^ (v663 >> 4)) & 0x5040004) ^ (v663 ^ (v663 >> 4)) & 0x5040004 ^ v663;
      v665 = 2 * ((v664 ^ (v664 >> 1)) & 0x4045015) ^ (v664 ^ (v664 >> 1)) & 0x4045015 ^ v835 ^ v664;
      v666 = 0;
      v836 = v665;
      v667 = 0;
      v668 = 0;
      v669 = v665 ^ *(_DWORD *)(v805 - 88);
      v670 = *(_DWORD *)(v805 - 24) ^ __ROL4__(v665, 4);
      v671 = v670;
      v672 = (v670 >> 8) & 0xFC00FC | 0xFF00FF00;
      v673 = v671 & 0xFC00FC;
      v674 = -167733504;
      v888 = v672;
      v673 |= 0xFF00FF00;
      v675 = v673;
      v676 = v669 & 0xFC00FC | 0xFF00FF00;
      v677 = v672 - v673;
      v861 = v673;
      v915 = v669 & 0xFC00FC | 0xFF00FF00;
      v941 = (v669 >> 8) & 0xFC00FC | 0xFF00FF00;
      v678 = v673;
      v679 = (signed int *)&unk_EF160;
      v680 = 0;
      v681 = v941 - v675;
      v682 = v676 - v675;
      v803 = v677;
      while ( 1 )
      {
        v679 += 4;
        v683 = v659 & (v682 + v678);
        v684 = v657 & (v681 + v678);
        v685 = v678 + v803;
        v668 ^= v678 & v658;
        v678 += 524296;
        v680 ^= v683;
        v666 ^= v684;
        v667 ^= v674 & v685;
        if ( v679 == (signed int *)"triple-DES inner-CBC" )
          break;
        v658 = *v679;
        v674 = v679[1];
        v659 = v679[2];
        v657 = v679[3];
      }
      v686 = 234941184;
      v687 = -2097117952;
      v688 = 2063609344;
      v689 = ((16 * v680 & 15360 * ((v915 + 16777472) & 0x40004) ^ v680) >> 8) & 0xF000F0 | (16 * v666 & 15360 * ((v941 + 16777472) & 0x40004) ^ v666) & 0xF000F000 | ((16 * v667 & 15360 * ((v888 + 16777472) & 0x40004) ^ v667) >> 4) & 0xF000F00 | ((16 * v668 & 15360 * ((v861 + 16777472) & 0x40004) ^ v668) >> 12) & 0xF000F;
      v690 = 16 * ((v689 ^ (v689 >> 4)) & 0x7030702) ^ (v689 ^ (v689 >> 4)) & 0x7030702 ^ v689;
      v691 = (((v690 ^ (v690 >> 8)) & 0x4E009E) << 8) ^ (v690 ^ (v690 >> 8)) & 0x4E009E ^ v690;
      v692 = ((unsigned __int16)((v691 ^ HIWORD(v691)) & 0xD9D3) << 16) ^ ((unsigned __int16)v691 ^ HIWORD(v691)) & 0xD9D3 ^ v691;
      v693 = 16 * ((v692 ^ (v692 >> 4)) & 0x5040004) ^ (v692 ^ (v692 >> 4)) & 0x5040004 ^ v692;
      v694 = 2 * ((v693 ^ (v693 >> 1)) & 0x4045015) ^ (v693 ^ (v693 >> 1)) & 0x4045015 ^ v820 ^ v693;
      v695 = 0;
      v821 = v694;
      v696 = 0;
      v697 = 0;
      v698 = v694 ^ *(_DWORD *)(v805 - 84);
      v699 = *(_DWORD *)(v805 - 20) ^ __ROL4__(v694, 4);
      v700 = v699;
      v701 = (v699 >> 8) & 0xFC00FC | 0xFF00FF00;
      v702 = v700 & 0xFC00FC;
      v703 = -167733504;
      v889 = v701;
      v702 |= 0xFF00FF00;
      v704 = v702;
      v705 = v698 & 0xFC00FC | 0xFF00FF00;
      v706 = v701 - v702;
      v862 = v702;
      v916 = v698 & 0xFC00FC | 0xFF00FF00;
      v942 = (v698 >> 8) & 0xFC00FC | 0xFF00FF00;
      v707 = v702;
      v708 = (signed int *)&unk_EF160;
      v709 = 0;
      v710 = v942 - v704;
      v711 = v705 - v704;
      while ( 1 )
      {
        v708 += 4;
        v712 = v686 & (v710 + v707);
        v697 ^= v707 & v687;
        v713 = v707 + v706;
        v709 ^= v688 & (v711 + v707);
        v707 += 524296;
        v695 ^= v712;
        v696 ^= v703 & v713;
        if ( v708 == (signed int *)"triple-DES inner-CBC" )
          break;
        v687 = *v708;
        v703 = v708[1];
        v688 = v708[2];
        v686 = v708[3];
      }
      v714 = 234941184;
      v715 = -2097117952;
      v716 = 2063609344;
      v717 = ((16 * v709 & 15360 * ((v916 + 16777472) & 0x40004) ^ v709) >> 8) & 0xF000F0 | (16 * v695 & 15360 * ((v942 + 16777472) & 0x40004) ^ v695) & 0xF000F000 | ((16 * v696 & 15360 * ((v889 + 16777472) & 0x40004) ^ v696) >> 4) & 0xF000F00 | ((16 * v697 & 15360 * ((v862 + 16777472) & 0x40004) ^ v697) >> 12) & 0xF000F;
      v718 = 16 * ((v717 ^ (v717 >> 4)) & 0x7030702) ^ (v717 ^ (v717 >> 4)) & 0x7030702 ^ v717;
      v719 = (((v718 ^ (v718 >> 8)) & 0x4E009E) << 8) ^ (v718 ^ (v718 >> 8)) & 0x4E009E ^ v718;
      v720 = ((unsigned __int16)((v719 ^ HIWORD(v719)) & 0xD9D3) << 16) ^ ((unsigned __int16)v719 ^ HIWORD(v719)) & 0xD9D3 ^ v719;
      v721 = 16 * ((v720 ^ (v720 >> 4)) & 0x5040004) ^ (v720 ^ (v720 >> 4)) & 0x5040004 ^ v720;
      v722 = 2 * ((v721 ^ (v721 >> 1)) & 0x4045015) ^ (v721 ^ (v721 >> 1)) & 0x4045015 ^ v836 ^ v721;
      v723 = 0;
      v837 = v722;
      v724 = 0;
      v725 = 0;
      v726 = v722 ^ *(_DWORD *)(v805 - 80);
      v727 = *(_DWORD *)(v805 - 16) ^ __ROL4__(v722, 4);
      v728 = v727;
      v729 = (v727 >> 8) & 0xFC00FC | 0xFF00FF00;
      v730 = v728 & 0xFC00FC;
      v731 = -167733504;
      v890 = v729;
      v730 |= 0xFF00FF00;
      v732 = v730;
      v733 = v726 & 0xFC00FC | 0xFF00FF00;
      v734 = v729 - v730;
      v863 = v730;
      v917 = v726 & 0xFC00FC | 0xFF00FF00;
      v943 = (v726 >> 8) & 0xFC00FC | 0xFF00FF00;
      v735 = v730;
      v736 = (signed int *)&unk_EF160;
      v737 = 0;
      v738 = v943 - v732;
      v739 = v733 - v732;
      v804 = v734;
      while ( 1 )
      {
        v736 += 4;
        v740 = v716 & (v739 + v735);
        v741 = v714 & (v738 + v735);
        v742 = v735 + v804;
        v725 ^= v735 & v715;
        v735 += 524296;
        v737 ^= v740;
        v723 ^= v741;
        v724 ^= v731 & v742;
        if ( v736 == (signed int *)"triple-DES inner-CBC" )
          break;
        v715 = *v736;
        v731 = v736[1];
        v716 = v736[2];
        v714 = v736[3];
      }
      v743 = 234941184;
      v744 = -2097117952;
      v745 = 2063609344;
      v746 = ((16 * v737 & 15360 * ((v917 + 16777472) & 0x40004) ^ v737) >> 8) & 0xF000F0 | (16 * v723 & 15360 * ((v943 + 16777472) & 0x40004) ^ v723) & 0xF000F000 | ((16 * v724 & 15360 * ((v890 + 16777472) & 0x40004) ^ v724) >> 4) & 0xF000F00 | ((16 * v725 & 15360 * ((v863 + 16777472) & 0x40004) ^ v725) >> 12) & 0xF000F;
      v747 = 16 * ((v746 ^ (v746 >> 4)) & 0x7030702) ^ (v746 ^ (v746 >> 4)) & 0x7030702 ^ v746;
      v748 = (((v747 ^ (v747 >> 8)) & 0x4E009E) << 8) ^ (v747 ^ (v747 >> 8)) & 0x4E009E ^ v747;
      v749 = ((unsigned __int16)((v748 ^ HIWORD(v748)) & 0xD9D3) << 16) ^ ((unsigned __int16)v748 ^ HIWORD(v748)) & 0xD9D3 ^ v748;
      v750 = 16 * ((v749 ^ (v749 >> 4)) & 0x5040004) ^ (v749 ^ (v749 >> 4)) & 0x5040004 ^ v749;
      v751 = 2 * ((v750 ^ (v750 >> 1)) & 0x4045015) ^ (v750 ^ (v750 >> 1)) & 0x4045015 ^ v821 ^ v750;
      v752 = 0;
      v822 = v751;
      v753 = 0;
      v754 = 0;
      v755 = v751 ^ *(_DWORD *)(v805 - 76);
      v756 = *(_DWORD *)(v805 - 12) ^ __ROL4__(v751, 4);
      v757 = v756;
      v758 = (v756 >> 8) & 0xFC00FC | 0xFF00FF00;
      v759 = v757 & 0xFC00FC;
      v760 = -167733504;
      v891 = v758;
      v759 |= 0xFF00FF00;
      v761 = v759;
      v762 = v755 & 0xFC00FC | 0xFF00FF00;
      v763 = v758 - v759;
      v864 = v759;
      v918 = v755 & 0xFC00FC | 0xFF00FF00;
      v944 = (v755 >> 8) & 0xFC00FC | 0xFF00FF00;
      v764 = v759;
      v765 = (signed int *)&unk_EF160;
      v766 = 0;
      v767 = v944 - v761;
      v768 = v762 - v761;
      while ( 1 )
      {
        v765 += 4;
        v769 = v743 & (v767 + v764);
        v754 ^= v764 & v744;
        v770 = v764 + v763;
        v766 ^= v745 & (v768 + v764);
        v764 += 524296;
        v752 ^= v769;
        v753 ^= v760 & v770;
        if ( v765 == (signed int *)"triple-DES inner-CBC" )
          break;
        v744 = *v765;
        v760 = v765[1];
        v745 = v765[2];
        v743 = v765[3];
      }
      v771 = ((16 * v766 & 15360 * ((v918 + 16777472) & 0x40004) ^ v766) >> 8) & 0xF000F0 | (16 * v752 & 15360 * ((v944 + 16777472) & 0x40004) ^ v752) & 0xF000F000 | ((16 * v753 & 15360 * ((v891 + 16777472) & 0x40004) ^ v753) >> 4) & 0xF000F00 | ((16 * v754 & 15360 * ((v864 + 16777472) & 0x40004) ^ v754) >> 12) & 0xF000F;
      v772 = (v771 ^ (v771 >> 4)) & 0x7030702;
      v773 = (((16 * v772 ^ v772 ^ v771 ^ ((16 * v772 ^ v772 ^ v771) >> 8)) & 0x4E009E) << 8) ^ (16 * v772 ^ v772 ^ v771 ^ ((16 * v772 ^ v772 ^ v771) >> 8)) & 0x4E009E ^ 16 * v772 ^ v772 ^ v771;
      v774 = ((unsigned __int16)((v773 ^ HIWORD(v773)) & 0xD9D3) << 16) ^ ((unsigned __int16)v773 ^ HIWORD(v773)) & 0xD9D3 ^ v773;
      v775 = 16 * ((v774 ^ (v774 >> 4)) & 0x5040004) ^ (v774 ^ (v774 >> 4)) & 0x5040004 ^ v774;
      v776 = __ROL4__(2 * ((v775 ^ (v775 >> 1)) & 0x4045015) ^ (v775 ^ (v775 >> 1)) & 0x4045015 ^ v837 ^ v775, 1);
      v777 = (__ROL4__(v822, 1) ^ (v776 >> 1)) & 0x55555555;
      v778 = 2 * v777 ^ v776;
      v779 = (v778 ^ (((unsigned int)v777 ^ __ROL4__(v822, 1)) >> 8)) & 0xFF00FF;
      v780 = v779 ^ v778;
      v781 = v777 ^ __ROL4__(v822, 1) ^ (v779 << 8);
      v782 = (v780 ^ (v781 >> 2)) & 0x33333333;
      v783 = v782 ^ v780;
      v784 = v781 ^ 4 * v782;
      v785 = (unsigned __int16)(v784 ^ HIWORD(v783));
      v786 = v785 ^ v784;
      v787 = (v785 << 16) ^ v783;
      v788 = (v786 ^ (v787 >> 4)) & 0xF0F0F0F;
      v4 = v788 ^ v786;
      v3 = 16 * v788 ^ v787;
      v789 = v806;
      *(_BYTE *)(v806 + 1) = BYTE2(v3);
      *(_BYTE *)(v806 + 3) = v3;
      *(_BYTE *)(v806 + 2) = BYTE1(v3);
      *(_BYTE *)v806 = HIBYTE(v3);
      *(_BYTE *)(v806 + 7) = v4;
      *(_BYTE *)(v806 + 6) = BYTE1(v4);
      *(_BYTE *)(v806 + 5) = BYTE2(v4);
      v806 += 8LL;
      *(_BYTE *)(v789 + 4) = HIBYTE(v4);
      *(_DWORD *)(v805 - 8) = v3;
      *(_DWORD *)(v805 - 4) = v4;
    }
    while ( v806 != v945 );
  }
}

void __fastcall sub_6B6D0(__int64 a1, unsigned int *a2, int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rbp
  unsigned int *v5; // r15
  __int64 v6; // r13
  __int64 v7; // rax
  __int64 v8; // kr00_8
  __int64 v9; // rax
  int v10; // edx
  int v11; // edi
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r14
  int v14; // er12
  __int64 v15; // rax
  int v16; // edx
  int v17; // edx
  int v18; // edi
  int v19; // edx
  unsigned int v20; // edi
  unsigned int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  int v26; // ecx
  int v27; // edx
  signed __int64 v28; // [rsp+0h] [rbp-40h]
  __int64 v29; // [rsp+8h] [rbp-38h]

  if ( a3 > 0 )
  {
    v3 = a1 - 408;
    v4 = a1;
    v5 = a2;
    v6 = a1 - 408 + 256;
    v29 = a1 - 408 + 128;
    v28 = (signed __int64)&a2[2 * ((unsigned int)(a3 - 1) >> 3) + 2];
    do
    {
      v7 = sub_63440(((unsigned __int64)_byteswap_ulong(v5[1]) << 32) | _byteswap_ulong(*v5));
      v8 = v7;
      v9 = sub_634C0(v7, v6, 15LL, -1LL);
      v10 = *(_DWORD *)(v4 - 12) ^ *(_DWORD *)(v4 - 4);
      v11 = *(_DWORD *)(v4 - 16) ^ *(_DWORD *)(v4 - 8);
      *(_QWORD *)(v4 - 8) = v8;
      v12 = sub_634C0(
              ((unsigned __int64)(HIDWORD(v9) ^ (unsigned int)v10) << 32) | v11 ^ (unsigned int)v9,
              v29,
              0LL,
              1LL);
      v13 = v12 >> 32;
      *(_QWORD *)(v4 - 16) = v12;
      v14 = v12;
      v15 = sub_634C0((v12 >> 32 << 32) | (unsigned int)v12, v3, 15LL, -1LL);
      v16 = *(_DWORD *)(v4 - 24);
      *(_DWORD *)(v4 - 24) = v14;
      v17 = v15 ^ v16;
      LODWORD(v15) = *(_DWORD *)(v4 - 20) ^ HIDWORD(v15);
      *(_DWORD *)(v4 - 20) = v13;
      LODWORD(v15) = __ROL4__(v15, 1);
      v18 = (v15 ^ (__ROL4__(v17, 1) >> 1)) & 0x55555555;
      LODWORD(v15) = v18 ^ v15;
      v19 = __ROL4__(v17, 1) ^ 2 * v18;
      v20 = v15 ^ (((v19 ^ ((unsigned int)v15 >> 8)) & 0xFF00FF) << 8);
      v21 = (v19 ^ ((unsigned int)v15 >> 8)) & 0xFF00FF ^ v19;
      v5 += 2;
      v22 = (v21 ^ (v20 >> 2)) & 0x33333333;
      v23 = v22 ^ v21;
      LODWORD(v15) = v20 ^ 4 * v22;
      v24 = (unsigned __int16)(v15 ^ HIWORD(v23));
      LODWORD(v15) = v24 ^ v15;
      v25 = v23 ^ (v24 << 16);
      v26 = (v15 ^ ((v23 ^ (unsigned int)(v24 << 16)) >> 4)) & 0xF0F0F0F;
      LODWORD(v15) = v26 ^ v15;
      *((_BYTE *)v5 - 1) = v15;
      v27 = v25 ^ 16 * v26;
      *((_BYTE *)v5 - 5) = v27;
      *((_BYTE *)v5 - 6) = BYTE1(v27);
      *((_BYTE *)v5 - 8) = HIBYTE(v27);
      *((_BYTE *)v5 - 7) = (v25 ^ (unsigned int)(16 * v26)) >> 16;
      *((_BYTE *)v5 - 2) = BYTE1(v15);
      *((_BYTE *)v5 - 3) = BYTE2(v15);
      *((_BYTE *)v5 - 4) = BYTE3(v15);
    }
    while ( v5 != (unsigned int *)v28 );
  }
}

void __fastcall sub_6B8B0(__int64 a1, __int64 a2, int a3)
{
  signed int v3; // er9
  signed int v4; // er11
  unsigned __int32 v5; // ebx
  unsigned __int32 v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // esi
  unsigned int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // esi
  unsigned int v16; // ecx
  unsigned int v17; // eax
  unsigned int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  unsigned int v22; // edx
  unsigned int v23; // eax
  signed int v24; // edi
  int v25; // er12
  int v26; // er13
  int v27; // ebp
  unsigned int v28; // ecx
  unsigned int v29; // eax
  int v30; // ebx
  signed int v31; // ecx
  int v32; // esi
  unsigned int v33; // er14
  int v34; // er8
  int v35; // edx
  signed int *v36; // rax
  unsigned int v37; // ebx
  int v38; // er15
  int v39; // er14
  int v40; // er8
  int v41; // esi
  int v42; // er10
  signed int v43; // er9
  signed int v44; // er11
  signed int v45; // edi
  unsigned int v46; // eax
  unsigned int v47; // esi
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  unsigned int v51; // eax
  int v52; // eax
  int v53; // er12
  int v54; // er13
  int v55; // ebp
  unsigned int v56; // edx
  unsigned int v57; // eax
  unsigned int v58; // ecx
  unsigned int v59; // eax
  int v60; // ebx
  signed int v61; // ecx
  int v62; // esi
  unsigned int v63; // er14
  int v64; // er8
  int v65; // edx
  signed int *v66; // rax
  unsigned int v67; // ebx
  int v68; // er15
  int v69; // er14
  int v70; // er8
  int v71; // esi
  int v72; // er10
  signed int v73; // er9
  signed int v74; // er11
  signed int v75; // edi
  unsigned int v76; // eax
  unsigned int v77; // esi
  unsigned int v78; // eax
  unsigned int v79; // eax
  unsigned int v80; // eax
  unsigned int v81; // eax
  int v82; // eax
  int v83; // er12
  int v84; // er13
  int v85; // ebp
  unsigned int v86; // edx
  unsigned int v87; // eax
  unsigned int v88; // ecx
  unsigned int v89; // eax
  int v90; // ebx
  signed int v91; // ecx
  int v92; // esi
  unsigned int v93; // er14
  int v94; // er8
  int v95; // edx
  signed int *v96; // rax
  unsigned int v97; // ebx
  int v98; // er15
  int v99; // er14
  int v100; // er8
  int v101; // esi
  int v102; // er10
  signed int v103; // er9
  signed int v104; // er11
  signed int v105; // edi
  unsigned int v106; // eax
  unsigned int v107; // esi
  unsigned int v108; // eax
  unsigned int v109; // eax
  unsigned int v110; // eax
  unsigned int v111; // eax
  int v112; // eax
  int v113; // er12
  int v114; // er13
  int v115; // ebp
  unsigned int v116; // edx
  unsigned int v117; // eax
  unsigned int v118; // ecx
  unsigned int v119; // eax
  int v120; // ebx
  signed int v121; // ecx
  int v122; // esi
  unsigned int v123; // er14
  int v124; // er8
  int v125; // edx
  signed int *v126; // rax
  unsigned int v127; // ebx
  int v128; // er15
  int v129; // er14
  int v130; // er8
  int v131; // esi
  int v132; // er10
  signed int v133; // er9
  signed int v134; // er11
  signed int v135; // edi
  unsigned int v136; // eax
  unsigned int v137; // esi
  unsigned int v138; // eax
  unsigned int v139; // eax
  unsigned int v140; // eax
  unsigned int v141; // eax
  int v142; // eax
  int v143; // er12
  int v144; // er13
  int v145; // ebp
  unsigned int v146; // edx
  unsigned int v147; // eax
  unsigned int v148; // ecx
  unsigned int v149; // eax
  int v150; // ebx
  signed int v151; // ecx
  int v152; // esi
  unsigned int v153; // er14
  int v154; // er8
  int v155; // edx
  signed int *v156; // rax
  unsigned int v157; // ebx
  int v158; // er15
  int v159; // er14
  int v160; // esi
  int v161; // er10
  signed int v162; // er9
  signed int v163; // er11
  signed int v164; // edi
  unsigned int v165; // eax
  unsigned int v166; // esi
  unsigned int v167; // eax
  unsigned int v168; // eax
  unsigned int v169; // eax
  unsigned int v170; // eax
  int v171; // eax
  int v172; // er12
  int v173; // er13
  int v174; // ebp
  unsigned int v175; // edx
  unsigned int v176; // eax
  unsigned int v177; // ecx
  unsigned int v178; // eax
  int v179; // ebx
  signed int v180; // ecx
  int v181; // esi
  unsigned int v182; // er14
  int v183; // er8
  int v184; // edx
  signed int *v185; // rax
  unsigned int v186; // ebx
  int v187; // er15
  int v188; // er14
  int v189; // er8
  int v190; // esi
  int v191; // er10
  signed int v192; // er9
  signed int v193; // er11
  signed int v194; // edi
  unsigned int v195; // eax
  unsigned int v196; // esi
  unsigned int v197; // eax
  unsigned int v198; // eax
  unsigned int v199; // eax
  unsigned int v200; // eax
  int v201; // eax
  int v202; // er12
  int v203; // er13
  int v204; // ebp
  unsigned int v205; // edx
  unsigned int v206; // eax
  unsigned int v207; // ecx
  unsigned int v208; // eax
  int v209; // ebx
  signed int v210; // ecx
  int v211; // esi
  unsigned int v212; // er14
  int v213; // er8
  int v214; // edx
  signed int *v215; // rax
  unsigned int v216; // ebx
  int v217; // er15
  int v218; // er14
  int v219; // esi
  int v220; // er10
  signed int v221; // er9
  signed int v222; // er11
  signed int v223; // edi
  unsigned int v224; // eax
  unsigned int v225; // esi
  unsigned int v226; // eax
  unsigned int v227; // eax
  unsigned int v228; // eax
  unsigned int v229; // eax
  int v230; // eax
  int v231; // er12
  int v232; // er13
  int v233; // ebp
  unsigned int v234; // edx
  unsigned int v235; // eax
  unsigned int v236; // ecx
  unsigned int v237; // eax
  int v238; // ebx
  signed int v239; // ecx
  int v240; // esi
  unsigned int v241; // er14
  int v242; // er8
  int v243; // edx
  signed int *v244; // rax
  unsigned int v245; // ebx
  int v246; // er15
  int v247; // er14
  int v248; // er8
  int v249; // esi
  int v250; // er10
  signed int v251; // er9
  signed int v252; // er11
  signed int v253; // edi
  unsigned int v254; // eax
  unsigned int v255; // esi
  unsigned int v256; // eax
  unsigned int v257; // eax
  unsigned int v258; // eax
  unsigned int v259; // eax
  int v260; // eax
  int v261; // er12
  int v262; // er13
  int v263; // ebp
  unsigned int v264; // edx
  unsigned int v265; // eax
  unsigned int v266; // ecx
  unsigned int v267; // eax
  int v268; // ebx
  signed int v269; // ecx
  int v270; // esi
  unsigned int v271; // er14
  int v272; // er8
  int v273; // edx
  signed int *v274; // rax
  unsigned int v275; // ebx
  int v276; // er15
  int v277; // er14
  int v278; // esi
  int v279; // er10
  signed int v280; // er9
  signed int v281; // er11
  signed int v282; // edi
  unsigned int v283; // eax
  unsigned int v284; // esi
  unsigned int v285; // eax
  unsigned int v286; // eax
  unsigned int v287; // eax
  unsigned int v288; // eax
  int v289; // eax
  int v290; // er12
  int v291; // er13
  int v292; // ebp
  unsigned int v293; // edx
  unsigned int v294; // eax
  unsigned int v295; // ecx
  unsigned int v296; // eax
  int v297; // ebx
  signed int v298; // ecx
  int v299; // esi
  unsigned int v300; // er14
  int v301; // er8
  int v302; // edx
  signed int *v303; // rax
  unsigned int v304; // ebx
  int v305; // er15
  int v306; // er14
  int v307; // er8
  int v308; // esi
  int v309; // er10
  signed int v310; // er9
  signed int v311; // er11
  signed int v312; // edi
  unsigned int v313; // eax
  unsigned int v314; // esi
  unsigned int v315; // eax
  unsigned int v316; // eax
  unsigned int v317; // eax
  unsigned int v318; // eax
  int v319; // eax
  int v320; // er12
  int v321; // er13
  int v322; // ebp
  unsigned int v323; // edx
  unsigned int v324; // eax
  unsigned int v325; // ecx
  unsigned int v326; // eax
  int v327; // ebx
  signed int v328; // ecx
  int v329; // esi
  unsigned int v330; // er14
  int v331; // er8
  int v332; // edx
  signed int *v333; // rax
  unsigned int v334; // ebx
  int v335; // er15
  int v336; // er14
  int v337; // esi
  int v338; // er10
  signed int v339; // er9
  signed int v340; // er11
  signed int v341; // edi
  unsigned int v342; // eax
  unsigned int v343; // esi
  unsigned int v344; // eax
  unsigned int v345; // eax
  unsigned int v346; // eax
  unsigned int v347; // eax
  int v348; // eax
  int v349; // er12
  int v350; // er13
  int v351; // ebp
  unsigned int v352; // edx
  unsigned int v353; // eax
  unsigned int v354; // ecx
  unsigned int v355; // eax
  int v356; // ebx
  signed int v357; // ecx
  int v358; // esi
  unsigned int v359; // er14
  int v360; // er8
  int v361; // edx
  signed int *v362; // rax
  unsigned int v363; // ebx
  int v364; // er15
  int v365; // er14
  int v366; // er8
  int v367; // esi
  int v368; // er10
  signed int v369; // er9
  signed int v370; // er11
  signed int v371; // edi
  unsigned int v372; // eax
  unsigned int v373; // esi
  unsigned int v374; // eax
  unsigned int v375; // eax
  unsigned int v376; // eax
  unsigned int v377; // eax
  int v378; // eax
  int v379; // er12
  int v380; // er13
  int v381; // ebp
  unsigned int v382; // edx
  unsigned int v383; // eax
  unsigned int v384; // ecx
  unsigned int v385; // eax
  int v386; // ebx
  signed int v387; // ecx
  int v388; // esi
  unsigned int v389; // er14
  int v390; // er8
  int v391; // edx
  signed int *v392; // rax
  unsigned int v393; // ebx
  int v394; // er15
  int v395; // er14
  int v396; // esi
  int v397; // er10
  signed int v398; // er9
  signed int v399; // er11
  signed int v400; // edi
  unsigned int v401; // eax
  unsigned int v402; // esi
  unsigned int v403; // eax
  unsigned int v404; // eax
  unsigned int v405; // eax
  unsigned int v406; // eax
  int v407; // eax
  int v408; // er12
  int v409; // er13
  int v410; // ebp
  unsigned int v411; // edx
  unsigned int v412; // eax
  unsigned int v413; // ecx
  unsigned int v414; // eax
  int v415; // ebx
  signed int v416; // ecx
  int v417; // esi
  unsigned int v418; // er14
  int v419; // er8
  int v420; // edx
  signed int *v421; // rax
  unsigned int v422; // ebx
  int v423; // er15
  int v424; // er14
  int v425; // er8
  int v426; // esi
  int v427; // er10
  signed int v428; // er9
  signed int v429; // er11
  signed int v430; // edi
  unsigned int v431; // eax
  unsigned int v432; // esi
  unsigned int v433; // eax
  unsigned int v434; // eax
  unsigned int v435; // eax
  unsigned int v436; // eax
  int v437; // eax
  int v438; // er12
  int v439; // er13
  int v440; // ebp
  unsigned int v441; // edx
  unsigned int v442; // eax
  unsigned int v443; // ecx
  unsigned int v444; // eax
  int v445; // ebx
  signed int v446; // ecx
  int v447; // esi
  unsigned int v448; // er14
  int v449; // er8
  int v450; // edx
  signed int *v451; // rax
  unsigned int v452; // ebx
  int v453; // er15
  int v454; // er14
  int v455; // esi
  int v456; // er10
  signed int v457; // er9
  signed int v458; // er11
  signed int v459; // edi
  unsigned int v460; // eax
  unsigned int v461; // esi
  unsigned int v462; // eax
  unsigned int v463; // eax
  unsigned int v464; // eax
  unsigned int v465; // eax
  int v466; // eax
  int v467; // er12
  int v468; // er13
  int v469; // ebp
  unsigned int v470; // edx
  unsigned int v471; // eax
  unsigned int v472; // ecx
  unsigned int v473; // eax
  int v474; // ebx
  signed int v475; // ecx
  int v476; // esi
  unsigned int v477; // er14
  int v478; // er8
  int v479; // edx
  signed int *v480; // rax
  unsigned int v481; // ebx
  int v482; // er15
  int v483; // er14
  int v484; // er8
  int v485; // esi
  int v486; // er10
  unsigned int v487; // esi
  int v488; // eax
  unsigned int v489; // eax
  unsigned int v490; // eax
  unsigned int v491; // eax
  int v492; // er12
  int v493; // er13
  unsigned __int64 v494; // rax
  signed int v495; // er9
  signed int v496; // edi
  signed int v497; // er11
  unsigned int v498; // ebp
  unsigned int v499; // edx
  int v500; // ecx
  int v501; // ebx
  signed int v502; // ecx
  int v503; // esi
  unsigned int v504; // er14
  int v505; // er8
  int v506; // edx
  signed int *v507; // rax
  unsigned int v508; // ebx
  int v509; // er15
  int v510; // er14
  int v511; // esi
  int v512; // er10
  __int64 v513; // r14
  unsigned int v514; // eax
  unsigned int v515; // esi
  unsigned int v516; // eax
  unsigned int v517; // eax
  unsigned int v518; // eax
  unsigned int v519; // eax
  int v520; // ebx
  int v521; // er12
  int v522; // er13
  int v523; // ebp
  int v524; // ebx
  int v525; // ebp
  int v526; // ebp
  signed int v527; // er9
  signed int v528; // edi
  unsigned int v529; // eax
  signed int v530; // er11
  unsigned int v531; // edx
  int v532; // ebp
  unsigned int v533; // ecx
  unsigned int v534; // eax
  int v535; // ebx
  signed int v536; // ecx
  int v537; // esi
  int v538; // er8
  int v539; // edx
  signed int *v540; // rax
  unsigned int v541; // ebx
  int v542; // er15
  int v543; // er14
  int v544; // er8
  int v545; // esi
  int v546; // er10
  signed int v547; // er9
  signed int v548; // er11
  signed int v549; // edi
  unsigned int v550; // eax
  unsigned int v551; // esi
  unsigned int v552; // eax
  unsigned int v553; // eax
  unsigned int v554; // eax
  unsigned int v555; // eax
  int v556; // eax
  int v557; // er12
  int v558; // er13
  int v559; // ebp
  unsigned int v560; // edx
  unsigned int v561; // eax
  unsigned int v562; // ecx
  unsigned int v563; // eax
  int v564; // ebx
  signed int v565; // ecx
  int v566; // esi
  unsigned int v567; // er14
  int v568; // er8
  int v569; // edx
  signed int *v570; // rax
  unsigned int v571; // ebx
  int v572; // er15
  int v573; // er14
  int v574; // esi
  int v575; // er10
  signed int v576; // er9
  signed int v577; // er11
  signed int v578; // edi
  unsigned int v579; // eax
  unsigned int v580; // esi
  unsigned int v581; // eax
  unsigned int v582; // eax
  unsigned int v583; // eax
  unsigned int v584; // eax
  int v585; // eax
  int v586; // er12
  int v587; // er13
  int v588; // ebp
  unsigned int v589; // edx
  unsigned int v590; // eax
  unsigned int v591; // ecx
  unsigned int v592; // eax
  int v593; // ebx
  signed int v594; // ecx
  int v595; // esi
  unsigned int v596; // er14
  int v597; // er8
  int v598; // edx
  signed int *v599; // rax
  unsigned int v600; // ebx
  int v601; // er15
  int v602; // er14
  int v603; // er8
  int v604; // esi
  int v605; // er10
  signed int v606; // er9
  signed int v607; // er11
  signed int v608; // edi
  unsigned int v609; // eax
  unsigned int v610; // esi
  unsigned int v611; // eax
  unsigned int v612; // eax
  unsigned int v613; // eax
  unsigned int v614; // eax
  int v615; // eax
  int v616; // er12
  int v617; // er13
  int v618; // ebp
  unsigned int v619; // edx
  unsigned int v620; // eax
  unsigned int v621; // ecx
  unsigned int v622; // eax
  int v623; // ebx
  signed int v624; // ecx
  int v625; // esi
  unsigned int v626; // er14
  int v627; // er8
  int v628; // edx
  signed int *v629; // rax
  unsigned int v630; // ebx
  int v631; // er15
  int v632; // er14
  int v633; // esi
  int v634; // er10
  signed int v635; // er9
  signed int v636; // er11
  signed int v637; // edi
  unsigned int v638; // eax
  unsigned int v639; // esi
  unsigned int v640; // eax
  unsigned int v641; // eax
  unsigned int v642; // eax
  unsigned int v643; // eax
  int v644; // eax
  int v645; // er12
  int v646; // er13
  int v647; // ebp
  unsigned int v648; // edx
  unsigned int v649; // eax
  unsigned int v650; // ecx
  unsigned int v651; // eax
  int v652; // ebx
  signed int v653; // ecx
  int v654; // esi
  unsigned int v655; // er14
  int v656; // er8
  int v657; // edx
  signed int *v658; // rax
  unsigned int v659; // ebx
  int v660; // er15
  int v661; // er14
  int v662; // er8
  int v663; // esi
  int v664; // er10
  signed int v665; // er9
  signed int v666; // er11
  signed int v667; // edi
  unsigned int v668; // eax
  unsigned int v669; // esi
  unsigned int v670; // eax
  unsigned int v671; // eax
  unsigned int v672; // eax
  unsigned int v673; // eax
  int v674; // eax
  int v675; // er12
  int v676; // er13
  int v677; // ebp
  unsigned int v678; // edx
  unsigned int v679; // eax
  unsigned int v680; // ecx
  unsigned int v681; // eax
  int v682; // ebx
  signed int v683; // ecx
  int v684; // esi
  unsigned int v685; // er14
  int v686; // er8
  int v687; // edx
  signed int *v688; // rax
  unsigned int v689; // ebx
  int v690; // er15
  int v691; // er14
  int v692; // esi
  int v693; // er10
  signed int v694; // er9
  signed int v695; // er11
  signed int v696; // edi
  unsigned int v697; // eax
  unsigned int v698; // esi
  unsigned int v699; // eax
  unsigned int v700; // eax
  unsigned int v701; // eax
  unsigned int v702; // eax
  int v703; // eax
  int v704; // er12
  int v705; // er13
  int v706; // ebp
  unsigned int v707; // edx
  unsigned int v708; // eax
  unsigned int v709; // ecx
  unsigned int v710; // eax
  int v711; // ebx
  signed int v712; // ecx
  int v713; // esi
  unsigned int v714; // er14
  int v715; // er8
  int v716; // edx
  signed int *v717; // rax
  unsigned int v718; // ebx
  int v719; // er15
  int v720; // er14
  int v721; // er8
  int v722; // esi
  int v723; // er10
  signed int v724; // er9
  signed int v725; // er11
  signed int v726; // edi
  unsigned int v727; // eax
  unsigned int v728; // esi
  unsigned int v729; // eax
  unsigned int v730; // eax
  unsigned int v731; // eax
  unsigned int v732; // eax
  int v733; // eax
  int v734; // er12
  int v735; // er13
  int v736; // ebp
  unsigned int v737; // edx
  unsigned int v738; // eax
  unsigned int v739; // ecx
  unsigned int v740; // eax
  int v741; // ebx
  signed int v742; // ecx
  int v743; // esi
  unsigned int v744; // er14
  int v745; // er8
  int v746; // edx
  signed int *v747; // rax
  unsigned int v748; // ebx
  int v749; // er15
  int v750; // er14
  int v751; // esi
  int v752; // er10
  signed int v753; // er9
  signed int v754; // er11
  signed int v755; // edi
  unsigned int v756; // eax
  unsigned int v757; // esi
  unsigned int v758; // eax
  unsigned int v759; // eax
  unsigned int v760; // eax
  unsigned int v761; // eax
  int v762; // eax
  int v763; // er12
  int v764; // er13
  int v765; // ebp
  unsigned int v766; // edx
  unsigned int v767; // eax
  unsigned int v768; // ecx
  unsigned int v769; // eax
  int v770; // ebx
  signed int v771; // ecx
  int v772; // esi
  unsigned int v773; // er14
  int v774; // er8
  int v775; // edx
  signed int *v776; // rax
  unsigned int v777; // ebx
  int v778; // er15
  int v779; // er14
  int v780; // er8
  int v781; // esi
  int v782; // er10
  signed int v783; // er9
  signed int v784; // er11
  signed int v785; // edi
  unsigned int v786; // eax
  unsigned int v787; // esi
  unsigned int v788; // eax
  unsigned int v789; // eax
  unsigned int v790; // eax
  unsigned int v791; // eax
  int v792; // eax
  int v793; // er12
  int v794; // er13
  int v795; // ebp
  unsigned int v796; // edx
  unsigned int v797; // eax
  unsigned int v798; // ecx
  unsigned int v799; // eax
  int v800; // ebx
  signed int v801; // ecx
  int v802; // esi
  unsigned int v803; // er14
  int v804; // er8
  int v805; // edx
  signed int *v806; // rax
  unsigned int v807; // ebx
  int v808; // er15
  int v809; // er14
  int v810; // esi
  int v811; // er10
  unsigned int v812; // eax
  unsigned int v813; // esi
  unsigned int v814; // eax
  unsigned int v815; // eax
  unsigned int v816; // eax
  unsigned int v817; // eax
  unsigned int v818; // eax
  int v819; // esi
  int v820; // edx
  int v821; // eax
  unsigned int v822; // ecx
  unsigned int v823; // esi
  int v824; // ecx
  unsigned int v825; // esi
  int v826; // eax
  int v827; // edx
  int v828; // eax
  int v829; // edx
  int v830; // esi
  int v831; // edx
  int v832; // ecx
  unsigned int v833; // eax
  int v834; // ecx
  int v835; // eax
  bool v836; // zf
  int v837; // [rsp+4h] [rbp-7Ch]
  int v838; // [rsp+4h] [rbp-7Ch]
  int v839; // [rsp+4h] [rbp-7Ch]
  int v840; // [rsp+4h] [rbp-7Ch]
  int v841; // [rsp+4h] [rbp-7Ch]
  int v842; // [rsp+4h] [rbp-7Ch]
  int v843; // [rsp+4h] [rbp-7Ch]
  int v844; // [rsp+4h] [rbp-7Ch]
  int v845; // [rsp+4h] [rbp-7Ch]
  int v846; // [rsp+4h] [rbp-7Ch]
  int v847; // [rsp+4h] [rbp-7Ch]
  int v848; // [rsp+4h] [rbp-7Ch]
  int v849; // [rsp+4h] [rbp-7Ch]
  int v850; // [rsp+4h] [rbp-7Ch]
  int v851; // [rsp+4h] [rbp-7Ch]
  __int64 v852; // [rsp+8h] [rbp-78h]
  __int64 v853; // [rsp+10h] [rbp-70h]
  __int64 v854; // [rsp+18h] [rbp-68h]
  int v855; // [rsp+18h] [rbp-68h]
  int v856; // [rsp+18h] [rbp-68h]
  int v857; // [rsp+18h] [rbp-68h]
  int v858; // [rsp+18h] [rbp-68h]
  int v859; // [rsp+18h] [rbp-68h]
  int v860; // [rsp+18h] [rbp-68h]
  int v861; // [rsp+18h] [rbp-68h]
  int v862; // [rsp+18h] [rbp-68h]
  int v863; // [rsp+18h] [rbp-68h]
  int v864; // [rsp+18h] [rbp-68h]
  int v865; // [rsp+18h] [rbp-68h]
  int v866; // [rsp+18h] [rbp-68h]
  int v867; // [rsp+18h] [rbp-68h]
  int v868; // [rsp+18h] [rbp-68h]
  int v869; // [rsp+18h] [rbp-68h]
  int v870; // [rsp+20h] [rbp-60h]
  int v871; // [rsp+20h] [rbp-60h]
  int v872; // [rsp+20h] [rbp-60h]
  int v873; // [rsp+20h] [rbp-60h]
  int v874; // [rsp+20h] [rbp-60h]
  int v875; // [rsp+20h] [rbp-60h]
  int v876; // [rsp+20h] [rbp-60h]
  int v877; // [rsp+20h] [rbp-60h]
  int v878; // [rsp+20h] [rbp-60h]
  int v879; // [rsp+20h] [rbp-60h]
  int v880; // [rsp+20h] [rbp-60h]
  int v881; // [rsp+20h] [rbp-60h]
  int v882; // [rsp+20h] [rbp-60h]
  int v883; // [rsp+20h] [rbp-60h]
  unsigned __int32 v884; // [rsp+24h] [rbp-5Ch]
  unsigned __int32 v885; // [rsp+28h] [rbp-58h]
  int v886; // [rsp+2Ch] [rbp-54h]
  int v887; // [rsp+2Ch] [rbp-54h]
  int v888; // [rsp+2Ch] [rbp-54h]
  int v889; // [rsp+2Ch] [rbp-54h]
  int v890; // [rsp+2Ch] [rbp-54h]
  int v891; // [rsp+2Ch] [rbp-54h]
  int v892; // [rsp+2Ch] [rbp-54h]
  int v893; // [rsp+2Ch] [rbp-54h]
  int v894; // [rsp+2Ch] [rbp-54h]
  int v895; // [rsp+2Ch] [rbp-54h]
  int v896; // [rsp+2Ch] [rbp-54h]
  int v897; // [rsp+2Ch] [rbp-54h]
  int v898; // [rsp+2Ch] [rbp-54h]
  int v899; // [rsp+2Ch] [rbp-54h]
  int v900; // [rsp+2Ch] [rbp-54h]
  int v901; // [rsp+2Ch] [rbp-54h]
  int v902; // [rsp+2Ch] [rbp-54h]
  int v903; // [rsp+2Ch] [rbp-54h]
  int v904; // [rsp+2Ch] [rbp-54h]
  int v905; // [rsp+2Ch] [rbp-54h]
  int v906; // [rsp+2Ch] [rbp-54h]
  int v907; // [rsp+2Ch] [rbp-54h]
  int v908; // [rsp+2Ch] [rbp-54h]
  int v909; // [rsp+2Ch] [rbp-54h]
  int v910; // [rsp+2Ch] [rbp-54h]
  int v911; // [rsp+2Ch] [rbp-54h]
  int v912; // [rsp+2Ch] [rbp-54h]
  unsigned int v913; // [rsp+30h] [rbp-50h]
  unsigned int v914; // [rsp+30h] [rbp-50h]
  unsigned int v915; // [rsp+30h] [rbp-50h]
  unsigned int v916; // [rsp+30h] [rbp-50h]
  unsigned int v917; // [rsp+30h] [rbp-50h]
  unsigned int v918; // [rsp+30h] [rbp-50h]
  unsigned int v919; // [rsp+30h] [rbp-50h]
  unsigned int v920; // [rsp+30h] [rbp-50h]
  unsigned int v921; // [rsp+30h] [rbp-50h]
  unsigned int v922; // [rsp+30h] [rbp-50h]
  unsigned int v923; // [rsp+30h] [rbp-50h]
  unsigned int v924; // [rsp+30h] [rbp-50h]
  unsigned int v925; // [rsp+30h] [rbp-50h]
  unsigned int v926; // [rsp+30h] [rbp-50h]
  unsigned int v927; // [rsp+30h] [rbp-50h]
  unsigned int v928; // [rsp+30h] [rbp-50h]
  unsigned int v929; // [rsp+30h] [rbp-50h]
  unsigned int v930; // [rsp+30h] [rbp-50h]
  unsigned int v931; // [rsp+30h] [rbp-50h]
  unsigned int v932; // [rsp+30h] [rbp-50h]
  unsigned int v933; // [rsp+30h] [rbp-50h]
  unsigned int v934; // [rsp+30h] [rbp-50h]
  unsigned int v935; // [rsp+30h] [rbp-50h]
  unsigned int v936; // [rsp+30h] [rbp-50h]
  unsigned int v937; // [rsp+30h] [rbp-50h]
  unsigned int v938; // [rsp+30h] [rbp-50h]
  unsigned int v939; // [rsp+30h] [rbp-50h]
  unsigned int v940; // [rsp+34h] [rbp-4Ch]
  unsigned int v941; // [rsp+34h] [rbp-4Ch]
  unsigned int v942; // [rsp+34h] [rbp-4Ch]
  unsigned int v943; // [rsp+34h] [rbp-4Ch]
  unsigned int v944; // [rsp+34h] [rbp-4Ch]
  unsigned int v945; // [rsp+34h] [rbp-4Ch]
  unsigned int v946; // [rsp+34h] [rbp-4Ch]
  unsigned int v947; // [rsp+34h] [rbp-4Ch]
  unsigned int v948; // [rsp+34h] [rbp-4Ch]
  unsigned int v949; // [rsp+34h] [rbp-4Ch]
  unsigned int v950; // [rsp+34h] [rbp-4Ch]
  unsigned int v951; // [rsp+34h] [rbp-4Ch]
  unsigned int v952; // [rsp+34h] [rbp-4Ch]
  unsigned int v953; // [rsp+34h] [rbp-4Ch]
  unsigned int v954; // [rsp+34h] [rbp-4Ch]
  unsigned int v955; // [rsp+34h] [rbp-4Ch]
  unsigned int v956; // [rsp+34h] [rbp-4Ch]
  unsigned int v957; // [rsp+34h] [rbp-4Ch]
  unsigned int v958; // [rsp+34h] [rbp-4Ch]
  unsigned int v959; // [rsp+34h] [rbp-4Ch]
  unsigned int v960; // [rsp+34h] [rbp-4Ch]
  unsigned int v961; // [rsp+34h] [rbp-4Ch]
  unsigned int v962; // [rsp+34h] [rbp-4Ch]
  unsigned int v963; // [rsp+34h] [rbp-4Ch]
  unsigned int v964; // [rsp+34h] [rbp-4Ch]
  unsigned int v965; // [rsp+34h] [rbp-4Ch]
  unsigned int v966; // [rsp+34h] [rbp-4Ch]
  unsigned int v967; // [rsp+38h] [rbp-48h]
  unsigned int v968; // [rsp+38h] [rbp-48h]
  unsigned int v969; // [rsp+38h] [rbp-48h]
  unsigned int v970; // [rsp+38h] [rbp-48h]
  unsigned int v971; // [rsp+38h] [rbp-48h]
  unsigned int v972; // [rsp+38h] [rbp-48h]
  unsigned int v973; // [rsp+38h] [rbp-48h]
  unsigned int v974; // [rsp+38h] [rbp-48h]
  unsigned int v975; // [rsp+38h] [rbp-48h]
  unsigned int v976; // [rsp+38h] [rbp-48h]
  unsigned int v977; // [rsp+38h] [rbp-48h]
  unsigned int v978; // [rsp+38h] [rbp-48h]
  unsigned int v979; // [rsp+38h] [rbp-48h]
  unsigned int v980; // [rsp+38h] [rbp-48h]
  unsigned int v981; // [rsp+38h] [rbp-48h]
  unsigned int v982; // [rsp+38h] [rbp-48h]
  int v983; // [rsp+38h] [rbp-48h]
  unsigned int v984; // [rsp+38h] [rbp-48h]
  unsigned int v985; // [rsp+38h] [rbp-48h]
  unsigned int v986; // [rsp+38h] [rbp-48h]
  unsigned int v987; // [rsp+38h] [rbp-48h]
  unsigned int v988; // [rsp+38h] [rbp-48h]
  unsigned int v989; // [rsp+38h] [rbp-48h]
  unsigned int v990; // [rsp+38h] [rbp-48h]
  unsigned int v991; // [rsp+38h] [rbp-48h]
  unsigned int v992; // [rsp+38h] [rbp-48h]
  unsigned int v993; // [rsp+38h] [rbp-48h]
  signed __int64 v994; // [rsp+40h] [rbp-40h]
  __int64 v995; // [rsp+48h] [rbp-38h]

  v852 = a1;
  v853 = a2;
  if ( a3 > 0 )
  {
    v995 = a1 - 264;
    v994 = a2 + 8LL * ((unsigned int)(a3 - 1) >> 3) + 8;
    do
    {
      v3 = 234941184;
      v4 = -2097117952;
      v5 = _byteswap_ulong(*(_DWORD *)v853);
      v884 = v5;
      v6 = _byteswap_ulong(*(_DWORD *)(v853 + 4));
      v885 = v6;
      v7 = (v6 ^ (v5 >> 4)) & 0xF0F0F0F;
      v8 = v7;
      v9 = v6 ^ v7;
      v10 = (unsigned __int16)(v9 ^ ((v5 ^ 16 * v8) >> 16));
      v11 = v10 ^ v9;
      v12 = v5 ^ 16 * v8 ^ (v10 << 16);
      v13 = (v12 ^ (v11 >> 2)) & 0x33333333;
      v14 = v13 ^ v12;
      v15 = v11 ^ 4 * v13;
      v16 = (v14 ^ ((v11 ^ 4 * v13) >> 8)) & 0xFF00FF;
      v17 = v16;
      v18 = v14 ^ v16;
      v19 = v15 ^ (v17 << 8);
      v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
      v21 = v20 ^ v19;
      v855 = __ROR4__(v18 ^ 2 * v20, 1);
      v870 = __ROR4__(v21, 1);
      v22 = __ROR4__(v21, 1) ^ *(_DWORD *)(v852 - 76);
      v23 = *(_DWORD *)(v852 - 12) ^ __ROL4__(v21, 3);
      v24 = 2063609344;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = v23;
      v29 = (v23 >> 8) & 0xFC00FC | 0xFF00FF00;
      v30 = v28 & 0xFC00FC;
      v31 = -167733504;
      v913 = v29;
      v30 |= 0xFF00FF00;
      v32 = v30;
      v33 = v22 & 0xFC00FC | 0xFF00FF00;
      v34 = v29 - v30;
      v886 = v30;
      v940 = v22 & 0xFC00FC | 0xFF00FF00;
      v967 = (v22 >> 8) & 0xFC00FC | 0xFF00FF00;
      v35 = v30;
      v36 = (signed int *)&unk_EF160;
      v37 = 0;
      v38 = v967 - v32;
      v39 = v33 - v32;
      v837 = v34;
      while ( 1 )
      {
        v36 += 4;
        v40 = v24 & (v39 + v35);
        v41 = v3 & (v38 + v35);
        v42 = v35 + v837;
        v37 ^= v35 & v4;
        v35 += 524296;
        v26 ^= v40;
        v25 ^= v41;
        v27 ^= v31 & v42;
        if ( v36 == (signed int *)"triple-DES inner-CBC" )
          break;
        v4 = *v36;
        v31 = v36[1];
        v24 = v36[2];
        v3 = v36[3];
      }
      v43 = 234941184;
      v44 = -2097117952;
      v45 = 2063609344;
      v46 = ((16 * v27 & 15360 * ((v913 + 16777472) & 0x40004) ^ v27) >> 4) & 0xF000F00 | ((16 * v37 & 15360 * ((v886 + 16777472) & 0x40004) ^ v37) >> 12) & 0xF000F | (v25 ^ 16 * v25 & 15360 * ((v967 + 16777472) & 0x40004)) & 0xF000F000;
      v47 = v46 | ((v26 ^ 16 * v26 & 15360 * ((v940 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v48 = (v47 ^ ((v46 | ((v26 ^ 16 * v26 & 15360 * ((v940 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v49 = (16 * v48 ^ v48 ^ v47 ^ ((16 * v48 ^ v48 ^ v47) >> 8)) & 0x4E009E ^ 16 * v48 ^ v48 ^ v47 ^ (((16 * v48 ^ v48 ^ v47 ^ ((16 * v48 ^ v48 ^ v47) >> 8)) & 0x4E009E) << 8);
      v50 = ((unsigned __int16)((v49 ^ HIWORD(v49)) & 0xD9D3) << 16) ^ ((unsigned __int16)v49 ^ HIWORD(v49)) & 0xD9D3 ^ v49;
      v51 = 16 * ((v50 ^ (v50 >> 4)) & 0x5040004) ^ (v50 ^ (v50 >> 4)) & 0x5040004 ^ v50;
      v52 = 2 * ((v51 ^ (v51 >> 1)) & 0x4045015) ^ (v51 ^ (v51 >> 1)) & 0x4045015 ^ v855 ^ v51;
      v53 = 0;
      v856 = v52;
      v54 = 0;
      v55 = 0;
      v56 = v52 ^ *(_DWORD *)(v852 - 80);
      v57 = *(_DWORD *)(v852 - 16) ^ __ROL4__(v52, 4);
      v58 = v57;
      v59 = (v57 >> 8) & 0xFC00FC | 0xFF00FF00;
      v60 = v58 & 0xFC00FC;
      v61 = -167733504;
      v914 = v59;
      v60 |= 0xFF00FF00;
      v62 = v60;
      v63 = v56 & 0xFC00FC | 0xFF00FF00;
      v64 = v59 - v60;
      v887 = v60;
      v941 = v56 & 0xFC00FC | 0xFF00FF00;
      v968 = (v56 >> 8) & 0xFC00FC | 0xFF00FF00;
      v65 = v60;
      v66 = (signed int *)&unk_EF160;
      v67 = 0;
      v68 = v968 - v62;
      v69 = v63 - v62;
      v838 = v64;
      while ( 1 )
      {
        v66 += 4;
        v70 = v45 & (v69 + v65);
        v71 = v43 & (v68 + v65);
        v72 = v65 + v838;
        v67 ^= v65 & v44;
        v65 += 524296;
        v54 ^= v70;
        v53 ^= v71;
        v55 ^= v61 & v72;
        if ( v66 == (signed int *)"triple-DES inner-CBC" )
          break;
        v44 = *v66;
        v61 = v66[1];
        v45 = v66[2];
        v43 = v66[3];
      }
      v73 = 234941184;
      v74 = -2097117952;
      v75 = 2063609344;
      v76 = ((16 * v55 & 15360 * ((v914 + 16777472) & 0x40004) ^ v55) >> 4) & 0xF000F00 | ((16 * v67 & 15360 * ((v887 + 16777472) & 0x40004) ^ v67) >> 12) & 0xF000F | (v53 ^ 16 * v53 & 15360 * ((v968 + 16777472) & 0x40004)) & 0xF000F000;
      v77 = v76 | ((v54 ^ 16 * v54 & 15360 * ((v941 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v78 = (v77 ^ ((v76 | ((v54 ^ 16 * v54 & 15360 * ((v941 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v79 = (16 * v78 ^ v78 ^ v77 ^ ((16 * v78 ^ v78 ^ v77) >> 8)) & 0x4E009E ^ 16 * v78 ^ v78 ^ v77 ^ (((16 * v78 ^ v78 ^ v77 ^ ((16 * v78 ^ v78 ^ v77) >> 8)) & 0x4E009E) << 8);
      v80 = ((unsigned __int16)((v79 ^ HIWORD(v79)) & 0xD9D3) << 16) ^ ((unsigned __int16)v79 ^ HIWORD(v79)) & 0xD9D3 ^ v79;
      v81 = 16 * ((v80 ^ (v80 >> 4)) & 0x5040004) ^ (v80 ^ (v80 >> 4)) & 0x5040004 ^ v80;
      v82 = 2 * ((v81 ^ (v81 >> 1)) & 0x4045015) ^ (v81 ^ (v81 >> 1)) & 0x4045015 ^ v870 ^ v81;
      v83 = 0;
      v871 = v82;
      v84 = 0;
      v85 = 0;
      v86 = v82 ^ *(_DWORD *)(v852 - 84);
      v87 = *(_DWORD *)(v852 - 20) ^ __ROL4__(v82, 4);
      v88 = v87;
      v89 = (v87 >> 8) & 0xFC00FC | 0xFF00FF00;
      v90 = v88 & 0xFC00FC;
      v91 = -167733504;
      v915 = v89;
      v90 |= 0xFF00FF00;
      v92 = v90;
      v93 = v86 & 0xFC00FC | 0xFF00FF00;
      v94 = v89 - v90;
      v888 = v90;
      v942 = v86 & 0xFC00FC | 0xFF00FF00;
      v969 = (v86 >> 8) & 0xFC00FC | 0xFF00FF00;
      v95 = v90;
      v96 = (signed int *)&unk_EF160;
      v97 = 0;
      v98 = v969 - v92;
      v99 = v93 - v92;
      v839 = v94;
      while ( 1 )
      {
        v96 += 4;
        v100 = v75 & (v99 + v95);
        v101 = v73 & (v98 + v95);
        v102 = v95 + v839;
        v97 ^= v95 & v74;
        v95 += 524296;
        v84 ^= v100;
        v83 ^= v101;
        v85 ^= v91 & v102;
        if ( v96 == (signed int *)"triple-DES inner-CBC" )
          break;
        v74 = *v96;
        v91 = v96[1];
        v75 = v96[2];
        v73 = v96[3];
      }
      v103 = 234941184;
      v104 = -2097117952;
      v105 = 2063609344;
      v106 = ((16 * v85 & 15360 * ((v915 + 16777472) & 0x40004) ^ v85) >> 4) & 0xF000F00 | ((16 * v97 & 15360 * ((v888 + 16777472) & 0x40004) ^ v97) >> 12) & 0xF000F | (v83 ^ 16 * v83 & 15360 * ((v969 + 16777472) & 0x40004)) & 0xF000F000;
      v107 = v106 | ((v84 ^ 16 * v84 & 15360 * ((v942 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v108 = (v107 ^ ((v106 | ((v84 ^ 16 * v84 & 15360 * ((v942 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v109 = (16 * v108 ^ v108 ^ v107 ^ ((16 * v108 ^ v108 ^ v107) >> 8)) & 0x4E009E ^ 16 * v108 ^ v108 ^ v107 ^ (((16 * v108 ^ v108 ^ v107 ^ ((16 * v108 ^ v108 ^ v107) >> 8)) & 0x4E009E) << 8);
      v110 = ((unsigned __int16)((v109 ^ HIWORD(v109)) & 0xD9D3) << 16) ^ ((unsigned __int16)v109 ^ HIWORD(v109)) & 0xD9D3 ^ v109;
      v111 = 16 * ((v110 ^ (v110 >> 4)) & 0x5040004) ^ (v110 ^ (v110 >> 4)) & 0x5040004 ^ v110;
      v112 = 2 * ((v111 ^ (v111 >> 1)) & 0x4045015) ^ (v111 ^ (v111 >> 1)) & 0x4045015 ^ v856 ^ v111;
      v113 = 0;
      v857 = v112;
      v114 = 0;
      v115 = 0;
      v116 = v112 ^ *(_DWORD *)(v852 - 88);
      v117 = *(_DWORD *)(v852 - 24) ^ __ROL4__(v112, 4);
      v118 = v117;
      v119 = (v117 >> 8) & 0xFC00FC | 0xFF00FF00;
      v120 = v118 & 0xFC00FC;
      v121 = -167733504;
      v916 = v119;
      v120 |= 0xFF00FF00;
      v122 = v120;
      v123 = v116 & 0xFC00FC | 0xFF00FF00;
      v124 = v119 - v120;
      v889 = v120;
      v943 = v116 & 0xFC00FC | 0xFF00FF00;
      v970 = (v116 >> 8) & 0xFC00FC | 0xFF00FF00;
      v125 = v120;
      v126 = (signed int *)&unk_EF160;
      v127 = 0;
      v128 = v970 - v122;
      v129 = v123 - v122;
      v840 = v124;
      while ( 1 )
      {
        v126 += 4;
        v130 = v105 & (v129 + v125);
        v131 = v103 & (v128 + v125);
        v132 = v125 + v840;
        v127 ^= v125 & v104;
        v125 += 524296;
        v114 ^= v130;
        v113 ^= v131;
        v115 ^= v121 & v132;
        if ( v126 == (signed int *)"triple-DES inner-CBC" )
          break;
        v104 = *v126;
        v121 = v126[1];
        v105 = v126[2];
        v103 = v126[3];
      }
      v133 = 234941184;
      v134 = -2097117952;
      v135 = 2063609344;
      v136 = ((16 * v115 & 15360 * ((v916 + 16777472) & 0x40004) ^ v115) >> 4) & 0xF000F00 | ((16 * v127 & 15360 * ((v889 + 16777472) & 0x40004) ^ v127) >> 12) & 0xF000F | (v113 ^ 16 * v113 & 15360 * ((v970 + 16777472) & 0x40004)) & 0xF000F000;
      v137 = v136 | ((v114 ^ 16 * v114 & 15360 * ((v943 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v138 = (v137 ^ ((v136 | ((v114 ^ 16 * v114 & 15360 * ((v943 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v139 = (16 * v138 ^ v138 ^ v137 ^ ((16 * v138 ^ v138 ^ v137) >> 8)) & 0x4E009E ^ 16 * v138 ^ v138 ^ v137 ^ (((16 * v138 ^ v138 ^ v137 ^ ((16 * v138 ^ v138 ^ v137) >> 8)) & 0x4E009E) << 8);
      v140 = ((unsigned __int16)((v139 ^ HIWORD(v139)) & 0xD9D3) << 16) ^ ((unsigned __int16)v139 ^ HIWORD(v139)) & 0xD9D3 ^ v139;
      v141 = 16 * ((v140 ^ (v140 >> 4)) & 0x5040004) ^ (v140 ^ (v140 >> 4)) & 0x5040004 ^ v140;
      v142 = 2 * ((v141 ^ (v141 >> 1)) & 0x4045015) ^ (v141 ^ (v141 >> 1)) & 0x4045015 ^ v871 ^ v141;
      v143 = 0;
      v872 = v142;
      v144 = 0;
      v145 = 0;
      v146 = v142 ^ *(_DWORD *)(v852 - 92);
      v147 = *(_DWORD *)(v852 - 28) ^ __ROL4__(v142, 4);
      v148 = v147;
      v149 = (v147 >> 8) & 0xFC00FC | 0xFF00FF00;
      v150 = v148 & 0xFC00FC;
      v151 = -167733504;
      v917 = v149;
      v150 |= 0xFF00FF00;
      v152 = v150;
      v153 = v146 & 0xFC00FC | 0xFF00FF00;
      v154 = v149 - v150;
      v890 = v150;
      v944 = v146 & 0xFC00FC | 0xFF00FF00;
      v971 = (v146 >> 8) & 0xFC00FC | 0xFF00FF00;
      v155 = v150;
      v156 = (signed int *)&unk_EF160;
      v157 = 0;
      v158 = v971 - v152;
      v159 = v153 - v152;
      while ( 1 )
      {
        v156 += 4;
        v160 = v133 & (v158 + v155);
        v157 ^= v155 & v134;
        v161 = v155 + v154;
        v144 ^= v135 & (v159 + v155);
        v155 += 524296;
        v143 ^= v160;
        v145 ^= v151 & v161;
        if ( v156 == (signed int *)"triple-DES inner-CBC" )
          break;
        v134 = *v156;
        v151 = v156[1];
        v135 = v156[2];
        v133 = v156[3];
      }
      v162 = 234941184;
      v163 = -2097117952;
      v164 = 2063609344;
      v165 = ((16 * v145 & 15360 * ((v917 + 16777472) & 0x40004) ^ v145) >> 4) & 0xF000F00 | ((16 * v157 & 15360 * ((v890 + 16777472) & 0x40004) ^ v157) >> 12) & 0xF000F | (v143 ^ 16 * v143 & 15360 * ((v971 + 16777472) & 0x40004)) & 0xF000F000;
      v166 = v165 | ((v144 ^ 16 * v144 & 15360 * ((v944 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v167 = (v166 ^ ((v165 | ((v144 ^ 16 * v144 & 15360 * ((v944 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v168 = (16 * v167 ^ v167 ^ v166 ^ ((16 * v167 ^ v167 ^ v166) >> 8)) & 0x4E009E ^ 16 * v167 ^ v167 ^ v166 ^ (((16 * v167 ^ v167 ^ v166 ^ ((16 * v167 ^ v167 ^ v166) >> 8)) & 0x4E009E) << 8);
      v169 = ((unsigned __int16)((v168 ^ HIWORD(v168)) & 0xD9D3) << 16) ^ ((unsigned __int16)v168 ^ HIWORD(v168)) & 0xD9D3 ^ v168;
      v170 = 16 * ((v169 ^ (v169 >> 4)) & 0x5040004) ^ (v169 ^ (v169 >> 4)) & 0x5040004 ^ v169;
      v171 = 2 * ((v170 ^ (v170 >> 1)) & 0x4045015) ^ (v170 ^ (v170 >> 1)) & 0x4045015 ^ v857 ^ v170;
      v172 = 0;
      v858 = v171;
      v173 = 0;
      v174 = 0;
      v175 = v171 ^ *(_DWORD *)(v852 - 96);
      v176 = *(_DWORD *)(v852 - 32) ^ __ROL4__(v171, 4);
      v177 = v176;
      v178 = (v176 >> 8) & 0xFC00FC | 0xFF00FF00;
      v179 = v177 & 0xFC00FC;
      v180 = -167733504;
      v918 = v178;
      v179 |= 0xFF00FF00;
      v181 = v179;
      v182 = v175 & 0xFC00FC | 0xFF00FF00;
      v183 = v178 - v179;
      v891 = v179;
      v945 = v175 & 0xFC00FC | 0xFF00FF00;
      v972 = (v175 >> 8) & 0xFC00FC | 0xFF00FF00;
      v184 = v179;
      v185 = (signed int *)&unk_EF160;
      v186 = 0;
      v187 = v972 - v181;
      v188 = v182 - v181;
      v841 = v183;
      while ( 1 )
      {
        v185 += 4;
        v189 = v164 & (v188 + v184);
        v190 = v162 & (v187 + v184);
        v191 = v184 + v841;
        v186 ^= v184 & v163;
        v184 += 524296;
        v173 ^= v189;
        v172 ^= v190;
        v174 ^= v180 & v191;
        if ( v185 == (signed int *)"triple-DES inner-CBC" )
          break;
        v163 = *v185;
        v180 = v185[1];
        v164 = v185[2];
        v162 = v185[3];
      }
      v192 = 234941184;
      v193 = -2097117952;
      v194 = 2063609344;
      v195 = ((16 * v174 & 15360 * ((v918 + 16777472) & 0x40004) ^ v174) >> 4) & 0xF000F00 | ((16 * v186 & 15360 * ((v891 + 16777472) & 0x40004) ^ v186) >> 12) & 0xF000F | (v172 ^ 16 * v172 & 15360 * ((v972 + 16777472) & 0x40004)) & 0xF000F000;
      v196 = v195 | ((v173 ^ 16 * v173 & 15360 * ((v945 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v197 = (v196 ^ ((v195 | ((v173 ^ 16 * v173 & 15360 * ((v945 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v198 = (16 * v197 ^ v197 ^ v196 ^ ((16 * v197 ^ v197 ^ v196) >> 8)) & 0x4E009E ^ 16 * v197 ^ v197 ^ v196 ^ (((16 * v197 ^ v197 ^ v196 ^ ((16 * v197 ^ v197 ^ v196) >> 8)) & 0x4E009E) << 8);
      v199 = ((unsigned __int16)((v198 ^ HIWORD(v198)) & 0xD9D3) << 16) ^ ((unsigned __int16)v198 ^ HIWORD(v198)) & 0xD9D3 ^ v198;
      v200 = 16 * ((v199 ^ (v199 >> 4)) & 0x5040004) ^ (v199 ^ (v199 >> 4)) & 0x5040004 ^ v199;
      v201 = 2 * ((v200 ^ (v200 >> 1)) & 0x4045015) ^ (v200 ^ (v200 >> 1)) & 0x4045015 ^ v872 ^ v200;
      v202 = 0;
      v873 = v201;
      v203 = 0;
      v204 = 0;
      v205 = v201 ^ *(_DWORD *)(v852 - 100);
      v206 = *(_DWORD *)(v852 - 36) ^ __ROL4__(v201, 4);
      v207 = v206;
      v208 = (v206 >> 8) & 0xFC00FC | 0xFF00FF00;
      v209 = v207 & 0xFC00FC;
      v210 = -167733504;
      v919 = v208;
      v209 |= 0xFF00FF00;
      v211 = v209;
      v212 = v205 & 0xFC00FC | 0xFF00FF00;
      v213 = v208 - v209;
      v892 = v209;
      v946 = v205 & 0xFC00FC | 0xFF00FF00;
      v973 = (v205 >> 8) & 0xFC00FC | 0xFF00FF00;
      v214 = v209;
      v215 = (signed int *)&unk_EF160;
      v216 = 0;
      v217 = v973 - v211;
      v218 = v212 - v211;
      while ( 1 )
      {
        v215 += 4;
        v219 = v192 & (v217 + v214);
        v216 ^= v214 & v193;
        v220 = v214 + v213;
        v203 ^= v194 & (v218 + v214);
        v214 += 524296;
        v202 ^= v219;
        v204 ^= v210 & v220;
        if ( v215 == (signed int *)"triple-DES inner-CBC" )
          break;
        v193 = *v215;
        v210 = v215[1];
        v194 = v215[2];
        v192 = v215[3];
      }
      v221 = 234941184;
      v222 = -2097117952;
      v223 = 2063609344;
      v224 = ((16 * v204 & 15360 * ((v919 + 16777472) & 0x40004) ^ v204) >> 4) & 0xF000F00 | ((16 * v216 & 15360 * ((v892 + 16777472) & 0x40004) ^ v216) >> 12) & 0xF000F | (v202 ^ 16 * v202 & 15360 * ((v973 + 16777472) & 0x40004)) & 0xF000F000;
      v225 = v224 | ((v203 ^ 16 * v203 & 15360 * ((v946 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v226 = (v225 ^ ((v224 | ((v203 ^ 16 * v203 & 15360 * ((v946 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v227 = (16 * v226 ^ v226 ^ v225 ^ ((16 * v226 ^ v226 ^ v225) >> 8)) & 0x4E009E ^ 16 * v226 ^ v226 ^ v225 ^ (((16 * v226 ^ v226 ^ v225 ^ ((16 * v226 ^ v226 ^ v225) >> 8)) & 0x4E009E) << 8);
      v228 = ((unsigned __int16)((v227 ^ HIWORD(v227)) & 0xD9D3) << 16) ^ ((unsigned __int16)v227 ^ HIWORD(v227)) & 0xD9D3 ^ v227;
      v229 = 16 * ((v228 ^ (v228 >> 4)) & 0x5040004) ^ (v228 ^ (v228 >> 4)) & 0x5040004 ^ v228;
      v230 = 2 * ((v229 ^ (v229 >> 1)) & 0x4045015) ^ (v229 ^ (v229 >> 1)) & 0x4045015 ^ v858 ^ v229;
      v231 = 0;
      v859 = v230;
      v232 = 0;
      v233 = 0;
      v234 = v230 ^ *(_DWORD *)(v852 - 104);
      v235 = *(_DWORD *)(v852 - 40) ^ __ROL4__(v230, 4);
      v236 = v235;
      v237 = (v235 >> 8) & 0xFC00FC | 0xFF00FF00;
      v238 = v236 & 0xFC00FC;
      v239 = -167733504;
      v920 = v237;
      v238 |= 0xFF00FF00;
      v240 = v238;
      v241 = v234 & 0xFC00FC | 0xFF00FF00;
      v242 = v237 - v238;
      v893 = v238;
      v947 = v234 & 0xFC00FC | 0xFF00FF00;
      v974 = (v234 >> 8) & 0xFC00FC | 0xFF00FF00;
      v243 = v238;
      v244 = (signed int *)&unk_EF160;
      v245 = 0;
      v246 = v974 - v240;
      v247 = v241 - v240;
      v842 = v242;
      while ( 1 )
      {
        v244 += 4;
        v248 = v223 & (v247 + v243);
        v249 = v221 & (v246 + v243);
        v250 = v243 + v842;
        v245 ^= v243 & v222;
        v243 += 524296;
        v232 ^= v248;
        v231 ^= v249;
        v233 ^= v239 & v250;
        if ( v244 == (signed int *)"triple-DES inner-CBC" )
          break;
        v222 = *v244;
        v239 = v244[1];
        v223 = v244[2];
        v221 = v244[3];
      }
      v251 = 234941184;
      v252 = -2097117952;
      v253 = 2063609344;
      v254 = ((16 * v233 & 15360 * ((v920 + 16777472) & 0x40004) ^ v233) >> 4) & 0xF000F00 | ((16 * v245 & 15360 * ((v893 + 16777472) & 0x40004) ^ v245) >> 12) & 0xF000F | (v231 ^ 16 * v231 & 15360 * ((v974 + 16777472) & 0x40004)) & 0xF000F000;
      v255 = v254 | ((v232 ^ 16 * v232 & 15360 * ((v947 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v256 = (v255 ^ ((v254 | ((v232 ^ 16 * v232 & 15360 * ((v947 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v257 = (16 * v256 ^ v256 ^ v255 ^ ((16 * v256 ^ v256 ^ v255) >> 8)) & 0x4E009E ^ 16 * v256 ^ v256 ^ v255 ^ (((16 * v256 ^ v256 ^ v255 ^ ((16 * v256 ^ v256 ^ v255) >> 8)) & 0x4E009E) << 8);
      v258 = ((unsigned __int16)((v257 ^ HIWORD(v257)) & 0xD9D3) << 16) ^ ((unsigned __int16)v257 ^ HIWORD(v257)) & 0xD9D3 ^ v257;
      v259 = 16 * ((v258 ^ (v258 >> 4)) & 0x5040004) ^ (v258 ^ (v258 >> 4)) & 0x5040004 ^ v258;
      v260 = 2 * ((v259 ^ (v259 >> 1)) & 0x4045015) ^ (v259 ^ (v259 >> 1)) & 0x4045015 ^ v873 ^ v259;
      v261 = 0;
      v874 = v260;
      v262 = 0;
      v263 = 0;
      v264 = v260 ^ *(_DWORD *)(v852 - 108);
      v265 = *(_DWORD *)(v852 - 44) ^ __ROL4__(v260, 4);
      v266 = v265;
      v267 = (v265 >> 8) & 0xFC00FC | 0xFF00FF00;
      v268 = v266 & 0xFC00FC;
      v269 = -167733504;
      v921 = v267;
      v268 |= 0xFF00FF00;
      v270 = v268;
      v271 = v264 & 0xFC00FC | 0xFF00FF00;
      v272 = v267 - v268;
      v894 = v268;
      v948 = v264 & 0xFC00FC | 0xFF00FF00;
      v975 = (v264 >> 8) & 0xFC00FC | 0xFF00FF00;
      v273 = v268;
      v274 = (signed int *)&unk_EF160;
      v275 = 0;
      v276 = v975 - v270;
      v277 = v271 - v270;
      while ( 1 )
      {
        v274 += 4;
        v278 = v251 & (v276 + v273);
        v275 ^= v273 & v252;
        v279 = v273 + v272;
        v262 ^= v253 & (v277 + v273);
        v273 += 524296;
        v261 ^= v278;
        v263 ^= v269 & v279;
        if ( v274 == (signed int *)"triple-DES inner-CBC" )
          break;
        v252 = *v274;
        v269 = v274[1];
        v253 = v274[2];
        v251 = v274[3];
      }
      v280 = 234941184;
      v281 = -2097117952;
      v282 = 2063609344;
      v283 = ((16 * v263 & 15360 * ((v921 + 16777472) & 0x40004) ^ v263) >> 4) & 0xF000F00 | ((16 * v275 & 15360 * ((v894 + 16777472) & 0x40004) ^ v275) >> 12) & 0xF000F | (v261 ^ 16 * v261 & 15360 * ((v975 + 16777472) & 0x40004)) & 0xF000F000;
      v284 = v283 | ((v262 ^ 16 * v262 & 15360 * ((v948 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v285 = (v284 ^ ((v283 | ((v262 ^ 16 * v262 & 15360 * ((v948 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v286 = (16 * v285 ^ v285 ^ v284 ^ ((16 * v285 ^ v285 ^ v284) >> 8)) & 0x4E009E ^ 16 * v285 ^ v285 ^ v284 ^ (((16 * v285 ^ v285 ^ v284 ^ ((16 * v285 ^ v285 ^ v284) >> 8)) & 0x4E009E) << 8);
      v287 = ((unsigned __int16)((v286 ^ HIWORD(v286)) & 0xD9D3) << 16) ^ ((unsigned __int16)v286 ^ HIWORD(v286)) & 0xD9D3 ^ v286;
      v288 = 16 * ((v287 ^ (v287 >> 4)) & 0x5040004) ^ (v287 ^ (v287 >> 4)) & 0x5040004 ^ v287;
      v289 = 2 * ((v288 ^ (v288 >> 1)) & 0x4045015) ^ (v288 ^ (v288 >> 1)) & 0x4045015 ^ v859 ^ v288;
      v290 = 0;
      v860 = v289;
      v291 = 0;
      v292 = 0;
      v293 = v289 ^ *(_DWORD *)(v852 - 112);
      v294 = *(_DWORD *)(v852 - 48) ^ __ROL4__(v289, 4);
      v295 = v294;
      v296 = (v294 >> 8) & 0xFC00FC | 0xFF00FF00;
      v297 = v295 & 0xFC00FC;
      v298 = -167733504;
      v922 = v296;
      v297 |= 0xFF00FF00;
      v299 = v297;
      v300 = v293 & 0xFC00FC | 0xFF00FF00;
      v301 = v296 - v297;
      v895 = v297;
      v949 = v293 & 0xFC00FC | 0xFF00FF00;
      v976 = (v293 >> 8) & 0xFC00FC | 0xFF00FF00;
      v302 = v297;
      v303 = (signed int *)&unk_EF160;
      v304 = 0;
      v305 = v976 - v299;
      v306 = v300 - v299;
      v843 = v301;
      while ( 1 )
      {
        v303 += 4;
        v307 = v282 & (v306 + v302);
        v308 = v280 & (v305 + v302);
        v309 = v302 + v843;
        v304 ^= v302 & v281;
        v302 += 524296;
        v291 ^= v307;
        v290 ^= v308;
        v292 ^= v298 & v309;
        if ( v303 == (signed int *)"triple-DES inner-CBC" )
          break;
        v281 = *v303;
        v298 = v303[1];
        v282 = v303[2];
        v280 = v303[3];
      }
      v310 = 234941184;
      v311 = -2097117952;
      v312 = 2063609344;
      v313 = ((16 * v292 & 15360 * ((v922 + 16777472) & 0x40004) ^ v292) >> 4) & 0xF000F00 | ((16 * v304 & 15360 * ((v895 + 16777472) & 0x40004) ^ v304) >> 12) & 0xF000F | (v290 ^ 16 * v290 & 15360 * ((v976 + 16777472) & 0x40004)) & 0xF000F000;
      v314 = v313 | ((v291 ^ 16 * v291 & 15360 * ((v949 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v315 = (v314 ^ ((v313 | ((v291 ^ 16 * v291 & 15360 * ((v949 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v316 = (16 * v315 ^ v315 ^ v314 ^ ((16 * v315 ^ v315 ^ v314) >> 8)) & 0x4E009E ^ 16 * v315 ^ v315 ^ v314 ^ (((16 * v315 ^ v315 ^ v314 ^ ((16 * v315 ^ v315 ^ v314) >> 8)) & 0x4E009E) << 8);
      v317 = ((unsigned __int16)((v316 ^ HIWORD(v316)) & 0xD9D3) << 16) ^ ((unsigned __int16)v316 ^ HIWORD(v316)) & 0xD9D3 ^ v316;
      v318 = 16 * ((v317 ^ (v317 >> 4)) & 0x5040004) ^ (v317 ^ (v317 >> 4)) & 0x5040004 ^ v317;
      v319 = 2 * ((v318 ^ (v318 >> 1)) & 0x4045015) ^ (v318 ^ (v318 >> 1)) & 0x4045015 ^ v874 ^ v318;
      v320 = 0;
      v875 = v319;
      v321 = 0;
      v322 = 0;
      v323 = v319 ^ *(_DWORD *)(v852 - 116);
      v324 = *(_DWORD *)(v852 - 52) ^ __ROL4__(v319, 4);
      v325 = v324;
      v326 = (v324 >> 8) & 0xFC00FC | 0xFF00FF00;
      v327 = v325 & 0xFC00FC;
      v328 = -167733504;
      v923 = v326;
      v327 |= 0xFF00FF00;
      v329 = v327;
      v330 = v323 & 0xFC00FC | 0xFF00FF00;
      v331 = v326 - v327;
      v896 = v327;
      v950 = v323 & 0xFC00FC | 0xFF00FF00;
      v977 = (v323 >> 8) & 0xFC00FC | 0xFF00FF00;
      v332 = v327;
      v333 = (signed int *)&unk_EF160;
      v334 = 0;
      v335 = v977 - v329;
      v336 = v330 - v329;
      while ( 1 )
      {
        v333 += 4;
        v337 = v310 & (v335 + v332);
        v334 ^= v332 & v311;
        v338 = v332 + v331;
        v321 ^= v312 & (v336 + v332);
        v332 += 524296;
        v320 ^= v337;
        v322 ^= v328 & v338;
        if ( v333 == (signed int *)"triple-DES inner-CBC" )
          break;
        v311 = *v333;
        v328 = v333[1];
        v312 = v333[2];
        v310 = v333[3];
      }
      v339 = 234941184;
      v340 = -2097117952;
      v341 = 2063609344;
      v342 = ((16 * v322 & 15360 * ((v923 + 16777472) & 0x40004) ^ v322) >> 4) & 0xF000F00 | ((16 * v334 & 15360 * ((v896 + 16777472) & 0x40004) ^ v334) >> 12) & 0xF000F | (v320 ^ 16 * v320 & 15360 * ((v977 + 16777472) & 0x40004)) & 0xF000F000;
      v343 = v342 | ((v321 ^ 16 * v321 & 15360 * ((v950 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v344 = (v343 ^ ((v342 | ((v321 ^ 16 * v321 & 15360 * ((v950 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v345 = (16 * v344 ^ v344 ^ v343 ^ ((16 * v344 ^ v344 ^ v343) >> 8)) & 0x4E009E ^ 16 * v344 ^ v344 ^ v343 ^ (((16 * v344 ^ v344 ^ v343 ^ ((16 * v344 ^ v344 ^ v343) >> 8)) & 0x4E009E) << 8);
      v346 = ((unsigned __int16)((v345 ^ HIWORD(v345)) & 0xD9D3) << 16) ^ ((unsigned __int16)v345 ^ HIWORD(v345)) & 0xD9D3 ^ v345;
      v347 = 16 * ((v346 ^ (v346 >> 4)) & 0x5040004) ^ (v346 ^ (v346 >> 4)) & 0x5040004 ^ v346;
      v348 = 2 * ((v347 ^ (v347 >> 1)) & 0x4045015) ^ (v347 ^ (v347 >> 1)) & 0x4045015 ^ v860 ^ v347;
      v349 = 0;
      v861 = v348;
      v350 = 0;
      v351 = 0;
      v352 = v348 ^ *(_DWORD *)(v852 - 120);
      v353 = *(_DWORD *)(v852 - 56) ^ __ROL4__(v348, 4);
      v354 = v353;
      v355 = (v353 >> 8) & 0xFC00FC | 0xFF00FF00;
      v356 = v354 & 0xFC00FC;
      v357 = -167733504;
      v924 = v355;
      v356 |= 0xFF00FF00;
      v358 = v356;
      v359 = v352 & 0xFC00FC | 0xFF00FF00;
      v360 = v355 - v356;
      v897 = v356;
      v951 = v352 & 0xFC00FC | 0xFF00FF00;
      v978 = (v352 >> 8) & 0xFC00FC | 0xFF00FF00;
      v361 = v356;
      v362 = (signed int *)&unk_EF160;
      v363 = 0;
      v364 = v978 - v358;
      v365 = v359 - v358;
      v844 = v360;
      while ( 1 )
      {
        v362 += 4;
        v366 = v341 & (v365 + v361);
        v367 = v339 & (v364 + v361);
        v368 = v361 + v844;
        v363 ^= v361 & v340;
        v361 += 524296;
        v350 ^= v366;
        v349 ^= v367;
        v351 ^= v357 & v368;
        if ( v362 == (signed int *)"triple-DES inner-CBC" )
          break;
        v340 = *v362;
        v357 = v362[1];
        v341 = v362[2];
        v339 = v362[3];
      }
      v369 = 234941184;
      v370 = -2097117952;
      v371 = 2063609344;
      v372 = ((16 * v351 & 15360 * ((v924 + 16777472) & 0x40004) ^ v351) >> 4) & 0xF000F00 | ((16 * v363 & 15360 * ((v897 + 16777472) & 0x40004) ^ v363) >> 12) & 0xF000F | (v349 ^ 16 * v349 & 15360 * ((v978 + 16777472) & 0x40004)) & 0xF000F000;
      v373 = v372 | ((v350 ^ 16 * v350 & 15360 * ((v951 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v374 = (v373 ^ ((v372 | ((v350 ^ 16 * v350 & 15360 * ((v951 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v375 = (16 * v374 ^ v374 ^ v373 ^ ((16 * v374 ^ v374 ^ v373) >> 8)) & 0x4E009E ^ 16 * v374 ^ v374 ^ v373 ^ (((16 * v374 ^ v374 ^ v373 ^ ((16 * v374 ^ v374 ^ v373) >> 8)) & 0x4E009E) << 8);
      v376 = ((unsigned __int16)((v375 ^ HIWORD(v375)) & 0xD9D3) << 16) ^ ((unsigned __int16)v375 ^ HIWORD(v375)) & 0xD9D3 ^ v375;
      v377 = 16 * ((v376 ^ (v376 >> 4)) & 0x5040004) ^ (v376 ^ (v376 >> 4)) & 0x5040004 ^ v376;
      v378 = 2 * ((v377 ^ (v377 >> 1)) & 0x4045015) ^ (v377 ^ (v377 >> 1)) & 0x4045015 ^ v875 ^ v377;
      v379 = 0;
      v876 = v378;
      v380 = 0;
      v381 = 0;
      v382 = v378 ^ *(_DWORD *)(v852 - 124);
      v383 = *(_DWORD *)(v852 - 60) ^ __ROL4__(v378, 4);
      v384 = v383;
      v385 = (v383 >> 8) & 0xFC00FC | 0xFF00FF00;
      v386 = v384 & 0xFC00FC;
      v387 = -167733504;
      v925 = v385;
      v386 |= 0xFF00FF00;
      v388 = v386;
      v389 = v382 & 0xFC00FC | 0xFF00FF00;
      v390 = v385 - v386;
      v898 = v386;
      v952 = v382 & 0xFC00FC | 0xFF00FF00;
      v979 = (v382 >> 8) & 0xFC00FC | 0xFF00FF00;
      v391 = v386;
      v392 = (signed int *)&unk_EF160;
      v393 = 0;
      v394 = v979 - v388;
      v395 = v389 - v388;
      while ( 1 )
      {
        v392 += 4;
        v396 = v369 & (v394 + v391);
        v393 ^= v391 & v370;
        v397 = v391 + v390;
        v380 ^= v371 & (v395 + v391);
        v391 += 524296;
        v379 ^= v396;
        v381 ^= v387 & v397;
        if ( v392 == (signed int *)"triple-DES inner-CBC" )
          break;
        v370 = *v392;
        v387 = v392[1];
        v371 = v392[2];
        v369 = v392[3];
      }
      v398 = 234941184;
      v399 = -2097117952;
      v400 = 2063609344;
      v401 = ((16 * v381 & 15360 * ((v925 + 16777472) & 0x40004) ^ v381) >> 4) & 0xF000F00 | ((16 * v393 & 15360 * ((v898 + 16777472) & 0x40004) ^ v393) >> 12) & 0xF000F | (v379 ^ 16 * v379 & 15360 * ((v979 + 16777472) & 0x40004)) & 0xF000F000;
      v402 = v401 | ((v380 ^ 16 * v380 & 15360 * ((v952 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v403 = (v402 ^ ((v401 | ((v380 ^ 16 * v380 & 15360 * ((v952 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v404 = (16 * v403 ^ v403 ^ v402 ^ ((16 * v403 ^ v403 ^ v402) >> 8)) & 0x4E009E ^ 16 * v403 ^ v403 ^ v402 ^ (((16 * v403 ^ v403 ^ v402 ^ ((16 * v403 ^ v403 ^ v402) >> 8)) & 0x4E009E) << 8);
      v405 = ((unsigned __int16)((v404 ^ HIWORD(v404)) & 0xD9D3) << 16) ^ ((unsigned __int16)v404 ^ HIWORD(v404)) & 0xD9D3 ^ v404;
      v406 = 16 * ((v405 ^ (v405 >> 4)) & 0x5040004) ^ (v405 ^ (v405 >> 4)) & 0x5040004 ^ v405;
      v407 = 2 * ((v406 ^ (v406 >> 1)) & 0x4045015) ^ (v406 ^ (v406 >> 1)) & 0x4045015 ^ v861 ^ v406;
      v408 = 0;
      v862 = v407;
      v409 = 0;
      v410 = 0;
      v411 = v407 ^ *(_DWORD *)(v852 - 128);
      v412 = *(_DWORD *)(v852 - 64) ^ __ROL4__(v407, 4);
      v413 = v412;
      v414 = (v412 >> 8) & 0xFC00FC | 0xFF00FF00;
      v415 = v413 & 0xFC00FC;
      v416 = -167733504;
      v926 = v414;
      v415 |= 0xFF00FF00;
      v417 = v415;
      v418 = v411 & 0xFC00FC | 0xFF00FF00;
      v419 = v414 - v415;
      v899 = v415;
      v953 = v411 & 0xFC00FC | 0xFF00FF00;
      v980 = (v411 >> 8) & 0xFC00FC | 0xFF00FF00;
      v420 = v415;
      v421 = (signed int *)&unk_EF160;
      v422 = 0;
      v423 = v980 - v417;
      v424 = v418 - v417;
      v845 = v419;
      while ( 1 )
      {
        v421 += 4;
        v425 = v400 & (v424 + v420);
        v426 = v398 & (v423 + v420);
        v427 = v420 + v845;
        v422 ^= v420 & v399;
        v420 += 524296;
        v409 ^= v425;
        v408 ^= v426;
        v410 ^= v416 & v427;
        if ( v421 == (signed int *)"triple-DES inner-CBC" )
          break;
        v399 = *v421;
        v416 = v421[1];
        v400 = v421[2];
        v398 = v421[3];
      }
      v428 = 234941184;
      v429 = -2097117952;
      v430 = 2063609344;
      v431 = ((16 * v410 & 15360 * ((v926 + 16777472) & 0x40004) ^ v410) >> 4) & 0xF000F00 | ((16 * v422 & 15360 * ((v899 + 16777472) & 0x40004) ^ v422) >> 12) & 0xF000F | (v408 ^ 16 * v408 & 15360 * ((v980 + 16777472) & 0x40004)) & 0xF000F000;
      v432 = v431 | ((v409 ^ 16 * v409 & 15360 * ((v953 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v433 = (v432 ^ ((v431 | ((v409 ^ 16 * v409 & 15360 * ((v953 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v434 = (16 * v433 ^ v433 ^ v432 ^ ((16 * v433 ^ v433 ^ v432) >> 8)) & 0x4E009E ^ 16 * v433 ^ v433 ^ v432 ^ (((16 * v433 ^ v433 ^ v432 ^ ((16 * v433 ^ v433 ^ v432) >> 8)) & 0x4E009E) << 8);
      v435 = ((unsigned __int16)((v434 ^ HIWORD(v434)) & 0xD9D3) << 16) ^ ((unsigned __int16)v434 ^ HIWORD(v434)) & 0xD9D3 ^ v434;
      v436 = 16 * ((v435 ^ (v435 >> 4)) & 0x5040004) ^ (v435 ^ (v435 >> 4)) & 0x5040004 ^ v435;
      v437 = 2 * ((v436 ^ (v436 >> 1)) & 0x4045015) ^ (v436 ^ (v436 >> 1)) & 0x4045015 ^ v876 ^ v436;
      v438 = 0;
      v877 = v437;
      v439 = 0;
      v440 = 0;
      v441 = v437 ^ *(_DWORD *)(v852 - 132);
      v442 = *(_DWORD *)(v852 - 68) ^ __ROL4__(v437, 4);
      v443 = v442;
      v444 = (v442 >> 8) & 0xFC00FC | 0xFF00FF00;
      v445 = v443 & 0xFC00FC;
      v446 = -167733504;
      v927 = v444;
      v445 |= 0xFF00FF00;
      v447 = v445;
      v448 = v441 & 0xFC00FC | 0xFF00FF00;
      v449 = v444 - v445;
      v900 = v445;
      v954 = v441 & 0xFC00FC | 0xFF00FF00;
      v981 = (v441 >> 8) & 0xFC00FC | 0xFF00FF00;
      v450 = v445;
      v451 = (signed int *)&unk_EF160;
      v452 = 0;
      v453 = v981 - v447;
      v454 = v448 - v447;
      while ( 1 )
      {
        v451 += 4;
        v455 = v428 & (v453 + v450);
        v452 ^= v450 & v429;
        v456 = v450 + v449;
        v439 ^= v430 & (v454 + v450);
        v450 += 524296;
        v438 ^= v455;
        v440 ^= v446 & v456;
        if ( v451 == (signed int *)"triple-DES inner-CBC" )
          break;
        v429 = *v451;
        v446 = v451[1];
        v430 = v451[2];
        v428 = v451[3];
      }
      v457 = 234941184;
      v458 = -2097117952;
      v459 = 2063609344;
      v460 = ((16 * v440 & 15360 * ((v927 + 16777472) & 0x40004) ^ v440) >> 4) & 0xF000F00 | ((16 * v452 & 15360 * ((v900 + 16777472) & 0x40004) ^ v452) >> 12) & 0xF000F | (v438 ^ 16 * v438 & 15360 * ((v981 + 16777472) & 0x40004)) & 0xF000F000;
      v461 = v460 | ((v439 ^ 16 * v439 & 15360 * ((v954 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v462 = (v461 ^ ((v460 | ((v439 ^ 16 * v439 & 15360 * ((v954 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v463 = (16 * v462 ^ v462 ^ v461 ^ ((16 * v462 ^ v462 ^ v461) >> 8)) & 0x4E009E ^ 16 * v462 ^ v462 ^ v461 ^ (((16 * v462 ^ v462 ^ v461 ^ ((16 * v462 ^ v462 ^ v461) >> 8)) & 0x4E009E) << 8);
      v464 = ((unsigned __int16)((v463 ^ HIWORD(v463)) & 0xD9D3) << 16) ^ ((unsigned __int16)v463 ^ HIWORD(v463)) & 0xD9D3 ^ v463;
      v465 = 16 * ((v464 ^ (v464 >> 4)) & 0x5040004) ^ (v464 ^ (v464 >> 4)) & 0x5040004 ^ v464;
      v466 = 2 * ((v465 ^ (v465 >> 1)) & 0x4045015) ^ (v465 ^ (v465 >> 1)) & 0x4045015 ^ v862 ^ v465;
      v467 = 0;
      LODWORD(v854) = v466;
      v468 = 0;
      v469 = 0;
      v470 = v466 ^ *(_DWORD *)(v852 - 136);
      v471 = *(_DWORD *)(v852 - 72) ^ __ROL4__(v466, 4);
      v472 = v471;
      v473 = (v471 >> 8) & 0xFC00FC | 0xFF00FF00;
      v474 = v472 & 0xFC00FC;
      v475 = -167733504;
      v928 = v473;
      v474 |= 0xFF00FF00;
      v476 = v474;
      v477 = v470 & 0xFC00FC | 0xFF00FF00;
      v478 = v473 - v474;
      v901 = v474;
      v955 = v470 & 0xFC00FC | 0xFF00FF00;
      v982 = (v470 >> 8) & 0xFC00FC | 0xFF00FF00;
      v479 = v474;
      v480 = (signed int *)&unk_EF160;
      v481 = 0;
      v482 = v982 - v476;
      v483 = v477 - v476;
      v846 = v478;
      while ( 1 )
      {
        v480 += 4;
        v484 = v459 & (v483 + v479);
        v485 = v457 & (v482 + v479);
        v486 = v479 + v846;
        v481 ^= v479 & v458;
        v479 += 524296;
        v468 ^= v484;
        v467 ^= v485;
        v469 ^= v475 & v486;
        if ( v480 == (signed int *)"triple-DES inner-CBC" )
          break;
        v458 = *v480;
        v475 = v480[1];
        v459 = v480[2];
        v457 = v480[3];
      }
      v487 = ((16 * v469 & 15360 * ((v928 + 16777472) & 0x40004) ^ v469) >> 4) & 0xF000F00 | ((16 * v481 & 15360 * ((v901 + 16777472) & 0x40004) ^ v481) >> 12) & 0xF000F | (v467 ^ 16 * v467 & 15360 * ((v982 + 16777472) & 0x40004)) & 0xF000F000 | ((v468 ^ 16 * v468 & 15360 * ((v955 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v488 = (v487 ^ (v487 >> 4)) & 0x7030702;
      v489 = (16 * v488 ^ v488 ^ v487 ^ ((16 * v488 ^ v488 ^ v487) >> 8)) & 0x4E009E ^ 16 * v488 ^ v488 ^ v487 ^ (((16 * v488 ^ v488 ^ v487 ^ ((16 * v488 ^ v488 ^ v487) >> 8)) & 0x4E009E) << 8);
      v490 = ((unsigned __int16)((v489 ^ HIWORD(v489)) & 0xD9D3) << 16) ^ ((unsigned __int16)v489 ^ HIWORD(v489)) & 0xD9D3 ^ v489;
      v491 = 16 * ((v490 ^ (v490 >> 4)) & 0x5040004) ^ (v490 ^ (v490 >> 4)) & 0x5040004 ^ v490;
      v492 = 0;
      v493 = 0;
      v494 = sub_634C0(
               (v854 << 32) | 2 * ((v491 ^ (v491 >> 1)) & 0x4045015) ^ (v491 ^ (v491 >> 1)) & 0x4045015 ^ v491 ^ v877,
               v995,
               0LL,
               1LL);
      v863 = v494;
      v494 >>= 32;
      v983 = v494;
      v495 = 234941184;
      v496 = 2063609344;
      v497 = -2097117952;
      v498 = 0;
      v499 = v494 ^ *(_DWORD *)(v852 - 332);
      LODWORD(v494) = *(_DWORD *)(v852 - 268) ^ __ROL4__(v494, 4);
      v500 = v494;
      LODWORD(v494) = ((unsigned int)v494 >> 8) & 0xFC00FC | 0xFF00FF00;
      v501 = v500 & 0xFC00FC;
      v502 = -167733504;
      v902 = v494;
      v501 |= 0xFF00FF00;
      v503 = v501;
      v504 = v499 & 0xFC00FC | 0xFF00FF00;
      v505 = v494 - v501;
      v878 = v501;
      v929 = v499 & 0xFC00FC | 0xFF00FF00;
      v956 = (v499 >> 8) & 0xFC00FC | 0xFF00FF00;
      v506 = v501;
      v507 = (signed int *)&unk_EF160;
      v508 = 0;
      v509 = v956 - v503;
      v510 = v504 - v503;
      while ( 1 )
      {
        v507 += 4;
        v511 = v495 & (v509 + v506);
        v508 ^= v506 & v497;
        v512 = v506 + v505;
        v493 ^= v496 & (v510 + v506);
        v506 += 524296;
        v492 ^= v511;
        v498 ^= v502 & v512;
        if ( v507 == (signed int *)"triple-DES inner-CBC" )
          break;
        v497 = *v507;
        v502 = v507[1];
        v496 = v507[2];
        v495 = v507[3];
      }
      v513 = v852;
      v514 = ((16 * v498 & 15360 * ((v902 + 16777472) & 0x40004) ^ v498) >> 4) & 0xF000F00 | ((16 * v508 & 15360 * ((v878 + 16777472) & 0x40004) ^ v508) >> 12) & 0xF000F | (v492 ^ 16 * v492 & 15360 * ((v956 + 16777472) & 0x40004)) & 0xF000F000;
      v515 = v514 | ((v493 ^ 16 * v493 & 15360 * ((v929 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v516 = (v515 ^ ((v514 | ((v493 ^ 16 * v493 & 15360 * ((v929 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v517 = (16 * v516 ^ v516 ^ v515 ^ ((16 * v516 ^ v516 ^ v515) >> 8)) & 0x4E009E ^ 16 * v516 ^ v516 ^ v515 ^ (((16 * v516 ^ v516 ^ v515 ^ ((16 * v516 ^ v516 ^ v515) >> 8)) & 0x4E009E) << 8);
      v518 = ((unsigned __int16)((v517 ^ HIWORD(v517)) & 0xD9D3) << 16) ^ ((unsigned __int16)v517 ^ HIWORD(v517)) & 0xD9D3 ^ v517;
      v519 = 16 * ((v518 ^ (v518 >> 4)) & 0x5040004) ^ (v518 ^ (v518 >> 4)) & 0x5040004 ^ v518;
      v520 = 2 * ((v519 ^ (v519 >> 1)) & 0x4045015) ^ (v519 ^ (v519 >> 1)) & 0x4045015 ^ v519 ^ v863;
      v521 = 0;
      v522 = 0;
      v523 = (unsigned __int64)sub_630F0(v520, *(_DWORD *)(v852 - 336), *(_DWORD *)(v852 - 272)) ^ v983;
      v524 = (unsigned __int64)sub_630F0(v523, *(_DWORD *)(v513 - 340), *(_DWORD *)(v513 - 276)) ^ v520;
      v525 = (unsigned __int64)sub_630F0(v524, *(_DWORD *)(v513 - 344), *(_DWORD *)(v513 - 280)) ^ v523;
      v864 = (unsigned __int64)sub_630F0(v525, *(_DWORD *)(v513 - 348), *(_DWORD *)(v513 - 284)) ^ v524;
      v526 = (unsigned __int64)sub_630F0(v864, *(_DWORD *)(v513 - 352), *(_DWORD *)(v513 - 288)) ^ v525;
      v527 = 234941184;
      v879 = v526;
      v528 = 2063609344;
      v529 = *(_DWORD *)(v852 - 292) ^ __ROL4__(v526, 4);
      v530 = -2097117952;
      v531 = v526 ^ *(_DWORD *)(v852 - 356);
      v532 = 0;
      v533 = v529;
      v534 = (v529 >> 8) & 0xFC00FC | 0xFF00FF00;
      v535 = v533 & 0xFC00FC;
      v536 = -167733504;
      v930 = v534;
      v535 |= 0xFF00FF00;
      v537 = v535;
      LODWORD(v513) = v531 & 0xFC00FC | 0xFF00FF00;
      v538 = v534 - v535;
      v903 = v535;
      v957 = v531 & 0xFC00FC | 0xFF00FF00;
      v984 = (v531 >> 8) & 0xFC00FC | 0xFF00FF00;
      v539 = v535;
      v540 = (signed int *)&unk_EF160;
      v541 = 0;
      v542 = v984 - v537;
      v543 = v513 - v537;
      v847 = v538;
      while ( 1 )
      {
        v540 += 4;
        v544 = v528 & (v543 + v539);
        v545 = v527 & (v542 + v539);
        v546 = v539 + v847;
        v541 ^= v539 & v530;
        v539 += 524296;
        v522 ^= v544;
        v521 ^= v545;
        v532 ^= v536 & v546;
        if ( v540 == (signed int *)"triple-DES inner-CBC" )
          break;
        v530 = *v540;
        v536 = v540[1];
        v528 = v540[2];
        v527 = v540[3];
      }
      v547 = 234941184;
      v548 = -2097117952;
      v549 = 2063609344;
      v550 = ((16 * v532 & 15360 * ((v930 + 16777472) & 0x40004) ^ v532) >> 4) & 0xF000F00 | ((16 * v541 & 15360 * ((v903 + 16777472) & 0x40004) ^ v541) >> 12) & 0xF000F | (v521 ^ 16 * v521 & 15360 * ((v984 + 16777472) & 0x40004)) & 0xF000F000;
      v551 = v550 | ((v522 ^ 16 * v522 & 15360 * ((v957 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v552 = (v551 ^ ((v550 | ((v522 ^ 16 * v522 & 15360 * ((v957 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v553 = (16 * v552 ^ v552 ^ v551 ^ ((16 * v552 ^ v552 ^ v551) >> 8)) & 0x4E009E ^ 16 * v552 ^ v552 ^ v551 ^ (((16 * v552 ^ v552 ^ v551 ^ ((16 * v552 ^ v552 ^ v551) >> 8)) & 0x4E009E) << 8);
      v554 = ((unsigned __int16)((v553 ^ HIWORD(v553)) & 0xD9D3) << 16) ^ ((unsigned __int16)v553 ^ HIWORD(v553)) & 0xD9D3 ^ v553;
      v555 = 16 * ((v554 ^ (v554 >> 4)) & 0x5040004) ^ (v554 ^ (v554 >> 4)) & 0x5040004 ^ v554;
      v556 = 2 * ((v555 ^ (v555 >> 1)) & 0x4045015) ^ (v555 ^ (v555 >> 1)) & 0x4045015 ^ v864 ^ v555;
      v557 = 0;
      v865 = v556;
      v558 = 0;
      v559 = 0;
      v560 = v556 ^ *(_DWORD *)(v852 - 360);
      v561 = *(_DWORD *)(v852 - 296) ^ __ROL4__(v556, 4);
      v562 = v561;
      v563 = (v561 >> 8) & 0xFC00FC | 0xFF00FF00;
      v564 = v562 & 0xFC00FC;
      v565 = -167733504;
      v931 = v563;
      v564 |= 0xFF00FF00;
      v566 = v564;
      v567 = v560 & 0xFC00FC | 0xFF00FF00;
      v568 = v563 - v564;
      v904 = v564;
      v958 = v560 & 0xFC00FC | 0xFF00FF00;
      v985 = (v560 >> 8) & 0xFC00FC | 0xFF00FF00;
      v569 = v564;
      v570 = (signed int *)&unk_EF160;
      v571 = 0;
      v572 = v985 - v566;
      v573 = v567 - v566;
      while ( 1 )
      {
        v570 += 4;
        v574 = v547 & (v572 + v569);
        v571 ^= v569 & v548;
        v575 = v569 + v568;
        v558 ^= v549 & (v573 + v569);
        v569 += 524296;
        v557 ^= v574;
        v559 ^= v565 & v575;
        if ( v570 == (signed int *)"triple-DES inner-CBC" )
          break;
        v548 = *v570;
        v565 = v570[1];
        v549 = v570[2];
        v547 = v570[3];
      }
      v576 = 234941184;
      v577 = -2097117952;
      v578 = 2063609344;
      v579 = ((16 * v559 & 15360 * ((v931 + 16777472) & 0x40004) ^ v559) >> 4) & 0xF000F00 | ((16 * v571 & 15360 * ((v904 + 16777472) & 0x40004) ^ v571) >> 12) & 0xF000F | (v557 ^ 16 * v557 & 15360 * ((v985 + 16777472) & 0x40004)) & 0xF000F000;
      v580 = v579 | ((v558 ^ 16 * v558 & 15360 * ((v958 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v581 = (v580 ^ ((v579 | ((v558 ^ 16 * v558 & 15360 * ((v958 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v582 = (16 * v581 ^ v581 ^ v580 ^ ((16 * v581 ^ v581 ^ v580) >> 8)) & 0x4E009E ^ 16 * v581 ^ v581 ^ v580 ^ (((16 * v581 ^ v581 ^ v580 ^ ((16 * v581 ^ v581 ^ v580) >> 8)) & 0x4E009E) << 8);
      v583 = ((unsigned __int16)((v582 ^ HIWORD(v582)) & 0xD9D3) << 16) ^ ((unsigned __int16)v582 ^ HIWORD(v582)) & 0xD9D3 ^ v582;
      v584 = 16 * ((v583 ^ (v583 >> 4)) & 0x5040004) ^ (v583 ^ (v583 >> 4)) & 0x5040004 ^ v583;
      v585 = 2 * ((v584 ^ (v584 >> 1)) & 0x4045015) ^ (v584 ^ (v584 >> 1)) & 0x4045015 ^ v879 ^ v584;
      v586 = 0;
      v880 = v585;
      v587 = 0;
      v588 = 0;
      v589 = v585 ^ *(_DWORD *)(v852 - 364);
      v590 = *(_DWORD *)(v852 - 300) ^ __ROL4__(v585, 4);
      v591 = v590;
      v592 = (v590 >> 8) & 0xFC00FC | 0xFF00FF00;
      v593 = v591 & 0xFC00FC;
      v594 = -167733504;
      v932 = v592;
      v593 |= 0xFF00FF00;
      v595 = v593;
      v596 = v589 & 0xFC00FC | 0xFF00FF00;
      v597 = v592 - v593;
      v905 = v593;
      v959 = v589 & 0xFC00FC | 0xFF00FF00;
      v986 = (v589 >> 8) & 0xFC00FC | 0xFF00FF00;
      v598 = v593;
      v599 = (signed int *)&unk_EF160;
      v600 = 0;
      v601 = v986 - v595;
      v602 = v596 - v595;
      v848 = v597;
      while ( 1 )
      {
        v599 += 4;
        v603 = v578 & (v602 + v598);
        v604 = v576 & (v601 + v598);
        v605 = v598 + v848;
        v600 ^= v598 & v577;
        v598 += 524296;
        v587 ^= v603;
        v586 ^= v604;
        v588 ^= v594 & v605;
        if ( v599 == (signed int *)"triple-DES inner-CBC" )
          break;
        v577 = *v599;
        v594 = v599[1];
        v578 = v599[2];
        v576 = v599[3];
      }
      v606 = 234941184;
      v607 = -2097117952;
      v608 = 2063609344;
      v609 = ((16 * v588 & 15360 * ((v932 + 16777472) & 0x40004) ^ v588) >> 4) & 0xF000F00 | ((16 * v600 & 15360 * ((v905 + 16777472) & 0x40004) ^ v600) >> 12) & 0xF000F | (v586 ^ 16 * v586 & 15360 * ((v986 + 16777472) & 0x40004)) & 0xF000F000;
      v610 = v609 | ((v587 ^ 16 * v587 & 15360 * ((v959 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v611 = (v610 ^ ((v609 | ((v587 ^ 16 * v587 & 15360 * ((v959 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v612 = (16 * v611 ^ v611 ^ v610 ^ ((16 * v611 ^ v611 ^ v610) >> 8)) & 0x4E009E ^ 16 * v611 ^ v611 ^ v610 ^ (((16 * v611 ^ v611 ^ v610 ^ ((16 * v611 ^ v611 ^ v610) >> 8)) & 0x4E009E) << 8);
      v613 = ((unsigned __int16)((v612 ^ HIWORD(v612)) & 0xD9D3) << 16) ^ ((unsigned __int16)v612 ^ HIWORD(v612)) & 0xD9D3 ^ v612;
      v614 = 16 * ((v613 ^ (v613 >> 4)) & 0x5040004) ^ (v613 ^ (v613 >> 4)) & 0x5040004 ^ v613;
      v615 = 2 * ((v614 ^ (v614 >> 1)) & 0x4045015) ^ (v614 ^ (v614 >> 1)) & 0x4045015 ^ v865 ^ v614;
      v616 = 0;
      v866 = v615;
      v617 = 0;
      v618 = 0;
      v619 = v615 ^ *(_DWORD *)(v852 - 368);
      v620 = *(_DWORD *)(v852 - 304) ^ __ROL4__(v615, 4);
      v621 = v620;
      v622 = (v620 >> 8) & 0xFC00FC | 0xFF00FF00;
      v623 = v621 & 0xFC00FC;
      v624 = -167733504;
      v933 = v622;
      v623 |= 0xFF00FF00;
      v625 = v623;
      v626 = v619 & 0xFC00FC | 0xFF00FF00;
      v627 = v622 - v623;
      v906 = v623;
      v960 = v619 & 0xFC00FC | 0xFF00FF00;
      v987 = (v619 >> 8) & 0xFC00FC | 0xFF00FF00;
      v628 = v623;
      v629 = (signed int *)&unk_EF160;
      v630 = 0;
      v631 = v987 - v625;
      v632 = v626 - v625;
      while ( 1 )
      {
        v629 += 4;
        v633 = v606 & (v631 + v628);
        v630 ^= v628 & v607;
        v634 = v628 + v627;
        v617 ^= v608 & (v632 + v628);
        v628 += 524296;
        v616 ^= v633;
        v618 ^= v624 & v634;
        if ( v629 == (signed int *)"triple-DES inner-CBC" )
          break;
        v607 = *v629;
        v624 = v629[1];
        v608 = v629[2];
        v606 = v629[3];
      }
      v635 = 234941184;
      v636 = -2097117952;
      v637 = 2063609344;
      v638 = ((16 * v618 & 15360 * ((v933 + 16777472) & 0x40004) ^ v618) >> 4) & 0xF000F00 | ((16 * v630 & 15360 * ((v906 + 16777472) & 0x40004) ^ v630) >> 12) & 0xF000F | (v616 ^ 16 * v616 & 15360 * ((v987 + 16777472) & 0x40004)) & 0xF000F000;
      v639 = v638 | ((v617 ^ 16 * v617 & 15360 * ((v960 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v640 = (v639 ^ ((v638 | ((v617 ^ 16 * v617 & 15360 * ((v960 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v641 = (16 * v640 ^ v640 ^ v639 ^ ((16 * v640 ^ v640 ^ v639) >> 8)) & 0x4E009E ^ 16 * v640 ^ v640 ^ v639 ^ (((16 * v640 ^ v640 ^ v639 ^ ((16 * v640 ^ v640 ^ v639) >> 8)) & 0x4E009E) << 8);
      v642 = ((unsigned __int16)((v641 ^ HIWORD(v641)) & 0xD9D3) << 16) ^ ((unsigned __int16)v641 ^ HIWORD(v641)) & 0xD9D3 ^ v641;
      v643 = 16 * ((v642 ^ (v642 >> 4)) & 0x5040004) ^ (v642 ^ (v642 >> 4)) & 0x5040004 ^ v642;
      v644 = 2 * ((v643 ^ (v643 >> 1)) & 0x4045015) ^ (v643 ^ (v643 >> 1)) & 0x4045015 ^ v880 ^ v643;
      v645 = 0;
      v881 = v644;
      v646 = 0;
      v647 = 0;
      v648 = v644 ^ *(_DWORD *)(v852 - 372);
      v649 = *(_DWORD *)(v852 - 308) ^ __ROL4__(v644, 4);
      v650 = v649;
      v651 = (v649 >> 8) & 0xFC00FC | 0xFF00FF00;
      v652 = v650 & 0xFC00FC;
      v653 = -167733504;
      v934 = v651;
      v652 |= 0xFF00FF00;
      v654 = v652;
      v655 = v648 & 0xFC00FC | 0xFF00FF00;
      v656 = v651 - v652;
      v907 = v652;
      v961 = v648 & 0xFC00FC | 0xFF00FF00;
      v988 = (v648 >> 8) & 0xFC00FC | 0xFF00FF00;
      v657 = v652;
      v658 = (signed int *)&unk_EF160;
      v659 = 0;
      v660 = v988 - v654;
      v661 = v655 - v654;
      v849 = v656;
      while ( 1 )
      {
        v658 += 4;
        v662 = v637 & (v661 + v657);
        v663 = v635 & (v660 + v657);
        v664 = v657 + v849;
        v659 ^= v657 & v636;
        v657 += 524296;
        v646 ^= v662;
        v645 ^= v663;
        v647 ^= v653 & v664;
        if ( v658 == (signed int *)"triple-DES inner-CBC" )
          break;
        v636 = *v658;
        v653 = v658[1];
        v637 = v658[2];
        v635 = v658[3];
      }
      v665 = 234941184;
      v666 = -2097117952;
      v667 = 2063609344;
      v668 = ((16 * v647 & 15360 * ((v934 + 16777472) & 0x40004) ^ v647) >> 4) & 0xF000F00 | ((16 * v659 & 15360 * ((v907 + 16777472) & 0x40004) ^ v659) >> 12) & 0xF000F | (v645 ^ 16 * v645 & 15360 * ((v988 + 16777472) & 0x40004)) & 0xF000F000;
      v669 = v668 | ((v646 ^ 16 * v646 & 15360 * ((v961 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v670 = (v669 ^ ((v668 | ((v646 ^ 16 * v646 & 15360 * ((v961 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v671 = (16 * v670 ^ v670 ^ v669 ^ ((16 * v670 ^ v670 ^ v669) >> 8)) & 0x4E009E ^ 16 * v670 ^ v670 ^ v669 ^ (((16 * v670 ^ v670 ^ v669 ^ ((16 * v670 ^ v670 ^ v669) >> 8)) & 0x4E009E) << 8);
      v672 = ((unsigned __int16)((v671 ^ HIWORD(v671)) & 0xD9D3) << 16) ^ ((unsigned __int16)v671 ^ HIWORD(v671)) & 0xD9D3 ^ v671;
      v673 = 16 * ((v672 ^ (v672 >> 4)) & 0x5040004) ^ (v672 ^ (v672 >> 4)) & 0x5040004 ^ v672;
      v674 = 2 * ((v673 ^ (v673 >> 1)) & 0x4045015) ^ (v673 ^ (v673 >> 1)) & 0x4045015 ^ v866 ^ v673;
      v675 = 0;
      v867 = v674;
      v676 = 0;
      v677 = 0;
      v678 = v674 ^ *(_DWORD *)(v852 - 376);
      v679 = *(_DWORD *)(v852 - 312) ^ __ROL4__(v674, 4);
      v680 = v679;
      v681 = (v679 >> 8) & 0xFC00FC | 0xFF00FF00;
      v682 = v680 & 0xFC00FC;
      v683 = -167733504;
      v935 = v681;
      v682 |= 0xFF00FF00;
      v684 = v682;
      v685 = v678 & 0xFC00FC | 0xFF00FF00;
      v686 = v681 - v682;
      v908 = v682;
      v962 = v678 & 0xFC00FC | 0xFF00FF00;
      v989 = (v678 >> 8) & 0xFC00FC | 0xFF00FF00;
      v687 = v682;
      v688 = (signed int *)&unk_EF160;
      v689 = 0;
      v690 = v989 - v684;
      v691 = v685 - v684;
      while ( 1 )
      {
        v688 += 4;
        v692 = v665 & (v690 + v687);
        v689 ^= v687 & v666;
        v693 = v687 + v686;
        v676 ^= v667 & (v691 + v687);
        v687 += 524296;
        v675 ^= v692;
        v677 ^= v683 & v693;
        if ( v688 == (signed int *)"triple-DES inner-CBC" )
          break;
        v666 = *v688;
        v683 = v688[1];
        v667 = v688[2];
        v665 = v688[3];
      }
      v694 = 234941184;
      v695 = -2097117952;
      v696 = 2063609344;
      v697 = ((16 * v677 & 15360 * ((v935 + 16777472) & 0x40004) ^ v677) >> 4) & 0xF000F00 | ((16 * v689 & 15360 * ((v908 + 16777472) & 0x40004) ^ v689) >> 12) & 0xF000F | (v675 ^ 16 * v675 & 15360 * ((v989 + 16777472) & 0x40004)) & 0xF000F000;
      v698 = v697 | ((v676 ^ 16 * v676 & 15360 * ((v962 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v699 = (v698 ^ ((v697 | ((v676 ^ 16 * v676 & 15360 * ((v962 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v700 = (16 * v699 ^ v699 ^ v698 ^ ((16 * v699 ^ v699 ^ v698) >> 8)) & 0x4E009E ^ 16 * v699 ^ v699 ^ v698 ^ (((16 * v699 ^ v699 ^ v698 ^ ((16 * v699 ^ v699 ^ v698) >> 8)) & 0x4E009E) << 8);
      v701 = ((unsigned __int16)((v700 ^ HIWORD(v700)) & 0xD9D3) << 16) ^ ((unsigned __int16)v700 ^ HIWORD(v700)) & 0xD9D3 ^ v700;
      v702 = 16 * ((v701 ^ (v701 >> 4)) & 0x5040004) ^ (v701 ^ (v701 >> 4)) & 0x5040004 ^ v701;
      v703 = 2 * ((v702 ^ (v702 >> 1)) & 0x4045015) ^ (v702 ^ (v702 >> 1)) & 0x4045015 ^ v881 ^ v702;
      v704 = 0;
      v882 = v703;
      v705 = 0;
      v706 = 0;
      v707 = v703 ^ *(_DWORD *)(v852 - 380);
      v708 = *(_DWORD *)(v852 - 316) ^ __ROL4__(v703, 4);
      v709 = v708;
      v710 = (v708 >> 8) & 0xFC00FC | 0xFF00FF00;
      v711 = v709 & 0xFC00FC;
      v712 = -167733504;
      v936 = v710;
      v711 |= 0xFF00FF00;
      v713 = v711;
      v714 = v707 & 0xFC00FC | 0xFF00FF00;
      v715 = v710 - v711;
      v909 = v711;
      v963 = v707 & 0xFC00FC | 0xFF00FF00;
      v990 = (v707 >> 8) & 0xFC00FC | 0xFF00FF00;
      v716 = v711;
      v717 = (signed int *)&unk_EF160;
      v718 = 0;
      v719 = v990 - v713;
      v720 = v714 - v713;
      v850 = v715;
      while ( 1 )
      {
        v717 += 4;
        v721 = v696 & (v720 + v716);
        v722 = v694 & (v719 + v716);
        v723 = v716 + v850;
        v718 ^= v716 & v695;
        v716 += 524296;
        v705 ^= v721;
        v704 ^= v722;
        v706 ^= v712 & v723;
        if ( v717 == (signed int *)"triple-DES inner-CBC" )
          break;
        v695 = *v717;
        v712 = v717[1];
        v696 = v717[2];
        v694 = v717[3];
      }
      v724 = 234941184;
      v725 = -2097117952;
      v726 = 2063609344;
      v727 = ((16 * v706 & 15360 * ((v936 + 16777472) & 0x40004) ^ v706) >> 4) & 0xF000F00 | ((16 * v718 & 15360 * ((v909 + 16777472) & 0x40004) ^ v718) >> 12) & 0xF000F | (v704 ^ 16 * v704 & 15360 * ((v990 + 16777472) & 0x40004)) & 0xF000F000;
      v728 = v727 | ((v705 ^ 16 * v705 & 15360 * ((v963 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v729 = (v728 ^ ((v727 | ((v705 ^ 16 * v705 & 15360 * ((v963 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v730 = (16 * v729 ^ v729 ^ v728 ^ ((16 * v729 ^ v729 ^ v728) >> 8)) & 0x4E009E ^ 16 * v729 ^ v729 ^ v728 ^ (((16 * v729 ^ v729 ^ v728 ^ ((16 * v729 ^ v729 ^ v728) >> 8)) & 0x4E009E) << 8);
      v731 = ((unsigned __int16)((v730 ^ HIWORD(v730)) & 0xD9D3) << 16) ^ ((unsigned __int16)v730 ^ HIWORD(v730)) & 0xD9D3 ^ v730;
      v732 = 16 * ((v731 ^ (v731 >> 4)) & 0x5040004) ^ (v731 ^ (v731 >> 4)) & 0x5040004 ^ v731;
      v733 = 2 * ((v732 ^ (v732 >> 1)) & 0x4045015) ^ (v732 ^ (v732 >> 1)) & 0x4045015 ^ v867 ^ v732;
      v734 = 0;
      v868 = v733;
      v735 = 0;
      v736 = 0;
      v737 = v733 ^ *(_DWORD *)(v852 - 384);
      v738 = *(_DWORD *)(v852 - 320) ^ __ROL4__(v733, 4);
      v739 = v738;
      v740 = (v738 >> 8) & 0xFC00FC | 0xFF00FF00;
      v741 = v739 & 0xFC00FC;
      v742 = -167733504;
      v937 = v740;
      v741 |= 0xFF00FF00;
      v743 = v741;
      v744 = v737 & 0xFC00FC | 0xFF00FF00;
      v745 = v740 - v741;
      v910 = v741;
      v964 = v737 & 0xFC00FC | 0xFF00FF00;
      v991 = (v737 >> 8) & 0xFC00FC | 0xFF00FF00;
      v746 = v741;
      v747 = (signed int *)&unk_EF160;
      v748 = 0;
      v749 = v991 - v743;
      v750 = v744 - v743;
      while ( 1 )
      {
        v747 += 4;
        v751 = v724 & (v749 + v746);
        v748 ^= v746 & v725;
        v752 = v746 + v745;
        v735 ^= v726 & (v750 + v746);
        v746 += 524296;
        v734 ^= v751;
        v736 ^= v742 & v752;
        if ( v747 == (signed int *)"triple-DES inner-CBC" )
          break;
        v725 = *v747;
        v742 = v747[1];
        v726 = v747[2];
        v724 = v747[3];
      }
      v753 = 234941184;
      v754 = -2097117952;
      v755 = 2063609344;
      v756 = ((16 * v736 & 15360 * ((v937 + 16777472) & 0x40004) ^ v736) >> 4) & 0xF000F00 | ((16 * v748 & 15360 * ((v910 + 16777472) & 0x40004) ^ v748) >> 12) & 0xF000F | (v734 ^ 16 * v734 & 15360 * ((v991 + 16777472) & 0x40004)) & 0xF000F000;
      v757 = v756 | ((v735 ^ 16 * v735 & 15360 * ((v964 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v758 = (v757 ^ ((v756 | ((v735 ^ 16 * v735 & 15360 * ((v964 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v759 = (16 * v758 ^ v758 ^ v757 ^ ((16 * v758 ^ v758 ^ v757) >> 8)) & 0x4E009E ^ 16 * v758 ^ v758 ^ v757 ^ (((16 * v758 ^ v758 ^ v757 ^ ((16 * v758 ^ v758 ^ v757) >> 8)) & 0x4E009E) << 8);
      v760 = ((unsigned __int16)((v759 ^ HIWORD(v759)) & 0xD9D3) << 16) ^ ((unsigned __int16)v759 ^ HIWORD(v759)) & 0xD9D3 ^ v759;
      v761 = 16 * ((v760 ^ (v760 >> 4)) & 0x5040004) ^ (v760 ^ (v760 >> 4)) & 0x5040004 ^ v760;
      v762 = 2 * ((v761 ^ (v761 >> 1)) & 0x4045015) ^ (v761 ^ (v761 >> 1)) & 0x4045015 ^ v882 ^ v761;
      v763 = 0;
      v883 = v762;
      v764 = 0;
      v765 = 0;
      v766 = v762 ^ *(_DWORD *)(v852 - 388);
      v767 = *(_DWORD *)(v852 - 324) ^ __ROL4__(v762, 4);
      v768 = v767;
      v769 = (v767 >> 8) & 0xFC00FC | 0xFF00FF00;
      v770 = v768 & 0xFC00FC;
      v771 = -167733504;
      v938 = v769;
      v770 |= 0xFF00FF00;
      v772 = v770;
      v773 = v766 & 0xFC00FC | 0xFF00FF00;
      v774 = v769 - v770;
      v911 = v770;
      v965 = v766 & 0xFC00FC | 0xFF00FF00;
      v992 = (v766 >> 8) & 0xFC00FC | 0xFF00FF00;
      v775 = v770;
      v776 = (signed int *)&unk_EF160;
      v777 = 0;
      v778 = v992 - v772;
      v779 = v773 - v772;
      v851 = v774;
      while ( 1 )
      {
        v776 += 4;
        v780 = v755 & (v779 + v775);
        v781 = v753 & (v778 + v775);
        v782 = v775 + v851;
        v777 ^= v775 & v754;
        v775 += 524296;
        v764 ^= v780;
        v763 ^= v781;
        v765 ^= v771 & v782;
        if ( v776 == (signed int *)"triple-DES inner-CBC" )
          break;
        v754 = *v776;
        v771 = v776[1];
        v755 = v776[2];
        v753 = v776[3];
      }
      v783 = 234941184;
      v784 = -2097117952;
      v785 = 2063609344;
      v786 = ((16 * v765 & 15360 * ((v938 + 16777472) & 0x40004) ^ v765) >> 4) & 0xF000F00 | ((16 * v777 & 15360 * ((v911 + 16777472) & 0x40004) ^ v777) >> 12) & 0xF000F | (v763 ^ 16 * v763 & 15360 * ((v992 + 16777472) & 0x40004)) & 0xF000F000;
      v787 = v786 | ((v764 ^ 16 * v764 & 15360 * ((v965 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v788 = (v787 ^ ((v786 | ((v764 ^ 16 * v764 & 15360 * ((v965 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v789 = (16 * v788 ^ v788 ^ v787 ^ ((16 * v788 ^ v788 ^ v787) >> 8)) & 0x4E009E ^ 16 * v788 ^ v788 ^ v787 ^ (((16 * v788 ^ v788 ^ v787 ^ ((16 * v788 ^ v788 ^ v787) >> 8)) & 0x4E009E) << 8);
      v790 = ((unsigned __int16)((v789 ^ HIWORD(v789)) & 0xD9D3) << 16) ^ ((unsigned __int16)v789 ^ HIWORD(v789)) & 0xD9D3 ^ v789;
      v791 = 16 * ((v790 ^ (v790 >> 4)) & 0x5040004) ^ (v790 ^ (v790 >> 4)) & 0x5040004 ^ v790;
      v792 = 2 * ((v791 ^ (v791 >> 1)) & 0x4045015) ^ (v791 ^ (v791 >> 1)) & 0x4045015 ^ v868 ^ v791;
      v793 = 0;
      v869 = v792;
      v794 = 0;
      v795 = 0;
      v796 = v792 ^ *(_DWORD *)(v852 - 392);
      v797 = *(_DWORD *)(v852 - 328) ^ __ROL4__(v792, 4);
      v798 = v797;
      v799 = (v797 >> 8) & 0xFC00FC | 0xFF00FF00;
      v800 = v798 & 0xFC00FC;
      v801 = -167733504;
      v939 = v799;
      v800 |= 0xFF00FF00;
      v802 = v800;
      v803 = v796 & 0xFC00FC | 0xFF00FF00;
      v804 = v799 - v800;
      v912 = v800;
      v966 = v796 & 0xFC00FC | 0xFF00FF00;
      v993 = (v796 >> 8) & 0xFC00FC | 0xFF00FF00;
      v805 = v800;
      v806 = (signed int *)&unk_EF160;
      v807 = 0;
      v808 = v993 - v802;
      v809 = v803 - v802;
      while ( 1 )
      {
        v806 += 4;
        v810 = v783 & (v808 + v805);
        v807 ^= v805 & v784;
        v811 = v805 + v804;
        v794 ^= v785 & (v809 + v805);
        v805 += 524296;
        v793 ^= v810;
        v795 ^= v801 & v811;
        if ( v806 == (signed int *)"triple-DES inner-CBC" )
          break;
        v784 = *v806;
        v801 = v806[1];
        v785 = v806[2];
        v783 = v806[3];
      }
      v812 = ((16 * v795 & 15360 * ((v939 + 16777472) & 0x40004) ^ v795) >> 4) & 0xF000F00 | ((16 * v807 & 15360 * ((v912 + 16777472) & 0x40004) ^ v807) >> 12) & 0xF000F | (v793 ^ 16 * v793 & 15360 * ((v993 + 16777472) & 0x40004)) & 0xF000F000;
      v813 = v812 | ((v794 ^ 16 * v794 & 15360 * ((v966 + 16777472) & 0x40004)) >> 8) & 0xF000F0;
      v814 = (v813 ^ ((v812 | ((v794 ^ 16 * v794 & 15360 * ((v966 + 16777472) & 0x40004)) >> 8) & 0xF000F0) >> 4)) & 0x7030702;
      v815 = (16 * v814 ^ v814 ^ v813 ^ ((16 * v814 ^ v814 ^ v813) >> 8)) & 0x4E009E ^ 16 * v814 ^ v814 ^ v813 ^ (((16 * v814 ^ v814 ^ v813 ^ ((16 * v814 ^ v814 ^ v813) >> 8)) & 0x4E009E) << 8);
      v816 = ((unsigned __int16)((v815 ^ HIWORD(v815)) & 0xD9D3) << 16) ^ ((unsigned __int16)v815 ^ HIWORD(v815)) & 0xD9D3 ^ v815;
      v817 = 16 * ((v816 ^ (v816 >> 4)) & 0x5040004) ^ (v816 ^ (v816 >> 4)) & 0x5040004 ^ v816;
      v818 = __ROL4__(2 * ((v817 ^ (v817 >> 1)) & 0x4045015) ^ (v817 ^ (v817 >> 1)) & 0x4045015 ^ v883 ^ v817, 1);
      v819 = (__ROL4__(v869, 1) ^ (v818 >> 1)) & 0x55555555;
      v820 = v819 ^ __ROL4__(v869, 1);
      v821 = 2 * v819 ^ v818;
      v822 = (v821 ^ (((unsigned int)v819 ^ __ROL4__(v869, 1)) >> 8)) & 0xFF00FF;
      v823 = v822;
      v824 = v821 ^ v822;
      v825 = v820 ^ (v823 << 8);
      v826 = (v824 ^ (v825 >> 2)) & 0x33333333;
      v827 = 4 * v826;
      v828 = v824 ^ v826;
      v829 = v825 ^ v827;
      v830 = (unsigned __int16)(v829 ^ HIWORD(v828));
      v831 = v830 ^ v829;
      v832 = v828 ^ (v830 << 16);
      v833 = (v831 ^ ((v828 ^ (unsigned int)(v830 << 16)) >> 4)) & 0xF0F0F0F;
      v834 = 16 * v833 ^ *(_DWORD *)(v852 - 8) ^ v832;
      v835 = *(_DWORD *)(v852 - 4) ^ v831 ^ v833;
      *(_BYTE *)(v853 + 7) = v835;
      *(_BYTE *)(v853 + 6) = BYTE1(v835);
      *(_BYTE *)(v853 + 3) = v834;
      *(_BYTE *)(v853 + 1) = BYTE2(v834);
      *(_BYTE *)(v853 + 4) = HIBYTE(v835);
      *(_BYTE *)(v853 + 2) = BYTE1(v834);
      v836 = v853 + 8 == v994;
      *(_BYTE *)v853 = HIBYTE(v834);
      *(_BYTE *)(v853 + 5) = BYTE2(v835);
      *(_DWORD *)(v852 - 8) = v884;
      v853 += 8LL;
      *(_DWORD *)(v852 - 4) = v885;
    }
    while ( !v836 );
  }
}

void __fastcall sub_6F090(__int64 a1, __int64 a2, int a3)
{
  signed int v3; // er9
  signed int v4; // edi
  signed int v5; // er11
  unsigned __int32 v6; // esi
  unsigned __int32 v7; // eax
  unsigned __int32 v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // ecx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // esi
  unsigned int v19; // ecx
  unsigned int v20; // edx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  unsigned int v24; // edx
  unsigned int v25; // eax
  int v26; // er12
  int v27; // ebp
  unsigned int v28; // er13
  unsigned int v29; // ecx
  unsigned int v30; // eax
  int v31; // ebx
  signed int v32; // ecx
  int v33; // esi
  unsigned int v34; // er14
  int v35; // er8
  int v36; // edx
  signed int *v37; // rax
  int v38; // ebx
  int v39; // er15
  int v40; // er14
  int v41; // er8
  int v42; // esi
  int v43; // er10
  __int64 v44; // r14
  unsigned int v45; // eax
  unsigned int v46; // eax
  int v47; // eax
  unsigned int v48; // eax
  unsigned int v49; // eax
  int v50; // ebx
  int v51; // er12
  int v52; // ebp
  int v53; // ebx
  int v54; // ebp
  int v55; // ebx
  int v56; // ebp
  int v57; // ebx
  int v58; // edi
  int v59; // ebp
  int v60; // ebx
  signed int v61; // er9
  signed int v62; // edi
  signed int v63; // er11
  unsigned int v64; // edx
  unsigned int v65; // eax
  unsigned int v66; // ecx
  unsigned int v67; // eax
  int v68; // ebx
  signed int v69; // ecx
  unsigned int v70; // er8
  int v71; // esi
  unsigned int v72; // eax
  unsigned int v73; // er15
  int v74; // edx
  int v75; // ebx
  unsigned int v76; // er13
  signed int *v77; // rax
  int v78; // er15
  int v79; // er14
  int v80; // er8
  int v81; // esi
  int v82; // er10
  signed int v83; // er9
  signed int v84; // er11
  signed int v85; // edi
  unsigned int v86; // eax
  unsigned int v87; // eax
  int v88; // eax
  unsigned int v89; // eax
  unsigned int v90; // eax
  int v91; // eax
  int v92; // er12
  int v93; // ebp
  unsigned int v94; // er13
  unsigned int v95; // edx
  unsigned int v96; // eax
  unsigned int v97; // ecx
  unsigned int v98; // eax
  int v99; // ebx
  signed int v100; // ecx
  int v101; // esi
  unsigned int v102; // er14
  int v103; // er8
  int v104; // edx
  signed int *v105; // rax
  int v106; // ebx
  int v107; // er15
  int v108; // er14
  int v109; // er8
  int v110; // esi
  int v111; // er10
  signed int v112; // er9
  signed int v113; // er11
  signed int v114; // edi
  unsigned int v115; // eax
  unsigned int v116; // eax
  int v117; // eax
  unsigned int v118; // eax
  unsigned int v119; // eax
  int v120; // eax
  int v121; // er12
  int v122; // ebp
  unsigned int v123; // er13
  unsigned int v124; // edx
  unsigned int v125; // eax
  unsigned int v126; // ecx
  unsigned int v127; // eax
  int v128; // ebx
  signed int v129; // ecx
  int v130; // esi
  unsigned int v131; // er14
  int v132; // er8
  int v133; // edx
  signed int *v134; // rax
  int v135; // ebx
  int v136; // er15
  int v137; // er14
  int v138; // er8
  int v139; // esi
  int v140; // er10
  signed int v141; // er9
  signed int v142; // er11
  signed int v143; // edi
  unsigned int v144; // eax
  unsigned int v145; // eax
  int v146; // eax
  unsigned int v147; // eax
  unsigned int v148; // eax
  int v149; // eax
  int v150; // er12
  int v151; // ebp
  unsigned int v152; // er13
  unsigned int v153; // edx
  unsigned int v154; // eax
  unsigned int v155; // ecx
  unsigned int v156; // eax
  int v157; // ebx
  signed int v158; // ecx
  int v159; // esi
  unsigned int v160; // er14
  int v161; // er8
  int v162; // edx
  signed int *v163; // rax
  int v164; // ebx
  int v165; // er15
  int v166; // er14
  int v167; // esi
  int v168; // er10
  signed int v169; // er9
  signed int v170; // er11
  signed int v171; // edi
  unsigned int v172; // eax
  unsigned int v173; // eax
  int v174; // eax
  unsigned int v175; // eax
  unsigned int v176; // eax
  int v177; // eax
  int v178; // er12
  int v179; // ebp
  unsigned int v180; // er13
  unsigned int v181; // edx
  unsigned int v182; // eax
  unsigned int v183; // ecx
  unsigned int v184; // eax
  int v185; // ebx
  signed int v186; // ecx
  int v187; // esi
  unsigned int v188; // er14
  int v189; // er8
  int v190; // edx
  signed int *v191; // rax
  int v192; // ebx
  int v193; // er15
  int v194; // er14
  int v195; // er8
  int v196; // esi
  int v197; // er10
  signed int v198; // er9
  signed int v199; // er11
  signed int v200; // edi
  unsigned int v201; // eax
  unsigned int v202; // eax
  int v203; // eax
  unsigned int v204; // eax
  unsigned int v205; // eax
  int v206; // eax
  int v207; // er12
  int v208; // ebp
  unsigned int v209; // er13
  unsigned int v210; // edx
  unsigned int v211; // eax
  unsigned int v212; // ecx
  unsigned int v213; // eax
  int v214; // ebx
  signed int v215; // ecx
  int v216; // esi
  unsigned int v217; // er14
  int v218; // er8
  int v219; // edx
  signed int *v220; // rax
  int v221; // ebx
  int v222; // er15
  int v223; // er14
  int v224; // esi
  int v225; // er10
  signed int v226; // er9
  signed int v227; // er11
  signed int v228; // edi
  unsigned int v229; // eax
  unsigned int v230; // eax
  int v231; // eax
  unsigned int v232; // eax
  unsigned int v233; // eax
  int v234; // eax
  int v235; // er12
  int v236; // ebp
  unsigned int v237; // er13
  unsigned int v238; // edx
  unsigned int v239; // eax
  unsigned int v240; // ecx
  unsigned int v241; // eax
  int v242; // ebx
  signed int v243; // ecx
  int v244; // esi
  unsigned int v245; // er14
  int v246; // er8
  int v247; // edx
  signed int *v248; // rax
  int v249; // ebx
  int v250; // er15
  int v251; // er14
  int v252; // er8
  int v253; // esi
  int v254; // er10
  unsigned int v255; // eax
  unsigned int v256; // eax
  int v257; // eax
  unsigned int v258; // eax
  unsigned int v259; // eax
  unsigned int v260; // ebx
  int v261; // er12
  unsigned int v262; // ebp
  unsigned int v263; // er13
  __int64 v264; // rax
  int v265; // ecx
  int v266; // edx
  signed int v267; // er9
  signed int v268; // edi
  signed int v269; // er11
  unsigned int v270; // edx
  int v271; // ecx
  int v272; // ebx
  signed int v273; // ecx
  int v274; // esi
  unsigned int v275; // er14
  int v276; // er8
  int v277; // edx
  signed int *v278; // rax
  int v279; // ebx
  int v280; // er15
  int v281; // er14
  int v282; // esi
  int v283; // er10
  signed int v284; // er9
  signed int v285; // er11
  signed int v286; // edi
  unsigned int v287; // eax
  unsigned int v288; // eax
  int v289; // eax
  unsigned int v290; // eax
  unsigned int v291; // eax
  int v292; // eax
  int v293; // er12
  int v294; // ebp
  unsigned int v295; // er13
  unsigned int v296; // edx
  unsigned int v297; // eax
  unsigned int v298; // ecx
  unsigned int v299; // eax
  int v300; // ebx
  signed int v301; // ecx
  int v302; // esi
  unsigned int v303; // er14
  int v304; // er8
  int v305; // edx
  signed int *v306; // rax
  int v307; // ebx
  int v308; // er15
  int v309; // er14
  int v310; // er8
  int v311; // esi
  int v312; // er10
  signed int v313; // er9
  signed int v314; // er11
  signed int v315; // edi
  unsigned int v316; // eax
  unsigned int v317; // eax
  int v318; // eax
  unsigned int v319; // eax
  unsigned int v320; // eax
  int v321; // eax
  int v322; // er12
  int v323; // ebp
  unsigned int v324; // er13
  unsigned int v325; // edx
  unsigned int v326; // eax
  unsigned int v327; // ecx
  unsigned int v328; // eax
  int v329; // ebx
  signed int v330; // ecx
  int v331; // esi
  unsigned int v332; // er14
  int v333; // er8
  int v334; // edx
  signed int *v335; // rax
  int v336; // ebx
  int v337; // er15
  int v338; // er14
  int v339; // esi
  int v340; // er10
  signed int v341; // er9
  signed int v342; // er11
  signed int v343; // edi
  unsigned int v344; // eax
  unsigned int v345; // eax
  int v346; // eax
  unsigned int v347; // eax
  unsigned int v348; // eax
  int v349; // eax
  int v350; // er12
  int v351; // ebp
  unsigned int v352; // er13
  unsigned int v353; // edx
  unsigned int v354; // eax
  unsigned int v355; // ecx
  unsigned int v356; // eax
  int v357; // ebx
  signed int v358; // ecx
  int v359; // esi
  unsigned int v360; // er14
  int v361; // er8
  int v362; // edx
  signed int *v363; // rax
  int v364; // ebx
  int v365; // er15
  int v366; // er14
  int v367; // er8
  int v368; // esi
  int v369; // er10
  signed int v370; // er9
  signed int v371; // er11
  signed int v372; // edi
  unsigned int v373; // eax
  unsigned int v374; // eax
  int v375; // eax
  unsigned int v376; // eax
  unsigned int v377; // eax
  int v378; // eax
  int v379; // er12
  int v380; // ebp
  unsigned int v381; // er13
  unsigned int v382; // edx
  unsigned int v383; // eax
  unsigned int v384; // ecx
  unsigned int v385; // eax
  int v386; // ebx
  signed int v387; // ecx
  int v388; // esi
  unsigned int v389; // er14
  int v390; // er8
  int v391; // edx
  signed int *v392; // rax
  int v393; // ebx
  int v394; // er15
  int v395; // er14
  int v396; // esi
  int v397; // er10
  signed int v398; // er9
  signed int v399; // er11
  signed int v400; // edi
  unsigned int v401; // eax
  unsigned int v402; // eax
  int v403; // eax
  unsigned int v404; // eax
  unsigned int v405; // eax
  int v406; // eax
  int v407; // er12
  int v408; // ebp
  unsigned int v409; // er13
  unsigned int v410; // edx
  unsigned int v411; // eax
  unsigned int v412; // ecx
  unsigned int v413; // eax
  int v414; // ebx
  signed int v415; // ecx
  int v416; // esi
  unsigned int v417; // er14
  int v418; // er8
  int v419; // edx
  signed int *v420; // rax
  int v421; // ebx
  int v422; // er15
  int v423; // er14
  int v424; // er8
  int v425; // esi
  int v426; // er10
  signed int v427; // er9
  signed int v428; // er11
  signed int v429; // edi
  unsigned int v430; // eax
  unsigned int v431; // eax
  int v432; // eax
  unsigned int v433; // eax
  unsigned int v434; // eax
  int v435; // eax
  int v436; // er12
  int v437; // ebp
  unsigned int v438; // er13
  unsigned int v439; // edx
  unsigned int v440; // eax
  unsigned int v441; // ecx
  unsigned int v442; // eax
  int v443; // ebx
  signed int v444; // ecx
  int v445; // esi
  unsigned int v446; // er14
  int v447; // er8
  int v448; // edx
  signed int *v449; // rax
  int v450; // ebx
  int v451; // er15
  int v452; // er14
  int v453; // esi
  int v454; // er10
  signed int v455; // er9
  signed int v456; // er11
  signed int v457; // edi
  unsigned int v458; // eax
  unsigned int v459; // eax
  int v460; // eax
  unsigned int v461; // eax
  unsigned int v462; // eax
  int v463; // eax
  int v464; // er12
  int v465; // ebp
  unsigned int v466; // er13
  unsigned int v467; // edx
  unsigned int v468; // eax
  unsigned int v469; // ecx
  unsigned int v470; // eax
  int v471; // ebx
  signed int v472; // ecx
  int v473; // esi
  unsigned int v474; // er14
  int v475; // er8
  int v476; // edx
  signed int *v477; // rax
  int v478; // ebx
  int v479; // er15
  int v480; // er14
  int v481; // er8
  int v482; // esi
  int v483; // er10
  signed int v484; // er9
  signed int v485; // er11
  signed int v486; // edi
  unsigned int v487; // eax
  unsigned int v488; // eax
  int v489; // eax
  unsigned int v490; // eax
  unsigned int v491; // eax
  int v492; // eax
  int v493; // er12
  int v494; // ebp
  unsigned int v495; // er13
  unsigned int v496; // edx
  unsigned int v497; // eax
  unsigned int v498; // ecx
  unsigned int v499; // eax
  int v500; // ebx
  signed int v501; // ecx
  int v502; // esi
  unsigned int v503; // er14
  int v504; // er8
  int v505; // edx
  signed int *v506; // rax
  int v507; // ebx
  int v508; // er15
  int v509; // er14
  int v510; // esi
  int v511; // er10
  signed int v512; // er9
  signed int v513; // er11
  signed int v514; // edi
  unsigned int v515; // eax
  unsigned int v516; // eax
  int v517; // eax
  unsigned int v518; // eax
  unsigned int v519; // eax
  int v520; // eax
  int v521; // er12
  int v522; // ebp
  unsigned int v523; // er13
  unsigned int v524; // edx
  unsigned int v525; // eax
  unsigned int v526; // ecx
  unsigned int v527; // eax
  int v528; // ebx
  signed int v529; // ecx
  int v530; // esi
  unsigned int v531; // er14
  int v532; // er8
  int v533; // edx
  signed int *v534; // rax
  int v535; // ebx
  int v536; // er15
  int v537; // er14
  int v538; // er8
  int v539; // esi
  int v540; // er10
  signed int v541; // er9
  signed int v542; // er11
  signed int v543; // edi
  unsigned int v544; // eax
  unsigned int v545; // eax
  int v546; // eax
  unsigned int v547; // eax
  unsigned int v548; // eax
  int v549; // eax
  int v550; // er12
  int v551; // ebp
  unsigned int v552; // er13
  unsigned int v553; // edx
  unsigned int v554; // eax
  unsigned int v555; // ecx
  unsigned int v556; // eax
  int v557; // ebx
  signed int v558; // ecx
  int v559; // esi
  unsigned int v560; // er14
  int v561; // er8
  int v562; // edx
  signed int *v563; // rax
  int v564; // ebx
  int v565; // er15
  int v566; // er14
  int v567; // esi
  int v568; // er10
  signed int v569; // er9
  signed int v570; // er11
  signed int v571; // edi
  unsigned int v572; // eax
  unsigned int v573; // eax
  int v574; // eax
  unsigned int v575; // eax
  unsigned int v576; // eax
  int v577; // eax
  int v578; // er12
  int v579; // ebp
  unsigned int v580; // er13
  unsigned int v581; // edx
  unsigned int v582; // eax
  unsigned int v583; // ecx
  unsigned int v584; // eax
  int v585; // ebx
  signed int v586; // ecx
  int v587; // esi
  unsigned int v588; // er14
  int v589; // er8
  int v590; // edx
  signed int *v591; // rax
  int v592; // ebx
  int v593; // er15
  int v594; // er14
  int v595; // er8
  int v596; // esi
  int v597; // er10
  signed int v598; // er9
  signed int v599; // er11
  signed int v600; // edi
  unsigned int v601; // eax
  unsigned int v602; // eax
  int v603; // eax
  unsigned int v604; // eax
  unsigned int v605; // eax
  int v606; // eax
  int v607; // er12
  int v608; // ebp
  unsigned int v609; // er13
  unsigned int v610; // edx
  unsigned int v611; // eax
  unsigned int v612; // ecx
  unsigned int v613; // eax
  int v614; // ebx
  signed int v615; // ecx
  int v616; // esi
  unsigned int v617; // er14
  int v618; // er8
  int v619; // edx
  signed int *v620; // rax
  int v621; // ebx
  int v622; // er15
  int v623; // er14
  int v624; // esi
  int v625; // er10
  signed int v626; // er9
  signed int v627; // er11
  signed int v628; // edi
  unsigned int v629; // eax
  unsigned int v630; // eax
  int v631; // eax
  unsigned int v632; // eax
  unsigned int v633; // eax
  int v634; // eax
  int v635; // er12
  int v636; // ebp
  unsigned int v637; // er13
  unsigned int v638; // edx
  unsigned int v639; // eax
  unsigned int v640; // ecx
  unsigned int v641; // eax
  int v642; // ebx
  signed int v643; // ecx
  int v644; // esi
  unsigned int v645; // er14
  int v646; // er8
  int v647; // edx
  signed int *v648; // rax
  int v649; // ebx
  int v650; // er15
  int v651; // er14
  int v652; // er8
  int v653; // esi
  int v654; // er10
  signed int v655; // er9
  signed int v656; // er11
  signed int v657; // edi
  unsigned int v658; // eax
  unsigned int v659; // eax
  int v660; // eax
  unsigned int v661; // eax
  unsigned int v662; // eax
  int v663; // eax
  int v664; // er12
  int v665; // ebp
  unsigned int v666; // er13
  unsigned int v667; // edx
  unsigned int v668; // eax
  unsigned int v669; // ecx
  unsigned int v670; // eax
  int v671; // ebx
  signed int v672; // ecx
  int v673; // esi
  unsigned int v674; // er14
  int v675; // er8
  int v676; // edx
  signed int *v677; // rax
  int v678; // ebx
  int v679; // er15
  int v680; // er14
  int v681; // esi
  int v682; // er10
  signed int v683; // er9
  signed int v684; // er11
  signed int v685; // edi
  unsigned int v686; // eax
  unsigned int v687; // eax
  int v688; // eax
  unsigned int v689; // eax
  unsigned int v690; // eax
  int v691; // eax
  int v692; // er12
  int v693; // ebp
  unsigned int v694; // er13
  unsigned int v695; // edx
  unsigned int v696; // eax
  unsigned int v697; // ecx
  unsigned int v698; // eax
  int v699; // ebx
  signed int v700; // ecx
  int v701; // esi
  unsigned int v702; // er14
  int v703; // er8
  int v704; // edx
  signed int *v705; // rax
  int v706; // ebx
  int v707; // er15
  int v708; // er14
  int v709; // er8
  int v710; // esi
  int v711; // er10
  unsigned int v712; // eax
  unsigned int v713; // eax
  int v714; // eax
  unsigned int v715; // eax
  unsigned int v716; // eax
  unsigned int v717; // edx
  int v718; // esi
  unsigned int v719; // eax
  int v720; // edx
  int v721; // ecx
  int v722; // edx
  int v723; // esi
  unsigned int v724; // ecx
  int v725; // edx
  int v726; // eax
  int v727; // ecx
  int v728; // eax
  int v729; // esi
  unsigned int v730; // ecx
  int v731; // eax
  int v732; // edx
  bool v733; // zf
  int v734; // [rsp+4h] [rbp-6Ch]
  int v735; // [rsp+4h] [rbp-6Ch]
  int v736; // [rsp+4h] [rbp-6Ch]
  int v737; // [rsp+4h] [rbp-6Ch]
  int v738; // [rsp+4h] [rbp-6Ch]
  int v739; // [rsp+4h] [rbp-6Ch]
  int v740; // [rsp+4h] [rbp-6Ch]
  int v741; // [rsp+4h] [rbp-6Ch]
  int v742; // [rsp+4h] [rbp-6Ch]
  int v743; // [rsp+4h] [rbp-6Ch]
  int v744; // [rsp+4h] [rbp-6Ch]
  int v745; // [rsp+4h] [rbp-6Ch]
  int v746; // [rsp+4h] [rbp-6Ch]
  int v747; // [rsp+4h] [rbp-6Ch]
  __int64 v748; // [rsp+8h] [rbp-68h]
  __int64 v749; // [rsp+10h] [rbp-60h]
  int v750; // [rsp+18h] [rbp-58h]
  int v751; // [rsp+18h] [rbp-58h]
  int v752; // [rsp+18h] [rbp-58h]
  int v753; // [rsp+18h] [rbp-58h]
  int v754; // [rsp+18h] [rbp-58h]
  int v755; // [rsp+18h] [rbp-58h]
  int v756; // [rsp+18h] [rbp-58h]
  int v757; // [rsp+18h] [rbp-58h]
  int v758; // [rsp+18h] [rbp-58h]
  int v759; // [rsp+18h] [rbp-58h]
  int v760; // [rsp+18h] [rbp-58h]
  int v761; // [rsp+18h] [rbp-58h]
  int v762; // [rsp+18h] [rbp-58h]
  int v763; // [rsp+1Ch] [rbp-54h]
  int v764; // [rsp+1Ch] [rbp-54h]
  int v765; // [rsp+1Ch] [rbp-54h]
  int v766; // [rsp+1Ch] [rbp-54h]
  unsigned int v767; // [rsp+1Ch] [rbp-54h]
  int v768; // [rsp+1Ch] [rbp-54h]
  int v769; // [rsp+1Ch] [rbp-54h]
  int v770; // [rsp+1Ch] [rbp-54h]
  int v771; // [rsp+1Ch] [rbp-54h]
  int v772; // [rsp+1Ch] [rbp-54h]
  int v773; // [rsp+1Ch] [rbp-54h]
  int v774; // [rsp+1Ch] [rbp-54h]
  int v775; // [rsp+1Ch] [rbp-54h]
  int v776; // [rsp+1Ch] [rbp-54h]
  unsigned int v777; // [rsp+20h] [rbp-50h]
  int v778; // [rsp+20h] [rbp-50h]
  int v779; // [rsp+20h] [rbp-50h]
  int v780; // [rsp+20h] [rbp-50h]
  int v781; // [rsp+20h] [rbp-50h]
  int v782; // [rsp+20h] [rbp-50h]
  int v783; // [rsp+20h] [rbp-50h]
  int v784; // [rsp+20h] [rbp-50h]
  int v785; // [rsp+20h] [rbp-50h]
  int v786; // [rsp+20h] [rbp-50h]
  int v787; // [rsp+20h] [rbp-50h]
  int v788; // [rsp+20h] [rbp-50h]
  int v789; // [rsp+20h] [rbp-50h]
  int v790; // [rsp+20h] [rbp-50h]
  int v791; // [rsp+20h] [rbp-50h]
  int v792; // [rsp+20h] [rbp-50h]
  int v793; // [rsp+20h] [rbp-50h]
  int v794; // [rsp+20h] [rbp-50h]
  int v795; // [rsp+20h] [rbp-50h]
  int v796; // [rsp+20h] [rbp-50h]
  int v797; // [rsp+20h] [rbp-50h]
  int v798; // [rsp+20h] [rbp-50h]
  int v799; // [rsp+20h] [rbp-50h]
  int v800; // [rsp+20h] [rbp-50h]
  unsigned int v801; // [rsp+24h] [rbp-4Ch]
  unsigned int v802; // [rsp+24h] [rbp-4Ch]
  unsigned int v803; // [rsp+24h] [rbp-4Ch]
  unsigned int v804; // [rsp+24h] [rbp-4Ch]
  unsigned int v805; // [rsp+24h] [rbp-4Ch]
  unsigned int v806; // [rsp+24h] [rbp-4Ch]
  unsigned int v807; // [rsp+24h] [rbp-4Ch]
  unsigned int v808; // [rsp+24h] [rbp-4Ch]
  int v809; // [rsp+24h] [rbp-4Ch]
  unsigned int v810; // [rsp+24h] [rbp-4Ch]
  unsigned int v811; // [rsp+24h] [rbp-4Ch]
  unsigned int v812; // [rsp+24h] [rbp-4Ch]
  unsigned int v813; // [rsp+24h] [rbp-4Ch]
  unsigned int v814; // [rsp+24h] [rbp-4Ch]
  unsigned int v815; // [rsp+24h] [rbp-4Ch]
  unsigned int v816; // [rsp+24h] [rbp-4Ch]
  unsigned int v817; // [rsp+24h] [rbp-4Ch]
  unsigned int v818; // [rsp+24h] [rbp-4Ch]
  unsigned int v819; // [rsp+24h] [rbp-4Ch]
  unsigned int v820; // [rsp+24h] [rbp-4Ch]
  unsigned int v821; // [rsp+24h] [rbp-4Ch]
  unsigned int v822; // [rsp+24h] [rbp-4Ch]
  unsigned int v823; // [rsp+24h] [rbp-4Ch]
  unsigned int v824; // [rsp+24h] [rbp-4Ch]
  unsigned int v825; // [rsp+28h] [rbp-48h]
  unsigned int v826; // [rsp+28h] [rbp-48h]
  unsigned int v827; // [rsp+28h] [rbp-48h]
  unsigned int v828; // [rsp+28h] [rbp-48h]
  unsigned int v829; // [rsp+28h] [rbp-48h]
  unsigned int v830; // [rsp+28h] [rbp-48h]
  unsigned int v831; // [rsp+28h] [rbp-48h]
  unsigned int v832; // [rsp+28h] [rbp-48h]
  unsigned int v833; // [rsp+28h] [rbp-48h]
  unsigned int v834; // [rsp+28h] [rbp-48h]
  unsigned int v835; // [rsp+28h] [rbp-48h]
  unsigned int v836; // [rsp+28h] [rbp-48h]
  unsigned int v837; // [rsp+28h] [rbp-48h]
  unsigned int v838; // [rsp+28h] [rbp-48h]
  unsigned int v839; // [rsp+28h] [rbp-48h]
  unsigned int v840; // [rsp+28h] [rbp-48h]
  unsigned int v841; // [rsp+28h] [rbp-48h]
  unsigned int v842; // [rsp+28h] [rbp-48h]
  unsigned int v843; // [rsp+28h] [rbp-48h]
  unsigned int v844; // [rsp+28h] [rbp-48h]
  unsigned int v845; // [rsp+28h] [rbp-48h]
  unsigned int v846; // [rsp+28h] [rbp-48h]
  unsigned int v847; // [rsp+28h] [rbp-48h]
  unsigned int v848; // [rsp+28h] [rbp-48h]
  int v849; // [rsp+2Ch] [rbp-44h]
  unsigned int v850; // [rsp+2Ch] [rbp-44h]
  unsigned int v851; // [rsp+2Ch] [rbp-44h]
  unsigned int v852; // [rsp+2Ch] [rbp-44h]
  unsigned int v853; // [rsp+2Ch] [rbp-44h]
  unsigned int v854; // [rsp+2Ch] [rbp-44h]
  unsigned int v855; // [rsp+2Ch] [rbp-44h]
  unsigned int v856; // [rsp+2Ch] [rbp-44h]
  unsigned int v857; // [rsp+2Ch] [rbp-44h]
  unsigned int v858; // [rsp+2Ch] [rbp-44h]
  unsigned int v859; // [rsp+2Ch] [rbp-44h]
  unsigned int v860; // [rsp+2Ch] [rbp-44h]
  unsigned int v861; // [rsp+2Ch] [rbp-44h]
  unsigned int v862; // [rsp+2Ch] [rbp-44h]
  unsigned int v863; // [rsp+2Ch] [rbp-44h]
  unsigned int v864; // [rsp+2Ch] [rbp-44h]
  unsigned int v865; // [rsp+2Ch] [rbp-44h]
  unsigned int v866; // [rsp+2Ch] [rbp-44h]
  unsigned int v867; // [rsp+2Ch] [rbp-44h]
  unsigned int v868; // [rsp+2Ch] [rbp-44h]
  unsigned int v869; // [rsp+2Ch] [rbp-44h]
  unsigned int v870; // [rsp+2Ch] [rbp-44h]
  unsigned int v871; // [rsp+2Ch] [rbp-44h]
  unsigned int v872; // [rsp+2Ch] [rbp-44h]
  signed __int64 v873; // [rsp+30h] [rbp-40h]
  __int64 v874; // [rsp+38h] [rbp-38h]

  v748 = a1;
  v749 = a2;
  if ( a3 > 0 )
  {
    v874 = a1 - 280;
    v873 = a2 + 8LL * ((unsigned int)(a3 - 1) >> 3) + 8;
    do
    {
      v3 = 234941184;
      v4 = 2063609344;
      v5 = -2097117952;
      v6 = _byteswap_ulong(*(_DWORD *)v749);
      v7 = _byteswap_ulong(*(_DWORD *)(v749 + 4));
      v8 = v7;
      v9 = (v7 ^ (v6 >> 4)) & 0xF0F0F0F;
      v10 = v9;
      v11 = v8 ^ v9;
      v12 = 16 * v10 ^ v6;
      v13 = (unsigned __int16)(v11 ^ HIWORD(v12));
      v14 = v13 ^ v11;
      v15 = v12 ^ (v13 << 16);
      v16 = (v15 ^ (v14 >> 2)) & 0x33333333;
      v17 = v16 ^ v15;
      v18 = v14 ^ 4 * v16;
      v19 = (v17 ^ ((v14 ^ 4 * v16) >> 8)) & 0xFF00FF;
      v20 = v19 ^ v17;
      v21 = v18 ^ (v19 << 8);
      v22 = (v21 ^ (v20 >> 1)) & 0x55555555;
      v23 = *(_DWORD *)(v748 - 20) ^ __ROR4__(v22 ^ v21, 1);
      v750 = v23;
      v849 = *(_DWORD *)(v748 - 24) ^ __ROR4__(2 * v22 ^ v20, 1);
      v24 = v23 ^ *(_DWORD *)(v748 - 408);
      v25 = *(_DWORD *)(v748 - 344) ^ __ROL4__(v23, 4);
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = v25;
      v30 = (v25 >> 8) & 0xFC00FC | 0xFF00FF00;
      v31 = v29 & 0xFC00FC;
      v32 = -167733504;
      v777 = v30;
      v31 |= 0xFF00FF00;
      v33 = v31;
      v34 = v24 & 0xFC00FC | 0xFF00FF00;
      v35 = v30 - v31;
      v763 = v31;
      v801 = v24 & 0xFC00FC | 0xFF00FF00;
      v825 = (v24 >> 8) & 0xFC00FC | 0xFF00FF00;
      v36 = v31;
      v37 = (signed int *)&unk_EF160;
      v38 = 0;
      v39 = v825 - v33;
      v40 = v34 - v33;
      v734 = v35;
      while ( 1 )
      {
        v37 += 4;
        v41 = v4 & (v40 + v36);
        v42 = v3 & (v39 + v36);
        v43 = v36 + v734;
        v28 ^= v36 & v5;
        v36 += 524296;
        v38 ^= v41;
        v26 ^= v42;
        v27 ^= v32 & v43;
        if ( v37 == (signed int *)"triple-DES inner-CBC" )
          break;
        v5 = *v37;
        v32 = v37[1];
        v4 = v37[2];
        v3 = v37[3];
      }
      v44 = v748;
      v45 = ((16 * v38 & 15360 * ((v801 + 16777472) & 0x40004) ^ v38) >> 8) & 0xF000F0 | (16 * v26 & 15360 * ((v825 + 16777472) & 0x40004) ^ v26) & 0xF000F000 | ((16 * v27 & 15360 * ((v777 + 16777472) & 0x40004) ^ v27) >> 4) & 0xF000F00 | ((16 * v28 & 15360 * ((v763 + 16777472) & 0x40004) ^ v28) >> 12) & 0xF000F;
      v46 = 16 * ((v45 ^ (v45 >> 4)) & 0x7030702) ^ (v45 ^ (v45 >> 4)) & 0x7030702 ^ v45;
      v47 = (((v46 ^ (v46 >> 8)) & 0x4E009E) << 8) ^ (v46 ^ (v46 >> 8)) & 0x4E009E ^ v46;
      v48 = ((unsigned __int16)((v47 ^ HIWORD(v47)) & 0xD9D3) << 16) ^ ((unsigned __int16)v47 ^ HIWORD(v47)) & 0xD9D3 ^ v47;
      v49 = 16 * ((v48 ^ (v48 >> 4)) & 0x5040004) ^ (v48 ^ (v48 >> 4)) & 0x5040004 ^ v48;
      v50 = 2 * ((v49 ^ (v49 >> 1)) & 0x4045015) ^ (v49 ^ (v49 >> 1)) & 0x4045015 ^ v49 ^ v849;
      v51 = 0;
      v52 = (unsigned __int64)sub_630F0(v50, *(_DWORD *)(v748 - 404), *(_DWORD *)(v748 - 340)) ^ v750;
      v53 = (unsigned __int64)sub_630F0(v52, *(_DWORD *)(v44 - 400), *(_DWORD *)(v44 - 336)) ^ v50;
      v54 = (unsigned __int64)sub_630F0(v53, *(_DWORD *)(v44 - 396), *(_DWORD *)(v44 - 332)) ^ v52;
      v55 = (unsigned __int64)sub_630F0(v54, *(_DWORD *)(v44 - 392), *(_DWORD *)(v44 - 328)) ^ v53;
      v56 = (unsigned __int64)sub_630F0(v55, *(_DWORD *)(v44 - 388), *(_DWORD *)(v44 - 324)) ^ v54;
      v57 = (unsigned __int64)sub_630F0(v56, *(_DWORD *)(v44 - 384), *(_DWORD *)(v44 - 320)) ^ v55;
      v58 = (unsigned __int64)sub_630F0(v57, *(_DWORD *)(v44 - 380), *(_DWORD *)(v44 - 316)) ^ v56;
      v59 = 0;
      v751 = v58;
      v60 = (unsigned __int64)sub_630F0(v58, *(_DWORD *)(v44 - 376), *(_DWORD *)(v44 - 312)) ^ v57;
      v61 = 234941184;
      v62 = 2063609344;
      v764 = v60;
      v63 = -2097117952;
      v64 = v60 ^ *(_DWORD *)(v748 - 372);
      v65 = *(_DWORD *)(v748 - 308) ^ __ROL4__(v60, 4);
      v66 = v65;
      v67 = (v65 >> 8) & 0xFC00FC | 0xFF00FF00;
      v68 = v66 & 0xFC00FC;
      v69 = -167733504;
      v70 = v67;
      v802 = v67;
      v68 |= 0xFF00FF00;
      v71 = v68;
      v72 = v64 & 0xFC00FC | 0xFF00FF00;
      LODWORD(v44) = v72;
      v778 = v68;
      v73 = (v64 >> 8) & 0xFC00FC | 0xFF00FF00;
      v74 = v68;
      v75 = 0;
      v76 = 0;
      v826 = v72;
      v850 = v73;
      v77 = (signed int *)&unk_EF160;
      v78 = v73 - v71;
      v79 = v44 - v71;
      v735 = v70 - v71;
      while ( 1 )
      {
        v77 += 4;
        v80 = v62 & (v79 + v74);
        v81 = v61 & (v78 + v74);
        v82 = v74 + v735;
        v76 ^= v74 & v63;
        v74 += 524296;
        v75 ^= v80;
        v51 ^= v81;
        v59 ^= v69 & v82;
        if ( v77 == (signed int *)"triple-DES inner-CBC" )
          break;
        v63 = *v77;
        v69 = v77[1];
        v62 = v77[2];
        v61 = v77[3];
      }
      v83 = 234941184;
      v84 = -2097117952;
      v85 = 2063609344;
      v86 = ((16 * v75 & 15360 * ((v826 + 16777472) & 0x40004) ^ v75) >> 8) & 0xF000F0 | (16 * v51 & 15360 * ((v850 + 16777472) & 0x40004) ^ v51) & 0xF000F000 | ((16 * v59 & 15360 * ((v802 + 16777472) & 0x40004) ^ v59) >> 4) & 0xF000F00 | ((16 * v76 & 15360 * ((v778 + 16777472) & 0x40004) ^ v76) >> 12) & 0xF000F;
      v87 = 16 * ((v86 ^ (v86 >> 4)) & 0x7030702) ^ (v86 ^ (v86 >> 4)) & 0x7030702 ^ v86;
      v88 = (((v87 ^ (v87 >> 8)) & 0x4E009E) << 8) ^ (v87 ^ (v87 >> 8)) & 0x4E009E ^ v87;
      v89 = ((unsigned __int16)((v88 ^ HIWORD(v88)) & 0xD9D3) << 16) ^ ((unsigned __int16)v88 ^ HIWORD(v88)) & 0xD9D3 ^ v88;
      v90 = 16 * ((v89 ^ (v89 >> 4)) & 0x5040004) ^ (v89 ^ (v89 >> 4)) & 0x5040004 ^ v89;
      v91 = 2 * ((v90 ^ (v90 >> 1)) & 0x4045015) ^ (v90 ^ (v90 >> 1)) & 0x4045015 ^ v751 ^ v90;
      v92 = 0;
      v752 = v91;
      v93 = 0;
      v94 = 0;
      v95 = v91 ^ *(_DWORD *)(v748 - 368);
      v96 = *(_DWORD *)(v748 - 304) ^ __ROL4__(v91, 4);
      v97 = v96;
      v98 = (v96 >> 8) & 0xFC00FC | 0xFF00FF00;
      v99 = v97 & 0xFC00FC;
      v100 = -167733504;
      v803 = v98;
      v99 |= 0xFF00FF00;
      v101 = v99;
      v102 = v95 & 0xFC00FC | 0xFF00FF00;
      v103 = v98 - v99;
      v779 = v99;
      v827 = v95 & 0xFC00FC | 0xFF00FF00;
      v851 = (v95 >> 8) & 0xFC00FC | 0xFF00FF00;
      v104 = v99;
      v105 = (signed int *)&unk_EF160;
      v106 = 0;
      v107 = v851 - v101;
      v108 = v102 - v101;
      v736 = v103;
      while ( 1 )
      {
        v105 += 4;
        v109 = v85 & (v108 + v104);
        v110 = v83 & (v107 + v104);
        v111 = v104 + v736;
        v94 ^= v104 & v84;
        v104 += 524296;
        v106 ^= v109;
        v92 ^= v110;
        v93 ^= v100 & v111;
        if ( v105 == (signed int *)"triple-DES inner-CBC" )
          break;
        v84 = *v105;
        v100 = v105[1];
        v85 = v105[2];
        v83 = v105[3];
      }
      v112 = 234941184;
      v113 = -2097117952;
      v114 = 2063609344;
      v115 = ((16 * v106 & 15360 * ((v827 + 16777472) & 0x40004) ^ v106) >> 8) & 0xF000F0 | (16 * v92 & 15360 * ((v851 + 16777472) & 0x40004) ^ v92) & 0xF000F000 | ((16 * v93 & 15360 * ((v803 + 16777472) & 0x40004) ^ v93) >> 4) & 0xF000F00 | ((16 * v94 & 15360 * ((v779 + 16777472) & 0x40004) ^ v94) >> 12) & 0xF000F;
      v116 = 16 * ((v115 ^ (v115 >> 4)) & 0x7030702) ^ (v115 ^ (v115 >> 4)) & 0x7030702 ^ v115;
      v117 = (((v116 ^ (v116 >> 8)) & 0x4E009E) << 8) ^ (v116 ^ (v116 >> 8)) & 0x4E009E ^ v116;
      v118 = ((unsigned __int16)((v117 ^ HIWORD(v117)) & 0xD9D3) << 16) ^ ((unsigned __int16)v117 ^ HIWORD(v117)) & 0xD9D3 ^ v117;
      v119 = 16 * ((v118 ^ (v118 >> 4)) & 0x5040004) ^ (v118 ^ (v118 >> 4)) & 0x5040004 ^ v118;
      v120 = 2 * ((v119 ^ (v119 >> 1)) & 0x4045015) ^ (v119 ^ (v119 >> 1)) & 0x4045015 ^ v764 ^ v119;
      v121 = 0;
      v765 = v120;
      v122 = 0;
      v123 = 0;
      v124 = v120 ^ *(_DWORD *)(v748 - 364);
      v125 = *(_DWORD *)(v748 - 300) ^ __ROL4__(v120, 4);
      v126 = v125;
      v127 = (v125 >> 8) & 0xFC00FC | 0xFF00FF00;
      v128 = v126 & 0xFC00FC;
      v129 = -167733504;
      v804 = v127;
      v128 |= 0xFF00FF00;
      v130 = v128;
      v131 = v124 & 0xFC00FC | 0xFF00FF00;
      v132 = v127 - v128;
      v780 = v128;
      v828 = v124 & 0xFC00FC | 0xFF00FF00;
      v852 = (v124 >> 8) & 0xFC00FC | 0xFF00FF00;
      v133 = v128;
      v134 = (signed int *)&unk_EF160;
      v135 = 0;
      v136 = v852 - v130;
      v137 = v131 - v130;
      v737 = v132;
      while ( 1 )
      {
        v134 += 4;
        v138 = v114 & (v137 + v133);
        v139 = v112 & (v136 + v133);
        v140 = v133 + v737;
        v123 ^= v133 & v113;
        v133 += 524296;
        v135 ^= v138;
        v121 ^= v139;
        v122 ^= v129 & v140;
        if ( v134 == (signed int *)"triple-DES inner-CBC" )
          break;
        v113 = *v134;
        v129 = v134[1];
        v114 = v134[2];
        v112 = v134[3];
      }
      v141 = 234941184;
      v142 = -2097117952;
      v143 = 2063609344;
      v144 = ((16 * v135 & 15360 * ((v828 + 16777472) & 0x40004) ^ v135) >> 8) & 0xF000F0 | (16 * v121 & 15360 * ((v852 + 16777472) & 0x40004) ^ v121) & 0xF000F000 | ((16 * v122 & 15360 * ((v804 + 16777472) & 0x40004) ^ v122) >> 4) & 0xF000F00 | ((16 * v123 & 15360 * ((v780 + 16777472) & 0x40004) ^ v123) >> 12) & 0xF000F;
      v145 = 16 * ((v144 ^ (v144 >> 4)) & 0x7030702) ^ (v144 ^ (v144 >> 4)) & 0x7030702 ^ v144;
      v146 = (((v145 ^ (v145 >> 8)) & 0x4E009E) << 8) ^ (v145 ^ (v145 >> 8)) & 0x4E009E ^ v145;
      v147 = ((unsigned __int16)((v146 ^ HIWORD(v146)) & 0xD9D3) << 16) ^ ((unsigned __int16)v146 ^ HIWORD(v146)) & 0xD9D3 ^ v146;
      v148 = 16 * ((v147 ^ (v147 >> 4)) & 0x5040004) ^ (v147 ^ (v147 >> 4)) & 0x5040004 ^ v147;
      v149 = 2 * ((v148 ^ (v148 >> 1)) & 0x4045015) ^ (v148 ^ (v148 >> 1)) & 0x4045015 ^ v752 ^ v148;
      v150 = 0;
      v753 = v149;
      v151 = 0;
      v152 = 0;
      v153 = v149 ^ *(_DWORD *)(v748 - 360);
      v154 = *(_DWORD *)(v748 - 296) ^ __ROL4__(v149, 4);
      v155 = v154;
      v156 = (v154 >> 8) & 0xFC00FC | 0xFF00FF00;
      v157 = v155 & 0xFC00FC;
      v158 = -167733504;
      v805 = v156;
      v157 |= 0xFF00FF00;
      v159 = v157;
      v160 = v153 & 0xFC00FC | 0xFF00FF00;
      v161 = v156 - v157;
      v781 = v157;
      v829 = v153 & 0xFC00FC | 0xFF00FF00;
      v853 = (v153 >> 8) & 0xFC00FC | 0xFF00FF00;
      v162 = v157;
      v163 = (signed int *)&unk_EF160;
      v164 = 0;
      v165 = v853 - v159;
      v166 = v160 - v159;
      while ( 1 )
      {
        v163 += 4;
        v167 = v141 & (v165 + v162);
        v152 ^= v162 & v142;
        v168 = v162 + v161;
        v164 ^= v143 & (v166 + v162);
        v162 += 524296;
        v150 ^= v167;
        v151 ^= v158 & v168;
        if ( v163 == (signed int *)"triple-DES inner-CBC" )
          break;
        v142 = *v163;
        v158 = v163[1];
        v143 = v163[2];
        v141 = v163[3];
      }
      v169 = 234941184;
      v170 = -2097117952;
      v171 = 2063609344;
      v172 = ((16 * v164 & 15360 * ((v829 + 16777472) & 0x40004) ^ v164) >> 8) & 0xF000F0 | (16 * v150 & 15360 * ((v853 + 16777472) & 0x40004) ^ v150) & 0xF000F000 | ((16 * v151 & 15360 * ((v805 + 16777472) & 0x40004) ^ v151) >> 4) & 0xF000F00 | ((16 * v152 & 15360 * ((v781 + 16777472) & 0x40004) ^ v152) >> 12) & 0xF000F;
      v173 = 16 * ((v172 ^ (v172 >> 4)) & 0x7030702) ^ (v172 ^ (v172 >> 4)) & 0x7030702 ^ v172;
      v174 = (((v173 ^ (v173 >> 8)) & 0x4E009E) << 8) ^ (v173 ^ (v173 >> 8)) & 0x4E009E ^ v173;
      v175 = ((unsigned __int16)((v174 ^ HIWORD(v174)) & 0xD9D3) << 16) ^ ((unsigned __int16)v174 ^ HIWORD(v174)) & 0xD9D3 ^ v174;
      v176 = 16 * ((v175 ^ (v175 >> 4)) & 0x5040004) ^ (v175 ^ (v175 >> 4)) & 0x5040004 ^ v175;
      v177 = 2 * ((v176 ^ (v176 >> 1)) & 0x4045015) ^ (v176 ^ (v176 >> 1)) & 0x4045015 ^ v765 ^ v176;
      v178 = 0;
      v766 = v177;
      v179 = 0;
      v180 = 0;
      v181 = v177 ^ *(_DWORD *)(v748 - 356);
      v182 = *(_DWORD *)(v748 - 292) ^ __ROL4__(v177, 4);
      v183 = v182;
      v184 = (v182 >> 8) & 0xFC00FC | 0xFF00FF00;
      v185 = v183 & 0xFC00FC;
      v186 = -167733504;
      v806 = v184;
      v185 |= 0xFF00FF00;
      v187 = v185;
      v188 = v181 & 0xFC00FC | 0xFF00FF00;
      v189 = v184 - v185;
      v782 = v185;
      v830 = v181 & 0xFC00FC | 0xFF00FF00;
      v854 = (v181 >> 8) & 0xFC00FC | 0xFF00FF00;
      v190 = v185;
      v191 = (signed int *)&unk_EF160;
      v192 = 0;
      v193 = v854 - v187;
      v194 = v188 - v187;
      v738 = v189;
      while ( 1 )
      {
        v191 += 4;
        v195 = v171 & (v194 + v190);
        v196 = v169 & (v193 + v190);
        v197 = v190 + v738;
        v180 ^= v190 & v170;
        v190 += 524296;
        v192 ^= v195;
        v178 ^= v196;
        v179 ^= v186 & v197;
        if ( v191 == (signed int *)"triple-DES inner-CBC" )
          break;
        v170 = *v191;
        v186 = v191[1];
        v171 = v191[2];
        v169 = v191[3];
      }
      v198 = 234941184;
      v199 = -2097117952;
      v200 = 2063609344;
      v201 = ((16 * v192 & 15360 * ((v830 + 16777472) & 0x40004) ^ v192) >> 8) & 0xF000F0 | (16 * v178 & 15360 * ((v854 + 16777472) & 0x40004) ^ v178) & 0xF000F000 | ((16 * v179 & 15360 * ((v806 + 16777472) & 0x40004) ^ v179) >> 4) & 0xF000F00 | ((16 * v180 & 15360 * ((v782 + 16777472) & 0x40004) ^ v180) >> 12) & 0xF000F;
      v202 = 16 * ((v201 ^ (v201 >> 4)) & 0x7030702) ^ (v201 ^ (v201 >> 4)) & 0x7030702 ^ v201;
      v203 = (((v202 ^ (v202 >> 8)) & 0x4E009E) << 8) ^ (v202 ^ (v202 >> 8)) & 0x4E009E ^ v202;
      v204 = ((unsigned __int16)((v203 ^ HIWORD(v203)) & 0xD9D3) << 16) ^ ((unsigned __int16)v203 ^ HIWORD(v203)) & 0xD9D3 ^ v203;
      v205 = 16 * ((v204 ^ (v204 >> 4)) & 0x5040004) ^ (v204 ^ (v204 >> 4)) & 0x5040004 ^ v204;
      v206 = 2 * ((v205 ^ (v205 >> 1)) & 0x4045015) ^ (v205 ^ (v205 >> 1)) & 0x4045015 ^ v753 ^ v205;
      v207 = 0;
      v754 = v206;
      v208 = 0;
      v209 = 0;
      v210 = v206 ^ *(_DWORD *)(v748 - 352);
      v211 = *(_DWORD *)(v748 - 288) ^ __ROL4__(v206, 4);
      v212 = v211;
      v213 = (v211 >> 8) & 0xFC00FC | 0xFF00FF00;
      v214 = v212 & 0xFC00FC;
      v215 = -167733504;
      v807 = v213;
      v214 |= 0xFF00FF00;
      v216 = v214;
      v217 = v210 & 0xFC00FC | 0xFF00FF00;
      v218 = v213 - v214;
      v783 = v214;
      v831 = v210 & 0xFC00FC | 0xFF00FF00;
      v855 = (v210 >> 8) & 0xFC00FC | 0xFF00FF00;
      v219 = v214;
      v220 = (signed int *)&unk_EF160;
      v221 = 0;
      v222 = v855 - v216;
      v223 = v217 - v216;
      while ( 1 )
      {
        v220 += 4;
        v224 = v198 & (v222 + v219);
        v209 ^= v219 & v199;
        v225 = v219 + v218;
        v221 ^= v200 & (v223 + v219);
        v219 += 524296;
        v207 ^= v224;
        v208 ^= v215 & v225;
        if ( v220 == (signed int *)"triple-DES inner-CBC" )
          break;
        v199 = *v220;
        v215 = v220[1];
        v200 = v220[2];
        v198 = v220[3];
      }
      v226 = 234941184;
      v227 = -2097117952;
      v228 = 2063609344;
      v229 = ((16 * v221 & 15360 * ((v831 + 16777472) & 0x40004) ^ v221) >> 8) & 0xF000F0 | (16 * v207 & 15360 * ((v855 + 16777472) & 0x40004) ^ v207) & 0xF000F000 | ((16 * v208 & 15360 * ((v807 + 16777472) & 0x40004) ^ v208) >> 4) & 0xF000F00 | ((16 * v209 & 15360 * ((v783 + 16777472) & 0x40004) ^ v209) >> 12) & 0xF000F;
      v230 = 16 * ((v229 ^ (v229 >> 4)) & 0x7030702) ^ (v229 ^ (v229 >> 4)) & 0x7030702 ^ v229;
      v231 = (((v230 ^ (v230 >> 8)) & 0x4E009E) << 8) ^ (v230 ^ (v230 >> 8)) & 0x4E009E ^ v230;
      v232 = ((unsigned __int16)((v231 ^ HIWORD(v231)) & 0xD9D3) << 16) ^ ((unsigned __int16)v231 ^ HIWORD(v231)) & 0xD9D3 ^ v231;
      v233 = 16 * ((v232 ^ (v232 >> 4)) & 0x5040004) ^ (v232 ^ (v232 >> 4)) & 0x5040004 ^ v232;
      v234 = 2 * ((v233 ^ (v233 >> 1)) & 0x4045015) ^ (v233 ^ (v233 >> 1)) & 0x4045015 ^ v766 ^ v233;
      v235 = 0;
      v767 = v234;
      v236 = 0;
      v237 = 0;
      v238 = v234 ^ *(_DWORD *)(v748 - 348);
      v239 = *(_DWORD *)(v748 - 284) ^ __ROL4__(v234, 4);
      v240 = v239;
      v241 = (v239 >> 8) & 0xFC00FC | 0xFF00FF00;
      v242 = v240 & 0xFC00FC;
      v243 = -167733504;
      v808 = v241;
      v242 |= 0xFF00FF00;
      v244 = v242;
      v245 = v238 & 0xFC00FC | 0xFF00FF00;
      v246 = v241 - v242;
      v784 = v242;
      v832 = v238 & 0xFC00FC | 0xFF00FF00;
      v856 = (v238 >> 8) & 0xFC00FC | 0xFF00FF00;
      v247 = v242;
      v248 = (signed int *)&unk_EF160;
      v249 = 0;
      v250 = v856 - v244;
      v251 = v245 - v244;
      v739 = v246;
      while ( 1 )
      {
        v248 += 4;
        v252 = v228 & (v251 + v247);
        v253 = v226 & (v250 + v247);
        v254 = v247 + v739;
        v237 ^= v247 & v227;
        v247 += 524296;
        v249 ^= v252;
        v235 ^= v253;
        v236 ^= v243 & v254;
        if ( v248 == (signed int *)"triple-DES inner-CBC" )
          break;
        v227 = *v248;
        v243 = v248[1];
        v228 = v248[2];
        v226 = v248[3];
      }
      *(_DWORD *)(v748 - 20) = v767;
      v255 = ((16 * v249 & 15360 * ((v832 + 16777472) & 0x40004) ^ v249) >> 8) & 0xF000F0 | (16 * v235 & 15360 * ((v856 + 16777472) & 0x40004) ^ v235) & 0xF000F000 | ((16 * v236 & 15360 * ((v808 + 16777472) & 0x40004) ^ v236) >> 4) & 0xF000F00 | ((16 * v237 & 15360 * ((v784 + 16777472) & 0x40004) ^ v237) >> 12) & 0xF000F;
      v256 = 16 * ((v255 ^ (v255 >> 4)) & 0x7030702) ^ (v255 ^ (v255 >> 4)) & 0x7030702 ^ v255;
      v257 = (((v256 ^ (v256 >> 8)) & 0x4E009E) << 8) ^ (v256 ^ (v256 >> 8)) & 0x4E009E ^ v256;
      v258 = ((unsigned __int16)((v257 ^ HIWORD(v257)) & 0xD9D3) << 16) ^ ((unsigned __int16)v257 ^ HIWORD(v257)) & 0xD9D3 ^ v257;
      v259 = 16 * ((v258 ^ (v258 >> 4)) & 0x5040004) ^ (v258 ^ (v258 >> 4)) & 0x5040004 ^ v258;
      v260 = 2 * ((v259 ^ (v259 >> 1)) & 0x4045015) ^ (v259 ^ (v259 >> 1)) & 0x4045015 ^ v259 ^ v754;
      *(_DWORD *)(v748 - 24) = v260;
      v261 = 0;
      v262 = 0;
      v263 = 0;
      v264 = sub_634C0(((unsigned __int64)v767 << 32) | v260, v874, 15LL, -1LL);
      v265 = *(_DWORD *)(v748 - 8) ^ *(_DWORD *)(v748 - 16);
      v266 = *(_DWORD *)(v748 - 12);
      *(_DWORD *)(v748 - 16) = v260;
      *(_DWORD *)(v748 - 12) = v767;
      v267 = 234941184;
      v268 = 2063609344;
      v269 = -2097117952;
      v768 = v264 ^ v265;
      LODWORD(v264) = HIDWORD(v264) ^ v266 ^ *(_DWORD *)(v748 - 4);
      v755 = v264;
      v270 = v264 ^ *(_DWORD *)(v748 - 152);
      LODWORD(v264) = *(_DWORD *)(v748 - 88) ^ __ROL4__(v264, 4);
      v271 = v264;
      LODWORD(v264) = ((unsigned int)v264 >> 8) & 0xFC00FC | 0xFF00FF00;
      v272 = v271 & 0xFC00FC;
      v273 = -167733504;
      v809 = v264;
      v272 |= 0xFF00FF00;
      v274 = v272;
      v275 = v270 & 0xFC00FC | 0xFF00FF00;
      v276 = v264 - v272;
      v785 = v272;
      v833 = v270 & 0xFC00FC | 0xFF00FF00;
      v857 = (v270 >> 8) & 0xFC00FC | 0xFF00FF00;
      v277 = v272;
      v278 = (signed int *)&unk_EF160;
      v279 = 0;
      v280 = v857 - v274;
      v281 = v275 - v274;
      while ( 1 )
      {
        v278 += 4;
        v282 = v267 & (v280 + v277);
        v263 ^= v277 & v269;
        v283 = v277 + v276;
        v279 ^= v268 & (v281 + v277);
        v277 += 524296;
        v261 ^= v282;
        v262 ^= v273 & v283;
        if ( v278 == (signed int *)"triple-DES inner-CBC" )
          break;
        v269 = *v278;
        v273 = v278[1];
        v268 = v278[2];
        v267 = v278[3];
      }
      v284 = 234941184;
      v285 = -2097117952;
      v286 = 2063609344;
      v287 = ((16 * v279 & 15360 * ((v833 + 16777472) & 0x40004) ^ v279) >> 8) & 0xF000F0 | (16 * v261 & 15360 * ((v857 + 16777472) & 0x40004) ^ v261) & 0xF000F000 | ((16 * v262 & 15360 * ((v809 + 16777472) & 0x40004) ^ v262) >> 4) & 0xF000F00 | ((16 * v263 & 15360 * ((v785 + 16777472) & 0x40004) ^ v263) >> 12) & 0xF000F;
      v288 = 16 * ((v287 ^ (v287 >> 4)) & 0x7030702) ^ (v287 ^ (v287 >> 4)) & 0x7030702 ^ v287;
      v289 = (((v288 ^ (v288 >> 8)) & 0x4E009E) << 8) ^ (v288 ^ (v288 >> 8)) & 0x4E009E ^ v288;
      v290 = ((unsigned __int16)((v289 ^ HIWORD(v289)) & 0xD9D3) << 16) ^ ((unsigned __int16)v289 ^ HIWORD(v289)) & 0xD9D3 ^ v289;
      v291 = 16 * ((v290 ^ (v290 >> 4)) & 0x5040004) ^ (v290 ^ (v290 >> 4)) & 0x5040004 ^ v290;
      v292 = 2 * ((v291 ^ (v291 >> 1)) & 0x4045015) ^ (v291 ^ (v291 >> 1)) & 0x4045015 ^ v768 ^ v291;
      v293 = 0;
      v769 = v292;
      v294 = 0;
      v295 = 0;
      v296 = v292 ^ *(_DWORD *)(v748 - 148);
      v297 = *(_DWORD *)(v748 - 84) ^ __ROL4__(v292, 4);
      v298 = v297;
      v299 = (v297 >> 8) & 0xFC00FC | 0xFF00FF00;
      v300 = v298 & 0xFC00FC;
      v301 = -167733504;
      v810 = v299;
      v300 |= 0xFF00FF00;
      v302 = v300;
      v303 = v296 & 0xFC00FC | 0xFF00FF00;
      v304 = v299 - v300;
      v786 = v300;
      v834 = v296 & 0xFC00FC | 0xFF00FF00;
      v858 = (v296 >> 8) & 0xFC00FC | 0xFF00FF00;
      v305 = v300;
      v306 = (signed int *)&unk_EF160;
      v307 = 0;
      v308 = v858 - v302;
      v309 = v303 - v302;
      v740 = v304;
      while ( 1 )
      {
        v306 += 4;
        v310 = v286 & (v309 + v305);
        v311 = v284 & (v308 + v305);
        v312 = v305 + v740;
        v295 ^= v305 & v285;
        v305 += 524296;
        v307 ^= v310;
        v293 ^= v311;
        v294 ^= v301 & v312;
        if ( v306 == (signed int *)"triple-DES inner-CBC" )
          break;
        v285 = *v306;
        v301 = v306[1];
        v286 = v306[2];
        v284 = v306[3];
      }
      v313 = 234941184;
      v314 = -2097117952;
      v315 = 2063609344;
      v316 = ((16 * v307 & 15360 * ((v834 + 16777472) & 0x40004) ^ v307) >> 8) & 0xF000F0 | (16 * v293 & 15360 * ((v858 + 16777472) & 0x40004) ^ v293) & 0xF000F000 | ((16 * v294 & 15360 * ((v810 + 16777472) & 0x40004) ^ v294) >> 4) & 0xF000F00 | ((16 * v295 & 15360 * ((v786 + 16777472) & 0x40004) ^ v295) >> 12) & 0xF000F;
      v317 = 16 * ((v316 ^ (v316 >> 4)) & 0x7030702) ^ (v316 ^ (v316 >> 4)) & 0x7030702 ^ v316;
      v318 = (((v317 ^ (v317 >> 8)) & 0x4E009E) << 8) ^ (v317 ^ (v317 >> 8)) & 0x4E009E ^ v317;
      v319 = ((unsigned __int16)((v318 ^ HIWORD(v318)) & 0xD9D3) << 16) ^ ((unsigned __int16)v318 ^ HIWORD(v318)) & 0xD9D3 ^ v318;
      v320 = 16 * ((v319 ^ (v319 >> 4)) & 0x5040004) ^ (v319 ^ (v319 >> 4)) & 0x5040004 ^ v319;
      v321 = 2 * ((v320 ^ (v320 >> 1)) & 0x4045015) ^ (v320 ^ (v320 >> 1)) & 0x4045015 ^ v755 ^ v320;
      v322 = 0;
      v756 = v321;
      v323 = 0;
      v324 = 0;
      v325 = v321 ^ *(_DWORD *)(v748 - 144);
      v326 = *(_DWORD *)(v748 - 80) ^ __ROL4__(v321, 4);
      v327 = v326;
      v328 = (v326 >> 8) & 0xFC00FC | 0xFF00FF00;
      v329 = v327 & 0xFC00FC;
      v330 = -167733504;
      v811 = v328;
      v329 |= 0xFF00FF00;
      v331 = v329;
      v332 = v325 & 0xFC00FC | 0xFF00FF00;
      v333 = v328 - v329;
      v787 = v329;
      v835 = v325 & 0xFC00FC | 0xFF00FF00;
      v859 = (v325 >> 8) & 0xFC00FC | 0xFF00FF00;
      v334 = v329;
      v335 = (signed int *)&unk_EF160;
      v336 = 0;
      v337 = v859 - v331;
      v338 = v332 - v331;
      while ( 1 )
      {
        v335 += 4;
        v339 = v313 & (v337 + v334);
        v324 ^= v334 & v314;
        v340 = v334 + v333;
        v336 ^= v315 & (v338 + v334);
        v334 += 524296;
        v322 ^= v339;
        v323 ^= v330 & v340;
        if ( v335 == (signed int *)"triple-DES inner-CBC" )
          break;
        v314 = *v335;
        v330 = v335[1];
        v315 = v335[2];
        v313 = v335[3];
      }
      v341 = 234941184;
      v342 = -2097117952;
      v343 = 2063609344;
      v344 = ((16 * v336 & 15360 * ((v835 + 16777472) & 0x40004) ^ v336) >> 8) & 0xF000F0 | (16 * v322 & 15360 * ((v859 + 16777472) & 0x40004) ^ v322) & 0xF000F000 | ((16 * v323 & 15360 * ((v811 + 16777472) & 0x40004) ^ v323) >> 4) & 0xF000F00 | ((16 * v324 & 15360 * ((v787 + 16777472) & 0x40004) ^ v324) >> 12) & 0xF000F;
      v345 = 16 * ((v344 ^ (v344 >> 4)) & 0x7030702) ^ (v344 ^ (v344 >> 4)) & 0x7030702 ^ v344;
      v346 = (((v345 ^ (v345 >> 8)) & 0x4E009E) << 8) ^ (v345 ^ (v345 >> 8)) & 0x4E009E ^ v345;
      v347 = ((unsigned __int16)((v346 ^ HIWORD(v346)) & 0xD9D3) << 16) ^ ((unsigned __int16)v346 ^ HIWORD(v346)) & 0xD9D3 ^ v346;
      v348 = 16 * ((v347 ^ (v347 >> 4)) & 0x5040004) ^ (v347 ^ (v347 >> 4)) & 0x5040004 ^ v347;
      v349 = 2 * ((v348 ^ (v348 >> 1)) & 0x4045015) ^ (v348 ^ (v348 >> 1)) & 0x4045015 ^ v769 ^ v348;
      v350 = 0;
      v770 = v349;
      v351 = 0;
      v352 = 0;
      v353 = v349 ^ *(_DWORD *)(v748 - 140);
      v354 = *(_DWORD *)(v748 - 76) ^ __ROL4__(v349, 4);
      v355 = v354;
      v356 = (v354 >> 8) & 0xFC00FC | 0xFF00FF00;
      v357 = v355 & 0xFC00FC;
      v358 = -167733504;
      v812 = v356;
      v357 |= 0xFF00FF00;
      v359 = v357;
      v360 = v353 & 0xFC00FC | 0xFF00FF00;
      v361 = v356 - v357;
      v788 = v357;
      v836 = v353 & 0xFC00FC | 0xFF00FF00;
      v860 = (v353 >> 8) & 0xFC00FC | 0xFF00FF00;
      v362 = v357;
      v363 = (signed int *)&unk_EF160;
      v364 = 0;
      v365 = v860 - v359;
      v366 = v360 - v359;
      v741 = v361;
      while ( 1 )
      {
        v363 += 4;
        v367 = v343 & (v366 + v362);
        v368 = v341 & (v365 + v362);
        v369 = v362 + v741;
        v352 ^= v362 & v342;
        v362 += 524296;
        v364 ^= v367;
        v350 ^= v368;
        v351 ^= v358 & v369;
        if ( v363 == (signed int *)"triple-DES inner-CBC" )
          break;
        v342 = *v363;
        v358 = v363[1];
        v343 = v363[2];
        v341 = v363[3];
      }
      v370 = 234941184;
      v371 = -2097117952;
      v372 = 2063609344;
      v373 = ((16 * v364 & 15360 * ((v836 + 16777472) & 0x40004) ^ v364) >> 8) & 0xF000F0 | (16 * v350 & 15360 * ((v860 + 16777472) & 0x40004) ^ v350) & 0xF000F000 | ((16 * v351 & 15360 * ((v812 + 16777472) & 0x40004) ^ v351) >> 4) & 0xF000F00 | ((16 * v352 & 15360 * ((v788 + 16777472) & 0x40004) ^ v352) >> 12) & 0xF000F;
      v374 = 16 * ((v373 ^ (v373 >> 4)) & 0x7030702) ^ (v373 ^ (v373 >> 4)) & 0x7030702 ^ v373;
      v375 = (((v374 ^ (v374 >> 8)) & 0x4E009E) << 8) ^ (v374 ^ (v374 >> 8)) & 0x4E009E ^ v374;
      v376 = ((unsigned __int16)((v375 ^ HIWORD(v375)) & 0xD9D3) << 16) ^ ((unsigned __int16)v375 ^ HIWORD(v375)) & 0xD9D3 ^ v375;
      v377 = 16 * ((v376 ^ (v376 >> 4)) & 0x5040004) ^ (v376 ^ (v376 >> 4)) & 0x5040004 ^ v376;
      v378 = 2 * ((v377 ^ (v377 >> 1)) & 0x4045015) ^ (v377 ^ (v377 >> 1)) & 0x4045015 ^ v756 ^ v377;
      v379 = 0;
      v757 = v378;
      v380 = 0;
      v381 = 0;
      v382 = v378 ^ *(_DWORD *)(v748 - 136);
      v383 = *(_DWORD *)(v748 - 72) ^ __ROL4__(v378, 4);
      v384 = v383;
      v385 = (v383 >> 8) & 0xFC00FC | 0xFF00FF00;
      v386 = v384 & 0xFC00FC;
      v387 = -167733504;
      v813 = v385;
      v386 |= 0xFF00FF00;
      v388 = v386;
      v389 = v382 & 0xFC00FC | 0xFF00FF00;
      v390 = v385 - v386;
      v789 = v386;
      v837 = v382 & 0xFC00FC | 0xFF00FF00;
      v861 = (v382 >> 8) & 0xFC00FC | 0xFF00FF00;
      v391 = v386;
      v392 = (signed int *)&unk_EF160;
      v393 = 0;
      v394 = v861 - v388;
      v395 = v389 - v388;
      while ( 1 )
      {
        v392 += 4;
        v396 = v370 & (v394 + v391);
        v381 ^= v391 & v371;
        v397 = v391 + v390;
        v393 ^= v372 & (v395 + v391);
        v391 += 524296;
        v379 ^= v396;
        v380 ^= v387 & v397;
        if ( v392 == (signed int *)"triple-DES inner-CBC" )
          break;
        v371 = *v392;
        v387 = v392[1];
        v372 = v392[2];
        v370 = v392[3];
      }
      v398 = 234941184;
      v399 = -2097117952;
      v400 = 2063609344;
      v401 = ((16 * v393 & 15360 * ((v837 + 16777472) & 0x40004) ^ v393) >> 8) & 0xF000F0 | (16 * v379 & 15360 * ((v861 + 16777472) & 0x40004) ^ v379) & 0xF000F000 | ((16 * v380 & 15360 * ((v813 + 16777472) & 0x40004) ^ v380) >> 4) & 0xF000F00 | ((16 * v381 & 15360 * ((v789 + 16777472) & 0x40004) ^ v381) >> 12) & 0xF000F;
      v402 = 16 * ((v401 ^ (v401 >> 4)) & 0x7030702) ^ (v401 ^ (v401 >> 4)) & 0x7030702 ^ v401;
      v403 = (((v402 ^ (v402 >> 8)) & 0x4E009E) << 8) ^ (v402 ^ (v402 >> 8)) & 0x4E009E ^ v402;
      v404 = ((unsigned __int16)((v403 ^ HIWORD(v403)) & 0xD9D3) << 16) ^ ((unsigned __int16)v403 ^ HIWORD(v403)) & 0xD9D3 ^ v403;
      v405 = 16 * ((v404 ^ (v404 >> 4)) & 0x5040004) ^ (v404 ^ (v404 >> 4)) & 0x5040004 ^ v404;
      v406 = 2 * ((v405 ^ (v405 >> 1)) & 0x4045015) ^ (v405 ^ (v405 >> 1)) & 0x4045015 ^ v770 ^ v405;
      v407 = 0;
      v771 = v406;
      v408 = 0;
      v409 = 0;
      v410 = v406 ^ *(_DWORD *)(v748 - 132);
      v411 = *(_DWORD *)(v748 - 68) ^ __ROL4__(v406, 4);
      v412 = v411;
      v413 = (v411 >> 8) & 0xFC00FC | 0xFF00FF00;
      v414 = v412 & 0xFC00FC;
      v415 = -167733504;
      v814 = v413;
      v414 |= 0xFF00FF00;
      v416 = v414;
      v417 = v410 & 0xFC00FC | 0xFF00FF00;
      v418 = v413 - v414;
      v790 = v414;
      v838 = v410 & 0xFC00FC | 0xFF00FF00;
      v862 = (v410 >> 8) & 0xFC00FC | 0xFF00FF00;
      v419 = v414;
      v420 = (signed int *)&unk_EF160;
      v421 = 0;
      v422 = v862 - v416;
      v423 = v417 - v416;
      v742 = v418;
      while ( 1 )
      {
        v420 += 4;
        v424 = v400 & (v423 + v419);
        v425 = v398 & (v422 + v419);
        v426 = v419 + v742;
        v409 ^= v419 & v399;
        v419 += 524296;
        v421 ^= v424;
        v407 ^= v425;
        v408 ^= v415 & v426;
        if ( v420 == (signed int *)"triple-DES inner-CBC" )
          break;
        v399 = *v420;
        v415 = v420[1];
        v400 = v420[2];
        v398 = v420[3];
      }
      v427 = 234941184;
      v428 = -2097117952;
      v429 = 2063609344;
      v430 = ((16 * v421 & 15360 * ((v838 + 16777472) & 0x40004) ^ v421) >> 8) & 0xF000F0 | (16 * v407 & 15360 * ((v862 + 16777472) & 0x40004) ^ v407) & 0xF000F000 | ((16 * v408 & 15360 * ((v814 + 16777472) & 0x40004) ^ v408) >> 4) & 0xF000F00 | ((16 * v409 & 15360 * ((v790 + 16777472) & 0x40004) ^ v409) >> 12) & 0xF000F;
      v431 = 16 * ((v430 ^ (v430 >> 4)) & 0x7030702) ^ (v430 ^ (v430 >> 4)) & 0x7030702 ^ v430;
      v432 = (((v431 ^ (v431 >> 8)) & 0x4E009E) << 8) ^ (v431 ^ (v431 >> 8)) & 0x4E009E ^ v431;
      v433 = ((unsigned __int16)((v432 ^ HIWORD(v432)) & 0xD9D3) << 16) ^ ((unsigned __int16)v432 ^ HIWORD(v432)) & 0xD9D3 ^ v432;
      v434 = 16 * ((v433 ^ (v433 >> 4)) & 0x5040004) ^ (v433 ^ (v433 >> 4)) & 0x5040004 ^ v433;
      v435 = 2 * ((v434 ^ (v434 >> 1)) & 0x4045015) ^ (v434 ^ (v434 >> 1)) & 0x4045015 ^ v757 ^ v434;
      v436 = 0;
      v758 = v435;
      v437 = 0;
      v438 = 0;
      v439 = v435 ^ *(_DWORD *)(v748 - 128);
      v440 = *(_DWORD *)(v748 - 64) ^ __ROL4__(v435, 4);
      v441 = v440;
      v442 = (v440 >> 8) & 0xFC00FC | 0xFF00FF00;
      v443 = v441 & 0xFC00FC;
      v444 = -167733504;
      v815 = v442;
      v443 |= 0xFF00FF00;
      v445 = v443;
      v446 = v439 & 0xFC00FC | 0xFF00FF00;
      v447 = v442 - v443;
      v791 = v443;
      v839 = v439 & 0xFC00FC | 0xFF00FF00;
      v863 = (v439 >> 8) & 0xFC00FC | 0xFF00FF00;
      v448 = v443;
      v449 = (signed int *)&unk_EF160;
      v450 = 0;
      v451 = v863 - v445;
      v452 = v446 - v445;
      while ( 1 )
      {
        v449 += 4;
        v453 = v427 & (v451 + v448);
        v438 ^= v448 & v428;
        v454 = v448 + v447;
        v450 ^= v429 & (v452 + v448);
        v448 += 524296;
        v436 ^= v453;
        v437 ^= v444 & v454;
        if ( v449 == (signed int *)"triple-DES inner-CBC" )
          break;
        v428 = *v449;
        v444 = v449[1];
        v429 = v449[2];
        v427 = v449[3];
      }
      v455 = 234941184;
      v456 = -2097117952;
      v457 = 2063609344;
      v458 = ((16 * v450 & 15360 * ((v839 + 16777472) & 0x40004) ^ v450) >> 8) & 0xF000F0 | (16 * v436 & 15360 * ((v863 + 16777472) & 0x40004) ^ v436) & 0xF000F000 | ((16 * v437 & 15360 * ((v815 + 16777472) & 0x40004) ^ v437) >> 4) & 0xF000F00 | ((16 * v438 & 15360 * ((v791 + 16777472) & 0x40004) ^ v438) >> 12) & 0xF000F;
      v459 = 16 * ((v458 ^ (v458 >> 4)) & 0x7030702) ^ (v458 ^ (v458 >> 4)) & 0x7030702 ^ v458;
      v460 = (((v459 ^ (v459 >> 8)) & 0x4E009E) << 8) ^ (v459 ^ (v459 >> 8)) & 0x4E009E ^ v459;
      v461 = ((unsigned __int16)((v460 ^ HIWORD(v460)) & 0xD9D3) << 16) ^ ((unsigned __int16)v460 ^ HIWORD(v460)) & 0xD9D3 ^ v460;
      v462 = 16 * ((v461 ^ (v461 >> 4)) & 0x5040004) ^ (v461 ^ (v461 >> 4)) & 0x5040004 ^ v461;
      v463 = 2 * ((v462 ^ (v462 >> 1)) & 0x4045015) ^ (v462 ^ (v462 >> 1)) & 0x4045015 ^ v771 ^ v462;
      v464 = 0;
      v772 = v463;
      v465 = 0;
      v466 = 0;
      v467 = v463 ^ *(_DWORD *)(v748 - 124);
      v468 = *(_DWORD *)(v748 - 60) ^ __ROL4__(v463, 4);
      v469 = v468;
      v470 = (v468 >> 8) & 0xFC00FC | 0xFF00FF00;
      v471 = v469 & 0xFC00FC;
      v472 = -167733504;
      v816 = v470;
      v471 |= 0xFF00FF00;
      v473 = v471;
      v474 = v467 & 0xFC00FC | 0xFF00FF00;
      v475 = v470 - v471;
      v792 = v471;
      v840 = v467 & 0xFC00FC | 0xFF00FF00;
      v864 = (v467 >> 8) & 0xFC00FC | 0xFF00FF00;
      v476 = v471;
      v477 = (signed int *)&unk_EF160;
      v478 = 0;
      v479 = v864 - v473;
      v480 = v474 - v473;
      v743 = v475;
      while ( 1 )
      {
        v477 += 4;
        v481 = v457 & (v480 + v476);
        v482 = v455 & (v479 + v476);
        v483 = v476 + v743;
        v466 ^= v476 & v456;
        v476 += 524296;
        v478 ^= v481;
        v464 ^= v482;
        v465 ^= v472 & v483;
        if ( v477 == (signed int *)"triple-DES inner-CBC" )
          break;
        v456 = *v477;
        v472 = v477[1];
        v457 = v477[2];
        v455 = v477[3];
      }
      v484 = 234941184;
      v485 = -2097117952;
      v486 = 2063609344;
      v487 = ((16 * v478 & 15360 * ((v840 + 16777472) & 0x40004) ^ v478) >> 8) & 0xF000F0 | (16 * v464 & 15360 * ((v864 + 16777472) & 0x40004) ^ v464) & 0xF000F000 | ((16 * v465 & 15360 * ((v816 + 16777472) & 0x40004) ^ v465) >> 4) & 0xF000F00 | ((16 * v466 & 15360 * ((v792 + 16777472) & 0x40004) ^ v466) >> 12) & 0xF000F;
      v488 = 16 * ((v487 ^ (v487 >> 4)) & 0x7030702) ^ (v487 ^ (v487 >> 4)) & 0x7030702 ^ v487;
      v489 = (((v488 ^ (v488 >> 8)) & 0x4E009E) << 8) ^ (v488 ^ (v488 >> 8)) & 0x4E009E ^ v488;
      v490 = ((unsigned __int16)((v489 ^ HIWORD(v489)) & 0xD9D3) << 16) ^ ((unsigned __int16)v489 ^ HIWORD(v489)) & 0xD9D3 ^ v489;
      v491 = 16 * ((v490 ^ (v490 >> 4)) & 0x5040004) ^ (v490 ^ (v490 >> 4)) & 0x5040004 ^ v490;
      v492 = 2 * ((v491 ^ (v491 >> 1)) & 0x4045015) ^ (v491 ^ (v491 >> 1)) & 0x4045015 ^ v758 ^ v491;
      v493 = 0;
      v759 = v492;
      v494 = 0;
      v495 = 0;
      v496 = v492 ^ *(_DWORD *)(v748 - 120);
      v497 = *(_DWORD *)(v748 - 56) ^ __ROL4__(v492, 4);
      v498 = v497;
      v499 = (v497 >> 8) & 0xFC00FC | 0xFF00FF00;
      v500 = v498 & 0xFC00FC;
      v501 = -167733504;
      v817 = v499;
      v500 |= 0xFF00FF00;
      v502 = v500;
      v503 = v496 & 0xFC00FC | 0xFF00FF00;
      v504 = v499 - v500;
      v793 = v500;
      v841 = v496 & 0xFC00FC | 0xFF00FF00;
      v865 = (v496 >> 8) & 0xFC00FC | 0xFF00FF00;
      v505 = v500;
      v506 = (signed int *)&unk_EF160;
      v507 = 0;
      v508 = v865 - v502;
      v509 = v503 - v502;
      while ( 1 )
      {
        v506 += 4;
        v510 = v484 & (v508 + v505);
        v495 ^= v505 & v485;
        v511 = v505 + v504;
        v507 ^= v486 & (v509 + v505);
        v505 += 524296;
        v493 ^= v510;
        v494 ^= v501 & v511;
        if ( v506 == (signed int *)"triple-DES inner-CBC" )
          break;
        v485 = *v506;
        v501 = v506[1];
        v486 = v506[2];
        v484 = v506[3];
      }
      v512 = 234941184;
      v513 = -2097117952;
      v514 = 2063609344;
      v515 = ((16 * v507 & 15360 * ((v841 + 16777472) & 0x40004) ^ v507) >> 8) & 0xF000F0 | (16 * v493 & 15360 * ((v865 + 16777472) & 0x40004) ^ v493) & 0xF000F000 | ((16 * v494 & 15360 * ((v817 + 16777472) & 0x40004) ^ v494) >> 4) & 0xF000F00 | ((16 * v495 & 15360 * ((v793 + 16777472) & 0x40004) ^ v495) >> 12) & 0xF000F;
      v516 = 16 * ((v515 ^ (v515 >> 4)) & 0x7030702) ^ (v515 ^ (v515 >> 4)) & 0x7030702 ^ v515;
      v517 = (((v516 ^ (v516 >> 8)) & 0x4E009E) << 8) ^ (v516 ^ (v516 >> 8)) & 0x4E009E ^ v516;
      v518 = ((unsigned __int16)((v517 ^ HIWORD(v517)) & 0xD9D3) << 16) ^ ((unsigned __int16)v517 ^ HIWORD(v517)) & 0xD9D3 ^ v517;
      v519 = 16 * ((v518 ^ (v518 >> 4)) & 0x5040004) ^ (v518 ^ (v518 >> 4)) & 0x5040004 ^ v518;
      v520 = 2 * ((v519 ^ (v519 >> 1)) & 0x4045015) ^ (v519 ^ (v519 >> 1)) & 0x4045015 ^ v772 ^ v519;
      v521 = 0;
      v773 = v520;
      v522 = 0;
      v523 = 0;
      v524 = v520 ^ *(_DWORD *)(v748 - 116);
      v525 = *(_DWORD *)(v748 - 52) ^ __ROL4__(v520, 4);
      v526 = v525;
      v527 = (v525 >> 8) & 0xFC00FC | 0xFF00FF00;
      v528 = v526 & 0xFC00FC;
      v529 = -167733504;
      v818 = v527;
      v528 |= 0xFF00FF00;
      v530 = v528;
      v531 = v524 & 0xFC00FC | 0xFF00FF00;
      v532 = v527 - v528;
      v794 = v528;
      v842 = v524 & 0xFC00FC | 0xFF00FF00;
      v866 = (v524 >> 8) & 0xFC00FC | 0xFF00FF00;
      v533 = v528;
      v534 = (signed int *)&unk_EF160;
      v535 = 0;
      v536 = v866 - v530;
      v537 = v531 - v530;
      v744 = v532;
      while ( 1 )
      {
        v534 += 4;
        v538 = v514 & (v537 + v533);
        v539 = v512 & (v536 + v533);
        v540 = v533 + v744;
        v523 ^= v533 & v513;
        v533 += 524296;
        v535 ^= v538;
        v521 ^= v539;
        v522 ^= v529 & v540;
        if ( v534 == (signed int *)"triple-DES inner-CBC" )
          break;
        v513 = *v534;
        v529 = v534[1];
        v514 = v534[2];
        v512 = v534[3];
      }
      v541 = 234941184;
      v542 = -2097117952;
      v543 = 2063609344;
      v544 = ((16 * v535 & 15360 * ((v842 + 16777472) & 0x40004) ^ v535) >> 8) & 0xF000F0 | (16 * v521 & 15360 * ((v866 + 16777472) & 0x40004) ^ v521) & 0xF000F000 | ((16 * v522 & 15360 * ((v818 + 16777472) & 0x40004) ^ v522) >> 4) & 0xF000F00 | ((16 * v523 & 15360 * ((v794 + 16777472) & 0x40004) ^ v523) >> 12) & 0xF000F;
      v545 = 16 * ((v544 ^ (v544 >> 4)) & 0x7030702) ^ (v544 ^ (v544 >> 4)) & 0x7030702 ^ v544;
      v546 = (((v545 ^ (v545 >> 8)) & 0x4E009E) << 8) ^ (v545 ^ (v545 >> 8)) & 0x4E009E ^ v545;
      v547 = ((unsigned __int16)((v546 ^ HIWORD(v546)) & 0xD9D3) << 16) ^ ((unsigned __int16)v546 ^ HIWORD(v546)) & 0xD9D3 ^ v546;
      v548 = 16 * ((v547 ^ (v547 >> 4)) & 0x5040004) ^ (v547 ^ (v547 >> 4)) & 0x5040004 ^ v547;
      v549 = 2 * ((v548 ^ (v548 >> 1)) & 0x4045015) ^ (v548 ^ (v548 >> 1)) & 0x4045015 ^ v759 ^ v548;
      v550 = 0;
      v760 = v549;
      v551 = 0;
      v552 = 0;
      v553 = v549 ^ *(_DWORD *)(v748 - 112);
      v554 = *(_DWORD *)(v748 - 48) ^ __ROL4__(v549, 4);
      v555 = v554;
      v556 = (v554 >> 8) & 0xFC00FC | 0xFF00FF00;
      v557 = v555 & 0xFC00FC;
      v558 = -167733504;
      v819 = v556;
      v557 |= 0xFF00FF00;
      v559 = v557;
      v560 = v553 & 0xFC00FC | 0xFF00FF00;
      v561 = v556 - v557;
      v795 = v557;
      v843 = v553 & 0xFC00FC | 0xFF00FF00;
      v867 = (v553 >> 8) & 0xFC00FC | 0xFF00FF00;
      v562 = v557;
      v563 = (signed int *)&unk_EF160;
      v564 = 0;
      v565 = v867 - v559;
      v566 = v560 - v559;
      while ( 1 )
      {
        v563 += 4;
        v567 = v541 & (v565 + v562);
        v552 ^= v562 & v542;
        v568 = v562 + v561;
        v564 ^= v543 & (v566 + v562);
        v562 += 524296;
        v550 ^= v567;
        v551 ^= v558 & v568;
        if ( v563 == (signed int *)"triple-DES inner-CBC" )
          break;
        v542 = *v563;
        v558 = v563[1];
        v543 = v563[2];
        v541 = v563[3];
      }
      v569 = 234941184;
      v570 = -2097117952;
      v571 = 2063609344;
      v572 = ((16 * v564 & 15360 * ((v843 + 16777472) & 0x40004) ^ v564) >> 8) & 0xF000F0 | (16 * v550 & 15360 * ((v867 + 16777472) & 0x40004) ^ v550) & 0xF000F000 | ((16 * v551 & 15360 * ((v819 + 16777472) & 0x40004) ^ v551) >> 4) & 0xF000F00 | ((16 * v552 & 15360 * ((v795 + 16777472) & 0x40004) ^ v552) >> 12) & 0xF000F;
      v573 = 16 * ((v572 ^ (v572 >> 4)) & 0x7030702) ^ (v572 ^ (v572 >> 4)) & 0x7030702 ^ v572;
      v574 = (((v573 ^ (v573 >> 8)) & 0x4E009E) << 8) ^ (v573 ^ (v573 >> 8)) & 0x4E009E ^ v573;
      v575 = ((unsigned __int16)((v574 ^ HIWORD(v574)) & 0xD9D3) << 16) ^ ((unsigned __int16)v574 ^ HIWORD(v574)) & 0xD9D3 ^ v574;
      v576 = 16 * ((v575 ^ (v575 >> 4)) & 0x5040004) ^ (v575 ^ (v575 >> 4)) & 0x5040004 ^ v575;
      v577 = 2 * ((v576 ^ (v576 >> 1)) & 0x4045015) ^ (v576 ^ (v576 >> 1)) & 0x4045015 ^ v773 ^ v576;
      v578 = 0;
      v774 = v577;
      v579 = 0;
      v580 = 0;
      v581 = v577 ^ *(_DWORD *)(v748 - 108);
      v582 = *(_DWORD *)(v748 - 44) ^ __ROL4__(v577, 4);
      v583 = v582;
      v584 = (v582 >> 8) & 0xFC00FC | 0xFF00FF00;
      v585 = v583 & 0xFC00FC;
      v586 = -167733504;
      v820 = v584;
      v585 |= 0xFF00FF00;
      v587 = v585;
      v588 = v581 & 0xFC00FC | 0xFF00FF00;
      v589 = v584 - v585;
      v796 = v585;
      v844 = v581 & 0xFC00FC | 0xFF00FF00;
      v868 = (v581 >> 8) & 0xFC00FC | 0xFF00FF00;
      v590 = v585;
      v591 = (signed int *)&unk_EF160;
      v592 = 0;
      v593 = v868 - v587;
      v594 = v588 - v587;
      v745 = v589;
      while ( 1 )
      {
        v591 += 4;
        v595 = v571 & (v594 + v590);
        v596 = v569 & (v593 + v590);
        v597 = v590 + v745;
        v580 ^= v590 & v570;
        v590 += 524296;
        v592 ^= v595;
        v578 ^= v596;
        v579 ^= v586 & v597;
        if ( v591 == (signed int *)"triple-DES inner-CBC" )
          break;
        v570 = *v591;
        v586 = v591[1];
        v571 = v591[2];
        v569 = v591[3];
      }
      v598 = 234941184;
      v599 = -2097117952;
      v600 = 2063609344;
      v601 = ((16 * v592 & 15360 * ((v844 + 16777472) & 0x40004) ^ v592) >> 8) & 0xF000F0 | (16 * v578 & 15360 * ((v868 + 16777472) & 0x40004) ^ v578) & 0xF000F000 | ((16 * v579 & 15360 * ((v820 + 16777472) & 0x40004) ^ v579) >> 4) & 0xF000F00 | ((16 * v580 & 15360 * ((v796 + 16777472) & 0x40004) ^ v580) >> 12) & 0xF000F;
      v602 = 16 * ((v601 ^ (v601 >> 4)) & 0x7030702) ^ (v601 ^ (v601 >> 4)) & 0x7030702 ^ v601;
      v603 = (((v602 ^ (v602 >> 8)) & 0x4E009E) << 8) ^ (v602 ^ (v602 >> 8)) & 0x4E009E ^ v602;
      v604 = ((unsigned __int16)((v603 ^ HIWORD(v603)) & 0xD9D3) << 16) ^ ((unsigned __int16)v603 ^ HIWORD(v603)) & 0xD9D3 ^ v603;
      v605 = 16 * ((v604 ^ (v604 >> 4)) & 0x5040004) ^ (v604 ^ (v604 >> 4)) & 0x5040004 ^ v604;
      v606 = 2 * ((v605 ^ (v605 >> 1)) & 0x4045015) ^ (v605 ^ (v605 >> 1)) & 0x4045015 ^ v760 ^ v605;
      v607 = 0;
      v761 = v606;
      v608 = 0;
      v609 = 0;
      v610 = v606 ^ *(_DWORD *)(v748 - 104);
      v611 = *(_DWORD *)(v748 - 40) ^ __ROL4__(v606, 4);
      v612 = v611;
      v613 = (v611 >> 8) & 0xFC00FC | 0xFF00FF00;
      v614 = v612 & 0xFC00FC;
      v615 = -167733504;
      v821 = v613;
      v614 |= 0xFF00FF00;
      v616 = v614;
      v617 = v610 & 0xFC00FC | 0xFF00FF00;
      v618 = v613 - v614;
      v797 = v614;
      v845 = v610 & 0xFC00FC | 0xFF00FF00;
      v869 = (v610 >> 8) & 0xFC00FC | 0xFF00FF00;
      v619 = v614;
      v620 = (signed int *)&unk_EF160;
      v621 = 0;
      v622 = v869 - v616;
      v623 = v617 - v616;
      while ( 1 )
      {
        v620 += 4;
        v624 = v598 & (v622 + v619);
        v609 ^= v619 & v599;
        v625 = v619 + v618;
        v621 ^= v600 & (v623 + v619);
        v619 += 524296;
        v607 ^= v624;
        v608 ^= v615 & v625;
        if ( v620 == (signed int *)"triple-DES inner-CBC" )
          break;
        v599 = *v620;
        v615 = v620[1];
        v600 = v620[2];
        v598 = v620[3];
      }
      v626 = 234941184;
      v627 = -2097117952;
      v628 = 2063609344;
      v629 = ((16 * v621 & 15360 * ((v845 + 16777472) & 0x40004) ^ v621) >> 8) & 0xF000F0 | (16 * v607 & 15360 * ((v869 + 16777472) & 0x40004) ^ v607) & 0xF000F000 | ((16 * v608 & 15360 * ((v821 + 16777472) & 0x40004) ^ v608) >> 4) & 0xF000F00 | ((16 * v609 & 15360 * ((v797 + 16777472) & 0x40004) ^ v609) >> 12) & 0xF000F;
      v630 = 16 * ((v629 ^ (v629 >> 4)) & 0x7030702) ^ (v629 ^ (v629 >> 4)) & 0x7030702 ^ v629;
      v631 = (((v630 ^ (v630 >> 8)) & 0x4E009E) << 8) ^ (v630 ^ (v630 >> 8)) & 0x4E009E ^ v630;
      v632 = ((unsigned __int16)((v631 ^ HIWORD(v631)) & 0xD9D3) << 16) ^ ((unsigned __int16)v631 ^ HIWORD(v631)) & 0xD9D3 ^ v631;
      v633 = 16 * ((v632 ^ (v632 >> 4)) & 0x5040004) ^ (v632 ^ (v632 >> 4)) & 0x5040004 ^ v632;
      v634 = 2 * ((v633 ^ (v633 >> 1)) & 0x4045015) ^ (v633 ^ (v633 >> 1)) & 0x4045015 ^ v774 ^ v633;
      v635 = 0;
      v775 = v634;
      v636 = 0;
      v637 = 0;
      v638 = v634 ^ *(_DWORD *)(v748 - 100);
      v639 = *(_DWORD *)(v748 - 36) ^ __ROL4__(v634, 4);
      v640 = v639;
      v641 = (v639 >> 8) & 0xFC00FC | 0xFF00FF00;
      v642 = v640 & 0xFC00FC;
      v643 = -167733504;
      v822 = v641;
      v642 |= 0xFF00FF00;
      v644 = v642;
      v645 = v638 & 0xFC00FC | 0xFF00FF00;
      v646 = v641 - v642;
      v798 = v642;
      v846 = v638 & 0xFC00FC | 0xFF00FF00;
      v870 = (v638 >> 8) & 0xFC00FC | 0xFF00FF00;
      v647 = v642;
      v648 = (signed int *)&unk_EF160;
      v649 = 0;
      v650 = v870 - v644;
      v651 = v645 - v644;
      v746 = v646;
      while ( 1 )
      {
        v648 += 4;
        v652 = v628 & (v651 + v647);
        v653 = v626 & (v650 + v647);
        v654 = v647 + v746;
        v637 ^= v647 & v627;
        v647 += 524296;
        v649 ^= v652;
        v635 ^= v653;
        v636 ^= v643 & v654;
        if ( v648 == (signed int *)"triple-DES inner-CBC" )
          break;
        v627 = *v648;
        v643 = v648[1];
        v628 = v648[2];
        v626 = v648[3];
      }
      v655 = 234941184;
      v656 = -2097117952;
      v657 = 2063609344;
      v658 = ((16 * v649 & 15360 * ((v846 + 16777472) & 0x40004) ^ v649) >> 8) & 0xF000F0 | (16 * v635 & 15360 * ((v870 + 16777472) & 0x40004) ^ v635) & 0xF000F000 | ((16 * v636 & 15360 * ((v822 + 16777472) & 0x40004) ^ v636) >> 4) & 0xF000F00 | ((16 * v637 & 15360 * ((v798 + 16777472) & 0x40004) ^ v637) >> 12) & 0xF000F;
      v659 = 16 * ((v658 ^ (v658 >> 4)) & 0x7030702) ^ (v658 ^ (v658 >> 4)) & 0x7030702 ^ v658;
      v660 = (((v659 ^ (v659 >> 8)) & 0x4E009E) << 8) ^ (v659 ^ (v659 >> 8)) & 0x4E009E ^ v659;
      v661 = ((unsigned __int16)((v660 ^ HIWORD(v660)) & 0xD9D3) << 16) ^ ((unsigned __int16)v660 ^ HIWORD(v660)) & 0xD9D3 ^ v660;
      v662 = 16 * ((v661 ^ (v661 >> 4)) & 0x5040004) ^ (v661 ^ (v661 >> 4)) & 0x5040004 ^ v661;
      v663 = 2 * ((v662 ^ (v662 >> 1)) & 0x4045015) ^ (v662 ^ (v662 >> 1)) & 0x4045015 ^ v761 ^ v662;
      v664 = 0;
      v762 = v663;
      v665 = 0;
      v666 = 0;
      v667 = v663 ^ *(_DWORD *)(v748 - 96);
      v668 = *(_DWORD *)(v748 - 32) ^ __ROL4__(v663, 4);
      v669 = v668;
      v670 = (v668 >> 8) & 0xFC00FC | 0xFF00FF00;
      v671 = v669 & 0xFC00FC;
      v672 = -167733504;
      v823 = v670;
      v671 |= 0xFF00FF00;
      v673 = v671;
      v674 = v667 & 0xFC00FC | 0xFF00FF00;
      v675 = v670 - v671;
      v799 = v671;
      v847 = v667 & 0xFC00FC | 0xFF00FF00;
      v871 = (v667 >> 8) & 0xFC00FC | 0xFF00FF00;
      v676 = v671;
      v677 = (signed int *)&unk_EF160;
      v678 = 0;
      v679 = v871 - v673;
      v680 = v674 - v673;
      while ( 1 )
      {
        v677 += 4;
        v681 = v655 & (v679 + v676);
        v666 ^= v676 & v656;
        v682 = v676 + v675;
        v678 ^= v657 & (v680 + v676);
        v676 += 524296;
        v664 ^= v681;
        v665 ^= v672 & v682;
        if ( v677 == (signed int *)"triple-DES inner-CBC" )
          break;
        v656 = *v677;
        v672 = v677[1];
        v657 = v677[2];
        v655 = v677[3];
      }
      v683 = 234941184;
      v684 = -2097117952;
      v685 = 2063609344;
      v686 = ((16 * v678 & 15360 * ((v847 + 16777472) & 0x40004) ^ v678) >> 8) & 0xF000F0 | (16 * v664 & 15360 * ((v871 + 16777472) & 0x40004) ^ v664) & 0xF000F000 | ((16 * v665 & 15360 * ((v823 + 16777472) & 0x40004) ^ v665) >> 4) & 0xF000F00 | ((16 * v666 & 15360 * ((v799 + 16777472) & 0x40004) ^ v666) >> 12) & 0xF000F;
      v687 = 16 * ((v686 ^ (v686 >> 4)) & 0x7030702) ^ (v686 ^ (v686 >> 4)) & 0x7030702 ^ v686;
      v688 = (((v687 ^ (v687 >> 8)) & 0x4E009E) << 8) ^ (v687 ^ (v687 >> 8)) & 0x4E009E ^ v687;
      v689 = ((unsigned __int16)((v688 ^ HIWORD(v688)) & 0xD9D3) << 16) ^ ((unsigned __int16)v688 ^ HIWORD(v688)) & 0xD9D3 ^ v688;
      v690 = 16 * ((v689 ^ (v689 >> 4)) & 0x5040004) ^ (v689 ^ (v689 >> 4)) & 0x5040004 ^ v689;
      v691 = 2 * ((v690 ^ (v690 >> 1)) & 0x4045015) ^ (v690 ^ (v690 >> 1)) & 0x4045015 ^ v775 ^ v690;
      v692 = 0;
      v776 = v691;
      v693 = 0;
      v694 = 0;
      v695 = v691 ^ *(_DWORD *)(v748 - 92);
      v696 = *(_DWORD *)(v748 - 28) ^ __ROL4__(v691, 4);
      v697 = v696;
      v698 = (v696 >> 8) & 0xFC00FC | 0xFF00FF00;
      v699 = v697 & 0xFC00FC;
      v700 = -167733504;
      v824 = v698;
      v699 |= 0xFF00FF00;
      v701 = v699;
      v702 = v695 & 0xFC00FC | 0xFF00FF00;
      v703 = v698 - v699;
      v800 = v699;
      v848 = v695 & 0xFC00FC | 0xFF00FF00;
      v872 = (v695 >> 8) & 0xFC00FC | 0xFF00FF00;
      v704 = v699;
      v705 = (signed int *)&unk_EF160;
      v706 = 0;
      v707 = v872 - v701;
      v708 = v702 - v701;
      v747 = v703;
      while ( 1 )
      {
        v705 += 4;
        v709 = v685 & (v708 + v704);
        v710 = v683 & (v707 + v704);
        v711 = v704 + v747;
        v694 ^= v704 & v684;
        v704 += 524296;
        v706 ^= v709;
        v692 ^= v710;
        v693 ^= v700 & v711;
        if ( v705 == (signed int *)"triple-DES inner-CBC" )
          break;
        v684 = *v705;
        v700 = v705[1];
        v685 = v705[2];
        v683 = v705[3];
      }
      v712 = ((16 * v706 & 15360 * ((v848 + 16777472) & 0x40004) ^ v706) >> 8) & 0xF000F0 | (16 * v692 & 15360 * ((v872 + 16777472) & 0x40004) ^ v692) & 0xF000F000 | ((16 * v693 & 15360 * ((v824 + 16777472) & 0x40004) ^ v693) >> 4) & 0xF000F00 | ((16 * v694 & 15360 * ((v800 + 16777472) & 0x40004) ^ v694) >> 12) & 0xF000F;
      v713 = 16 * ((v712 ^ (v712 >> 4)) & 0x7030702) ^ (v712 ^ (v712 >> 4)) & 0x7030702 ^ v712;
      v714 = (((v713 ^ (v713 >> 8)) & 0x4E009E) << 8) ^ (v713 ^ (v713 >> 8)) & 0x4E009E ^ v713;
      v715 = ((unsigned __int16)((v714 ^ HIWORD(v714)) & 0xD9D3) << 16) ^ ((unsigned __int16)v714 ^ HIWORD(v714)) & 0xD9D3 ^ v714;
      v716 = 16 * ((v715 ^ (v715 >> 4)) & 0x5040004) ^ (v715 ^ (v715 >> 4)) & 0x5040004 ^ v715;
      v717 = 2 * ((v716 ^ (v716 >> 1)) & 0x4045015) ^ (v716 ^ (v716 >> 1)) & 0x4045015 ^ v716 ^ v762;
      *(_DWORD *)(v748 - 4) = v776;
      *(_DWORD *)(v748 - 8) = v717;
      v717 = __ROL4__(v717, 1);
      v718 = (__ROL4__(v776, 1) ^ (v717 >> 1)) & 0x55555555;
      v719 = v718 ^ __ROL4__(v776, 1);
      v720 = 2 * v718 ^ v717;
      v721 = (v720 ^ (v719 >> 8)) & 0xFF00FF;
      v722 = v721 ^ v720;
      v723 = v719 ^ (v721 << 8);
      v724 = (v722 ^ ((v719 ^ (v721 << 8)) >> 2)) & 0x33333333;
      v725 = v724 ^ v722;
      v726 = v723 ^ 4 * v724;
      v727 = (unsigned __int16)(v726 ^ HIWORD(v725));
      v728 = v727 ^ v726;
      v729 = v725 ^ (v727 << 16);
      v730 = (v728 ^ ((v725 ^ (unsigned int)(v727 << 16)) >> 4)) & 0xF0F0F0F;
      v731 = v730 ^ v728;
      *(_BYTE *)(v749 + 7) = v731;
      *(_BYTE *)(v749 + 6) = BYTE1(v731);
      v732 = v729 ^ 16 * v730;
      *(_BYTE *)(v749 + 3) = v732;
      *(_BYTE *)(v749 + 2) = BYTE1(v732);
      *(_BYTE *)(v749 + 1) = BYTE2(v732);
      *(_BYTE *)v749 = HIBYTE(v732);
      v733 = v749 + 8 == v873;
      *(_BYTE *)(v749 + 5) = BYTE2(v731);
      *(_BYTE *)(v749 + 4) = HIBYTE(v731);
      v749 += 8LL;
    }
    while ( !v733 );
  }
}

_QWORD *__fastcall sub_72390(__int64 a1)
{
  _QWORD *result; // rax

  *(_QWORD *)(a1 + 16) = sub_334A0(
                           "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E340"
                           "4DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F4"
                           "06B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA"
                           "8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C3290"
                           "5E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE51"
                           "5D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF");
  result = sub_330A0(2LL);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

_QWORD *__fastcall sub_723C0(__int64 a1)
{
  _QWORD *result; // rax

  *(_QWORD *)(a1 + 16) = sub_334A0(
                           "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E340"
                           "4DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F4"
                           "06B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF");
  result = sub_330A0(2LL);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

__int64 __fastcall sub_723F0(__int64 a1)
{
  return **(unsigned __int8 **)(a1 + 32);
}

unsigned __int64 **__fastcall sub_72400(__int64 a1)
{
  __int64 v1; // rbp
  unsigned __int64 **v2; // rbx
  unsigned __int64 *v3; // rax
  unsigned __int64 **result; // rax

  v1 = *(_QWORD *)(a1 + 32);
  if ( *(_BYTE *)v1 )
    __assert_fail("!extra->gex", "sshdh.c", 0x95u, "dh_setup_group");
  v2 = (unsigned __int64 **)sub_2F450(1uLL, 0x28uLL, 0LL);
  (*(void (__fastcall **)(unsigned __int64 **, signed __int64))(v1 + 8))(v2, 40LL);
  v3 = sub_34B90(v2[2], 1uLL);
  v2[1] = 0LL;
  v2[3] = v3;
  result = v2;
  *v2 = 0LL;
  return result;
}

_QWORD *__fastcall sub_72480(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rax
  unsigned __int64 *v4; // rdi
  _QWORD *v5; // rax
  _QWORD *result; // rax

  v2 = sub_2F450(1uLL, 0x28uLL, 0LL);
  v2[2] = sub_334C0(a1);
  v3 = sub_334C0(a2);
  v4 = (unsigned __int64 *)v2[2];
  v2[4] = v3;
  v5 = sub_34B90(v4, 1uLL);
  v2[1] = 0LL;
  v2[3] = v5;
  result = v2;
  *v2 = 0LL;
  return result;
}

signed __int64 __fastcall sub_724E0(__int64 a1)
{
  return sub_335B0(*(__int64 **)(a1 + 16));
}

void __fastcall sub_72500(_QWORD **a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi
  _QWORD *v5; // rdi
  _QWORD *v6; // rdi

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    sub_330F0(v2);
  v3 = (_QWORD *)v1[1];
  if ( v3 )
    sub_330F0(v3);
  v4 = (_QWORD *)v1[2];
  if ( v4 )
    sub_330F0(v4);
  v5 = (_QWORD *)v1[4];
  if ( v5 )
    sub_330F0(v5);
  v6 = (_QWORD *)v1[3];
  if ( v6 )
    sub_330F0(v6);
  sub_2F4D0(v1);
}

unsigned __int64 *__fastcall sub_72560(__int64 a1, int a2)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // r13
  __int64 *v4; // rbp
  __int64 *v5; // r12
  __int64 *v6; // rdi
  unsigned __int64 *result; // rax

  v2 = a1;
  v3 = sub_330A0(2LL);
  v4 = sub_334C0(*(_QWORD *)(a1 + 24));
  sub_33B10(v4, (unsigned __int64 *)v4, 1LL);
  if ( a2 )
  {
    v5 = (__int64 *)sub_36970(a2 + 1);
    sub_36890(v5, (unsigned __int64 *)v5, (unsigned __int64 *)v4);
    v6 = v4;
    v4 = v5;
    sub_330F0(v6);
  }
  *(_QWORD *)v2 = sub_36ED0(v3, (unsigned __int64 *)v4, (void (__fastcall *)(_BYTE *, unsigned __int64))sub_7BF50);
  sub_330F0(v3);
  sub_330F0(v4);
  result = sub_364B0(*(unsigned __int64 **)(v2 + 32), *(unsigned __int64 **)v2, *(_QWORD *)(v2 + 16));
  *(_QWORD *)(v2 + 8) = result;
  return result;
}

const char *__fastcall sub_72610(__int64 a1, signed __int64 *a2)
{
  int v2; // eax
  const char *v3; // rdx
  __int64 *v4; // rbp
  int v5; // ebx

  v2 = sub_340C0(a2, 2LL);
  v3 = "f value received is too small";
  if ( v2 )
  {
    v4 = sub_334C0(*(_QWORD *)(a1 + 16));
    sub_33B10(v4, (unsigned __int64 *)v4, 1LL);
    v5 = sub_33E30((unsigned __int64 *)a2, (unsigned __int64 *)v4);
    sub_330F0(v4);
    v3 = "f value received is too large";
    if ( !v5 )
      v3 = 0LL;
  }
  return v3;
}

unsigned __int64 *__fastcall sub_72690(__int64 a1, unsigned __int64 *a2)
{
  return sub_364B0(a2, *(unsigned __int64 **)a1, *(_QWORD *)(a1 + 16));
}

__int64 sub_726B0()
{
  return 0LL;
}

unsigned __int64 __fastcall sub_726C0(__int64 a1, __int64 a2)
{
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 40));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 32));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 24));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 16));
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 8));
}

unsigned __int64 __fastcall sub_72720(__int64 a1, __int64 a2)
{
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 8));
}

void __fastcall sub_72730(__int64 a1, _QWORD *a2)
{
  __int64 (**v2)(void); // rbp
  char *v3; // rbx
  size_t v4; // r12

  v2 = (__int64 (**)(void))(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) )
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), 44);
  sub_2EC20(v2);
  v3 = (char *)sub_33660(a2);
  v4 = strlen(v3);
  sub_2EC20(v2);
  sub_BD070(v3, v4);
  sub_2F4D0(v3);
}

__int64 __fastcall sub_727A0(__int64 a1, __int64 a2)
{
  void **v2; // rax
  _QWORD *v3; // rsi
  __int64 *v4; // rbx
  __int64 result; // rax

  v2 = (void **)sub_BC640();
  v3 = *(_QWORD **)(a1 - 40);
  v4 = (__int64 *)v2;
  if ( v3 )
  {
    sub_72730((__int64)v2, v3);
    sub_72730((__int64)v4, *(_QWORD **)(a1 - 32));
    sub_72730((__int64)v4, *(_QWORD **)(a1 - 24));
    sub_72730((__int64)v4, *(_QWORD **)(a1 - 16));
    result = sub_BC6B0(v4);
  }
  else
  {
    sub_BC660(v2);
    result = 0LL;
  }
  return result;
}

void __fastcall sub_72810(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi
  _QWORD *v5; // rdi
  _QWORD *v6; // rdi
  _QWORD *v7; // rdi

  v1 = (void *)(a1 - 40);
  v2 = a1;
  v3 = *(_QWORD **)(a1 - 40);
  if ( v3 )
    sub_330F0(v3);
  v4 = *(_QWORD **)(v2 - 32);
  if ( v4 )
    sub_330F0(v4);
  v5 = *(_QWORD **)(v2 - 24);
  if ( v5 )
    sub_330F0(v5);
  v6 = *(_QWORD **)(v2 - 16);
  if ( v6 )
    sub_330F0(v6);
  v7 = *(_QWORD **)(v2 - 8);
  if ( v7 )
    sub_330F0(v7);
  sub_2F4D0(v1);
}

unsigned __int64 __fastcall sub_72880(__int64 a1, __int64 a2)
{
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), "ssh-dss");
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 40));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 32));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 24));
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 16));
}

__int64 __fastcall sub_728E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  unsigned __int64 *v6; // rbx
  char *v7; // r14
  size_t v8; // rdx
  size_t v9; // rbp
  char *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r15
  signed __int64 *v14; // rbp
  signed __int64 *v15; // r15
  int v16; // er14
  int v17; // er14
  int v18; // er14
  unsigned __int64 *v19; // r14
  unsigned __int64 *v20; // ST28_8
  unsigned __int64 *v21; // rbx
  unsigned __int64 *v22; // r13
  unsigned __int64 *v23; // ST00_8
  unsigned __int64 *v24; // ST08_8
  unsigned __int64 *v25; // ST20_8
  unsigned __int64 *v26; // ST18_8
  unsigned __int64 *v27; // ST10_8
  __int64 v28; // [rsp+0h] [rbp-B8h]
  __int64 v29; // [rsp+30h] [rbp-88h]
  __int64 v30; // [rsp+38h] [rbp-80h]
  __int64 v31; // [rsp+40h] [rbp-78h]
  int v32; // [rsp+48h] [rbp-70h]
  __int64 *v33; // [rsp+50h] [rbp-68h]
  char v34; // [rsp+60h] [rbp-58h]
  unsigned __int64 v35; // [rsp+78h] [rbp-40h]

  v35 = __readfsqword(0x28u);
  v28 = a5;
  if ( !*(_QWORD *)(a1 - 40) )
    goto LABEL_4;
  v5 = a4;
  v6 = (unsigned __int64 *)a2;
  v29 = a2;
  v31 = a3;
  v30 = 0LL;
  v32 = 0;
  v33 = &v29;
  if ( a3 != 40 )
  {
    v7 = sub_2F1D0((__int64)&v29);
    v9 = v8;
    v10 = sub_2F1D0((__int64)v33);
    v12 = v11;
    if ( *((_DWORD *)v33 + 6)
      || (v6 = (unsigned __int64 *)v10, (unsigned __int8)sub_BD100(v7, v9, "ssh-dss") != 1)
      || v12 != 40 )
    {
LABEL_4:
      LODWORD(v6) = 0;
      return (unsigned int)v6;
    }
  }
  v14 = sub_33390((__int64)v6, 20LL);
  v15 = sub_33390((__int64)v6 + 20, 20LL);
  LOBYTE(v6) = v15 == 0LL || v14 == 0LL;
  if ( (_BYTE)v6 )
  {
    if ( v14 )
      sub_330F0(v14);
    if ( v15 )
      sub_330F0(v15);
    goto LABEL_4;
  }
  v16 = sub_341A0(v14, 0LL);
  v17 = sub_341A0(v15, 0LL) | v16;
  v18 = (unsigned __int64)sub_33E30((unsigned __int64 *)v14, *(unsigned __int64 **)(a1 - 32)) | v17;
  if ( !((unsigned int)sub_33E30((unsigned __int64 *)v15, *(unsigned __int64 **)(a1 - 32)) | v18) )
  {
    v19 = sub_355D0((unsigned __int64 *)v15, *(__int64 **)(a1 - 32));
    if ( v19 )
    {
      sub_5E520((__int64 (**)(void))&off_3215A0, v5, v28, (__int64)&v34);
      v20 = sub_33390((__int64)&v34, 20LL);
      v21 = sub_362D0(v20, v19, *(__int64 **)(a1 - 32));
      v22 = sub_362D0((unsigned __int64 *)v14, v19, *(__int64 **)(a1 - 32));
      v23 = v21;
      v6 = sub_364B0(*(unsigned __int64 **)(a1 - 24), v21, *(_QWORD *)(a1 - 40));
      v24 = v6;
      v25 = sub_364B0(*(unsigned __int64 **)(a1 - 16), v22, *(_QWORD *)(a1 - 40));
      v26 = sub_362D0(v6, v25, *(__int64 **)(a1 - 40));
      v27 = sub_35FB0(v26, *(__int64 **)(a1 - 32));
      LOBYTE(v6) = (unsigned int)sub_34130(v27, (unsigned __int64 *)v14) != 0;
      sub_330F0(v19);
      sub_330F0(v20);
      sub_330F0(v23);
      sub_330F0(v22);
      sub_330F0(v24);
      sub_330F0(v25);
      sub_330F0(v26);
      sub_330F0(v27);
    }
  }
  sub_330F0(v14);
  sub_330F0(v15);
  return (unsigned int)v6;
}

signed __int64 **__fastcall sub_72BA0(__int64 a1, __int64 a2)
{
  signed __int64 **v2; // rax
  __int64 v3; // rdi
  signed __int64 **v4; // rbx
  signed __int64 *v5; // rax
  __int64 v6; // rdi
  signed __int64 *v7; // rax
  __int64 v8; // rdi
  signed __int64 *v9; // rax
  __int64 v10; // rdi
  signed __int64 *v11; // rax
  __int64 v12; // rdi
  __int64 v13; // rbp

  v2 = (signed __int64 **)sub_2F450(1uLL, 0x30uLL, 0LL);
  v3 = *(_QWORD *)(a2 + 32);
  v4 = v2;
  v2[5] = (signed __int64 *)off_320680;
  v5 = sub_33840(v3);
  v6 = *(_QWORD *)(a2 + 32);
  *v4 = v5;
  v7 = sub_33840(v6);
  v8 = *(_QWORD *)(a2 + 32);
  v4[1] = v7;
  v9 = sub_33840(v8);
  v10 = *(_QWORD *)(a2 + 32);
  v4[2] = v9;
  v11 = sub_33840(v10);
  v12 = *(_QWORD *)(a2 + 32);
  v4[3] = v11;
  v4[4] = sub_33840(v12);
  v13 = (__int64)(v4 + 5);
  if ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 24LL) )
  {
    v13 = (__int64)(v4 + 5);
    if ( !(unsigned int)sub_341A0(v4[1], 0LL) && !(unsigned int)sub_341A0(*v4, 0LL) )
      return v4 + 5;
  }
  sub_72810(v13);
  return 0LL;
}

signed __int64 __fastcall sub_72C60(__int64 a1, __int64 a2, __int64 a3)
{
  char *v3; // rax
  size_t v4; // rdx
  signed __int64 **v5; // rax
  __int64 v6; // rdi
  signed __int64 **v7; // rbx
  signed __int64 v8; // rbp
  signed __int64 *v9; // rax
  __int64 v10; // rdi
  signed __int64 *v11; // rax
  __int64 v12; // rdi
  signed __int64 *v13; // rax
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v17; // rdi
  __int64 v18; // [rsp+0h] [rbp-48h]
  __int64 v19; // [rsp+8h] [rbp-40h]
  __int64 v20; // [rsp+10h] [rbp-38h]
  int v21; // [rsp+18h] [rbp-30h]
  __int64 *v22; // [rsp+20h] [rbp-28h]
  unsigned __int64 v23; // [rsp+28h] [rbp-20h]

  v18 = a2;
  v20 = a3;
  v23 = __readfsqword(0x28u);
  v22 = &v18;
  v19 = 0LL;
  v21 = 0;
  v3 = sub_2F1D0((__int64)&v18);
  if ( !(unsigned __int8)sub_BD100(v3, v4, "ssh-dss") )
    return 0LL;
  v5 = (signed __int64 **)sub_2F450(1uLL, 0x30uLL, 0LL);
  v6 = (__int64)v22;
  v7 = v5;
  v8 = (signed __int64)(v5 + 5);
  v5[5] = (signed __int64 *)off_320680;
  v9 = sub_33840(v6);
  v10 = (__int64)v22;
  *v7 = v9;
  v11 = sub_33840(v10);
  v12 = (__int64)v22;
  v7[1] = v11;
  v13 = sub_33840(v12);
  v14 = (__int64)v22;
  v7[2] = v13;
  v7[3] = sub_33840(v14);
  v15 = (__int64)v22;
  v7[4] = 0LL;
  if ( *(_DWORD *)(v15 + 24)
    || (v8 = (signed __int64)(v7 + 5), (unsigned int)sub_341A0(*v7, 0LL))
    || (unsigned int)sub_341A0(v7[1], 0LL) )
  {
    v17 = v8;
    v8 = 0LL;
    sub_72810(v17);
  }
  return v8;
}

__int64 __fastcall sub_72D80(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 v3; // rax
  __int64 v4; // rbx
  unsigned int v5; // ebp

  v3 = sub_72C60(a1, a2, a3);
  if ( v3 )
  {
    v4 = v3;
    v5 = sub_335B0(*(__int64 **)(v3 - 40));
    sub_72810(v4);
  }
  else
  {
    v5 = -1;
  }
  return v5;
}

signed __int64 __fastcall sub_72DC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12
  __int64 v6; // rbp
  signed __int64 v7; // rax
  __int64 v8; // rbx
  signed __int64 v9; // r12
  _QWORD *v10; // rax
  __int64 v11; // rdi
  char *v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 *v15; // rbp
  unsigned __int64 *v16; // rdi
  __int64 v18; // [rsp+0h] [rbp-78h]
  __int64 v19; // [rsp+8h] [rbp-70h]
  __int64 v20; // [rsp+10h] [rbp-68h]
  int v21; // [rsp+18h] [rbp-60h]
  __int64 *v22; // [rsp+20h] [rbp-58h]
  char v23; // [rsp+30h] [rbp-48h]
  unsigned __int64 v24; // [rsp+48h] [rbp-30h]

  v5 = a4;
  v6 = a5;
  v24 = __readfsqword(0x28u);
  v7 = sub_72C60(a1, a2, a3);
  if ( !v7 )
    return 0LL;
  v8 = v7;
  v18 = v5;
  v22 = &v18;
  v20 = v6;
  v9 = v7;
  v19 = 0LL;
  v21 = 0;
  v10 = sub_33840((__int64)&v18);
  v11 = (__int64)v22;
  *(_QWORD *)(v8 - 8) = v10;
  if ( *(_DWORD *)(v11 + 24) )
  {
    v9 = 0LL;
    sub_72810(v8);
    return v9;
  }
  v12 = sub_2F1D0(v11);
  if ( v13 == 20 )
  {
    v14 = sub_7F880();
    v15 = (__int64 *)v14;
    if ( v14 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 8LL))(v14);
    sub_33730(v15[1], *(__int64 **)(v8 - 40));
    sub_33730(v15[1], *(__int64 **)(v8 - 32));
    sub_33730(v15[1], *(__int64 **)(v8 - 24));
    (*(void (__fastcall **)(__int64 *, char *))(*v15 + 24))(v15, &v23);
    (*(void (__fastcall **)(__int64 *))(*v15 + 32))(v15);
    if ( !(unsigned __int8)sub_BD090((__int64)v12, (__int64)&v23, 20LL) )
      goto LABEL_11;
  }
  v16 = sub_364B0(*(unsigned __int64 **)(v8 - 24), *(unsigned __int64 **)(v8 - 8), *(_QWORD *)(v8 - 40));
  if ( !(unsigned int)sub_34130(v16, *(unsigned __int64 **)(v8 - 16)) )
  {
    sub_330F0(v16);
LABEL_11:
    v9 = 0LL;
    sub_72810(v8);
    return v9;
  }
  sub_330F0(v16);
  return v9;
}

_QWORD *__fastcall sub_72F40(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rdx

  v1 = sub_7BC90();
  sub_7BCD0((__int64)v1, "key_type", "DSA");
  v2 = *(_QWORD *)(a1 - 40);
  if ( !v2 )
    __assert_fail("dss->p", "sshdss.c", 0x5Eu, "dss_components");
  sub_7BD50((__int64)v1, "p", v2);
  sub_7BD50((__int64)v1, "q", *(_QWORD *)(a1 - 32));
  sub_7BD50((__int64)v1, "g", *(_QWORD *)(a1 - 24));
  sub_7BD50((__int64)v1, "public_y", *(_QWORD *)(a1 - 16));
  v3 = *(_QWORD *)(a1 - 8);
  if ( v3 )
    sub_7BD50((__int64)v1, "private_x", v3);
  return v1;
}

__int64 *__fastcall sub_73000(const char *a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbp
  __int64 v4; // rax
  __int64 *v5; // rbx
  __int64 *v6; // rbx
  unsigned __int64 *v7; // r13
  __int64 *v8; // r12
  __int64 v10; // [rsp+0h] [rbp-88h]
  unsigned __int64 v11; // [rsp+48h] [rbp-40h]

  v3 = a3;
  v11 = __readfsqword(0x28u);
  v4 = sub_7EDE0((__int64)off_321460);
  v5 = (__int64 *)v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
  sub_2EF90((__int64 (__fastcall **)(_QWORD, const char *, size_t))v5[1], a1);
  sub_33730(v5[1], v3);
  (*(void (__fastcall **)(__int64 *, __int64 *))(*v5 + 24))(v5, &v10);
  (*(void (__fastcall **)(__int64 *))(*v5 + 8))(v5);
  sub_2EC20((__int64 (**)(void))v5[1]);
  sub_2EC20((__int64 (**)(void))v5[1]);
  (*(void (__fastcall **)(__int64 *, __int64 *))(*v5 + 24))(v5, &v10);
  (*(void (__fastcall **)(__int64 *))(*v5 + 32))(v5);
  v6 = sub_334C0(a2);
  sub_33B10(v6, (unsigned __int64 *)v6, 2LL);
  v7 = sub_33390((__int64)&v10, 64LL);
  v8 = (__int64 *)sub_35FB0(v7, v6);
  sub_330F0(v7);
  sub_330F0(v6);
  sub_33A80(v8, (unsigned __int64 *)v8, 2uLL);
  sub_BD070(&v10, 0x40uLL);
  return v8;
}

unsigned __int64 __fastcall sub_73140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // rbp
  __int64 *v7; // rbx
  unsigned __int64 *v8; // r15
  unsigned __int64 *v9; // ST00_8
  unsigned __int64 *v10; // r12
  unsigned __int64 *v11; // r14
  unsigned __int64 *v12; // ST08_8
  unsigned __int64 *v13; // ST00_8
  unsigned __int64 *v14; // r13
  __int64 *v15; // rdi
  signed __int64 v16; // rbx
  unsigned __int64 v17; // rsi
  char v18; // al
  signed __int64 v19; // rbx
  unsigned __int64 v20; // rsi
  char v21; // al
  char v23; // [rsp+10h] [rbp-58h]
  unsigned __int64 v24; // [rsp+28h] [rbp-40h]

  v5 = a1;
  v6 = a5;
  v24 = __readfsqword(0x28u);
  sub_5E520((__int64 (**)(void))&off_3215A0, a2, a3, (__int64)&v23);
  v7 = sub_73000("DSA deterministic k generator", *(_QWORD *)(v5 - 32), *(__int64 **)(v5 - 8));
  v8 = sub_355D0((unsigned __int64 *)v7, *(__int64 **)(a1 - 32));
  v9 = sub_364B0(*(unsigned __int64 **)(v5 - 24), (unsigned __int64 *)v7, *(_QWORD *)(v5 - 40));
  v10 = sub_35FB0(v9, *(__int64 **)(a1 - 32));
  sub_330F0(v9);
  v11 = sub_33390((__int64)&v23, 20LL);
  v12 = sub_342F0(*(unsigned __int64 **)(a1 - 8), v10);
  v13 = (unsigned __int64 *)sub_341F0(v12, v11);
  v14 = sub_362D0(v8, v13, *(__int64 **)(a1 - 32));
  sub_330F0(v13);
  sub_330F0(v12);
  sub_330F0(v8);
  v15 = v7;
  v16 = 19LL;
  sub_330F0(v15);
  sub_330F0(v11);
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), "ssh-dss");
  sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(v6 + 8), 40);
  do
  {
    v17 = v16--;
    v18 = sub_334D0(v10, v17);
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), v18);
  }
  while ( v16 != -1 );
  v19 = 19LL;
  do
  {
    v20 = v19--;
    v21 = sub_334D0(v14, v20);
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), v21);
  }
  while ( v19 != -1 );
  sub_330F0(v10);
  sub_330F0(v14);
  return __readfsqword(0x28u) ^ v24;
}

__int64 sub_73300()
{
  return 0LL;
}

__int64 __fastcall sub_73310(__int64 a1)
{
  return *(_QWORD *)((**(__int64 (***)(void))(a1 + 120))() + 24);
}

unsigned __int64 __fastcall sub_73330(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  __int64 *v4; // r12
  __int64 v5; // rbp
  signed __int64 v6; // rax
  unsigned __int64 result; // rax

  v4 = (__int64 *)a3;
  *(_DWORD *)a1 = a2;
  v5 = a4;
  *(_QWORD *)(a1 + 40) = sub_334C0(a3);
  v6 = sub_335B0(v4);
  *(_QWORD *)(a1 + 24) = v6;
  result = (unsigned __int64)(v6 + v5 + 7) >> 3;
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

_QWORD *__fastcall sub_73370(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  _QWORD *v4; // [rsp+8h] [rbp-30h]
  _QWORD *v5; // [rsp+10h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v1 = sub_7BC90();
  sub_7BCD0((__int64)v1, "key_type", "EdDSA");
  sub_7BCD0((__int64)v1, "curve_name", *(char **)(*(_QWORD *)(a1 - 24) + 16LL));
  sub_2BB90(*(_QWORD **)(a1 - 16), (__int64 *)&v4, (__int64 *)&v5);
  sub_7BD50((__int64)v1, "public_affine_x", (__int64)v4);
  sub_7BD50((__int64)v1, "public_affine_y", (__int64)v5);
  sub_330F0(v4);
  sub_330F0(v5);
  v2 = *(_QWORD *)(a1 - 8);
  if ( v2 )
    sub_7BD50((__int64)v1, "private_exponent", v2);
  return v1;
}

__int64 __fastcall sub_73450(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // r13
  __int64 v4; // rax
  __int64 *v5; // rbx
  void *v6; // r12
  void *v7; // rbp

  v3 = a3;
  v4 = sub_BC640();
  v5 = (__int64 *)v4;
  if ( a1 )
    sub_BC720(v4, (__int64)"%s,", a1);
  v6 = (void *)sub_33660(a2);
  v7 = (void *)sub_33660(v3);
  sub_BC720((__int64)v5, (__int64)"0x%s,0x%s", v6, v7);
  sub_2F4D0(v6);
  sub_2F4D0(v7);
  return sub_BC6B0(v5);
}

void __fastcall sub_734E0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // [rsp+8h] [rbp-20h]
  _QWORD *v4; // [rsp+10h] [rbp-18h]
  unsigned __int64 v5; // [rsp+18h] [rbp-10h]

  v1 = a1;
  v2 = *(_QWORD **)(a1 - 16);
  v5 = __readfsqword(0x28u);
  sub_2BB90(v2, (__int64 *)&v3, (__int64 *)&v4);
  sub_73450(*(_QWORD *)(*(_QWORD *)(v1 - 24) + 8LL), v3, v4);
  sub_330F0(v3);
  sub_330F0(v4);
  __readfsqword(0x28u);
}

unsigned __int64 __fastcall sub_73560(__int64 a1, _QWORD *a2, __int64 a3, char a4)
{
  __int64 v4; // r12
  char v5; // bl
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  char v9; // al
  unsigned __int64 v10; // rsi
  char v11; // bl
  char v12; // al
  unsigned __int64 *v14; // [rsp+8h] [rbp-30h]
  unsigned __int64 *v15; // [rsp+10h] [rbp-28h]
  unsigned __int64 v16; // [rsp+18h] [rbp-20h]

  v4 = a3;
  v5 = a4;
  v16 = __readfsqword(0x28u);
  sub_2BB90(a2, (__int64 *)&v14, (__int64 *)&v15);
  v6 = *(_QWORD *)(v4 + 32);
  if ( v6 <= 1 )
    __assert_fail("curve->fieldBytes >= 2", aSsh_1, 0x246u, "BinarySink_put_epoint");
  if ( v5
    || (sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), v6),
        v10 = 0LL,
        *(_QWORD *)(v4 + 32) != 1LL) )
  {
    v7 = 0LL;
    do
    {
      v8 = v7++;
      v9 = sub_334D0(v15, v8);
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8), v9);
      v10 = *(_QWORD *)(v4 + 32) - 1LL;
    }
    while ( v10 > v7 );
  }
  v11 = sub_334D0(v15, v10) & 0x7F;
  v12 = sub_33500(v14, 0LL);
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 + 8), (v12 << 7) | v11);
  sub_330F0(v14);
  sub_330F0(v15);
  return __readfsqword(0x28u) ^ v16;
}

unsigned __int64 __fastcall sub_73680(__int64 a1, __int64 a2)
{
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), *(char **)(*(_QWORD *)a1 + 104LL));
  return sub_73560(*(_QWORD *)(a2 + 8), *(_QWORD **)(a1 - 16), *(_QWORD *)(a1 - 24), 0);
}

void __fastcall sub_736C0(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi

  v1 = (void *)(a1 - 24);
  v2 = a1;
  v3 = *(_QWORD **)(a1 - 16);
  if ( v3 )
    sub_2B4B0(v3);
  v4 = *(_QWORD **)(v2 - 8);
  if ( v4 )
    sub_330F0(v4);
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_73700(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // rbx
  unsigned __int64 *v4; // rbp
  unsigned __int8 v5; // r12
  _QWORD *v6; // rbx

  if ( *a3 != 2 )
    __assert_fail("curve->type == EC_EDWARDS", aSsh_1, 0x21Bu, "eddsa_decode");
  v3 = a3;
  v4 = sub_33380(a1, a2);
  v5 = sub_33500(v4, 8LL * *((_QWORD *)v3 + 4) - 1);
  sub_33550(v4, 8LL * *((_QWORD *)v3 + 4) - 1, 0);
  if ( (unsigned int)sub_33E30(v4, *((unsigned __int64 **)v3 + 5)) )
    v6 = 0LL;
  else
    v6 = sub_2B4F0(*((_QWORD **)v3 + 6), (__int64)v4, v5);
  sub_330F0(v4);
  return v6;
}

_QWORD *__fastcall sub_737B0(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rbx
  char *v4; // r13
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rbp
  char *v7; // rax
  __int64 v8; // rdx
  char *v9; // r15
  __int64 v10; // rdx
  char *v11; // rax
  size_t v12; // rdx
  _QWORD *v13; // rax
  _QWORD *v14; // r14
  _QWORD *v15; // rax
  __int64 v17; // [rsp+8h] [rbp-70h]
  char *v18; // [rsp+10h] [rbp-68h]
  __int64 v19; // [rsp+18h] [rbp-60h]
  __int64 v20; // [rsp+20h] [rbp-58h]
  int v21; // [rsp+28h] [rbp-50h]
  __int64 *v22; // [rsp+30h] [rbp-48h]
  unsigned __int64 v23; // [rsp+38h] [rbp-40h]

  v23 = __readfsqword(0x28u);
  v2 = (_DWORD *)(**(__int64 (***)(void))(a1 + 120))();
  if ( *v2 != 2 )
    __assert_fail("curve->type == EC_EDWARDS", aSsh_1, 0x349u, "eddsa_new_priv_openssh");
  v3 = v2;
  v4 = sub_2F1D0(*(_QWORD *)(a2 + 32));
  v6 = v5;
  v7 = sub_2F1D0(*(_QWORD *)(a2 + 32));
  if ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 24LL) && v6 == *((_QWORD *)v3 + 4) )
  {
    v18 = v7;
    v20 = v8;
    v19 = 0LL;
    v22 = (__int64 *)&v18;
    v21 = 0;
    v9 = sub_2F040((__int64)&v18, v6);
    v17 = v10;
    v11 = sub_2F040((__int64)v22, *((_QWORD *)v3 + 4));
    if ( !*((_DWORD *)v22 + 6) && v22[2] == v22[1] && sub_BD140(v4, v6, v11, v12) )
    {
      v13 = sub_2F450(1uLL, 0x20uLL, 0LL);
      v13[3] = a1;
      *v13 = v3;
      v13[2] = 0LL;
      v14 = v13;
      v15 = sub_73700((__int64)v4, v6, v3);
      v14[1] = v15;
      if ( v15 )
      {
        v14[2] = sub_33380((__int64)v9, v17);
        return v14 + 3;
      }
      sub_736C0((__int64)(v14 + 3));
    }
  }
  return 0LL;
}

_QWORD *__fastcall sub_73940(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // r15
  __int64 v9; // r13
  __int64 v10; // r14
  __int64 v11; // r12
  _QWORD *v12; // rax
  _QWORD *result; // rax

  v8 = a5;
  v9 = a3;
  v10 = a4;
  v11 = a6;
  sub_73330((__int64)a1, 0, a2, 0);
  v12 = sub_29780(a2, v9, v10, v8);
  a1[6] = v12;
  a1[7] = sub_29860((__int64)v12, v11, a7);
  result = sub_334C0(a8);
  a1[8] = result;
  return result;
}

_QWORD *__fastcall sub_739C0(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  _QWORD *v4; // [rsp+8h] [rbp-30h]
  _QWORD *v5; // [rsp+10h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v1 = sub_7BC90();
  sub_7BCD0((__int64)v1, "key_type", "ECDSA");
  sub_7BCD0((__int64)v1, "curve_name", *(char **)(*(_QWORD *)(a1 - 24) + 16LL));
  sub_2A860(*(_QWORD **)(a1 - 16), (__int64 *)&v4, (__int64 *)&v5);
  sub_7BD50((__int64)v1, "public_affine_x", (__int64)v4);
  sub_7BD50((__int64)v1, "public_affine_y", (__int64)v5);
  sub_330F0(v4);
  sub_330F0(v5);
  v2 = *(_QWORD *)(a1 - 8);
  if ( v2 )
    sub_7BD50((__int64)v1, "private_exponent", v2);
  return v1;
}

void __fastcall sub_73AA0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // [rsp+8h] [rbp-20h]
  _QWORD *v4; // [rsp+10h] [rbp-18h]
  unsigned __int64 v5; // [rsp+18h] [rbp-10h]

  v1 = a1;
  v2 = *(_QWORD **)(a1 - 16);
  v5 = __readfsqword(0x28u);
  sub_2A860(v2, (__int64 *)&v3, (__int64 *)&v4);
  sub_73450(*(_QWORD *)(*(_QWORD *)(v1 - 24) + 8LL), v3, v4);
  sub_330F0(v3);
  sub_330F0(v4);
  __readfsqword(0x28u);
}

unsigned __int64 __usercall sub_73B20@<rax>(__int64 a1@<rdx>, char a2@<cl>, signed __int64 a3@<rdi>, _QWORD *a4@<rsi>, __int64 a5@<r14>)
{
  __int64 v5; // r15
  char v6; // r12
  signed __int64 v7; // rbp
  __int64 v9; // rax
  signed __int64 v10; // rbx
  unsigned __int64 v11; // rsi
  char v12; // al
  __int64 v13; // rax
  signed __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  char v16; // al
  unsigned __int64 *v17; // [rsp+8h] [rbp-50h]
  unsigned __int64 *v18; // [rsp+10h] [rbp-48h]
  unsigned __int64 v19; // [rsp+18h] [rbp-40h]

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v19 = __readfsqword(0x28u);
  if ( !a2 )
  {
    a5 = sub_BC640();
    v7 = a5 + 24;
  }
  if ( (unsigned int)sub_2A850((__int64)a4) )
  {
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), 0);
  }
  else
  {
    sub_2A860(a4, (__int64 *)&v17, (__int64 *)&v18);
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), 4);
    v9 = *(_QWORD *)(v5 + 32);
    v10 = v9 - 1;
    if ( v9 )
    {
      do
      {
        v11 = v10--;
        v12 = sub_334D0(v17, v11);
        sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), v12);
      }
      while ( v10 != -1 );
      v13 = *(_QWORD *)(v5 + 32);
      v14 = v13 - 1;
      if ( v13 )
      {
        do
        {
          v15 = v14--;
          v16 = sub_334D0(v18, v15);
          sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), v16);
        }
        while ( v14 != -1 );
      }
    }
    sub_330F0(v17);
    sub_330F0(v18);
  }
  if ( !v6 )
    sub_2EF70(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a3 + 8), a5);
  return __readfsqword(0x28u) ^ v19;
}

unsigned __int64 __usercall sub_73C60@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>)
{
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), *(char **)(*(_QWORD *)(a1 - 24) + 8LL));
  sub_73B20(*(_QWORD *)(a1 - 24), 0, *(_QWORD *)(a2 + 8), *(_QWORD **)(a1 - 16), a3);
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 8));
}

unsigned __int64 __usercall sub_73CB0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>)
{
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), *(char **)(*(_QWORD *)a1 + 104LL));
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), *(char **)(*(_QWORD *)(a1 - 24) + 8LL));
  return sub_73B20(*(_QWORD *)(a1 - 24), 0, *(_QWORD *)(a2 + 8), *(_QWORD **)(a1 - 16), a3);
}

unsigned __int64 __usercall sub_73D00@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r14>)
{
  return sub_73B20(*(_QWORD *)(a1 + 8), 1, *(_QWORD *)(a2 + 8), *(_QWORD **)(a1 + 24), a3);
}

void __fastcall sub_73D20(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi

  v1 = (void *)(a1 - 24);
  v2 = a1;
  v3 = *(_QWORD **)(a1 - 16);
  if ( v3 )
    sub_299D0(v3);
  v4 = *(_QWORD **)(v2 - 8);
  if ( v4 )
    sub_330F0(v4);
  sub_2F4D0(v1);
}

void __fastcall sub_73D60(__int64 a1)
{
  sub_299D0(*(_QWORD **)(a1 + 24));
}

void __fastcall sub_73D70(__int64 a1)
{
  sub_2ACD0(*(_QWORD **)(a1 + 24));
}

unsigned __int64 *__fastcall sub_73D80(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // rbx
  __int64 *v4; // r12
  __int64 **v5; // rbx
  signed __int64 v6; // r13
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  char v9; // al
  unsigned __int64 *result; // rax
  unsigned __int64 *v11; // [rsp+0h] [rbp-38h]
  unsigned __int64 v12; // [rsp+8h] [rbp-30h]

  v12 = __readfsqword(0x28u);
  v3 = sub_33380(a2, a3);
  sub_34C70(v3, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL));
  v4 = (__int64 *)sub_2ABE0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 48LL), (__int64)v3);
  sub_330F0(v3);
  v5 = sub_2B0B0(v4, *(_QWORD *)(a1 + 16));
  if ( (unsigned int)sub_2B2B0((__int64)v5) )
  {
    sub_2ACD0(v4);
    sub_2ACD0(v5);
    result = 0LL;
  }
  else
  {
    sub_2B230(v5, (__int64 *)&v11);
    sub_2ACD0(v4);
    sub_2ACD0(v5);
    v6 = sub_BC640();
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL) )
    {
      v7 = 0LL;
      do
      {
        v8 = v7++;
        v9 = sub_334D0(v11, v8);
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v6 + 24), v9);
      }
      while ( *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL) > v7 );
    }
    sub_330F0(v11);
    v11 = sub_33390(*(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16));
    sub_BC660((void **)v6);
    result = v11;
  }
  return result;
}

unsigned __int64 __fastcall sub_73EC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // r12
  _QWORD *v4; // rdi
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rsi
  char v7; // al
  unsigned __int64 *v9; // [rsp+0h] [rbp-28h]
  unsigned __int64 v10; // [rsp+8h] [rbp-20h]

  v2 = a1;
  v3 = a2;
  v4 = *(_QWORD **)(a1 + 24);
  v10 = __readfsqword(0x28u);
  sub_2B230(v4, (__int64 *)&v9);
  if ( *(_QWORD *)(*(_QWORD *)(v2 + 8) + 32LL) )
  {
    v5 = 0LL;
    do
    {
      v6 = v5++;
      v7 = sub_334D0(v9, v6);
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v3 + 8), v7);
    }
    while ( *(_QWORD *)(*(_QWORD *)(v2 + 8) + 32LL) > v5 );
  }
  sub_330F0(v9);
  return __readfsqword(0x28u) ^ v10;
}

__int64 **__fastcall sub_73F50(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r12
  unsigned __int64 v4; // rbx
  char *v5; // rax
  unsigned __int64 *v6; // rax
  __int64 v7; // rdx
  unsigned int v8; // ebx
  unsigned __int64 v9; // rsi
  __int64 **result; // rax

  v2 = sub_BC650();
  v3 = v2;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
  v5 = sub_BC510(v2, v4);
  sub_7BF50(v5, v4);
  v6 = sub_33380(*(_QWORD *)(v3 + 8), *(_QWORD *)(v3 + 16));
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = v6;
  sub_34C70(v6, *(_QWORD *)(v7 + 24));
  sub_33550(*(unsigned __int64 **)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL) - 1LL, 1);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 64LL) )
  {
    v8 = 0;
    do
    {
      v9 = v8++;
      sub_33550(*(unsigned __int64 **)(a1 + 16), v9, 0);
    }
    while ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 64LL) > v8 );
  }
  sub_BC660((void **)v3);
  result = sub_2B0B0(*(__int64 **)(*(_QWORD *)(a1 + 8) + 56LL), *(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

__int64 **__fastcall sub_74010(_QWORD *a1)
{
  unsigned __int64 *v1; // rbp
  __int64 **result; // rax

  v1 = sub_330A0(1LL);
  a1[2] = sub_36ED0(v1, *(unsigned __int64 **)(a1[1] + 64LL), (void (__fastcall *)(_BYTE *, unsigned __int64))sub_7BF50);
  sub_330F0(v1);
  result = sub_2A720(*(_QWORD **)(a1[1] + 56LL), a1[2]);
  a1[3] = result;
  return result;
}

unsigned __int64 *__fastcall sub_74070(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 *v4; // r12
  unsigned int v5; // ebx

  if ( *(_QWORD *)(a3 + 32) > a2 )
    __assert_fail("hash.len >= curve->fieldBytes", aSsh_1, 0x169u, "eddsa_exponent_from_hash");
  v3 = a3;
  v4 = sub_33380(a1, *(_QWORD *)(a3 + 32));
  sub_33550(v4, *(_QWORD *)(v3 + 24) - 1LL, 1);
  sub_34C70(v4, *(_QWORD *)(v3 + 24));
  if ( *(_DWORD *)(v3 + 72) )
  {
    v5 = 0;
    do
      sub_33550(v4, v5++, 0);
    while ( *(_DWORD *)(v3 + 72) > v5 );
  }
  return v4;
}

unsigned __int64 __fastcall sub_74100(__int64 (__fastcall ***a1)(_QWORD, char *, signed __int64), unsigned __int64 *a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 *v4; // r13
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rsi
  char v8; // al

  v3 = a3;
  v4 = a2;
  result = sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))*a1, a3);
  if ( v3 )
  {
    v6 = 0LL;
    do
    {
      v7 = v6++;
      v8 = sub_334D0(v4, v7);
      result = sub_2ECE0((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))*a1, v8);
    }
    while ( v3 != v6 );
  }
  return result;
}

void __fastcall sub_74160(__int64 a1, __int64 a2)
{
  signed __int64 v2; // r15
  unsigned __int64 v3; // rbp
  char *v4; // r14
  signed __int64 v5; // r13
  signed __int64 v6; // rbx
  signed __int64 v7; // ST08_8

  if ( **(_DWORD **)(a1 - 24) != 2 )
    __assert_fail(aEk, aSsh_1, 0x378u, "eddsa_openssh_blob");
  v2 = sub_BC640();
  sub_73560(v2 + 24, *(_QWORD **)(a1 - 16), *(_QWORD *)(a1 - 24), 0);
  v3 = *(_QWORD *)(v2 + 16) - 4LL;
  v4 = (char *)(*(_QWORD *)v2 + 4LL);
  v5 = sub_BC650();
  sub_74100(
    (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v5 + 32),
    *(unsigned __int64 **)(a1 - 8),
    *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL));
  v6 = *(_QWORD *)(v5 + 16) - 4LL;
  v7 = *(_QWORD *)v5 + 4LL;
  sub_2EF30(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), v4, v3);
  sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a2 + 8), v3 + v6);
  sub_2EC30(*(__int64 (***)(void))(a2 + 8));
  sub_2EC30(*(__int64 (***)(void))(a2 + 8));
  sub_BC660((void **)v2);
  sub_BC660((void **)v5);
}

unsigned __int64 __fastcall sub_74260(__int64 a1, __int64 a2)
{
  unsigned __int64 *v2; // rax

  v2 = *(unsigned __int64 **)(a1 - 8);
  if ( !v2 )
    __assert_fail("ek->privateKey", aSsh_1, 0x323u, "eddsa_private_blob");
  return sub_74100(
           (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(a2 + 8) + 8LL),
           v2,
           *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL));
}

_QWORD *__fastcall sub_742B0(__int64 *a1, _QWORD **a2, _QWORD *a3, __int64 *a4)
{
  _QWORD **v4; // r13
  __int64 *v5; // r12
  _QWORD *v6; // rbx
  __int64 v7; // rax
  __int64 (***v8)(void); // r15
  __int64 v9; // rsi
  __int64 v10; // rdx
  _QWORD *v11; // r12
  char v13; // [rsp+20h] [rbp-B8h]
  unsigned __int64 v14; // [rsp+98h] [rbp-40h]

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v14 = __readfsqword(0x28u);
  v7 = (*(__int64 (__fastcall **)(_QWORD))*a3)(*a3);
  v8 = (__int64 (***)(void))v7;
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  v9 = *v5;
  v10 = v5[1];
  sub_2EC30(v8[1]);
  sub_2EC30(v8[1]);
  sub_73560((__int64)v8[1], *v4, *a1, 1);
  sub_2EC30(v8[1]);
  ((void (__fastcall *)(__int64 (***)(void), char *))(*v8)[3])(v8, &v13);
  ((void (__fastcall *)(__int64 (***)(void)))(*v8)[4])(v8);
  v11 = sub_33380((__int64)&v13, *(_QWORD *)(*v6 + 40LL));
  sub_BD070(&v13, *(_QWORD *)(*v6 + 40LL));
  return v11;
}

bool __fastcall sub_743D0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  void *v4; // rbp
  __int64 v5; // rbx
  char *v6; // rax
  size_t v7; // rdx
  char *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rax
  char *v12; // r12
  __int64 v13; // rdx
  __int64 v14; // rbp
  __int64 v15; // rdx
  char *v16; // rcx
  _QWORD *v17; // ST20_8
  _QWORD *v18; // rbx
  unsigned __int64 **v19; // rbp
  unsigned __int64 **v20; // r12
  __int64 *v21; // rbx
  _QWORD *v22; // [rsp+8h] [rbp-80h]
  __int64 v23; // [rsp+10h] [rbp-78h]
  __int64 v24; // [rsp+18h] [rbp-70h]
  __int64 v25; // [rsp+20h] [rbp-68h]
  __int64 v26; // [rsp+28h] [rbp-60h]
  __int64 v27; // [rsp+30h] [rbp-58h]
  int v28; // [rsp+38h] [rbp-50h]
  __int64 *v29; // [rsp+40h] [rbp-48h]
  unsigned __int64 v30; // [rsp+48h] [rbp-40h]

  v30 = __readfsqword(0x28u);
  v3 = *a1;
  v25 = a2;
  v27 = a3;
  v26 = 0LL;
  v28 = 0;
  v29 = &v25;
  v4 = *(void **)(v3 + 104);
  v5 = *(_QWORD *)(v3 + 120);
  v6 = sub_2F1D0((__int64)&v25);
  if ( !(unsigned __int8)sub_BD100(v6, v7, v4) )
    return 0;
  v9 = sub_2F1D0((__int64)v29);
  if ( *((_DWORD *)v29 + 6) )
    return 0;
  v25 = (__int64)v9;
  v11 = *(a1 - 3);
  v29 = &v25;
  v27 = v10;
  v26 = 0LL;
  v28 = 0;
  v12 = sub_2F040((__int64)&v25, *(_QWORD *)(v11 + 32));
  v14 = v13;
  v16 = sub_2F040((__int64)v29, *(_QWORD *)(*(a1 - 3) + 32LL));
  if ( *((_DWORD *)v29 + 6) )
    return 0;
  if ( v29[2] != v29[1] )
    return 0;
  v24 = v15;
  v23 = (__int64)v16;
  v22 = sub_73700((__int64)v12, v14, (_DWORD *)*(a1 - 3));
  if ( !v22 )
    return 0;
  v17 = sub_33380(v23, v24);
  v18 = sub_742B0(a1 - 3, (_QWORD **)a1 - 2, (_QWORD *)(v5 + 8), (__int64 *)(v5 + 32));
  v19 = sub_2B960(*(_QWORD **)(*(a1 - 3) + 56LL), (__int64)v17);
  sub_330F0(v17);
  v20 = sub_2B960((_QWORD *)*(a1 - 2), (__int64)v18);
  sub_330F0(v18);
  v21 = (__int64 *)sub_2B6C0((__int64)v22, v20);
  sub_2B4B0(v20);
  LODWORD(v20) = sub_2BA90(v19, v21);
  sub_2B4B0(v19);
  sub_2B4B0(v21);
  sub_2B4B0(v22);
  return (_DWORD)v20 != 0;
}

unsigned __int64 __fastcall sub_745F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 (__fastcall ***v8)(_QWORD, char *, signed __int64); // r15
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rsi
  char v11; // al
  __int64 v12; // rax
  __int64 (***v13)(void); // r15
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rdx
  unsigned __int64 *v17; // r15
  unsigned __int64 *v18; // r12
  unsigned __int64 **v19; // r13
  signed __int64 v20; // r15
  __int64 v21; // r8
  __int64 v22; // r9
  unsigned __int64 *v23; // ST10_8
  unsigned __int64 *v24; // rbx
  unsigned __int64 *v25; // r13
  __int64 v26; // rdx
  __int64 v27; // rsi
  unsigned __int64 v28; // rbx
  unsigned __int64 v29; // rsi
  char v30; // al
  unsigned __int64 *v32; // [rsp+10h] [rbp-C8h]
  char v33; // [rsp+20h] [rbp-B8h]
  unsigned __int64 v34; // [rsp+98h] [rbp-40h]

  v34 = __readfsqword(0x28u);
  v5 = *(_QWORD **)(*(_QWORD *)a1 + 120LL);
  if ( !*(_QWORD *)(a1 - 8) )
    __assert_fail("ek->privateKey", aSsh_1, 0x493u, "eddsa_sign");
  v6 = a5;
  v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64))v5[1])(v5[1], a2, a3, a4);
  v8 = (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))v7;
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  if ( *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL) )
  {
    v9 = 0LL;
    do
    {
      v10 = v9++;
      v11 = sub_334D0(*(unsigned __int64 **)(a1 - 8), v10);
      sub_2ECE0(v8[1], v11);
    }
    while ( *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL) > v9 );
  }
  ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64), char *))(*v8)[3])(v8, &v33);
  ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64)))(*v8)[4])(v8);
  v32 = sub_74070((__int64)&v33, *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL), *(_QWORD *)(a1 - 24));
  v12 = (*(__int64 (__fastcall **)(_QWORD))v5[1])(v5[1]);
  v13 = (__int64 (***)(void))v12;
  if ( v12 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 8LL))(v12);
  v14 = v5[4];
  v15 = v5[5];
  sub_2EC30(v13[1]);
  v16 = *(_QWORD *)(v5[1] + 40LL) - *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL);
  sub_2EC20(v13[1]);
  sub_2EC30(v13[1]);
  ((void (__fastcall *)(__int64 (***)(void), char *))(*v13)[3])(v13, &v33);
  ((void (__fastcall *)(__int64 (***)(void)))(*v13)[4])(v13);
  v17 = sub_33380((__int64)&v33, *(_QWORD *)(v5[1] + 40LL));
  v18 = sub_35FB0(v17, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v17);
  v19 = sub_2B960(*(_QWORD **)(*(_QWORD *)(a1 - 24) + 56LL), (__int64)v18);
  v20 = sub_BC640();
  sub_73560(v20 + 24, v19, *(_QWORD *)(a1 - 24), 1);
  sub_2B4B0(v19);
  v21 = *(_QWORD *)(v20 + 8);
  v22 = *(_QWORD *)(v20 + 16);
  v23 = sub_742B0((__int64 *)(a1 - 24), (_QWORD **)(a1 - 16), v5 + 1, v5 + 4);
  v24 = sub_362D0(v23, v32, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  v25 = sub_36590(v18, v24, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v23);
  sub_330F0(v32);
  sub_330F0(v24);
  sub_330F0(v18);
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), *(char **)(*(_QWORD *)a1 + 104LL));
  sub_2ED90(
    *(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(v6 + 8),
    *(_DWORD *)(*(_QWORD *)(a1 - 24) + 32LL) + *(_DWORD *)(v20 + 16));
  v26 = *(_QWORD *)(v20 + 16);
  v27 = *(_QWORD *)(v20 + 8);
  sub_2EC20(*(__int64 (***)(void))(v6 + 8));
  sub_BC660((void **)v20);
  if ( *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL) )
  {
    v28 = 0LL;
    do
    {
      v29 = v28++;
      v30 = sub_334D0(v25, v29);
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), v30);
    }
    while ( *(_QWORD *)(*(_QWORD *)(a1 - 24) + 32LL) > v28 );
  }
  sub_330F0(v25);
  return __readfsqword(0x28u) ^ v34;
}

signed __int64 __fastcall sub_748F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  _DWORD *v4; // rax
  _DWORD *v5; // rbp
  _QWORD *v6; // rax
  __int64 v7; // r12
  _QWORD *v8; // rbx
  char *v9; // rax
  __int64 v10; // rdx
  _QWORD *v11; // rax
  signed __int64 v12; // rbx
  signed __int64 result; // rax
  __int64 v14; // rdi
  __int64 v15; // [rsp+0h] [rbp-58h]
  __int64 v16; // [rsp+8h] [rbp-50h]
  __int64 v17; // [rsp+10h] [rbp-48h]
  int v18; // [rsp+18h] [rbp-40h]
  __int64 *v19; // [rsp+20h] [rbp-38h]
  unsigned __int64 v20; // [rsp+28h] [rbp-30h]

  v3 = a3;
  v20 = __readfsqword(0x28u);
  v4 = (_DWORD *)(**(__int64 (***)(void))(a1 + 120))();
  if ( *v4 != 2 )
LABEL_8:
    __assert_fail("curve->type == EC_EDWARDS", aSsh_1, 0x29Du, "eddsa_new_pub");
  v5 = v4;
  v17 = v3;
  v19 = &v15;
  v15 = a2;
  v16 = 0LL;
  v18 = 0;
  sub_2F1D0((__int64)&v15);
  v6 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v6[3] = a1;
  v7 = (__int64)v19;
  v8 = v6;
  *v6 = v5;
  v6[2] = 0LL;
  v9 = sub_2F1D0(*(_QWORD *)(v7 + 32));
  if ( *(_DWORD *)(*(_QWORD *)(v7 + 32) + 24LL) )
  {
    v8[1] = 0LL;
    v12 = (signed __int64)(v8 + 3);
  }
  else
  {
    v11 = sub_73700((__int64)v9, v10, v5);
    v12 = (signed __int64)(v8 + 3);
    *(_QWORD *)(v12 - 16) = v11;
    if ( v11 )
      goto LABEL_4;
  }
  v14 = v12;
  v12 = 0LL;
  sub_736C0(v14);
LABEL_4:
  result = v12;
  if ( __readfsqword(0x28u) != v20 )
    goto LABEL_8;
  return result;
}

signed __int64 __fastcall sub_74A10(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12
  __int64 v6; // rbp
  signed __int64 v7; // rbx
  char *v8; // rax
  __int64 v9; // rdx
  __int64 v11; // [rsp+0h] [rbp-48h]
  __int64 v12; // [rsp+8h] [rbp-40h]
  __int64 v13; // [rsp+10h] [rbp-38h]
  int v14; // [rsp+18h] [rbp-30h]
  __int64 *v15; // [rsp+20h] [rbp-28h]
  unsigned __int64 v16; // [rsp+28h] [rbp-20h]

  v5 = a4;
  v6 = a5;
  v16 = __readfsqword(0x28u);
  v7 = sub_748F0(a1, a2, a3);
  if ( v7 )
  {
    v11 = v5;
    v13 = v6;
    v15 = &v11;
    v12 = 0LL;
    v14 = 0;
    v8 = sub_2F1D0((__int64)&v11);
    *(_QWORD *)(v7 - 8) = sub_33380((__int64)v8, v9);
  }
  return v7;
}

unsigned __int64 __fastcall sub_74AA0(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax

  v2 = *(__int64 **)(a1 - 8);
  if ( !v2 )
    __assert_fail("ek->privateKey", aSsh_1, 0x31Au, "ecdsa_private_blob");
  return sub_33730(*(_QWORD *)(a2 + 8), v2);
}

unsigned __int64 *__fastcall sub_74AE0(__int64 **a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 (***v3)(void); // rbx
  __int64 *v4; // rbp
  signed __int64 v5; // rbx
  signed __int64 v6; // rax
  unsigned __int64 *v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-A8h]
  unsigned __int64 v10; // [rsp+78h] [rbp-30h]

  v10 = __readfsqword(0x28u);
  v2 = (*(__int64 (__fastcall **)(_QWORD))*a2)(*a2);
  v3 = (__int64 (***)(void))v2;
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
  sub_2EC30(v3[1]);
  ((void (__fastcall *)(__int64 (***)(void), __int64 *))(*v3)[3])(v3, &v9);
  ((void (__fastcall *)(__int64 (***)(void)))(*v3)[4])(v3);
  v4 = sub_33390((__int64)&v9, *(_QWORD *)(*a2 + 40LL));
  v5 = sub_335B0(v4);
  v6 = sub_335B0(*a1);
  v7 = sub_34BE0((__int64)v4, (v5 - v6) & ~((v5 - v6) >> 63));
  sub_330F0(v4);
  return v7;
}

bool __fastcall sub_74BC0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  void *v4; // r14
  __int64 v5; // rbp
  char *v6; // rax
  size_t v7; // rdx
  char *v9; // rax
  __int64 v10; // rdx
  signed __int64 *v11; // r14
  signed __int64 *v12; // r15
  int v13; // ST0C_4
  int v14; // ST0C_4
  int v15; // ST0C_4
  int v16; // ST0C_4
  unsigned __int64 *v17; // r12
  unsigned __int64 *v18; // rbp
  unsigned __int64 *v19; // r13
  unsigned __int64 *v20; // r12
  __int64 **v21; // rbp
  __int64 **v22; // r13
  __int64 **v23; // r12
  int v24; // ebx
  unsigned __int64 *v25; // [rsp+18h] [rbp-70h]
  __int64 v26; // [rsp+20h] [rbp-68h]
  __int64 v27; // [rsp+28h] [rbp-60h]
  __int64 v28; // [rsp+30h] [rbp-58h]
  int v29; // [rsp+38h] [rbp-50h]
  __int64 *v30; // [rsp+40h] [rbp-48h]
  unsigned __int64 v31; // [rsp+48h] [rbp-40h]

  v31 = __readfsqword(0x28u);
  v3 = *a1;
  v26 = a2;
  v28 = a3;
  v27 = 0LL;
  v29 = 0;
  v30 = &v26;
  v4 = *(void **)(v3 + 104);
  v5 = *(_QWORD *)(v3 + 120);
  v6 = sub_2F1D0((__int64)&v26);
  if ( !(unsigned __int8)sub_BD100(v6, v7, v4) )
    return 0;
  v9 = sub_2F1D0((__int64)v30);
  if ( *((_DWORD *)v30 + 6) )
    return 0;
  v28 = v10;
  v30 = &v26;
  v26 = (__int64)v9;
  v27 = 0LL;
  v29 = 0;
  v11 = sub_33840((__int64)&v26);
  v12 = sub_33840((__int64)v30);
  if ( *((_DWORD *)v30 + 6) )
  {
    sub_330F0(v11);
    sub_330F0(v12);
    return 0;
  }
  v13 = sub_341A0(v11, 0LL);
  v14 = v13 | sub_341A0(v12, 0LL);
  v15 = v14 | (unsigned __int64)sub_33E30((unsigned __int64 *)v11, *(unsigned __int64 **)(*(a1 - 3) + 64));
  v16 = v15 | (unsigned __int64)sub_33E30((unsigned __int64 *)v12, *(unsigned __int64 **)(*(a1 - 3) + 64));
  v17 = sub_74AE0((__int64 **)(*(a1 - 3) + 64), (_QWORD *)(v5 + 8));
  v18 = sub_355D0((unsigned __int64 *)v12, *(__int64 **)(*(a1 - 3) + 64));
  v19 = sub_362D0(v17, v18, *(__int64 **)(*(a1 - 3) + 64));
  sub_330F0(v17);
  v20 = sub_362D0((unsigned __int64 *)v11, v18, *(__int64 **)(*(a1 - 3) + 64));
  sub_330F0(v18);
  v21 = sub_2A720(*(_QWORD **)(*(a1 - 3) + 56), (__int64)v19);
  sub_330F0(v19);
  v22 = sub_2A720((_QWORD *)*(a1 - 2), (__int64)v20);
  sub_330F0(v20);
  v23 = sub_2A1D0(v21, v22);
  sub_299D0(v21);
  sub_299D0(v22);
  sub_2A860(v23, (__int64 *)&v25, 0LL);
  sub_299D0(v23);
  sub_35880(v25, *(__int64 **)(*(a1 - 3) + 64), 0LL, v25);
  v24 = v16 | sub_34130((unsigned __int64 *)v11, v25) ^ 1;
  sub_330F0(v25);
  sub_330F0(v11);
  sub_330F0(v12);
  return v24 == 0;
}

unsigned __int64 __fastcall sub_74E50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // r13
  unsigned __int64 *v8; // r14
  __int64 *v9; // r12
  __int64 **v10; // rbp
  unsigned __int64 *v11; // rbp
  unsigned __int64 *v12; // ST08_8
  unsigned __int64 *v13; // r15
  unsigned __int64 *v14; // r14
  __int64 *v15; // r12
  signed __int64 v16; // rax
  __int64 v17; // r14
  __int64 v18; // rbx
  unsigned __int64 *v20; // [rsp+18h] [rbp-60h]
  char v21; // [rsp+20h] [rbp-58h]
  unsigned __int64 v22; // [rsp+38h] [rbp-40h]

  v22 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 - 8) )
    __assert_fail("ek->privateKey", aSsh_1, 0x45Eu, "ecdsa_sign");
  v5 = a1;
  v6 = a3;
  v7 = a5;
  v8 = sub_74AE0((__int64 **)(*(_QWORD *)(a1 - 24) + 64LL), (_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 120LL) + 8LL));
  sub_5E520((__int64 (**)(void))&off_3215A0, a2, v6, (__int64)&v21);
  v9 = sub_73000("ECDSA deterministic k generator", *(_QWORD *)(*(_QWORD *)(v5 - 24) + 64LL), *(__int64 **)(v5 - 8));
  v10 = sub_2A720(*(_QWORD **)(*(_QWORD *)(a1 - 24) + 56LL), (__int64)v9);
  sub_2A860(v10, (__int64 *)&v20, 0LL);
  sub_299D0(v10);
  v11 = sub_35FB0(v20, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v20);
  v12 = sub_362D0(v11, *(unsigned __int64 **)(v5 - 8), *(__int64 **)(*(_QWORD *)(v5 - 24) + 64LL));
  v13 = sub_36590(v8, v12, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v8);
  sub_330F0(v12);
  v14 = sub_355D0((unsigned __int64 *)v9, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v9);
  v15 = (__int64 *)sub_362D0(v13, v14, *(__int64 **)(*(_QWORD *)(a1 - 24) + 64LL));
  sub_330F0(v13);
  sub_330F0(v14);
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), *(char **)(*(_QWORD *)a1 + 104LL));
  v16 = sub_BC640();
  v17 = v16 + 24;
  v18 = v16;
  sub_33730(v16 + 24, (__int64 *)v11);
  sub_33730(v17, v15);
  sub_2EF70(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v7 + 8), v18);
  sub_330F0(v11);
  sub_330F0(v15);
  return __readfsqword(0x28u) ^ v22;
}

_QWORD *__fastcall sub_75050(__int64 a1, __int64 a2, int a3, __int64 *a4)
{
  __int64 *v4; // rbp
  unsigned __int8 v5; // al
  unsigned __int8 v6; // bl
  unsigned __int64 v7; // rsi
  _QWORD *v8; // rbx
  _QWORD *result; // rax
  char *v10; // rax
  __int64 v11; // rdx
  _QWORD *v12; // r12
  char *v13; // rax
  __int64 v14; // rdx
  _QWORD *v15; // r12
  char *v16; // rax
  __int64 v17; // rdx
  _QWORD *v18; // r13
  _QWORD *v19; // rdi
  __int64 v20; // [rsp+0h] [rbp-58h]
  __int64 v21; // [rsp+8h] [rbp-50h]
  __int64 v22; // [rsp+10h] [rbp-48h]
  int v23; // [rsp+18h] [rbp-40h]
  __int64 *v24; // [rsp+20h] [rbp-38h]
  unsigned __int64 v25; // [rsp+28h] [rbp-30h]

  v25 = __readfsqword(0x28u);
  if ( a3 )
LABEL_15:
    __assert_fail("curve->type == EC_WEIERSTRASS", aSsh_1, 0x1AAu, "ecdsa_decode");
  v20 = a1;
  v22 = a2;
  v24 = &v20;
  v4 = a4;
  v21 = 0LL;
  v23 = 0;
  v5 = sub_2F080((__int64)&v20);
  v6 = v5;
  v7 = v24[2] - v24[1];
  if ( v5 > 3u )
  {
    if ( v5 != 4 || v7 & 1 )
      goto LABEL_11;
    v13 = sub_2F040((__int64)v24, v7 >> 1);
    v15 = sub_33390((__int64)v13, v14);
    v16 = sub_2F040((__int64)v24, v7 >> 1);
    v18 = sub_33390((__int64)v16, v17);
    v8 = sub_29860(*v4, (__int64)v15, (__int64)v18);
    sub_330F0(v15);
    sub_330F0(v18);
  }
  else
  {
    if ( v5 < 2u )
    {
      if ( !v5 )
      {
        v8 = sub_298A0((_QWORD *)*v4);
        goto LABEL_6;
      }
LABEL_11:
      v8 = 0LL;
      goto LABEL_8;
    }
    v10 = sub_2F040((__int64)v24, v7);
    v12 = sub_33390((__int64)v10, v11);
    v8 = sub_29A10((_QWORD *)*v4, (__int64)v12, v6 & 1);
    sub_330F0(v12);
    if ( !v8 )
      goto LABEL_11;
  }
LABEL_6:
  if ( !(unsigned int)sub_2A940(v8) )
  {
    v19 = v8;
    v8 = 0LL;
    sub_299D0(v19);
  }
LABEL_8:
  result = v8;
  if ( __readfsqword(0x28u) != v25 )
    goto LABEL_15;
  return result;
}

__int64 __fastcall sub_751F0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  __int64 **v5; // rbp
  __int64 result; // rax
  __int64 v7; // [rsp+0h] [rbp-28h]
  unsigned __int64 v8; // [rsp+8h] [rbp-20h]

  v8 = __readfsqword(0x28u);
  v3 = sub_75050(a2, a3, **(_DWORD **)(a1 + 8), (__int64 *)(*(_QWORD *)(a1 + 8) + 48LL));
  if ( !v3 )
    return 0LL;
  v4 = v3;
  if ( (unsigned int)sub_2A850((__int64)v3) )
  {
    sub_299D0(v4);
    result = 0LL;
  }
  else
  {
    v5 = sub_2A720(v4, *(_QWORD *)(a1 + 16));
    sub_2A860(v5, &v7, 0LL);
    sub_299D0(v4);
    sub_299D0(v5);
    result = v7;
  }
  return result;
}

_QWORD *__fastcall sub_752A0(__int64 *a1, __int64 a2)
{
  char *v2; // rax
  __int64 v3; // rdx
  _QWORD *result; // rax

  v2 = sub_2F1D0(*a1);
  if ( *(_DWORD *)(*a1 + 24) )
    result = 0LL;
  else
    result = sub_75050((__int64)v2, v3, *(_DWORD *)a2, (__int64 *)(a2 + 48));
  return result;
}

signed __int64 __fastcall sub_752F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  _DWORD *v4; // rax
  __int64 v5; // rbp
  void *v6; // rbx
  char *v7; // rax
  size_t v8; // rdx
  _QWORD *v9; // rax
  signed __int64 v10; // rbx
  _QWORD *v11; // rax
  __int64 v13; // rdi
  __int64 v14; // [rsp+0h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-50h]
  __int64 v16; // [rsp+10h] [rbp-48h]
  int v17; // [rsp+18h] [rbp-40h]
  __int64 *v18; // [rsp+20h] [rbp-38h]
  unsigned __int64 v19; // [rsp+28h] [rbp-30h]

  v3 = a3;
  v19 = __readfsqword(0x28u);
  v4 = (_DWORD *)(**(__int64 (***)(void))(a1 + 120))();
  if ( *v4 )
    __assert_fail("curve->type == EC_WEIERSTRASS", aSsh_1, 0x280u, "ecdsa_new_pub");
  v5 = (__int64)v4;
  v16 = v3;
  v18 = &v14;
  v14 = a2;
  v15 = 0LL;
  v17 = 0;
  sub_2F1D0((__int64)&v14);
  v6 = *(void **)(v5 + 8);
  v7 = sub_2F1D0((__int64)v18);
  if ( !(unsigned __int8)sub_BD100(v7, v8, v6) )
    return 0LL;
  v9 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v9[3] = a1;
  *v9 = v5;
  v9[2] = 0LL;
  v10 = (signed __int64)(v9 + 3);
  v11 = sub_752A0(v18 + 4, v5);
  *(_QWORD *)(v10 - 16) = v11;
  if ( !v11 )
  {
    v13 = v10;
    v10 = 0LL;
    sub_73D20(v13);
  }
  return v10;
}

signed __int64 __fastcall sub_75410(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12
  __int64 v6; // rbp
  signed __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-48h]
  __int64 v10; // [rsp+8h] [rbp-40h]
  __int64 v11; // [rsp+10h] [rbp-38h]
  int v12; // [rsp+18h] [rbp-30h]
  __int64 *v13; // [rsp+20h] [rbp-28h]
  unsigned __int64 v14; // [rsp+28h] [rbp-20h]

  v5 = a4;
  v6 = a5;
  v14 = __readfsqword(0x28u);
  v7 = sub_752F0(a1, a2, a3);
  if ( v7 )
  {
    v9 = v5;
    v11 = v6;
    v10 = 0LL;
    v12 = 0;
    v13 = &v9;
    *(_QWORD *)(v7 - 8) = sub_33840((__int64)&v9);
  }
  return v7;
}

_QWORD *__fastcall sub_75490(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rax
  __int64 v3; // rbp
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  _QWORD *result; // rax

  v2 = (_DWORD *)(**(__int64 (***)(void))(a1 + 120))();
  if ( *v2 )
    __assert_fail("curve->type == EC_WEIERSTRASS", aSsh_1, 0x395u, "ecdsa_new_priv_openssh");
  v3 = (__int64)v2;
  sub_2F1D0(*(_QWORD *)(a2 + 32));
  v4 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v4[3] = a1;
  *v4 = v3;
  v4[2] = 0LL;
  v5 = sub_752A0((__int64 *)(*(_QWORD *)(a2 + 32) + 32LL), v3);
  v4[1] = v5;
  if ( v5 )
  {
    v4[2] = sub_33840(*(_QWORD *)(a2 + 32));
    result = v4 + 3;
  }
  else
  {
    sub_73D20((__int64)(v4 + 3));
    result = 0LL;
  }
  return result;
}

void *sub_75550()
{
  _QWORD *v1; // rbx
  _QWORD *v2; // r15
  _QWORD *v3; // r14
  _QWORD *v4; // r13
  _QWORD *v5; // r12
  _QWORD *v6; // rbp
  _QWORD *v7; // ST08_8

  if ( !byte_326430 )
  {
    v1 = sub_334A0("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    v2 = sub_334A0("52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3");
    v3 = sub_334A0("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec");
    v4 = sub_334A0("216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a");
    v5 = sub_334A0("6666666666666666666666666666666666666666666666666666666666666658");
    v6 = sub_334A0("1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed");
    v7 = sub_330A0(2LL);
    sub_73330((__int64)&unk_3263E0, 2, (__int64)v1, 1u);
    qword_326410 = (__int64)sub_2B2C0((__int64)v1, (__int64)v2, (__int64)v3, (__int64)v7);
    dword_326428 = 3;
    qword_326418 = (__int64)sub_2B3A0(qword_326410, (__int64)v4, (__int64)v5);
    qword_326420 = (__int64)sub_334C0((__int64)v6);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    sub_330F0(v5);
    sub_330F0(v6);
    sub_330F0(v7);
    qword_3263E8 = 0LL;
    byte_326430 = 1;
    qword_3263F0 = (__int64)"Ed25519";
  }
  return &unk_3263E0;
}

void *sub_756B0()
{
  _QWORD *v1; // rbx
  _QWORD *v2; // r15
  _QWORD *v3; // r14
  _QWORD *v4; // r13
  _QWORD *v5; // r12
  _QWORD *v6; // rbp
  _QWORD *v7; // ST08_8

  if ( !byte_3263D0 )
  {
    v1 = sub_334A0(
           "fffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    v2 = sub_334A0(
           "fffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756");
    v3 = sub_334A0("1");
    v4 = sub_334A0(
           "4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e");
    v5 = sub_334A0(
           "693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14");
    v6 = sub_334A0(
           "3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3");
    v7 = sub_330A0(7LL);
    sub_73330((__int64)&unk_326380, 2, (__int64)v1, 1u);
    qword_3263B0 = (__int64)sub_2B2C0((__int64)v1, (__int64)v2, (__int64)v3, (__int64)v7);
    dword_3263C8 = 2;
    qword_3263B8 = (__int64)sub_2B3A0(qword_3263B0, (__int64)v4, (__int64)v5);
    qword_3263C0 = (__int64)sub_334C0((__int64)v6);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    sub_330F0(v5);
    sub_330F0(v6);
    sub_330F0(v7);
    qword_326388 = 0LL;
    byte_3263D0 = 1;
    qword_326390 = (__int64)"Ed448";
  }
  return &unk_326380;
}

void *sub_75810()
{
  _QWORD *v1; // r15
  _QWORD *v2; // r14
  _QWORD *v3; // r13
  _QWORD *v4; // r12
  _QWORD *v5; // rbp
  _QWORD *v6; // rbx
  _QWORD *v7; // ST18_8

  if ( !byte_326370 )
  {
    v1 = sub_334A0("ffffffff00000001000000000000000000000000ffffffffffffffffffffffff");
    v2 = sub_334A0("ffffffff00000001000000000000000000000000fffffffffffffffffffffffc");
    v3 = sub_334A0("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
    v4 = sub_334A0("6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296");
    v5 = sub_334A0("4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5");
    v6 = sub_334A0("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551");
    v7 = sub_330A0(3LL);
    sub_73940(&unk_326320, (__int64)v1, (__int64)v2, (__int64)v3, (__int64)v7, (__int64)v4, (__int64)v5, (__int64)v6);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    sub_330F0(v5);
    sub_330F0(v6);
    sub_330F0(v7);
    byte_326370 = 1;
    qword_326328 = (__int64)"nistp256";
    qword_326330 = (__int64)"nistp256";
  }
  return &unk_326320;
}

void *sub_75930()
{
  _QWORD *v1; // r15
  _QWORD *v2; // r14
  _QWORD *v3; // r13
  _QWORD *v4; // r12
  _QWORD *v5; // rbp
  _QWORD *v6; // rbx
  _QWORD *v7; // ST18_8

  if ( !byte_326310 )
  {
    v1 = sub_334A0("fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff");
    v2 = sub_334A0("fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc");
    v3 = sub_334A0("b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
    v4 = sub_334A0("aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7");
    v5 = sub_334A0("3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f");
    v6 = sub_334A0("ffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973");
    v7 = sub_330A0(19LL);
    sub_73940(&unk_3262C0, (__int64)v1, (__int64)v2, (__int64)v3, (__int64)v7, (__int64)v4, (__int64)v5, (__int64)v6);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    sub_330F0(v5);
    sub_330F0(v6);
    sub_330F0(v7);
    byte_326310 = 1;
    qword_3262C8 = (__int64)"nistp384";
    qword_3262D0 = (__int64)"nistp384";
  }
  return &unk_3262C0;
}

void *sub_75A50()
{
  _QWORD *v1; // r15
  _QWORD *v2; // r14
  _QWORD *v3; // r13
  _QWORD *v4; // r12
  _QWORD *v5; // rbp
  _QWORD *v6; // rbx
  _QWORD *v7; // ST18_8

  if ( !byte_3262B0 )
  {
    v1 = sub_334A0(
           "01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
           "fffffffffffffffffffffff");
    v2 = sub_334A0(
           "01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
           "ffffffffffffffffffffffc");
    v3 = sub_334A0(
           "0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883"
           "d2c34f1ef451fd46b503f00");
    v4 = sub_334A0(
           "00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c18"
           "56a429bf97e7e31c2e5bd66");
    v5 = sub_334A0(
           "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a"
           "272c24088be94769fd16650");
    v6 = sub_334A0(
           "01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b88"
           "99c47aebb6fb71e91386409");
    v7 = sub_330A0(3LL);
    sub_73940(&unk_326260, (__int64)v1, (__int64)v2, (__int64)v3, (__int64)v7, (__int64)v4, (__int64)v5, (__int64)v6);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    sub_330F0(v5);
    sub_330F0(v6);
    sub_330F0(v7);
    byte_3262B0 = 1;
    qword_326268 = (__int64)"nistp521";
    qword_326270 = (__int64)"nistp521";
  }
  return &unk_326260;
}

void *sub_75B70()
{
  _QWORD *v1; // rbx
  _QWORD *v2; // r13
  _QWORD *v3; // r12
  _QWORD *v4; // rbp

  if ( !byte_326250 )
  {
    v1 = sub_334A0("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    v2 = sub_334A0("0000000000000000000000000000000000000000000000000000000000076d06");
    v3 = sub_334A0("0000000000000000000000000000000000000000000000000000000000000001");
    v4 = sub_334A0("0000000000000000000000000000000000000000000000000000000000000009");
    sub_73330((__int64)&unk_326200, 1, (__int64)v1, 0);
    qword_326230 = (__int64)sub_2AAC0((__int64)v1, (__int64)v2, (__int64)v3);
    dword_326240 = 3;
    qword_326238 = (__int64)sub_2ABE0(qword_326230, (__int64)v4);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    qword_326208 = 0LL;
    byte_326250 = 1;
    qword_326210 = (__int64)"Curve25519";
  }
  return &unk_326200;
}

void *sub_75C70()
{
  _QWORD *v1; // rbx
  _QWORD *v2; // r13
  _QWORD *v3; // r12
  _QWORD *v4; // rbp

  if ( !byte_3261F0 )
  {
    v1 = sub_334A0(
           "fffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    v2 = sub_334A0(
           "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000262a6");
    v3 = sub_334A0(
           "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001");
    v4 = sub_334A0(
           "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005");
    sub_73330((__int64)&unk_3261A0, 1, (__int64)v1, 0);
    qword_3261D0 = (__int64)sub_2AAC0((__int64)v1, (__int64)v2, (__int64)v3);
    dword_3261E0 = 2;
    qword_3261D8 = (__int64)sub_2ABE0(qword_3261D0, (__int64)v4);
    sub_330F0(v1);
    sub_330F0(v2);
    sub_330F0(v3);
    sub_330F0(v4);
    qword_3261A8 = 0LL;
    byte_3261F0 = 1;
    qword_3261B0 = (__int64)"Curve448";
  }
  return &unk_3261A0;
}

__int64 **__fastcall sub_75D70(unsigned __int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  unsigned __int64 *v4; // rbp
  __int64 **v5; // rbx

  v2 = (**(__int64 (***)(void))(a2 + 120))();
  if ( *(_DWORD *)v2 )
    __assert_fail("curve->type == EC_WEIERSTRASS", aSsh_1, 0x15Au, "ecdsa_public");
  v3 = v2;
  v4 = sub_35FB0(a1, *(__int64 **)(v2 + 40));
  v5 = sub_2A720(*(_QWORD **)(v3 + 56), (__int64)v4);
  sub_330F0(v4);
  return v5;
}

unsigned __int64 **__fastcall sub_75DE0(unsigned __int64 *a1, __int64 a2)
{
  __int64 v2; // r14
  _DWORD *v3; // rax
  __int64 v4; // r12
  __int64 v5; // rax
  __int64 (__fastcall ***v6)(_QWORD, char *, signed __int64); // rbp
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  char v9; // al
  unsigned __int64 *v10; // rbx
  unsigned __int64 **v11; // rbp
  __int64 v13; // [rsp+0h] [rbp-A8h]
  unsigned __int64 v14; // [rsp+78h] [rbp-30h]

  v2 = *(_QWORD *)(a2 + 120);
  v14 = __readfsqword(0x28u);
  v3 = (_DWORD *)(*(__int64 (**)(void))v2)();
  if ( *v3 != 2 )
    __assert_fail("curve->type == EC_EDWARDS", aSsh_1, 0x181u, "eddsa_public");
  v4 = (__int64)v3;
  v5 = (**(__int64 (__fastcall ***)(_QWORD))(v2 + 8))(*(_QWORD *)(v2 + 8));
  v6 = (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))v5;
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
  if ( *(_QWORD *)(v4 + 32) )
  {
    v7 = 0LL;
    do
    {
      v8 = v7++;
      v9 = sub_334D0(a1, v8);
      sub_2ECE0(v6[1], v9);
    }
    while ( *(_QWORD *)(v4 + 32) > v7 );
  }
  ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64), __int64 *))(*v6)[3])(v6, &v13);
  ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64)))(*v6)[4])(v6);
  v10 = sub_74070((__int64)&v13, *(_QWORD *)(*(_QWORD *)(v2 + 8) + 40LL), v4);
  v11 = sub_2B960(*(_QWORD **)(v4 + 56), (__int64)v10);
  sub_330F0(v10);
  return v11;
}

__int64 __fastcall sub_75EF0(__int64 a1)
{
  return *(_QWORD *)((**(__int64 (***)(void))(a1 + 32))() + 16);
}

_QWORD *__fastcall sub_75F10(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // r12
  _QWORD *v3; // rax
  _QWORD *v4; // rbx

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (*(__int64 (**)(void))v1)();
  v3 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v4 = v3;
  *v3 = v1;
  v3[1] = v2;
  (*(void (__fastcall **)(_QWORD *, signed __int64))(v1 + 8))(v3, 32LL);
  return v4;
}

__int64 __fastcall sub_75F50(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 24LL))();
}

__int64 __fastcall sub_75F60(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 32LL))();
}

void __fastcall sub_75F70(_QWORD **a1)
{
  sub_330F0(a1[2]);
  ((void (__fastcall *)(_QWORD **))(*a1)[2])(a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_76150(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = unk_326020;
  a2[1] = *((_QWORD *)&unk_326020 + 1);
  result = 0LL;
  *a2 = v2;
  return result;
}

__int64 __fastcall sub_76170(__int64 a1, __int64 a2)
{
  char v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  return (*(unsigned int (__fastcall **)(char *, __int64, _QWORD))(a1 + 152))(&v3, a2, 0LL) >= 1 ? 6 : 0;
}

__int64 __fastcall sub_761C0(__int64 a1, __int64 a2)
{
  char v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  return (*(unsigned int (__fastcall **)(char *, __int64, _QWORD))(a1 + 168))(&v3, a2, 0LL) >= 1 ? 6 : 0;
}

__int64 __fastcall sub_76210(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  if ( a2 )
    result = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int64, __int64))(a1 + 120))(
               a2 + 4,
               *(_QWORD *)(a2 + 8),
               0LL,
               a3,
               a4);
  else
    result = 6LL;
  return result;
}

__int64 __fastcall sub_76240(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  if ( a2 )
    result = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, _QWORD))(a1 + 128))(
               a2 + 4,
               *(_QWORD *)(a2 + 8),
               a3,
               a4,
               0LL);
  else
    result = 6LL;
  return result;
}

__int64 __fastcall sub_76270(__int64 a1, __int64 a2)
{
  return sub_76170(a1, a2);
}

signed __int64 __fastcall sub_76280(__int64 a1, unsigned int *a2, _QWORD *a3)
{
  _QWORD *v3; // r12
  __int64 v4; // rbx
  signed __int64 result; // rax
  unsigned __int64 v6; // rdi
  void *v7; // rax
  size_t v8; // rdx
  void *v9; // rsi
  char v10; // [rsp+18h] [rbp-70h]
  int v11; // [rsp+1Ch] [rbp-6Ch]
  size_t n; // [rsp+20h] [rbp-68h]
  void *src; // [rsp+28h] [rbp-60h]
  size_t v14; // [rsp+30h] [rbp-58h]
  void *v15; // [rsp+38h] [rbp-50h]
  unsigned __int64 v16; // [rsp+48h] [rbp-40h]

  v3 = a3;
  v4 = a1;
  *a3 = 0LL;
  a3[1] = 0LL;
  v16 = __readfsqword(0x28u);
  n = 0LL;
  src = 0LL;
  v14 = 0LL;
  v15 = 0LL;
  v11 = 0;
  if ( (*(unsigned int (__fastcall **)(char *, _QWORD, signed __int64, void *, int *, size_t *))(a1 + 112))(
         &v10,
         *a2,
         1LL,
         &unk_326020,
         &v11,
         &n) )
  {
    return 6LL;
  }
  v11 = 0;
  if ( (*(unsigned int (__fastcall **)(char *, _QWORD, signed __int64, void *, int *))(a1 + 112))(
         &v10,
         a2[1],
         2LL,
         &unk_326020,
         &v11) )
  {
    (*(void (__fastcall **)(char *, size_t *))(a1 + 152))(&v10, &n);
    result = 6LL;
  }
  else
  {
    v6 = n + v14 + 2;
    *v3 = n + v14 + 1;
    v7 = sub_2F450(v6, 1uLL, 0LL);
    v8 = n;
    v9 = src;
    v3[1] = v7;
    memcpy(v7, v9, v8);
    *(_BYTE *)(v3[1] + n) = 32;
    memcpy((void *)(v3[1] + n + 1), v15, v14);
    *(_BYTE *)(v3[1] + *v3) = 0;
    (*(void (__fastcall **)(char *, size_t *))(v4 + 152))(&v10, &n);
    (*(void (__fastcall **)(char *, size_t *))(v4 + 152))(&v10, &v14);
    result = 0LL;
  }
  return result;
}

signed __int64 __fastcall sub_76430(__int64 a1, _QWORD **a2)
{
  _QWORD *v2; // rbx
  int v3; // er12
  signed __int64 result; // rax
  char v5; // [rsp+4h] [rbp-24h]
  unsigned __int64 v6; // [rsp+8h] [rbp-20h]

  v2 = *a2;
  v6 = __readfsqword(0x28u);
  if ( !v2 )
    return 6LL;
  if ( v2[1] )
  {
    v3 = (*(__int64 (__fastcall **)(char *, _QWORD *, _QWORD, _QWORD))(a1 + 104))(&v5, v2 + 1, 0LL, 0LL);
    sub_2F4D0(v2);
    result = 0LL;
    *a2 = 0LL;
    if ( !v3 )
      return result;
    return 6LL;
  }
  sub_2F4D0(v2);
  *a2 = 0LL;
  return 0LL;
}

signed __int64 __fastcall sub_764D0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // r14
  _QWORD *v4; // rax
  signed __int64 v5; // r13
  _QWORD *v6; // rbx
  int v7; // eax
  signed __int64 result; // rax
  char v9; // [rsp+10h] [rbp-68h]
  unsigned int v10; // [rsp+14h] [rbp-64h]
  __int64 v11; // [rsp+18h] [rbp-60h]
  __int64 v12; // [rsp+20h] [rbp-58h]
  void *v13; // [rsp+28h] [rbp-50h]
  unsigned __int64 v14; // [rsp+38h] [rbp-40h]

  v3 = a3;
  v14 = __readfsqword(0x28u);
  v12 = 1LL;
  v13 = &unk_326020;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  v5 = (signed __int64)v4 + 4;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v6 = v4;
  v7 = (*(__int64 (__fastcall **)(signed __int64, _QWORD, signed __int64, __int64 *, signed __int64, __int64 *, _QWORD, unsigned int *))(a1 + 176))(
         (signed __int64)v4 + 4,
         0LL,
         0xFFFFFFFFLL,
         &v12,
         1LL,
         &v11,
         0LL,
         &v10);
  *(_DWORD *)v6 = v7;
  if ( v7 )
    goto LABEL_15;
  if ( v10 - 1 > 0xFFFFFFFD )
    *(_DWORD *)v6 = (*(__int64 (__fastcall **)(signed __int64, __int64, void *, _QWORD, unsigned int *, _QWORD, _QWORD))(a1 + 184))(
                      v5,
                      v11,
                      &unk_326020,
                      0LL,
                      &v10,
                      0LL,
                      0LL);
  (*(void (__fastcall **)(char *, __int64 *))(a1 + 160))(&v9, &v11);
  if ( *(_DWORD *)v6 )
  {
LABEL_15:
    sub_2F4D0(v6);
    result = 6LL;
  }
  else
  {
    if ( v10 == -1 )
      v6[2] = -1LL;
    else
      v6[2] = v10 + time(0LL);
    if ( v3 )
      *v3 = v6[2];
    *a2 = v6;
    result = 0LL;
  }
  return result;
}

__int64 __fastcall sub_76630(__int64 a1, int **a2, __int64 a3, int a4, __int64 a5, __int64 a6, _QWORD *a7, _QWORD *a8)
{
  int *v8; // rbx
  int v9; // eax
  unsigned int v10; // edx
  char v12; // [rsp+8h] [rbp-28h]
  unsigned int v13; // [rsp+Ch] [rbp-24h]
  unsigned __int64 v14; // [rsp+10h] [rbp-20h]

  v8 = *a2;
  v14 = __readfsqword(0x28u);
  v9 = (*(__int64 (__fastcall **)(int *, _QWORD, int *, __int64, void *, _QWORD, _QWORD, _QWORD, __int64, _QWORD, __int64, char *, unsigned int *))(a1 + 144))(
         v8 + 1,
         0LL,
         v8 + 2,
         a3,
         &unk_326020,
         (a4 != 0) | 0x22u,
         0LL,
         0LL,
         a5,
         0LL,
         a6,
         &v12,
         &v13);
  *v8 = v9;
  if ( a8 )
  {
    if ( v13 != -1 )
    {
      *a8 = v13;
      if ( !a7 )
        goto LABEL_5;
      goto LABEL_4;
    }
    *a8 = -1LL;
    if ( a7 )
      *a7 = -1LL;
  }
  else if ( a7 )
  {
    if ( v13 != -1 )
    {
LABEL_4:
      *a7 = v13 + time(0LL);
      v9 = *v8;
      goto LABEL_5;
    }
    *a7 = -1LL;
  }
LABEL_5:
  v10 = 0;
  if ( v9 )
    v10 = 5 * (v9 != 1) + 1;
  return v10;
}

__int64 __fastcall sub_76740(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r12
  char *v12; // rax
  char *v13; // rbx
  unsigned int v14; // ebp
  char v16; // [rsp+Ch] [rbp-3Ch]
  size_t v17; // [rsp+10h] [rbp-38h]
  char *v18; // [rsp+18h] [rbp-30h]
  unsigned __int64 v19; // [rsp+28h] [rbp-20h]

  v11 = a3;
  v19 = __readfsqword(0x28u);
  v12 = sub_BC160("host@", a4, a5, a6, a7, a8, a9, a10, a11, a2, 0LL);
  v13 = v12;
  v18 = v12;
  v17 = strlen(v12);
  v14 = (*(__int64 (__fastcall **)(char *, size_t *, void *, __int64))(a1 + 136))(&v16, &v17, off_326040, v11);
  sub_2F4D0(v13);
  return v14 >= 1 ? 6 : 0;
}

__int64 (__fastcall *__fastcall sub_767D0(_QWORD *a1))()
{
  __int64 (__fastcall *result)(); // rax

  a1[2] = sub_76150;
  a1[3] = sub_76740;
  a1[4] = sub_761C0;
  a1[5] = sub_76630;
  a1[6] = sub_76170;
  a1[7] = sub_764D0;
  a1[8] = sub_76430;
  a1[9] = sub_76210;
  a1[10] = sub_76240;
  a1[11] = sub_76270;
  result = (__int64 (__fastcall *)())sub_76280;
  a1[12] = sub_76280;
  return result;
}

__int64 __fastcall sub_76850(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 - 24) + 16LL))(
           *(_QWORD *)(a1 - 24),
           *(_QWORD *)(a1 - 32));
}

__int64 __fastcall sub_76870(__int64 a1)
{
  return **(_QWORD **)(a1 - 8);
}

__int64 __fastcall sub_76880(__int64 a1, void *a2)
{
  void *v2; // r13
  _QWORD *v3; // r12
  __int64 v4; // r14
  __int64 v5; // rbp
  _QWORD *v6; // r12
  __int64 (***v7)(void); // rbp
  __int64 v8; // rsi
  __int64 v9; // rdx

  v2 = a2;
  v3 = *(_QWORD **)(a1 - 24);
  v4 = *(_QWORD *)(a1 - 16);
  v5 = (*(__int64 (__fastcall **)(_QWORD))*v3)(*v3);
  (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v5 + 16LL))(v5, v3);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 24LL))(v5, v4);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 32LL))(v5);
  v6 = *(_QWORD **)(a1 - 40);
  v7 = (__int64 (***)(void))(*(__int64 (__fastcall **)(_QWORD))*v6)(*v6);
  ((void (__fastcall *)(__int64 (***)(void), _QWORD *))(*v7)[2])(v7, v6);
  v8 = *(_QWORD *)(a1 - 16);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 - 48) + 40LL);
  sub_2EC20(v7[1]);
  ((void (__fastcall *)(__int64 (***)(void), _QWORD))(*v7)[3])(v7, *(_QWORD *)(a1 - 16));
  ((void (__fastcall *)(__int64 (***)(void)))(*v7)[4])(v7);
  memcpy(v2, *(const void **)(a1 - 16), *(signed int *)(*(_QWORD *)a1 + 64LL));
  return sub_BD070(*(void **)(a1 - 16), *(_QWORD *)(*(_QWORD *)(a1 - 48) + 40LL));
}

void __fastcall sub_76940(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r12
  unsigned __int64 v4; // rbp
  char *v5; // r13
  char *v6; // r15
  char v7; // si
  unsigned __int64 v8; // r14
  char *v9; // r14
  char v10; // al

  v3 = 0LL;
  v4 = a3;
  v5 = (char *)a2;
  if ( *(_QWORD *)(*(_QWORD *)(a1 - 48) + 48LL) < a3 )
  {
    v3 = sub_BC650();
    sub_BC510(v3, *(_QWORD *)(*(_QWORD *)(a1 - 48) + 40LL));
    sub_5E520(*(__int64 (***)(void))(a1 - 48), a2, v4, *(_QWORD *)(v3 + 8));
    v5 = *(char **)(v3 + 8);
    v4 = *(_QWORD *)(v3 + 16);
  }
  (*(void (**)(void))(**(_QWORD **)(a1 - 40) + 8LL))();
  if ( v4 )
  {
    v6 = v5;
    do
    {
      v7 = *v6++;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(a1 - 40) + 8LL), v7 ^ 0x5C);
    }
    while ( &v5[v4] != v6 );
  }
  if ( v4 < *(_QWORD *)(*(_QWORD *)(a1 - 48) + 48LL) )
  {
    v8 = v4;
    do
    {
      ++v8;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(a1 - 40) + 8LL), 92);
    }
    while ( *(_QWORD *)(*(_QWORD *)(a1 - 48) + 48LL) > v8 );
  }
  (*(void (**)(void))(**(_QWORD **)(a1 - 32) + 8LL))();
  if ( v4 )
  {
    v9 = &v5[v4];
    do
    {
      v10 = *v5++;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(a1 - 32) + 8LL), v10 ^ 0x36);
    }
    while ( v5 != v9 );
  }
  while ( *(_QWORD *)(*(_QWORD *)(a1 - 48) + 48LL) > v4 )
  {
    ++v4;
    sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(_QWORD *)(a1 - 32) + 8LL), 54);
  }
  if ( v3 )
    sub_BC660((void **)v3);
}

void __fastcall sub_76AB0(__int64 a1)
{
  (*(void (**)(void))(**(_QWORD **)(a1 - 40) + 32LL))();
  (*(void (**)(void))(**(_QWORD **)(a1 - 32) + 32LL))();
  (*(void (**)(void))(**(_QWORD **)(a1 - 24) + 32LL))();
  sub_BD070(*(void **)(a1 - 16), *(_QWORD *)(*(_QWORD *)(a1 - 48) + 40LL));
  sub_2F4D0(*(void **)(a1 - 16));
  sub_BC660(*(void ***)(a1 - 8));
  sub_BD070((void *)(a1 - 48), 0x40uLL);
  sub_2F4D0((void *)(a1 - 48));
}

_QWORD *__fastcall sub_76B20(__int64 a1)
{
  __int64 v1; // r13
  _QWORD *v2; // rax
  _QWORD *v3; // r12
  _QWORD *v4; // rbx
  __int64 v5; // rax
  __int64 (__fastcall ***v6)(_QWORD); // rbp
  __int64 (__fastcall **v7)(_QWORD); // rax
  __int64 v8; // rax
  __int64 v9; // rbp
  __int64 (__fastcall **v10)(_QWORD); // rax
  __int64 v11; // rax
  __int64 v12; // rbp
  __int64 (__fastcall **v13)(_QWORD); // rax
  __int64 v14; // rax
  __int64 (__fastcall **v15)(_QWORD); // rdx
  __int64 v16; // rcx
  char *v17; // rdx
  __int64 v18; // rdi
  __int64 v19; // rax

  v1 = a1;
  v2 = sub_2F450(1uLL, 0x40uLL, 0LL);
  v3 = *(_QWORD **)(a1 + 72);
  v4 = v2;
  v5 = (*(__int64 (__fastcall **)(_QWORD, signed __int64))*v3)(*v3, 64LL);
  v6 = (__int64 (__fastcall ***)(_QWORD))v5;
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 8LL))(v5);
  v7 = *v6;
  v4[1] = v6;
  *v4 = v7;
  v8 = (*v7)(v7);
  v9 = v8;
  if ( v8 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 8LL))(v8);
  v10 = (__int64 (__fastcall **)(_QWORD))*v4;
  v4[2] = v9;
  v11 = (*v10)(v10);
  v12 = v11;
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  v13 = (__int64 (__fastcall **)(_QWORD))*v4;
  v4[3] = v12;
  if ( !v13[6] )
    __assert_fail("ctx->hashalg->blocklen", "sshhmac.c", 0x28u, "hmac_new");
  v4[4] = sub_2F450((unsigned __int64)v13[5], 1uLL, 0LL);
  v14 = sub_BC640();
  v15 = (__int64 (__fastcall **)(_QWORD))*v4;
  v16 = v3[1];
  v4[5] = v14;
  sub_BC720(v14, (__int64)&unk_F0A3A, v15[7], v16);
  if ( v3[2] || *(_QWORD *)(*v4 + 64LL) )
  {
    sub_BC720(v4[5], (__int64)" (");
    v17 = &locale;
    if ( v3[2] )
    {
      sub_BC720(v4[5], (__int64)"%s%s", &locale);
      v17 = ", ";
    }
    v18 = v4[5];
    if ( *(_QWORD *)(*v4 + 64LL) )
    {
      sub_BC720(v18, (__int64)"%s%s", v17);
      v18 = v4[5];
    }
    sub_BC720(v18, (__int64)")", v17);
  }
  v19 = v4[3];
  v4[6] = v1;
  v4[7] = *(_QWORD *)(v19 + 8);
  return v4 + 6;
}

__int64 __fastcall sub_76CB0(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v4; // [rsp+0h] [rbp-68h]
  unsigned __int64 v5; // [rsp+48h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  if ( *(_DWORD *)(*(_QWORD *)a1 + 64LL) > 0x40u )
    __assert_fail("mac->vt->len <= sizeof(correct)", "sshmac.c", 0xFu, "ssh2_mac_verresult");
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 32LL))(a1, &v4);
  v2 = sub_BD090((__int64)&v4, a2, *(signed int *)(*(_QWORD *)a1 + 64LL));
  sub_BD070(&v4, 0x40uLL);
  return v2;
}

__int64 __fastcall sub_76D40(__int64 (***a1)(void), __int64 a2, int a3, int a4)
{
  int v4; // er13
  __int64 v5; // r12

  v4 = a4;
  v5 = a3;
  (*a1)[3]();
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a1[1], v4);
  sub_2EC20(a1[1]);
  return ((__int64 (__fastcall *)(__int64 (***)(void), __int64))(*a1)[4])(a1, a2 + v5);
}

__int64 __fastcall sub_76DA0(__int64 (***a1)(void), __int64 a2, int a3, int a4)
{
  int v4; // er13
  __int64 v5; // r12

  v4 = a4;
  v5 = a3;
  (*a1)[3]();
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a1[1], v4);
  sub_2EC20(a1[1]);
  return sub_76CB0((__int64)a1, a2 + v5);
}

void __fastcall sub_76DF0(__int64 a1)
{
  sub_BD070((void *)(a1 - 112), 0x80uLL);
  sub_2F4D0((void *)(a1 - 112));
}

void __fastcall sub_76E10(__int64 a1)
{
  __m128i v1; // xmm0

  v1 = _mm_load_si128((const __m128i *)&xmmword_F0EC0);
  *(_QWORD *)(a1 - 32) = 0LL;
  *(_QWORD *)(a1 - 24) = 0LL;
  *(__m128i *)(a1 - 112) = v1;
}

signed __int64 __fastcall sub_76E30(__m128i *a1, const __m128i *a2)
{
  signed __int64 result; // rax
  __m128i v3; // xmm0

  a1[-7] = _mm_loadu_si128(a2 - 7);
  result = (signed __int64)a1[-1].m128i_i64;
  a1[-6] = _mm_loadu_si128(a2 - 6);
  a1[-5] = _mm_loadu_si128(a2 - 5);
  a1[-4] = _mm_loadu_si128(a2 - 4);
  a1[-3] = _mm_loadu_si128(a2 - 3);
  a1[-2] = _mm_loadu_si128(a2 - 2);
  a1[-1] = _mm_loadu_si128(a2 - 1);
  v3 = _mm_loadu_si128(a2);
  a1[-1].m128i_i64[1] = result;
  *a1 = v3;
  a1->m128i_i64[1] = result;
  return result;
}

char *__fastcall sub_76E90(__int64 a1)
{
  _QWORD *v1; // rax
  signed __int64 v2; // rdx
  char *result; // rax

  v1 = sub_2F450(1uLL, 0x80uLL, 0LL);
  v2 = (signed __int64)(v1 + 12);
  v1[14] = a1;
  result = (char *)(v1 + 14);
  *((_QWORD *)result - 2) = sub_77010;
  *((_QWORD *)result - 1) = v2;
  *((_QWORD *)result + 1) = v2;
  return result;
}

unsigned __int64 __fastcall sub_76ED0(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  signed __int64 v3; // r13
  signed __int64 v4; // rbp
  __int64 (**v5)(void); // rdi
  __int64 v6; // rax
  int v7; // edx
  __int16 v9; // [rsp+0h] [rbp-38h]
  char v10; // [rsp+2h] [rbp-36h]
  char v11; // [rsp+3h] [rbp-35h]
  char v12; // [rsp+4h] [rbp-34h]
  char v13; // [rsp+5h] [rbp-33h]
  char v14; // [rsp+6h] [rbp-32h]
  char v15; // [rsp+7h] [rbp-31h]
  unsigned __int64 v16; // [rsp+8h] [rbp-30h]

  v2 = a1;
  v3 = 55LL - *(_QWORD *)(a1 - 32);
  v16 = __readfsqword(0x28u);
  v4 = 8LL * *(_QWORD *)(a1 - 24);
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  sub_2EC40(*(void (__fastcall ***)(_QWORD, __int64 *, signed __int64))(a1 - 8), v3 & 0x3F, 0);
  v9 = v4;
  v5 = *(__int64 (***)(void))(a1 - 8);
  v10 = BYTE2(v4);
  v11 = BYTE3(v4);
  v12 = BYTE4(v4);
  v13 = BYTE5(v4);
  v15 = HIBYTE(v4);
  v14 = BYTE6(v4);
  sub_2EC20(v5);
  sub_BD070(&v9, 8uLL);
  v6 = *(_QWORD *)(v2 - 32);
  if ( v6 )
    __assert_fail("blk->used == 0 && \"Should have exactly hit a block boundary\"", "sshmd5.c", 0x61u, "md5_block_pad");
  do
  {
    v7 = *(_DWORD *)(v2 + 4 * v6 - 112);
    *(_WORD *)(a2 + 4 * v6) = v7;
    *(_BYTE *)(a2 + 4 * v6 + 2) = BYTE2(v7);
    *(_BYTE *)(a2 + 4 * v6++ + 3) = HIBYTE(v7);
  }
  while ( v6 != 4 );
  return __readfsqword(0x28u) ^ v16;
}

unsigned __int64 __fastcall sub_77010(__int64 a1, char *a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r13
  char *v7; // r12
  __int64 v8; // rbx
  unsigned __int64 v9; // rbp
  size_t v10; // rdi
  char *v11; // rsi
  size_t v12; // r15
  __int64 v13; // rdi
  __int64 v14; // rax
  int v15; // er8
  int v16; // edi
  unsigned int *v17; // r11
  int v18; // esi
  int v19; // eax
  __int64 v20; // r14
  unsigned int *v21; // r10
  unsigned int v22; // er9
  signed int v23; // ecx
  unsigned int v24; // edx
  unsigned int v25; // edx
  unsigned int v26; // edx
  unsigned int v27; // er9
  int v28; // edi
  int v29; // ecx
  unsigned int *v31; // r9
  unsigned int v32; // er8
  unsigned int v33; // edx
  unsigned int v34; // edx
  unsigned int v35; // er14
  int v36; // edi
  int v37; // ecx
  unsigned int *v38; // r14
  unsigned int v39; // er8
  unsigned int v40; // edx
  unsigned int v41; // edx
  unsigned int v42; // er10
  unsigned int v43; // edx
  int v44; // ecx
  unsigned int v45; // er8
  unsigned int v46; // edx
  unsigned int v47; // edx
  unsigned int v48; // er10
  unsigned int v49; // edx
  int v50; // ecx
  int v51; // [rsp+10h] [rbp-98h]
  int v52; // [rsp+18h] [rbp-90h]
  int v53; // [rsp+1Ch] [rbp-8Ch]
  int v54[18]; // [rsp+20h] [rbp-88h]
  unsigned __int64 v55; // [rsp+68h] [rbp-40h]

  v6 = a1 - 80;
  v7 = a2;
  v8 = a1;
  v9 = a3;
  v55 = __readfsqword(0x28u);
  while ( v9 )
  {
    v10 = *(_QWORD *)(v8 - 16);
    while ( 1 )
    {
      v11 = v7;
      v12 = 64 - v10;
      if ( 64 - v10 > v9 )
        v12 = v9;
      v7 += v12;
      v9 -= v12;
      memcpy((void *)(v6 + v10), v11, v12);
      v13 = *(_QWORD *)(v8 - 16);
      *(_QWORD *)(v8 - 8) += v12;
      v10 = v12 + v13;
      *(_QWORD *)(v8 - 16) = v10;
      if ( v10 == 64 )
        break;
      if ( !v9 )
        return __readfsqword(0x28u) ^ v55;
    }
    *(_QWORD *)(v8 - 16) = 0LL;
    v14 = 0LL;
    do
    {
      v54[v14] = *(_DWORD *)(v6 + 4 * v14);
      ++v14;
    }
    while ( v14 != 16 );
    v15 = *(_DWORD *)(v8 - 96);
    v16 = *(_DWORD *)(v8 - 92);
    v17 = (unsigned int *)&unk_F0BC0;
    v18 = *(_DWORD *)(v8 - 88);
    v19 = *(_DWORD *)(v8 - 84);
    v20 = 0LL;
    v21 = (unsigned int *)&unk_F0BC0;
    LOBYTE(v22) = 7;
    v23 = -680876936;
    v51 = *(_DWORD *)(v8 - 96);
    v52 = *(_DWORD *)(v8 - 88);
    v53 = *(_DWORD *)(v8 - 84);
    while ( 1 )
    {
      v24 = v23 + v15 + v54[v20] + (v19 ^ v16 & (v19 ^ v18));
      v15 = ((v24 >> -(char)v22) | (v24 << v22)) + v16;
      v25 = v54[v21[5]] + v21[3] + v19 + (v18 ^ v15 & (v16 ^ v18));
      v19 = ((v25 >> -*((_BYTE *)v21 + 16)) | (v25 << v21[4])) + v15;
      v26 = v54[v21[8]] + v21[6] + v18 + (v16 ^ v19 & (v16 ^ v15));
      v27 = v21[10];
      v18 = ((v26 >> -*((_BYTE *)v21 + 28)) | (v26 << v21[7])) + v19;
      v28 = v54[v21[11]] + v21[9] + v16;
      v29 = -v21[10];
      v21 += 12;
      v16 = (((v28 + (v15 ^ v18 & (v15 ^ (unsigned int)v19))) >> v29) | ((v28 + (v15 ^ v18 & (v15 ^ v19))) << v27))
          + v18;
      if ( &unk_F0C80 == (_UNKNOWN *)v21 )
        break;
      v23 = *v21;
      v22 = v21[1];
      v20 = v21[2];
    }
    v31 = (unsigned int *)&unk_F0BC0;
    do
    {
      v32 = v54[v31[50]] + v31[48] + (v18 ^ v19 & (v16 ^ v18)) + v15;
      v15 = v16 + ((v32 >> -*((_BYTE *)v31 + 196)) | (v32 << v31[49]));
      v33 = v54[v31[53]] + v31[51] + v19 + (v16 ^ v18 & (v16 ^ v15));
      v19 = ((v33 >> -*((_BYTE *)v31 + 208)) | (v33 << v31[52])) + v15;
      v34 = v54[v31[56]] + v31[54] + v18 + (v15 ^ v16 & (v15 ^ v19));
      v35 = v31[58];
      v18 = ((v34 >> -*((_BYTE *)v31 + 220)) | (v34 << v31[55])) + v19;
      v36 = v54[v31[59]] + v31[57] + v16;
      v37 = -v31[58];
      v31 += 12;
      v16 = (((v36 + (v19 ^ v15 & (v19 ^ (unsigned int)v18))) >> v37) | ((v36 + (v19 ^ v15 & (v19 ^ v18))) << v35))
          + v18;
    }
    while ( v21 != v31 );
    v38 = (unsigned int *)&unk_F0BC0;
    do
    {
      v39 = v54[v38[98]] + v38[96] + (v19 ^ v16 ^ v18) + v15;
      v15 = v16 + ((v39 >> -*((_BYTE *)v38 + 388)) | (v39 << v38[97]));
      v40 = v54[v38[101]] + v38[99] + v19 + (v15 ^ v16 ^ v18);
      v19 = ((v40 >> -*((_BYTE *)v38 + 400)) | (v40 << v38[100])) + v15;
      v41 = v54[v38[104]] + v38[102] + v18 + (v19 ^ v16 ^ v15);
      v42 = v38[106];
      v18 = ((v41 >> -*((_BYTE *)v38 + 412)) | (v41 << v38[103])) + v19;
      v43 = v54[v38[107]] + v38[105] + v16 + (v18 ^ v15 ^ v19);
      v44 = -v38[106];
      v38 += 12;
      v16 = ((v43 >> v44) | (v43 << v42)) + v18;
    }
    while ( v31 != v38 );
    do
    {
      v45 = v54[v17[146]] + v17[144] + (v18 ^ (v16 | ~v19)) + v15;
      v15 = v16 + ((v45 >> -*((_BYTE *)v17 + 580)) | (v45 << v17[145]));
      v46 = v54[v17[149]] + v17[147] + v19 + (v16 ^ (v15 | ~v18));
      v19 = ((v46 >> -*((_BYTE *)v17 + 592)) | (v46 << v17[148])) + v15;
      v47 = v54[v17[152]] + v17[150] + v18 + (v15 ^ (v19 | ~v16));
      v48 = v17[154];
      v18 = ((v47 >> -*((_BYTE *)v17 + 604)) | (v47 << v17[151])) + v19;
      v49 = v54[v17[155]] + v17[153] + v16 + (v19 ^ (v18 | ~v15));
      v50 = -v17[154];
      v17 += 12;
      v16 = ((v49 >> v50) | (v49 << v48)) + v18;
    }
    while ( v31 != v17 );
    *(_DWORD *)(v8 - 92) += v16;
    *(_DWORD *)(v8 - 88) = v52 + v18;
    *(_DWORD *)(v8 - 96) = v51 + v15;
    *(_DWORD *)(v8 - 84) = v53 + v19;
    sub_BD070(v54, 0x40uLL);
  }
  return __readfsqword(0x28u) ^ v55;
}

__int64 __fastcall sub_77500(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(_QWORD *)(a1 + 48);
  if ( !v1 )
    __assert_fail("pi->keymaker", "sshprng.c", 0xA8u, "prng_seed_BinarySink_write");
  return sub_2EC20(*(__int64 (***)(void))(v1 + 8));
}

_QWORD *__fastcall sub_77540(__int64 a1)
{
  __int64 v1; // rbx
  char *v2; // rax
  signed __int64 v3; // r14
  _QWORD *v4; // r12
  __int64 *v5; // rbp
  signed __int64 v6; // r13
  __int64 v7; // rax
  __int64 v8; // rbx

  v1 = a1;
  v2 = (char *)sub_2F450(1uLL, 0x1A0uLL, 0LL);
  v3 = (signed __int64)(v2 + 8);
  v4 = v2;
  *(_QWORD *)v2 = 0LL;
  *((_QWORD *)v2 + 51) = 0LL;
  v5 = (__int64 *)(v2 + 136);
  v6 = (signed __int64)(v2 + 392);
  memset(
    (void *)((unsigned __int64)(v2 + 8) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v2 - (((_DWORD)v2 + 8) & 0xFFFFFFF8) + 416) >> 3));
  *(_OWORD *)(v2 + 40) = 0LL;
  *((_QWORD *)v2 + 3) = a1;
  *((_QWORD *)v2 + 7) = 0LL;
  *((_QWORD *)v2 + 4) = 0LL;
  do
  {
    v7 = (*(__int64 (__fastcall **)(__int64, signed __int64))v1)(v1, 416LL);
    v8 = v7;
    if ( v7 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
    *v5 = v8;
    ++v5;
    v1 = v4[3];
  }
  while ( (__int64 *)v6 != v5 );
  v4[49] = 0LL;
  v4[2] = v3;
  v4[1] = sub_77500;
  *v4 = 4LL * *(_QWORD *)(v1 + 40);
  return v4;
}

void __fastcall sub_77630(_QWORD *a1)
{
  _QWORD *v1; // r12
  __int64 *v2; // rbp
  __int64 *v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rdi
  __int64 v6; // rdi

  v1 = a1;
  v2 = a1 + 49;
  v3 = a1 + 17;
  sub_BD070(a1 + 5, 0x10uLL);
  do
  {
    v4 = *v3;
    ++v3;
    (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)v4 + 32LL))(v4, 16LL);
  }
  while ( v3 != v2 );
  v5 = v1[4];
  if ( v5 )
    (*(void (**)(void))(*(_QWORD *)v5 + 32LL))();
  v6 = v1[7];
  if ( v6 )
    (*(void (**)(void))(*(_QWORD *)v6 + 32LL))();
  sub_BD070(v1, 0x1A0uLL);
  sub_2F4D0(v1);
}

__int64 __fastcall sub_776B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  if ( *(_QWORD *)(a1 + 56) )
    __assert_fail("!pi->keymaker", "sshprng.c", 0x92u, "prng_seed_begin");
  v1 = *(_QWORD *)(a1 + 32);
  if ( v1 )
  {
    *(_QWORD *)(a1 + 56) = v1;
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  else
  {
    v2 = (**(__int64 (__fastcall ***)(_QWORD))(a1 + 24))(*(_QWORD *)(a1 + 24));
    v1 = v2;
    if ( v2 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 8LL))(v2);
    *(_QWORD *)(a1 + 56) = v1;
  }
  return sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v1 + 8), 82);
}

unsigned __int64 __fastcall sub_77730(__int64 a1)
{
  __int64 v1; // rbp
  _QWORD *v2; // rbx
  bool v3; // zf
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 (**v7)(void); // rdi
  __int64 v8; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v10; // rt1
  __int64 v11; // [rsp+0h] [rbp-98h]
  unsigned __int64 v12; // [rsp+78h] [rbp-20h]

  v1 = *(_QWORD *)(a1 + 56);
  v12 = __readfsqword(0x28u);
  if ( !v1 )
    __assert_fail("pi->keymaker", "sshprng.c", 0xB2u, "prng_seed_finish");
  v2 = (_QWORD *)a1;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v1 + 24LL))(v1, &v11);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 32LL))(v1);
  v3 = *(_QWORD *)(a1 + 32) == 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  if ( !v3 )
    goto LABEL_11;
  v4 = (**(__int64 (__fastcall ***)(_QWORD))(a1 + 24))(*(_QWORD *)(a1 + 24));
  v5 = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(__int64 (***)(void))(v5 + 8);
  v2[4] = v5;
  v8 = *(_QWORD *)(v6 + 40);
  sub_2EC20(v7);
  v2[49] = 64LL;
  v2[51] = sub_B7CA0();
  sub_BD070(&v11, 0x72uLL);
  v10 = __readfsqword(0x28u);
  result = v10 ^ v12;
  if ( v10 != v12 )
LABEL_11:
    __assert_fail("!pi->generator", "sshprng.c", 0xC0u, "prng_seed_finish");
  return result;
}

unsigned __int64 __fastcall sub_77840(_QWORD *a1, char *a2, size_t a3)
{
  _QWORD *v3; // rbx
  size_t i; // rbp
  _QWORD *v5; // r12
  __int64 (__fastcall ***v6)(_QWORD, char *, signed __int64); // r15
  _QWORD *v7; // rsi
  unsigned int v8; // er12
  char v9; // cl
  __int64 v10; // rdx
  __int64 v11; // r13
  __int64 (__fastcall **v12)(_QWORD, char *, signed __int64); // rdx
  __int64 (__fastcall **v13)(_QWORD, char *, signed __int64); // rdx
  __int64 (__fastcall ***v14)(_QWORD, char *, signed __int64); // rdi
  size_t v15; // r15
  __int64 v16; // rax
  char *dest; // [rsp+0h] [rbp-C8h]
  char v19; // [rsp+10h] [rbp-B8h]
  unsigned __int64 v20; // [rsp+88h] [rbp-40h]

  v20 = __readfsqword(0x28u);
  dest = a2;
  if ( a1[7] )
    __assert_fail("!pi->keymaker", "sshprng.c", 0xDDu, "prng_read");
  v3 = a1;
  for ( i = a3; i; dest = (char *)memcpy(dest, &v19, v15) + v15 )
  {
    v5 = (_QWORD *)v3[4];
    v6 = (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(*(__int64 (__fastcall **)(_QWORD))*v5)(*v5);
    v7 = v5;
    v8 = 0;
    ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64), _QWORD *))(*v6)[2])(v6, v7);
    sub_2ECE0(v6[1], 71);
    do
    {
      v9 = v8;
      v10 = v8 >> 6;
      v8 += 8;
      sub_2ECE0(v6[1], v3[v10 + 5] >> v9);
    }
    while ( v8 != 128 );
    v11 = v3[5];
    v3[5] = v11 + 1;
    v12 = *v6;
    v3[6] += __CFADD__(v11, 1LL);
    ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64), char *))v12[3])(v6, &v19);
    v13 = *v6;
    v14 = v6;
    v15 = i;
    ((void (__fastcall *)(__int64 (__fastcall ***)(_QWORD, char *, signed __int64)))v13[4])(v14);
    v16 = v3[3];
    if ( *(_QWORD *)(v16 + 40) <= i )
      v15 = *(_QWORD *)(v16 + 40);
    i -= v15;
  }
  sub_BD070(&v19, 0x72uLL);
  sub_776B0((__int64)v3);
  sub_77730((__int64)v3);
  return __readfsqword(0x28u) ^ v20;
}

__int64 __fastcall sub_77BD0(const char *a1, _DWORD *a2)
{
  unsigned __int64 v2; // rax
  unsigned int v3; // edx
  _BYTE *v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+8h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v2 = strtoul(a1, &v5, 10);
  v3 = 0;
  if ( *a1 )
  {
    v3 = (unsigned int)v5;
    LOBYTE(v3) = v2 <= 0xFFFFFFFF && *v5 == 0;
    if ( (_BYTE)v3 )
      *a2 = v2;
  }
  return v3;
}

unsigned __int64 __fastcall sub_77C50(const char *a1)
{
  unsigned __int64 result; // rax
  _BYTE *v2; // [rsp+0h] [rbp-18h]
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  result = strtoul(a1, &v2, 10);
  if ( !*a1 || *v2 || result > 0x1554 )
    result = 0xFFFFFFFFLL;
  return result;
}

char *__fastcall sub_77CC0(char *s, __int64 a2, int a3)
{
  __int64 v3; // r12
  int v4; // ebp
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  signed __int64 v7; // rbx
  size_t v8; // rax
  unsigned int v9; // eax
  char *v10; // r15
  int v11; // er14
  char *v12; // rdx
  signed int v13; // ebx
  unsigned __int8 *v14; // rdi
  unsigned int v15; // eax
  const char *src; // [rsp+0h] [rbp-78h]
  char *v18; // [rsp+8h] [rbp-70h]
  __int64 v19; // [rsp+10h] [rbp-68h]
  __int64 v20; // [rsp+18h] [rbp-60h]
  __int64 v21; // [rsp+20h] [rbp-58h]
  int v22; // [rsp+28h] [rbp-50h]
  __int64 *v23; // [rsp+30h] [rbp-48h]
  unsigned __int64 v24; // [rsp+38h] [rbp-40h]

  v3 = a2;
  v4 = a3;
  src = s;
  v19 = a2;
  v24 = __readfsqword(0x28u);
  v20 = 0LL;
  v22 = 0;
  v21 = a3;
  v23 = &v19;
  sub_2F1D0((__int64)&v19);
  v6 = 17LL;
  if ( !*((_DWORD *)v23 + 6) )
    v6 = v5;
  v7 = 4 * ((v4 + 2) / 3) + 3LL;
  if ( !s )
  {
    v18 = (char *)sub_2F450(v7 + v6, 1uLL, 0LL);
    v15 = sub_BC2F0(v6);
    v10 = &v18[(signed int)__sprintf_chk(v18, 1LL, -1LL, "%.*s ", v15)];
    if ( v4 <= 0 )
      goto LABEL_12;
    goto LABEL_5;
  }
  v8 = strlen(s);
  v18 = (char *)sub_2F450(v8 + v7 + v6, 1uLL, 0LL);
  v9 = sub_BC2F0(v6);
  v10 = &v18[(signed int)__sprintf_chk(v18, 1LL, -1LL, "%.*s ", v9)];
  if ( v4 > 0 )
  {
LABEL_5:
    v11 = 0;
    do
    {
      v12 = v10;
      v13 = v4 - v11;
      if ( v4 - v11 > 3 )
        v13 = 3;
      v14 = (unsigned __int8 *)(v3 + v11);
      v10 += 4;
      v11 += v13;
      sub_BCA40(v14, v13, v12);
    }
    while ( v4 > v11 );
    if ( src )
      goto LABEL_10;
LABEL_12:
    *v10 = 0;
    return v18;
  }
LABEL_10:
  *v10 = 32;
  strcpy(v10 + 1, src);
  return v18;
}

signed __int64 __fastcall sub_77E90(__int64 *a1, _BYTE *a2)
{
  _BYTE *i; // rbx
  char v3; // al

  for ( i = a2; ; *(i - 1) = v3 )
  {
    v3 = sub_2F080(*a1);
    if ( v3 == 10 || v3 == 13 || *(_DWORD *)(*a1 + 24) )
      return 0LL;
    if ( v3 == 58 )
      break;
    if ( i == a2 + 39 )
      return 0LL;
    ++i;
  }
  if ( (unsigned __int8)sub_2F080(*a1) != 32 )
    return 0LL;
  *i = 0;
  return 1LL;
}

__int64 __fastcall sub_77F00(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  char *v4; // rax
  size_t v5; // rdx
  __int64 result; // rax

  v3 = a3;
  v4 = sub_2F040(*a1, a3);
  if ( *(_DWORD *)(*a1 + 24) )
    return 0LL;
  LOBYTE(result) = sub_BD140((const void *)a2, v3, v4, v5);
  return (unsigned int)result;
}

__int64 __fastcall sub_77F50(__int64 a1, _QWORD *a2, char a3, __int64 *a4, char *a5, _QWORD *a6)
{
  char v6; // r14
  _QWORD *v7; // r13
  __int64 v8; // rbx
  __int64 *v9; // r12
  unsigned int v10; // er15
  __int64 v12; // rdi
  unsigned __int8 v13; // al
  char *v14; // rax
  size_t v15; // rdx
  char *v16; // r8
  int v17; // ecx
  int v18; // ST1C_4
  size_t v19; // ST10_8
  char *v20; // ST08_8
  _BYTE *v21; // rax
  __int64 v22; // rdi
  unsigned __int64 v23; // ST08_8
  signed __int64 v24; // r12
  __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rax
  char v28; // r14
  char v29; // r15
  char v30; // al
  _QWORD *v31; // rax
  __int64 v32; // rdi
  _QWORD *v33; // rax
  __int64 v34; // rdi
  const char *s; // [rsp+0h] [rbp-78h]
  char sa; // [rsp+0h] [rbp-78h]
  int v37; // [rsp+8h] [rbp-70h]
  int v38; // [rsp+8h] [rbp-70h]
  char v39; // [rsp+20h] [rbp-58h]
  unsigned __int64 v40; // [rsp+38h] [rbp-40h]

  v6 = a3;
  v7 = a6;
  v8 = a1;
  v9 = a4;
  v40 = __readfsqword(0x28u);
  s = a5;
  v10 = 0;
  *a6 = "not an SSH-1 RSA file";
  if ( !(unsigned __int8)sub_77F00(
                           (__int64 *)(a1 + 32),
                           (__int64)"SSH PRIVATE KEY FILE FORMAT 1.1\n",
                           (unsigned __int64)&qword_20 + 1) )
    return v10;
  v12 = *(_QWORD *)(a1 + 32);
  *v7 = "file format error";
  v13 = sub_2F080(v12);
  LOBYTE(v10) = v13 != 0;
  if ( v13 != 3 && (_BYTE)v10 )
    return 0;
  v37 = v13;
  if ( sub_2F150(*(_QWORD *)(v8 + 32)) )
    return 0;
  sub_7CCA0(*(_QWORD *)(v8 + 32), (__int64)a2, 1);
  v14 = sub_2F1D0(*(_QWORD *)(v8 + 32));
  v16 = v14;
  v17 = v37;
  if ( v9 )
  {
    v18 = v37;
    v19 = v15;
    v20 = v14;
    v21 = sub_BD360(v14, v15);
    v17 = v18;
    v15 = v19;
    v16 = v20;
    *v9 = (__int64)v21;
  }
  v38 = v17;
  if ( !a2 )
  {
    if ( !v6 )
    {
      v10 = (unsigned __int8)v10;
      *v7 = 0LL;
      return v10;
    }
    return 1;
  }
  a2[7] = sub_BD360(v16, v15);
  if ( v6 )
    return 1;
  v22 = *(_QWORD *)(v8 + 32);
  if ( v38 )
  {
    v10 = 0;
    if ( (*(_BYTE *)(v22 + 16) - *(_BYTE *)(v22 + 8)) & 7 )
      return v10;
    v23 = *(_QWORD *)(v22 + 16) - *(_QWORD *)(v22 + 8);
    v24 = sub_BC650();
    sub_2F040(*(_QWORD *)(v8 + 32), v23);
    sub_2EC30((__int64 (**)(void))(v24 + 24));
    v25 = strlen(s);
    sub_5E520((__int64 (**)(void))off_320E40, (__int64)s, v25, (__int64)&v39);
    sub_5E3A0((const __m128i *)&v39, *(_QWORD *)(v24 + 8), v23);
    sub_BD070(&v39, 0x10uLL);
    v26 = *(_QWORD *)(v24 + 8);
    v27 = *(_QWORD *)(v24 + 16);
    v22 = v8;
    *(_QWORD *)(v8 + 8) = 0LL;
    *(_DWORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 32) = v8;
    *(_QWORD *)v8 = v26;
    *(_QWORD *)(v8 + 16) = v27;
  }
  else
  {
    v24 = 0LL;
  }
  v28 = sub_2F080(v22);
  sa = sub_2F080(*(_QWORD *)(v8 + 32));
  v29 = sub_2F080(*(_QWORD *)(v8 + 32));
  v30 = sub_2F080(*(_QWORD *)(v8 + 32));
  if ( v28 != v29 || sa != v30 )
  {
    v10 = -1;
    *v7 = "wrong passphrase";
  }
  else
  {
    sub_7CD50(*(_QWORD *)(v8 + 32), (__int64)a2);
    v31 = sub_337C0(*(_QWORD *)(v8 + 32));
    v32 = *(_QWORD *)(v8 + 32);
    a2[6] = v31;
    v33 = sub_337C0(v32);
    v34 = *(_QWORD *)(v8 + 32);
    a2[5] = v33;
    a2[4] = sub_337C0(v34);
    if ( (unsigned __int8)sub_7D450((_QWORD **)a2) )
    {
      *v7 = 0LL;
      v10 = 1;
    }
    else
    {
      v10 = 0;
      *v7 = "rsa_verify failed";
      sub_7D770(a2);
    }
  }
  if ( v24 )
    sub_BC660((void **)v24);
  return v10;
}

__int64 __fastcall sub_78240(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // rbx
  signed __int64 i; // r12
  int v4; // esi
  int v6; // eax

  v2 = a2;
  for ( i = sub_BC650(); ; sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(i + 24), v4) )
  {
    v4 = (unsigned __int8)sub_2F080(*v2);
    if ( v4 == 13 || v4 == 10 )
      break;
    if ( *(_DWORD *)(*v2 + 24) )
      return sub_BC6B0((__int64 *)i);
  }
  if ( !*(_DWORD *)(*v2 + 24) )
  {
    v6 = (unsigned __int8)sub_2F080(*v2);
    if ( (unsigned __int8)v6 != 13 && v6 != 10 && !*(_DWORD *)(*v2 + 24) )
      --*a1;
  }
  return sub_BC6B0((__int64 *)i);
}

_BOOL8 __fastcall sub_782D0(__int64 a1, signed int a2, __int64 (***a3)(void))
{
  __int64 (***v3)(void); // r13
  const char *v4; // rax
  char *v5; // r14
  signed int v6; // eax
  __int64 v7; // rbx
  signed __int64 v8; // r12
  _BOOL8 result; // rax
  int v10; // [rsp+0h] [rbp-68h]
  bool v11; // [rsp+7h] [rbp-61h]
  void *v12; // [rsp+18h] [rbp-50h]
  char v13; // [rsp+25h] [rbp-43h]
  unsigned __int64 v14; // [rsp+28h] [rbp-40h]

  v14 = __readfsqword(0x28u);
  if ( a2 > 5460 )
    goto LABEL_20;
  v3 = a3;
  v12 = sub_2F450(48 * a2, 1uLL, 0LL);
  if ( a2 <= 0 )
  {
LABEL_14:
    sub_2F4D0(v12);
    v11 = 1;
  }
  else
  {
    v10 = 0;
    while ( 1 )
    {
      v4 = (const char *)sub_78240((_QWORD *)(a1 + 8), (__int64 *)(a1 + 32));
      v5 = (char *)v4;
      if ( !v4 )
      {
        sub_2F4D0(v12);
        v11 = 0;
        goto LABEL_11;
      }
      v6 = strlen(v4);
      v11 = v6 > 64 || (v6 & 3) != 0;
      if ( v11 )
      {
        sub_2F4D0(v12);
        sub_2F4D0(v5);
        v11 = 0;
        goto LABEL_11;
      }
      if ( v6 > 0 )
        break;
LABEL_13:
      sub_2F4D0(v5);
      if ( a2 == ++v10 )
        goto LABEL_14;
    }
    v7 = (__int64)v5;
    v8 = (signed __int64)&v5[4 * ((unsigned int)(v6 - 1) >> 2) + 4];
    while ( (unsigned int)sub_BCB10(v7, &v13) )
    {
      v7 += 4LL;
      sub_2EC20(*v3);
      if ( v7 == v8 )
        goto LABEL_13;
    }
    sub_2F4D0(v5);
    sub_2F4D0(v12);
  }
LABEL_11:
  result = v11;
  if ( __readfsqword(0x28u) != v14 )
LABEL_20:
    __assert_fail("nlines < MAX_KEY_BLOB_LINES", "sshpubk.c", 0x20Eu, "read_blob");
  return result;
}

unsigned __int64 __fastcall sub_78470(unsigned int a1, unsigned __int64 *a2, unsigned __int64 *a3, __int16 *a4, unsigned __int64 a5, __int64 a6, __m128i a7, __m128i xmm1_0, _OWORD *a8, _OWORD *a9, char **a10, __int128 a11, __int64 a12)
{
  unsigned __int64 v13; // r14
  __int64 v14; // r12
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rsi
  unsigned int v17; // edx
  __int64 v18; // rdi
  unsigned int v19; // er8
  unsigned int v20; // eax
  __int64 v21; // rsi
  int v22; // eax
  __int64 v23; // rax
  __int64 v24; // rdx
  __int128 v25; // ax
  __int64 v26; // rdi
  __int128 v27; // ax
  __int64 v28; // rdi
  char *v29; // rdx
  int v31; // ebp
  unsigned int v32; // ebx
  unsigned __int64 v33; // rsi
  __int64 v34; // rax
  __int64 (***v35)(void); // r15
  int v36; // esi
  char *v37; // rax
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rsi
  __int64 v40; // rax
  __int64 (***v41)(void); // rbp
  char *v42; // rax
  __int128 v43; // ST10_16
  unsigned __int64 *v44; // [rsp+0h] [rbp-A8h]
  unsigned __int64 *v45; // [rsp+10h] [rbp-98h]
  int v46; // [rsp+3Ch] [rbp-6Ch]
  __int64 v47; // [rsp+40h] [rbp-68h]
  __int64 v48; // [rsp+48h] [rbp-60h]
  __int64 v49; // [rsp+50h] [rbp-58h]
  int v50; // [rsp+58h] [rbp-50h]
  __int64 *v51; // [rsp+60h] [rbp-48h]
  unsigned __int64 v52; // [rsp+68h] [rbp-40h]

  v44 = a2;
  v45 = a3;
  v52 = __readfsqword(0x28u);
  if ( a1 < 1 )
    goto LABEL_16;
  v13 = a5;
  v14 = a6;
  if ( a1 > 2 )
  {
    if ( a1 == 3 )
    {
      v15 = 0LL;
      v16 = *a2;
      if ( *v44 )
      {
        v17 = *(_DWORD *)(a12 + 16);
        v18 = *(unsigned int *)(a12 + 4);
        v19 = *(_DWORD *)v45 + v16 + 32;
        v20 = *(_DWORD *)(a12 + 20);
        v21 = *(unsigned int *)(a12 + 8);
        if ( *(_BYTE *)(a12 + 12) )
        {
          v15 = 32LL;
          sub_5E040(
            v18,
            v21,
            v17,
            (unsigned int *)&v46,
            v20,
            v19,
            a4,
            v13,
            (__int16 *)a11,
            *((unsigned __int64 *)&a11 + 1),
            (__int16 *)&locale,
            0LL,
            (__int16 *)&locale,
            0LL,
            a6);
          v22 = v46;
          v16 = *v44;
          *(_BYTE *)(a12 + 12) = 0;
          *(_DWORD *)(a12 + 16) = v22;
        }
        else
        {
          v15 = 32LL;
          *((_QWORD *)&v43 + 1) = v13;
          *(_QWORD *)&v43 = a4;
          sub_5DF90(v18, v21, v17, v20, v19, a6, a7, v43, a11, (unsigned __int64)&locale, xmm1_0);
          v16 = *v44;
        }
      }
      goto LABEL_7;
    }
LABEL_16:
    __assert_fail(
      "false && \"bad format version in ssh2_ppk_derive_keys\"",
      "sshpubk.c",
      0x294u,
      "ssh2_ppk_derive_keys");
  }
  v31 = 0;
  v32 = 20;
  v33 = *a2;
  if ( *v44 )
  {
    do
    {
      v34 = sub_7F880();
      v35 = (__int64 (***)(void))v34;
      if ( v34 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 8LL))(v34);
      v36 = v31++;
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v35[1], v36);
      sub_2EC30(v35[1]);
      v37 = sub_BC510(v14, 0x14uLL);
      ((void (__fastcall *)(__int64 (***)(void), char *))(*v35)[3])(v35, v37);
      ((void (__fastcall *)(__int64 (***)(void)))(*v35)[4])(v35);
      v38 = v32;
      v32 += 20;
      v33 = *v44;
    }
    while ( v38 < *v44 );
  }
  sub_BC590((__int64 *)v14, v33);
  v39 = *v45;
  sub_2EC40((void (__fastcall **)(_QWORD, __int64 *, signed __int64))(v14 + 24), *v45, 0);
  v40 = sub_7F880();
  v41 = (__int64 (***)(void))v40;
  if ( v40 )
    (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)v40 + 8LL))(v40, v39);
  v15 = (unsigned __int64)(*v41)[5];
  sub_2EC30(v41[1]);
  sub_2EC30(v41[1]);
  v42 = sub_BC510(v14, v15);
  ((void (__fastcall *)(__int64 (***)(void), char *))(*v41)[3])(v41, v42);
  ((void (__fastcall *)(__int64 (***)(void)))(*v41)[4])(v41);
  v16 = *v44;
LABEL_7:
  v23 = *(_QWORD *)(v14 + 16);
  v24 = *(_QWORD *)(v14 + 8);
  v48 = 0LL;
  v50 = 0;
  v51 = &v47;
  v47 = v24;
  v49 = v23;
  *(_QWORD *)&v25 = sub_2F040((__int64)&v47, v16);
  v26 = (__int64)v51;
  *a8 = v25;
  *(_QWORD *)&v27 = sub_2F040(v26, *v45);
  v28 = (__int64)v51;
  *a9 = v27;
  *a10 = sub_2F040(v28, v15);
  a10[1] = v29;
  return __readfsqword(0x28u) ^ v52;
}

unsigned __int64 __fastcall sub_787A0(__int64 (__fastcall ***a1)(_QWORD, char *, signed __int64), __int64 a2, signed int a3, signed int a4)
{
  __int64 (__fastcall ***v4)(_QWORD, char *, signed __int64); // rbp
  signed int v5; // er12
  signed int v6; // er14
  signed int v7; // ebx
  signed int v8; // er15
  __int64 v9; // r15
  __int64 (__fastcall **v10)(_QWORD, char *, signed __int64); // rdi
  char v11; // si
  unsigned __int8 *v13; // [rsp+8h] [rbp-50h]
  char v14[4]; // [rsp+14h] [rbp-44h]
  unsigned __int64 v15; // [rsp+18h] [rbp-40h]

  v4 = a1;
  v15 = __readfsqword(0x28u);
  v13 = (unsigned __int8 *)a2;
  if ( a3 > 0 )
  {
    v5 = a3;
    v6 = a4;
    v7 = 0;
    do
    {
      v8 = 3;
      if ( v5 <= 3 )
        v8 = v5;
      v5 -= v8;
      sub_BCA40(v13, v8, v14);
      v13 += v8;
      v9 = 0LL;
      do
      {
        v10 = *v4;
        if ( v6 <= v7 )
        {
          v7 = 1;
          sub_2ECE0(v10, 10);
          v10 = *v4;
        }
        else
        {
          ++v7;
        }
        v11 = v14[v9++];
        sub_2ECE0(v10, v11);
      }
      while ( v9 != 4 );
    }
    while ( v5 > 0 );
  }
  sub_2ECE0(*v4, 10);
  return __readfsqword(0x28u) ^ v15;
}

_QWORD *__fastcall sub_78880(__int64 a1)
{
  _QWORD *result; // rax

  result = sub_2F450(1uLL, 0x40uLL, a1);
  result[1] = 0LL;
  result[2] = a1;
  *result = result + 8;
  return result;
}

void __fastcall sub_788B0(_QWORD *a1)
{
  sub_BD070((void *)*a1, a1[2]);
  sub_BD070(a1, 0x40uLL);
  sub_2F4D0(a1);
}

signed __int64 __fastcall sub_788E0(__int64 *a1, FILE *a2)
{
  unsigned __int64 v2; // rdx
  __int64 *v3; // rbx
  unsigned __int64 v4; // rdi
  size_t v5; // r12
  signed __int64 result; // rax
  __int64 v7; // rdx
  int v8; // eax

  v2 = a1[2];
  v3 = a1;
  a1[1] = 0LL;
  v4 = 0LL;
  if ( !v2 )
    goto LABEL_13;
  do
  {
    v5 = fread((void *)(*v3 + v4), 1uLL, v2 - v4, a2);
    if ( ferror(a2) )
      return 2LL;
    v4 = v3[1];
    v2 = v3[2];
    if ( !v5 )
      break;
    v4 += v5;
    v3[1] = v4;
  }
  while ( v4 < v2 );
  if ( v2 != v4 )
  {
    result = 0LL;
  }
  else
  {
LABEL_13:
    v8 = fgetc(a2);
    v4 = v3[1];
    result = v8 != -1;
  }
  v7 = *v3;
  v3[5] = v4;
  v3[4] = 0LL;
  *((_DWORD *)v3 + 12) = 0;
  v3[3] = v7;
  v3[7] = (__int64)(v3 + 3);
  return result;
}

__int64 __usercall sub_789A0@<rax>(__int64 *a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<rbx>)
{
  unsigned int v3; // ebp
  FILE *v4; // rax
  FILE *v5; // rbx

  v3 = 2;
  v4 = sub_B5170(0, a3, (const char **)a2, "rb");
  if ( v4 )
  {
    v5 = v4;
    v3 = sub_788E0(a1, v4);
    fclose(v5);
  }
  return v3;
}

__int64 *__fastcall sub_789F0(__int64 a1, char **a2)
{
  __int64 *v2; // rax
  __int64 *v3; // rbx
  unsigned int v4; // eax
  int *v5; // rax
  char *v6; // rax
  __int64 *v7; // rdi

  v2 = (__int64 *)sub_2F450(1uLL, 0x40uLL, 353621LL);
  v3 = v2;
  *v2 = (__int64)(v2 + 8);
  v2[1] = 0LL;
  v2[2] = 353621LL;
  v4 = sub_789A0(v2, a1, (__int64)v2);
  if ( v4 == 1 )
  {
    v6 = "file is too large to be a key file";
  }
  else
  {
    if ( v4 < 1 )
      return v3;
    if ( v4 != 2 )
      sub_1AE96();
    v5 = __errno_location();
    v6 = strerror(*v5);
  }
  if ( a2 )
    *a2 = v6;
  v7 = v3;
  v3 = 0LL;
  sub_788B0(v7);
  return v3;
}

__int64 __fastcall sub_78B20(__int64 a1, _QWORD *a2, char *a3, char **a4)
{
  char *v4; // r13
  char **v5; // rbp
  __int64 *v6; // rbx
  __int64 result; // rax
  unsigned int v8; // ST0C_4

  v4 = a3;
  v5 = a4;
  v6 = sub_789F0(a1, a4);
  result = 0LL;
  if ( v6 )
  {
    v8 = sub_77F50((__int64)(v6 + 3), a2, 0, 0LL, v4, v5);
    sub_788B0(v6);
    result = v8;
  }
  return result;
}

bool __fastcall sub_78B80(__int64 a1, __int64 *a2)
{
  __int64 v3; // [rsp+0h] [rbp-18h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  return (unsigned int)sub_77F50(a1, 0LL, 0, a2, 0LL, &v3) == 1;
}

__int64 __fastcall sub_78BD0(__int64 a1, __int64 *a2)
{
  unsigned int v2; // ebp
  __int64 *v3; // rax
  __int64 *v4; // rbx
  __int64 v6; // [rsp+0h] [rbp-28h]
  unsigned __int64 v7; // [rsp+8h] [rbp-20h]

  v2 = 0;
  v7 = __readfsqword(0x28u);
  v3 = sub_789F0(a1, 0LL);
  if ( v3 )
  {
    v4 = v3;
    LOBYTE(v2) = (unsigned int)sub_77F50((__int64)(v3 + 3), 0LL, 0, a2, 0LL, &v6) == 1;
    sub_788B0(v4);
  }
  return v2;
}

signed __int64 __fastcall sub_78C50(__int64 a1, __int64 a2, __int64 *a3, const char **a4)
{
  __int64 *v4; // r12
  const char **v5; // rbp
  char v6; // r14
  signed __int64 result; // rax
  void *v8; // rax
  size_t v9; // rdx
  const char *v10; // rax
  char *v11; // rbx
  size_t v12; // rax
  char *v13; // r14
  size_t v14; // rax
  char *v15; // r15
  _BYTE *v16; // rax
  signed __int64 v17; // rcx
  __int64 v18; // r14
  signed __int64 v19; // rax
  char *v20; // rcx
  char *src; // [rsp+8h] [rbp-A0h]
  const char *v22; // [rsp+18h] [rbp-90h]
  __int128 v23; // [rsp+20h] [rbp-88h]
  __int128 v24; // [rsp+30h] [rbp-78h]
  __int128 v25; // [rsp+40h] [rbp-68h]
  __int128 v26; // [rsp+50h] [rbp-58h]
  __int64 v27; // [rsp+60h] [rbp-48h]
  unsigned __int64 v28; // [rsp+68h] [rbp-40h]

  v4 = a3;
  v5 = a4;
  v28 = __readfsqword(0x28u);
  v22 = 0LL;
  v6 = sub_77F00((__int64 *)(a1 + 32), (__int64)"SSH PRIVATE KEY FILE FORMAT 1.1\n", (unsigned __int64)&qword_20 + 1);
  sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
  if ( v6 )
  {
    v27 = 0LL;
    v23 = 0LL;
    v24 = 0LL;
    v25 = 0LL;
    v26 = 0LL;
    if ( (unsigned int)sub_77F50(a1, &v23, 1, v4, 0LL, &v22) )
    {
      sub_7D5B0(a2, (__int64)&v23, 0);
      sub_7D770(&v23);
      return 1LL;
    }
    goto LABEL_3;
  }
  v8 = (void *)sub_2F2D0(*(__int64 **)(a1 + 32));
  v10 = sub_BD360(v8, v9);
  v11 = (char *)v10;
  v12 = (size_t)&v10[strspn(v10, "0123456789")];
  if ( *(_BYTE *)v12 != 32 )
    goto LABEL_8;
  v13 = (char *)(v12 + 1);
  *(_BYTE *)v12 = 0;
  v14 = v12 + 1 + strspn((const char *)(v12 + 1), "0123456789");
  if ( *(_BYTE *)v14 != 32 )
    goto LABEL_8;
  v15 = (char *)(v14 + 1);
  *(_BYTE *)v14 = 0;
  v16 = (_BYTE *)(v14 + 1 + strspn((const char *)(v14 + 1), "0123456789"));
  if ( *v16 )
  {
    if ( *v16 != 32 )
    {
LABEL_8:
      sub_2F4D0(v11);
      v22 = "not an SSH-1 RSA file";
      goto LABEL_3;
    }
    v17 = (signed __int64)(v16 + 1);
    *v16 = 0;
  }
  else
  {
    v17 = 0LL;
  }
  src = (char *)v17;
  v27 = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  v26 = 0LL;
  *(_QWORD *)&v24 = sub_33DB0(v13);
  *((_QWORD *)&v23 + 1) = sub_33DB0(v15);
  v18 = (signed int)strtol(v11, 0LL, 10);
  v19 = sub_335B0(*((__int64 **)&v23 + 1));
  v20 = src;
  if ( v18 != v19 )
  {
    sub_330F0((_QWORD *)v24);
    sub_330F0(*((_QWORD **)&v23 + 1));
    sub_2F4D0(v11);
    v22 = "key bit count does not match in SSH-1 public key file";
LABEL_3:
    result = 0LL;
    if ( v5 )
      *v5 = v22;
    return result;
  }
  if ( v4 )
  {
    if ( src )
      v20 = sub_BC120(src);
    *v4 = (__int64)v20;
  }
  sub_7D5B0(a2, (__int64)&v23, 0);
  sub_7D770(&v23);
  sub_2F4D0(v11);
  return 1LL;
}

__int64 __fastcall sub_78EF0(__int64 a1, __int64 a2, __int64 *a3, char **a4)
{
  __int64 *v4; // r13
  const char **v5; // rbp
  __int64 *v6; // rbx
  __int64 result; // rax
  unsigned int v8; // ST0C_4

  v4 = a3;
  v5 = (const char **)a4;
  v6 = sub_789F0(a1, a4);
  result = 0LL;
  if ( v6 )
  {
    v8 = sub_78C50((__int64)(v6 + 3), a2, v4, v5);
    sub_788B0(v6);
    result = v8;
  }
  return result;
}

__int64 __fastcall sub_78F50(__int64 a1, unsigned __int64 a2)
{
  const char *v2; // r14
  signed __int64 v3; // rax
  __int64 (__fastcall **v4)(_QWORD, char *, signed __int64); // rbx
  signed __int64 v5; // r12
  char *v6; // rsi
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v10; // [rsp+0h] [rbp-58h]
  unsigned __int64 v11; // [rsp+18h] [rbp-40h]

  v2 = (const char *)a2;
  v11 = __readfsqword(0x28u);
  v3 = sub_BC650();
  v4 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v3 + 24);
  v5 = v3;
  sub_2EC30((__int64 (**)(void))(v3 + 24));
  sub_2ECE0(v4, a2 >= 1 ? 3 : 0);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v4, 0);
  sub_7D5B0((__int64)v4, a1, 1);
  v6 = *(char **)(a1 + 56);
  if ( !v6 )
    v6 = &locale;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))v4, v6);
  v7 = *(_QWORD *)(v5 + 16);
  sub_7BF50((char *)&v10, 2uLL);
  sub_2EC20((__int64 (**)(void))v4);
  sub_2EC20((__int64 (**)(void))v4);
  sub_33680((__int64)v4, *(__int64 **)(a1 + 24));
  sub_33680((__int64)v4, *(__int64 **)(a1 + 48));
  sub_33680((__int64)v4, *(__int64 **)(a1 + 40));
  sub_33680((__int64)v4, *(__int64 **)(a1 + 32));
  sub_2EC40((void (__fastcall **)(_QWORD, __int64 *, signed __int64))v4, ((_DWORD)v7 - *(_DWORD *)(v5 + 16)) & 7, 0);
  if ( v2 )
  {
    v8 = strlen(v2);
    sub_5E520((__int64 (**)(void))off_320E40, (__int64)v2, v8, (__int64)&v10);
    sub_5E3E0((const __m128i *)&v10, (signed int)v7 + *(_QWORD *)(v5 + 8), *(_DWORD *)(v5 + 16) - v7);
    sub_BD070(&v10, 0x10uLL);
  }
  return v5;
}

__int64 __usercall sub_790D0@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, unsigned __int64 a3@<rdx>, __int64 a4@<rbx>)
{
  unsigned __int64 v4; // r13
  unsigned int v5; // er12
  FILE *v6; // rax
  FILE *v7; // rbx
  __int64 v8; // rbp
  size_t v9; // r14
  __int64 v10; // r13

  v4 = a3;
  v5 = 0;
  v6 = sub_B5170(1, a4, (const char **)a1, "wb");
  if ( v6 )
  {
    v7 = v6;
    v8 = sub_78F50(a2, v4);
    v9 = fwrite(*(const void **)v8, 1uLL, *(_QWORD *)(v8 + 16), v7);
    v10 = *(_QWORD *)(v8 + 16);
    if ( !fclose(v7) )
      LOBYTE(v5) = v9 == v10;
    sub_BC660((void **)v8);
  }
  return v5;
}

__int64 (__fastcall *(*__fastcall sub_79160(void *s1, size_t n))[13])()
{
  __int64 (__fastcall *(**v2)[13])(); // rbx
  __int64 (__fastcall *(*v3)[13])(); // rbp

  v2 = off_3249A8;
  v3 = (__int64 (__fastcall *(*)[13])())off_3210C0;
  while ( !(unsigned __int8)sub_BD100(s1, n, (*v3)[13]) )
  {
    if ( v2 == &off_3249A8[8] )
      return 0LL;
    v3 = *v2;
    ++v2;
  }
  return v3;
}

__int64 __fastcall sub_791C0(__int64 a1)
{
  __int64 *v1; // rbp
  char v2; // al
  unsigned int v3; // ecx
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // al
  __int64 v9; // rdx
  __int64 v10; // rdx
  void *v11; // rax
  size_t v12; // rdx
  __int64 v13; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rdx
  __int64 v20; // rdx

  v1 = (__int64 *)(a1 + 32);
  sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
  v2 = sub_77F00((__int64 *)(a1 + 32), (__int64)"SSH PRIVATE KEY FILE FORMAT 1.1\n", (unsigned __int64)&qword_20 + 1);
  v3 = 2;
  if ( !v2 )
  {
    sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
    v4 = sub_77F00(v1, (__int64)"---- BEGIN SSH2 PUBLIC KEY", (unsigned __int64)&off_18 + 2);
    v3 = 9;
    if ( !v4 )
    {
      sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
      v5 = sub_77F00(v1, (__int64)"PuTTY-User-Key-File-", (unsigned __int64)&dword_14);
      v3 = 3;
      if ( !v5 )
      {
        sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
        v6 = sub_77F00(v1, (__int64)"-----BEGIN OPENSSH PRIVATE KEY", (unsigned __int64)&off_18 + 6);
        v3 = 6;
        if ( !v6 )
        {
          sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
          v7 = sub_77F00(v1, (__int64)"-----BEGIN ", (unsigned __int64)&byte_9[2]);
          v3 = 5;
          if ( !v7 )
          {
            sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
            v8 = sub_77F00(v1, (__int64)"---- BEGIN SSH2 ENCRYPTED PRIVAT", (unsigned __int64)&qword_20);
            v3 = 7;
            if ( !v8 )
            {
              sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
              sub_2F2B0(*(_QWORD *)(a1 + 32), "0123456789");
              if ( v9
                && (sub_2F2B0(*(_QWORD *)(a1 + 32), " "), v10 == 1)
                && (sub_2F2B0(*(_QWORD *)(a1 + 32), "0123456789"), v17)
                && (sub_2F2B0(*(_QWORD *)(a1 + 32), " "), v18 == 1)
                && (sub_2F2B0(*(_QWORD *)(a1 + 32), "0123456789"), v19)
                && (sub_2F2C0(*(_QWORD *)(a1 + 32)), !v20) )
              {
                v3 = 8;
              }
              else
              {
                sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
                sub_2F2C0(*(_QWORD *)(a1 + 32));
                if ( !sub_79160(v11, v12)
                  || (sub_2F2B0(*(_QWORD *)(a1 + 32), " "), v13 != 1)
                  || (sub_2F2B0(
                        *(_QWORD *)(a1 + 32),
                        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/="),
                      !v15)
                  || (sub_2F2C0(*(_QWORD *)(a1 + 32)), v3 = 10, v16) )
                {
                  v3 = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

__int64 (__fastcall *(*__fastcall sub_79410(void *s1))[13])()
{
  size_t v1; // rax

  v1 = strlen((const char *)s1);
  return sub_79160(s1, v1);
}

_QWORD *__usercall sub_79430@<rax>(const char **a1@<rdx>, __int64 a2@<rdi>, char *a3@<rsi>, unsigned __int8 *a4@<r15>, __m128i a5@<xmm1>)
{
  __int64 v5; // r12
  __int64 *v6; // rbp
  const char **v7; // r13
  char v8; // al
  bool v9; // cf
  bool v10; // zf
  const char *v11; // rdi
  signed __int64 v12; // rcx
  char *v13; // rsi
  char v14; // al
  bool v15; // cf
  bool v16; // zf
  const char *v17; // rdi
  signed __int64 v18; // rcx
  char *v19; // rsi
  char v20; // al
  bool v21; // cf
  bool v22; // zf
  _QWORD *v23; // r14
  unsigned __int8 *v24; // rax
  unsigned __int8 *v25; // rdi
  char v26; // al
  bool v27; // cf
  bool v28; // zf
  const char *v29; // rdi
  signed __int64 v30; // rcx
  char *v31; // rsi
  __int64 v32; // rax
  bool v33; // cf
  bool v34; // zf
  _BYTE *v35; // rsi
  const char *v36; // rdi
  signed __int64 v37; // rcx
  _BYTE *v38; // rdx
  char v39; // al
  bool v40; // cf
  bool v41; // zf
  const char *v42; // rdi
  signed __int64 v43; // rcx
  _BYTE *v44; // rsi
  char v45; // al
  bool v46; // cf
  bool v47; // zf
  const char *v48; // rdi
  signed __int64 v49; // rcx
  char *v50; // rsi
  char v51; // al
  bool v52; // cf
  bool v53; // zf
  const char *v54; // rdi
  signed __int64 v55; // rcx
  char *v56; // rsi
  const char *v57; // rax
  char *v58; // ST60_8
  signed int v59; // er15
  char v60; // al
  bool v61; // cf
  bool v62; // zf
  const char *v63; // rdi
  signed __int64 v64; // rcx
  char *v65; // rsi
  unsigned __int8 *v66; // rax
  signed int v67; // ST60_4
  signed int v68; // er15
  char v69; // al
  bool v70; // cf
  bool v71; // zf
  const char *v72; // rdi
  signed __int64 v73; // rcx
  char *v74; // rsi
  char v75; // al
  bool v76; // cf
  bool v77; // zf
  const char *v78; // rdi
  signed __int64 v79; // rcx
  char *v80; // rsi
  __int128 v81; // cx
  __int64 v82; // ST90_8
  size_t v83; // rax
  unsigned __int64 v84; // r8
  __int64 v85; // rcx
  signed __int64 v86; // rbp
  __int64 (__fastcall **v87)(); // r14
  __int64 (***v88)(void); // rbx
  __int64 v89; // rdx
  void *v90; // rsi
  signed __int64 v91; // rbx
  char *v92; // r12
  char *v93; // rdi
  int v94; // eax
  const char *v95; // rbx
  _QWORD *v96; // rbp
  const char *v97; // rdi
  signed __int64 v98; // rcx
  char *v99; // rsi
  char v100; // al
  bool v101; // cf
  bool v102; // zf
  const char *v103; // rdi
  char *v104; // rsi
  signed __int64 v105; // rcx
  _QWORD *result; // rax
  char v107; // al
  bool v108; // cf
  bool v109; // zf
  const char *v110; // rdi
  signed __int64 v111; // rcx
  char *v112; // rsi
  unsigned __int8 *v113; // rax
  bool v114; // cf
  bool v115; // zf
  const char *v116; // rdi
  unsigned __int8 *v117; // rsi
  signed __int64 v118; // rcx
  char v119; // al
  bool v120; // cf
  bool v121; // zf
  char v122; // al
  bool v123; // cf
  bool v124; // zf
  const char *v125; // rdi
  signed __int64 v126; // rcx
  char *v127; // rsi
  unsigned __int8 *v128; // rdi
  char v129; // al
  bool v130; // cf
  bool v131; // zf
  const char *v132; // rdi
  signed __int64 v133; // rcx
  char *v134; // rsi
  char v135; // al
  bool v136; // cf
  bool v137; // zf
  const char *v138; // rdi
  signed __int64 v139; // rcx
  char *v140; // rsi
  unsigned __int8 *v141; // rax
  char v142; // al
  bool v143; // cf
  bool v144; // zf
  const char *v145; // rdi
  signed __int64 v146; // rcx
  char *v147; // rsi
  unsigned __int8 *v148; // rax
  unsigned __int8 v149; // ST60_1
  const unsigned __int16 **v150; // rax
  unsigned __int8 v151; // dl
  const unsigned __int16 **v152; // rbp
  unsigned __int8 *v153; // rbx
  __int64 v154; // rax
  unsigned __int8 v155; // al
  char v156; // al
  signed __int64 v157; // rax
  void (__fastcall **v158)(_QWORD, char *, signed __int64); // rbx
  __int64 v159; // rax
  const char *v160; // rdi
  signed __int64 v161; // rcx
  unsigned __int8 *v162; // rsi
  char v163; // al
  bool v164; // cf
  bool v165; // zf
  const char *v166; // rdi
  signed __int64 v167; // rcx
  unsigned __int8 *v168; // rsi
  void *v169; // rdi
  signed __int64 v170; // [rsp+8h] [rbp-1A0h]
  unsigned __int8 *v171; // [rsp+10h] [rbp-198h]
  char *s; // [rsp+18h] [rbp-190h]
  unsigned int v173; // [rsp+20h] [rbp-188h]
  __int64 v174; // [rsp+20h] [rbp-188h]
  char *v175; // [rsp+28h] [rbp-180h]
  signed __int64 v176; // [rsp+30h] [rbp-178h]
  __int64 *v177; // [rsp+30h] [rbp-178h]
  __int64 (__fastcall *(*v178)[13])(); // [rsp+38h] [rbp-170h]
  signed __int64 v179; // [rsp+40h] [rbp-168h]
  char **v180; // [rsp+48h] [rbp-160h]
  char v181; // [rsp+50h] [rbp-158h]
  char v182; // [rsp+58h] [rbp-150h]
  __int64 v183; // [rsp+70h] [rbp-138h]
  __int64 v184; // [rsp+80h] [rbp-128h]
  __int64 v185; // [rsp+90h] [rbp-118h]
  __int64 v186; // [rsp+98h] [rbp-110h]
  __int128 v187; // [rsp+A0h] [rbp-108h]
  __int128 v188; // [rsp+B0h] [rbp-F8h]
  __int64 v189; // [rsp+C0h] [rbp-E8h]
  char v190; // [rsp+CFh] [rbp-D9h]
  char v191; // [rsp+D0h] [rbp-D8h]
  char v192; // [rsp+F0h] [rbp-B8h]
  char nptr; // [rsp+120h] [rbp-88h]
  __int16 v194; // [rsp+121h] [rbp-87h]
  unsigned __int64 v195; // [rsp+168h] [rbp-40h]

  v5 = a2;
  v6 = (__int64 *)(a2 + 32);
  v7 = a1;
  s = a3;
  v195 = __readfsqword(0x28u);
  v170 = sub_BC640();
  v8 = sub_77E90((__int64 *)(a2 + 32), &v192);
  v9 = 0;
  v10 = v8 == 0;
  if ( !v8 )
  {
    v95 = "no header line found in key file";
    goto LABEL_95;
  }
  v11 = "PuTTY-User-Key-File-3";
  v12 = 22LL;
  v13 = &v192;
  do
  {
    if ( !v12 )
      break;
    v9 = (unsigned __int8)*v13 < *v11;
    v10 = *v13++ == *v11++;
    --v12;
  }
  while ( v10 );
  v14 = (!v9 && !v10) - v9;
  v15 = 0;
  v16 = v14 == 0;
  if ( v14 )
  {
    v17 = "PuTTY-User-Key-File-2";
    v18 = 22LL;
    v19 = &v192;
    do
    {
      if ( !v18 )
        break;
      v15 = (unsigned __int8)*v19 < *v17;
      v16 = *v19++ == *v17++;
      --v18;
    }
    while ( v16 );
    v20 = (!v15 && !v16) - v15;
    v21 = 0;
    v22 = v20 == 0;
    if ( v20 )
    {
      v97 = "PuTTY-User-Key-File-1";
      v98 = 22LL;
      v99 = &v192;
      do
      {
        if ( !v98 )
          break;
        v21 = (unsigned __int8)*v99 < *v97;
        v22 = *v99++ == *v97++;
        --v98;
      }
      while ( v22 );
      v100 = (!v21 && !v22) - v21;
      v101 = 0;
      v102 = v100 == 0;
      if ( v100 )
      {
        v103 = "PuTTY-User-Key-File-";
        v104 = &v192;
        v105 = 20LL;
        v95 = "PuTTY key format too new";
        do
        {
          if ( !v105 )
            break;
          v101 = (unsigned __int8)*v104 < *v103;
          v102 = *v104++ == *v103++;
          --v105;
        }
        while ( v102 );
        if ( (!v101 && !v102) != v101 )
          v95 = "not a PuTTY SSH-2 private key";
        goto LABEL_95;
      }
      nullsub_39();
      v173 = 1;
    }
    else
    {
      v173 = 2;
    }
  }
  else
  {
    v173 = 3;
  }
  v23 = (_QWORD *)(v5 + 8);
  v24 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
  a4 = v24;
  if ( !v24 )
  {
LABEL_102:
    v95 = "file format error";
LABEL_95:
    v96 = 0LL;
    goto LABEL_96;
  }
  v178 = sub_79410(v24);
  v25 = a4;
  if ( !v178 )
  {
LABEL_101:
    sub_2F4D0(v25);
    goto LABEL_102;
  }
  sub_2F4D0(a4);
  v26 = sub_77E90(v6, &v192);
  v27 = 0;
  v28 = v26 == 0;
  if ( !v26 )
    goto LABEL_102;
  v29 = "Encryption";
  v30 = 11LL;
  v31 = &v192;
  do
  {
    if ( !v30 )
      break;
    v27 = (unsigned __int8)*v31 < *v29;
    v28 = *v31++ == *v29++;
    --v30;
  }
  while ( v28 );
  if ( (!v27 && !v28) != v27 )
    goto LABEL_102;
  v32 = sub_78240((_QWORD *)(v5 + 8), v6);
  v33 = 0;
  v34 = v32 == 0;
  v35 = (_BYTE *)v32;
  if ( !v32 )
    goto LABEL_102;
  v36 = "aes256-cbc";
  v37 = 11LL;
  v38 = (_BYTE *)v32;
  v171 = (unsigned __int8 *)v32;
  do
  {
    if ( !v37 )
      break;
    v33 = *v35 < (const unsigned __int8)*v36;
    v34 = *v35++ == *v36++;
    --v37;
  }
  while ( v34 );
  v39 = (!v33 && !v34) - v33;
  v40 = 0;
  v41 = v39 == 0;
  if ( v39 )
  {
    v42 = "none";
    v43 = 5LL;
    v44 = v38;
    do
    {
      if ( !v43 )
        break;
      v40 = *v44 < (const unsigned __int8)*v42;
      v41 = *v44++ == *v42++;
      --v43;
    }
    while ( v41 );
    if ( (!v40 && !v41) != v40 )
      goto LABEL_100;
    v180 = &off_320F20;
  }
  else
  {
    v180 = &off_320F00;
  }
  v45 = sub_77E90(v6, &v192);
  v46 = 0;
  v47 = v45 == 0;
  if ( !v45 )
    goto LABEL_100;
  v48 = "Comment";
  v49 = 8LL;
  v50 = &v192;
  do
  {
    if ( !v49 )
      break;
    v46 = (unsigned __int8)*v50 < *v48;
    v47 = *v50++ == *v48++;
    --v49;
  }
  while ( v47 );
  if ( (!v46 && !v47) != v46 )
  {
LABEL_100:
    v25 = v171;
    goto LABEL_101;
  }
  v175 = (char *)sub_78240((_QWORD *)(v5 + 8), v6);
  if ( !v175 )
  {
    v96 = 0LL;
    v95 = "file format error";
    sub_2F4D0(v171);
    goto LABEL_96;
  }
  v189 = 0LL;
  v187 = 0LL;
  v188 = 0LL;
  v51 = sub_77E90(v6, &v192);
  v52 = 0;
  v53 = v51 == 0;
  if ( !v51 )
    goto LABEL_193;
  v54 = "Public-Lines";
  v55 = 13LL;
  v56 = &v192;
  do
  {
    if ( !v55 )
      break;
    v52 = (unsigned __int8)*v56 < *v54;
    v53 = *v56++ == *v54++;
    --v55;
  }
  while ( v53 );
  if ( (!v52 && !v53) != v52
    || (v57 = (const char *)sub_78240((_QWORD *)(v5 + 8), v6)) == 0LL
    || (v58 = (char *)v57, v59 = sub_77C50(v57), sub_2F4D0(v58), v59 < 0) )
  {
LABEL_193:
    v95 = "file format error";
    v5 = 0LL;
    v176 = 0LL;
    v179 = 0LL;
    v96 = 0LL;
    a4 = 0LL;
    goto LABEL_105;
  }
  v179 = sub_BC640();
  if ( !(unsigned __int8)sub_782D0(v5, v59, (__int64 (***)(void))(v179 + 32)) )
    goto LABEL_161;
  if ( v173 == 3 && v180[2] )
  {
    v107 = sub_77E90(v6, &v192);
    v108 = 0;
    v109 = v107 == 0;
    if ( !v107 )
      goto LABEL_161;
    v110 = "Key-Derivation";
    v111 = 15LL;
    v112 = &v192;
    do
    {
      if ( !v111 )
        break;
      v108 = (unsigned __int8)*v112 < *v110;
      v109 = *v112++ == *v110++;
      --v111;
    }
    while ( v109 );
    if ( (!v108 && !v109) != v108 )
      goto LABEL_161;
    v113 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
    v114 = 0;
    v115 = v113 == 0LL;
    a4 = v113;
    if ( !v113 )
      goto LABEL_178;
    v116 = "Argon2d";
    v117 = v113;
    v118 = 8LL;
    do
    {
      if ( !v118 )
        break;
      v114 = *v117 < *v116;
      v115 = *v117++ == *v116++;
      --v118;
    }
    while ( v115 );
    v119 = (!v114 && !v115) - v114;
    v120 = 0;
    v121 = v119 == 0;
    if ( v119 )
    {
      v160 = "Argon2i";
      v161 = 8LL;
      v162 = a4;
      do
      {
        if ( !v161 )
          break;
        v120 = *v162 < *v160;
        v121 = *v162++ == *v160++;
        --v161;
      }
      while ( v121 );
      v163 = (!v120 && !v121) - v120;
      v164 = 0;
      v165 = v163 == 0;
      if ( v163 )
      {
        v166 = "Argon2id";
        v167 = 9LL;
        v168 = a4;
        do
        {
          if ( !v167 )
            break;
          v164 = *v168 < *v166;
          v165 = *v168++ == *v166++;
          --v167;
        }
        while ( v165 );
        if ( (!v164 && !v165) != v164 )
          goto LABEL_159;
        DWORD1(v187) = 2;
      }
      else
      {
        DWORD1(v187) = 1;
      }
    }
    else
    {
      DWORD1(v187) = 0;
    }
    sub_2F4D0(a4);
    v122 = sub_77E90(v6, &v192);
    v123 = 0;
    v124 = v122 == 0;
    if ( !v122 )
      goto LABEL_161;
    v125 = "Argon2-Memory";
    v126 = 14LL;
    v127 = &v192;
    do
    {
      if ( !v126 )
        break;
      v123 = (unsigned __int8)*v127 < *v125;
      v124 = *v127++ == *v125++;
      --v126;
    }
    while ( v124 );
    if ( (!v123 && !v124) != v123 )
      goto LABEL_161;
    a4 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
    if ( !a4 )
      goto LABEL_178;
    v128 = a4;
    if ( !(unsigned __int8)sub_77BD0((const char *)a4, (_DWORD *)&v187 + 2) )
      goto LABEL_160;
    sub_2F4D0(a4);
    v129 = sub_77E90(v6, &v192);
    v130 = 0;
    v131 = v129 == 0;
    if ( !v129 )
      goto LABEL_161;
    v132 = "Argon2-Passes";
    v133 = 14LL;
    v134 = &v192;
    do
    {
      if ( !v133 )
        break;
      v130 = (unsigned __int8)*v134 < *v132;
      v131 = *v134++ == *v132++;
      --v133;
    }
    while ( v131 );
    if ( (!v130 && !v131) != v130 )
      goto LABEL_161;
    a4 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
    if ( !a4 )
      goto LABEL_178;
    v128 = a4;
    if ( !(unsigned __int8)sub_77BD0((const char *)a4, &v188) )
      goto LABEL_160;
    sub_2F4D0(a4);
    v135 = sub_77E90(v6, &v192);
    v136 = 0;
    v137 = v135 == 0;
    if ( !v135 )
      goto LABEL_161;
    v138 = "Argon2-Parallelism";
    v139 = 19LL;
    v140 = &v192;
    do
    {
      if ( !v139 )
        break;
      v136 = (unsigned __int8)*v140 < *v138;
      v137 = *v140++ == *v138++;
      --v139;
    }
    while ( v137 );
    if ( (!v136 && !v137) != v136 )
      goto LABEL_161;
    v141 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
    a4 = v141;
    if ( !v141 )
      goto LABEL_178;
    v128 = v141;
    if ( !(unsigned __int8)sub_77BD0((const char *)v141, (_DWORD *)&v188 + 1) )
    {
LABEL_160:
      sub_2F4D0(v128);
      goto LABEL_161;
    }
    sub_2F4D0(a4);
    v142 = sub_77E90(v6, &v192);
    v143 = 0;
    v144 = v142 == 0;
    if ( !v142 )
      goto LABEL_161;
    v145 = "Argon2-Salt";
    v146 = 12LL;
    v147 = &v192;
    do
    {
      if ( !v146 )
        break;
      v143 = (unsigned __int8)*v147 < *v145;
      v144 = *v147++ == *v145++;
      --v146;
    }
    while ( v144 );
    if ( (!v143 && !v144) != v143 )
      goto LABEL_161;
    v148 = (unsigned __int8 *)sub_78240((_QWORD *)(v5 + 8), v6);
    a4 = v148;
    if ( !v148 )
      goto LABEL_178;
    if ( !*v148 )
    {
LABEL_188:
      sub_2F4D0(a4);
      goto LABEL_44;
    }
    v149 = *v148;
    v150 = __ctype_b_loc();
    v151 = v149;
    v177 = v6;
    v152 = v150;
    v153 = a4 + 1;
    while ( (*v152)[v151] & 0x1000 )
    {
      v154 = *v153;
      if ( !(_BYTE)v154 || !((*v152)[v154] & 0x1000) )
        break;
      nptr = v151;
      v155 = *v153;
      v153 += 2;
      v194 = v155;
      v156 = strtoul(&nptr, 0LL, 16);
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v170 + 24), v156);
      v151 = *(v153 - 1);
      if ( !v151 )
      {
        v6 = v177;
        v23 = (_QWORD *)(v5 + 8);
        goto LABEL_188;
      }
    }
LABEL_159:
    v128 = a4;
    goto LABEL_160;
  }
LABEL_44:
  v60 = sub_77E90(v6, &v192);
  v61 = 0;
  v62 = v60 == 0;
  if ( !v60 )
    goto LABEL_161;
  v63 = "Private-Lines";
  v64 = 14LL;
  v65 = &v192;
  do
  {
    if ( !v64 )
      break;
    v61 = (unsigned __int8)*v65 < *v63;
    v62 = *v65++ == *v63++;
    --v64;
  }
  while ( v62 );
  if ( (!v61 && !v62) != v61 )
    goto LABEL_161;
  v66 = (unsigned __int8 *)sub_78240(v23, v6);
  a4 = v66;
  if ( !v66 )
  {
LABEL_178:
    v95 = "file format error";
    v5 = 0LL;
    v176 = 0LL;
    v96 = 0LL;
    goto LABEL_105;
  }
  v67 = sub_77C50((const char *)v66);
  sub_2F4D0(a4);
  v68 = v67;
  if ( v67 < 0 )
  {
LABEL_161:
    v95 = "file format error";
    v5 = 0LL;
    v176 = 0LL;
    v96 = 0LL;
    a4 = 0LL;
    goto LABEL_105;
  }
  v176 = sub_BC650();
  if ( !(unsigned __int8)sub_782D0(v5, v68, (__int64 (***)(void))(v176 + 32)) )
    goto LABEL_165;
  v69 = sub_77E90(v6, &v192);
  v70 = 0;
  v71 = v69 == 0;
  v181 = v69;
  if ( !v69 )
    goto LABEL_165;
  v72 = "Private-MAC";
  v73 = 12LL;
  v74 = &v192;
  do
  {
    if ( !v73 )
      break;
    v70 = (unsigned __int8)*v74 < *v72;
    v71 = *v74++ == *v72++;
    --v73;
  }
  while ( v71 );
  v75 = (!v70 && !v71) - v70;
  v76 = 0;
  v77 = v75 == 0;
  if ( v75 )
  {
    v78 = "Private-Hash";
    v79 = 13LL;
    v80 = &v192;
    do
    {
      if ( !v79 )
        break;
      v76 = (unsigned __int8)*v80 < *v78;
      v77 = *v80++ == *v78++;
      --v79;
    }
    while ( v77 );
    if ( v173 == 1 && (!v76 && !v77) == v76 )
    {
      a4 = (unsigned __int8 *)sub_78240(v23, v6);
      if ( a4 )
      {
        v182 = 0;
        goto LABEL_64;
      }
LABEL_186:
      v95 = "file format error";
      v5 = 0LL;
      v96 = 0LL;
      goto LABEL_105;
    }
LABEL_165:
    v95 = "file format error";
    v5 = 0LL;
    v96 = 0LL;
    a4 = 0LL;
    goto LABEL_105;
  }
  a4 = (unsigned __int8 *)sub_78240(v23, v6);
  if ( !a4 )
    goto LABEL_186;
  v182 = v181;
LABEL_64:
  v5 = sub_BC640();
  v81 = *(_OWORD *)(v170 + 8);
  if ( s )
  {
    v82 = *(_QWORD *)(v170 + 8);
    v83 = strlen(s);
    *(_QWORD *)&v81 = v82;
    v84 = v83;
  }
  else
  {
    v84 = 0LL;
    s = &locale;
  }
  sub_78470(
    v173,
    (unsigned __int64 *)v180 + 2,
    (unsigned __int64 *)v180 + 3,
    (__int16 *)s,
    v84,
    v5,
    (__m128i)0LL,
    a5,
    &v183,
    &v184,
    (char **)&v185,
    v81,
    (__int64)&v187);
  v85 = *(_QWORD *)(v176 + 16);
  if ( *(_QWORD *)(v176 + 16) % (unsigned __int64)v180[1] )
  {
    v95 = "file format error";
    v96 = 0LL;
    goto LABEL_105;
  }
  if ( v180 == &off_320F00 )
    sub_5E360(v183, v184, *(_QWORD *)(v176 + 8), v85);
  if ( v173 == 3 )
  {
    v87 = off_320DE0;
LABEL_168:
    v157 = sub_BC650();
    v158 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v157 + 24);
    v86 = v157;
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v157 + 24), (char *)(*v178)[13]);
    sub_2EF40(v158, (char *)v171);
    sub_2EF40(v158, v175);
    sub_2EE80(v158, *(char **)v179, *(_QWORD *)(v179 + 16));
    sub_2EE80(v158, *(char **)v176, *(_QWORD *)(v176 + 16));
    goto LABEL_72;
  }
  if ( v173 != 1 )
  {
    v87 = off_320D20;
    goto LABEL_168;
  }
  v86 = v176;
  v87 = off_320D20;
  v181 = 0;
LABEL_72:
  if ( v182 )
  {
    v88 = (__int64 (***)(void))((__int64 (__fastcall *)(__int64 (__fastcall **)(), _QWORD))*v87)(v87, 0LL);
    ((void (__fastcall *)(__int64 (***)(void), __int64, __int64))(*v88)[2])(v88, v185, v186);
    ((void (__fastcall *)(__int64 (***)(void)))(*v88)[3])(v88);
    v89 = *(_QWORD *)(v86 + 16);
    v90 = *(void **)v86;
    sub_2EC20(v88[1]);
    ((void (__fastcall *)(__int64 (***)(void), char *))(*v88)[4])(v88, &v191);
    ((void (__fastcall *)(__int64 (***)(void)))(*v88)[1])(v88);
  }
  else
  {
    sub_5E520((__int64 (**)(void))&off_3215A0, *(_QWORD *)(v86 + 8), *(_QWORD *)(v86 + 16), (__int64)&v191);
  }
  if ( v181 )
    sub_BC660((void **)v86);
  if ( *((_DWORD *)v87 + 16) > 0 )
  {
    v174 = v5;
    v91 = 1LL;
    v92 = &nptr;
    do
    {
      v93 = v92;
      v92 += 2;
      __sprintf_chk(v93, 1LL, -1LL, "%02x", (unsigned __int8)*(&v190 + v91));
      v94 = v91++;
    }
    while ( *((_DWORD *)v87 + 16) > v94 );
    v5 = v174;
  }
  if ( !strcmp((const char *)a4, &nptr) )
  {
    v96 = sub_2F450(1uLL, 0x10uLL, 0LL);
    v96[1] = v175;
    v159 = ((__int64 (__fastcall *)(__int64 (__fastcall *(*)[13])(), _QWORD, _QWORD, _QWORD, _QWORD))(*v178)[1])(
             v178,
             *(_QWORD *)(v179 + 8),
             *(_QWORD *)(v179 + 16),
             *(_QWORD *)(v176 + 8),
             *(_QWORD *)(v176 + 16));
    *v96 = v159;
    if ( !v159 )
      goto LABEL_189;
    v95 = 0LL;
    goto LABEL_171;
  }
  v95 = "wrong passphrase";
  v96 = &unk_326440;
  if ( !v180[2] )
    v95 = "MAC failed";
  if ( !v180[2] )
    v96 = 0LL;
LABEL_105:
  sub_2F4D0(v175);
  sub_2F4D0(v171);
  if ( !a4 )
    goto LABEL_107;
  while ( 1 )
  {
    sub_2F4D0(a4);
LABEL_107:
    if ( v179 )
      sub_BC660((void **)v179);
    if ( v176 )
      sub_BC660((void **)v176);
    if ( v5 )
      sub_BC660((void **)v5);
LABEL_96:
    sub_BC660((void **)v170);
    if ( v7 )
      *v7 = v95;
    result = v96;
    if ( __readfsqword(0x28u) == v195 )
      break;
LABEL_189:
    v169 = v96;
    v95 = "createkey failed";
    v96 = 0LL;
    sub_2F4D0(v169);
LABEL_171:
    sub_2F4D0(v171);
  }
  return result;
}

_QWORD *__usercall sub_7A080@<rax>(char **a1@<rdx>, __int64 a2@<rdi>, char *a3@<rsi>, unsigned __int8 *a4@<r15>, __m128i a5@<xmm1>)
{
  char **v5; // rbp
  __int64 *v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // rbp

  v5 = a1;
  v6 = sub_789F0(a2, a1);
  if ( v6 )
  {
    v7 = v6;
    v8 = sub_79430((const char **)v5, (__int64)(v6 + 3), a3, a4, a5);
    sub_788B0(v7);
  }
  else
  {
    *v5 = "can't open file";
    v8 = 0LL;
  }
  return v8;
}

__int64 __fastcall sub_7A0D0(__int64 a1, _QWORD *a2, __int64 a3, char ***a4, const char **a5)
{
  char ***v5; // r15
  const char **v6; // r12
  __int64 v7; // rbx
  int v8; // ebp
  const char *v9; // rax
  _BOOL4 v10; // ebx
  __int64 result; // rax
  void *v12; // rax
  size_t v13; // rdx
  _BYTE *v14; // rax
  bool v15; // cf
  bool v16; // zf
  const char *v17; // rdi
  signed __int64 v18; // rcx
  _BYTE *v19; // rsi
  const char *v20; // rbp
  void *v21; // rax
  size_t v22; // rdx
  const char *v23; // rax
  char *v24; // rax
  const char *v25; // rbx
  char *v26; // rax
  int v27; // ebp
  int v28; // er14
  unsigned int *v29; // r13
  __int64 v30; // rdi
  int v31; // eax
  const char *v32; // rbx
  signed __int32 v33; // edx
  char v34; // al
  bool v35; // cf
  bool v36; // zf
  const char *v37; // rdi
  signed __int64 v38; // rcx
  char *v39; // rsi
  char v40; // al
  bool v41; // cf
  bool v42; // zf
  const char *v43; // rdi
  signed __int64 v44; // rcx
  char *v45; // rsi
  char v46; // al
  bool v47; // cf
  bool v48; // zf
  const char *v49; // rdi
  signed __int64 v50; // rcx
  char *v51; // rsi
  char v52; // al
  const char *v53; // rdi
  signed __int64 v54; // rcx
  char *v55; // rsi
  char *v56; // rax
  char *v57; // ST20_8
  char v58; // al
  bool v59; // cf
  bool v60; // zf
  const char *v61; // rdi
  signed __int64 v62; // rcx
  char *v63; // rsi
  void *v64; // rax
  char **v65; // rax
  char *v66; // rcx
  char v67; // al
  char *v68; // rcx
  int v69; // eax
  const char *v70; // rdi
  signed __int64 v71; // rcx
  _BYTE *v72; // rsi
  bool v73; // cf
  bool v74; // zf
  char v75; // al
  bool v76; // cf
  bool v77; // zf
  const char *v78; // rdi
  signed __int64 v79; // rcx
  _BYTE *v80; // rsi
  void *v81; // rax
  size_t v82; // rdx
  const char *v83; // rax
  _BYTE *v84; // r13
  char *v85; // rax
  bool v86; // cf
  bool v87; // zf
  char *v88; // r9
  signed __int64 v89; // rcx
  _BYTE *v90; // rsi
  const char *v91; // rdi
  char v92; // al
  char v93; // cl
  char *v94; // rdx
  _BYTE *v95; // rsi
  char v96; // cl
  char *v97; // rax
  char v98; // cl
  char *v99; // ST20_8
  size_t v100; // rax
  char *v101; // rax
  int v102; // er14
  char v103; // al
  bool v104; // cf
  bool v105; // zf
  char *v106; // rbp
  __int64 v107; // rdx
  void *v108; // rax
  size_t v109; // rdx
  const char *v110; // rdi
  signed __int64 v111; // rcx
  _BYTE *v112; // rsi
  unsigned __int64 v113; // rax
  __int64 v114; // rsi
  __int64 v115; // rdx
  __int64 v116; // rsi
  const char *v117; // rax
  char *v118; // rbp
  signed int v119; // er13
  char *v120; // ST20_8
  _QWORD *v121; // [rsp+8h] [rbp-B0h]
  __int64 v122; // [rsp+10h] [rbp-A8h]
  char **v123; // [rsp+18h] [rbp-A0h]
  char *s; // [rsp+20h] [rbp-98h]
  char *sa; // [rsp+20h] [rbp-98h]
  char *v126; // [rsp+28h] [rbp-90h]
  signed __int64 v127; // [rsp+38h] [rbp-80h]
  char v128; // [rsp+4Dh] [rbp-6Bh]
  char s1[40]; // [rsp+50h] [rbp-68h]
  unsigned __int64 v130; // [rsp+78h] [rbp-40h]

  v5 = a4;
  v6 = a5;
  v7 = a1;
  v121 = a2;
  v122 = a3;
  v130 = __readfsqword(0x28u);
  v8 = sub_791C0(a1);
  sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
  if ( v8 != 9 )
  {
    if ( v8 == 10 )
    {
      v21 = (void *)sub_2F2D0(*(__int64 **)(a1 + 32));
      v23 = sub_BD360(v21, v22);
      s = (char *)v23;
      v24 = strchr(v23, 32);
      v123 = (char **)v24;
      if ( v24 )
      {
        v25 = v24 + 1;
        *v24 = 0;
        v26 = strchr(v24 + 1, 32);
        v123 = (char **)v26;
        if ( v26 )
        {
          *v26 = 0;
          v123 = (char **)sub_BC120(v26 + 1);
        }
        v27 = 0;
        v28 = 3 * (strlen(v25) >> 2);
        v29 = (unsigned int *)sub_2F450(v28, 1uLL, 0LL);
        while ( !memchr(v25, 0, 4uLL) )
        {
          if ( v28 <= v27 + 2 )
            __assert_fail("pubbloblen + 3 <= pubblobsize", "sshpubk.c", 0x48Du, "openssh_loadpub");
          v30 = (__int64)v25;
          v25 += 4;
          v27 += sub_BCB10(v30, (_BYTE *)v29 + v27);
        }
        if ( *v25 )
        {
          v32 = "invalid length for base64 data in OpenSSH public key file";
        }
        else
        {
          v31 = strlen(s);
          if ( v27 <= v31 + 3 )
          {
            v32 = "key algorithms do not match in OpenSSH public key file";
          }
          else
          {
            v32 = "key algorithms do not match in OpenSSH public key file";
            v33 = _byteswap_ulong(*v29);
            if ( v33 == v31 && !memcmp(v29 + 1, s, v33) )
            {
              if ( a2 )
                *a2 = sub_BC120(s);
              if ( v5 )
                *v5 = v123;
              else
                sub_2F4D0(v123);
              v10 = 1;
              sub_2F4D0(s);
              sub_2EC20(*(__int64 (***)(void))(v122 + 8));
              sub_2F4D0(v29);
              goto LABEL_8;
            }
          }
        }
      }
      else
      {
        v29 = 0LL;
        v32 = "no key blob in OpenSSH public key file";
      }
      sub_2F4D0(s);
      sub_2F4D0(v123);
      sub_2F4D0(v29);
      if ( v6 )
        *v6 = v32;
    }
    else
    {
      if ( v8 != 3 )
      {
LABEL_4:
        v9 = "not a PuTTY SSH-2 private key";
        goto LABEL_5;
      }
      v34 = sub_77E90((__int64 *)(a1 + 32), s1);
      v35 = 0;
      v36 = v34 == 0;
      if ( !v34 )
        goto LABEL_144;
      v37 = "PuTTY-User-Key-File-3";
      v38 = 22LL;
      v39 = s1;
      do
      {
        if ( !v38 )
          break;
        v35 = (unsigned __int8)*v39 < *v37;
        v36 = *v39++ == *v37++;
        --v38;
      }
      while ( v36 );
      v40 = (!v35 && !v36) - v35;
      v41 = 0;
      v42 = v40 == 0;
      if ( v40 )
      {
        v43 = "PuTTY-User-Key-File-2";
        v44 = 22LL;
        v45 = s1;
        do
        {
          if ( !v44 )
            break;
          v41 = (unsigned __int8)*v45 < *v43;
          v42 = *v45++ == *v43++;
          --v44;
        }
        while ( v42 );
        v46 = (!v41 && !v42) - v41;
        v47 = 0;
        v48 = v46 == 0;
        if ( v46 )
        {
          v49 = "PuTTY-User-Key-File-1";
          v50 = 22LL;
          v51 = s1;
          do
          {
            if ( !v50 )
              break;
            v47 = (unsigned __int8)*v51 < *v49;
            v48 = *v51++ == *v49++;
            --v50;
          }
          while ( v48 );
          v52 = (!v47 && !v48) - v47;
          v35 = 0;
          v36 = v52 == 0;
          if ( v52 )
          {
LABEL_144:
            v53 = "PuTTY-User-Key-File-";
            v54 = 20LL;
            v55 = s1;
            v9 = "PuTTY key format too new";
            do
            {
              if ( !v54 )
                break;
              v35 = (unsigned __int8)*v55 < *v53;
              v36 = *v55++ == *v53++;
              --v54;
            }
            while ( v36 );
            if ( (!v35 && !v36) == v35 )
              goto LABEL_5;
            goto LABEL_4;
          }
        }
      }
      v56 = (char *)sub_78240((_QWORD *)(v7 + 8), (__int64 *)(v7 + 32));
      if ( !v56 )
        goto LABEL_145;
      v57 = v56;
      v123 = (char **)sub_79410(v56);
      sub_2F4D0(v57);
      if ( !v123 )
        goto LABEL_145;
      v58 = sub_77E90((__int64 *)(v7 + 32), s1);
      v59 = 0;
      v60 = v58 == 0;
      if ( !v58 )
        goto LABEL_145;
      v61 = "Encryption";
      v62 = 11LL;
      v63 = s1;
      do
      {
        if ( !v62 )
          break;
        v59 = (unsigned __int8)*v63 < *v61;
        v60 = *v63++ == *v61++;
        --v62;
      }
      while ( v60 );
      if ( (!v59 && !v60) != v59
        || (v64 = (void *)sub_78240((_QWORD *)(v7 + 8), (__int64 *)(v7 + 32))) == 0LL
        || (sub_2F4D0(v64), !(unsigned __int8)sub_77E90((__int64 *)(v7 + 32), s1))
        || strcmp(s1, "Comment")
        || (v65 = (char **)sub_78240((_QWORD *)(v7 + 8), (__int64 *)(v7 + 32)), (v66 = (char *)v65) == 0LL) )
      {
LABEL_145:
        v9 = "file format error";
LABEL_5:
        if ( v6 )
          *v6 = v9;
        goto LABEL_7;
      }
      if ( v5 )
      {
        *v5 = v65;
      }
      else
      {
        v120 = (char *)v65;
        sub_2F4D0(v65);
        v66 = v120;
      }
      sa = v66;
      v67 = sub_77E90((__int64 *)(v7 + 32), s1);
      v68 = sa;
      if ( v67 )
      {
        v69 = strcmp(s1, "Public-Lines");
        v68 = sa;
        if ( !v69 )
        {
          v117 = (const char *)sub_78240((_QWORD *)(v7 + 8), (__int64 *)(v7 + 32));
          v118 = (char *)v117;
          v68 = sa;
          if ( v117 )
          {
            v119 = sub_77C50(v117);
            sub_2F4D0(v118);
            v68 = sa;
            if ( v119 >= 0 )
            {
              v10 = sub_782D0(v7, v119, (__int64 (***)(void))(v122 + 8));
              v68 = sa;
              if ( (_BYTE)v10 )
              {
                if ( v121 )
                  *v121 = sub_BC120(v123[13]);
                goto LABEL_8;
              }
            }
          }
        }
      }
      if ( v6 )
        *v6 = "file format error";
      if ( v5 )
      {
        v10 = 0;
        sub_2F4D0(v68);
        *v5 = 0LL;
        goto LABEL_8;
      }
    }
LABEL_7:
    v10 = 0;
    goto LABEL_8;
  }
  v12 = (void *)sub_2F2D0(*(__int64 **)(a1 + 32));
  v14 = sub_BD360(v12, v13);
  v15 = 0;
  v16 = v14 == 0LL;
  if ( !v14 )
  {
    v20 = "invalid begin line in SSH-2 public key file";
    sub_2F4D0(0LL);
    sub_2F4D0(0LL);
    goto LABEL_16;
  }
  v17 = "---- BEGIN SSH2 PUBLIC KEY ----";
  v18 = 32LL;
  v19 = v14;
  do
  {
    if ( !v18 )
      break;
    v15 = *v19 < (const unsigned __int8)*v17;
    v16 = *v19++ == *v17++;
    --v18;
  }
  while ( v16 );
  if ( (!v15 && !v16) != v15 )
  {
    v20 = "invalid begin line in SSH-2 public key file";
    sub_2F4D0(v14);
    sub_2F4D0(0LL);
    goto LABEL_16;
  }
  sub_2F4D0(v14);
  v123 = 0LL;
  while ( 1 )
  {
    v81 = (void *)sub_2F2D0(*(__int64 **)(v7 + 32));
    v83 = sub_BD360(v81, v82);
    v84 = v83;
    if ( !v83 )
    {
      v20 = "truncated SSH-2 public key file";
LABEL_105:
      sub_2F4D0(v84);
      sub_2F4D0(v123);
      goto LABEL_16;
    }
    v85 = strstr(v83, ": ");
    v86 = 0;
    v87 = v85 == 0LL;
    v88 = v85;
    if ( !v85 )
      break;
    *v85 = 0;
    v89 = 8LL;
    v90 = v84;
    v91 = "Comment";
    do
    {
      if ( !v89 )
        break;
      v86 = *v90 < (const unsigned __int8)*v91;
      v87 = *v90++ == *v91++;
      --v89;
    }
    while ( v87 );
    v92 = (!v86 && !v87) - v86;
    v73 = 0;
    v74 = v92 == 0;
    if ( !v92 )
    {
      v93 = v88[2];
      v94 = v88 + 2;
      if ( v93 != 34 )
        goto LABEL_93;
      v126 = v88;
      v99 = v88 + 2;
      v100 = strlen(v88 + 2);
      v94 = v99;
      v93 = 34;
      v101 = &v99[v100 - 1];
      if ( *v101 != 34 )
        goto LABEL_146;
      *v101 = 0;
      v94 = v126 + 3;
      v93 = v126[3];
LABEL_93:
      if ( v93 )
      {
LABEL_146:
        v95 = v84;
        do
        {
          while ( 1 )
          {
            if ( v93 == 92 )
            {
              v98 = v94[1];
              if ( v98 )
                break;
            }
            v96 = *v94;
            ++v95;
            v97 = v94++;
            *(v95 - 1) = v96;
            v93 = v97[1];
            if ( !v93 )
              goto LABEL_99;
          }
          *(++v95 - 1) = v98;
          v93 = v94[2];
          v94 += 2;
        }
        while ( v93 );
      }
      else
      {
        v95 = v84;
      }
LABEL_99:
      *v95 = 0;
      sub_2F4D0(v123);
      v123 = (char **)sub_BC120(v84);
      goto LABEL_85;
    }
    v70 = "Subject";
    v71 = 8LL;
    v72 = v84;
    do
    {
      if ( !v71 )
        break;
      v73 = *v72 < (const unsigned __int8)*v70;
      v74 = *v72++ == *v70++;
      --v71;
    }
    while ( v74 );
    v75 = (!v73 && !v74) - v73;
    v76 = 0;
    v77 = v75 == 0;
    if ( v75 )
    {
      v78 = "x-";
      v79 = 2LL;
      v80 = v84;
      do
      {
        if ( !v79 )
          break;
        v76 = *v80 < (const unsigned __int8)*v78;
        v77 = *v80++ == *v78++;
        --v79;
      }
      while ( v77 );
      if ( (!v76 && !v77) != v76 )
      {
        v20 = "unrecognised header in SSH-2 public key file";
        goto LABEL_105;
      }
    }
LABEL_85:
    sub_2F4D0(v84);
  }
  v127 = sub_BC640();
  v102 = 0;
  while ( 1 )
  {
    v103 = *v84;
    v104 = *v84 < 0x2Du;
    v105 = *v84 == 45;
    if ( *v84 == 45 )
      break;
    v106 = v84;
    if ( v103 )
    {
      do
      {
        while ( 1 )
        {
          v107 = v102++;
          s1[v107] = v103;
          if ( v102 == 4 )
            break;
          v103 = *++v106;
          if ( !*v106 )
            goto LABEL_113;
        }
        ++v106;
        sub_BCB10((__int64)s1, &v128);
        v102 = 0;
        sub_2EC20((__int64 (**)(void))(v127 + 24));
        v103 = *v106;
      }
      while ( *v106 );
    }
LABEL_113:
    sub_2F4D0(v84);
    v108 = (void *)sub_2F2D0(*(__int64 **)(v7 + 32));
    v84 = sub_BD360(v108, v109);
    if ( !v84 )
      goto LABEL_114;
  }
  v110 = "---- END SSH2 PUBLIC KEY ----";
  v111 = 30LL;
  v112 = v84;
  do
  {
    if ( !v111 )
      break;
    v104 = *v112 < (const unsigned __int8)*v110;
    v105 = *v112++ == *v110++;
    --v111;
  }
  while ( v105 );
  if ( (!v104 && !v105) == v104 )
  {
    sub_2F4D0(v84);
    v113 = *(_QWORD *)(v127 + 16);
    if ( v113 <= 3 )
    {
      v20 = "not enough data in SSH-2 public key file";
    }
    else
    {
      v114 = _byteswap_ulong(**(_DWORD **)(v127 + 8));
      if ( (signed int)v114 >= 0 && (signed int)v114 <= v113 - 4 )
      {
        if ( v121 )
          *v121 = sub_BC360((__int64)"%.*s", v114, *(_QWORD *)v127 + 4LL);
        if ( !v5 )
          goto LABEL_135;
        *v5 = v123;
        goto LABEL_128;
      }
      v20 = "invalid algorithm prefix in SSH-2 public key file";
    }
    sub_2F4D0(0LL);
    sub_2F4D0(v123);
    goto LABEL_115;
  }
LABEL_114:
  v20 = "invalid end line in SSH-2 public key file";
  sub_2F4D0(v84);
  sub_2F4D0(v123);
  if ( !v127 )
    goto LABEL_16;
LABEL_115:
  sub_BC660((void **)v127);
LABEL_16:
  v10 = 0;
  if ( v6 )
    *v6 = v20;
LABEL_8:
  while ( 1 )
  {
    result = (unsigned int)v10;
    if ( __readfsqword(0x28u) == v130 )
      break;
LABEL_135:
    sub_2F4D0(v123);
LABEL_128:
    v115 = *(_QWORD *)(v127 + 16);
    v116 = *(_QWORD *)(v127 + 8);
    sub_2EC30(*(__int64 (***)(void))(v122 + 8));
    v10 = 1;
    sub_BC660((void **)v127);
  }
  return result;
}

__int64 __fastcall sub_7AA40(__int64 a1, _QWORD *a2, __int64 a3, char ***a4, char **a5)
{
  char ***v5; // r14
  __int64 v6; // r13
  const char **v7; // rbp
  __int64 *v8; // rbx
  __int64 result; // rax
  unsigned __int8 v10; // ST0F_1

  v5 = a4;
  v6 = a3;
  v7 = (const char **)a5;
  v8 = sub_789F0(a1, a5);
  result = 0LL;
  if ( v8 )
  {
    v10 = sub_7A0D0((__int64)(v8 + 3), a2, v6, v5, v7);
    sub_788B0(v8);
    result = v10;
  }
  return result;
}

__int64 __fastcall sub_7AAA0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r13
  __int64 v3; // rbp
  __int64 *v4; // r12
  char v5; // al
  bool v6; // cf
  bool v7; // zf
  const char *v8; // rdi
  signed __int64 v9; // rcx
  char *v10; // rsi
  char v11; // al
  bool v12; // cf
  bool v13; // zf
  const char *v14; // rdi
  signed __int64 v15; // rcx
  char *v16; // rsi
  char v17; // al
  bool v18; // cf
  bool v19; // zf
  _QWORD *v20; // rbp
  void *v21; // rax
  unsigned int v22; // eax
  bool v23; // cf
  bool v24; // zf
  unsigned int v25; // er14
  const char *v26; // rdi
  signed __int64 v27; // rcx
  char *v28; // rsi
  void *v29; // r15
  unsigned __int8 v30; // al
  bool v31; // cf
  bool v32; // zf
  const char *v33; // rdi
  signed __int64 v34; // rcx
  char *v35; // rsi
  const char *v36; // rdi
  signed __int64 v37; // rcx
  char *v38; // rsi
  void *v40; // rax
  bool v41; // cf
  bool v42; // zf
  const char *v43; // rdi
  signed __int64 v44; // rcx
  _BYTE *v45; // rsi
  unsigned __int8 v46; // [rsp+Fh] [rbp-69h]
  char v47; // [rsp+10h] [rbp-68h]
  unsigned __int64 v48; // [rsp+38h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  v48 = __readfsqword(0x28u);
  if ( a2 )
    *a2 = 0LL;
  v4 = (__int64 *)(a1 + 32);
  v5 = sub_77E90((__int64 *)(a1 + 32), &v47);
  v6 = 0;
  v7 = v5 == 0;
  if ( !v5 )
    goto LABEL_42;
  v8 = "PuTTY-User-Key-File-3";
  v9 = 22LL;
  v10 = &v47;
  do
  {
    if ( !v9 )
      break;
    v6 = (unsigned __int8)*v10 < *v8;
    v7 = *v10++ == *v8++;
    --v9;
  }
  while ( v7 );
  v11 = (!v6 && !v7) - v6;
  v12 = 0;
  v13 = v11 == 0;
  if ( v11 )
  {
    v14 = "PuTTY-User-Key-File-2";
    v15 = 22LL;
    v16 = &v47;
    do
    {
      if ( !v15 )
        break;
      v12 = (unsigned __int8)*v16 < *v14;
      v13 = *v16++ == *v14++;
      --v15;
    }
    while ( v13 );
    v17 = (!v12 && !v13) - v12;
    v18 = 0;
    v19 = v17 == 0;
    if ( v17 )
    {
      v36 = "PuTTY-User-Key-File-1";
      v37 = 22LL;
      v38 = &v47;
      do
      {
        if ( !v37 )
          break;
        v18 = (unsigned __int8)*v38 < *v36;
        v19 = *v38++ == *v36++;
        --v37;
      }
      while ( v19 );
      if ( (!v18 && !v19) != v18 )
        goto LABEL_42;
    }
  }
  v20 = (_QWORD *)(v3 + 8);
  v21 = (void *)sub_78240(v20, v4);
  if ( !v21 )
    goto LABEL_42;
  sub_2F4D0(v21);
  v22 = sub_77E90(v4, &v47);
  v23 = 0;
  v24 = (_BYTE)v22 == 0;
  v25 = v22;
  if ( !(_BYTE)v22 )
    goto LABEL_42;
  v26 = "Encryption";
  v27 = 11LL;
  v28 = &v47;
  do
  {
    if ( !v27 )
      break;
    v23 = (unsigned __int8)*v28 < *v26;
    v24 = *v28++ == *v26++;
    --v27;
  }
  while ( v24 );
  if ( (!v23 && !v24) == v23 && (v29 = (void *)sub_78240(v20, v4)) != 0LL )
  {
    v30 = sub_77E90(v4, &v47);
    v31 = 0;
    v32 = v30 == 0;
    if ( v30 )
    {
      v33 = "Comment";
      v34 = 8LL;
      v35 = &v47;
      do
      {
        if ( !v34 )
          break;
        v31 = (unsigned __int8)*v35 < *v33;
        v32 = *v35++ == *v33++;
        --v34;
      }
      while ( v32 );
      if ( (!v31 && !v32) == v31 )
      {
        v46 = v30;
        v40 = (void *)sub_78240(v20, v4);
        if ( !v40 )
        {
          sub_2F4D0(v29);
          return v46;
        }
        v41 = 0;
        v42 = v2 == 0LL;
        if ( v2 )
          *v2 = v40;
        else
          sub_2F4D0(v40);
        v43 = "aes256-cbc";
        v44 = 11LL;
        v45 = v29;
        do
        {
          if ( !v44 )
            break;
          v41 = *v45 < (const unsigned __int8)*v43;
          v42 = *v45++ == *v43++;
          --v44;
        }
        while ( v42 );
        LOBYTE(v25) = (!v41 && !v42) == v41;
      }
    }
    sub_2F4D0(v29);
  }
  else
  {
LABEL_42:
    v25 = 0;
  }
  return v25;
}

__int64 __fastcall sub_7AC70(__int64 a1, _QWORD *a2)
{
  __int64 *v2; // rax
  __int64 *v3; // rbx
  unsigned __int8 v4; // ST0F_1
  __int64 result; // rax

  v2 = sub_789F0(a1, 0LL);
  if ( v2 )
  {
    v3 = v2;
    v4 = sub_7AAA0((__int64)(v2 + 3), a2);
    sub_788B0(v3);
    result = v4;
  }
  else
  {
    result = 0LL;
    if ( a2 )
      *a2 = 0LL;
  }
  return result;
}

__int64 __fastcall sub_7AD60(char **a1, const char *a2, const __m128i *a3, double a4, __m128i a5)
{
  char **v5; // r14
  const __m128i *v6; // rbx
  signed __int64 v7; // r13
  signed __int64 v8; // r12
  char **v9; // rax
  signed int v10; // ecx
  const char *v11; // rax
  __int64 v12; // rdi
  size_t v13; // rdx
  __int64 v14; // rax
  __m128i v15; // xmm0
  __int64 v16; // rax
  __int64 v17; // r9
  __int64 v18; // r10
  __int64 v19; // ST70_8
  __int64 v20; // ST78_8
  size_t v21; // rax
  unsigned __int64 v22; // r8
  char *v23; // rcx
  __int64 (__fastcall **v24)(); // rbp
  __int128 v25; // ST18_16
  signed __int64 v26; // rax
  void (__fastcall **v27)(_QWORD, char *, signed __int64); // rbx
  signed __int64 v28; // ST70_8
  __int64 v29; // rbx
  signed __int64 v30; // r14
  int v31; // eax
  __int64 result; // rax
  const char *v33; // rdx
  unsigned __int64 v34; // r15
  __int64 v35; // rdx
  char *v36; // rax
  char *dest; // [rsp+0h] [rbp-118h]
  void *desta; // [rsp+0h] [rbp-118h]
  __int64 v39; // [rsp+8h] [rbp-110h]
  char *v40; // [rsp+18h] [rbp-100h]
  void **v41; // [rsp+20h] [rbp-F8h]
  int v42; // [rsp+34h] [rbp-E4h]
  char **v43; // [rsp+38h] [rbp-E0h]
  __int64 v44; // [rsp+50h] [rbp-C8h]
  __int64 v45; // [rsp+58h] [rbp-C0h]
  __int64 v46; // [rsp+60h] [rbp-B8h]
  __int64 v47; // [rsp+70h] [rbp-A8h]
  __int64 v48; // [rsp+78h] [rbp-A0h]
  __m128i v49; // [rsp+80h] [rbp-98h]
  __m128i v50; // [rsp+90h] [rbp-88h]
  __int64 v51; // [rsp+A0h] [rbp-78h]
  char v52; // [rsp+AFh] [rbp-69h]
  char v53; // [rsp+B0h] [rbp-68h]
  unsigned __int64 v54; // [rsp+D8h] [rbp-40h]

  v5 = a1;
  v6 = a3;
  v54 = __readfsqword(0x28u);
  v7 = sub_BC640();
  (*(void (__fastcall **)(char *, signed __int64))(*(_QWORD *)*a1 + 56LL))(*a1, v7 + 24);
  v8 = sub_BC650();
  (*(void (__fastcall **)(char *, signed __int64))(*(_QWORD *)*v5 + 64LL))(*v5, v8 + 24);
  v9 = &off_320F00;
  if ( !a2 )
    v9 = &off_320F20;
  v43 = v9;
  v11 = "aes256-cbc";
  if ( !a2 )
    v11 = "none";
  v40 = (char *)v11;
  v10 = (unsigned __int64)a2 < 1 ? 1 : 16;
  v42 = v10 + *(_DWORD *)(v8 + 16) - 1 - (v10 + *(_DWORD *)(v8 + 16) - 1) % v10;
  dest = (char *)sub_2F450(v42, 1uLL, 0LL);
  memset(dest, 0, v42);
  memcpy(dest, *(const void **)(v8 + 8), *(_QWORD *)(v8 + 16));
  sub_5E520((__int64 (**)(void))&off_3215A0, *(_QWORD *)(v8 + 8), *(_QWORD *)(v8 + 16), (__int64)&v53);
  v12 = *(_QWORD *)(v8 + 16);
  v13 = v42 - v12;
  if ( v13 > 0x13 )
    goto LABEL_39;
  memcpy(&dest[v12], &v53, v13);
  v14 = v6[2].m128i_i64[0];
  v49 = _mm_loadu_si128(v6);
  v15 = _mm_loadu_si128(v6 + 1);
  v51 = v14;
  v50 = v15;
  v16 = sub_BC640();
  v39 = v16;
  if ( v49.m128i_i32[0] == 3 )
  {
    if ( v50.m128i_i64[1] )
    {
      sub_2EC20((__int64 (**)(void))(v16 + 24));
    }
    else
    {
      v36 = sub_BC510(v16, 0x10uLL);
      sub_7BF50(v36, 0x10uLL);
    }
  }
  v41 = (void **)sub_BC640();
  v17 = *(_QWORD *)(v39 + 8);
  v18 = *(_QWORD *)(v39 + 16);
  if ( a2 )
  {
    v19 = *(_QWORD *)(v39 + 8);
    v20 = *(_QWORD *)(v39 + 16);
    v21 = strlen(a2);
    v17 = v19;
    v18 = v20;
    v22 = v21;
    v23 = (char *)a2;
  }
  else
  {
    v22 = 0LL;
    v23 = &locale;
  }
  v24 = off_320DE0;
  *((_QWORD *)&v25 + 1) = v18;
  *(_QWORD *)&v25 = v17;
  sub_78470(
    v49.m128i_u32[0],
    (unsigned __int64 *)v43 + 2,
    (unsigned __int64 *)v43 + 3,
    (__int16 *)v23,
    v22,
    (__int64)v41,
    v15,
    a5,
    &v44,
    &v46,
    (char **)&v47,
    v25,
    (__int64)&v49);
  if ( v49.m128i_i32[0] == 2 )
    v24 = off_320D20;
  v26 = sub_BC650();
  v27 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v26 + 24);
  v28 = v26;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v26 + 24), *(char **)(*(_QWORD *)*v5 + 104LL));
  sub_2EF40(v27, v40);
  sub_2EF40(v27, v5[1]);
  sub_2EE80(v27, *(char **)v7, *(_QWORD *)(v7 + 16));
  sub_2EE80(v27, dest, v42);
  sub_5E580(
    (__int64 (__fastcall **)(_QWORD, _QWORD))v24,
    v47,
    v48,
    *(_QWORD *)(v28 + 8),
    *(_QWORD *)(v28 + 16),
    (__int64)&v53);
  sub_BC660((void **)v28);
  if ( a2 )
  {
    if ( v45 != 32 )
      __assert_fail("cipherkey.len == 32", "sshpubk.c", 0x60Bu, "ppk_save_sb");
    sub_5E320(v44, v46, (__int64)dest, v42);
  }
  v29 = sub_BC650();
  sub_BC720(v29, (__int64)"PuTTY-User-Key-File-%u: %s\n", v49.m128i_u32[0], *(_QWORD *)(*(_QWORD *)*v5 + 104LL), dest);
  sub_BC720(v29, (__int64)"Encryption: %s\n", v40);
  sub_BC720(v29, (__int64)"Comment: %s\n", v5[1]);
  sub_BC720(v29, (__int64)"Public-Lines: %d\n", (*(_DWORD *)(v7 + 16) + 47) / 48);
  sub_787A0(
    (__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v29 + 32),
    *(_QWORD *)(v7 + 8),
    *(_DWORD *)(v7 + 16),
    64);
  if ( v49.m128i_i32[0] == 3 && v43[2] )
  {
    v33 = "Argon2d";
    if ( v49.m128i_i32[1] )
    {
      v33 = "Argon2id";
      if ( v49.m128i_i32[1] == 1 )
        v33 = "Argon2i";
    }
    sub_BC720(v29, (__int64)"Key-Derivation: %s\n", v33);
    sub_BC720(v29, (__int64)"Argon2-Memory: %u\n", v49.m128i_u32[2]);
    if ( v49.m128i_i8[12] )
      __assert_fail("!params.argon2_passes_auto", "sshpubk.c", 0x61Cu, "ppk_save_sb");
    sub_BC720(v29, (__int64)"Argon2-Passes: %u\n", v50.m128i_u32[0]);
    sub_BC720(v29, (__int64)"Argon2-Parallelism: %u\n", v50.m128i_u32[1]);
    sub_BC720(v29, (__int64)"Argon2-Salt: ");
    if ( *(_QWORD *)(v39 + 16) )
    {
      v34 = 0LL;
      do
      {
        v35 = *(unsigned __int8 *)(*(_QWORD *)(v39 + 8) + v34++);
        sub_BC720(v29, (__int64)"%02x", v35);
      }
      while ( *(_QWORD *)(v39 + 16) > v34 );
    }
    sub_BC720(v29, (__int64)"\n");
  }
  sub_BC720(v29, (__int64)"Private-Lines: %d\n", (v42 + 47) / 48);
  sub_787A0((__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v29 + 32), (__int64)desta, v42, 64);
  sub_BC720(v29, (__int64)"Private-MAC: ");
  if ( *((_DWORD *)v24 + 16) > 0 )
  {
    v30 = 1LL;
    do
    {
      sub_BC720(v29, (__int64)"%02x", (unsigned __int8)*(&v52 + v30));
      v31 = v30++;
    }
    while ( *((_DWORD *)v24 + 16) > v31 );
  }
  sub_BC720(v29, (__int64)"\n");
  sub_BC660(v41);
  sub_BC660((void **)v39);
  sub_BC660((void **)v7);
  sub_BC660((void **)v8);
  sub_BD070(desta, v42);
  sub_2F4D0(desta);
  result = v29;
  if ( __readfsqword(0x28u) != v54 )
LABEL_39:
    __assert_fail("priv_encrypted_len - priv_blob->len < 20", "sshpubk.c", 0x5DFu, "ppk_save_sb");
  return result;
}

__int64 __usercall sub_7B3C0@<rax>(__int64 a1@<rdi>, char **a2@<rsi>, const char *a3@<rdx>, const __m128i *a4@<rcx>, __int64 a5@<rbx>, double a6@<xmm0>, __m128i a7@<xmm1>)
{
  const char *v7; // r13
  const __m128i *v8; // r14
  unsigned int v9; // er12
  FILE *v10; // rax
  FILE *v11; // rbx
  __int64 v12; // rbp
  size_t v13; // r14
  __int64 v14; // r13

  v7 = a3;
  v8 = a4;
  v9 = 0;
  v10 = sub_B5170(1, a5, (const char **)a1, "wb");
  if ( v10 )
  {
    v11 = v10;
    v12 = sub_7AD60(a2, v7, v8, a6, a7);
    v13 = fwrite(*(const void **)v12, 1uLL, *(_QWORD *)(v12 + 16), v11);
    v14 = *(_QWORD *)(v12 + 16);
    if ( !fclose(v11) )
      LOBYTE(v9) = v13 == v14;
    sub_BC660((void **)v12);
  }
  return v9;
}

char *__fastcall sub_7B450(__int64 *a1)
{
  char *v1; // r14
  _BYTE *v2; // r13
  _BYTE *v3; // rax
  char *v4; // rbp
  void *v5; // r12
  signed __int64 v6; // rax
  char *v7; // rbx

  v1 = " ";
  v2 = sub_34480(a1[2]);
  v3 = sub_34480(a1[1]);
  v4 = (char *)a1[7];
  v5 = v3;
  if ( !v4 )
  {
    v4 = &locale;
    v1 = &locale;
  }
  v6 = sub_335B0((__int64 *)a1[1]);
  v7 = sub_BC360((__int64)&unk_F12D0, v6, v2, v5, v1, v4);
  sub_2F4D0(v2);
  sub_2F4D0(v5);
  return v7;
}

void __fastcall sub_7B4E0(__int64 a1, __int64 *a2)
{
  char *v2; // rbx

  v2 = sub_7B450(a2);
  __fprintf_chk(a1, 1LL, &off_F813B, v2);
  sub_2F4D0(v2);
}

char *__fastcall sub_7B520(char **a1, __int64 a2)
{
  signed __int64 v2; // rbx
  char *v3; // rbp

  v2 = sub_BC640();
  (*(void (__fastcall **)(char *, signed __int64))(*(_QWORD *)*a1 + 56LL))(*a1, v2 + 24);
  v3 = sub_77CC0(a1[1], *(_QWORD *)v2, *(_DWORD *)(v2 + 16));
  sub_BC660((void **)v2);
  return v3;
}

__int64 __fastcall sub_7B790(__int64 a1, const char *a2, int a3)
{
  int v3; // ebx
  __int64 v4; // rbp
  size_t v5; // rdx
  char *v6; // r14
  char *v7; // rbx
  unsigned int v8; // er14
  signed int v9; // esi
  unsigned __int8 *v10; // rdi
  signed __int64 v12; // rbx
  __int64 v13; // rax
  unsigned __int64 v14; // r15
  __int64 (__fastcall *(*v15)[13])(); // rax
  unsigned int v16; // ST0C_4
  unsigned int v17; // eax
  unsigned int v18; // eax
  __int64 v19; // [rsp+10h] [rbp-98h]
  __int64 v20; // [rsp+18h] [rbp-90h]
  const char *v21; // [rsp+20h] [rbp-88h]
  int v22; // [rsp+28h] [rbp-80h]
  __int64 *v23; // [rsp+30h] [rbp-78h]
  char v24; // [rsp+3Bh] [rbp-6Dh]
  char v25; // [rsp+3Fh] [rbp-69h]
  char v26[40]; // [rsp+40h] [rbp-68h]
  unsigned __int64 v27; // [rsp+68h] [rbp-40h]

  v3 = a3;
  v27 = __readfsqword(0x28u);
  v4 = sub_BC640();
  v19 = a1;
  v21 = a2;
  v20 = 0LL;
  v22 = 0;
  v23 = &v19;
  v6 = sub_2F1D0((__int64)&v19);
  if ( !*((_DWORD *)v23 + 6) )
  {
    v14 = v5;
    v15 = sub_79160(v6, v5);
    if ( v15 )
    {
      v16 = ((__int64 (__fastcall *)(__int64 (__fastcall *(*)[13])(), __int64, const char *))(*v15)[12])(v15, a1, a2);
      v17 = sub_BC2F0(v14);
      sub_BC720(v4, (__int64)"%.*s %d ", v17, v6, v16);
    }
    else
    {
      v18 = sub_BC2F0(v14);
      sub_BC720(v4, (__int64)"%.*s ", v18, v6);
    }
  }
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      v7 = v26;
      v8 = 32;
      sub_5E520((__int64 (**)(void))&off_321220, a1, (__int64)a2, (__int64)v26);
      sub_2EC30((__int64 (**)(void))(v4 + 24));
      do
      {
        v9 = 3;
        v10 = (unsigned __int8 *)v7;
        if ( v8 <= 3 )
          v9 = v8;
        v7 += 3;
        sub_BCA40(v10, v9, &v24);
        sub_2EC20((__int64 (**)(void))(v4 + 24));
        v8 -= 3;
      }
      while ( v7 != &v26[33] );
      sub_BC610((_QWORD *)v4, 61);
    }
  }
  else
  {
    v12 = 1LL;
    sub_5E520((__int64 (**)(void))off_320E40, a1, (__int64)a2, (__int64)v26);
    do
    {
      sub_BC720(v4, (__int64)"%02x%s", (unsigned __int8)*(&v25 + v12), ":");
      v13 = (unsigned int)v12++;
    }
    while ( v12 != 16 );
    sub_BC720(v4, (__int64)"%02x%s", (unsigned __int8)v26[v13], &locale);
  }
  return sub_BC6B0((__int64 *)v4);
}

_QWORD *__fastcall sub_7B9C0(__int64 a1, const char *a2)
{
  _QWORD *v2; // rbx

  v2 = sub_2F450(2uLL, 8uLL, 0LL);
  *v2 = sub_7B790(a1, a2, 0);
  v2[1] = sub_7B790(a1, a2, 1);
  return v2;
}

__int64 __fastcall sub_7BA10(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // rbp

  v2 = sub_BC640();
  (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)a1 + 56LL))(a1, v2 + 24);
  v3 = sub_7B790(*(_QWORD *)(v2 + 8), *(const char **)(v2 + 16), a2);
  sub_BC660((void **)v2);
  return v3;
}

_QWORD *__fastcall sub_7BA60(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  _QWORD *v3; // rbp

  v2 = sub_BC640();
  (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)a1 + 56LL))(a1, v2 + 24);
  v3 = sub_7B9C0(*(_QWORD *)(v2 + 8), *(const char **)(v2 + 16));
  sub_BC660((void **)v2);
  return v3;
}

void __fastcall sub_7BAB0(void **a1)
{
  sub_2F4D0(*a1);
  sub_2F4D0(a1[1]);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_7BAD0(__int64 a1)
{
  unsigned int v1; // ebp

  v1 = sub_791C0(a1);
  sub_2F3E0(*(_QWORD *)(a1 + 32), 0LL);
  return v1;
}

__int64 __fastcall sub_7BB00(__int64 a1)
{
  __int64 *v1; // rbx
  unsigned int v2; // ebp
  __int64 result; // rax

  v1 = (__int64 *)sub_2F450(1uLL, 0x40uLL, 1024LL);
  *v1 = (__int64)(v1 + 8);
  v1[1] = 0LL;
  v1[2] = 1024LL;
  if ( (unsigned int)sub_789A0(v1, a1, (__int64)v1) == 2 )
  {
    sub_788B0(v1);
    result = 0LL;
  }
  else
  {
    v2 = sub_791C0((__int64)(v1 + 3));
    sub_2F3E0(v1[7], 0LL);
    sub_788B0(v1);
    result = v2;
  }
  return result;
}

char *__fastcall sub_7BB90(int a1)
{
  char *result; // rax

  switch ( a1 )
  {
    case 0:
      result = "unable to open file";
      break;
    case 1:
      result = "not a recognised key file format";
      break;
    case 2:
      result = "SSH-1 private key";
      break;
    case 3:
      result = "PuTTY SSH-2 private key";
      break;
    case 4:
      __assert_fail(
        "false && \"OPENSSH_AUTO should never reach key_type_to_str\"",
        "sshpubk.c",
        0x78Eu,
        "key_type_to_str");
      return result;
    case 5:
      result = "OpenSSH SSH-2 private key (old PEM format)";
      break;
    case 6:
      result = "OpenSSH SSH-2 private key (new format)";
      break;
    case 7:
      result = "ssh.com SSH-2 private key";
      break;
    case 8:
      result = "SSH-1 public key";
      break;
    case 9:
      result = "SSH-2 public key (RFC 4716 format)";
      break;
    case 10:
      result = "SSH-2 public key (OpenSSH format)";
      break;
    default:
      __assert_fail("false && \"bad key type in key_type_to_str\"", "sshpubk.c", 0x790u, "key_type_to_str");
      return result;
  }
  return result;
}

_QWORD *sub_7BC90()
{
  _QWORD *result; // rax

  result = sub_2F450(1uLL, 0x18uLL, 0LL);
  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  return result;
}

char *__fastcall sub_7BCD0(__int64 a1, char *a2, char *a3)
{
  char *v3; // r12
  char *v4; // rax
  unsigned __int64 v5; // rdx
  signed __int64 v6; // rbx
  char **v7; // r14
  char *v8; // rax
  signed __int64 v9; // rbx
  char *result; // rax

  v3 = a3;
  v4 = (char *)sub_2F4F0(*(void **)(a1 + 16), (unsigned __int64 *)(a1 + 8), 0x18uLL, *(_QWORD *)a1, 1uLL, 0);
  v5 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)a1 = v5 + 1;
  v6 = 24 * v5;
  v7 = (char **)&v4[24 * v5];
  v8 = sub_BC120(a2);
  v9 = *(_QWORD *)(a1 + 16) + v6;
  *v7 = v8;
  *(_BYTE *)(v9 + 8) = 0;
  result = sub_BC120(v3);
  *(_QWORD *)(v9 + 16) = result;
  return result;
}

_QWORD *__fastcall sub_7BD50(__int64 a1, char *a2, __int64 a3)
{
  __int64 v3; // r12
  char *v4; // rax
  unsigned __int64 v5; // rdx
  signed __int64 v6; // rbx
  char **v7; // r14
  char *v8; // rax
  signed __int64 v9; // rbx
  _QWORD *result; // rax

  v3 = a3;
  v4 = (char *)sub_2F4F0(*(void **)(a1 + 16), (unsigned __int64 *)(a1 + 8), 0x18uLL, *(_QWORD *)a1, 1uLL, 0);
  v5 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)a1 = v5 + 1;
  v6 = 24 * v5;
  v7 = (char **)&v4[24 * v5];
  v8 = sub_BC120(a2);
  v9 = *(_QWORD *)(a1 + 16) + v6;
  *v7 = v8;
  *(_BYTE *)(v9 + 8) = 1;
  result = sub_334C0(v3);
  *(_QWORD *)(v9 + 16) = result;
  return result;
}

__int64 sub_7BE70()
{
  return sub_2EC20((__int64 (**)(void))(qword_326460 + 8));
}

__int64 __usercall sub_7BE90@<rax>(__int64 a1@<rsi>, __int64 a2@<r12>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __int64 result; // rax

  result = (unsigned int)dword_326450;
  if ( dword_326450 > 0 && qword_326458 == a1 )
  {
    sub_B7B30(a2, a3, a4, a5);
    result = sub_99D00((__int64)&loc_493E0, (__int64)sub_7BE90, (__int64)&unk_326468);
    qword_326458 = result;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 __usercall sub_7BEE0@<rax>(int a1@<edx>, __int64 a2@<rbx>, __int64 a3@<rbp>, unsigned int a4@<edi>, __int64 a5@<rsi>, __int64 a6@<r12>, __int64 a7@<r13>, __int64 a8@<r14>, __int64 a9@<r15>)
{
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rbx
  signed __int64 v12; // rdi
  int v13; // ecx
  unsigned int v14; // eax
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rbp
  unsigned int v18; // er12
  __int64 v19; // rdx
  unsigned __int64 result; // rax
  __int64 v21; // [rsp-B8h] [rbp-B8h]
  unsigned __int64 v22; // [rsp-40h] [rbp-40h]
  __int64 v23; // [rsp-30h] [rbp-30h]
  __int64 v24; // [rsp-28h] [rbp-28h]
  __int64 v25; // [rsp-20h] [rbp-20h]
  __int64 v26; // [rsp-18h] [rbp-18h]
  __int64 v27; // [rsp-10h] [rbp-10h]
  __int64 v28; // [rsp-8h] [rbp-8h]

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
  {
    v28 = a9;
    v27 = a8;
    v26 = a7;
    v25 = a6;
    v24 = a3;
    v23 = a2;
    v9 = a1;
    v22 = __readfsqword(0x28u);
    if ( a4 > 0x10 )
      __assert_fail("source_id < NOISE_MAX_SOURCES", "sshprng.c", 0xF4u, "prng_add_entropy");
    v10 = qword_326460 + 4LL * a4;
    v11 = qword_326460;
    v12 = 1LL;
    v13 = *(_DWORD *)(v10 + 64);
    *(_DWORD *)(v10 + 64) = v13 + 1;
    v14 = (unsigned int)(v13 + 1) >> 1;
    if ( (v13 + 1) & 1 )
    {
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 136) + 8LL));
      v16 = *(_QWORD *)(v11 + 392);
      if ( v16 < v9 )
      {
        *(_QWORD *)(v11 + 392) = 0LL;
        goto LABEL_12;
      }
      v15 = v16 - v9;
      *(_QWORD *)(v11 + 392) = v15;
    }
    else
    {
      do
      {
        if ( v14 & 1 )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 8 * v12 + 136) + 8LL));
          v15 = *(_QWORD *)(v11 + 392);
          goto LABEL_8;
        }
        ++v12;
        v14 >>= 1;
      }
      while ( v12 != 31 );
      sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v11 + 384) + 8LL));
      v15 = *(_QWORD *)(v11 + 392);
    }
LABEL_8:
    if ( v15 )
      return __readfsqword(0x28u) ^ v22;
LABEL_12:
    if ( (unsigned __int64)(sub_B7CA0() - *(_QWORD *)(v11 + 408)) > 0x63 )
    {
      v17 = (_QWORD *)(v11 + 136);
      sub_776B0(v11);
      v18 = *(_DWORD *)(v11 + 400) + 1;
      *(_DWORD *)(v11 + 400) = v18;
      do
      {
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 24LL))(*v17, &v21);
        v19 = *(_QWORD *)(*(_QWORD *)(v11 + 24) + 40LL);
        sub_2EC20((__int64 (**)(void))(v11 + 8));
        (*(void (__fastcall **)(_QWORD, __int64 *))(*(_QWORD *)*v17 + 8LL))(*v17, &v21);
        if ( v18 & 1 )
          break;
        ++v17;
        v18 >>= 1;
      }
      while ( v17 != (_QWORD *)(v11 + 392) );
      sub_BD070(&v21, 0x72uLL);
      sub_77730(v11);
    }
    return __readfsqword(0x28u) ^ v22;
  }
  return result;
}

unsigned __int64 sub_7BF10()
{
  sub_776B0(qword_326460);
  sub_2EC30((__int64 (**)(void))(qword_326460 + 8));
  return sub_77730(qword_326460);
}

unsigned __int64 __fastcall sub_7BF50(char *a1, size_t a2)
{
  if ( dword_326450 <= 0 )
    __assert_fail("random_active > 0", "sshrand.c", 0x85u, "random_read");
  return sub_77840((_QWORD *)qword_326460, a1, a2);
}

__int64 __fastcall sub_7BF90(char **a1, _DWORD *a2)
{
  char *v2; // rbx
  __int64 result; // rax

  v2 = (char *)sub_2F450(*(_QWORD *)qword_326460, 1uLL, 0LL);
  sub_7BF50(v2, *(_QWORD *)qword_326460);
  result = *(_QWORD *)qword_326460;
  *a2 = *(_QWORD *)qword_326460;
  *a1 = v2;
  return result;
}

unsigned __int64 sub_7BFE0()
{
  int v1; // [rsp+Ch] [rbp-1Ch]
  void *buf; // [rsp+10h] [rbp-18h]
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  sub_7BF90((char **)&buf, &v1);
  sub_BB290(buf, v1);
  sub_2F4D0(buf);
  return __readfsqword(0x28u) ^ v3;
}

unsigned __int64 sub_7C040()
{
  unsigned __int64 result; // rax

  result = (unsigned int)dword_326450;
  if ( dword_326450 )
    result = sub_7BFE0();
  return result;
}

unsigned __int64 __fastcall sub_7C060(__int64 a1)
{
  unsigned __int64 result; // rax

  if ( qword_326460 )
    __assert_fail("!global_prng", "sshrand.c", 0x3Fu, "random_create");
  qword_326460 = (__int64)sub_77540(a1);
  sub_776B0(qword_326460);
  sub_B7910((void (__fastcall *)(__int64 *, signed __int64))sub_7BE70);
  sub_77730(qword_326460);
  qword_326458 = sub_99D00((__int64)&loc_493E0, (__int64)sub_7BE90, (__int64)&unk_326468);
  result = (unsigned int)dword_326450;
  if ( dword_326450 )
    result = sub_7BFE0();
  return result;
}

unsigned __int64 sub_7C100()
{
  unsigned __int64 result; // rax
  bool v1; // zf

  result = (unsigned int)dword_326450;
  v1 = dword_326450++ == 0;
  if ( v1 )
    result = sub_7C060((__int64)&off_321220);
  return result;
}

void nullsub_48()
{
  ;
}

void sub_7C1B0()
{
  int v0; // eax

  v0 = dword_326450;
  if ( dword_326450 <= 0 )
    __assert_fail("random_active > 0", "sshrand.c", 0x7Eu, "random_unref");
  --dword_326450;
  if ( v0 == 1 )
  {
    JUMPOUT(qword_326460, 0LL, nullsub_48);
    if ( dword_326450 )
      sub_7BFE0();
    sub_99EF0((__int64)&unk_326468);
    sub_77630((_QWORD *)qword_326460);
    qword_326460 = 0LL;
    dword_326450 = 0;
  }
}

void sub_7C1B0()
{
  int v0; // eax

  v0 = dword_326450;
  if ( dword_326450 <= 0 )
    __assert_fail("random_active > 0", "sshrand.c", 0x7Eu, "random_unref");
  --dword_326450;
  if ( v0 == 1 )
  {
    JUMPOUT(qword_326460, 0LL, nullsub_48);
    if ( dword_326450 )
      sub_7BFE0();
    sub_99EF0((__int64)&unk_326468);
    sub_77630((_QWORD *)qword_326460);
    qword_326460 = 0LL;
    dword_326450 = 0;
  }
}

void sub_7C1B0()
{
  int v0; // eax

  v0 = dword_326450;
  if ( dword_326450 <= 0 )
    __assert_fail("random_active > 0", "sshrand.c", 0x7Eu, "random_unref");
  --dword_326450;
  if ( v0 == 1 )
  {
    JUMPOUT(qword_326460, 0LL, nullsub_48);
    if ( dword_326450 )
      sub_7BFE0();
    sub_99EF0((__int64)&unk_326468);
    sub_77630((_QWORD *)qword_326460);
    qword_326460 = 0LL;
    dword_326450 = 0;
  }
}

unsigned __int64 *__fastcall sub_7C240(unsigned __int64 *a1, unsigned __int64 *a2, __int64 *a3, __int64 a4, __int64 *a5, unsigned __int64 *a6)
{
  __int64 *v6; // r13
  __int64 *v7; // r12
  unsigned __int64 *v8; // ST28_8
  __int64 *v9; // ST18_8
  __int64 *v10; // r15
  __int64 *v11; // r14
  unsigned __int64 *v12; // ST08_8
  unsigned __int64 *v13; // ST10_8
  unsigned __int64 *v14; // ST20_8
  unsigned __int64 *v15; // rbx
  unsigned __int64 *v16; // ST20_8
  unsigned __int64 *v17; // rbp
  char v18; // al
  unsigned __int64 *v19; // r13
  unsigned __int64 *v20; // ST20_8
  __int64 *v21; // r12
  unsigned __int64 *v22; // ST18_8

  v6 = (__int64 *)a4;
  v7 = a5;
  v8 = a6;
  v9 = a3;
  v10 = sub_334C0(a4);
  sub_33B10(v10, (unsigned __int64 *)v10, 1LL);
  v11 = sub_334C0((__int64)v7);
  sub_33B10(v11, (unsigned __int64 *)v11, 1LL);
  v12 = sub_35FB0(a2, v10);
  v13 = sub_35FB0(a2, v11);
  v14 = sub_35FB0(a1, v6);
  v15 = sub_364B0(v14, v12, (__int64)v6);
  sub_330F0(v14);
  v16 = sub_35FB0(a1, v7);
  v17 = sub_364B0(v16, v13, (__int64)v7);
  sub_330F0(v16);
  v18 = sub_33E30(v17, v15);
  sub_33DD0((__int64 *)v15, v15, (unsigned __int64 *)v6, v18);
  v19 = (unsigned __int64 *)sub_34240(v15, v17);
  v20 = sub_342F0(v8, (unsigned __int64 *)v7);
  v21 = (__int64 *)sub_342F0(v20, v19);
  sub_338A0(v21, v21, v17);
  v22 = sub_35FB0((unsigned __int64 *)v21, v9);
  sub_330F0(v10);
  sub_330F0(v11);
  sub_330F0(v12);
  sub_330F0(v13);
  sub_330F0(v15);
  sub_330F0(v17);
  sub_330F0(v19);
  sub_330F0(v20);
  sub_330F0(v21);
  return v22;
}

void __fastcall sub_7C3F0(__int64 a1, _QWORD *a2)
{
  __int64 (**v2)(void); // rbp
  char *v3; // rbx
  size_t v4; // r12

  v2 = (__int64 (**)(void))(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) )
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), 44);
  sub_2EC20(v2);
  v3 = (char *)sub_33660(a2);
  v4 = strlen(v3);
  sub_2EC20(v2);
  sub_BD070(v3, v4);
  sub_2F4D0(v3);
}

unsigned __int64 __fastcall sub_7C460(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v5; // r15
  int v6; // ebx
  __int64 v7; // rax
  __int64 (***v8)(void); // r13
  __int64 v9; // r8
  __int64 v10; // r12
  __int64 v11; // rdx
  int v13; // [rsp+8h] [rbp-C0h]
  char v14[120]; // [rsp+10h] [rbp-B8h]
  unsigned __int64 v15; // [rsp+88h] [rbp-40h]

  v5 = a4;
  v6 = a5;
  v15 = __readfsqword(0x28u);
  v7 = (*(__int64 (**)(void))a1)();
  v8 = (__int64 (***)(void))v7;
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8LL))(v7);
  if ( v6 > 0 )
  {
    v13 = 0;
    do
    {
      v9 = v6;
      if ( *(_QWORD *)(a1 + 40) <= (unsigned __int64)v6 )
        v9 = *(_QWORD *)(a1 + 40);
      v10 = v9;
      ((void (__fastcall *)(__int64 (***)(void)))(*v8)[1])(v8);
      if ( *(_QWORD *)(a1 + 40) > 0x72uLL )
        __assert_fail("h->hlen <= MAX_HASH_LEN", "sshrsa.c", 0x393u, "oaep_mask");
      sub_2EC20(v8[1]);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v8[1], v13);
      ((void (__fastcall *)(__int64 (***)(void), char *))(*v8)[3])(v8, v14);
      ++v13;
      if ( (_DWORD)v10 )
      {
        v11 = 0LL;
        do
        {
          *(_BYTE *)(v5 + v11) ^= v14[v11];
          ++v11;
        }
        while ( (unsigned int)(v10 - 1) + 1LL != v11 );
      }
      v6 -= v10;
      v5 += v10;
    }
    while ( v6 > 0 );
  }
  ((void (__fastcall *)(__int64 (***)(void)))(*v8)[4])(v8);
  return __readfsqword(0x28u) ^ v15;
}

unsigned __int64 __fastcall sub_7C5A0(__int64 a1, __int64 a2)
{
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 56));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 48));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 40));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 16));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 32));
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 24));
}

unsigned __int64 __fastcall sub_7C600(__int64 a1, __int64 a2)
{
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 40));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 32));
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 24));
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 16));
}

unsigned __int64 __fastcall sub_7C650(__int64 a1, __int64 a2)
{
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(a2 + 8), "ssh-rsa");
  sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 48));
  return sub_33730(*(_QWORD *)(a2 + 8), *(__int64 **)(a1 - 56));
}

char *__fastcall sub_7C690(__int64 a1, char a2)
{
  signed __int64 v2; // rax
  unsigned __int64 v3; // rdi
  __int64 (__fastcall **v4)(); // rcx
  const char *v5; // rdx
  signed __int64 v7; // r8

  v2 = sub_335B0(*(__int64 **)(a1 - 56));
  v3 = (unsigned __int64)(v2 + 7) >> 3;
  if ( a2 & 2 )
  {
    v4 = &off_3215A0;
    v5 = "rsa-sha2-256";
    if ( &off_321220 != &off_3215A0 )
    {
      v4 = &off_321220;
LABEL_13:
      v7 = 22LL;
LABEL_9:
      if ( v3 >= (unsigned __int64)v4[5] + v7 )
        return 0LL;
      return sub_BC360((__int64)"%zu-bit RSA key is too short to generate %s signatures", v2, v5);
    }
LABEL_8:
    v7 = 18LL;
    goto LABEL_9;
  }
  if ( !(a2 & 4) )
  {
    v4 = &off_3215A0;
    v5 = "ssh-rsa";
    goto LABEL_8;
  }
  v4 = off_321460;
  if ( off_321460 == &off_3215A0 )
  {
    v5 = "rsa-sha2-512";
    goto LABEL_8;
  }
  if ( off_321460 == &off_321220 )
  {
    v5 = "rsa-sha2-512";
    goto LABEL_13;
  }
  v5 = "rsa-sha2-512";
  if ( v3 >= (unsigned __int64)off_321460[5] + 22 )
    return 0LL;
  return sub_BC360((__int64)"%zu-bit RSA key is too short to generate %s signatures", v2, v5);
}

_WORD *__fastcall sub_7C760(unsigned __int64 a1, __int64 a2)
{
  __int64 (__fastcall **v2)(_QWORD, __int64, unsigned __int64, char *); // r15
  unsigned __int64 v3; // rax
  char *v4; // rcx
  signed __int64 v5; // r12
  size_t v6; // r13
  char *v7; // ST08_8
  _WORD *v8; // rax
  _WORD *v9; // rbx
  _QWORD *v10; // rax
  __int64 v11; // rsi
  unsigned __int64 v12; // rdx
  char *v13; // rax
  char *v14; // rcx
  unsigned int v15; // eax
  unsigned int v16; // eax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 (***v19)(void); // r15
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax

  v2 = (__int64 (__fastcall **)(_QWORD, __int64, unsigned __int64, char *))a2;
  if ( (__int64 (__fastcall **)())a2 == &off_3215A0 )
  {
    v21 = *(_QWORD *)(a2 + 40) + 18LL;
    if ( a1 < v21 )
      goto LABEL_17;
    v5 = 16LL;
    v4 = (char *)&unk_F1CC0;
    v6 = a1 - v21;
  }
  else
  {
    if ( (__int64 (__fastcall **)())a2 != &off_321220 )
    {
      if ( (__int64 (__fastcall **)())a2 != off_321460 )
        sub_1AEB9();
      v3 = *(_QWORD *)(a2 + 40) + 22LL;
      if ( a1 >= v3 )
      {
        v4 = (char *)&unk_F1C80;
        v5 = 20LL;
        v6 = a1 - v3;
        goto LABEL_6;
      }
LABEL_17:
      __assert_fail("nbytes >= fixed_parts", "sshrsa.c", 0x2D1u, "rsa_pkcs1_signature_string");
    }
    v22 = *(_QWORD *)(a2 + 40) + 22LL;
    if ( a1 < v22 )
      goto LABEL_17;
    v5 = 20LL;
    v4 = (char *)&unk_F1CA0;
    v6 = a1 - v22;
  }
LABEL_6:
  v7 = v4;
  v8 = sub_2F450(a1, 1uLL, 0LL);
  v9 = v8;
  *v8 = 256;
  memset(v8 + 1, 255, v6);
  v10 = (_QWORD *)((char *)v9 + v6 + 2);
  *v10 = *(_QWORD *)v7;
  v11 = *(_QWORD *)&v7[(unsigned int)v5 - 8];
  *(_QWORD *)((char *)v10 + (unsigned int)v5 - 8) = v11;
  v12 = ((unsigned __int64)v9 + v6 + 10) & 0xFFFFFFFFFFFFFFF8LL;
  v13 = (char *)v10 - v12;
  v14 = (char *)(v7 - v13);
  v15 = (v5 + (_DWORD)v13) & 0xFFFFFFF8;
  if ( v15 >= 8 )
  {
    v16 = v15 & 0xFFFFFFF8;
    LODWORD(v11) = 0;
    do
    {
      v17 = (unsigned int)v11;
      v11 = (unsigned int)(v11 + 8);
      *(_QWORD *)(v12 + v17) = *(_QWORD *)&v14[v17];
    }
    while ( (unsigned int)v11 < v16 );
  }
  v18 = (*v2)(v2, v11, v12, v14);
  v19 = (__int64 (***)(void))v18;
  if ( v18 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 8LL))(v18);
  sub_2EC30(v19[1]);
  ((void (__fastcall *)(__int64 (***)(void), size_t))(*v19)[3])(v19, (signed __int64)v9 + v6 + v5 + 2);
  ((void (__fastcall *)(__int64 (***)(void)))(*v19)[4])(v19);
  return v9;
}

__int64 __fastcall sub_7C920(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  _QWORD *v4; // r12
  __int64 v5; // rax
  __int64 *v6; // rdi
  int v7; // eax
  __int64 (__fastcall **v8)(); // rbp
  unsigned __int64 v9; // rbx
  char *v10; // r15
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r14
  __int64 v13; // rdx
  char *v14; // r8
  unsigned __int64 *v15; // ST10_8
  unsigned __int64 *v16; // r15
  _WORD *v17; // rax
  char *v18; // r12
  int v19; // er13
  char v20; // bp
  char v21; // al
  void *v23; // [rsp+8h] [rbp-80h]
  __int64 v24; // [rsp+10h] [rbp-78h]
  __int64 v25; // [rsp+18h] [rbp-70h]
  __int64 v26; // [rsp+20h] [rbp-68h]
  __int64 v27; // [rsp+28h] [rbp-60h]
  __int64 v28; // [rsp+30h] [rbp-58h]
  int v29; // [rsp+38h] [rbp-50h]
  __int64 *v30; // [rsp+40h] [rbp-48h]
  unsigned __int64 v31; // [rsp+48h] [rbp-40h]

  v3 = a3;
  v4 = a1;
  v31 = __readfsqword(0x28u);
  v5 = *a1;
  v6 = (__int64 *)*(a1 - 7);
  v7 = **(_DWORD **)(v5 + 120);
  if ( !(v7 & 2) )
  {
    if ( v7 & 4 )
    {
      v8 = off_321460;
      v9 = (unsigned __int64)(sub_335B0(v6) + 7) >> 3;
      if ( off_321460 != &off_3215A0 )
        goto LABEL_4;
    }
    else
    {
      v8 = &off_3215A0;
      v9 = (unsigned __int64)(sub_335B0(v6) + 7) >> 3;
    }
LABEL_13:
    if ( (unsigned __int64)v8[5] + 18 <= v9 )
      goto LABEL_5;
LABEL_14:
    LODWORD(v12) = 0;
    return (unsigned int)v12;
  }
  v8 = &off_3215A0;
  v9 = (unsigned __int64)(sub_335B0(v6) + 7) >> 3;
  if ( &off_321220 == &off_3215A0 )
    goto LABEL_13;
  v8 = &off_321220;
LABEL_4:
  if ( (unsigned __int64)v8[5] + 22 > v9 )
    goto LABEL_14;
LABEL_5:
  v26 = a2;
  v28 = v3;
  v27 = 0LL;
  v29 = 0;
  v30 = &v26;
  v10 = sub_2F1D0((__int64)&v26);
  v12 = v11;
  v14 = sub_2F1D0((__int64)v30);
  if ( *((_DWORD *)v30 + 6) )
    goto LABEL_14;
  v25 = v13;
  v24 = (__int64)v14;
  LODWORD(v12) = sub_BD100(v10, v12, *(void **)(*v4 + 104LL));
  if ( !(_BYTE)v12 )
    goto LABEL_14;
  v15 = sub_33390(v24, v25);
  v16 = sub_364B0(v15, (unsigned __int64 *)*(v4 - 6), *(v4 - 7));
  sub_330F0(v15);
  v17 = sub_7C760(v9, (__int64)v8);
  v23 = v17;
  if ( v9 )
  {
    v18 = (char *)v17 + v9 - 1;
    v12 = 0LL;
    v19 = 0;
    do
    {
      v20 = *v18;
      v21 = sub_334D0(v16, v12++);
      --v18;
      v19 |= (unsigned __int8)(v21 ^ v20);
    }
    while ( v12 != v9 );
    LOBYTE(v12) = v19 == 0;
  }
  sub_BD070(v23, v9);
  sub_2F4D0(v23);
  sub_330F0(v16);
  return (unsigned int)v12;
}

void __fastcall sub_7CB60(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  char *v5; // r15
  __int64 v6; // r12
  __int64 (__fastcall **v7)(); // rsi
  int v8; // ecx
  int v9; // ecx
  unsigned __int64 v10; // rbp
  _WORD *v11; // r14
  unsigned __int64 *v12; // r13
  __int64 *v13; // rbp
  unsigned __int64 v14; // rbx
  signed __int64 v15; // rbx
  unsigned __int64 v16; // rsi
  char v17; // al

  v5 = "rsa-sha2-256";
  v6 = a5;
  v7 = &off_321220;
  v8 = **(_DWORD **)(*(_QWORD *)a1 + 120LL) | a4;
  if ( !(v8 & 2) )
  {
    v5 = "ssh-rsa";
    v9 = v8 & 4;
    v7 = &off_3215A0;
    if ( v9 )
      v5 = "rsa-sha2-512";
    if ( v9 )
      v7 = off_321460;
  }
  v10 = (unsigned __int64)(sub_335B0(*(__int64 **)(a1 - 56)) + 7) >> 3;
  v11 = sub_7C760(v10, (__int64)v7);
  v12 = sub_33390((__int64)v11, v10);
  sub_BD070(v11, v10);
  sub_2F4D0(v11);
  v13 = (__int64 *)sub_7C240(
                     v12,
                     *(unsigned __int64 **)(a1 - 40),
                     *(__int64 **)(a1 - 56),
                     *(_QWORD *)(a1 - 32),
                     *(__int64 **)(a1 - 24),
                     *(unsigned __int64 **)(a1 - 16));
  sub_330F0(v12);
  sub_2EF40(*(void (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), v5);
  v14 = (unsigned __int64)(sub_335B0(v13) + 7) >> 3;
  sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(v6 + 8), v14);
  if ( v14 )
  {
    v15 = v14 - 1;
    do
    {
      v16 = v15--;
      v17 = sub_334D0((unsigned __int64 *)v13, v16);
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(v6 + 8), v17);
    }
    while ( v15 != -1 );
  }
  sub_330F0(v13);
}

void __fastcall sub_7CCA0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rbp
  int v4; // er12
  int v5; // er14
  __int64 v6; // rdi
  _QWORD *v7; // r13
  __int64 *v8; // r12

  v3 = a1;
  v4 = a3;
  v5 = sub_2F150(*(_QWORD *)(a1 + 32));
  v6 = *(_QWORD *)(a1 + 32);
  if ( v4 )
  {
    v8 = sub_337C0(v6);
    v7 = sub_337C0(*(_QWORD *)(v3 + 32));
    if ( a2 )
      goto LABEL_3;
  }
  else
  {
    v7 = sub_337C0(v6);
    v8 = sub_337C0(*(_QWORD *)(v3 + 32));
    if ( a2 )
    {
LABEL_3:
      *(_DWORD *)a2 = v5;
      *(_QWORD *)(a2 + 16) = v7;
      *(_QWORD *)(a2 + 8) = v8;
      *(_DWORD *)(a2 + 4) = (unsigned __int64)(sub_335B0(v8) + 7) >> 3;
      return;
    }
  }
  sub_330F0(v7);
  sub_330F0(v8);
}

_QWORD *__fastcall sub_7CD50(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax

  result = sub_337C0(*(_QWORD *)(a1 + 32));
  *(_QWORD *)(a2 + 24) = result;
  return result;
}

_QWORD *__fastcall sub_7CD70(__int64 *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx

  v1 = sub_7BC90();
  sub_7BCD0((__int64)v1, "key_type", "RSA");
  sub_7BD50((__int64)v1, "public_modulus", a1[1]);
  sub_7BD50((__int64)v1, "public_exponent", a1[2]);
  v2 = a1[3];
  if ( v2 )
  {
    sub_7BD50((__int64)v1, "private_exponent", v2);
    sub_7BD50((__int64)v1, "private_p", a1[4]);
    sub_7BD50((__int64)v1, "private_q", a1[5]);
    sub_7BD50((__int64)v1, "private_inverse_q_mod_p", a1[6]);
  }
  return v1;
}

_QWORD *__fastcall sub_7CE20(__int64 a1)
{
  return sub_7CD70((__int64 *)(a1 - 64));
}

_QWORD *__fastcall sub_7CE30(__int64 a1)
{
  __int64 v1; // rbp
  _QWORD *v2; // rax
  _QWORD *v3; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rax
  __int64 v7; // rdi
  _QWORD *v8; // rax
  __int64 v9; // rdi

  v1 = a1;
  v2 = sub_2F450(1uLL, 0x48uLL, 0LL);
  v2[8] = 0LL;
  v3 = v2;
  *(_OWORD *)v2 = 0LL;
  *((_OWORD *)v2 + 1) = 0LL;
  *((_OWORD *)v2 + 2) = 0LL;
  *((_OWORD *)v2 + 3) = 0LL;
  sub_7CCA0(*(_QWORD *)(a1 + 32), (__int64)v2, 1);
  v4 = sub_337C0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32LL));
  v5 = *(_QWORD *)(a1 + 32);
  v3[3] = v4;
  v6 = sub_337C0(v5);
  v7 = *(_QWORD *)(v1 + 32);
  v3[6] = v6;
  v8 = sub_337C0(v7);
  v9 = *(_QWORD *)(v1 + 32);
  v3[5] = v8;
  v3[4] = sub_337C0(v9);
  return v3;
}

__int64 __fastcall sub_7CEC0(void *src, int a2, __int64 a3)
{
  int v3; // ecx
  char *v5; // r12
  __int64 v6; // r13
  signed __int64 v7; // rbp
  unsigned __int64 v8; // r15
  unsigned __int64 *v9; // rbx
  unsigned __int64 *v10; // ST08_8
  char *v11; // rbp
  char v12; // al
  int v13; // eax
  unsigned __int64 *v14; // rax
  unsigned __int64 *v15; // r14
  unsigned __int64 *v16; // rax
  int v17; // edx
  unsigned __int64 *v18; // rbp
  int v19; // eax
  unsigned __int64 v20; // rsi
  signed __int64 v21; // rbx
  signed __int64 v22; // r13
  signed __int64 v23; // [rsp+0h] [rbp-40h]

  v3 = *(_DWORD *)(a3 + 4);
  if ( a2 + 3 >= v3 )
    return 0LL;
  v5 = (char *)src;
  v6 = a3;
  memmove((char *)src + v3 - (signed __int64)a2, src, a2);
  *(_WORD *)src = 512;
  v7 = *(_DWORD *)(v6 + 4) - a2 - 3 + 16LL;
  v8 = 8 * v7;
  v9 = sub_33090(8 * v7 + 8);
  v10 = sub_36E00(8 * v7, (void (__fastcall *)(_BYTE *, unsigned __int64))sub_7BF50);
  sub_331D0(v9, v10);
  sub_330F0(v10);
  if ( *(_DWORD *)(v6 + 4) - a2 > 3 )
  {
    v23 = v7 & 0x1FFFFFFFFFFFFFFFLL;
    v11 = (char *)src;
    do
    {
      sub_33BA0((__int64 *)v9, v9, 0xFFu);
      v12 = sub_334D0(v9, v23);
      if ( v12 == -1 )
        __assert_fail("byte != 255", "sshrsa.c", 0x76u, "rsa_ssh1_encrypt");
      v11[2] = v12 + 1;
      sub_34C70(v9, v8);
      v13 = (_DWORD)v11++ + 3 - (_DWORD)src;
    }
    while ( *(_DWORD *)(v6 + 4) + ~a2 > v13 );
  }
  sub_330F0(v9);
  *((char *)src + *(_DWORD *)(v6 + 4) - a2 - 1) = 0;
  v14 = sub_33390((__int64)src, *(signed int *)(v6 + 4));
  v15 = v14;
  v16 = sub_364B0(v14, *(unsigned __int64 **)(v6 + 16), *(_QWORD *)(v6 + 8));
  v17 = *(_DWORD *)(v6 + 4);
  v18 = v16;
  v19 = v17 - 1;
  if ( v17 )
  {
    v20 = v19;
    v21 = v19 - 1LL;
    v22 = v21 - (unsigned int)v19;
    while ( 1 )
    {
      *(++v5 - 1) = sub_334D0(v18, v20);
      v20 = v21;
      if ( v21 == v22 )
        break;
      --v21;
    }
  }
  sub_330F0(v15);
  sub_330F0(v18);
  return 1LL;
}

unsigned __int64 *__fastcall sub_7D090(unsigned __int64 *a1, __int64 a2)
{
  return sub_7C240(
           a1,
           *(unsigned __int64 **)(a2 + 24),
           *(__int64 **)(a2 + 8),
           *(_QWORD *)(a2 + 32),
           *(__int64 **)(a2 + 40),
           *(unsigned __int64 **)(a2 + 48));
}

__int64 __fastcall sub_7D210(__int64 a1, __int64 a2)
{
  __int64 *v2; // rbx

  v2 = (__int64 *)sub_BC640();
  sub_7C3F0((__int64)v2, *(_QWORD **)(a1 + 16));
  sub_7C3F0((__int64)v2, *(_QWORD **)(a1 + 8));
  return sub_BC6B0(v2);
}

__int64 __fastcall sub_7D250(__int64 a1, __int64 a2)
{
  return sub_7D210(a1 - 64, a2);
}

__int64 __fastcall sub_7D260(__int64 a1)
{
  char *v1; // rax
  char *v2; // r12
  unsigned __int64 v3; // rax
  signed __int64 v4; // rbx
  unsigned __int64 v5; // rsi
  char v6; // al
  unsigned __int64 v7; // rax
  signed __int64 v8; // rbx
  unsigned __int64 v9; // rsi
  char v10; // al
  __int64 v11; // rbx
  __int64 *v12; // r12
  signed __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v16; // [rsp+0h] [rbp-48h]
  unsigned __int64 v17; // [rsp+18h] [rbp-30h]

  v17 = __readfsqword(0x28u);
  v1 = sub_76E90((__int64)off_320E40);
  v2 = v1;
  if ( v1 )
    (*(void (__fastcall **)(char *))(*(_QWORD *)v1 + 8LL))(v1);
  v3 = (unsigned __int64)(sub_335B0(*(__int64 **)(a1 + 8)) + 7) >> 3;
  v4 = v3 - 1;
  if ( v3 )
  {
    do
    {
      v5 = v4--;
      v6 = sub_334D0(*(unsigned __int64 **)(a1 + 8), v5);
      sub_2ECE0(*((__int64 (__fastcall ***)(_QWORD, char *, signed __int64))v2 + 1), v6);
    }
    while ( v4 != -1 );
  }
  v7 = (unsigned __int64)(sub_335B0(*(__int64 **)(a1 + 16)) + 7) >> 3;
  v8 = v7 - 1;
  if ( v7 )
  {
    do
    {
      v9 = v8--;
      v10 = sub_334D0(*(unsigned __int64 **)(a1 + 16), v9);
      sub_2ECE0(*((__int64 (__fastcall ***)(_QWORD, char *, signed __int64))v2 + 1), v10);
    }
    while ( v8 != -1 );
  }
  v11 = 0LL;
  (*(void (__fastcall **)(char *, __int64 *))(*(_QWORD *)v2 + 24LL))(v2, &v16);
  (*(void (__fastcall **)(char *))(*(_QWORD *)v2 + 32LL))(v2);
  v12 = (__int64 *)sub_BC640();
  v13 = sub_335B0(*(__int64 **)(a1 + 8));
  sub_BC720((__int64)v12, (__int64)"%zu ", v13);
  while ( 1 )
  {
    v14 = *((unsigned __int8 *)&v16 + v11);
    if ( v11 )
      break;
    sub_BC720((__int64)v12, (__int64)&unk_F1B19, &locale, v14);
LABEL_8:
    ++v11;
  }
  sub_BC720((__int64)v12, (__int64)&unk_F1B19, ":", v14);
  if ( (_DWORD)v11 != 15 )
    goto LABEL_8;
  if ( *(_QWORD *)(a1 + 56) )
    sub_BC720((__int64)v12, (__int64)" %s");
  return sub_BC6B0(v12);
}

_QWORD *__fastcall sub_7D400(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx

  v1 = sub_2F450(2uLL, 8uLL, 0LL);
  v2 = v1;
  *v1 = 0LL;
  v1[1] = 0LL;
  *v1 = sub_7D260(a1);
  return v2;
}

__int64 __fastcall sub_7D450(_QWORD **a1)
{
  int v1; // ebp
  int v2; // eax
  unsigned int v3; // edx
  unsigned __int64 *v4; // r12
  char v5; // bp
  __int64 *v6; // r12
  signed __int64 *v7; // r13
  char v8; // bp
  __int64 *v9; // r12
  signed __int64 *v10; // r13
  int v11; // ebp
  __int64 *v12; // r13
  __int64 *v13; // r12

  v1 = sub_340C0(a1[4], 2LL);
  v2 = sub_340C0(a1[5], 2LL);
  v3 = 0;
  if ( v2 & v1 )
  {
    v4 = sub_342F0(a1[4], a1[5]);
    v5 = sub_34130(v4, a1[1]);
    sub_330F0(v4);
    v6 = sub_334C0((__int64)a1[4]);
    sub_33B10(v6, (unsigned __int64 *)v6, 1LL);
    v7 = (signed __int64 *)sub_362D0(a1[2], a1[3], v6);
    sub_330F0(v6);
    v8 = sub_341A0(v7, 1LL) & v5;
    sub_330F0(v7);
    v9 = sub_334C0((__int64)a1[5]);
    sub_33B10(v9, (unsigned __int64 *)v9, 1LL);
    v10 = (signed __int64 *)sub_362D0(a1[2], a1[3], v9);
    sub_330F0(v9);
    v11 = sub_341A0(v10, 1LL) & v8 & 1;
    sub_330F0(v10);
    v12 = sub_36930(a1[4], a1[5]);
    v13 = sub_368F0(a1[4], a1[5]);
    sub_330F0(a1[4]);
    sub_330F0(a1[5]);
    sub_330F0(a1[6]);
    a1[4] = v12;
    a1[5] = v13;
    a1[6] = sub_355D0((unsigned __int64 *)v13, v12);
    v3 = v11 & 1;
  }
  return v3;
}

unsigned __int64 __fastcall sub_7D5B0(__int64 a1, __int64 a2, int a3)
{
  int v3; // er12
  int v4; // eax
  unsigned __int64 result; // rax

  v3 = a3;
  v4 = sub_335B0(*(__int64 **)(a2 + 8));
  sub_2ED90(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), v4);
  if ( v3 )
  {
    sub_33680(*(_QWORD *)(a1 + 8), *(__int64 **)(a2 + 8));
    result = sub_33680(*(_QWORD *)(a1 + 8), *(__int64 **)(a2 + 16));
  }
  else
  {
    sub_33680(*(_QWORD *)(a1 + 8), *(__int64 **)(a2 + 16));
    result = sub_33680(*(_QWORD *)(a1 + 8), *(__int64 **)(a2 + 8));
  }
  return result;
}

unsigned __int64 __fastcall sub_7D620(__int64 a1, __int64 **a2)
{
  sub_7D5B0(a1, (__int64)a2, 1);
  sub_33680(*(_QWORD *)(a1 + 8), a2[3]);
  sub_33680(*(_QWORD *)(a1 + 8), a2[6]);
  sub_33680(*(_QWORD *)(a1 + 8), a2[5]);
  return sub_33680(*(_QWORD *)(a1 + 8), a2[4]);
}

signed __int64 __fastcall sub_7D670(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rax
  signed __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-38h]
  __int64 v6; // [rsp+8h] [rbp-30h]
  __int64 v7; // [rsp+10h] [rbp-28h]
  int v8; // [rsp+18h] [rbp-20h]
  __int64 *v9; // [rsp+20h] [rbp-18h]
  unsigned __int64 v10; // [rsp+28h] [rbp-10h]

  v5 = a1;
  v7 = a2;
  v10 = __readfsqword(0x28u);
  v9 = &v5;
  v6 = 0LL;
  v8 = 0;
  sub_2F150((__int64)&v5);
  v2 = sub_337C0((__int64)v9);
  sub_330F0(v2);
  v3 = sub_337C0((__int64)v9);
  sub_330F0(v3);
  if ( *((_DWORD *)v9 + 6) )
    result = 0xFFFFFFFFLL;
  else
    result = (unsigned int)v6;
  return result;
}

void __fastcall sub_7D710(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi
  _QWORD *v5; // rdi

  v1 = a1;
  v2 = (_QWORD *)a1[3];
  if ( v2 )
  {
    sub_330F0(v2);
    v1[3] = 0LL;
  }
  v3 = (_QWORD *)v1[4];
  if ( v3 )
  {
    sub_330F0(v3);
    v1[4] = 0LL;
  }
  v4 = (_QWORD *)v1[5];
  if ( v4 )
  {
    sub_330F0(v4);
    v1[5] = 0LL;
  }
  v5 = (_QWORD *)v1[6];
  if ( v5 )
  {
    sub_330F0(v5);
    v1[6] = 0LL;
  }
}

void __fastcall sub_7D770(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rdi
  void *v4; // rdi

  v1 = a1;
  sub_7D710(a1);
  v2 = (_QWORD *)a1[1];
  if ( v2 )
  {
    sub_330F0(v2);
    v1[1] = 0LL;
  }
  v3 = (_QWORD *)v1[2];
  if ( v3 )
  {
    sub_330F0(v3);
    v1[2] = 0LL;
  }
  v4 = (void *)v1[7];
  if ( v4 )
  {
    sub_2F4D0(v4);
    v1[7] = 0LL;
  }
}

void __fastcall sub_7D7C0(__int64 a1)
{
  sub_7D770((_QWORD *)(a1 - 64));
  sub_2F4D0((void *)(a1 - 64));
}

_QWORD *__fastcall sub_7D7E0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rdi
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rdi
  _QWORD *v7; // rax
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 v10; // rdi
  _QWORD *v11; // rax
  __int64 v12; // rdi
  _QWORD *v13; // rax
  __int64 v14; // rdi

  v2 = sub_2F450(1uLL, 0x48uLL, 0LL);
  v3 = *(_QWORD *)(a2 + 32);
  v4 = v2;
  v2[7] = 0LL;
  v2[8] = off_3210C0;
  v5 = sub_33840(v3);
  v6 = *(_QWORD *)(a2 + 32);
  v4[1] = v5;
  v7 = sub_33840(v6);
  v8 = *(_QWORD *)(a2 + 32);
  v4[2] = v7;
  v9 = sub_33840(v8);
  v10 = *(_QWORD *)(a2 + 32);
  v4[3] = v9;
  v11 = sub_33840(v10);
  v12 = *(_QWORD *)(a2 + 32);
  v4[6] = v11;
  v13 = sub_33840(v12);
  v14 = *(_QWORD *)(a2 + 32);
  v4[4] = v13;
  v4[5] = sub_33840(v14);
  if ( !*(_DWORD *)(v14 + 24) && (unsigned __int8)sub_7D450((_QWORD **)v4) )
    return v4 + 8;
  sub_7D770(v4);
  sub_2F4D0(v4);
  return 0LL;
}

_QWORD *__fastcall sub_7D8A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  char *v4; // rax
  size_t v5; // rdx
  _QWORD *v6; // rax
  __int64 v7; // rdi
  _QWORD *v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rdi
  _QWORD *v11; // rax
  __int64 v12; // rdx
  _QWORD *result; // rax
  __int64 v14; // [rsp+0h] [rbp-48h]
  __int64 v15; // [rsp+8h] [rbp-40h]
  __int64 v16; // [rsp+10h] [rbp-38h]
  int v17; // [rsp+18h] [rbp-30h]
  __int64 *v18; // [rsp+20h] [rbp-28h]
  unsigned __int64 v19; // [rsp+28h] [rbp-20h]

  v3 = a1;
  v14 = a2;
  v16 = a3;
  v19 = __readfsqword(0x28u);
  v18 = &v14;
  v15 = 0LL;
  v17 = 0;
  v4 = sub_2F1D0((__int64)&v14);
  if ( !(unsigned __int8)sub_BD100(v4, v5, "ssh-rsa") )
    return 0LL;
  v6 = sub_2F450(1uLL, 0x48uLL, 0LL);
  v7 = (__int64)v18;
  v6[8] = v3;
  v8 = v6;
  v9 = sub_33840(v7);
  v10 = (__int64)v18;
  v8[2] = v9;
  v11 = sub_33840(v10);
  v12 = (__int64)v18;
  v8[1] = v11;
  result = v8 + 8;
  v8[3] = 0LL;
  v8[6] = 0LL;
  v8[5] = 0LL;
  v8[4] = 0LL;
  LODWORD(v12) = *(_DWORD *)(v12 + 24);
  v8[7] = 0LL;
  if ( (_DWORD)v12 )
  {
    sub_7D770(v8);
    sub_2F4D0(v8);
    result = 0LL;
  }
  return result;
}

__int64 __fastcall sub_7D9B0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  unsigned int v5; // ebp

  v3 = sub_7D8A0(a1, a2, a3);
  if ( v3 )
  {
    v4 = v3 - 8;
    v5 = sub_335B0((__int64 *)*(v3 - 7));
    sub_7D770(v4);
    sub_2F4D0(v4);
  }
  else
  {
    v5 = -1;
  }
  return v5;
}

_QWORD *__fastcall sub_7DA00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // r12
  _QWORD *v7; // rax
  _QWORD *v8; // rbx
  _QWORD *v9; // rbp
  _QWORD *v10; // rax
  __int64 v11; // rdi
  _QWORD *v12; // rax
  __int64 v13; // rdi
  _QWORD *v14; // rax
  __int64 v15; // rdi
  __int64 v17; // [rsp+0h] [rbp-58h]
  __int64 v18; // [rsp+8h] [rbp-50h]
  __int64 v19; // [rsp+10h] [rbp-48h]
  int v20; // [rsp+18h] [rbp-40h]
  __int64 *v21; // [rsp+20h] [rbp-38h]
  unsigned __int64 v22; // [rsp+28h] [rbp-30h]

  v5 = a4;
  v6 = a5;
  v22 = __readfsqword(0x28u);
  v7 = sub_7D8A0(a1, a2, a3);
  v8 = v7;
  if ( v7 )
  {
    v9 = v7 - 8;
    v17 = v5;
    v21 = &v17;
    v19 = v6;
    v18 = 0LL;
    v20 = 0;
    v10 = sub_33840((__int64)&v17);
    v11 = (__int64)v21;
    *(v8 - 5) = v10;
    v12 = sub_33840(v11);
    v13 = (__int64)v21;
    *(v8 - 4) = v12;
    v14 = sub_33840(v13);
    v15 = (__int64)v21;
    *(v8 - 3) = v14;
    *(v8 - 2) = sub_33840(v15);
    if ( *((_DWORD *)v21 + 6) || !(unsigned __int8)sub_7D450((_QWORD **)v9) )
    {
      v8 = 0LL;
      sub_7D770(v9);
      sub_2F4D0(v9);
    }
  }
  return v8;
}

signed __int64 __fastcall sub_7DAE0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  signed __int64 v3; // rdx
  bool v4; // zf
  signed __int64 result; // rax

  v2 = sub_7D8A0((__int64)off_3210C0, a1, a2);
  v3 = (signed __int64)(v2 - 8);
  v4 = v2 == 0LL;
  result = 0LL;
  if ( !v4 )
    result = v3;
  return result;
}

void __fastcall sub_7DB10(_QWORD *a1)
{
  sub_7D770(a1);
  sub_2F4D0(a1);
}

signed __int64 __fastcall sub_7DB30(__int64 a1)
{
  return sub_335B0(*(__int64 **)(a1 + 8));
}

__int64 __fastcall sub_7DB50(__int64 a1, __int64 a2, void *a3, size_t a4)
{
  __int64 v4; // r12
  unsigned __int64 v5; // rbp
  int v6; // ST24_4
  __int64 v7; // rax
  char *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r14
  __int64 v11; // ST08_8
  unsigned __int64 *v12; // r13
  unsigned __int64 *v13; // r12
  unsigned int v14; // eax
  unsigned __int64 v15; // rsi
  signed __int64 v16; // rbp
  signed __int64 v17; // r14
  unsigned __int64 v19; // [rsp+0h] [rbp-68h]
  __int64 v20; // [rsp+10h] [rbp-58h]
  const void *src; // [rsp+18h] [rbp-50h]

  v4 = *(_QWORD *)(a2 + 40);
  src = a3;
  v19 = a4;
  v5 = (unsigned __int64)(sub_335B0(*(__int64 **)(a1 + 8)) + 7) >> 3;
  if ( !v19 || (signed int)v5 - 2 * (signed int)v4 - 2 < v19 )
    __assert_fail("in.len > 0 && in.len <= k - 2*HLEN - 2", "sshrsa.c", 0x3C9u, "ssh_rsakex_encrypt");
  v6 = v5 - 2 * v4;
  v7 = sub_BC650();
  v20 = v7;
  v8 = sub_BC510(v7, (signed int)v5);
  v9 = (__int64)v8;
  *v8 = 0;
  v10 = (__int64)&v8[(signed int)v4 + 1];
  v11 = (__int64)(v8 + 1);
  sub_7BF50(v8 + 1, (signed int)v4);
  sub_5E520((__int64 (**)(void))a2, (__int64)&locale, 0LL, v10);
  memset((void *)(v9 + 2 * (signed int)v4 + 1), 0, (signed int)v5 - (2 * (signed int)v4 + 1));
  *(_BYTE *)(v9 + (signed int)v5 - v19 - 1) = 1;
  memcpy((void *)(v9 + (signed int)v5 - v19), src, v19);
  sub_7C460(a2, v11, (unsigned int)v4, v10, v6 + v4 - 1);
  sub_7C460(a2, v10, (unsigned int)(v6 + v4 - 1), v11, v4);
  v12 = sub_33390(v9, (signed int)v5);
  v13 = sub_364B0(v12, *(unsigned __int64 **)(a1 + 16), *(_QWORD *)(a1 + 8));
  v14 = v5 - 1;
  if ( (_DWORD)v5 )
  {
    v15 = (signed int)v14;
    v16 = (signed int)v14 - 1LL;
    v17 = v16 - v14;
    while ( 1 )
    {
      *(_BYTE *)(++v9 - 1) = sub_334D0(v13, v15);
      v15 = v16;
      if ( v16 == v17 )
        break;
      --v16;
    }
  }
  sub_330F0(v12);
  sub_330F0(v13);
  return v20;
}

_QWORD *__fastcall sub_7DD20(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // r12
  unsigned __int64 v6; // rbp
  __int64 *v7; // rdi
  __int64 v8; // r13
  unsigned __int64 v9; // rbx
  unsigned __int64 *v10; // r12
  _BYTE *v11; // rax
  _BYTE *v12; // rbp
  _BYTE *v13; // r14
  unsigned __int64 v14; // rsi
  signed __int64 v15; // r15
  signed int v16; // edx
  _BYTE *v17; // rcx
  char v18; // cl
  _BYTE *v19; // rax
  char v20; // cl
  _QWORD *result; // rax
  _QWORD *v22; // [rsp+0h] [rbp-D8h]
  void *s2; // [rsp+8h] [rbp-D0h]
  __int64 (**v24)(void); // [rsp+10h] [rbp-C8h]
  unsigned __int64 *v25; // [rsp+18h] [rbp-C0h]
  _BYTE *v26; // [rsp+20h] [rbp-B8h]
  __int64 v27; // [rsp+28h] [rbp-B0h]
  __int64 v28; // [rsp+30h] [rbp-A8h]
  int v29; // [rsp+38h] [rbp-A0h]
  __int64 *v30; // [rsp+40h] [rbp-98h]
  char v31; // [rsp+50h] [rbp-88h]
  unsigned __int64 v32; // [rsp+98h] [rbp-40h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  v7 = *(__int64 **)(a1 + 8);
  v8 = *(_QWORD *)(a2 + 40);
  v32 = __readfsqword(0x28u);
  v24 = (__int64 (**)(void))a2;
  v9 = (unsigned __int64)(sub_335B0(v7) + 7) >> 3;
  if ( v6 != (signed int)v9 )
    return 0LL;
  v25 = sub_33390(v4, v6);
  v10 = sub_7C240(
          v25,
          *(unsigned __int64 **)(v5 + 24),
          *(__int64 **)(v5 + 8),
          *(_QWORD *)(v5 + 32),
          *(__int64 **)(v5 + 40),
          *(unsigned __int64 **)(v5 + 48));
  v11 = sub_2F450(v6, 1uLL, 0LL);
  v12 = v11;
  if ( (signed int)v9 > 0 )
  {
    v13 = v11;
    v14 = (signed int)v9 - 1;
    v15 = v14 - 1;
    s2 = (void *)(v14 - 1 - (unsigned int)(v9 - 1));
    while ( 1 )
    {
      *(++v13 - 1) = sub_334D0(v10, v14);
      v14 = v15;
      if ( (void *)v15 == s2 )
        break;
      --v15;
    }
  }
  sub_330F0(v25);
  sub_330F0(v10);
  sub_7C460((__int64)v24, (__int64)&v12[(signed int)v8 + 1], (unsigned int)(v9 - v8 - 1), (__int64)(v12 + 1), v8);
  sub_7C460((__int64)v24, (__int64)(v12 + 1), (unsigned int)v8, (__int64)&v12[(signed int)v8 + 1], v9 - v8 - 1);
  if ( *v12 )
    goto LABEL_21;
  if ( (unsigned int)v8 > 0x40 )
    __assert_fail("HLEN <= lenof(labelhash)", "sshrsa.c", 0x425u, "ssh_rsakex_decrypt");
  sub_5E520(v24, (__int64)&locale, 0LL, (__int64)&v31);
  if ( memcmp(&v12[(signed int)v8 + 1], &v31, (signed int)v8) )
    goto LABEL_21;
  v16 = 2 * v8 + 1;
  v17 = &v12[v16];
  if ( (signed int)v9 > v16 )
  {
    v18 = *v17;
    if ( v18 == 1 )
    {
LABEL_22:
      v17 = &v12[++v16];
    }
    else
    {
      v19 = &v12[v16 + 1];
      if ( v18 )
      {
LABEL_21:
        sub_2F4D0(v12);
        return 0LL;
      }
      while ( 1 )
      {
        ++v16;
        v17 = v19;
        if ( (_DWORD)v9 == v16 )
          break;
        v20 = *v19;
        if ( *v19 == 1 )
          goto LABEL_22;
        ++v19;
        if ( v20 )
          goto LABEL_21;
      }
      v16 = v9;
    }
  }
  v26 = v17;
  v27 = 0LL;
  v29 = 0;
  v30 = (__int64 *)&v26;
  v28 = (signed int)v9 - v16;
  v22 = sub_33840((__int64)&v26);
  sub_2F4D0(v12);
  result = v22;
  if ( *((_DWORD *)v30 + 6) || v30[2] != v30[1] )
  {
    sub_330F0(v22);
    result = 0LL;
  }
  return result;
}

__int64 sub_7DFE0()
{
  unsigned int v5; // esi
  __int64 result; // rax

  _RAX = 0LL;
  __asm { cpuid }
  v5 = _RAX;
  result = 0LL;
  if ( v5 > 6 )
  {
    _RAX = 7LL;
    __asm { cpuid }
    result = ((unsigned int)_RBX >> 29) & 1;
  }
  return result;
}

__int64 sub_7E030()
{
  char v0; // al
  signed __int64 (__fastcall *v1)(__int64); // rdx
  __int64 (__fastcall **v2)(); // rdi
  __int64 v3; // rax
  __int64 v4; // rbx

  v0 = byte_32646C;
  if ( !byte_32646D )
  {
    v0 = sub_7DFE0();
    byte_32646D = 1;
    byte_32646C = v0;
  }
  v1 = sub_7E220;
  v2 = off_3211C0;
  if ( v0 )
  {
    v1 = sub_7E260;
    if ( v0 )
      v2 = off_321160;
  }
  v3 = v1((__int64)v2);
  v4 = v3;
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  return v4;
}

void __fastcall sub_7E0A0(__int64 a1)
{
  __m128i v1; // xmm0

  v1 = _mm_load_si128((const __m128i *)&xmmword_F1EE0);
  *(_QWORD *)(a1 - 40) = 0LL;
  *(_QWORD *)(a1 - 32) = 0LL;
  *(__m128i *)(a1 - 136) = v1;
  *(__m128i *)(a1 - 120) = _mm_load_si128((const __m128i *)&xmmword_F1EF0);
}

signed __int64 __fastcall sub_7E0D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __m128i v3; // xmm0
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 - 24);
  *(__m128i *)(a1 - 136) = _mm_load_si128((const __m128i *)(a2 - 136));
  *(__m128i *)(a1 - 120) = _mm_load_si128((const __m128i *)(a2 - 120));
  *(__m128i *)(a1 - 104) = _mm_load_si128((const __m128i *)(a2 - 104));
  *(__m128i *)(a1 - 88) = _mm_load_si128((const __m128i *)(a2 - 88));
  *(__m128i *)(a1 - 72) = _mm_load_si128((const __m128i *)(a2 - 72));
  *(__m128i *)(a1 - 56) = _mm_load_si128((const __m128i *)(a2 - 56));
  *(__m128i *)(a1 - 40) = _mm_load_si128((const __m128i *)(a2 - 40));
  *(__m128i *)(a1 - 24) = _mm_load_si128((const __m128i *)(a2 - 24));
  *(__m128i *)(a1 - 8) = _mm_load_si128((const __m128i *)(a2 - 8));
  v3 = _mm_load_si128((const __m128i *)(a2 + 8));
  *(_QWORD *)(a1 - 24) = v2;
  result = a1 - 16;
  *(__m128i *)(a1 + 8) = v3;
  *(_QWORD *)(a1 - 8) = a1 - 16;
  *(_QWORD *)(a1 + 8) = a1 - 16;
  return result;
}

void __fastcall sub_7E150(__int64 a1)
{
  sub_BD070((void *)(a1 - 128), 0x90uLL);
  sub_2F4D0((void *)(a1 - 128));
}

void __fastcall sub_7E170(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 - 24);
  sub_BD070((void *)(a1 - 136), 0xA0uLL);
  sub_2F4D0(v1);
}

void __fastcall sub_7E190(__int64 a1)
{
  __m128i v1; // xmm0

  v1 = _mm_load_si128((const __m128i *)&xmmword_F1EC0);
  *(_QWORD *)(a1 - 32) = 0LL;
  *(_QWORD *)(a1 - 24) = 0LL;
  *(__m128i *)(a1 - 128) = v1;
  *(__m128i *)(a1 - 112) = _mm_load_si128((const __m128i *)&xmmword_F1ED0);
}

signed __int64 __fastcall sub_7E1C0(__m128i *a1, const __m128i *a2)
{
  signed __int64 result; // rax
  __m128i v3; // xmm0

  a1[-8] = _mm_loadu_si128(a2 - 8);
  result = (signed __int64)a1[-1].m128i_i64;
  a1[-7] = _mm_loadu_si128(a2 - 7);
  a1[-6] = _mm_loadu_si128(a2 - 6);
  a1[-5] = _mm_loadu_si128(a2 - 5);
  a1[-4] = _mm_loadu_si128(a2 - 4);
  a1[-3] = _mm_loadu_si128(a2 - 3);
  a1[-2] = _mm_loadu_si128(a2 - 2);
  a1[-1] = _mm_loadu_si128(a2 - 1);
  v3 = _mm_loadu_si128(a2);
  a1[-1].m128i_i64[1] = result;
  *a1 = v3;
  a1->m128i_i64[1] = result;
  return result;
}

char *__fastcall sub_7E220(__int64 a1)
{
  _QWORD *v1; // rax
  signed __int64 v2; // rdx
  char *result; // rax

  v1 = sub_2F450(1uLL, 0x90uLL, 0LL);
  v2 = (signed __int64)(v1 + 14);
  v1[16] = a1;
  result = (char *)(v1 + 16);
  *((_QWORD *)result - 2) = sub_7ED30;
  *((_QWORD *)result - 1) = v2;
  *((_QWORD *)result + 1) = v2;
  return result;
}

_QWORD *__fastcall sub_7E260(__int64 a1)
{
  char v1; // al
  void *v2; // rax
  _QWORD *v3; // rdx

  v1 = byte_32646C;
  if ( !byte_32646D )
  {
    v1 = sub_7DFE0();
    byte_32646D = 1;
    byte_32646C = v1;
  }
  if ( !v1 )
    return 0LL;
  v2 = sub_2F450(0xAFuLL, 1uLL, 0LL);
  v3 = (_QWORD *)(((unsigned __int64)v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v3[14] = v2;
  v3[17] = a1;
  v3[15] = sub_7E3B0;
  v3[16] = v3 + 15;
  v3[18] = v3 + 15;
  return v3 + 17;
}

__int64 __fastcall sub_7E2F0(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  signed __int64 v3; // r13
  signed __int64 v4; // r12
  __int64 result; // rax
  int v6; // edx

  v2 = 8LL * *(_QWORD *)(a1 - 24);
  v3 = ((55 - *(_DWORD *)(a1 - 32)) & 0x3F) + 1LL;
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  if ( v3 != 1 )
  {
    v4 = 1LL;
    do
    {
      ++v4;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 0);
    }
    while ( v3 != v4 );
  }
  sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v2);
  result = *(_QWORD *)(a1 - 32);
  if ( result )
    sub_1AEDC();
  do
  {
    v6 = *(_DWORD *)(a1 + 4 * result - 128);
    *(_BYTE *)(a2 + 4 * result + 3) = v6;
    *(_BYTE *)(a2 + 4 * result + 2) = BYTE1(v6);
    *(_BYTE *)(a2 + 4 * result + 1) = BYTE2(v6);
    *(_BYTE *)(a2 + 4 * result++) = HIBYTE(v6);
  }
  while ( result != 8 );
  return result;
}

void *__fastcall sub_7E3B0(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  char *v4; // r15
  __int64 i; // rbp
  size_t v6; // rdi
  char *v7; // rsi
  size_t v8; // rbx
  void *result; // rax
  __int64 v10; // rdi
  __int128 v11; // t1

  v3 = a3;
  v4 = a2;
  for ( i = a1; v3; *(__m128i *)(i - 120) = _mm_add_epi32(_XMM4, _XMM1) )
  {
    v6 = *(_QWORD *)(i - 24);
    while ( 1 )
    {
      v7 = v4;
      v8 = 64 - v6;
      if ( 64 - v6 > v3 )
        v8 = v3;
      v4 += v8;
      v3 -= v8;
      result = memcpy((void *)(i - 88 + v6), v7, v8);
      v10 = *(_QWORD *)(i - 24);
      *(_QWORD *)(i - 16) += v8;
      v6 = v8 + v10;
      *(_QWORD *)(i - 24) = v6;
      if ( v6 == 64 )
        break;
      if ( !v3 )
        return result;
    }
    v11 = *(_OWORD *)(i - 88);
    *(_QWORD *)(i - 24) = 0LL;
    _XMM4 = _mm_load_si128((const __m128i *)(i - 120));
    __asm { sha256rnds2 xmm2, xmm4, xmm0 }
    _XMM5 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(i - 72)), (__m128i)xmmword_F1F00);
    __asm
    {
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM10 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(i - 56)), (__m128i)xmmword_F1F00);
    _XMM6 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(i - 40)), (__m128i)xmmword_F1F00);
    __asm
    {
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg1 xmm7, xmm5
      sha256msg1 xmm5, xmm10
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm7, xmm6
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg1 xmm9, xmm6
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm5, xmm7
      sha256msg1 xmm6, xmm7
      sha256rnds2 xmm1, xmm2, xmm0
    }
    _XMM8 = _XMM5;
    __asm
    {
      sha256rnds2 xmm2, xmm1, xmm0
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm9, xmm8
      sha256msg1 xmm7, xmm8
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm5, xmm9
      sha256msg1 xmm8, xmm9
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm7, xmm5
      sha256msg1 xmm9, xmm5
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm8, xmm7
      sha256msg1 xmm5, xmm7
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm9, xmm8
      sha256msg1 xmm7, xmm8
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm5, xmm9
      sha256msg1 xmm8, xmm9
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm7, xmm5
      sha256msg1 xmm6, xmm5
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm8, xmm7
      sha256msg1 xmm5, xmm7
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm6, xmm8
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm5, xmm6
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
    }
    *(__m128i *)(i - 104) = _mm_add_epi32(_mm_load_si128((const __m128i *)(i - 104)), _XMM2);
    __asm { sha256rnds2 xmm1, xmm2, xmm0 }
  }
  return result;
}

unsigned __int64 __fastcall sub_7E770(__int64 a1, __m128i *a2)
{
  __int64 v2; // r12
  signed __int64 v3; // rbp
  signed __int64 v4; // rbx
  unsigned __int64 result; // rax
  __m128i v6; // xmm2
  __m128i v7; // xmm0
  __m128i v8; // xmm1
  __m128i v9; // xmm0
  __m128i v10; // xmm2

  v2 = 8LL * *(_QWORD *)(a1 - 32);
  v3 = ((55 - *(_DWORD *)(a1 - 40)) & 0x3F) + 1LL;
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  if ( v3 != 1 )
  {
    v4 = 1LL;
    do
    {
      ++v4;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 0);
    }
    while ( v3 != v4 );
  }
  result = sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v2);
  if ( *(_QWORD *)(a1 - 40) )
    sub_1AEDC();
  v6 = _mm_shuffle_epi32(*(__m128i *)(a1 - 136), 27);
  v7 = _mm_shuffle_epi32(*(__m128i *)(a1 - 120), 177);
  v8 = _mm_blend_epi16(v6, v7, 240);
  v9 = _mm_alignr_epi8(v7, v6, 8);
  v10 = _mm_load_si128((const __m128i *)&xmmword_F1F00);
  *a2 = _mm_shuffle_epi8(v8, v10);
  a2[1] = _mm_shuffle_epi8(v9, v10);
  return result;
}

unsigned __int64 __fastcall sub_7E840(int *a1, __int64 a2)
{
  __int64 v2; // rax
  char *v3; // rdi
  char *v4; // r11
  unsigned int v5; // eax
  unsigned int v6; // ecx
  signed int v7; // er13
  signed int v8; // er12
  signed int v9; // ebp
  int v10; // esi
  int v11; // ecx
  int v12; // eax
  int v13; // edi
  int v14; // er8
  int v15; // er9
  int v16; // er10
  __int128 *v17; // r14
  int v18; // ebx
  int v19; // er13
  int v20; // eax
  int v21; // er10
  int v22; // er12
  int v23; // ebx
  int v24; // edx
  int v25; // ebp
  int v26; // ecx
  int v27; // er8
  int v28; // ebp
  int v29; // er9
  int v30; // esi
  int v31; // edi
  int v32; // eax
  int v33; // ebp
  int v34; // edx
  int v35; // ecx
  int v36; // ebp
  int v37; // esi
  int v38; // edx
  signed int v40; // [rsp+Ch] [rbp-18Ch]
  signed int v41; // [rsp+10h] [rbp-188h]
  signed int v42; // [rsp+14h] [rbp-184h]
  signed int v43; // [rsp+18h] [rbp-180h]
  signed int v44; // [rsp+1Ch] [rbp-17Ch]
  int *v45; // [rsp+20h] [rbp-178h]
  int v46; // [rsp+30h] [rbp-168h]
  int v47; // [rsp+34h] [rbp-164h]
  int v48; // [rsp+38h] [rbp-160h]
  int v49; // [rsp+3Ch] [rbp-15Ch]
  int v50; // [rsp+44h] [rbp-154h]
  int v51; // [rsp+48h] [rbp-150h]
  int v52; // [rsp+4Ch] [rbp-14Ch]
  char v53[264]; // [rsp+50h] [rbp-148h]
  unsigned __int64 v54; // [rsp+158h] [rbp-40h]

  v45 = a1;
  v54 = __readfsqword(0x28u);
  v2 = 0LL;
  do
  {
    *(_DWORD *)&v53[4 * v2] = _byteswap_ulong(*(_DWORD *)(a2 + 4 * v2));
    ++v2;
  }
  while ( v2 != 16 );
  v3 = v53;
  v4 = v53;
  do
  {
    v5 = *((_DWORD *)v3 + 14);
    v6 = *((_DWORD *)v3 + 1);
    v3 += 4;
    *((_DWORD *)v3 + 15) = *((_DWORD *)v3 + 8)
                         + *((_DWORD *)v3 - 1)
                         + ((v5 >> 10) ^ __ROL4__(v5, 13) ^ __ROL4__(v5, 15))
                         + ((v6 >> 3) ^ __ROL4__(v6, 14) ^ __ROR4__(v6, 7));
  }
  while ( &v53[192] != v3 );
  v7 = 1116352408;
  v8 = 1899447441;
  v9 = -1245643825;
  v44 = -373957723;
  v43 = 961987163;
  v42 = 1508970993;
  v41 = -1841331548;
  v10 = *v45;
  v11 = v45[1];
  v12 = v45[3];
  v13 = v45[4];
  v14 = v45[5];
  v15 = v45[6];
  v46 = *v45;
  v47 = v45[1];
  v48 = v45[2];
  v49 = v45[3];
  v16 = v45[7];
  v52 = v45[7];
  v50 = v45[5];
  v17 = (__int128 *)&unk_F1DC0;
  v51 = v45[6];
  v40 = -1424204075;
  v18 = v45[2];
  while ( 1 )
  {
    v19 = *(_DWORD *)v4
        + (v15 ^ v13 & (v14 ^ v15))
        + (__ROL4__(v13, 7) ^ __ROR4__(v13, 6) ^ __ROR4__(v13, 11))
        + v16
        + v7;
    v20 = v19 + v12;
    v21 = v19 + (__ROL4__(v10, 10) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 13)) + (v11 & v10 | v18 & (v11 | v10));
    v22 = (v14 ^ v20 & (v14 ^ v13))
        + *((_DWORD *)v4 + 1)
        + v15
        + (__ROL4__(v20, 7) ^ __ROR4__(v20, 6) ^ __ROR4__(v20, 11))
        + v8;
    v23 = v22 + v18;
    v24 = v22 + (__ROL4__(v21, 10) ^ __ROR4__(v21, 2) ^ __ROR4__(v21, 13)) + (v21 & v10 | v11 & (v21 | v10));
    v25 = (__ROL4__(v23, 7) ^ __ROR4__(v23, 6) ^ __ROR4__(v23, 11))
        + (v13 ^ v23 & (v20 ^ v13))
        + *((_DWORD *)v4 + 2)
        + v14
        + v9;
    v26 = v25 + v11;
    v27 = v25 + (__ROL4__(v24, 10) ^ __ROR4__(v24, 2) ^ __ROR4__(v24, 13)) + (v21 & v24 | v10 & (v21 | v24));
    v28 = __ROR4__(
            v25 + (__ROL4__(v24, 10) ^ __ROR4__(v24, 2) ^ __ROR4__(v24, 13)) + (v21 & v24 | v10 & (v21 | v24)),
            13);
    v29 = *((_DWORD *)v4 + 3)
        + v13
        + (v20 ^ v26 & (v20 ^ v23))
        + (__ROL4__(v26, 7) ^ __ROR4__(v26, 6) ^ __ROR4__(v26, 11))
        + v44;
    v30 = v29 + v10;
    v31 = v29 + (__ROL4__(v27, 10) ^ __ROR4__(v27, 2) ^ v28) + (v24 & v27 | v21 & (v24 | v27));
    v32 = *((_DWORD *)v4 + 4)
        + v20
        + (v23 ^ v30 & (v23 ^ v26))
        + (__ROL4__(v30, 7) ^ __ROR4__(v30, 6) ^ __ROR4__(v30, 11));
    v16 = v32 + v43 + v21;
    v12 = v32 + v43 + (__ROL4__(v31, 10) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 2)) + (v27 & v31 | v24 & (v27 | v31));
    v33 = (__ROL4__(v16, 7) ^ __ROR4__(v16, 11) ^ __ROR4__(v16, 6))
        + (v26 ^ v16 & (v26 ^ v30))
        + *((_DWORD *)v4 + 5)
        + v23
        + v42;
    v15 = v33 + v24;
    v18 = v33 + (__ROL4__(v12, 10) ^ __ROR4__(v12, 13) ^ __ROR4__(v12, 2)) + (v31 & v12 | v27 & (v31 | v12));
    v34 = v41
        + (v30 ^ v15 & (v30 ^ v16))
        + *((_DWORD *)v4 + 6)
        + v26
        + (__ROL4__(v15, 7) ^ __ROR4__(v15, 11) ^ __ROR4__(v15, 6));
    v35 = __ROR4__(
            v33 + (__ROL4__(v12, 10) ^ __ROR4__(v12, 13) ^ __ROR4__(v12, 2)) + (v31 & v12 | v27 & (v31 | v12)),
            13) ^ __ROR4__(v18, 2);
    v36 = __ROL4__(
            v33 + (__ROL4__(v12, 10) ^ __ROR4__(v12, 13) ^ __ROR4__(v12, 2)) + (v31 & v12 | v27 & (v31 | v12)),
            10);
    v14 = v34 + v27;
    v37 = *((_DWORD *)v4 + 7) + v30;
    v4 += 32;
    v11 = v34 + (v35 ^ v36) + (v12 & v18 | v31 & (v12 | v18));
    v38 = v40 + (v16 ^ v14 & (v16 ^ v15)) + v37 + (__ROL4__(v14, 7) ^ __ROR4__(v14, 11) ^ __ROR4__(v14, 6));
    v13 = v38 + v31;
    v10 = v38 + (__ROR4__(v11, 13) ^ __ROR4__(v11, 2) ^ __ROL4__(v11, 10)) + (v18 & v11 | v12 & (v18 | v11));
    v17 += 2;
    if ( &xmmword_F1EC0 == v17 )
      break;
    v9 = *((_DWORD *)v17 + 2);
    v8 = *((_DWORD *)v17 + 1);
    v7 = *(_DWORD *)v17;
    v40 = *((_DWORD *)v17 + 7);
    v41 = *((_DWORD *)v17 + 6);
    v42 = *((_DWORD *)v17 + 5);
    v43 = *((_DWORD *)v17 + 4);
    v44 = *((_DWORD *)v17 + 3);
  }
  v45[4] += v13;
  *v45 = v46 + v10;
  v45[3] = v49 + v12;
  v45[1] = v47 + v11;
  v45[2] = v48 + v18;
  v45[5] = v50 + v14;
  v45[6] = v51 + v15;
  v45[7] = v52 + v16;
  sub_BD070(v53, 0x100uLL);
  return __readfsqword(0x28u) ^ v54;
}

signed __int64 __fastcall sub_7ED30(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r15
  signed __int64 result; // rax
  __int64 v5; // r14
  char *v6; // rbp
  size_t v7; // rdi
  __int64 v8; // r12
  char *v9; // rsi
  size_t v10; // rbx
  __int64 v11; // rdi
  int *i; // [rsp+8h] [rbp-40h]

  v3 = a3;
  result = a1 - 112;
  v5 = a1;
  v6 = a2;
  for ( i = (int *)(a1 - 112); v3; result = sub_7E840(i, v8) )
  {
    v7 = *(_QWORD *)(v5 - 16);
    v8 = (__int64)(i + 8);
    while ( 1 )
    {
      v9 = v6;
      v10 = 64 - v7;
      if ( 64 - v7 > v3 )
        v10 = v3;
      v6 += v10;
      v3 -= v10;
      result = (signed __int64)memcpy((void *)(v8 + v7), v9, v10);
      v11 = *(_QWORD *)(v5 - 16);
      *(_QWORD *)(v5 - 8) += v10;
      v7 = v10 + v11;
      *(_QWORD *)(v5 - 16) = v7;
      if ( v7 == 64 )
        break;
      if ( !v3 )
        return result;
    }
    *(_QWORD *)(v5 - 16) = 0LL;
  }
  return result;
}

__int64 __fastcall sub_7EDE0(__int64 a1)
{
  __int64 v1; // rdx
  __int64 (__fastcall **v2)(_QWORD); // rax
  __int64 v3; // rax
  __int64 v4; // rbx

  v1 = *(_QWORD *)(a1 + 80);
  v2 = *(__int64 (__fastcall ***)(_QWORD))(v1 + 8);
  if ( byte_32646F )
  {
    if ( byte_32646E )
      v2 = *(__int64 (__fastcall ***)(_QWORD))v1;
  }
  else
  {
    byte_32646E = 0;
    byte_32646F = 1;
  }
  v3 = (*v2)(v2);
  v4 = v3;
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  return v4;
}

__int64 sub_7EE30()
{
  return 0LL;
}

void __fastcall sub_7EE40(__int64 a1)
{
  sub_BD070((void *)(a1 - 232), 0xF8uLL);
  sub_2F4D0((void *)(a1 - 232));
}

void __noreturn sub_7EE60()
{
  __assert_fail("false && \"Should never be called\"", "sshsh512.c", 0x32Bu, "sha512_stub_free");
}

void __noreturn sub_7EE90()
{
  __assert_fail("false && \"Should never be called\"", "sshsh512.c", 0x32Cu, "sha512_stub_digest");
}

void __noreturn sub_7EEC0()
{
  __assert_fail("false && \"Should never be called\"", "sshsh512.c", 0x32Au, "sha512_stub_copyfrom");
}

void __noreturn sub_7EEF0()
{
  __assert_fail("false && \"Should never be called\"", "sshsh512.c", 0x329u, "sha512_stub_reset");
}

const __m128i *__fastcall sub_7EF20(__int64 a1)
{
  const __m128i *result; // rax
  __m128i v2; // xmm0

  result = *(const __m128i **)(*(_QWORD *)a1 + 80LL);
  *(__m128i *)(a1 - 232) = _mm_loadu_si128(result);
  *(__m128i *)(a1 - 216) = _mm_loadu_si128(result + 1);
  *(__m128i *)(a1 - 200) = _mm_loadu_si128(result + 2);
  v2 = _mm_loadu_si128(result + 3);
  *(_QWORD *)(a1 - 40) = 0LL;
  *(_QWORD *)(a1 - 24) = 0LL;
  *(__m128i *)(a1 - 184) = v2;
  *(_QWORD *)(a1 - 32) = 0LL;
  return result;
}

signed __int64 __fastcall sub_7EF70(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __m128i v3; // xmm0

  result = a1 - 16;
  *(__m128i *)(a1 - 232) = _mm_loadu_si128((const __m128i *)(a2 - 232));
  *(__m128i *)(a1 - 216) = _mm_loadu_si128((const __m128i *)(a2 - 216));
  *(__m128i *)(a1 - 200) = _mm_loadu_si128((const __m128i *)(a2 - 200));
  *(__m128i *)(a1 - 184) = _mm_loadu_si128((const __m128i *)(a2 - 184));
  *(__m128i *)(a1 - 168) = _mm_loadu_si128((const __m128i *)(a2 - 168));
  *(__m128i *)(a1 - 152) = _mm_loadu_si128((const __m128i *)(a2 - 152));
  *(__m128i *)(a1 - 136) = _mm_loadu_si128((const __m128i *)(a2 - 136));
  *(__m128i *)(a1 - 120) = _mm_loadu_si128((const __m128i *)(a2 - 120));
  *(__m128i *)(a1 - 104) = _mm_loadu_si128((const __m128i *)(a2 - 104));
  *(__m128i *)(a1 - 88) = _mm_loadu_si128((const __m128i *)(a2 - 88));
  *(__m128i *)(a1 - 72) = _mm_loadu_si128((const __m128i *)(a2 - 72));
  *(__m128i *)(a1 - 56) = _mm_loadu_si128((const __m128i *)(a2 - 56));
  *(__m128i *)(a1 - 40) = _mm_loadu_si128((const __m128i *)(a2 - 40));
  *(__m128i *)(a1 - 24) = _mm_loadu_si128((const __m128i *)(a2 - 24));
  v3 = _mm_loadu_si128((const __m128i *)(a2 - 8));
  *(_QWORD *)(a1 + 8) = a1 - 16;
  *(__m128i *)(a1 - 8) = v3;
  *(_QWORD *)(a1 - 8) = a1 - 16;
  return result;
}

char *__fastcall sub_7F030(__int64 a1)
{
  _QWORD *v1; // rax
  signed __int64 v2; // rdx
  char *result; // rax

  v1 = sub_2F450(1uLL, 0xF8uLL, 0LL);
  v2 = (signed __int64)(v1 + 27);
  v1[29] = a1;
  result = (char *)(v1 + 29);
  *((_QWORD *)result - 2) = sub_7F760;
  *((_QWORD *)result - 1) = v2;
  *((_QWORD *)result + 1) = v2;
  return result;
}

unsigned __int64 __fastcall sub_7F070(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // r13
  unsigned int v4; // er12
  unsigned __int64 v5; // rdx
  unsigned __int64 result; // rax
  __int64 v7; // rax

  v2 = *(_QWORD *)(a1 - 32);
  v3 = *(_QWORD *)(a1 - 24);
  v4 = (111 - *(_DWORD *)(a1 - 40)) & 0x7F;
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  sub_2EC40(*(void (__fastcall ***)(_QWORD, __int64 *, signed __int64))(a1 - 8), v4, 0);
  sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v2);
  sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v3);
  v5 = *(_QWORD *)(a1 - 40);
  if ( v5 )
    __assert_fail(
      "blk->used == 0 && \"Should have exactly hit a block boundary\"",
      "sshsh512.c",
      0xDEu,
      "sha512_block_pad");
  result = *(_QWORD *)(*(_QWORD *)a1 + 40LL) >> 3;
  if ( result )
  {
    do
    {
      v7 = *(_QWORD *)(a1 + 8 * v5++ - 232);
      a2 += 8LL;
      *(_BYTE *)(a2 - 1) = v7;
      *(_BYTE *)(a2 - 2) = BYTE1(v7);
      *(_BYTE *)(a2 - 3) = BYTE2(v7);
      *(_BYTE *)(a2 - 4) = BYTE3(v7);
      *(_BYTE *)(a2 - 5) = BYTE4(v7);
      *(_BYTE *)(a2 - 6) = BYTE5(v7);
      *(_BYTE *)(a2 - 8) = HIBYTE(v7);
      *(_BYTE *)(a2 - 7) = BYTE6(v7);
      result = *(_QWORD *)(*(_QWORD *)a1 + 40LL) >> 3;
    }
    while ( result > v5 );
  }
  return result;
}

unsigned __int64 __fastcall sub_7F180(signed __int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  char *v3; // rdi
  char *v4; // r11
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rcx
  signed __int64 v7; // r13
  signed __int64 v8; // r12
  signed __int64 v9; // rbp
  signed __int64 v10; // rsi
  signed __int64 v11; // rax
  signed __int64 v12; // rdi
  signed __int64 v13; // r8
  signed __int64 v14; // r9
  signed __int64 v15; // r14
  signed __int64 v16; // r10
  _QWORD *v17; // r15
  signed __int64 v18; // rbx
  signed __int64 v19; // rcx
  signed __int64 v20; // rcx
  signed __int64 v21; // rax
  signed __int64 v22; // r10
  __int64 v23; // rcx
  signed __int64 v24; // r12
  signed __int64 v25; // r14
  signed __int64 v26; // rdx
  signed __int64 v27; // rbp
  signed __int64 v28; // rbx
  signed __int64 v29; // rcx
  signed __int64 v30; // rbp
  signed __int64 v31; // r8
  signed __int64 v32; // rsi
  signed __int64 v33; // rdi
  signed __int64 v34; // rax
  signed __int64 v35; // r8
  signed __int64 v36; // rdx
  __int64 v37; // rbx
  signed __int64 v38; // rsi
  signed __int64 v39; // rdx
  signed __int64 v41; // [rsp+8h] [rbp-340h]
  signed __int64 v42; // [rsp+10h] [rbp-338h]
  signed __int64 v43; // [rsp+18h] [rbp-330h]
  signed __int64 v44; // [rsp+20h] [rbp-328h]
  signed __int64 v45; // [rsp+28h] [rbp-320h]
  signed __int64 *v46; // [rsp+30h] [rbp-318h]
  signed __int64 v47; // [rsp+40h] [rbp-308h]
  signed __int64 v48; // [rsp+48h] [rbp-300h]
  signed __int64 v49; // [rsp+50h] [rbp-2F8h]
  signed __int64 v50; // [rsp+58h] [rbp-2F0h]
  signed __int64 v51; // [rsp+68h] [rbp-2E0h]
  signed __int64 v52; // [rsp+70h] [rbp-2D8h]
  signed __int64 v53; // [rsp+78h] [rbp-2D0h]
  char v54[648]; // [rsp+80h] [rbp-2C8h]
  unsigned __int64 v55; // [rsp+308h] [rbp-40h]

  v46 = a1;
  v55 = __readfsqword(0x28u);
  v2 = 0LL;
  do
  {
    *(_QWORD *)&v54[v2] = _byteswap_uint64(*(_QWORD *)(a2 + v2));
    v2 += 8LL;
  }
  while ( v2 != 128 );
  v3 = v54;
  v4 = v54;
  do
  {
    v5 = *((_QWORD *)v3 + 1);
    v6 = *((_QWORD *)v3 + 14);
    v3 += 8;
    *((_QWORD *)v3 + 15) = *((_QWORD *)v3 - 1)
                         + *((_QWORD *)v3 + 8)
                         + ((v5 >> 7) ^ __ROR8__(v5, 8) ^ __ROR8__(v5, 1))
                         + ((v6 >> 6) ^ __ROR8__(v6, 19) ^ __ROL8__(v6, 3));
  }
  while ( &v54[512] != v3 );
  v7 = 4794697086780616226LL;
  v45 = -1606136188198331460LL;
  v8 = 8158064640168781261LL;
  v44 = 4131703408338449720LL;
  v9 = -5349999486874862801LL;
  v10 = *v46;
  v11 = v46[3];
  v12 = v46[4];
  v13 = v46[5];
  v14 = v46[6];
  v15 = v46[2];
  v43 = 6480981068601479193LL;
  v47 = *v46;
  v42 = -7908458776815382629LL;
  v48 = v46[1];
  v16 = v46[7];
  v53 = v46[7];
  v41 = -6116909921290321640LL;
  v49 = v46[2];
  v17 = &unk_F2240;
  v50 = v46[3];
  v51 = v46[5];
  v52 = v46[6];
  v18 = v46[1];
  while ( 1 )
  {
    v20 = *(_QWORD *)v4
        + (__ROL8__(v12, 23) ^ __ROR8__(v12, 14) ^ __ROR8__(v12, 18))
        + (v14 ^ v12 & (v14 ^ v13))
        + v16
        + v7;
    v21 = v20 + v11;
    v22 = v20 + (__ROL8__(v10, 25) ^ __ROR8__(v10, 28) ^ __ROL8__(v10, 30)) + (v18 & v10 | v15 & (v18 | v10));
    v23 = __ROL8__(
            v20 + (__ROL8__(v10, 25) ^ __ROR8__(v10, 28) ^ __ROL8__(v10, 30)) + (v18 & v10 | v15 & (v18 | v10)),
            30);
    v24 = (v13 ^ v21 & (v12 ^ v13))
        + *((_QWORD *)v4 + 1)
        + v14
        + (__ROL8__(v21, 23) ^ __ROR8__(v21, 14) ^ __ROR8__(v21, 18))
        + v8;
    v25 = v24 + v15;
    v26 = v24 + (__ROL8__(v22, 25) ^ __ROR8__(v22, 28) ^ v23) + (v22 & v10 | v18 & (v22 | v10));
    v27 = (v12 ^ v25 & (v21 ^ v12))
        + *((_QWORD *)v4 + 2)
        + v13
        + (__ROL8__(v25, 23) ^ __ROR8__(v25, 14) ^ __ROR8__(v25, 18))
        + v9;
    v28 = v27 + v18;
    v29 = v27 + (__ROL8__(v26, 25) ^ __ROR8__(v26, 28) ^ __ROL8__(v26, 30)) + (v22 & v26 | v10 & (v22 | v26));
    v30 = v26 & (v27 + (__ROL8__(v26, 25) ^ __ROR8__(v26, 28) ^ __ROL8__(v26, 30)) + (v22 & v26 | v10 & (v22 | v26)));
    v31 = *((_QWORD *)v4 + 3)
        + v12
        + (v21 ^ v28 & (v21 ^ v25))
        + (__ROL8__(v28, 23) ^ __ROR8__(v28, 14) ^ __ROR8__(v28, 18))
        + v45;
    v32 = v31 + v10;
    v33 = v31 + (__ROL8__(v29, 25) ^ __ROR8__(v29, 28) ^ __ROL8__(v29, 30)) + (v30 | v22 & (v26 | v29));
    v34 = *((_QWORD *)v4 + 4)
        + v21
        + (v25 ^ v32 & (v25 ^ v28))
        + (__ROL8__(v32, 23) ^ __ROR8__(v32, 14) ^ __ROR8__(v32, 18));
    v16 = v34 + v44 + v22;
    v11 = v34 + v44 + (__ROL8__(v33, 25) ^ __ROL8__(v33, 30) ^ __ROR8__(v33, 28)) + (v29 & v33 | v26 & (v29 | v33));
    v35 = (__ROL8__(v16, 23) ^ __ROR8__(v16, 18) ^ __ROR8__(v16, 14))
        + (v28 ^ v16 & (v28 ^ v32))
        + *((_QWORD *)v4 + 5)
        + v25
        + v43;
    v14 = v35 + v26;
    v15 = v35 + (__ROL8__(v11, 25) ^ __ROL8__(v11, 30) ^ __ROR8__(v11, 28)) + (v33 & v11 | v29 & (v33 | v11));
    v36 = v42
        + (v32 ^ v14 & (v32 ^ v16))
        + *((_QWORD *)v4 + 6)
        + v28
        + (__ROL8__(v14, 23) ^ __ROR8__(v14, 18) ^ __ROR8__(v14, 14));
    v37 = __ROR8__(
            v35 + (__ROL8__(v11, 25) ^ __ROL8__(v11, 30) ^ __ROR8__(v11, 28)) + (v33 & v11 | v29 & (v33 | v11)),
            28);
    v38 = *((_QWORD *)v4 + 7) + v32;
    v4 += 64;
    v13 = v36 + v29;
    v18 = v36 + (v11 & v15 | v33 & (v11 | v15)) + (__ROL8__(v15, 25) ^ __ROL8__(v15, 30) ^ v37);
    v39 = v41 + (v16 ^ v13 & (v16 ^ v14)) + v38 + (__ROL8__(v13, 23) ^ __ROR8__(v13, 18) ^ __ROR8__(v13, 14));
    v12 = v39 + v33;
    v10 = v39 + (__ROL8__(v18, 30) ^ __ROR8__(v18, 28) ^ __ROL8__(v18, 25)) + (v15 & v18 | v11 & (v15 | v18));
    if ( v17 == (_QWORD *)&unk_F2480 )
      break;
    v19 = v17[7];
    v9 = v17[2];
    v17 += 8;
    v8 = *(v17 - 7);
    v7 = *(v17 - 8);
    v41 = v19;
    v42 = *(v17 - 2);
    v43 = *(v17 - 3);
    v44 = *(v17 - 4);
    v45 = *(v17 - 5);
  }
  v46[4] += v12;
  *v46 = v47 + v10;
  v46[3] = v50 + v11;
  v46[1] = v48 + v18;
  v46[2] = v49 + v15;
  v46[5] = v51 + v13;
  v46[6] = v52 + v14;
  v46[7] = v53 + v16;
  sub_BD070(v54, 0x280uLL);
  return __readfsqword(0x28u) ^ v55;
}

__int64 __fastcall sub_7F760(__int64 a1, char *a2, unsigned __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // r14
  __int64 v5; // r15
  char *v6; // rbp
  size_t v7; // rdi
  __int64 v8; // r12
  char *v9; // rsi
  size_t v10; // rbx
  signed __int64 v11; // rbx
  unsigned __int8 v12; // cf
  signed __int64 v13; // rbx
  signed __int64 *i; // [rsp+8h] [rbp-40h]

  result = a1 - 216;
  v4 = a3;
  v5 = a1;
  v6 = a2;
  for ( i = (signed __int64 *)(a1 - 216); v4; result = sub_7F180(i, v8) )
  {
    v7 = *(_QWORD *)(v5 - 24);
    v8 = (__int64)(i + 8);
    while ( 1 )
    {
      v9 = v6;
      v10 = 128 - v7;
      if ( 128 - v7 > v4 )
        v10 = v4;
      v6 += v10;
      v4 -= v10;
      memcpy((void *)(v8 + v7), v9, v10);
      v7 = v10 + *(_QWORD *)(v5 - 24);
      v11 = 8 * v10;
      v12 = __CFADD__(*(_QWORD *)(v5 - 8), v11);
      v13 = *(_QWORD *)(v5 - 8) + v11;
      *(_QWORD *)(v5 - 24) = v7;
      result = v12;
      *(_QWORD *)(v5 - 16) += v12;
      *(_QWORD *)(v5 - 8) = v13;
      if ( v7 == 128 )
        break;
      if ( !v4 )
        return result;
    }
    *(_QWORD *)(v5 - 24) = 0LL;
  }
  return result;
}

__int64 sub_7F830()
{
  unsigned int v5; // esi
  __int64 result; // rax

  _RAX = 0LL;
  __asm { cpuid }
  v5 = _RAX;
  result = 0LL;
  if ( v5 > 6 )
  {
    _RAX = 7LL;
    __asm { cpuid }
    result = ((unsigned int)_RBX >> 29) & 1;
  }
  return result;
}

__int64 sub_7F880()
{
  char v0; // al
  signed __int64 (__fastcall *v1)(__int64); // rdx
  __int64 (__fastcall **v2)(); // rdi
  __int64 v3; // rax
  __int64 v4; // rbx

  v0 = byte_326470;
  if ( !byte_326471 )
  {
    v0 = sub_7F830();
    byte_326471 = 1;
    byte_326470 = v0;
  }
  v1 = sub_7FF70;
  v2 = off_321540;
  if ( v0 )
  {
    v1 = sub_7FFB0;
    if ( v0 )
      v2 = off_3214E0;
  }
  v3 = v1((__int64)v2);
  v4 = v3;
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  return v4;
}

void __fastcall sub_7F8F0(__int64 a1)
{
  __m128i v1; // xmm0

  v1 = _mm_load_si128((const __m128i *)&xmmword_F2590);
  *(_QWORD *)(a1 - 40) = 0LL;
  *(_QWORD *)(a1 - 32) = 0LL;
  *(__m128i *)(a1 - 136) = v1;
  *(__m128i *)(a1 - 120) = _mm_load_si128((const __m128i *)&xmmword_F25A0);
}

signed __int64 __fastcall sub_7F920(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __m128i v3; // xmm0
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a1 - 24);
  *(__m128i *)(a1 - 136) = _mm_load_si128((const __m128i *)(a2 - 136));
  *(__m128i *)(a1 - 120) = _mm_load_si128((const __m128i *)(a2 - 120));
  *(__m128i *)(a1 - 104) = _mm_load_si128((const __m128i *)(a2 - 104));
  *(__m128i *)(a1 - 88) = _mm_load_si128((const __m128i *)(a2 - 88));
  *(__m128i *)(a1 - 72) = _mm_load_si128((const __m128i *)(a2 - 72));
  *(__m128i *)(a1 - 56) = _mm_load_si128((const __m128i *)(a2 - 56));
  *(__m128i *)(a1 - 40) = _mm_load_si128((const __m128i *)(a2 - 40));
  *(__m128i *)(a1 - 24) = _mm_load_si128((const __m128i *)(a2 - 24));
  *(__m128i *)(a1 - 8) = _mm_load_si128((const __m128i *)(a2 - 8));
  v3 = _mm_load_si128((const __m128i *)(a2 + 8));
  *(_QWORD *)(a1 - 24) = v2;
  result = a1 - 16;
  *(__m128i *)(a1 + 8) = v3;
  *(_QWORD *)(a1 - 8) = a1 - 16;
  *(_QWORD *)(a1 + 8) = a1 - 16;
  return result;
}

unsigned __int64 __fastcall sub_7F9A0(int *a1, __int64 a2)
{
  __int64 v2; // rax
  char *v3; // r9
  char *v4; // rdx
  int v5; // eax
  int v6; // er12
  int v7; // er15
  char *v8; // rbp
  int v9; // edx
  int v10; // ecx
  int v11; // er8
  int v12; // eax
  int v13; // esi
  int v14; // er13
  int v15; // esi
  int v16; // ecx
  int v17; // er13
  int v18; // er8
  int v19; // edx
  int v20; // er13
  int v21; // eax
  int v22; // er13
  int v23; // er8
  char *v24; // rbx
  int v25; // er13
  int v26; // esi
  int v27; // ecx
  int v28; // er13
  int v29; // er8
  int v30; // edx
  int v31; // er13
  int v32; // eax
  int v33; // eax
  int v34; // er13
  int v35; // esi
  int v36; // er13
  int v37; // er8
  char *v38; // rbp
  int v39; // er13
  int v40; // er11
  int v41; // esi
  int v42; // ecx
  int v43; // er13
  int v44; // er11
  int v45; // er8
  int v46; // er11
  int v47; // er13
  int v48; // edx
  int v49; // er11
  int v50; // er11
  int v51; // er13
  int v52; // eax
  int v53; // er11
  int v54; // er13
  int v55; // er11
  int v56; // ebp
  int v57; // esi
  int v58; // ecx
  int v59; // ebp
  int v60; // er8
  int v61; // edx
  int v62; // ebp
  int v63; // eax
  int v64; // eax
  int v65; // ebp
  int v66; // esi
  int v67; // ebp
  int v68; // er8
  int v70; // [rsp+4h] [rbp-194h]
  int v71; // [rsp+8h] [rbp-190h]
  char v72[328]; // [rsp+10h] [rbp-188h]
  unsigned __int64 v73; // [rsp+158h] [rbp-40h]

  v73 = __readfsqword(0x28u);
  v2 = 0LL;
  do
  {
    *(_DWORD *)&v72[4 * v2] = _byteswap_ulong(*(_DWORD *)(a2 + 4 * v2));
    ++v2;
  }
  while ( v2 != 16 );
  v3 = v72;
  v4 = v72;
  do
  {
    v5 = *((_DWORD *)v4 + 8) ^ *((_DWORD *)v4 + 13);
    v4 += 4;
    *((_DWORD *)v4 + 15) = __ROL4__(*((_DWORD *)v4 - 1) ^ *((_DWORD *)v4 + 1) ^ v5, 1);
  }
  while ( &v72[256] != v4 );
  v6 = a1[1];
  v7 = a1[2];
  v8 = v72;
  v9 = a1[3];
  v71 = a1[4];
  v10 = a1[4];
  v11 = *a1;
  v12 = a1[2];
  v13 = a1[1];
  v70 = a1[3];
  do
  {
    v14 = v13 & (v9 ^ v12);
    v15 = __ROR4__(v13, 2);
    v16 = __ROL4__(v11, 5) + *(_DWORD *)v8 + 1518500249 + (v9 ^ v14) + v10;
    v17 = v11 & (v12 ^ v15);
    v18 = __ROR4__(v11, 2);
    v19 = __ROL4__(v16, 5) + (v12 ^ v17) + v9 + *((_DWORD *)v8 + 1) + 1518500249;
    v20 = v16 & (v15 ^ v18);
    v10 = __ROR4__(v16, 2);
    v21 = __ROL4__(v19, 5) + (v15 ^ v20) + v12 + *((_DWORD *)v8 + 2) + 1518500249;
    v22 = v19 & (v18 ^ v10);
    v9 = __ROR4__(v19, 2);
    v13 = __ROL4__(v21, 5) + (v18 ^ v22) + v15 + *((_DWORD *)v8 + 3) + 1518500249;
    v23 = (v10 ^ v21 & (v10 ^ v9)) + v18 + *((_DWORD *)v8 + 4) + 1518500249;
    v8 += 20;
    v12 = __ROR4__(v21, 2);
    v11 = __ROL4__(v13, 5) + v23;
  }
  while ( &v72[80] != v8 );
  v24 = v72;
  do
  {
    v25 = v13;
    v26 = __ROR4__(v13, 2);
    v24 += 20;
    v27 = *((_DWORD *)v24 + 15) + (v9 ^ v12 ^ v25) + __ROL4__(v11, 5) + 1859775393 + v10;
    v28 = v11;
    v29 = __ROR4__(v11, 2);
    v30 = __ROL4__(v27, 5) + *((_DWORD *)v24 + 16) + v9 + (v26 ^ v12 ^ v28) + 1859775393;
    v31 = v12 + *((_DWORD *)v24 + 17) + 1859775393;
    v32 = v27 ^ v26 ^ v29;
    v10 = __ROR4__(v27, 2);
    v33 = __ROL4__(v30, 5) + v31 + v32;
    v34 = v26 + *((_DWORD *)v24 + 18) + 1859775393;
    v35 = v30 ^ v29 ^ v10;
    v9 = __ROR4__(v30, 2);
    v13 = __ROL4__(v33, 5) + v34 + v35;
    v36 = v29 + *((_DWORD *)v24 + 19) + 1859775393;
    v37 = v33 ^ v10 ^ v9;
    v12 = __ROR4__(v33, 2);
    v11 = __ROL4__(v13, 5) + v36 + v37;
  }
  while ( v8 != v24 );
  v38 = v72;
  do
  {
    v39 = v12 & v13;
    v40 = v9 & (v12 | v13);
    v41 = __ROR4__(v13, 2);
    v42 = __ROL4__(v11, 5) + *((_DWORD *)v38 + 40) - 1894007588 + (v39 | v40) + v10;
    v43 = v11 & v41;
    v44 = v11 | v41;
    v45 = __ROR4__(v11, 2);
    v46 = v43 | v12 & v44;
    v47 = v42 & v45;
    v48 = __ROL4__(v42, 5) + v46 + v9 + *((_DWORD *)v38 + 41) - 1894007588;
    v49 = v42 | v45;
    v10 = __ROR4__(v42, 2);
    v50 = v47 | v41 & v49;
    v51 = v48 & v10;
    v52 = __ROL4__(v48, 5) + v50 + v12 + *((_DWORD *)v38 + 42) - 1894007588;
    v53 = v48 | v10;
    v9 = __ROR4__(v48, 2);
    v13 = __ROL4__(v52, 5) + (v51 | v45 & v53) + v41 + *((_DWORD *)v38 + 43) - 1894007588;
    v54 = v52 & v9;
    v38 += 20;
    v55 = v10 & (v52 | v9);
    v12 = __ROR4__(v52, 2);
    v11 = __ROL4__(v13, 5) + (v54 | v55) + v45 + *((_DWORD *)v38 + 39) - 1894007588;
  }
  while ( v24 != v38 );
  do
  {
    v56 = v13;
    v57 = __ROR4__(v13, 2);
    v3 += 20;
    v58 = *((_DWORD *)v3 + 55) + (v9 ^ v12 ^ v56) + __ROL4__(v11, 5) - 899497514 + v10;
    v59 = v11;
    v60 = __ROR4__(v11, 2);
    v61 = __ROL4__(v58, 5) + *((_DWORD *)v3 + 56) + v9 + (v57 ^ v12 ^ v59) - 899497514;
    v62 = v12 + *((_DWORD *)v3 + 57) - 899497514;
    v63 = v58 ^ v57 ^ v60;
    v10 = __ROR4__(v58, 2);
    v64 = __ROL4__(v61, 5) + v62 + v63;
    v65 = v57 + *((_DWORD *)v3 + 58) - 899497514;
    v66 = v61 ^ v60 ^ v10;
    v9 = __ROR4__(v61, 2);
    v13 = __ROL4__(v64, 5) + v65 + v66;
    v67 = v60 + *((_DWORD *)v3 + 59) - 899497514;
    v68 = v64 ^ v10 ^ v9;
    v12 = __ROR4__(v64, 2);
    v11 = __ROL4__(v13, 5) + v67 + v68;
  }
  while ( v24 != v3 );
  *a1 += v11;
  a1[1] = v6 + v13;
  a1[2] = v7 + v12;
  a1[3] = v70 + v9;
  a1[4] = v71 + v10;
  sub_BD070(v72, 0x140uLL);
  return __readfsqword(0x28u) ^ v73;
}

void __fastcall sub_7FDF0(__int64 a1)
{
  sub_BD070((void *)(a1 - 120), 0x88uLL);
  sub_2F4D0((void *)(a1 - 120));
}

void __fastcall sub_7FE10(__int64 a1)
{
  void *v1; // rbx

  v1 = *(void **)(a1 - 24);
  sub_BD070((void *)(a1 - 136), 0xA0uLL);
  sub_2F4D0(v1);
}

signed __int64 __fastcall sub_7FE30(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r15
  signed __int64 result; // rax
  __int64 v5; // r14
  char *v6; // rbp
  size_t v7; // rdi
  __int64 v8; // r12
  const void *v9; // rsi
  size_t v10; // rbx
  __int64 v11; // rdi
  int *i; // [rsp+8h] [rbp-40h]

  v3 = a3;
  result = a1 - 104;
  v5 = a1;
  v6 = a2;
  for ( i = (int *)(a1 - 104); v3; result = sub_7F9A0(i, v8) )
  {
    v7 = *(_QWORD *)(v5 - 16);
    v8 = (__int64)(i + 6);
    while ( 1 )
    {
      v9 = v6;
      v10 = 64 - v7;
      if ( 64 - v7 > v3 )
        v10 = v3;
      v6 += v10;
      v3 -= v10;
      result = (signed __int64)memcpy((void *)(v8 + v7), v9, v10);
      v11 = *(_QWORD *)(v5 - 16);
      *(_QWORD *)(v5 - 8) += v10;
      v7 = v10 + v11;
      *(_QWORD *)(v5 - 16) = v7;
      if ( v7 == 64 )
        break;
      if ( !v3 )
        return result;
    }
    *(_QWORD *)(v5 - 16) = 0LL;
  }
  return result;
}

signed __int64 __fastcall sub_7FEE0(__int64 a1)
{
  signed __int64 result; // rax
  __m128i v2; // xmm0

  result = 3285377520LL;
  *(_QWORD *)(a1 - 32) = 0LL;
  v2 = _mm_load_si128((const __m128i *)&xmmword_F2570);
  *(_QWORD *)(a1 - 24) = 0LL;
  *(__m128i *)(a1 - 120) = v2;
  *(_DWORD *)(a1 - 104) = -1009589776;
  return result;
}

signed __int64 __fastcall sub_7FF10(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __m128i v3; // xmm0

  result = a1 - 16;
  *(__m128i *)(a1 - 120) = _mm_loadu_si128((const __m128i *)(a2 - 120));
  *(__m128i *)(a1 - 104) = _mm_loadu_si128((const __m128i *)(a2 - 104));
  *(__m128i *)(a1 - 88) = _mm_loadu_si128((const __m128i *)(a2 - 88));
  *(__m128i *)(a1 - 72) = _mm_loadu_si128((const __m128i *)(a2 - 72));
  *(__m128i *)(a1 - 56) = _mm_loadu_si128((const __m128i *)(a2 - 56));
  *(__m128i *)(a1 - 40) = _mm_loadu_si128((const __m128i *)(a2 - 40));
  *(__m128i *)(a1 - 24) = _mm_loadu_si128((const __m128i *)(a2 - 24));
  v3 = _mm_loadu_si128((const __m128i *)(a2 - 8));
  *(_QWORD *)(a1 + 8) = a1 - 16;
  *(__m128i *)(a1 - 8) = v3;
  *(_QWORD *)(a1 - 8) = a1 - 16;
  return result;
}

char *__fastcall sub_7FF70(__int64 a1)
{
  _QWORD *v1; // rax
  signed __int64 v2; // rdx
  char *result; // rax

  v1 = sub_2F450(1uLL, 0x88uLL, 0LL);
  v2 = (signed __int64)(v1 + 13);
  v1[15] = a1;
  result = (char *)(v1 + 15);
  *((_QWORD *)result - 2) = sub_7FE30;
  *((_QWORD *)result - 1) = v2;
  *((_QWORD *)result + 1) = v2;
  return result;
}

_QWORD *__fastcall sub_7FFB0(__int64 a1)
{
  char v1; // al
  void *v2; // rax
  _QWORD *v3; // rdx

  v1 = byte_326470;
  if ( !byte_326471 )
  {
    v1 = sub_7F830();
    byte_326471 = 1;
    byte_326470 = v1;
  }
  if ( !v1 )
    return 0LL;
  v2 = sub_2F450(0xAFuLL, 1uLL, 0LL);
  v3 = (_QWORD *)(((unsigned __int64)v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v3[14] = v2;
  v3[17] = a1;
  v3[15] = sub_80100;
  v3[16] = v3 + 15;
  v3[18] = v3 + 15;
  return v3 + 17;
}

__int64 __fastcall sub_80040(__int64 a1, __m128i *a2)
{
  __int64 v2; // r13
  signed __int64 v3; // rbp
  signed __int64 v4; // rbx
  unsigned int v5; // eax
  __int8 v6; // cl
  unsigned int v7; // edx
  __int64 result; // rax

  v2 = 8LL * *(_QWORD *)(a1 - 32);
  v3 = ((55 - *(_DWORD *)(a1 - 40)) & 0x3F) + 1LL;
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  if ( v3 != 1 )
  {
    v4 = 1LL;
    do
    {
      ++v4;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 0);
    }
    while ( v3 != v4 );
  }
  sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v2);
  if ( *(_QWORD *)(a1 - 40) )
    sub_1AEFF();
  *a2 = _mm_shuffle_epi8(_mm_shuffle_epi32(*(__m128i *)(a1 - 136), 27), (__m128i)xmmword_F1F00);
  v5 = *(_DWORD *)(a1 - 108);
  a2[1].m128i_i8[3] = v5;
  v6 = BYTE1(v5);
  v7 = v5 >> 16;
  result = v5 >> 24;
  a2[1].m128i_i8[2] = v6;
  a2[1].m128i_i8[1] = v7;
  a2[1].m128i_i8[0] = result;
  return result;
}

void *__fastcall sub_80100(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  char *v4; // r15
  __int64 v5; // rbp
  __int64 i; // r13
  size_t v7; // rdi
  char *v8; // rsi
  size_t v9; // rbx
  void *result; // rax
  __int64 v11; // rdi
  __m128i v12; // xmm1
  __m128i v13; // xmm3

  v3 = a3;
  v4 = a2;
  v5 = a1;
  for ( i = a1 - 88; v3; *(__m128i *)(v5 - 120) = _mm_add_epi32(v13, _XMM0) )
  {
    v7 = *(_QWORD *)(v5 - 24);
    while ( 1 )
    {
      v8 = v4;
      v9 = 64 - v7;
      if ( 64 - v7 > v3 )
        v9 = v3;
      v4 += v9;
      v3 -= v9;
      result = memcpy((void *)(i + v7), v8, v9);
      v11 = *(_QWORD *)(v5 - 24);
      *(_QWORD *)(v5 - 16) += v9;
      v7 = v9 + v11;
      *(_QWORD *)(v5 - 24) = v7;
      if ( v7 == 64 )
        break;
      if ( !v3 )
        return result;
    }
    v12 = _mm_loadu_si128((const __m128i *)(v5 - 88));
    *(_QWORD *)(v5 - 24) = 0LL;
    v13 = _mm_load_si128((const __m128i *)(v5 - 120));
    _XMM2 = _mm_load_si128((const __m128i *)(v5 - 104));
    _XMM0 = _mm_add_epi32(_XMM2, _mm_shuffle_epi8(v12, (__m128i)xmmword_ED040));
    __asm { sha1rnds4 xmm5, xmm0, 0 }
    _XMM9 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v5 - 56)), (__m128i)xmmword_ED040);
    _XMM0 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v5 - 72)), (__m128i)xmmword_ED040);
    __asm
    {
      sha1nexte xmm5, xmm9
      sha1nexte xmm4, xmm0
      sha1msg1 xmm1, xmm0
    }
    _XMM8 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v5 - 40)), (__m128i)xmmword_ED040);
    __asm
    {
      sha1rnds4 xmm7, xmm4, 0
      sha1msg1 xmm0, xmm9
      sha1nexte xmm7, xmm8
      sha1msg2 xmm1, xmm8
      sha1rnds4 xmm6, xmm5, 0
      sha1msg1 xmm4, xmm8
      sha1nexte xmm6, xmm1
      sha1msg2 xmm0, xmm1
      sha1rnds4 xmm10, xmm7, 0
      sha1msg1 xmm5, xmm1
      sha1msg2 xmm4, xmm0
      sha1rnds4 xmm11, xmm6, 0
      sha1nexte xmm7, xmm0
      sha1msg1 xmm1, xmm0
      sha1rnds4 xmm12, xmm7, 1
      sha1nexte xmm6, xmm4
      sha1msg2 xmm5, xmm4
      sha1rnds4 xmm13, xmm6, 1
      sha1nexte xmm7, xmm5
      sha1msg1 xmm0, xmm4
      sha1msg2 xmm1, xmm5
      sha1rnds4 xmm14, xmm7, 1
      sha1nexte xmm6, xmm1
      sha1msg1 xmm4, xmm5
      sha1msg2 xmm0, xmm1
      sha1rnds4 xmm15, xmm6, 1
      sha1nexte xmm7, xmm0
      sha1msg1 xmm5, xmm1
      sha1msg2 xmm4, xmm0
      sha1rnds4 xmm10, xmm7, 1
      sha1nexte xmm6, xmm4
      sha1msg1 xmm1, xmm0
      sha1msg2 xmm5, xmm4
      sha1rnds4 xmm11, xmm6, 2
      sha1nexte xmm7, xmm5
      sha1msg1 xmm0, xmm4
      sha1msg2 xmm1, xmm5
      sha1rnds4 xmm12, xmm7, 2
      sha1nexte xmm6, xmm1
      sha1msg1 xmm4, xmm5
      sha1msg2 xmm0, xmm1
      sha1rnds4 xmm13, xmm6, 2
      sha1nexte xmm7, xmm0
      sha1msg1 xmm5, xmm1
      sha1msg2 xmm4, xmm0
      sha1rnds4 xmm14, xmm7, 2
      sha1nexte xmm6, xmm4
      sha1msg1 xmm1, xmm0
      sha1msg2 xmm5, xmm4
      sha1rnds4 xmm15, xmm6, 2
      sha1nexte xmm7, xmm5
      sha1msg1 xmm0, xmm4
      sha1msg2 xmm1, xmm5
      sha1rnds4 xmm8, xmm7, 3
      sha1nexte xmm6, xmm1
      sha1msg1 xmm4, xmm5
      sha1msg2 xmm0, xmm1
      sha1rnds4 xmm9, xmm6, 3
      sha1msg1 xmm5, xmm1
      sha1nexte xmm7, xmm0
      sha1msg2 xmm1, xmm0
      sha1rnds4 xmm4, xmm7, 3
      sha1nexte xmm6, xmm1
      sha1msg2 xmm0, xmm1
      sha1rnds4 xmm1, xmm6, 3
      sha1nexte xmm4, xmm0
      sha1nexte xmm1, xmm2
      sha1rnds4 xmm0, xmm4, 3
    }
    *(_OWORD *)(v5 - 104) = _XMM1;
  }
  return result;
}

__int64 __fastcall sub_80440(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  signed __int64 v3; // r13
  signed __int64 v4; // rbp
  __int64 result; // rax
  int v6; // edx

  v2 = 8LL * *(_QWORD *)(a1 - 24);
  v3 = ((55 - *(_DWORD *)(a1 - 32)) & 0x3F) + 1LL;
  sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 128);
  if ( v3 != 1 )
  {
    v4 = 1LL;
    do
    {
      ++v4;
      sub_2ECE0(*(__int64 (__fastcall ***)(_QWORD, char *, signed __int64))(a1 - 8), 0);
    }
    while ( v3 != v4 );
  }
  sub_2EDF0(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 - 8), v2);
  result = *(_QWORD *)(a1 - 32);
  if ( result )
    sub_1AEFF();
  do
  {
    v6 = *(_DWORD *)(a1 + 4 * result - 120);
    *(_BYTE *)(a2 + 4 * result + 3) = v6;
    *(_BYTE *)(a2 + 4 * result + 2) = BYTE1(v6);
    *(_BYTE *)(a2 + 4 * result + 1) = BYTE2(v6);
    *(_BYTE *)(a2 + 4 * result++) = HIBYTE(v6);
  }
  while ( result != 5 );
  return result;
}

void __fastcall sub_804F0(__int64 a1, __int64 a2)
{
  qmemcpy((void *)(a1 - 432), (const void *)(a2 - 432), 0x1B0uLL);
}

void __fastcall sub_80510(__int64 a1)
{
  sub_BD070((void *)(a1 - 432), 0x1D0uLL);
  sub_2F4D0((void *)(a1 - 432));
}

unsigned __int64 __fastcall sub_80530(_QWORD *a1, char *a2, size_t a3)
{
  _QWORD *v3; // r15
  __int64 v4; // rbp
  __int64 v5; // rax
  size_t v6; // rbp
  _QWORD *v7; // r15
  signed __int64 *v8; // r8
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdi
  signed __int64 v11; // rsi
  signed __int64 *v12; // rdx
  __int64 v13; // rcx
  signed __int64 v14; // rcx
  _QWORD *v15; // rdx
  __int64 *v16; // r11
  signed __int64 *v17; // r10
  __int64 *v18; // rsi
  signed __int64 i; // rdi
  __int64 v20; // rax
  signed __int64 *v21; // rdi
  int v22; // er8
  __int64 v23; // rdx
  signed __int64 *j; // rax
  signed __int64 v25; // rcx
  signed __int64 *v26; // rbp
  int *v27; // r12
  int v28; // er13
  int v29; // er9
  int v30; // er8
  __int64 k; // rdi
  unsigned __int64 v32; // rsi
  unsigned int v33; // ecx
  __int64 v34; // rdx
  unsigned int v35; // ecx
  unsigned int v36; // esi
  __int64 v37; // rdx
  signed __int64 v38; // rdi
  signed __int64 *v40; // [rsp+0h] [rbp-148h]
  char *v41; // [rsp+8h] [rbp-140h]
  signed __int64 v42; // [rsp+10h] [rbp-138h]
  signed __int64 *v43; // [rsp+18h] [rbp-130h]
  _QWORD *v44; // [rsp+20h] [rbp-128h]
  _QWORD *dest; // [rsp+28h] [rbp-120h]
  char *src; // [rsp+30h] [rbp-118h]
  size_t n; // [rsp+38h] [rbp-110h]
  __int64 v48[25]; // [rsp+40h] [rbp-108h]
  unsigned __int64 v49; // [rsp+108h] [rbp-40h]

  v3 = a1;
  v4 = a1[52];
  v49 = __readfsqword(0x28u);
  v5 = a1[51];
  src = a2;
  n = a3;
  dest = a1 + 25;
  v6 = v4 - v5;
  if ( a3 < v6 )
  {
    dest = (_QWORD *)((char *)dest + v5);
  }
  else
  {
    v40 = a1;
    v43 = a1 + 5;
    v44 = a1 + 1;
    v7 = a1 + 26;
    do
    {
      memcpy((char *)dest + v5, src, v6);
      v8 = v40;
      n -= v6;
      v9 = 0LL;
      src += v6;
      v10 = v40[52];
      do
      {
        v11 = v9 + 40;
        v12 = v8;
        do
        {
          if ( v10 <= v9 )
            break;
          v13 = dest[v9 / 8];
          v9 += 8LL;
          *v12 ^= v13;
          v12 += 5;
        }
        while ( v9 != v11 );
        ++v8;
      }
      while ( v43 != v8 );
      v42 = 1LL;
      v14 = *v40;
      v41 = (char *)&off_F26A8;
      while ( 1 )
      {
        v15 = v44;
        v16 = v48;
        v17 = v40;
        v18 = v48;
        for ( i = v14; ; i = *(v15 - 1) )
        {
          v20 = v15[1] ^ *v15;
          v15 += 5;
          ++v18;
          *(v18 - 1) = i ^ *(v15 - 2) ^ *(v15 - 3) ^ v20;
          if ( v7 == v15 )
            break;
        }
        v21 = v43;
        v22 = 0;
        while ( 1 )
        {
          v23 = v48[(v22 + 4) % 5u] ^ __ROL8__(v48[(v22 + 1) % 5u], 1);
          *(v21 - 5) = v23 ^ v14;
          for ( j = v21 - 4; v21 != j; *(j - 1) = v23 ^ v25 )
          {
            v25 = *j;
            ++j;
          }
          if ( v22 == 4 )
            break;
          v14 = *v21;
          ++v22;
          v21 += 5;
        }
        v26 = v40;
        v27 = (int *)&unk_F2620;
        v28 = 0;
        LOBYTE(v29) = 0;
        while ( 1 )
        {
          v30 = v28;
          for ( k = 0LL; ; v29 = v27[k] )
          {
            v32 = v26[k];
            v33 = v30;
            v30 += 3;
            v34 = (unsigned int)k++;
            v48[5 * v34 + v33 % 5] = (v32 >> -(char)v29) | (v32 << v29);
            if ( k == 5 )
              break;
          }
          v27 += 5;
          v26 += 5;
          if ( v28 == 8 )
            break;
          v29 = *v27;
          v28 += 2;
        }
        v35 = 0;
        do
        {
          v36 = v35++ + 2;
          v37 = 0LL;
          do
          {
            v17[v37] = v16[v37] ^ v48[5 * (v36 % 5) + v37] & ~v48[5 * (v35 % 5) + v37];
            ++v37;
          }
          while ( v37 != 5 );
          v16 += 5;
          v17 += 5;
        }
        while ( v35 != 5 );
        v14 = *v40 ^ v42;
        *v40 = v14;
        if ( "Connection sharing downstream #%u: %s" == v41 )
          break;
        v38 = *(_QWORD *)v41;
        v41 += 8;
        v42 = v38;
      }
      sub_BD070(v48, 0xC8uLL);
      v6 = v40[52];
      v40[51] = 0LL;
      v5 = 0LL;
    }
    while ( v6 <= n );
    v3 = v40;
  }
  memcpy(dest, src, n);
  v3[51] += n;
  return __readfsqword(0x28u) ^ v49;
}

unsigned __int64 __fastcall sub_808A0(__int64 a1, char *a2, size_t a3)
{
  return sub_80530((_QWORD *)(a1 - 448), a2, a3);
}

unsigned __int64 __fastcall sub_808B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // r12
  size_t v4; // r13
  signed __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 *v7; // rsi
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  _QWORD *v10; // rdx
  unsigned __int64 v12; // r10
  char *v13; // rdx
  char *v14; // r13
  unsigned int v15; // edx
  unsigned int v16; // edx
  unsigned int v17; // er11
  __int64 v18; // r14
  char v19; // [rsp+1h] [rbp-109h]
  __int16 v20; // [rsp+2h] [rbp-108h]
  char v21; // [rsp+4h] [rbp-106h]
  char v22; // [rsp+5h] [rbp-105h]
  char v23; // [rsp+6h] [rbp-104h]
  char v24; // [rsp+7h] [rbp-103h]
  char v25; // [rsp+8h] [rbp-102h]
  char v26; // [rsp+9h] [rbp-101h]
  unsigned __int64 v27; // [rsp+CAh] [rbp-40h]

  v2 = a1;
  v3 = a2;
  v27 = __readfsqword(0x28u);
  v4 = *(_QWORD *)(a1 - 16) - *(_QWORD *)(a1 - 24);
  if ( *(_QWORD *)(a1 - 16) == *(_QWORD *)(a1 - 24) )
    v4 = *(_QWORD *)(a1 - 16);
  __memset_chk(&v20, 0LL, v4, 200LL);
  LOBYTE(v20) = *(_BYTE *)(a1 - 32) | v20;
  *(&v19 + v4) |= 0x80u;
  sub_80530((_QWORD *)(a1 - 432), (char *)&v20, v4);
  v5 = a1 - 232;
  v6 = 0LL;
  do
  {
    v7 = (__int64 *)(v5 - 200);
    do
    {
      v8 = *(_QWORD *)(v2 - 8) - v6;
      if ( *(_QWORD *)(v2 - 8) == v6 )
        break;
      v9 = *v7;
      if ( v8 > 8 )
        v8 = 8LL;
      v20 = *v7;
      v21 = BYTE2(v9);
      v22 = BYTE3(v9);
      v23 = BYTE4(v9);
      v24 = BYTE5(v9);
      v26 = HIBYTE(v9);
      v25 = BYTE6(v9);
      v10 = (_QWORD *)(v3 + v6);
      if ( (unsigned int)v8 >= 8 )
      {
        *v10 = *(_QWORD *)&v20;
        *(_QWORD *)((char *)v10 + (unsigned int)v8 - 8) = *(_QWORD *)((char *)&v20 + (unsigned int)v8 - 8);
        v12 = (unsigned __int64)(v10 + 1) & 0xFFFFFFFFFFFFFFF8LL;
        v13 = (char *)v10 - v12;
        v14 = (char *)((char *)&v20 - v13);
        v15 = (v8 + (_DWORD)v13) & 0xFFFFFFF8;
        if ( v15 >= 8 )
        {
          v16 = v15 & 0xFFFFFFF8;
          v17 = 0;
          do
          {
            v18 = v17;
            v17 += 8;
            *(_QWORD *)(v12 + v18) = *(_QWORD *)&v14[v18];
          }
          while ( v17 < v16 );
        }
      }
      else if ( v8 & 4 )
      {
        *(_DWORD *)v10 = *(_DWORD *)&v20;
        *(_DWORD *)((char *)v10 + (unsigned int)v8 - 4) = *(_DWORD *)((char *)&v20 + (unsigned int)v8 - 4);
      }
      else if ( (_DWORD)v8 )
      {
        *(_BYTE *)v10 = v20;
        if ( v8 & 2 )
          *(_WORD *)((char *)v10 + (unsigned int)v8 - 2) = *(__int16 *)((char *)&v20 + (unsigned int)v8 - 2);
      }
      v7 += 5;
      v6 += v8;
    }
    while ( (__int64 *)v5 != v7 );
    v5 += 8LL;
  }
  while ( v5 != v2 - 192 );
  return __readfsqword(0x28u) ^ v27;
}

signed __int64 __fastcall sub_80AB0(__int64 a1)
{
  _QWORD *v1; // rax
  signed __int64 v2; // rbx

  v1 = sub_2F450(1uLL, 0x1D0uLL, 0LL);
  v2 = (signed __int64)(v1 + 54);
  v1[54] = a1;
  v1[56] = sub_808A0;
  v1[57] = v1 + 56;
  v1[55] = v1 + 56;
  (*(void (__fastcall **)(_QWORD *, signed __int64))(a1 + 8))(v1 + 54, 464LL);
  return v2;
}

void __fastcall sub_80BA0(__int64 a1)
{
  __int64 v1; // rdx

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 40LL);
  JUMPOUT(&loc_80B10);
}

signed __int64 __fastcall sub_80BD0(__int64 *a1)
{
  signed __int64 result; // rax
  __int64 v2; // rax
  signed __int64 v3; // rdi
  unsigned int v4; // esi

  v2 = *a1;
  v3 = (signed __int64)(a1 - 54);
  v4 = 8 * *(unsigned __int64 *)(v2 + 40);
  *(_QWORD *)(v3 + 408) = 0LL;
  *(_BYTE *)(v3 + 400) = 31;
  *(_QWORD *)(v3 + 424) = v4 >> 3;
  *(_QWORD *)(v3 + 416) = 136LL;
  result = v3 + 40;
  do
  {
    *(_QWORD *)v3 = 0LL;
    *(_QWORD *)(v3 + 40) = 0LL;
    v3 += 8LL;
    *(_QWORD *)(v3 + 72) = 0LL;
    *(_QWORD *)(v3 + 112) = 0LL;
    *(_QWORD *)(v3 + 152) = 0LL;
  }
  while ( v3 != result );
  return result;
}

signed __int64 __fastcall sub_80BD0(__int64 *a1)
{
  signed __int64 result; // rax
  __int64 v2; // rax
  signed __int64 v3; // rdi
  unsigned int v4; // esi

  v2 = *a1;
  v3 = (signed __int64)(a1 - 54);
  v4 = 8 * *(unsigned __int64 *)(v2 + 40);
  *(_QWORD *)(v3 + 408) = 0LL;
  *(_BYTE *)(v3 + 400) = 31;
  *(_QWORD *)(v3 + 424) = v4 >> 3;
  *(_QWORD *)(v3 + 416) = 136LL;
  result = v3 + 40;
  do
  {
    *(_QWORD *)v3 = 0LL;
    *(_QWORD *)(v3 + 40) = 0LL;
    v3 += 8LL;
    *(_QWORD *)(v3 + 72) = 0LL;
    *(_QWORD *)(v3 + 112) = 0LL;
    *(_QWORD *)(v3 + 152) = 0LL;
  }
  while ( v3 != result );
  return result;
}

signed __int64 __fastcall sub_80BF0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_80C10(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_80C30(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 4) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 4) > v2;
  return result;
}

signed __int64 __fastcall sub_80C50(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(a1 + 8) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 8) > v2;
  return result;
}

signed __int64 __fastcall sub_80C70(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_80C90(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 4) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 4) > v2;
  return result;
}

void nullsub_31()
{
  ;
}

void __fastcall sub_80CC0(_QWORD *a1, __int64 a2)
{
  sub_9B440((__int64 *)a1[2057], a2);
  sub_9B440((__int64 *)a1[2058], a2);
  if ( *(_QWORD *)(a2 + 24) )
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1[2] + 32LL) + 8LL) + 64LL))();
  sub_2F4D0(*(void **)(a2 + 40));
  sub_2F4D0((void *)a2);
}

unsigned __int64 __usercall sub_80D20@<rax>(unsigned int *a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>, ...)
{
  char *v4; // rbx
  __int64 v5; // rdx
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v8; // [rsp+18h] [rbp-D0h]

  va_start(va, a4);
  v8 = __readfsqword(0x28u);
  v4 = sub_BC310(a2, (const __m128i *)va);
  v5 = *a1;
  sub_2D3F0(**(_QWORD **)(*((_QWORD *)a1 + 2) + 32LL), (__int64)"Connection sharing downstream #%u: %s", a3, a4);
  sub_2F4D0(v4);
  return __readfsqword(0x28u) ^ v8;
}

void __fastcall sub_80E10(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  char *v9; // rax
  char *v10; // rbp
  size_t v11; // rax

  v9 = sub_BC160(
         "SSHCONNECTION@putty.projects.tartarus.org-2.0-",
         a2,
         a3,
         a4,
         a5,
         a6,
         a7,
         a8,
         a9,
         *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40LL),
         "\r\n",
         0LL);
  v10 = v9;
  v11 = strlen(v9);
  (*(void (__fastcall **)(_QWORD, char *, size_t))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), v10, v11);
  sub_2F4D0(v10);
  *(_BYTE *)(a1 + 28) = 1;
}

void __fastcall sub_80E70(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // rbx
  _QWORD *i; // rdi

  v3 = a3;
  sub_9B440((__int64 *)a1, (__int64)a3);
  sub_9B440((__int64 *)*a2, (__int64)v3);
  for ( i = (_QWORD *)v3[2]; i; i = (_QWORD *)v3[2] )
  {
    v3[2] = *i;
    sub_2F4D0(i);
  }
  sub_2F4D0(v3);
}

unsigned __int64 __fastcall sub_80ED0(_QWORD *a1, _BYTE *a2, __int64 a3, int a4, signed int *a5)
{
  signed __int64 v5; // rax
  __int64 (**v6)(void); // r13
  void **v7; // rbx
  _BYTE *v8; // rdx
  int v9; // eax
  int v11; // ebx
  char *v12; // rbp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r14
  unsigned __int64 v15; // rbx
  signed __int64 v16; // rax
  __int64 (__fastcall **v17)(_QWORD, char *, signed __int64); // r15
  void **v18; // r13
  int v19; // ecx
  _BYTE *v20; // rax
  signed int *v21; // [rsp+0h] [rbp-78h]
  int v22; // [rsp+8h] [rbp-70h]
  __int64 v23; // [rsp+10h] [rbp-68h]
  __int64 v24; // [rsp+18h] [rbp-60h]
  __int64 v25; // [rsp+20h] [rbp-58h]
  int v26; // [rsp+28h] [rbp-50h]
  __int64 *v27; // [rsp+30h] [rbp-48h]
  unsigned __int64 v28; // [rsp+38h] [rbp-40h]

  v28 = __readfsqword(0x28u);
  v21 = a5;
  if ( *a1 )
  {
    if ( (_DWORD)a2 == 94 )
    {
      v23 = a3;
      v25 = a4;
      v24 = 0LL;
      v26 = 0;
      v27 = &v23;
      v11 = sub_2F150((__int64)&v23);
      v12 = sub_2F1D0((__int64)v27);
      v14 = v13;
      v22 = v11;
      do
      {
        v15 = *v21;
        if ( v15 > v14 )
          LODWORD(v15) = v14;
        v16 = sub_BC650();
        v17 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v16 + 24);
        v18 = (void **)v16;
        v14 -= (signed int)v15;
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v16 + 24), 0);
        sub_2ECE0(v17, 94);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v17, v22);
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v17, v15);
        sub_2EC20((__int64 (**)(void))v17);
        v12 += (signed int)v15;
        v19 = *((_DWORD *)v18 + 4) - 4;
        v20 = *v18;
        v20[3] = v19;
        v20[2] = BYTE1(v19);
        v20[1] = BYTE2(v19);
        *v20 = HIBYTE(v19);
        (*(void (__fastcall **)(_QWORD, void *, void *))(*(_QWORD *)*a1 + 16LL))(*a1, *v18, v18[2]);
        sub_BC660(v18);
      }
      while ( v14 );
    }
    else
    {
      v5 = sub_BC650();
      v6 = (__int64 (**)(void))(v5 + 24);
      v7 = (void **)v5;
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v5 + 24), 0);
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v6, (char)a2);
      sub_2EC20(v6);
      v8 = *v7;
      v9 = *((_DWORD *)v7 + 4) - 4;
      v8[3] = v9;
      v8[2] = BYTE1(v9);
      v8[1] = BYTE2(v9);
      *v8 = HIBYTE(v9);
      (*(void (__fastcall **)(_QWORD, void *, void *))(*(_QWORD *)*a1 + 16LL))(*a1, *v7, v7[2]);
      sub_BC660(v7);
    }
  }
  return __readfsqword(0x28u) ^ v28;
}

_QWORD *__fastcall sub_81090(_QWORD *a1, _QWORD **a2, int a3, const void *a4, int a5)
{
  int v5; // er14
  size_t v6; // r12
  const void *v7; // r15
  _DWORD *v8; // rax
  _QWORD *v9; // rbx
  _QWORD *result; // rax

  v5 = a3;
  v6 = a5;
  v7 = a4;
  v8 = sub_2F450(1uLL, 0x20uLL, a5);
  v8[6] = v6;
  v8[2] = v5;
  v9 = v8;
  *((_QWORD *)v8 + 2) = v8 + 8;
  memcpy(v8 + 8, v7, v6);
  result = *a2;
  if ( !*a2 )
    result = a1;
  *result = v9;
  *v9 = 0LL;
  *a2 = v9;
  return result;
}

_DWORD *__fastcall sub_81110(_QWORD *a1, _QWORD *a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // er15
  int v8; // er14
  int v9; // er13
  __int64 **v10; // rbp
  int v11; // er12
  _DWORD *v12; // rbx
  __int64 *v13; // rdi
  _DWORD *result; // rax

  v7 = a4;
  v8 = a5;
  v9 = a6;
  v10 = (__int64 **)a1;
  v11 = a3;
  v12 = sub_2F450(1uLL, 0x38uLL, 0LL);
  *v12 = v11;
  v12[1] = v7;
  v12[2] = v8;
  v12[4] = v9;
  v13 = (__int64 *)*a1;
  *((_QWORD *)v12 + 3) = 0LL;
  *((_QWORD *)v12 + 5) = 0LL;
  v12[8] = -1;
  v12[12] = 0;
  v12[3] = a7;
  *((_BYTE *)v12 + 52) = 0;
  if ( v12 != (_DWORD *)sub_9AFD0(v13, (__int64)v12) )
    goto LABEL_6;
  result = v12;
  if ( v12[4] != 3 )
  {
    result = (_DWORD *)sub_9AFD0((__int64 *)*a2, (__int64)v12);
    if ( v12 != result )
    {
      sub_9B440(*v10, (__int64)v12);
LABEL_6:
      sub_2F4D0(v12);
      return 0LL;
    }
  }
  return result;
}

signed int __fastcall sub_811F0(__int64 a1, __int64 a2)
{
  signed int result; // eax
  int v3; // eax

  result = strcmp(*(const char **)a1, *(const char **)a2);
  if ( !result )
  {
    v3 = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a1 + 8) < v3 )
      result = -1;
    else
      result = *(_DWORD *)(a1 + 8) > v3;
  }
  return result;
}

__int64 __fastcall sub_81230(_QWORD *a1, int a2)
{
  __int64 **v2; // r12
  unsigned int v3; // ebp
  __int64 *v4; // rdi
  int v5; // er14
  int v6; // er15
  int v7; // ebx
  _DWORD *v8; // rax
  int v9; // edx
  __int64 *v10; // rdi
  int v12; // [rsp+Ch] [rbp-40CCh]
  int v13; // [rsp+10h] [rbp-40C8h]
  unsigned __int64 v14; // [rsp+4098h] [rbp-40h]

  v2 = (__int64 **)a1;
  v3 = a2;
  v4 = (__int64 *)*a1;
  v13 = a2;
  v14 = __readfsqword(0x28u);
  if ( sub_9B220(v4, (__int64)&v13, 0LL, 4, &v12) )
  {
    v5 = v12;
    v6 = sub_9AFB0(*v2);
    while ( 1 )
    {
      v10 = *v2;
      if ( v6 - v5 <= 1 )
        break;
      v7 = (v5 + v6) / 2;
      v8 = (_DWORD *)sub_9B010(v10, v7);
      v9 = a2 + v7 - v12;
      if ( *v8 == v9 )
        v5 = (v5 + v6) / 2;
      if ( *v8 != v9 )
        v6 = v7;
    }
    v3 = a2 + v5 - v12 + 1;
    v13 = a2 + v5 - v12 + 1;
    if ( sub_9B3D0(v10, (__int64)&v13, 0LL) )
      __assert_fail(
        "NULL == find234(sharestate->connections, &dummy, NULL)",
        "sshshare.c",
        0x173u,
        "share_find_unused_id");
  }
  return v3;
}

signed __int64 __usercall sub_81340@<rax>(__int64 a1@<rdx>, __int64 a2@<rdi>, __int64 (__fastcall *a3)(__int64, __int64)@<rsi>, __int64 a4@<r15>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  __int64 v10; // r13
  __int64 (__fastcall *v11)(__int64, __int64); // r12
  _QWORD *v12; // rax
  __int64 v13; // rbx
  int v14; // esi
  int v15; // eax
  int v16; // eax
  __int64 *v17; // rax
  __int64 v18; // rdx
  double v19; // xmm4_8
  double v20; // xmm5_8
  bool v21; // zf
  _QWORD *v22; // rax
  __int64 v23; // rdi
  void **v24; // rbp
  signed __int64 result; // rax

  v10 = a1;
  v11 = a3;
  v12 = sub_2F450(1uLL, 0x4088uLL, 0LL);
  v13 = (__int64)v12;
  v14 = *(_DWORD *)(a2 - 24);
  v12[2064] = &unk_321820;
  v12[2] = a2 - 48;
  v15 = sub_81230((_QWORD *)(a2 - 32), v14);
  *(_DWORD *)v13 = v15;
  if ( !v15 )
  {
    v15 = sub_81230((_QWORD *)(a2 - 32), 1);
    *(_DWORD *)v13 = v15;
    if ( !v15 )
      goto LABEL_12;
  }
  v16 = v15 + 1;
  if ( !v16 )
    v16 = 1;
  *(_DWORD *)(a2 - 24) = v16;
  v17 = (__int64 *)v11(v10, v13 + 16512);
  v18 = *v17;
  *(_QWORD *)(v13 + 8) = v17;
  if ( !(*(__int64 (__fastcall **)(__int64 *))(v18 + 48))(v17) )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v13 + 8) + 40LL))(*(_QWORD *)(v13 + 8), 0LL);
    sub_9AFD0(*(__int64 **)(*(_QWORD *)(v13 + 16) + 16LL), v13);
    v21 = *(_QWORD *)(a2 - 8) == 0LL;
    *(_BYTE *)(v13 + 28) = 0;
    if ( !v21 )
      sub_80E10(v13, a5, a6, a7, a8, v19, v20, a9, a10);
    *(_BYTE *)(v13 + 29) = 0;
    *(_QWORD *)(v13 + 16440) = 0LL;
    *(_DWORD *)(v13 + 24) = 0;
    *(_QWORD *)(v13 + 16448) = sub_9AF60((__int64)sub_80C10);
    *(_QWORD *)(v13 + 16456) = sub_9AF60((__int64)sub_80C30);
    *(_QWORD *)(v13 + 16464) = sub_9AF60((__int64)sub_80C50);
    *(_QWORD *)(v13 + 16472) = sub_9AF60((__int64)sub_80C70);
    *(_QWORD *)(v13 + 16480) = sub_9AF60((__int64)sub_80C90);
    v22 = sub_9AF60((__int64)sub_811F0);
    v23 = *(_QWORD *)(v13 + 8);
    *(_QWORD *)(v13 + 16488) = v22;
    *(_QWORD *)(v13 + 16504) = 0LL;
    *(_QWORD *)(v13 + 16496) = 0LL;
    v24 = (void **)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v23 + 56LL))(v23, v13);
    sub_80D20((unsigned int *)v13, (__int64)"connected%s%s", v10, a4);
    sub_32240(v24);
    result = 0LL;
  }
  else
  {
LABEL_12:
    sub_2F4D0((void *)v13);
    result = 1LL;
  }
  return result;
}

unsigned __int64 __usercall sub_81520@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>, ...)
{
  char *v3; // rbx
  gcc_va_list va; // [rsp+0h] [rbp-E8h]
  unsigned __int64 v6; // [rsp+18h] [rbp-D0h]

  va_start(va, a3);
  v6 = __readfsqword(0x28u);
  v3 = sub_BC310((__int64)"listening socket: %s", (const __m128i *)va);
  sub_2D3F0(**(_QWORD **)(a1 + 32), (__int64)"Connection sharing: %s", a2, a3);
  sub_2F4D0(v3);
  return __readfsqword(0x28u) ^ v6;
}

__int64 __usercall sub_81610@<rax>(__int64 a1@<rdi>, const char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 result; // rax

  if ( a2 )
  {
    a2 = "listening socket: %s";
    sub_81520(a1 - 48, a3, a4);
  }
  result = (*(__int64 (__fastcall **)(_QWORD, const char *))(**(_QWORD **)(a1 - 40) + 8LL))(*(_QWORD *)(a1 - 40), a2);
  *(_QWORD *)(a1 - 40) = 0LL;
  return result;
}

void __fastcall sub_81650(_QWORD *a1)
{
  _QWORD *v1; // rbp
  void *v2; // rax
  void *v3; // rax
  _QWORD *v4; // rbx
  _QWORD *v5; // rdi
  void *v6; // rax
  _QWORD *i; // rdi
  __int64 v8; // rdi

  v1 = a1;
  while ( 1 )
  {
    v2 = (void *)sub_9B400((__int64 *)a1[2056], 0);
    if ( !v2 )
      break;
    sub_2F4D0(v2);
  }
  sub_9AF90((_QWORD **)a1[2056]);
  sub_9AF90((_QWORD **)a1[2058]);
  while ( 1 )
  {
    v3 = (void *)sub_9B400((__int64 *)a1[2057], 0);
    if ( !v3 )
      break;
    sub_2F4D0(v3);
  }
  sub_9AF90((_QWORD **)a1[2057]);
  while ( 1 )
  {
    v4 = (_QWORD *)sub_9B400((__int64 *)v1[2059], 0);
    if ( !v4 )
      break;
    while ( 1 )
    {
      v5 = (_QWORD *)v4[2];
      if ( !v5 )
        break;
      v4[2] = *v5;
      sub_2F4D0(v5);
    }
    sub_2F4D0(v4);
  }
  sub_9AF90((_QWORD **)v1[2059]);
  sub_9AF90((_QWORD **)v1[2060]);
  while ( 1 )
  {
    v6 = (void *)sub_9B400((__int64 *)v1[2061], 0);
    if ( !v6 )
      break;
    sub_2F4D0(v6);
  }
  sub_9AF90((_QWORD **)v1[2061]);
  for ( i = (_QWORD *)v1[2062]; i; i = (_QWORD *)v1[2062] )
  {
    v1[2062] = *i;
    sub_2F4D0(i);
  }
  v8 = v1[1];
  if ( v8 )
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v8 + 8LL))(v8, 0LL);
  sub_2F4D0(v1);
}

__int64 __usercall sub_81790@<rax>(unsigned int *a1@<rdi>, _QWORD *a2@<r13>)
{
  signed __int64 v2; // rax
  void **v3; // r12
  int *v4; // rbp
  signed int i; // er12
  __int64 v6; // rax
  _DWORD *v7; // rbp
  signed int j; // er12
  __int64 v9; // rax
  __int64 v10; // rbp
  signed __int64 v11; // rax
  void (__fastcall **v12)(_QWORD, char *, signed __int64); // r14
  __int64 result; // rax
  __int64 v14; // rbp
  __int64 v15; // rdi

  while ( 1 )
  {
    v4 = (int *)sub_9B010(*((__int64 **)a1 + 2056), 0);
    if ( !v4 )
      break;
    v2 = sub_BC640();
    a2 = (_QWORD *)(v2 + 24);
    v3 = (void **)v2;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v2 + 24), *v4);
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a2, 2);
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))a2, "PuTTY downstream no longer available");
    sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))a2, (char *)&off_F2E3F);
    (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, void *, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                         + 72LL))(
      *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
      *a1,
      92LL,
      *v3,
      *((unsigned int *)v3 + 4),
      "cleanup after downstream went away");
    sub_BC660(v3);
    sub_9B440(*((__int64 **)a1 + 2056), (__int64)v4);
    sub_2F4D0(v4);
  }
  for ( i = 0; ; ++i )
  {
    v6 = sub_9B010(*((__int64 **)a1 + 2057), i);
    v7 = (_DWORD *)v6;
    if ( !v6 )
      break;
    if ( (*(_DWORD *)(v6 + 16) & 0xFFFFFFFD) != 1 )
    {
      a2 = (_QWORD *)sub_BC640();
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))a2 + 3, v7[2]);
      (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, _QWORD, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                           + 72LL))(
        *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
        *a1,
        97LL,
        *a2,
        *((unsigned int *)a2 + 4),
        "cleanup after downstream went away");
      sub_BC660((void **)a2);
      if ( v7[4] == 2 )
      {
        --i;
        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL) + 88LL))(
          *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
          (unsigned int)v7[1]);
        sub_80CC0(a1, (__int64)v7);
      }
      else
      {
        v7[4] = 1;
      }
    }
  }
  for ( j = 0; ; ++j )
  {
    v9 = sub_9B010(*((__int64 **)a1 + 2061), j);
    v10 = v9;
    if ( !v9 )
      break;
    if ( *(_BYTE *)(v9 + 12) )
    {
      v11 = sub_BC640();
      v12 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v11 + 24);
      a2 = (_QWORD *)v11;
      --j;
      sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v11 + 24), "cancel-tcpip-forward");
      sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v12, 0);
      sub_2EF40(v12, *(char **)v10);
      sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v12, *(_DWORD *)(v10 + 8));
      (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, _QWORD, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                           + 72LL))(
        *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
        *a1,
        80LL,
        *a2,
        *((unsigned int *)a2 + 4),
        "cleanup after downstream went away");
      sub_BC660((void **)a2);
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL) + 8LL))(
        *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
        *(_QWORD *)(v10 + 16));
      sub_9B440(*((__int64 **)a1 + 2061), v10);
      sub_2F4D0((void *)v10);
    }
  }
  result = sub_9AFB0(*((__int64 **)a1 + 2056));
  if ( !(_DWORD)result )
  {
    result = sub_9AFB0(*((__int64 **)a1 + 2057));
    if ( !(_DWORD)result )
    {
      result = sub_9AFB0(*((__int64 **)a1 + 2061));
      if ( !(_DWORD)result )
      {
        v14 = *((_QWORD *)a1 + 2);
        sub_9B440(*(__int64 **)(v14 + 16), (__int64)a1);
        sub_80D20(a1, (__int64)"disconnected", (__int64)a2, (__int64)"cancel-tcpip-forward");
        sub_81650(a1);
        result = sub_9AFB0(*(__int64 **)(v14 + 16));
        if ( !(_DWORD)result )
        {
          v15 = *(_QWORD *)(v14 + 32);
          if ( v15 )
            result = (*(__int64 (**)(void))(*(_QWORD *)(v15 + 8) + 104LL))();
        }
      }
    }
  }
  return result;
}

__int64 __fastcall sub_81A80(__int64 a1, char *a2)
{
  signed __int64 v2; // rax
  void (__fastcall **v3)(_QWORD, char *, signed __int64); // r12
  signed __int64 v4; // rbp

  v2 = sub_BC640();
  v3 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24);
  v4 = v2;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v2 + 24), 2);
  sub_2EF40(v3, a2);
  sub_2EF40(v3, "en");
  sub_80ED0((_QWORD *)(a1 + 8), (_BYTE *)&n + 1, *(_QWORD *)v4, *(_DWORD *)(v4 + 16), (signed int *)&byte_9[3]);
  sub_BC660((void **)v4);
  (*(void (__fastcall **)(_QWORD, signed __int64))(**(_QWORD **)(a1 + 8) + 8LL))(*(_QWORD *)(a1 + 8), 1LL);
  *(_QWORD *)(a1 + 8) = 0LL;
  return sub_81790((unsigned int *)a1, a2);
}

__int64 __usercall sub_81B10@<rax>(int a1@<edx>, __int64 a2@<rdi>, __int64 a3@<rsi>, _QWORD *a4@<r13>, __int64 a5@<r15>)
{
  if ( a3 && (a1 != 32 || *(_BYTE *)(a2 - 16483)) )
    sub_80D20((unsigned int *)(a2 - 16512), (__int64)"Socket error: %s", (__int64)a4, a5);
  (*(void (**)(void))(**(_QWORD **)(a2 - 16504) + 8LL))();
  *(_QWORD *)(a2 - 16504) = 0LL;
  return sub_81790((unsigned int *)(a2 - 16512), a4);
}

void __fastcall sub_81B70(void **a1)
{
  void **v1; // rbx
  _QWORD *v2; // rax
  void *v3; // rdi

  v1 = a1;
  sub_B9C50((char *)*a1);
  while ( 1 )
  {
    v2 = (_QWORD *)sub_9B400((__int64 *)a1[2], 0);
    if ( !v2 )
      break;
    sub_81650(v2);
  }
  sub_9AF90((_QWORD **)a1[2]);
  v3 = a1[1];
  if ( v3 )
  {
    (*(void (__fastcall **)(void *, _QWORD))(*(_QWORD *)v3 + 8LL))(v3, 0LL);
    v1[1] = 0LL;
  }
  sub_2F4D0(v1[5]);
  sub_2F4D0(*v1);
  sub_2F4D0(v1);
}

unsigned __int64 __fastcall sub_81BE0(_QWORD *a1, unsigned int *a2)
{
  signed int *v2; // rbx
  char v3; // r12
  signed int v4; // eax
  __int64 v5; // rdx
  void **v6; // r15
  __int64 v8; // [rsp+0h] [rbp-68h]
  __int64 v9; // [rsp+8h] [rbp-60h]
  __int64 v10; // [rsp+10h] [rbp-58h]
  int v11; // [rsp+18h] [rbp-50h]
  __int64 *v12; // [rsp+20h] [rbp-48h]
  unsigned __int64 v13; // [rsp+28h] [rbp-40h]

  v2 = (signed int *)*((_QWORD *)a2 + 2);
  v13 = __readfsqword(0x28u);
  if ( v2 )
  {
    v3 = 0;
    do
    {
      *((_QWORD *)a2 + 2) = *(_QWORD *)v2;
      v4 = v2[2];
      if ( v4 == 98 )
      {
        if ( v2[6] > 4 )
        {
          v5 = *((_QWORD *)v2 + 2);
          v10 = v2[6];
          v9 = 0LL;
          v11 = 0;
          v12 = &v8;
          v8 = v5;
          sub_2F150((__int64)&v8);
          sub_2F1D0((__int64)v12);
          if ( sub_2F0C0((__int64)v12) )
          {
            v6 = (void **)sub_BC640();
            sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v6 + 3, a2[1]);
            (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, void *, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(a1[2] + 32LL) + 8LL)
                                                                                                 + 72LL))(
              *(_QWORD *)(a1[2] + 32LL),
              *(unsigned int *)a1,
              100LL,
              *v6,
              *((unsigned int *)v6 + 4),
              "downstream refused X channel open");
            sub_BC660(v6);
          }
        }
      }
      else if ( v4 == 97 )
      {
        v3 = 1;
      }
      sub_2F4D0(v2);
      v2 = (signed int *)*((_QWORD *)a2 + 2);
    }
    while ( v2 );
    *((_QWORD *)a2 + 3) = 0LL;
    if ( v3 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1[2] + 32LL) + 8LL) + 88LL))(
        *(_QWORD *)(a1[2] + 32LL),
        *a2);
      sub_80E70(a1[2059], a1 + 2060, a2);
    }
  }
  else
  {
    *((_QWORD *)a2 + 3) = 0LL;
  }
  return __readfsqword(0x28u) ^ v13;
}

void __fastcall sub_81D50(unsigned int *a1, __int64 a2, int *a3, int a4)
{
  unsigned int *v4; // rbx
  signed int *v5; // rbp
  int *v6; // r13
  int v7; // ecx
  _BYTE *v8; // rdx
  int v9; // eax
  signed __int64 v10; // rax
  void (__fastcall **v11)(_QWORD, char *, signed __int64, _QWORD); // rbp
  void **v12; // rbx
  int v13; // [rsp+Ch] [rbp-3Ch]

  v4 = *(unsigned int **)(a2 + 16);
  v13 = a4;
  if ( v4 )
  {
    v5 = a3 + 3;
    v6 = a3;
    do
    {
      v7 = v4[6];
      v8 = (_BYTE *)*((_QWORD *)v4 + 2);
      *(_QWORD *)(a2 + 16) = *(_QWORD *)v4;
      if ( v7 > 3 )
      {
        v9 = *v6;
        v8[3] = *v6;
        v8[2] = BYTE1(v9);
        v8[1] = BYTE2(v9);
        *v8 = HIBYTE(v9);
        v7 = v4[6];
        v8 = (_BYTE *)*((_QWORD *)v4 + 2);
      }
      sub_80ED0((_QWORD *)a1 + 1, (_BYTE *)v4[2], (__int64)v8, v7, v5);
      sub_2F4D0(v4);
      v4 = *(unsigned int **)(a2 + 16);
    }
    while ( v4 );
  }
  v10 = sub_BC640();
  v11 = (void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v10 + 24);
  v12 = (void **)v10;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v10 + 24), *(_DWORD *)(a2 + 4));
  sub_2ED90(v11, v13 - *(_DWORD *)(a2 + 12));
  (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, void *, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                       + 72LL))(
    *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
    *a1,
    93LL,
    *v12,
    *((unsigned int *)v12 + 4),
    "window adjustment after downstream accepted X channel");
  sub_BC660(v12);
}

unsigned __int64 __fastcall sub_81E40(_QWORD *a1, __int64 a2)
{
  void **v2; // rbx

  v2 = (void **)sub_BC640();
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v2 + 3, *(_DWORD *)(a2 + 4));
  (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, void *, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(a1[2] + 32LL) + 8LL)
                                                                                       + 72LL))(
    *(_QWORD *)(a1[2] + 32LL),
    *(unsigned int *)a1,
    97LL,
    *v2,
    *((unsigned int *)v2 + 4),
    "downstream refused X channel open");
  sub_BC660(v2);
  *(_BYTE *)(a2 + 8) = 0;
  return sub_81BE0(a1, (unsigned int *)a2);
}

unsigned __int64 __fastcall sub_81EB0(unsigned int *a1, __int64 a2, __int64 a3, signed int a4)
{
  __int64 v4; // r15
  unsigned int *v5; // rbx
  unsigned int v6; // ebp
  int v7; // er13
  char *v8; // r13
  __int64 v9; // rdx
  size_t v10; // r14
  bool v11; // r12
  char *v12; // rax
  size_t v13; // rdx
  char *v14; // r13
  unsigned int v15; // er14
  size_t v16; // rdx
  char *v17; // r13
  const char *v18; // r9
  _DWORD *v19; // rbp
  char *v20; // rax
  __int64 *v21; // rdi
  _QWORD *v22; // rax
  _QWORD *v23; // rdx
  unsigned int v24; // er13
  int v25; // er14
  __int64 *v26; // rdi
  void *v27; // r12
  int v28; // ecx
  _BYTE *v29; // rdx
  int *v30; // rax
  __int64 v31; // r8
  __int64 v32; // rcx
  signed __int64 v33; // rdx
  __int64 v34; // rdi
  __int64 v35; // rax
  char *v36; // rbp
  unsigned __int64 result; // rax
  unsigned __int64 v38; // rt1
  unsigned int v39; // er12
  __int64 v40; // rdx
  __int64 *v41; // rdi
  __int64 v42; // rax
  __int64 v43; // rbp
  __int64 v44; // r13
  int v45; // er14
  int v46; // er12
  int v47; // eax
  unsigned int v48; // er13
  _BYTE *v49; // rax
  __int64 *v50; // rdi
  char *v51; // rax
  size_t v52; // rdx
  char *v53; // r14
  int v54; // er13
  char *v55; // rax
  char *v56; // r14
  char *v57; // rax
  __int64 *v58; // rdi
  __int64 v59; // r13
  const char *v60; // r9
  _QWORD *v61; // rax
  _QWORD *v62; // rdx
  char *v63; // r13
  size_t v64; // rdx
  size_t v65; // rsi
  size_t v66; // r14
  __int64 *v67; // rdi
  __int64 v68; // rax
  unsigned int v69; // ecx
  __int64 *v70; // rdi
  int *v71; // r13
  signed __int64 v72; // rbp
  __int64 *v73; // rdi
  __int64 v74; // rbp
  bool v75; // r13
  char *v76; // rax
  size_t v77; // rdx
  unsigned int v78; // er14
  char *v79; // r15
  unsigned __int64 v80; // rdx
  __int64 v81; // rax
  signed __int64 v82; // rax
  void (__fastcall **v83)(_QWORD, char *, signed __int64); // r14
  void **v84; // r15
  __int64 *v85; // rdi
  int *v86; // rax
  signed __int64 v87; // r12
  __int64 v88; // [rsp-10h] [rbp-D8h]
  __int64 v89; // [rsp+8h] [rbp-C0h]
  int v90; // [rsp+8h] [rbp-C0h]
  int v91; // [rsp+8h] [rbp-C0h]
  size_t n; // [rsp+10h] [rbp-B8h]
  size_t na; // [rsp+10h] [rbp-B8h]
  size_t nb; // [rsp+10h] [rbp-B8h]
  size_t nc; // [rsp+10h] [rbp-B8h]
  bool nd; // [rsp+10h] [rbp-B8h]
  int *v97; // [rsp+18h] [rbp-B0h]
  unsigned __int64 v98; // [rsp+18h] [rbp-B0h]
  char *v99; // [rsp+20h] [rbp-A8h]
  unsigned int v100; // [rsp+28h] [rbp-A0h]
  __int64 v101; // [rsp+60h] [rbp-68h]
  size_t v102; // [rsp+68h] [rbp-60h]
  __int64 v103; // [rsp+70h] [rbp-58h]
  int v104; // [rsp+78h] [rbp-50h]
  __int64 *v105; // [rsp+80h] [rbp-48h]
  unsigned __int64 v106; // [rsp+88h] [rbp-40h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  v101 = a3;
  v102 = 0LL;
  v106 = __readfsqword(0x28u);
  v104 = 0;
  v103 = a4;
  v105 = &v101;
  if ( (_DWORD)a2 == 90 )
  {
    sub_2F1D0((__int64)&v101);
    v44 = v102;
    v45 = sub_2F150((__int64)v105);
    v46 = (*(__int64 (__fastcall **)(_QWORD, unsigned int *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                            + 80LL))(
            *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
            a1);
    sub_2F150((__int64)v105);
    v47 = sub_2F150((__int64)v105);
    if ( *((_DWORD *)v105 + 6) )
    {
      v36 = sub_BC360((__int64)"Truncated CHANNEL_OPEN packet");
      goto LABEL_27;
    }
    sub_81110((_QWORD *)a1 + 2057, (_QWORD *)a1 + 2058, v45, v46, 0, 3, v47);
    v49 = (_BYTE *)(v4 + v44);
    v49[3] = v46;
    v49[2] = BYTE1(v46);
    v49[1] = BYTE2(v46);
    *v49 = HIBYTE(v46);
    a2 = *a1;
    (*(void (__fastcall **)(_QWORD, __int64, signed __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL)
                                                                                                 + 8LL)
                                                                                     + 72LL))(
      *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
      a2,
      90LL,
      v4,
      v6,
      0LL);
    goto LABEL_29;
  }
  v7 = a2;
  if ( (signed int)a2 > 90 )
  {
    if ( (_DWORD)a2 == 92 )
    {
      v48 = sub_2F150((__int64)&v101);
      if ( *((_DWORD *)v105 + 6) )
      {
        v36 = sub_BC360((__int64)"Truncated CHANNEL_OPEN_FAILURE packet");
        goto LABEL_27;
      }
      v50 = (__int64 *)*((_QWORD *)a1 + 2056);
      LODWORD(v99) = v48;
      v27 = (void *)sub_9B3D0(v50, (__int64)&v99, 0LL);
      if ( !v27 )
      {
        v67 = (__int64 *)*((_QWORD *)v5 + 2060);
        HIDWORD(v99) = v48;
        v68 = sub_9B3D0(v67, (__int64)&v99, 0LL);
        if ( !v68 )
        {
          v36 = sub_BC360((__int64)"CHANNEL_OPEN_FAILURE packet cited unknown channel %u", v48);
          goto LABEL_27;
        }
        a2 = v68;
        sub_81E40(v5, v68);
        goto LABEL_29;
      }
      v31 = v6;
      v32 = v4;
      v33 = 92LL;
      v34 = *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL);
      v35 = *(_QWORD *)(v34 + 8);
    }
    else
    {
      if ( (signed int)a2 >= 92 )
      {
        if ( (signed int)a2 > 100 )
          goto LABEL_26;
        goto LABEL_31;
      }
      if ( a4 <= 15
        || (v24 = sub_2F150((__int64)&v101),
            nb = v102,
            v90 = sub_2F150((__int64)v105),
            sub_2F150((__int64)v105),
            v25 = sub_2F150((__int64)v105),
            *((_DWORD *)v105 + 6)) )
      {
        v36 = sub_BC360((__int64)"Truncated CHANNEL_OPEN_CONFIRMATION packet");
        goto LABEL_27;
      }
      v26 = (__int64 *)*((_QWORD *)a1 + 2056);
      LODWORD(v99) = v24;
      v27 = (void *)sub_9B3D0(v26, (__int64)&v99, 0LL);
      if ( v27 )
      {
        v97 = 0LL;
        v28 = (*(__int64 (__fastcall **)(_QWORD, unsigned int *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL)
                                                                            + 8LL)
                                                                + 80LL))(
                *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
                v5);
      }
      else
      {
        v85 = (__int64 *)*((_QWORD *)v5 + 2060);
        HIDWORD(v99) = v24;
        v86 = (int *)sub_9B3D0(v85, (__int64)&v99, 0LL);
        v97 = v86;
        if ( !v86 )
        {
          v36 = sub_BC360((__int64)"CHANNEL_OPEN_CONFIRMATION packet cited unknown channel %u", v24);
          goto LABEL_27;
        }
        v28 = *v86;
      }
      a2 = (__int64)(v5 + 4116);
      v29 = (_BYTE *)(v4 + nb);
      v29[1] = BYTE2(v28);
      v29[3] = v28;
      v29[2] = BYTE1(v28);
      *v29 = HIBYTE(v28);
      v30 = sub_81110((_QWORD *)v5 + 2057, (_QWORD *)v5 + 2058, v90, v28, v24, 0, v25);
      if ( !v27 )
      {
        if ( v97 )
        {
          v69 = _byteswap_ulong(*(_DWORD *)(v4 + 8));
          if ( v69 <= 0xFF )
          {
            v36 = sub_BC360((__int64)"Initial window size for x11 channel must be at least 256 (got %u)", v69, v88);
            goto LABEL_27;
          }
          sub_81D50(v5, (__int64)v97, v30, v69);
          a2 = (__int64)(v5 + 4120);
          sub_80E70(*((_QWORD *)v5 + 2059), (_QWORD *)v5 + 2060, v97);
        }
        goto LABEL_29;
      }
      v31 = v6;
      v32 = v4;
      v33 = 91LL;
      v34 = *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL);
      v35 = *(_QWORD *)(v34 + 8);
    }
    (*(void (__fastcall **)(__int64, _QWORD, signed __int64, __int64, __int64, _QWORD))(v35 + 72))(
      v34,
      *v5,
      v33,
      v32,
      v31,
      0LL);
    a2 = (__int64)v27;
    sub_9B440(*((__int64 **)v5 + 2056), (__int64)v27);
    sub_2F4D0(v27);
    goto LABEL_29;
  }
  if ( (_DWORD)a2 == 2 )
    goto LABEL_31;
  if ( (signed int)a2 <= 2 )
  {
    if ( (_DWORD)a2 == 1 )
    {
      (*(void (**)(void))(**((_QWORD **)a1 + 1) + 8LL))();
      *((_QWORD *)a1 + 1) = 0LL;
      sub_81790(a1, (_QWORD *)(unsigned int)a2);
      goto LABEL_29;
    }
LABEL_26:
    v36 = sub_BC360((__int64)"Unexpected packet type %d\n", (unsigned int)a2);
    goto LABEL_27;
  }
  if ( (_DWORD)a2 == 4 )
  {
LABEL_31:
    v39 = sub_2F150((__int64)&v101);
    if ( (_DWORD)a2 == 98 )
    {
      v63 = sub_2F1D0((__int64)v105);
      v65 = v64;
      v66 = v64;
      if ( (unsigned __int8)sub_BD100(v63, v64, "auth-agent-req@openssh.com")
        && !(*(unsigned __int8 (__fastcall **)(_QWORD, size_t))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                              + 112LL))(
              *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
              v65) )
      {
        v70 = (__int64 *)*((_QWORD *)a1 + 2058);
        v100 = v39;
        v71 = (int *)sub_9B3D0(v70, (__int64)&v99, 0LL);
        if ( !v71 )
        {
          v36 = sub_BC360((__int64)"Agent forwarding request for unrecognised channel %u", v39);
          goto LABEL_28;
        }
        v72 = sub_BC640();
        sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v72 + 24), *v71);
        a2 = 100LL;
        sub_80ED0(
          (_QWORD *)v5 + 1,
          (_BYTE *)&qword_60 + 4,
          *(_QWORD *)v72,
          *(_DWORD *)(v72 + 16),
          (signed int *)&byte_9[3]);
        sub_BC660((void **)v72);
      }
      else if ( (unsigned __int8)sub_BD100(v63, v66, "x11-req") )
      {
        v73 = (__int64 *)*((_QWORD *)a1 + 2058);
        v100 = v39;
        v74 = sub_9B3D0(v73, (__int64)&v99, 0LL);
        if ( !v74 )
        {
          v36 = sub_BC360((__int64)"X11 forwarding request for unrecognised channel %u", v39);
          goto LABEL_28;
        }
        nd = sub_2F0C0((__int64)v105);
        v75 = sub_2F0C0((__int64)v105);
        v76 = sub_2F1D0((__int64)v105);
        a2 = v77;
        v78 = sub_BF1C0(v76, v77);
        v79 = sub_2F1D0((__int64)v105);
        v98 = v80;
        v91 = sub_2F150((__int64)v105);
        if ( *((_DWORD *)v105 + 6) )
          goto LABEL_89;
        if ( (v78 & 0x80000000) != 0 )
        {
          v87 = sub_BC640();
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v87 + 24), *(_DWORD *)v74);
          a2 = 100LL;
          sub_80ED0(
            (_QWORD *)v5 + 1,
            (_BYTE *)&qword_60 + 4,
            *(_QWORD *)v87,
            *(_DWORD *)(v87 + 16),
            (signed int *)&byte_9[3]);
          sub_BC660((void **)v87);
        }
        else
        {
          *(_DWORD *)(v74 + 32) = v78;
          *(_QWORD *)(v74 + 40) = sub_BF210(v79, v98, (_DWORD *)(v74 + 48));
          v81 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned int *, __int64))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL)
                                                                                               + 8LL)
                                                                                   + 56LL))(
                  *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
                  v78,
                  v5,
                  v74);
          *(_BYTE *)(v74 + 52) = v75;
          *(_QWORD *)(v74 + 24) = v81;
          v82 = sub_BC650();
          v83 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v82 + 24);
          v84 = (void **)v82;
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v82 + 24), v39);
          sub_2EF40(v83, "x11-req");
          sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v83, nd);
          sub_2ED00((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v83, v75);
          sub_2EF40(v83, *(char **)(*(_QWORD *)(v74 + 24) + 24LL));
          sub_2EF40(v83, *(char **)(*(_QWORD *)(v74 + 24) + 32LL));
          sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v83, v91);
          a2 = *v5;
          (*(void (__fastcall **)(_QWORD, __int64, signed __int64, void *, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL)
                                                                                          + 72LL))(
            *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
            a2,
            98LL,
            *v84,
            *((unsigned int *)v84 + 4),
            0LL);
          sub_BC660(v84);
        }
      }
      else
      {
        a2 = *a1;
        (*(void (__fastcall **)(_QWORD, __int64, signed __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                         + 72LL))(
          *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
          a2,
          98LL,
          v4,
          v6,
          0LL);
      }
    }
    else
    {
      v40 = (unsigned int)a2;
      a2 = *a1;
      (*(void (__fastcall **)(_QWORD, __int64, __int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL)
                                                                                            + 8LL)
                                                                                + 72LL))(
        *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
        a2,
        v40,
        v4,
        v6,
        0LL);
      if ( v7 == 97 && (signed int)v6 > 3 )
      {
        v41 = (__int64 *)*((_QWORD *)a1 + 2058);
        a2 = (__int64)&v99;
        v100 = v39;
        v42 = sub_9B3D0(v41, (__int64)&v99, 0LL);
        v43 = v42;
        if ( v42 )
        {
          if ( *(_DWORD *)(v42 + 16) == 2 )
          {
            (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL) + 88LL))(
              *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
              *(unsigned int *)(v42 + 4));
            a2 = v43;
            sub_80CC0(v5, v43);
          }
          else
          {
            *(_DWORD *)(v42 + 16) = 1;
          }
        }
      }
    }
    goto LABEL_29;
  }
  if ( (_DWORD)a2 != 80 )
    goto LABEL_26;
  v8 = sub_2F1D0((__int64)&v101);
  v10 = v9;
  v89 = v102;
  a2 = v9;
  v11 = sub_2F0C0((__int64)v105);
  if ( (unsigned __int8)sub_BD100(v8, a2, "tcpip-forward") )
  {
    v12 = sub_2F1D0((__int64)v105);
    n = v13;
    v14 = v12;
    v15 = sub_2F150((__int64)v105);
    v16 = n;
    if ( !*((_DWORD *)v105 + 6) )
    {
      v17 = sub_BD360(v14, n);
      a2 = (__int64)v17;
      na = (**(__int64 (__fastcall ***)(_QWORD, char *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, unsigned int *))(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL))(
             *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
             v17,
             v15,
             0LL,
             0LL,
             0LL,
             0LL,
             0LL,
             a1);
      if ( na )
      {
        v18 = "upstream added want_reply flag";
        *(_BYTE *)(v4 + v89) = 1;
        if ( v11 )
          v18 = 0LL;
        (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, __int64, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL) + 8LL)
                                                                                              + 72LL))(
          *(_QWORD *)(*((_QWORD *)a1 + 2) + 32LL),
          *a1,
          80LL,
          v4,
          v6,
          v18);
        v19 = sub_2F450(1uLL, 0x18uLL, 0LL);
        v20 = sub_BC120(v17);
        v21 = (__int64 *)*((_QWORD *)a1 + 2061);
        *(_QWORD *)v19 = v20;
        v19[2] = v15;
        *((_BYTE *)v19 + 12) = 0;
        if ( v19 == (_DWORD *)sub_9AFD0(v21, (__int64)v19) )
        {
          (*(void (__fastcall **)(_QWORD, unsigned int *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL)
                                                         + 96LL))(
            *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
            v5);
          a2 = 24LL;
          v22 = sub_2F450(1uLL, 0x18uLL, 0LL);
          v23 = (_QWORD *)*((_QWORD *)v5 + 2063);
          *v22 = 0LL;
          if ( v23 )
            *v23 = v22;
          else
            *((_QWORD *)v5 + 2062) = v22;
          v22[2] = v19;
          *((_BYTE *)v22 + 12) = v11;
          *((_DWORD *)v22 + 2) = 0;
          *((_QWORD *)v19 + 2) = na;
        }
        else
        {
          sub_2F4D0(v19);
          a2 = (__int64)v5;
          (*(void (__fastcall **)(_QWORD, unsigned int *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL)
                                                         + 96LL))(
            *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
            v5);
        }
      }
      else if ( v11 )
      {
        a2 = 82LL;
        sub_80ED0((_QWORD *)a1 + 1, (_BYTE *)off_50 + 2, (__int64)&locale, 0, (signed int *)&byte_9[3]);
      }
      sub_2F4D0(v17);
      goto LABEL_29;
    }
LABEL_51:
    v36 = sub_BC360((__int64)"Truncated GLOBAL_REQUEST packet", a2, v16);
    goto LABEL_27;
  }
  a2 = v10;
  if ( (unsigned __int8)sub_BD100(v8, v10, "cancel-tcpip-forward") )
  {
    v51 = sub_2F1D0((__int64)v105);
    nc = v52;
    v53 = v51;
    v54 = sub_2F150((__int64)v105);
    v16 = nc;
    if ( *((_DWORD *)v105 + 6) )
      goto LABEL_51;
    v55 = sub_BD360(v53, nc);
    v56 = v55;
    v57 = sub_BC120(v55);
    v58 = (__int64 *)*((_QWORD *)a1 + 2061);
    a2 = (__int64)&v99;
    v100 = v54;
    v99 = v57;
    v59 = sub_9B3D0(v58, (__int64)&v99, 0LL);
    sub_2F4D0(v99);
    if ( v59 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL) + 8LL))(
        *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
        *(_QWORD *)(v59 + 16));
      v60 = "upstream added want_reply flag";
      *(_BYTE *)(v4 + v89) = 1;
      if ( v11 )
        v60 = 0LL;
      (*(void (__fastcall **)(_QWORD, _QWORD, signed __int64, __int64, _QWORD, const char *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL)
                                                                                            + 72LL))(
        *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
        *v5,
        80LL,
        v4,
        v6,
        v60);
      (*(void (__fastcall **)(_QWORD, unsigned int *))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL) + 96LL))(
        *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
        v5);
      a2 = 24LL;
      v61 = sub_2F450(1uLL, 0x18uLL, 0LL);
      v62 = (_QWORD *)*((_QWORD *)v5 + 2063);
      *v61 = 0LL;
      if ( v62 )
        *v62 = v61;
      else
        *((_QWORD *)v5 + 2062) = v61;
      v61[2] = v59;
      *((_BYTE *)v61 + 12) = v11;
      *((_DWORD *)v61 + 2) = 1;
    }
    else if ( v11 )
    {
      a2 = 82LL;
      sub_80ED0((_QWORD *)v5 + 1, (_BYTE *)off_50 + 2, (__int64)&locale, 0, (signed int *)&byte_9[3]);
    }
    sub_2F4D0(v56);
  }
  else if ( v11 )
  {
    a2 = 82LL;
    sub_80ED0((_QWORD *)a1 + 1, (_BYTE *)off_50 + 2, (__int64)&locale, 0, (signed int *)&byte_9[3]);
  }
LABEL_29:
  while ( 1 )
  {
    v38 = __readfsqword(0x28u);
    result = v38 ^ v106;
    if ( v38 == v106 )
      break;
LABEL_89:
    v36 = sub_BC360((__int64)"Truncated CHANNEL_REQUEST(\"x11-req\") packet", a2);
LABEL_27:
    if ( !v36 )
      __assert_fail("err != NULL", "sshshare.c", 0x6C8u, "share_got_pkt_from_downstream");
LABEL_28:
    a2 = (__int64)v36;
    sub_81A80((__int64)v5, v36);
    sub_2F4D0(v36);
  }
  return result;
}

void __fastcall sub_82AF0(__int64 a1, __int64 a2, char *i, signed __int64 a4)
{
  unsigned int *v4; // r15
  signed __int64 v5; // r14
  __int64 v6; // rbx
  signed int v7; // eax
  char v8; // cl
  char *v9; // r13
  __int64 v10; // rdx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  signed __int64 v13; // r12
  unsigned __int64 v14; // rbp
  __int64 v15; // rdx
  char v16; // cl
  int v17; // edx
  __int64 v18; // rsi
  __int64 v19; // rdx
  char *v20; // rax
  const char *v21; // rdi
  char *v22; // rbp
  char v23; // al
  unsigned __int64 v24; // rdx
  signed __int64 v25; // rdx

  v4 = (unsigned int *)(a1 - 16512);
  v5 = a4;
  v6 = a1;
  v7 = *(_DWORD *)(a1 - 16488);
  if ( v7 == 1771 )
    goto LABEL_27;
  if ( v7 <= 1771 )
  {
    if ( v7 )
      goto LABEL_23;
    *(_QWORD *)(a1 - 72) = 0LL;
LABEL_27:
    if ( !a4 )
    {
LABEL_34:
      *(_DWORD *)(a1 - 16488) = 1771;
      return;
    }
    v23 = *i;
    v9 = i + 1;
    v13 = a4 - 1;
    v24 = *(_QWORD *)(a1 - 72);
    if ( v23 == 10 )
    {
      v14 = *(_QWORD *)(a1 - 72);
LABEL_10:
      if ( v14 > 0x2D && !memcmp(v4 + 9, "SSHCONNECTION@putty.projects.tartarus.org-2.0-", 0x2EuLL) )
      {
        if ( *(_BYTE *)(a1 + v14 - 16477) == 13 )
          *(_QWORD *)(a1 - 72) = v14-- - 1;
        sub_BC2F0(v14);
        sub_80D20(v4, (__int64)"Downstream version string: %.*s", (__int64)v9, (__int64)v4);
        *(_BYTE *)(a1 - 16483) = 1;
LABEL_15:
        *(_QWORD *)(a1 - 72) = 0LL;
        v5 = v13;
        for ( i = v9; ; i = v9 )
        {
LABEL_16:
          if ( !v5 )
          {
            *(_DWORD *)(a1 - 16488) = 1808;
            return;
          }
          v9 = i + 1;
          v15 = *(_QWORD *)(a1 - 72);
          v16 = *(v9 - 1);
          --v5;
          v11 = v15 + 1;
          *(_QWORD *)(a1 - 72) = v15 + 1;
          *(_BYTE *)(a1 + v15 - 16476) = v16;
          if ( (unsigned __int64)(v15 + 1) > 3 )
            break;
        }
        v17 = (*(unsigned __int8 *)(a1 - 16476) << 24) | *(unsigned __int8 *)(a1 - 16473) | (*(unsigned __int8 *)(a1 - 16475) << 16) | (*(unsigned __int8 *)(a1 - 16474) << 8);
        v18 = (unsigned int)(v17 + 4);
        v19 = (unsigned int)(v17 - 1);
        v12 = (signed int)v18;
        *(_DWORD *)(a1 - 16480) = v18;
        if ( (unsigned int)v19 <= 0x400B )
          goto LABEL_7;
        v20 = sub_BC360((__int64)"Bad packet length %u\n", v18, v19, (signed int)v18);
        goto LABEL_22;
      }
      v21 = "Version string did not have expected prefix\n";
    }
    else
    {
      if ( v24 <= 0x400F )
      {
        v14 = v24 + 1;
        v25 = v24 + a4 - 16401;
        do
        {
          *(_QWORD *)(a1 - 72) = v14;
          *(_BYTE *)(a1 + v14 - 16477) = v23;
          if ( !v13 )
            goto LABEL_34;
          v23 = *(++v9 - 1);
          --v13;
          if ( v23 == 10 )
            goto LABEL_10;
          ++v14;
        }
        while ( v25 != v13 );
      }
      v21 = "Version string far too long\n";
    }
    v20 = sub_BC360((__int64)v21);
LABEL_22:
    v22 = v20;
    sub_81A80((__int64)v4, v20);
    sub_2F4D0(v22);
LABEL_23:
    *(_DWORD *)(v6 - 16488) = 0;
    return;
  }
  if ( v7 == 1808 )
    goto LABEL_16;
  if ( v7 != 1821 )
    goto LABEL_23;
  while ( v5 )
  {
    v8 = *i;
    v9 = i + 1;
    v10 = *(_QWORD *)(a1 - 72);
    --v5;
    v11 = v10 + 1;
    *(_QWORD *)(a1 - 72) = v10 + 1;
    *(_BYTE *)(a1 + v10 - 16476) = v8;
    v12 = *(signed int *)(a1 - 16480);
LABEL_7:
    i = v9;
    if ( v12 <= v11 )
    {
      v13 = v5;
      sub_81EB0(v4, *(unsigned __int8 *)(a1 - 16472), a1 - 16471, v11 - 5);
      goto LABEL_15;
    }
  }
  *(_DWORD *)(a1 - 16488) = 1821;
}

// write access to const memory has been detected, the output may be wrong!
unsigned __int64 __fastcall sub_82DC0(_QWORD *a1, __int64 a2, int a3, int a4, int a5, int a6, int a7, char *a8, int a9, unsigned int a10, unsigned int a11, __int64 a12, int a13, int a14)
{
  int v14; // ebp
  _QWORD *v15; // r12
  _BYTE *v16; // rbx
  __int64 *v17; // rdi
  _BYTE *v18; // ST28_8
  signed __int64 v19; // rax
  __int64 (**v20)(void); // rbp
  signed __int64 v21; // r15
  signed __int64 v22; // rax
  void (__fastcall **v23)(_QWORD, char *, signed __int64); // rbp
  signed __int64 v24; // r15
  void *v25; // rdi
  _BYTE *v27; // rbp
  signed __int64 v28; // rax
  __int64 (**v29)(void); // rbx
  signed __int64 v30; // r12
  int v31; // [rsp+1Ch] [rbp-5Ch]
  int v32; // [rsp+28h] [rbp-50h]
  int v33; // [rsp+2Ch] [rbp-4Ch]
  int v34; // [rsp+34h] [rbp-44h]
  unsigned __int64 v35; // [rsp+38h] [rbp-40h]

  v14 = a3;
  v15 = a1;
  v31 = a4;
  v32 = a5;
  v33 = a6;
  v35 = __readfsqword(0x28u);
  v16 = sub_2F450(1uLL, 0x20uLL, 0LL);
  *(_DWORD *)v16 = v14;
  v17 = (__int64 *)a1[2059];
  v16[8] = 1;
  *((_QWORD *)v16 + 3) = 0LL;
  *((_QWORD *)v16 + 2) = 0LL;
  *((_DWORD *)v16 + 1) = v31;
  if ( v16 != (_BYTE *)sub_9AFD0(v17, (__int64)v16) )
  {
LABEL_7:
    sub_2F4D0(v16);
    v27 = sub_BF300(
            a10,
            a11,
            a12,
            *(_DWORD *)(a2 + 32),
            *(__int64 **)(a2 + 40),
            *(_DWORD *)(a2 + 48),
            (__int64)a8,
            a9,
            &v34);
    v28 = sub_BC650();
    v29 = (__int64 (**)(void))(v28 + 24);
    v30 = v28;
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v28 + 24), 0);
    sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v29, v34 + a14);
    sub_2EC20(v29);
    sub_2EC20(v29);
    sub_2F4D0(v27);
    sub_81090(&word_10, (_QWORD **)&off_18, 94, *(const void **)v30, *(_DWORD *)(v30 + 16));
    sub_BC660((void **)v30);
    *(_DWORD *)&byte_9[3] = 0;
    BUG();
  }
  if ( v16 != (_BYTE *)sub_9AFD0((__int64 *)v15[2060], (__int64)v16) )
  {
    sub_9B440((__int64 *)v15[2059], (__int64)v16);
    goto LABEL_7;
  }
  v18 = sub_BF300(
          a10,
          a11,
          a12,
          *(_DWORD *)(a2 + 32),
          *(__int64 **)(a2 + 40),
          *(_DWORD *)(a2 + 48),
          (__int64)a8,
          a9,
          &v34);
  v19 = sub_BC650();
  v20 = (__int64 (**)(void))(v19 + 24);
  v21 = v19;
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))(v19 + 24), 0);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v20, v34 + a14);
  sub_2EC20(v20);
  sub_2EC20(v20);
  sub_2F4D0(v18);
  sub_81090((_QWORD *)v16 + 2, (_QWORD **)v16 + 3, 94, *(const void **)v21, *(_DWORD *)(v21 + 16));
  sub_BC660((void **)v21);
  *((_DWORD *)v16 + 3) = v34 + a7;
  v22 = sub_BC640();
  v23 = (void (__fastcall **)(_QWORD, char *, signed __int64))(v22 + 24);
  v24 = v22;
  sub_2EF40((void (__fastcall **)(_QWORD, char *, signed __int64))(v22 + 24), "x11");
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v23, v31);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v23, v32);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v23, v33);
  sub_2EF40(v23, a8);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v23, a9);
  sub_80ED0(v15 + 1, (_BYTE *)&qword_58 + 2, *(_QWORD *)v24, *(_DWORD *)(v24 + 16), (signed int *)&byte_9[3]);
  sub_BC660((void **)v24);
  if ( *(_BYTE *)(a2 + 52) )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v15[2] + 32LL) + 8LL) + 64LL))(
      *(_QWORD *)(v15[2] + 32LL),
      *(_QWORD *)(a2 + 24));
    v25 = *(void **)(a2 + 40);
    *(_QWORD *)(a2 + 24) = 0LL;
    sub_2F4D0(v25);
    *(_DWORD *)(a2 + 32) = -1;
    *(_DWORD *)(a2 + 48) = 0;
    *(_BYTE *)(a2 + 52) = 0;
  }
  return __readfsqword(0x28u) ^ v35;
}

unsigned __int64 __fastcall sub_83120(unsigned int *a1, unsigned int a2, __int64 a3, int a4)
{
  unsigned __int64 v4; // r14
  unsigned int *v5; // rbx
  _DWORD *v6; // r12
  int v7; // ebp
  int v8; // eax
  __int64 *v9; // rdi
  int v10; // er15
  _BYTE *v11; // r15
  int v12; // eax
  int v13; // er14
  _DWORD *v14; // rax
  __int64 *v15; // rdi
  void *v16; // r13
  unsigned __int64 result; // rax
  unsigned __int64 v18; // rt1
  _DWORD *v19; // r14
  int v20; // eax
  _BYTE *v21; // r15
  bool v22; // zf
  unsigned int v23; // eax
  __int64 *v24; // rdi
  __int64 *v25; // rdi
  __int64 v26; // rax
  __int64 v27; // r14
  int *v28; // [rsp+0h] [rbp-B8h]
  int v29; // [rsp+10h] [rbp-A8h]
  int v30; // [rsp+14h] [rbp-A4h]
  __int64 v31; // [rsp+50h] [rbp-68h]
  __int64 v32; // [rsp+58h] [rbp-60h]
  __int64 v33; // [rsp+60h] [rbp-58h]
  int v34; // [rsp+68h] [rbp-50h]
  __int64 *v35; // [rsp+70h] [rbp-48h]
  unsigned __int64 v36; // [rsp+78h] [rbp-40h]

  v4 = a4;
  v5 = a1;
  v36 = __readfsqword(0x28u);
  v31 = a3;
  v33 = a4;
  v32 = 0LL;
  v34 = 0;
  v35 = &v31;
  v6 = (_DWORD *)a3;
  v7 = a4;
  switch ( a2 )
  {
    case 0x51u:
    case 0x52u:
      v19 = (_DWORD *)*((_QWORD *)a1 + 2062);
      if ( !v19 )
        goto LABEL_39;
      v20 = v19[2];
      if ( v20 )
      {
        if ( v20 != 1 || a2 != 81 )
        {
LABEL_16:
          if ( !*((_BYTE *)v19 + 12) )
            goto LABEL_17;
          goto LABEL_23;
        }
        v21 = (_BYTE *)*((_QWORD *)v19 + 2);
LABEL_33:
        sub_9B440(*((__int64 **)a1 + 2061), (__int64)v21);
        sub_2F4D0(v21);
        goto LABEL_16;
      }
      v21 = (_BYTE *)*((_QWORD *)v19 + 2);
      if ( a2 == 82 )
        goto LABEL_33;
      v22 = *((_BYTE *)v19 + 12) == 0;
      v21[12] = 1;
      if ( v22 )
        goto LABEL_17;
LABEL_23:
      sub_80ED0((_QWORD *)a1 + 1, (_BYTE *)a2, (__int64)v6, v7, (signed int *)&byte_9[3]);
LABEL_17:
      *((_QWORD *)a1 + 2062) = *(_QWORD *)v19;
      sub_2F4D0(v19);
      if ( !*((_QWORD *)a1 + 2062) )
        *((_QWORD *)a1 + 2063) = 0LL;
      if ( !*((_QWORD *)a1 + 1) )
LABEL_20:
        sub_81790(v5, (_QWORD *)a2);
LABEL_10:
      v18 = __readfsqword(0x28u);
      result = v18 ^ v36;
      if ( v18 != v36 )
LABEL_39:
        __assert_fail("globreq", "sshshare.c", 0x49Fu, "share_got_pkt_from_server");
      return result;
    case 0x5Au:
      sub_2F1D0((__int64)&v31);
      v13 = sub_2F150((__int64)v35);
      if ( *((_DWORD *)v35 + 6) )
        __assert_fail("!get_err(src)", "sshshare.c", 0x4BEu, "share_got_pkt_from_server");
      v14 = sub_2F450(1uLL, 4uLL, 0LL);
      v15 = (__int64 *)*((_QWORD *)a1 + 2056);
      v16 = v14;
      *v14 = v13;
      if ( v14 != (_DWORD *)sub_9AFD0(v15, (__int64)v14) )
        sub_2F4D0(v16);
      sub_80ED0((_QWORD *)v5 + 1, (_BYTE *)&qword_58 + 2, (__int64)v6, v7, (signed int *)&byte_9[3]);
      goto LABEL_10;
    case 0x5Bu:
    case 0x5Cu:
    case 0x5Du:
    case 0x5Eu:
    case 0x5Fu:
    case 0x60u:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
      v8 = sub_2F150((__int64)&v31);
      v9 = (__int64 *)*((_QWORD *)a1 + 2057);
      v10 = v8;
      v30 = v8;
      v28 = (int *)sub_9B3D0(v9, (__int64)&v29, 0LL);
      if ( !v28 )
      {
        v25 = (__int64 *)*((_QWORD *)v5 + 2059);
        v29 = v10;
        v26 = sub_9B3D0(v25, (__int64)&v29, 0LL);
        v27 = v26;
        if ( v26 )
        {
          sub_81090((_QWORD *)(v26 + 16), (_QWORD **)(v26 + 24), a2, v6, v7);
          if ( !*(_BYTE *)(v27 + 8) )
            sub_81BE0(v5, (unsigned int *)v27);
        }
        goto LABEL_10;
      }
      v11 = sub_2F450(v4, 1uLL, 0LL);
      memcpy(v11, v6, v4);
      v12 = *v28;
      v11[3] = *v28;
      v11[2] = BYTE1(v12);
      v11[1] = BYTE2(v12);
      *v11 = HIBYTE(v12);
      sub_80ED0((_QWORD *)v5 + 1, (_BYTE *)a2, (__int64)v11, v4, v28 + 3);
      sub_2F4D0(v11);
      switch ( a2 )
      {
        case 0x5Bu:
          if ( v28[4] != 3 )
            goto LABEL_10;
          if ( (signed int)v4 <= 7 )
            goto LABEL_10;
          v23 = v6[1];
          v24 = (__int64 *)*((_QWORD *)v5 + 2058);
          v28[4] = 0;
          v28[2] = _byteswap_ulong(v23);
          sub_9AFD0(v24, (__int64)v28);
          if ( *((_QWORD *)v5 + 1) )
            goto LABEL_10;
          break;
        case 0x5Cu:
          (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL) + 88LL))(
            *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
            (unsigned int)v28[1]);
          sub_80CC0(v5, (__int64)v28);
          goto LABEL_10;
        case 0x61u:
          if ( v28[4] != 1 )
          {
            v28[4] = 2;
            goto LABEL_10;
          }
          (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL) + 8LL) + 88LL))(
            *(_QWORD *)(*((_QWORD *)v5 + 2) + 32LL),
            (unsigned int)v28[1]);
          sub_80CC0(v5, (__int64)v28);
          if ( *((_QWORD *)v5 + 1) )
            goto LABEL_10;
          break;
        default:
          goto LABEL_10;
      }
      goto LABEL_20;
    default:
      __assert_fail(
        "false && \"This packet type should never have come from ssh.c\"",
        "sshshare.c",
        0x50Fu,
        "share_got_pkt_from_server");
      return result;
  }
}

__int64 __fastcall sub_83550(__int64 a1)
{
  return sub_9AFB0(*(__int64 **)(a1 + 16));
}

__int64 __fastcall sub_83560(__int64 a1, const char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbp
  size_t v11; // rax
  const char *v12; // rbx
  size_t v13; // rax
  char *v14; // rdi
  signed int v15; // ebx
  __int64 result; // rax
  double v17; // xmm4_8
  double v18; // xmm5_8

  v10 = a1;
  v11 = strcspn(a2, "-");
  v12 = &a2[v11 + 1 - (a2[v11] < 1u)];
  v13 = strcspn(v12, "-");
  v14 = (char *)&v12[v13 + 1 - (v12[v13] < 1u)];
  v15 = 0;
  *(_QWORD *)(v10 + 40) = sub_BC120(v14);
  while ( 1 )
  {
    result = sub_9B010(*(__int64 **)(v10 + 16), v15);
    if ( !result )
      break;
    if ( *(_BYTE *)(result + 28) )
      __assert_fail("!cs->sent_verstring", "sshshare.c", 0x76Bu, "share_activate");
    ++v15;
    sub_80E10(result, a3, a4, a5, a6, v17, v18, a9, a10);
  }
  return result;
}

char *__fastcall sub_83600(__int64 a1, int a2, __int64 *a3)
{
  __int64 *v3; // rbx
  char *v4; // rbp
  char *result; // rax
  char *v6; // rax
  char *v7; // rbx
  char *v8; // rbp
  char *v9; // rbp
  char *v10; // rbp

  v3 = a3;
  if ( (unsigned int)sub_1EFD0(a3, 2) == 4 )
  {
    if ( a2 != 22 )
    {
LABEL_3:
      v4 = sub_BC360((__int64)"%s:%d", a1, (unsigned int)a2);
      sub_2F4D0(0LL);
      return v4;
    }
    goto LABEL_7;
  }
  v6 = sub_3D010(v3);
  v7 = v6;
  if ( a2 == 22 )
  {
    if ( !v6 )
    {
LABEL_7:
      v9 = sub_BC360((__int64)"%s", a1);
      sub_2F4D0(0LL);
      return v9;
    }
    v10 = sub_BC360((__int64)"%s@%s", v6, a1);
    sub_2F4D0(v7);
    result = v10;
  }
  else
  {
    if ( !v6 )
      goto LABEL_3;
    v8 = sub_BC360((__int64)"%s@%s:%d", v6, a1, (unsigned int)a2);
    sub_2F4D0(v7);
    result = v8;
  }
  return result;
}

signed __int64 __fastcall sub_836F0(__int64 a1, int a2, __int64 *a3)
{
  __int64 *v3; // rbp
  char *v4; // rbx
  __int64 *v5; // rsi
  int v6; // ebp
  signed __int64 result; // rax
  void *v8; // [rsp+8h] [rbp-40h]
  __int128 v9; // [rsp+10h] [rbp-38h]
  __int64 v10; // [rsp+20h] [rbp-28h]
  unsigned __int64 v11; // [rsp+28h] [rbp-20h]

  v3 = a3;
  v11 = __readfsqword(0x28u);
  v10 = 0LL;
  v4 = sub_83600(a1, a2, a3);
  v9 = 0uLL;
  v8 = 0LL;
  v5 = v3;
  v6 = sub_B98C0(
         v4,
         v3,
         (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))&off_326010,
         0LL,
         &v10,
         (__int64 *)&v8,
         (void **)&v9,
         (void **)&v9 + 1,
         0,
         1);
  sub_2F4D0(v8);
  sub_2F4D0((void *)v9);
  sub_2F4D0(*((void **)&v9 + 1));
  sub_2F4D0(v4);
  if ( v6 )
  {
    if ( v6 != 1 )
      __assert_fail("result == SHARE_DOWNSTREAM", "sshshare.c", 0x7F8u, "ssh_share_test_for_upstream");
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 8LL))(v10, v5);
    result = 1LL;
  }
  else
  {
    if ( v10 )
      __assert_fail("sock == NULL", "sshshare.c", 0x7F5u, "ssh_share_test_for_upstream");
    result = 0LL;
  }
  return result;
}

void __fastcall sub_83810(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 32) = a2;
}

__int64 __fastcall sub_83820(__int64 a1, int a2, __int64 *a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  _QWORD *v6; // r15
  __int64 *v7; // rbx
  __int64 v8; // r14
  void (__fastcall ***v9)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD); // r13
  __int64 v10; // rbx
  __int64 result; // rax
  char v12; // al
  char *v13; // rbp
  char **v14; // rax
  char **v15; // r12
  int v16; // eax
  __int64 v17; // rax
  char *v18; // rax
  char v19; // [rsp+8h] [rbp-70h]
  int v20; // [rsp+Ch] [rbp-6Ch]
  void *v21; // [rsp+18h] [rbp-60h]
  void *v22; // [rsp+20h] [rbp-58h]
  void *v23; // [rsp+28h] [rbp-50h]
  __int64 v24; // [rsp+30h] [rbp-48h]
  unsigned __int64 v25; // [rsp+38h] [rbp-40h]

  v6 = a6;
  v7 = a3;
  v8 = a4;
  v9 = (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))a5;
  v25 = __readfsqword(0x28u);
  if ( !(unsigned __int8)sub_1EF00(a3, 189) )
    goto LABEL_4;
  v12 = sub_1EF00(v7, 190);
  if ( !v12 )
  {
    if ( (unsigned __int8)sub_1EF00(v7, 191) )
    {
      LOBYTE(v20) = 1;
      v19 = 0;
      goto LABEL_9;
    }
LABEL_4:
    v10 = 0LL;
    goto LABEL_5;
  }
  v19 = 1;
  v20 = (unsigned __int8)sub_1EF00(v7, 191);
LABEL_9:
  v13 = sub_83600(a1, a2, v7);
  v14 = (char **)sub_2F450(1uLL, 0x38uLL, 0LL);
  v15 = v14;
  v24 = 0LL;
  v23 = 0LL;
  v22 = 0LL;
  v14[6] = (char *)&unk_3217E0;
  v21 = 0LL;
  v14[1] = 0LL;
  v14[4] = 0LL;
  v16 = sub_B98C0(v13, v7, v9, (__int64)(v14 + 6), &v24, (__int64 *)&v21, &v22, &v23, v19, v20);
  if ( v16 == 1 )
  {
    sub_2D3F0(v8, (__int64)"Using existing shared connection at %s", (__int64)v9, (__int64)v6);
    *v6 = 0LL;
    sub_2F4D0(v15);
    sub_2F4D0(v13);
    v10 = v24;
  }
  else if ( v16 == 2 )
  {
    v10 = 0LL;
    sub_2D3F0(v8, (__int64)"Sharing this connection at %s", (__int64)v9, (__int64)v6);
    v17 = v24;
    *v6 = v15;
    v15[1] = (char *)v17;
    v18 = (char *)sub_9AF60((__int64)sub_80BF0);
    v15[5] = 0LL;
    v15[2] = v18;
    *v15 = v13;
    *((_DWORD *)v15 + 6) = 1;
  }
  else
  {
    v10 = 0LL;
    if ( !v16 )
    {
      if ( v21 )
      {
        sub_2D3F0(v8, (__int64)"Could not set up connection sharing: %s", (__int64)v9, (__int64)v6);
      }
      else
      {
        if ( v22 )
          sub_2D3F0(v8, (__int64)"Could not set up connection sharing as downstream: %s", (__int64)v9, (__int64)v6);
        if ( v23 )
          sub_2D3F0(v8, (__int64)"Could not set up connection sharing as upstream: %s", (__int64)v9, (__int64)v6);
      }
      v10 = v24;
      if ( v24 )
LABEL_24:
        __assert_fail("sock == NULL", "sshshare.c", 0x857u, "ssh_connection_sharing_init");
      *v6 = 0LL;
      sub_2F4D0(v15);
      sub_2F4D0(v13);
    }
  }
  sub_2F4D0(v21);
  sub_2F4D0(v22);
  sub_2F4D0(v23);
LABEL_5:
  result = v10;
  if ( __readfsqword(0x28u) != v25 )
    goto LABEL_24;
  return result;
}

void __noreturn sub_83B40()
{
  __assert_fail(
    "false && \"this channel type should never receive OPEN_CONFIRMATION\"",
    aSsh_2,
    0x14u,
    "chan_remotely_opened_confirmation");
}

void __noreturn sub_83B70()
{
  __assert_fail(
    "false && \"this channel type should never receive OPEN_FAILURE\"",
    aSsh_2,
    0x19u,
    "chan_remotely_opened_failure");
}

__int64 __fastcall sub_83BA0(__int64 a1, int a2, unsigned int a3)
{
  return a2 & a3;
}

__int64 sub_83BB0()
{
  return 0LL;
}

__int64 sub_83BC0()
{
  return 0LL;
}

__int64 sub_83BD0()
{
  return 0LL;
}

__int64 sub_83BE0()
{
  return 0LL;
}

__int64 sub_83BF0()
{
  return 0LL;
}

__int64 sub_83C00()
{
  return 0LL;
}

__int64 sub_83C10()
{
  return 0LL;
}

__int64 sub_83C20()
{
  return 0LL;
}

__int64 sub_83C30()
{
  return 0LL;
}

__int64 sub_83C40()
{
  return 0LL;
}

__int64 sub_83C50()
{
  return 0LL;
}

__int64 sub_83C60()
{
  return 0LL;
}

__int64 sub_83C70()
{
  return 0LL;
}

void __noreturn sub_83C80()
{
  __assert_fail(
    "false && \"this channel type should never send a want-reply request\"",
    aSsh_2,
    0x71u,
    "chan_no_request_response");
}

void __fastcall sub_83CB0(void **a1)
{
  if ( a1 )
  {
    sub_2F4D0(a1[4]);
    sub_2F4D0(a1[1]);
    sub_2F4D0(a1[2]);
    sub_2F4D0(a1);
  }
}

void nullsub_32()
{
  ;
}

void __noreturn sub_83D00()
{
  __assert_fail(
    "false && \"Should never try to send packets during SSH version \" \"string exchange\"",
    "sshverstring.c",
    0x194u,
    "ssh_verstring_new_pktout");
}

signed __int64 __fastcall sub_83D30(const char *a1, const char *a2)
{
  unsigned __int64 v2; // r12
  unsigned __int64 v3; // rax
  bool v4; // cf
  signed __int64 result; // rax
  char *v6; // rdi
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // rdx
  char *endptr; // [rsp+8h] [rbp-40h]
  char *nptr; // [rsp+10h] [rbp-38h]
  unsigned __int64 v11; // [rsp+18h] [rbp-30h]

  v11 = __readfsqword(0x28u);
  v2 = strtoul(a1, &endptr, 10);
  v3 = strtoul(a2, &nptr, 10);
  v4 = v2 < v3;
  if ( v2 != v3 )
    goto LABEL_14;
  v6 = endptr;
  if ( *endptr == 46 )
    v6 = endptr++ + 1;
  if ( *nptr == 46 )
    ++nptr;
  v7 = strtoul(v6, &endptr, 10);
  v8 = strtoul(nptr, &nptr, 10);
  result = 0LL;
  v4 = v7 < v8;
  if ( v7 != v8 )
  {
LABEL_14:
    if ( v4 )
      result = 0xFFFFFFFFLL;
    else
      result = 1LL;
  }
  return result;
}

void __usercall sub_83E10(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbx
  char *v4; // rax
  const char *v5; // rdi
  char *v6; // rbp
  char *v7; // rax
  char v8; // dl
  size_t v9; // rax
  char *v10; // rax

  v3 = a1;
  v4 = sub_BC360(
         (__int64)"%.*s%s-%s%s",
         *(unsigned int *)(a1 + 24),
         *(_QWORD *)(a1 + 16),
         *(_QWORD *)(a1 + 32),
         *(_QWORD *)(a1 + 128),
         "-Release-0.76");
  v5 = *(const char **)(a1 + 32);
  *(_QWORD *)(v3 + 160) = v4;
  v6 = v4;
  v7 = &v4[(signed int)(*(_DWORD *)(v3 + 24) + strlen(v5) + 1)];
  v8 = *v7;
  if ( *v7 )
  {
    do
    {
      while ( v8 != 45 && v8 != 32 )
      {
        v8 = *++v7;
        if ( !*v7 )
          goto LABEL_7;
      }
      *v7++ = 95;
      v8 = *v7;
    }
    while ( *v7 );
LABEL_7:
    v6 = *(char **)(v3 + 160);
  }
  v9 = strlen(v6);
  sub_BCD20(*(_QWORD *)(v3 + 192), v6, v9);
  if ( (signed int)sub_83D30(*(const char **)(v3 + 32), "1.99") >= 0 )
    sub_BCD20(*(_QWORD *)(v3 + 192), "\r", 1uLL);
  sub_BCD20(*(_QWORD *)(v3 + 192), "\n", 1uLL);
  v10 = sub_BC360((__int64)"We claim version: %s", *(_QWORD *)(v3 + 160));
  sub_2D3A0(*(_QWORD *)(v3 + 328), v10, a2, a3);
}

unsigned __int64 __usercall sub_83F30@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // rbp
  __int64 v4; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  _BYTE *v7; // rax
  _BYTE *v8; // r12
  size_t v9; // rdx
  char *v10; // rax
  int v11; // eax
  __int64 v12; // rdi
  const void *v13; // rax
  size_t v14; // rdx
  unsigned __int64 v15; // r12
  char *v16; // rax
  __int64 *v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rsi
  __int64 v22; // rax
  char v23; // al
  char *v24; // rax
  const char *v25; // r12
  unsigned int v26; // eax
  const char *v27; // rdx
  __int64 v28; // r13
  char *v29; // r12
  char *v30; // rax
  __int64 *v31; // rdi
  const char *v32; // rsi
  unsigned int v33; // eax
  bool v34; // cf
  bool v35; // zf
  char *v36; // rsi
  unsigned int v37; // eax
  bool v38; // cf
  bool v39; // zf
  char *v40; // rsi
  unsigned int v41; // eax
  bool v42; // cf
  bool v43; // zf
  signed __int64 v44; // rsi
  char *v45; // rax
  signed __int64 v46; // rsi
  char *v47; // rax
  signed __int64 v48; // rsi
  signed __int64 v49; // rsi
  char *v50; // rax
  signed __int64 v51; // rsi
  signed __int64 v52; // rsi
  signed __int64 v53; // rsi
  char *v54; // rax
  signed __int64 v55; // rsi
  signed __int64 v56; // rsi
  char *v57; // rax
  const char *v58; // rdi
  signed __int64 v59; // rcx
  char v60; // al
  bool v61; // cf
  bool v62; // zf
  const char *v63; // rdi
  signed __int64 v64; // rcx
  char v65; // al
  bool v66; // cf
  bool v67; // zf
  const char *v68; // rdi
  signed __int64 v69; // rcx
  char *v70; // rax
  const char *v71; // rdi
  signed __int64 v72; // rcx
  char v73; // al
  bool v74; // cf
  bool v75; // zf
  const char *v76; // rdi
  signed __int64 v77; // rcx
  char *v78; // rax
  char *v79; // rax
  char *v80; // rax
  char *v81; // rax
  const char *v82; // rdi
  signed __int64 v83; // rcx
  char *v84; // rax
  char *v85; // rax
  char *v86; // rax
  char *v87; // rax

  v3 = a1 - 176;
  v4 = a1;
  result = *(unsigned int *)(a1 - 176);
  if ( (_DWORD)result == 242 )
    goto LABEL_13;
  if ( (signed int)result <= 242 )
  {
    if ( !(_DWORD)result )
    {
      if ( *(_BYTE *)(a1 - 128) )
        sub_83E10(a1 - 176, a2, a3);
      *(_DWORD *)(a1 - 8) = 0;
      goto LABEL_12;
    }
    goto LABEL_22;
  }
  if ( (_DWORD)result == 259 )
  {
    while ( 1 )
    {
      result = sub_BCD00(*(_QWORD *)(a1 + 8));
      if ( !result )
        goto LABEL_6;
      v7 = (_BYTE *)sub_BCF00(*(_QWORD *)(a1 + 8));
      v8 = v7;
      a2 = v9;
      v10 = (char *)memchr(v7, 10, v9);
      if ( v10 )
      {
        sub_BCE20(*(_QWORD *)(a1 + 8), v10 - v8 + 1);
        sub_41EF0(*(_QWORD **)(a1 + 160));
LABEL_12:
        *(_DWORD *)(a1 - 176) = 242;
LABEL_13:
        result = sub_BCD00(*(_QWORD *)(a1 + 8));
        v6 = *(_QWORD *)(a1 - 152);
        if ( result < v6 )
          goto LABEL_6;
        sub_BCF10(*(_QWORD *)(a1 + 8), (char *)(v3 + 60), v6);
        a2 = *(_QWORD *)(a1 - 152);
        if ( !memcmp((const void *)(v3 + 60), *(const void **)(a1 - 160), *(_QWORD *)(a1 - 152)) )
        {
          sub_BCE20(*(_QWORD *)(a1 + 8), a2);
          sub_41EF0(*(_QWORD **)(a1 + 160));
          v19 = *(_QWORD *)(a1 - 40);
          v20 = *(_QWORD *)(a1 - 152);
          v21 = *(_QWORD *)(a1 - 160);
          *(_BYTE *)(a1 - 127) = 1;
          sub_2EC20((__int64 (**)(void))(v19 + 24));
          *(_DWORD *)(a1 - 8) = 0;
          goto LABEL_27;
        }
      }
      else
      {
        sub_BCE20(*(_QWORD *)(a1 + 8), a2);
        sub_41EF0(*(_QWORD **)(a1 + 160));
      }
      *(_DWORD *)(a1 - 176) = 259;
    }
  }
  if ( (_DWORD)result != 287 )
  {
LABEL_22:
    *(_DWORD *)(v4 - 176) = 0;
    return result;
  }
  while ( 1 )
  {
    result = sub_BCD00(*(_QWORD *)(v4 + 8));
    if ( !result )
      break;
    v13 = (const void *)sub_BCF00(*(_QWORD *)(v4 + 8));
    a2 = (__int64)v13;
    v15 = v14;
    v16 = (char *)memchr(v13, 10, v14);
    if ( v16 )
      v15 = (unsigned __int64)&v16[-a2 + 1];
    sub_2EC30((__int64 (**)(void))(*(_QWORD *)(v4 - 40) + 24LL));
    sub_BCE20(*(_QWORD *)(v4 + 8), v15);
    sub_41EF0(*(_QWORD **)(v4 + 160));
    v17 = *(__int64 **)(v4 - 40);
    v18 = v17[2];
    if ( *(_BYTE *)(*v17 + v18 - 1) == 10 )
    {
      if ( v18 )
      {
        do
        {
          sub_BC5D0(v17, 1uLL);
          v17 = *(__int64 **)(v4 - 40);
          v22 = v17[2];
          if ( !v22 )
            break;
          v23 = *(_BYTE *)(*v17 + v22 - 1);
        }
        while ( v23 == 13 || v23 == 10 );
      }
      v24 = sub_BC360((__int64)"Remote version: %s");
      sub_2D3A0(*(_QWORD *)(v4 + 152), v24, a2, a3);
      v25 = (const char *)(**(_QWORD **)(v4 - 40) + *(_QWORD *)(v4 - 152));
      v26 = strcspn(v25, "-");
      v27 = v25;
      v28 = (signed int)v26;
      v29 = (char *)&v25[v26];
      v30 = sub_BC360((__int64)"%.*s", v26, v27);
      *(_QWORD *)(v4 - 24) = v29;
      *(_QWORD *)(v4 - 32) = v30;
      if ( *v29 )
      {
        if ( *v29 != 45 )
          __assert_fail("*s->softwareversion == '-'", "sshverstring.c", 0x142u, "ssh_verstring_handle_input");
        *(_QWORD *)(v4 - 24) = ++v29;
      }
      v31 = *(__int64 **)(v4 - 168);
      *(_DWORD *)(v4 - 120) = 0;
      v32 = (_BYTE *)(&qword_A8 + 7);
      if ( !(unsigned int)sub_1EFD0(v31, 175) )
        goto LABEL_149;
      v33 = sub_1EFD0(*(__int64 **)(v4 - 168), 175);
      v34 = v33 < 2;
      v35 = v33 == 2;
      if ( v33 == 2 )
      {
        v58 = "1.2.18";
        v59 = 7LL;
        v32 = v29;
        do
        {
          if ( !v59 )
            break;
          v34 = (const unsigned __int8)*v32 < *v58;
          v35 = *v32++ == *v58++;
          --v59;
        }
        while ( v35 );
        v60 = (!v34 && !v35) - v34;
        v61 = 0;
        v62 = v60 == 0;
        if ( !v60 )
          goto LABEL_149;
        v63 = "1.2.19";
        v64 = 7LL;
        v32 = v29;
        do
        {
          if ( !v64 )
            break;
          v61 = (const unsigned __int8)*v32 < *v63;
          v62 = *v32++ == *v63++;
          --v64;
        }
        while ( v62 );
        v65 = (!v61 && !v62) - v61;
        v66 = 0;
        v67 = v65 == 0;
        if ( !v65 )
          goto LABEL_149;
        v68 = "1.2.20";
        v69 = 7LL;
        v32 = v29;
        do
        {
          if ( !v69 )
            break;
          v66 = (const unsigned __int8)*v32 < *v68;
          v67 = *v32++ == *v68++;
          --v69;
        }
        while ( v67 );
        if ( (!v66 && !v67) == v66
          || (v32 = "1.2.21", !strcmp(v29, "1.2.21"))
          || (v32 = "1.2.22", !strcmp(v29, "1.2.22"))
          || (v32 = "Cisco-1.25", !strcmp(v29, "Cisco-1.25"))
          || (v32 = "OSU_1.4alpha3", !strcmp(v29, "OSU_1.4alpha3"))
          || (v32 = "OSU_1.5alpha4", !strcmp(v29, "OSU_1.5alpha4")) )
        {
LABEL_149:
          *(_DWORD *)(v4 - 120) |= 1u;
          v70 = sub_BC360((__int64)"We believe remote version has SSH-1 ignore bug", v32);
          sub_2D3A0(*(_QWORD *)(v4 + 152), v70, v28, a3);
        }
      }
      v36 = (char *)&dword_B0;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 176) )
        goto LABEL_150;
      v37 = sub_1EFD0(*(__int64 **)(v4 - 168), 176);
      v38 = v37 < 2;
      v39 = v37 == 2;
      if ( v37 == 2 )
      {
        v71 = "Cisco-1.25";
        v72 = 11LL;
        v36 = v29;
        do
        {
          if ( !v72 )
            break;
          v38 = (unsigned __int8)*v36 < *v71;
          v39 = *v36++ == *v71++;
          --v72;
        }
        while ( v39 );
        v73 = (!v38 && !v39) - v38;
        v74 = 0;
        v75 = v73 == 0;
        if ( !v73 )
          goto LABEL_150;
        v76 = "OSU_1.4alpha3";
        v77 = 14LL;
        v36 = v29;
        do
        {
          if ( !v77 )
            break;
          v74 = (unsigned __int8)*v36 < *v76;
          v75 = *v36++ == *v76++;
          --v77;
        }
        while ( v75 );
        if ( (!v74 && !v75) == v74 )
        {
LABEL_150:
          *(_DWORD *)(v4 - 120) |= 4u;
          v78 = sub_BC360((__int64)"We believe remote version needs a plain SSH-1 password", v36);
          sub_2D3A0(*(_QWORD *)(v4 + 152), v78, v28, a3);
        }
      }
      v40 = (_BYTE *)(&dword_B0 + 1);
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 177) )
        goto LABEL_151;
      v41 = sub_1EFD0(*(__int64 **)(v4 - 168), 177);
      v42 = v41 < 2;
      v43 = v41 == 2;
      if ( v41 == 2 )
      {
        v82 = "Cisco-1.25";
        v83 = 11LL;
        v40 = v29;
        do
        {
          if ( !v83 )
            break;
          v42 = (unsigned __int8)*v40 < *v82;
          v43 = *v40++ == *v82++;
          --v83;
        }
        while ( v43 );
        if ( (!v42 && !v43) == v42 )
        {
LABEL_151:
          *(_DWORD *)(v4 - 120) |= 8u;
          v84 = sub_BC360((__int64)"We believe remote version can't handle SSH-1 RSA authentication", v40);
          sub_2D3A0(*(_QWORD *)(v4 + 152), v84, v28, a3);
        }
      }
      v44 = 178LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 178)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 178) == 2
        && !(unsigned int)sub_BDDB0("* VShell", v29)
        && ((v44 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.1.0*", v29))
         || (v44 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.0.*", v29))
         || (v44 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.2.0*", v29))
         || (v44 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.3.0*", v29))
         || (v44 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.1 *", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 2u;
        v45 = sub_BC360((__int64)"We believe remote version has SSH-2 HMAC bug", v44);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v45, v28, a3);
      }
      v46 = 179LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 179)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 179) == 2
        && !(unsigned int)sub_BDDB0("* VShell", v29)
        && ((v46 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.0.0*", v29))
         || (v46 = (signed __int64)v29, (unsigned int)sub_BDDB0("2.0.10*", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 0x20u;
        v47 = sub_BC360((__int64)"We believe remote version has SSH-2 key-derivation bug", v46);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v47, v28, a3);
      }
      v48 = 180LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 180)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 180) == 2
        && ((v48 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_2.[5-9]*", v29))
         || (v48 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_3.[0-2]*", v29))
         || (v48 = (signed __int64)v29, (unsigned int)sub_BDDB0("mod_sftp/0.[0-8]*", v29))
         || (v48 = (signed __int64)v29, (unsigned int)sub_BDDB0("mod_sftp/0.9.[0-8]", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 0x10u;
        v81 = sub_BC360((__int64)"We believe remote version has SSH-2 RSA padding bug", v48);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v81, v28, a3);
      }
      v49 = 181LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 181)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 181) == 2
        && (v49 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_2.[0-2]*", v29)) )
      {
        *(_DWORD *)(v4 - 120) |= 0x80u;
        v50 = sub_BC360((__int64)"We believe remote version has SSH-2 public-key-session-ID bug", v49);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v50, v28, a3);
      }
      v51 = 182LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 182)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 182) == 2
        && ((v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("DigiSSH_2.0", v29))
         || (v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_2.[0-4]*", v29))
         || (v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_2.5.[0-3]*", v29))
         || (v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("Sun_SSH_1.0", v29))
         || (v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("Sun_SSH_1.0.1", v29))
         || (v51 = (signed __int64)v29, (unsigned int)sub_BDDB0("WeOnlyDo-*", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 0x40u;
        v80 = sub_BC360((__int64)"We believe remote version has SSH-2 rekey bug", v51);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v80, v28, a3);
      }
      v52 = 183LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 183)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 183) == 2
        && ((v52 = (signed __int64)v29, (unsigned int)sub_BDDB0("1.36_sshlib GlobalSCAPE", v29))
         || (v52 = (signed __int64)v29, (unsigned int)sub_BDDB0("1.36 sshlib: GlobalScape", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 0x100u;
        v85 = sub_BC360((__int64)"We believe remote version ignores SSH-2 maximum packet size", v52);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v85, v28, a3);
      }
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 184) )
      {
        *(_DWORD *)(v4 - 120) |= 0x200u;
        v87 = sub_BC360((__int64)"We believe remote version has SSH-2 ignore bug", 184LL);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v87, v28, a3);
      }
      v53 = 185LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 185)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 185) == 2
        && (v53 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_2.[235]*", v29)) )
      {
        *(_DWORD *)(v4 - 120) |= 0x1000u;
        v54 = sub_BC360((__int64)"We believe remote version has outdated SSH-2 GEX", v53);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v54, v28, a3);
      }
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 186) )
      {
        *(_DWORD *)(v4 - 120) |= 0x400u;
        v86 = sub_BC360((__int64)"We believe remote version has winadj bug", 186LL);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v86, v28, a3);
      }
      v55 = 187LL;
      if ( !(unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 187)
        || (unsigned int)sub_1EFD0(*(__int64 **)(v4 - 168), 187) == 2
        && ((v55 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_[2-5].*", v29))
         || (v55 = (signed __int64)v29, (unsigned int)sub_BDDB0("OpenSSH_6.[0-6]*", v29))
         || (v55 = (signed __int64)v29, (unsigned int)sub_BDDB0("dropbear_0.[2-4][0-9]*", v29))
         || (v55 = (signed __int64)v29, (unsigned int)sub_BDDB0("dropbear_0.5[01]*", v29))) )
      {
        *(_DWORD *)(v4 - 120) |= 0x800u;
        v79 = sub_BC360((__int64)"We believe remote version has SSH-2 channel request bug", v55);
        sub_2D3A0(*(_QWORD *)(v4 + 152), v79, v28, a3);
      }
      if ( (signed int)sub_83D30(*(const char **)(v4 - 144), "1.99") < 0
        || (signed int)sub_83D30(*(const char **)(v4 - 32), "1.99") < 0 )
      {
        if ( (signed int)sub_83D30(*(const char **)(v4 - 144), "2.0") >= 0
          || (signed int)sub_83D30(*(const char **)(v4 - 32), "2.0") >= 0 )
        {
          v11 = sub_83D30(*(const char **)(v4 - 144), "1.99");
          v12 = *(_QWORD *)(v4 + 160);
          if ( v11 < 0 )
            result = sub_42500(
                       v12,
                       (__int64)"SSH protocol version 1 required by our configuration but not provided by remote",
                       v28,
                       a3);
          else
            result = sub_42500(
                       v12,
                       (__int64)"SSH protocol version 2 required by our configuration but remote only provides (old, insecure) SSH-1",
                       v28,
                       a3);
          goto LABEL_22;
        }
        v35 = *(_BYTE *)(v4 - 128) == 0;
        *(_DWORD *)(v4 - 124) = 1;
        v56 = 1LL;
        if ( v35 )
        {
          if ( (signed int)sub_83D30(*(const char **)(v4 - 144), *(const char **)(v4 - 32)) > 0 )
          {
            sub_2F4D0(*(void **)(v4 - 144));
            *(_QWORD *)(v4 - 144) = sub_BC120(*(char **)(v4 - 32));
          }
          v56 = *(unsigned int *)(v4 - 124);
        }
      }
      else
      {
        *(_DWORD *)(v4 - 124) = 2;
        v56 = 2LL;
      }
      v57 = sub_BC360((__int64)"Using SSH protocol version %d", v56);
      sub_2D3A0(*(_QWORD *)(v4 + 152), v57, v28, a3);
      if ( !*(_BYTE *)(v4 - 128) )
        sub_83E10(v3, v28, a3);
      return (**(__int64 (__fastcall ***)(const char *, _QWORD))(v4 - 136))(
               "Using SSH protocol version %d",
               *(unsigned int *)(v4 - 124));
    }
LABEL_27:
    *(_DWORD *)(v4 - 176) = 287;
  }
LABEL_6:
  if ( *(_BYTE *)(v4 + 24) )
    result = sub_42140(*(_QWORD *)(v4 + 160), (__int64)"Remote side unexpectedly closed network connection", a2, a3);
  return result;
}

void __fastcall sub_84B90(__int64 a1)
{
  sub_1ED50(*(_QWORD **)(a1 - 168));
  sub_2F4D0(*(void **)(a1 - 48));
  sub_BC660(*(void ***)(a1 - 40));
  sub_2F4D0(*(void **)(a1 - 32));
  sub_2F4D0(*(void **)(a1 - 16));
  sub_2F4D0(*(void **)(a1 - 144));
  sub_2F4D0((void *)(a1 - 176));
}

__int64 __fastcall sub_84BE0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(a1 + 136))(a1 + 88, a1 + 88, 0LL);
  if ( result )
    __assert_fail(
      "false && \"Should never try to send packets during SSH version \" \"string exchange\"",
      "sshverstring.c",
      0x19Bu,
      "ssh_verstring_handle_output");
  return result;
}

_QWORD *__fastcall sub_84C20(_QWORD *a1, __int64 a2, char a3, char *a4, __int64 a5, char a6, char *src)
{
  char v7; // r13
  char *v8; // r12
  char v9; // bp
  _BOOL4 v10; // ebx
  _QWORD *v11; // rax
  _QWORD *v12; // r15
  __int64 v14; // [rsp+8h] [rbp-40h]

  v7 = a3;
  v8 = a4;
  v9 = a6;
  LOBYTE(v10) = a6;
  v14 = a5;
  v11 = sub_2F450(1uLL, 0x190uLL, 0LL);
  *v11 = 0LL;
  v11[49] = 0LL;
  v12 = v11;
  memset(
    (void *)((unsigned __int64)(v11 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v11 - (((_DWORD)v11 + 8) & 0xFFFFFFF8) + 400) >> 3));
  if ( v7 )
  {
    v11[3] = 42LL;
    v11[2] = "SSHCONNECTION@putty.projects.tartarus.org-";
  }
  else
  {
    v11[3] = 4LL;
    v11[2] = "SSH-";
  }
  v11[1] = sub_1EED0(a1);
  v12[41] = a2;
  v12[4] = sub_BC120(v8);
  v12[5] = v14;
  v12[16] = sub_BC120(src);
  v12[17] = sub_BC640();
  if ( !v9 )
    v10 = (signed int)sub_83D30(v8, "2.0") >= 0;
  *((_BYTE *)v12 + 48) = v10;
  v12[22] = off_321860;
  sub_62760((__int64)(v12 + 22));
  return v12 + 22;
}

__int64 __fastcall sub_84D60(__int64 a1)
{
  return **(_QWORD **)(a1 - 40);
}

__int64 __fastcall sub_84D70(__int64 a1)
{
  return *(_QWORD *)(a1 - 16);
}

__int64 __fastcall sub_84D80(__int64 a1)
{
  return *(unsigned int *)(a1 - 120);
}

_QWORD *__fastcall sub_84D90(__int64 a1, __int64 a2, signed int a3, unsigned int a4, signed int a5, int a6)
{
  signed int v6; // er14
  signed int v7; // ebp
  __int64 v8; // r12
  int v9; // er15
  _QWORD *v10; // ST08_8
  char *v11; // rax
  _QWORD *v12; // r10
  int v13; // er8
  char *v14; // rdx
  __int64 v15; // rdi
  int v16; // esi
  char *v17; // rdx
  int v18; // ecx
  int v19; // er14
  __int64 v20; // r13
  signed int v21; // er15
  _QWORD *v22; // r12
  int v23; // ebp
  char *v24; // rbx
  int v25; // er9
  int v26; // er9
  __int64 v28; // [rsp+0h] [rbp-58h]
  signed int v29; // [rsp+8h] [rbp-50h]
  __int64 v30; // [rsp+10h] [rbp-48h]
  unsigned int v31; // [rsp+18h] [rbp-40h]
  signed int v32; // [rsp+1Ch] [rbp-3Ch]

  v6 = a3;
  v7 = a5;
  v8 = a2;
  v9 = a6;
  v28 = a1;
  v31 = a4;
  v10 = sub_2F450(1uLL, 0x10uLL, 0LL);
  v11 = (char *)sub_2F450(1LL << v9, 0x10uLL, 0LL);
  v12 = v10;
  v13 = (1 << v9) - 1;
  v10[1] = v11;
  *(_DWORD *)v10 = v13;
  if ( v13 < 0 )
  {
    if ( v6 <= 0 )
      return v12;
  }
  else
  {
    v14 = v11;
    do
    {
      *v14 = 0;
      *((_QWORD *)v14 + 1) = 0LL;
      *((_WORD *)v14 + 1) = -1;
      v14 += 16;
    }
    while ( &v11[16 * v13 + 16] != v14 );
    if ( v6 <= 0 )
    {
LABEL_15:
      v30 = v8;
      v32 = v6;
      v29 = 1 << v7;
      v19 = v9;
      v20 = 0LL;
      v21 = v7;
      v22 = v12;
      v23 = 0;
      while ( 1 )
      {
        v24 = &v11[16 * v20];
        v25 = (unsigned __int8)*v24;
        if ( v25 > v19 )
        {
          v26 = v25 - v19;
          *((_WORD *)v24 + 1) = -1;
          *v24 = v19;
          if ( v26 > 7 )
            v26 = 7;
          *((_QWORD *)v24 + 1) = sub_84D90(v28, v30, v32, v23 | v31, v21 + v19, v26);
        }
        v23 += v29;
        if ( *(_DWORD *)v22 < (signed int)++v20 )
          break;
        v11 = (char *)v22[1];
      }
      return v22;
    }
  }
  v15 = 0LL;
  do
  {
    while ( 1 )
    {
      if ( *(unsigned __int8 *)(v8 + v15) > v7 && (((1 << v7) - 1) & *(_DWORD *)(v28 + 4 * v15)) == v31 )
      {
        v16 = v13 & (*(_DWORD *)(v28 + 4 * v15) >> v7);
        if ( v13 >= v16 )
          break;
      }
      if ( v6 <= (signed int)++v15 )
        goto LABEL_14;
    }
    do
    {
      v17 = &v11[16 * v16];
      *((_WORD *)v17 + 1) = v15;
      v18 = *(unsigned __int8 *)(v8 + v15) - v7;
      if ( (unsigned __int8)*v17 < v18 )
      {
        *v17 = v18;
        LOBYTE(v18) = *(_BYTE *)(v8 + v15) - v7;
      }
      v16 += 1 << v18;
    }
    while ( v13 >= v16 );
    ++v15;
  }
  while ( v6 > (signed int)v15 );
LABEL_14:
  if ( v13 >= 0 )
    goto LABEL_15;
  return v12;
}

_QWORD *__fastcall sub_84F90(unsigned __int8 *a1, signed int a2)
{
  signed int v2; // edx
  unsigned __int8 *v3; // r11
  int *v4; // rax
  unsigned __int8 *v5; // rax
  int v6; // er9
  unsigned __int8 *v7; // r8
  __int64 v8; // rdi
  signed __int64 v9; // rcx
  int v10; // eax
  int v11; // eax
  __int64 v12; // rsi
  __int64 v13; // rax
  int v14; // ecx
  int v15; // ebx
  int v16; // eax
  int v17; // er8
  int v18; // er10
  int v20[16]; // [rsp+0h] [rbp-528h]
  int v21[16]; // [rsp+40h] [rbp-4E8h]
  char v22[1160]; // [rsp+80h] [rbp-4A8h]
  unsigned __int64 v23; // [rsp+508h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  v23 = __readfsqword(0x28u);
  v4 = &v20[1];
  do
  {
    *v4 = 0;
    ++v4;
  }
  while ( v4 != v21 );
  if ( a2 <= 0 )
  {
    v6 = 0;
  }
  else
  {
    v5 = a1;
    v6 = 0;
    v7 = &a1[a2 - 1 + 1];
    do
    {
      v8 = *v5;
      ++v20[v8];
      if ( v6 < (signed int)v8 )
        v6 = v8;
      ++v5;
    }
    while ( v7 != v5 );
    if ( v6 > 9 )
      v6 = 9;
  }
  v9 = 1LL;
  v10 = 0;
  do
  {
    v21[v9] = v10;
    v11 = v20[v9] + v10;
    ++v9;
    v10 = 2 * v11;
  }
  while ( v9 != 16 );
  if ( a2 > 0 )
  {
    v12 = 0LL;
    do
    {
      v13 = v3[v12];
      *(_DWORD *)&v22[4 * v12] = 0;
      v14 = v21[v13];
      v15 = v13;
      v21[v13] = v14 + 1;
      if ( (_DWORD)v13 )
      {
        v16 = 0;
        v17 = 0;
        do
        {
          ++v17;
          v18 = v14 & 1;
          v14 >>= 1;
          v16 = v18 | 2 * v16;
        }
        while ( v15 != v17 );
        *(_DWORD *)&v22[4 * v12] = v16;
      }
      ++v12;
    }
    while ( (unsigned int)(v2 - 1) + 1LL != v12 );
  }
  return sub_84D90((__int64)v22, (__int64)v3, v2, 0, 0, v6);
}

__int64 __fastcall sub_850E0(signed __int64 *a1, unsigned __int8 *a2, signed __int64 a3, unsigned __int64 a4, signed __int64 a5, signed __int64 a6)
{
  signed __int64 v6; // rbp
  int v7; // edi
  unsigned __int8 *v8; // rbx
  signed int v9; // er15
  int v10; // esi
  int v11; // er15
  __int64 v12; // rax
  char v13; // dl
  unsigned __int8 v14; // r11
  _WORD *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // r8
  int v18; // esi
  unsigned int v19; // er13
  int v20; // eax
  __int64 v21; // rdi
  unsigned __int8 v22; // si
  __int64 v23; // rdx
  __int64 v24; // r10
  signed __int64 v25; // r10
  __int64 v26; // rax
  unsigned __int8 v27; // r11
  int v28; // ecx
  __int64 v29; // rsi
  __int64 v30; // rax
  signed __int64 v31; // r11
  __int64 *v32; // rax
  int v33; // er12
  int v34; // er10
  __int64 *v35; // rdi
  __int64 v36; // r14
  __int64 v37; // r11
  __int64 result; // rax
  unsigned __int64 v39; // rt1
  __int64 v40; // rax
  signed int v41; // [rsp+8h] [rbp-170h]
  signed __int64 *v42; // [rsp+10h] [rbp-168h]
  unsigned int v43; // [rsp+18h] [rbp-160h]
  unsigned int v44; // [rsp+1Ch] [rbp-15Ch]
  unsigned int v45; // [rsp+2Ch] [rbp-14Ch]
  __int64 v46[32]; // [rsp+30h] [rbp-148h]
  __int64 v47[32]; // [rsp+38h] [rbp-140h]
  unsigned __int8 v48; // [rsp+135h] [rbp-43h]
  unsigned __int8 v49; // [rsp+136h] [rbp-42h]
  unsigned __int8 v50; // [rsp+137h] [rbp-41h]
  unsigned __int64 v51; // [rsp+138h] [rbp-40h]

  v6 = *a1;
  v42 = a1;
  v51 = __readfsqword(0x28u);
  v7 = *(_DWORD *)(v6 + 233464);
  if ( v7 > 3 )
    goto LABEL_77;
  v8 = a2;
  v9 = a3;
  if ( v7 <= 0 )
  {
    v18 = *(_DWORD *)(v6 + 233464);
  }
  else if ( v7 + (signed int)a3 <= 2 )
  {
    v18 = *(_DWORD *)(v6 + 233464);
    LODWORD(a4) = 0;
LABEL_16:
    a4 = (signed int)a4;
    a3 = v6 - (signed int)a4;
    do
    {
      *(_BYTE *)(a3 + a4 + 233458) = *(_BYTE *)(v6 + a4 + 233458);
      ++a4;
    }
    while ( v7 > (signed int)a4 );
  }
  else
  {
    v10 = *(_DWORD *)(v6 + 229376);
    v41 = a3;
    a6 = v6;
    LODWORD(a4) = 0;
    v11 = v7 + a3 - 2;
    while ( 1 )
    {
      v12 = 0LL;
      do
      {
        if ( v7 <= (signed int)a4 + (signed int)v12 )
          v13 = v8[(signed int)a4 - v7 + (signed int)v12];
        else
          v13 = *(_BYTE *)(a6 + v12 + 233458);
        *(&v48 + v12++) = v13;
      }
      while ( v12 != 3 );
      v14 = v48;
      v15 = (_WORD *)(v6 + 6LL * v10);
      v16 = (signed int)(269 * v50
                       + 257 * v48
                       + 263 * v49
                       - 2039
                       * ((unsigned int)((unsigned __int64)(269620311LL * (269 * v50 + 257 * v48 + 263 * v49)) >> 32) >> 7));
      v17 = (signed __int16)v15[1];
      if ( (_WORD)v17 == -1 )
      {
        v36 = (signed __int16)v15[2];
        if ( (_WORD)v36 != -1 )
          *(__int16 *)((char *)&word_38004[v36] + v6) = -1;
      }
      else
      {
        *(_WORD *)(v6 + 6 * v17) = -1;
      }
      a5 = v6 + 2 * v16;
      v15[2] = v16;
      v15[1] = -1;
      a3 = (unsigned int)*(__int16 *)((char *)word_38004 + a5);
      *v15 = *(__int16 *)((char *)word_38004 + a5);
      *(__int16 *)((char *)word_38004 + a5) = v10;
      if ( (_DWORD)a3 != -1 )
      {
        a3 = (signed int)a3;
        *(_WORD *)(v6 + 6LL * (signed int)a3 + 2) = v10;
      }
      a4 = (unsigned int)(a4 + 1);
      *((_BYTE *)&loc_30000 + v6 + v10) = v14;
      v10 = ((_WORD)v10 + 1) & 0x7FFF;
      *(_DWORD *)(v6 + 229376) = v10;
      if ( v7 == (_DWORD)a4 )
        break;
      ++a6;
      if ( (_DWORD)a4 == v11 )
      {
        v9 = v41;
        v18 = v7 - a4;
        goto LABEL_16;
      }
    }
    v9 = v41;
    v18 = 0;
  }
  v19 = 0;
  *(_DWORD *)(v6 + 233464) = v18;
  v43 = 0;
  v45 = 0;
  if ( v9 > 0 )
  {
    if ( v9 > 2 )
      goto LABEL_33;
LABEL_20:
    if ( !v19 )
    {
      ((void (__fastcall *)(signed __int64 *, _QWORD, signed __int64, unsigned __int64, signed __int64, signed __int64))v42[2])(
        v42,
        *v8,
        a3,
        a4,
        a5,
        a6);
      v20 = 1;
      goto LABEL_22;
    }
LABEL_21:
    ((void (__fastcall *)(signed __int64 *, _QWORD, _QWORD, unsigned __int64, signed __int64, signed __int64))v42[3])(
      v42,
      v43,
      v19,
      a4,
      a5,
      a6);
    v20 = v19 - 1;
    v19 = 0;
    a5 = (signed __int64)v8;
    if ( v20 )
      goto LABEL_22;
    do
    {
      v8 = (unsigned __int8 *)a5;
      if ( v9 <= 2 )
        goto LABEL_20;
LABEL_33:
      v27 = *v8;
      v44 = *v8;
      v28 = 269 * v8[2] + 257 * v44 + 263 * v8[1];
      a3 = 2039 * ((unsigned int)((unsigned __int64)(269620311LL * v28) >> 32) >> 7);
      a4 = v28 - (signed int)a3;
      v29 = *(__int16 *)((char *)&word_38004[a4] + v6);
      if ( (_DWORD)v29 == -1 )
        goto LABEL_20;
      a5 = *(unsigned int *)(v6 + 229376);
      a3 = 0LL;
      do
      {
        while ( 1 )
        {
          a4 = v27;
          a6 = (unsigned int)(0x8000 - ((signed int)v29 + 0x8000 - (signed int)a5) % 0x8000);
          v30 = 0LL;
          if ( ((signed int)v29 + 0x8000 - (signed int)a5) % 0x8000 - 0x8000 >= 0 )
            goto LABEL_36;
LABEL_39:
          if ( *((unsigned __int8 *)&loc_30000
               + v6
               + (((_WORD)a5
                 - (-32768
                  - (unsigned __int16)(((signed int)v29 + 0x8000 - (signed int)a5) % 0x8000))
                 + (_WORD)v30) & 0x7FFF)) != (_DWORD)a4 )
            goto LABEL_40;
LABEL_37:
          if ( ++v30 == 3 )
            break;
          a4 = v8[v30];
          if ( (signed int)v30 - (signed int)a6 < 0 )
            goto LABEL_39;
LABEL_36:
          if ( v8[((signed int)v29 + 0x8000 - (signed int)a5) % 0x8000 - 0x8000 + v30] == (_DWORD)a4 )
            goto LABEL_37;
LABEL_40:
          v29 = *(signed __int16 *)(v6 + 6 * v29);
          if ( (_DWORD)v29 == -1 )
            goto LABEL_41;
        }
        v40 = (signed int)a3;
        a3 = (unsigned int)(a3 + 1);
        LODWORD(v46[v40]) = a6;
        HIDWORD(v46[v40]) = 3;
        if ( (signed int)a3 > 31 )
          goto LABEL_42;
        v29 = *(signed __int16 *)(v6 + 6 * v29);
      }
      while ( (_DWORD)v29 != -1 );
LABEL_41:
      if ( !(_DWORD)a3 )
        goto LABEL_20;
LABEL_42:
      if ( v9 == 3 )
      {
        v33 = 3;
        HIDWORD(v46[0]) = 3;
        if ( v19 )
          goto LABEL_67;
      }
      else
      {
        v31 = 3LL;
        do
        {
          v32 = v47;
          v33 = v31;
          v34 = v8[v31];
          v35 = v46;
          a6 = (signed __int64)&v47[(unsigned int)(a3 - 1)];
          LODWORD(a3) = 0;
          while ( 1 )
          {
            a4 = (signed int)v31 - *(_DWORD *)v35 >= 0 ? (unsigned __int64)v8[(signed int)v31 - *(_DWORD *)v35] : (unsigned __int64)*((unsigned __int8 *)&loc_30000 + v6 + (((_WORD)v31 + (_WORD)a5 - (unsigned __int16)*(_DWORD *)v35) & 0x7FFF));
            if ( (_DWORD)a4 == v34 )
            {
              a4 = (signed int)a3;
              LODWORD(a3) = a3 + 1;
              v46[a4] = *v35;
            }
            v35 = v32;
            if ( (__int64 *)a6 == v32 )
              break;
            ++v32;
          }
          if ( !(_DWORD)a3 )
            break;
          v33 = v31++ + 1;
        }
        while ( (unsigned int)(v9 - 4) + 4LL != v31 );
        HIDWORD(v46[0]) = v33;
        if ( v19 )
        {
LABEL_67:
          if ( (signed int)(v19 + 1) < v33 )
          {
            v19 = v33;
            ((void (__fastcall *)(signed __int64 *, _QWORD))v42[2])(v42, v45);
            v43 = v46[0];
            v45 = *v8;
            v20 = 1;
            goto LABEL_22;
          }
          goto LABEL_21;
        }
      }
      v19 = v33;
      v43 = v46[0];
      v45 = v44;
      v20 = 1;
LABEL_22:
      a6 = 269620311LL;
      a5 = (signed __int64)&v8[v20 - 1 + 1];
      do
      {
        while ( v9 <= 2 )
        {
          v26 = *(signed int *)(v6 + 233464);
          if ( (signed int)v26 > 2 )
            __assert_fail("st->npending < HASHCHARS", "sshzlib.c", 0x140u, "lz77_compress");
          ++v8;
          --v9;
          *(_DWORD *)(v6 + 233464) = v26 + 1;
          a3 = *(v8 - 1);
          *(_BYTE *)(v6 + v26 + 233458) = a3;
          if ( v8 == (unsigned __int8 *)a5 )
            goto LABEL_31;
        }
        v21 = *(signed int *)(v6 + 229376);
        v22 = *v8;
        v23 = (signed int)(269 * v8[2]
                         + 257 * *v8
                         + 263 * v8[1]
                         - 2039
                         * ((unsigned int)((unsigned __int64)(269620311LL * (269 * v8[2] + 257 * *v8 + 263 * v8[1])) >> 32) >> 7));
        a4 = v6 + 6 * v21;
        v24 = *(signed __int16 *)(a4 + 2);
        if ( (_WORD)v24 == -1 )
        {
          v37 = *(signed __int16 *)(a4 + 4);
          if ( (_WORD)v37 != -1 )
            *(__int16 *)((char *)&word_38004[v37] + v6) = -1;
        }
        else
        {
          *(_WORD *)(v6 + 6 * v24) = -1;
        }
        *(_WORD *)(a4 + 4) = v23;
        *(_WORD *)(a4 + 2) = -1;
        v25 = v6 + 2 * v23;
        a3 = (unsigned int)*(__int16 *)((char *)word_38004 + v25);
        *(_WORD *)a4 = *(__int16 *)((char *)word_38004 + v25);
        *(__int16 *)((char *)word_38004 + v25) = v21;
        if ( (_DWORD)a3 != -1 )
        {
          a3 = 3LL * (signed int)a3;
          *(_WORD *)(v6 + 2 * a3 + 2) = v21;
        }
        ++v8;
        --v9;
        *((_BYTE *)&loc_30000 + v6 + v21) = v22;
        *(_DWORD *)(v6 + 229376) = ((_WORD)v21 + 1) & 0x7FFF;
      }
      while ( v8 != (unsigned __int8 *)a5 );
LABEL_31:
      ;
    }
    while ( v9 > 0 );
  }
  v39 = __readfsqword(0x28u);
  result = v39 ^ v51;
  if ( v39 != v51 )
LABEL_77:
    __assert_fail("st->npending <= HASHCHARS", "sshzlib.c", 0xBAu, "lz77_compress");
  return result;
}

void __fastcall sub_85790(__int64 a1)
{
  void ***v1; // rbp

  v1 = *(void ****)(a1 - 24);
  if ( *v1 )
    sub_BC660(*v1);
  sub_2F4D0(v1);
  sub_2F4D0(*(void **)(a1 - 32));
  sub_2F4D0((void *)(a1 - 32));
}

__int64 __fastcall sub_857D0(void **a1)
{
  _QWORD *v1; // rbx
  void **v2; // r13
  char *v3; // rdi
  __int64 v4; // r12
  int v5; // ebp

  v1 = *a1;
  if ( *a1 )
  {
    v2 = a1;
    v3 = (char *)v1[1];
    if ( *(_DWORD *)v1 >= 0 )
    {
      v4 = 0LL;
      v5 = 0;
      do
      {
        if ( *(_QWORD *)&v3[v4 + 8] )
        {
          sub_857D0(&v3[v4 + 8]);
          v3 = (char *)v1[1];
        }
        ++v5;
        v4 += 16LL;
      }
      while ( *(_DWORD *)v1 >= v5 );
    }
    sub_2F4D0(v3);
    v1[1] = 0LL;
    sub_2F4D0(v1);
    *v2 = 0LL;
  }
  return 0LL;
}

void __fastcall sub_85850(__int64 a1)
{
  void **v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rax
  void **v4; // rdi

  v1 = (void **)(a1 - 33216);
  v2 = *(_QWORD *)(a1 - 33200);
  if ( v2 && v2 != *(_QWORD *)(a1 - 33216) )
    sub_857D0(v1 + 2);
  v3 = *(_QWORD *)(a1 - 33192);
  if ( v3 && v3 != *(_QWORD *)(a1 - 33208) )
    sub_857D0(v1 + 3);
  if ( *(_QWORD *)(a1 - 33184) )
    sub_857D0(v1 + 4);
  sub_857D0(v1);
  sub_857D0(v1 + 1);
  v4 = *(void ***)(a1 - 8);
  if ( v4 )
    sub_BC660(v4);
  sub_2F4D0(v1);
}

signed __int64 __fastcall sub_858E0(__int64 a1, __int64 a2, int a3, _QWORD *a4, _DWORD *a5)
{
  __int64 v5; // rbx
  __int64 v6; // r15
  int v7; // ebp
  __int64 v8; // r13
  signed __int64 v9; // rax
  int v10; // er8
  unsigned __int64 v11; // rdx
  signed int v12; // ecx
  int v13; // eax
  unsigned __int64 v14; // rax
  unsigned int v15; // edx
  __int64 v16; // rdi
  unsigned __int64 v18; // rax
  char *v19; // rsi
  int v20; // ecx
  unsigned __int64 v21; // rdx
  int v22; // eax
  int v23; // er12
  int v24; // eax
  char v25; // si
  int v26; // eax
  signed int *v27; // rdx
  unsigned __int64 v28; // rsi
  signed int v29; // edx
  unsigned __int8 *v30; // rax
  int v31; // ecx
  __int64 v32; // rdi
  unsigned __int64 v33; // rsi
  signed int *v34; // rdx
  __int16 v35; // dx
  unsigned __int8 *v36; // rax
  int v37; // ecx
  _WORD *v38; // rsi
  int v39; // ecx
  unsigned __int64 v40; // rdx
  int v41; // eax
  int v42; // ecx
  unsigned __int64 v43; // rsi
  int v44; // edx
  int v45; // ecx
  int v46; // edi
  char v47; // si
  __int64 v48; // rax
  signed __int64 v49; // rdi
  __int64 v50; // rdx
  int v51; // er9
  __int64 v52; // rdi
  signed int v53; // esi
  _QWORD *v54; // rax
  __int64 v55; // rdi
  signed int v56; // esi
  __int16 v57; // ax
  unsigned __int64 v58; // rdx
  unsigned __int16 v59; // ax
  __int64 v60; // rdx
  __int16 v61; // ax
  int v62; // eax
  bool v63; // zf
  unsigned __int64 v64; // rax
  int v65; // er9
  int v66; // er10
  unsigned __int64 v67; // rdx
  __int64 v68; // rax
  __int64 v69; // rdi
  char v70; // si
  _QWORD *v71; // rax
  unsigned __int64 v72; // rax
  unsigned __int64 v73; // rdx
  unsigned __int64 v74; // rax
  int v75; // edx
  int v76; // ecx
  signed int *v77; // rdx
  unsigned __int64 v78; // rsi
  __int16 v79; // dx
  unsigned __int8 *v80; // rax
  int v81; // ecx
  __int16 v82; // ax
  int v83; // eax
  __int64 v84; // rax
  _QWORD *v85; // [rsp+8h] [rbp-50h]
  _DWORD *v86; // [rsp+10h] [rbp-48h]
  void **v87; // [rsp+18h] [rbp-40h]

  v85 = a4;
  v86 = a5;
  if ( *(_QWORD *)(a1 - 8) )
    __assert_fail("!dctx->outblk", "sshzlib.c", 0x3E9u, "zlib_decompress_block");
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a1 - 33216;
  v9 = sub_BC650();
  v10 = *(_DWORD *)(a1 - 32784);
  *(_QWORD *)(a1 - 8) = v9;
  v87 = (void **)(a1 - 33216 + 24);
LABEL_3:
  while ( 2 )
  {
    if ( v7 <= 0 )
    {
LABEL_13:
      if ( v10 <= 0 )
        goto LABEL_14;
    }
    else
    {
LABEL_4:
      if ( v10 <= 23 )
      {
        v11 = *(_QWORD *)(v5 - 32792);
        v12 = v10;
        do
        {
          ++v6;
          --v7;
          v13 = *(unsigned __int8 *)(v6 - 1) << v12;
          v12 += 8;
          *(_DWORD *)(v5 - 32784) = v12;
          v11 |= v13;
          *(_QWORD *)(v5 - 32792) = v11;
        }
        while ( v12 <= 23 && v7 > 0 );
        v10 = v12;
      }
    }
    switch ( *(_DWORD *)(v5 - 33176) )
    {
      case 0:
        if ( v10 <= 15 )
          goto LABEL_14;
        v57 = *(_WORD *)(v5 - 32792);
        v58 = *(_QWORD *)(v5 - 32792);
        v10 -= 16;
        *(_DWORD *)(v5 - 32784) = v10;
        v59 = __ROL2__(v57, 8);
        *(_QWORD *)(v5 - 32792) = v58 >> 16;
        if ( (v59 & 0xF00) == 2048 && (v59 & 0xF000u) <= 0x7000 && !(v59 & 0x20) && v59 == 31 * (v59 / 0x1Fu) )
          goto LABEL_49;
        goto LABEL_67;
      case 1:
        if ( v10 <= 2 )
          goto LABEL_14;
        v72 = *(_QWORD *)(v5 - 32792);
        v10 -= 3;
        *(_DWORD *)(v5 - 32784) = v10;
        v73 = v72;
        v74 = v72 >> 3;
        *(_QWORD *)(v5 - 32792) = v74;
        v75 = (v73 >> 1) & 3;
        if ( v75 )
        {
          if ( v75 == 1 )
          {
            v84 = *(_QWORD *)(v5 - 33216);
            *(_DWORD *)(v5 - 33176) = 6;
            *(_QWORD *)(v5 - 33200) = v84;
            *(_QWORD *)(v5 - 33192) = *(_QWORD *)(v5 - 33208);
          }
          else if ( v75 == 2 )
          {
            *(_DWORD *)(v5 - 33176) = 2;
          }
        }
        else
        {
          *(_DWORD *)(v5 - 33176) = 10;
          v76 = v10 & 7;
          v10 -= v76;
          *(_DWORD *)(v5 - 32784) = v10;
          *(_QWORD *)(v5 - 32792) = v74 >> v76;
        }
        continue;
      case 2:
        if ( v10 <= 13 )
          goto LABEL_14;
        v64 = *(_QWORD *)(v5 - 32792);
        v10 -= 14;
        *(_DWORD *)(v5 - 33156) = 0;
        *(_DWORD *)(v5 - 33176) = 3;
        *(_DWORD *)(v5 - 32784) = v10;
        *(_DWORD *)(v5 - 33168) = (v64 & 0x1F) + 257;
        *(_DWORD *)(v5 - 33164) = ((v64 >> 5) & 0x1F) + 1;
        *(_QWORD *)(v5 - 32792) = v64 >> 14;
        *(_DWORD *)(v5 - 33160) = ((v64 >> 10) & 0xF) + 4;
        *(_WORD *)(v8 + 100) = 0;
        *(_OWORD *)(v8 + 84) = 0LL;
        *(_BYTE *)(v8 + 102) = 0;
        continue;
      case 3:
        if ( v10 <= 2 )
          goto LABEL_14;
        v65 = *(_DWORD *)(v5 - 33156);
        v66 = *(_DWORD *)(v5 - 33160);
        if ( v65 >= v66 )
          goto LABEL_62;
        v10 = *(_DWORD *)(v5 - 32784);
        if ( v10 <= 2 )
          continue;
        v67 = *(_QWORD *)(v5 - 32792);
        v68 = v65 + 1;
        v69 = v68 + (unsigned int)(v66 - 1 - v65);
        while ( 1 )
        {
          v10 -= 3;
          v70 = v67 & 7;
          v67 >>= 3;
          v65 = v68;
          *(_BYTE *)(v5 + byte_F379F[v68] - 33132) = v70;
          if ( v69 == v68 )
            break;
          ++v68;
          if ( v10 <= 2 )
          {
            *(_QWORD *)(v5 - 32792) = v67;
            *(_DWORD *)(v5 - 33156) = v65;
            *(_DWORD *)(v5 - 32784) = v10;
            goto LABEL_3;
          }
        }
        *(_QWORD *)(v5 - 32792) = v67;
        *(_DWORD *)(v5 - 33156) = v69;
        *(_DWORD *)(v5 - 32784) = v10;
LABEL_62:
        if ( v65 == v66 )
        {
          v71 = sub_84F90((unsigned __int8 *)(v8 + 84), 19);
          *(_DWORD *)(v5 - 33176) = 4;
          *(_QWORD *)(v5 - 33184) = v71;
          *(_DWORD *)(v5 - 33156) = 0;
          v10 = *(_DWORD *)(v5 - 32784);
          continue;
        }
        goto LABEL_21;
      case 4:
        v52 = *(signed int *)(v5 - 33156);
        v53 = *(_DWORD *)(v5 - 33168);
        if ( (signed int)v52 >= v53 + *(_DWORD *)(v5 - 33164) )
        {
          v54 = sub_84F90((unsigned __int8 *)(v8 + 103), v53);
          v55 = *(signed int *)(v5 - 33168);
          v56 = *(_DWORD *)(v5 - 33164);
          *(_QWORD *)(v5 - 33200) = v54;
          *(_QWORD *)(v5 - 33192) = sub_84F90((unsigned __int8 *)(v8 + 103 + v55), v56);
          sub_857D0((void **)(v8 + 32));
          *(_QWORD *)(v5 - 33184) = 0LL;
          *(_DWORD *)(v5 - 33176) = 6;
          v10 = *(_DWORD *)(v5 - 32784);
          continue;
        }
        v77 = *(signed int **)(v5 - 33184);
        v78 = *(_QWORD *)(v5 - 32792);
        while ( 1 )
        {
          v80 = (unsigned __int8 *)(*((_QWORD *)v77 + 1) + 16 * (v78 & *v77));
          v81 = *v80;
          if ( v81 > v10 )
            goto LABEL_14;
          v79 = *((_WORD *)v80 + 1);
          v78 >>= v81;
          v10 -= v81;
          if ( v79 != -1 )
            break;
          v77 = (signed int *)*((_QWORD *)v80 + 1);
          if ( !v77 )
            goto LABEL_67;
        }
        *(_QWORD *)(v5 - 32792) = v78;
        *(_DWORD *)(v5 - 32784) = v10;
        if ( v79 != -1 )
        {
          if ( v79 == -2 )
          {
LABEL_67:
            *v85 = 0LL;
            *v86 = 0;
            return 0LL;
          }
          if ( v79 > 15 )
          {
            if ( v79 != 16 )
            {
              if ( v79 == 17 )
              {
                *(_DWORD *)(v5 - 33152) = 3;
              }
              else
              {
                *(_DWORD *)(v5 - 33152) = 7;
                if ( v79 == 18 )
                {
                  *(_DWORD *)(v5 - 33148) = 11;
                  v83 = 0;
                  goto LABEL_99;
                }
              }
              *(_DWORD *)(v5 - 33148) = 3;
LABEL_103:
              v83 = 0;
              goto LABEL_99;
            }
            *(_DWORD *)(v5 - 33152) = 2;
            *(_DWORD *)(v5 - 33148) = 3;
            if ( (signed int)v52 <= 0 )
              goto LABEL_103;
            v83 = *(unsigned __int8 *)(v5 + (signed int)v52 - 1 - 33113);
LABEL_99:
            *(_DWORD *)(v5 - 33140) = v83;
            *(_DWORD *)(v5 - 33176) = 5;
          }
          else
          {
            *(_DWORD *)(v5 - 33156) = v52 + 1;
            *(_BYTE *)(v5 + v52 - 33113) = v79;
          }
          continue;
        }
LABEL_14:
        v16 = *(_QWORD *)(v5 - 8);
LABEL_15:
        *v86 = *(_QWORD *)(v16 + 16);
        *v85 = sub_BC6B0((__int64 *)v16);
        *(_QWORD *)(v5 - 8) = 0LL;
        return 1LL;
      case 5:
        v42 = *(_DWORD *)(v5 - 33152);
        if ( v42 > v10 )
          goto LABEL_14;
        v43 = *(_QWORD *)(v5 - 32792);
        v10 -= v42;
        *(_DWORD *)(v5 - 32784) = v10;
        v44 = *(_DWORD *)(v5 - 33148) + (v43 & ((1 << v42) - 1));
        *(_QWORD *)(v5 - 32792) = v43 >> v42;
        if ( v44 <= 0 )
          goto LABEL_41;
        v45 = *(_DWORD *)(v5 - 33168) + *(_DWORD *)(v5 - 33164);
        v46 = *(_DWORD *)(v5 - 33156);
        if ( v46 >= v45 )
          goto LABEL_41;
        v47 = *(_BYTE *)(v5 - 33140);
        v48 = v46 + 1;
        v49 = v48 + (unsigned int)(v45 - v46 - 1) + 1;
        v50 = v48 + (unsigned int)(v44 - 1);
        do
        {
          *(_BYTE *)(v5 - 1 + v48 - 33113) = v47;
          v51 = v48;
          if ( v50 == v48 )
          {
            *(_DWORD *)(v5 - 33156) = v50;
            goto LABEL_41;
          }
          ++v48;
        }
        while ( v49 != v48 );
        *(_DWORD *)(v5 - 33156) = v51;
LABEL_41:
        *(_DWORD *)(v5 - 33176) = 4;
        continue;
      case 6:
        v32 = *(_QWORD *)(v5 - 33200);
        v33 = *(_QWORD *)(v5 - 32792);
        v34 = *(signed int **)(v5 - 33200);
        while ( 2 )
        {
          v36 = (unsigned __int8 *)(*((_QWORD *)v34 + 1) + 16 * (v33 & *v34));
          v37 = *v36;
          if ( v37 > v10 )
            goto LABEL_14;
          v35 = *((_WORD *)v36 + 1);
          v33 >>= v37;
          v10 -= v37;
          if ( v35 == -1 )
          {
            v34 = (signed int *)*((_QWORD *)v36 + 1);
            if ( !v34 )
              goto LABEL_67;
            continue;
          }
          break;
        }
        *(_QWORD *)(v5 - 32792) = v33;
        *(_DWORD *)(v5 - 32784) = v10;
        if ( v35 == -1 )
          goto LABEL_14;
        if ( v35 == -2 )
          goto LABEL_67;
        if ( v35 <= 255 )
        {
          v82 = *(_DWORD *)(v5 - 12);
          *(_BYTE *)(v5 + *(signed int *)(v5 - 12) - 32780) = v35;
          *(_DWORD *)(v5 - 12) = (v82 + 1) & 0x7FFF;
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 - 8) + 24LL), v35);
          v10 = *(_DWORD *)(v5 - 32784);
        }
        else if ( v35 == 256 )
        {
          v63 = v32 == *(_QWORD *)(v5 - 33216);
          *(_DWORD *)(v5 - 33176) = 1;
          if ( !v63 )
          {
            sub_857D0((void **)(v8 + 16));
            *(_QWORD *)(v5 - 33200) = 0LL;
          }
          if ( *(_QWORD *)(v5 - 33192) == *(_QWORD *)(v5 - 33208) )
          {
LABEL_21:
            v10 = *(_DWORD *)(v5 - 32784);
          }
          else
          {
            sub_857D0(v87);
            *(_QWORD *)(v5 - 33192) = 0LL;
            v10 = *(_DWORD *)(v5 - 32784);
          }
        }
        else
        {
          if ( v35 > 285 )
            goto LABEL_67;
          *(_DWORD *)(v5 - 33176) = 7;
          *(_DWORD *)(v5 - 33172) = v35;
        }
        continue;
      case 7:
        v38 = &off_F39A0[6 * (*(_DWORD *)(v5 - 33172) - 257)];
        v39 = (signed __int16)v38[1];
        if ( v39 > v10 )
          goto LABEL_14;
        v40 = *(_QWORD *)(v5 - 32792);
        v10 -= v39;
        *(_DWORD *)(v5 - 32784) = v10;
        *(_DWORD *)(v5 - 33176) = 8;
        v41 = *((_DWORD *)v38 + 1) + (v40 & ((1 << v39) - 1));
        *(_QWORD *)(v5 - 32792) = v40 >> v39;
        *(_DWORD *)(v5 - 33144) = v41;
        continue;
      case 8:
        v27 = *(signed int **)(v5 - 33192);
        v28 = *(_QWORD *)(v5 - 32792);
        while ( 2 )
        {
          v30 = (unsigned __int8 *)(*((_QWORD *)v27 + 1) + 16 * (v28 & *v27));
          v31 = *v30;
          if ( v31 > v10 )
            goto LABEL_14;
          v29 = *((signed __int16 *)v30 + 1);
          v28 >>= v31;
          v10 -= v31;
          if ( *((_WORD *)v30 + 1) == -1 )
          {
            v27 = (signed int *)*((_QWORD *)v30 + 1);
            if ( !v27 )
              goto LABEL_67;
            continue;
          }
          break;
        }
        *(_QWORD *)(v5 - 32792) = v28;
        *(_DWORD *)(v5 - 32784) = v10;
        if ( v29 == -1 )
          goto LABEL_14;
        if ( v29 > 29 || v29 == -2 )
          goto LABEL_67;
        *(_DWORD *)(v5 - 33176) = 9;
        *(_DWORD *)(v5 - 33172) = v29;
        continue;
      case 9:
        v19 = (char *)&unk_F3820 + 12 * *(signed int *)(v5 - 33172);
        v20 = *((signed __int16 *)v19 + 1);
        if ( v20 > v10 )
          goto LABEL_14;
        v21 = *(_QWORD *)(v5 - 32792);
        v10 -= v20;
        *(_DWORD *)(v5 - 32784) = v10;
        *(_DWORD *)(v5 - 33176) = 6;
        v22 = *(_DWORD *)(v5 - 33144);
        v23 = *((_DWORD *)v19 + 1) + (v21 & ((1 << v20) - 1));
        *(_QWORD *)(v5 - 32792) = v21 >> v20;
        *(_DWORD *)(v5 - 33144) = v22 - 1;
        if ( !v22 )
          continue;
        do
        {
          v24 = *(_DWORD *)(v5 - 12);
          v25 = *(_BYTE *)(v5 + (((unsigned __int16)*(_DWORD *)(v5 - 12) - (_WORD)v23) & 0x7FFF) - 32780);
          *(_BYTE *)(v5 + v24 - 32780) = v25;
          *(_DWORD *)(v5 - 12) = ((_WORD)v24 + 1) & 0x7FFF;
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 - 8) + 24LL), v25);
          v26 = *(_DWORD *)(v5 - 33144);
          *(_DWORD *)(v5 - 33144) = v26 - 1;
        }
        while ( v26 );
        goto LABEL_21;
      case 0xA:
        if ( v10 <= 15 )
          goto LABEL_14;
        v18 = *(_QWORD *)(v5 - 32792);
        v10 -= 16;
        *(_DWORD *)(v5 - 33176) = 11;
        *(_DWORD *)(v5 - 32784) = v10;
        *(_DWORD *)(v5 - 33136) = (unsigned __int16)v18;
        *(_QWORD *)(v5 - 32792) = v18 >> 16;
        continue;
      case 0xB:
        if ( v10 <= 15 )
          goto LABEL_14;
        v14 = *(_QWORD *)(v5 - 32792);
        v10 -= 16;
        *(_DWORD *)(v5 - 32784) = v10;
        *(_QWORD *)(v5 - 32792) = v14 >> 16;
        v15 = *(_DWORD *)(v5 - 33136);
        if ( v15 != (unsigned __int16)~(_WORD)v14 )
          goto LABEL_67;
        *(_DWORD *)(v5 - 33176) = v15 < 1 ? 1 : 12;
        if ( v7 <= 0 )
          goto LABEL_13;
        goto LABEL_4;
      case 0xC:
        v16 = *(_QWORD *)(v5 - 8);
        if ( v10 <= 7 )
          goto LABEL_15;
        v60 = *(_QWORD *)(v5 - 32792);
        v61 = *(_DWORD *)(v5 - 12);
        *(_BYTE *)(v5 + *(signed int *)(v5 - 12) - 32780) = v60;
        *(_DWORD *)(v5 - 12) = (v61 + 1) & 0x7FFF;
        sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v16 + 24), v60);
        v62 = *(_DWORD *)(v5 - 32784);
        *(_QWORD *)(v5 - 32792) >>= 8;
        v63 = (*(_DWORD *)(v5 - 33136))-- == 1;
        v10 = v62 - 8;
        *(_DWORD *)(v5 - 32784) = v62 - 8;
        if ( v63 )
LABEL_49:
          *(_DWORD *)(v5 - 33176) = 1;
        continue;
      default:
        goto LABEL_21;
    }
  }
}

_QWORD *sub_86340()
{
  _QWORD *v0; // rbx
  _DWORD *v1; // rax
  _DWORD *v2; // rdx
  char *v3; // rdx
  _DWORD *v4; // rax

  v0 = sub_2F450(1uLL, 0x28uLL, 0LL);
  v1 = sub_2F450(1uLL, (unsigned __int64)&off_38FFC, 0LL);
  if ( v1 )
  {
    *v0 = v1;
    v2 = v1;
    do
    {
      *((_WORD *)v2 + 2) = -1;
      *((_WORD *)v2 + 1) = -1;
      v2 = (_DWORD *)((char *)v2 + 6);
      *((_WORD *)v2 - 3) = -1;
    }
    while ( v2 != (_DWORD *)((char *)&loc_30000 + (_QWORD)v1) );
    v3 = (char *)word_38004 + (_QWORD)v1;
    do
    {
      v3 += 2;
      *((_WORD *)v3 - 1) = -1;
    }
    while ( (char *)v1 + 233458 != v3 );
    v1[57344] = 0;
    v1[58366] = 0;
  }
  v0[4] = off_3218A0;
  v0[2] = sub_86860;
  v0[3] = sub_86650;
  v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
  *(_QWORD *)v4 = 0LL;
  v4[4] = 0;
  *((_QWORD *)v4 + 1) = 0LL;
  *((_BYTE *)v4 + 20) = 1;
  v0[1] = v4;
  return v0 + 4;
}

char **sub_86440()
{
  char *v0; // rbx
  _QWORD *v1; // rax
  __m128i v2; // xmm0
  _QWORD *v3; // rax
  bool v4; // zf
  char **result; // rax
  __m128i v6; // [rsp+0h] [rbp-148h]
  __m128i v7; // [rsp+10h] [rbp-138h]
  __m128i v8; // [rsp+20h] [rbp-128h]
  __m128i v9; // [rsp+30h] [rbp-118h]
  __m128i v10; // [rsp+40h] [rbp-108h]
  __m128i v11; // [rsp+50h] [rbp-F8h]
  __m128i v12; // [rsp+60h] [rbp-E8h]
  __m128i v13; // [rsp+70h] [rbp-D8h]
  __m128i v14; // [rsp+80h] [rbp-C8h]
  __m128i v15; // [rsp+90h] [rbp-B8h]
  __m128i v16; // [rsp+A0h] [rbp-A8h]
  __m128i v17; // [rsp+B0h] [rbp-98h]
  __m128i v18; // [rsp+C0h] [rbp-88h]
  __m128i v19; // [rsp+D0h] [rbp-78h]
  __m128i v20; // [rsp+E0h] [rbp-68h]
  __m128i v21; // [rsp+F0h] [rbp-58h]
  __m128i v22; // [rsp+100h] [rbp-48h]
  __int64 v23; // [rsp+110h] [rbp-38h]
  __int64 v24; // [rsp+118h] [rbp-30h]
  unsigned __int64 v25; // [rsp+128h] [rbp-20h]

  v25 = __readfsqword(0x28u);
  v0 = (char *)sub_2F450(1uLL, 0x81C8uLL, 0LL);
  v13 = _mm_load_si128((const __m128i *)&xmmword_F3C00);
  v14 = v13;
  v12 = v13;
  v11 = v13;
  v10 = v13;
  v9 = v13;
  v8 = v13;
  v6 = v13;
  v7 = v13;
  v15 = _mm_load_si128((const __m128i *)&xmmword_F3C10);
  v17 = v15;
  v18 = v15;
  v19 = v15;
  v20 = v15;
  v21 = v15;
  v16 = v15;
  v22 = _mm_load_si128((const __m128i *)&xmmword_F3C20);
  v23 = 506381209866536711LL;
  v24 = 578721382704613384LL;
  v1 = sub_84F90((unsigned __int8 *)&v6, 288);
  v2 = _mm_load_si128((const __m128i *)&xmmword_F3C30);
  *(_QWORD *)v0 = v1;
  v6 = v2;
  v7 = v2;
  v3 = sub_84F90((unsigned __int8 *)&v6, 32);
  v4 = __readfsqword(0x28u) == v25;
  *((_QWORD *)v0 + 1) = v3;
  result = off_3218A0;
  *((_DWORD *)v0 + 10) = 0;
  *((_QWORD *)v0 + 4) = 0LL;
  *((_QWORD *)v0 + 3) = 0LL;
  *((_QWORD *)v0 + 2) = 0LL;
  *((_QWORD *)v0 + 53) = 0LL;
  *((_DWORD *)v0 + 108) = 0;
  *((_DWORD *)v0 + 8301) = 0;
  *((_QWORD *)v0 + 4151) = 0LL;
  *((_QWORD *)v0 + 4152) = off_3218A0;
  if ( v4 )
    result = (char **)(v0 + 33216);
  return result;
}

__int64 __fastcall sub_865D0(__int64 a1, __int64 a2, int a3)
{
  int v3; // ecx
  int v4; // edx
  __int64 v5; // rsi
  __int64 result; // rax
  bool v7; // sf

  v3 = *(_DWORD *)(a1 + 16);
  v4 = v3 + a3;
  if ( v4 > 32 )
    __assert_fail("out->noutbits + nbits <= 32", "sshzlib.c", 0x161u, "outbits");
  v5 = *(_QWORD *)(a1 + 8) | (a2 << v3);
  *(_DWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 8) = v5;
  if ( v4 > 7 )
  {
    do
    {
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)a1 + 24LL), v5);
      result = (unsigned int)(*(_DWORD *)(a1 + 16) - 8);
      v5 = *(_QWORD *)(a1 + 8) >> 8;
      v7 = *(_DWORD *)(a1 + 16) - 15 < 0;
      *(_QWORD *)(a1 + 8) = v5;
      *(_DWORD *)(a1 + 16) = result;
    }
    while ( !((unsigned __int8)(v7 ^ __OFSUB__((_DWORD)result, 7)) | ((_DWORD)result == 7)) );
  }
  return result;
}

__int64 __fastcall sub_86650(__int64 a1, int a2, signed int a3)
{
  __int64 result; // rax
  int v4; // er15
  signed int v5; // ebx
  int v6; // er8
  int v7; // ecx
  int v8; // esi
  __int64 v9; // r13
  signed __int16 *v10; // rdx
  int v11; // ebp
  int v12; // eax
  __int16 v13; // ax
  int v14; // ecx
  int v15; // esi
  signed __int16 *v16; // r13
  int v17; // ebp
  __int64 v18; // [rsp+0h] [rbp-48h]
  int v19; // [rsp+Ch] [rbp-3Ch]

  result = *(_QWORD *)(a1 + 8);
  v18 = *(_QWORD *)(a1 + 8);
  if ( a3 > 0 )
  {
    v4 = a2;
    v5 = a3;
    do
    {
      if ( v5 <= 260 )
      {
        if ( v5 <= 258 )
        {
          v6 = v5;
          v5 = 0;
        }
        else
        {
          v6 = v5 - 3;
          v5 = 3;
        }
      }
      else
      {
        v5 -= 258;
        v6 = 258;
      }
      v7 = 29;
      v8 = -1;
      do
      {
        while ( 1 )
        {
          if ( v7 - v8 <= 1 )
            __assert_fail("j - i >= 2", "sshzlib.c", 0x1FEu, "zlib_match");
          v9 = (v8 + v7) / 2;
          v10 = &off_F39A0[6 * v9];
          v11 = *((_DWORD *)v10 + 1);
          if ( v11 <= v6 )
            break;
          v7 = (v8 + v7) / 2;
        }
        v8 = (v8 + v7) / 2;
      }
      while ( *((_DWORD *)v10 + 2) < v6 );
      v12 = *v10;
      v19 = v6;
      if ( *v10 > 279 )
        sub_865D0(v18, byte_F3B00[v12 - 88], 8);
      else
        sub_865D0(v18, byte_F3B00[2 * v12 - 512], 7);
      v13 = off_F39A0[6 * v9 + 1];
      if ( v13 )
        sub_865D0(v18, v19 - v11, v13);
      v14 = 30;
      v15 = -1;
      do
      {
        while ( 1 )
        {
          if ( v14 - v15 <= 1 )
            __assert_fail("j - i >= 2", "sshzlib.c", 0x222u, "zlib_match");
          v16 = (signed __int16 *)((char *)&unk_F3820 + 12 * ((v15 + v14) / 2));
          v17 = *((_DWORD *)v16 + 1);
          if ( v17 <= v4 )
            break;
          v14 = (v15 + v14) / 2;
        }
        v15 = (v15 + v14) / 2;
      }
      while ( *((_DWORD *)v16 + 2) < v4 );
      sub_865D0(v18, byte_F3B00[8 * *v16], 5);
      result = (unsigned __int16)v16[1];
      if ( (_WORD)result )
        result = sub_865D0(v18, v4 - v17, (signed __int16)result);
    }
    while ( v5 );
  }
  return result;
}

__int64 __fastcall sub_86860(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // rdi
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 8);
  if ( a2 <= 0x8Fu )
    result = sub_865D0(v2, byte_F3B00[a2 + 48], 8);
  else
    result = sub_865D0(v2, 2LL * byte_F3B00[a2] + 1, 9);
  return result;
}

__int64 __fastcall sub_868B0(__int64 a1, unsigned __int8 *a2, unsigned int a3, __int64 *a4, _DWORD *a5, int a6)
{
  _BYTE *v6; // rbx
  unsigned int v7; // er15
  __int64 *v8; // r12
  _DWORD *v9; // r13
  unsigned __int64 v10; // rbp
  signed __int64 v11; // rax
  unsigned __int64 v12; // rcx
  signed __int64 v13; // r8
  signed __int64 v14; // r9
  bool v15; // zf
  __int64 *v16; // rdi
  unsigned __int64 i; // rax
  __int64 result; // rax

  v6 = *(_BYTE **)(a1 - 24);
  if ( *(_QWORD *)v6 )
    __assert_fail("!out->outbuf", "sshzlib.c", 0x269u, "zlib_compress_block");
  v7 = a3;
  v8 = a4;
  v9 = a5;
  v10 = a6;
  v11 = sub_BC650();
  v15 = v6[20] == 0;
  *(_QWORD *)v6 = v11;
  if ( !v15 )
  {
    sub_865D0((__int64)v6, 40056LL, 16);
    v6[20] = 0;
    sub_865D0((__int64)v6, 2LL, 3);
  }
  sub_850E0((signed __int64 *)(a1 - 32), a2, v7, v12, v13, v14);
  sub_865D0((__int64)v6, 0LL, 7);
  sub_865D0((__int64)v6, 2LL, 10);
  sub_865D0((__int64)v6, 2LL, 3);
  v16 = *(__int64 **)v6;
  for ( i = *(_QWORD *)(*(_QWORD *)v6 + 16LL); i < v10; i = *(_QWORD *)(*(_QWORD *)v6 + 16LL) )
  {
    sub_865D0((__int64)v6, 0LL, 7);
    sub_865D0((__int64)v6, 2LL, 3);
    v16 = *(__int64 **)v6;
  }
  *v9 = i;
  result = sub_BC6B0(v16);
  *v8 = result;
  *(_QWORD *)v6 = 0LL;
  return result;
}

unsigned __int64 __fastcall sub_869F0(__int64 a1, _DWORD *a2, size_t a3)
{
  const char *v3; // r12
  __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  __int64 v6; // r14
  __int64 v7; // rdi
  signed __int64 v8; // r13
  size_t v9; // r15
  size_t v10; // rdx
  __int64 v11; // r15
  size_t v12; // rax
  wint_t v13; // er15
  int v14; // eax
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  size_t v18; // rax
  unsigned __int64 v19; // rdx
  size_t v20; // rdx
  __int64 v21; // r13
  size_t v22; // rax
  unsigned __int64 v23; // r15
  wint_t v24; // er13
  int v25; // eax
  char *v26; // rax
  unsigned __int64 v27; // rdx
  signed __int64 v28; // rcx
  unsigned __int64 v29; // r14
  unsigned __int64 v30; // rcx
  const char *v31; // r12
  unsigned int v32; // eax
  unsigned int v33; // edx
  __int64 v34; // rcx
  __int64 v35; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v37; // rt1
  unsigned __int64 v38; // r15
  unsigned int v39; // ecx
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r13
  int v42; // eax
  unsigned int v43; // er15
  wchar_t v44; // ecx
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // rax
  wchar_t v47; // ST08_4
  unsigned __int64 v48; // ST20_8
  wchar_t *v49; // ST08_8
  char *v50; // ST18_8
  unsigned __int64 v51; // ST20_8
  wchar_t v52; // ST08_4
  int v53; // eax
  int v54; // eax
  char *v55; // ST18_8
  wchar_t v56; // ST08_4
  int v57; // [rsp+8h] [rbp-90h]
  wchar_t *v58; // [rsp+8h] [rbp-90h]
  wchar_t *v59; // [rsp+8h] [rbp-90h]
  int s; // [rsp+18h] [rbp-80h]
  unsigned __int64 v61; // [rsp+20h] [rbp-78h]
  const char *locale; // [rsp+28h] [rbp-70h]
  wint_t wc; // [rsp+38h] [rbp-60h]
  wint_t v64; // [rsp+3Ch] [rbp-5Ch]
  char v65; // [rsp+40h] [rbp-58h]
  unsigned __int64 v66; // [rsp+58h] [rbp-40h]

  v3 = (const char *)a2;
  v4 = a1;
  v5 = a3;
  v6 = a1 - 152;
  v66 = __readfsqword(0x28u);
  locale = setlocale(0, 0LL);
  setlocale(0, &::locale);
  v7 = *(_QWORD *)(a1 - 64);
  if ( !v7 )
    goto LABEL_20;
  v8 = v6 + 24;
  while ( 1 )
  {
    v9 = 64 - v7;
    if ( v5 <= 64 - v7 )
      v9 = v5;
    memcpy((void *)(v8 + v7), a2, v9);
    v10 = v9 + *(_QWORD *)(v4 - 64);
    v11 = *(_QWORD *)(v4 - 152);
    v12 = mbrtowc((wchar_t *)&wc, (const char *)(v6 + 24), v10, (mbstate_t *)(v4 - 152));
    if ( v12 == -2LL )
      break;
    if ( v12 == -1LL )
    {
      *(_QWORD *)v6 = 0LL;
      v19 = *(_QWORD *)(v4 - 64);
      v15 = 1LL;
      if ( v19 <= 1 )
        goto LABEL_52;
      goto LABEL_19;
    }
    if ( v12 )
    {
      v13 = wc;
      v61 = v12;
      v57 = sub_BD8A0(wc);
      v14 = iswprint(v13);
      v15 = v61;
      if ( v57 >= 0 && v14 )
      {
LABEL_10:
        v16 = v57;
        goto LABEL_11;
      }
      if ( v13 == 10 || v13 == 13 && *(_BYTE *)(v4 - 136) )
      {
        v16 = 0LL;
        if ( v57 >= 0 )
          goto LABEL_10;
LABEL_11:
        if ( *(_BYTE *)(v4 - 24) )
        {
          if ( *(_BYTE *)(v4 - 23) )
          {
            v48 = v16;
            v49 = (wchar_t *)v15;
            sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
            *(_BYTE *)(v4 - 23) = 0;
            *(_QWORD *)(v4 - 16) = 77LL;
            v16 = v48;
            v15 = (unsigned __int64)v49;
            if ( v13 == 10 )
              goto LABEL_104;
LABEL_14:
            v17 = *(_QWORD *)(v4 - 16);
            if ( v17 < v16 )
            {
              v51 = v16;
              v59 = (wchar_t *)v15;
              sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
              v16 = v51;
              *(_QWORD *)(v4 - 16) = 77LL;
              if ( v51 > 0x4D )
                goto LABEL_121;
              v17 = 77LL;
              v15 = (unsigned __int64)v59;
            }
            *(_QWORD *)(v4 - 16) = v17 - v16;
          }
          else
          {
            if ( v13 != 10 )
              goto LABEL_14;
LABEL_104:
            *(_BYTE *)(v4 - 23) = 1;
          }
        }
        v58 = (wchar_t *)v15;
        v18 = wcrtomb(&v65, v13, (mbstate_t *)(v6 + 8));
        v15 = (unsigned __int64)v58;
        if ( v18 )
        {
          sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
          v15 = (unsigned __int64)v58;
        }
      }
      else
      {
        v13 = *(_DWORD *)(v4 - 132);
        if ( v13 )
        {
          LODWORD(v16) = sub_BD8A0(v13);
          if ( (v16 & 0x80000000) != 0LL )
            goto LABEL_110;
          v16 = (signed int)v16;
          v15 = v61;
          goto LABEL_11;
        }
      }
      v19 = *(_QWORD *)(v4 - 64);
      if ( v15 >= v19 )
        goto LABEL_52;
      goto LABEL_19;
    }
    v38 = (signed int)sub_BD8A0(0);
    if ( iswprint(0) && (v38 & 0x80000000) == 0LL )
    {
      v44 = 0;
    }
    else
    {
      v39 = *(_DWORD *)(v4 - 132);
      if ( !v39 )
        goto LABEL_51;
      v52 = *(_DWORD *)(v4 - 132);
      v53 = sub_BD8A0(v39);
      v38 = v53;
      v44 = v52;
      if ( v53 < 0 )
LABEL_110:
        sub_1AF45();
    }
    if ( *(_BYTE *)(v4 - 24) )
    {
      if ( *(_BYTE *)(v4 - 23) )
      {
        v47 = v44;
        sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
        v44 = v47;
        *(_BYTE *)(v4 - 23) = 0;
        *(_QWORD *)(v4 - 16) = 77LL;
        if ( v47 != 10 )
        {
LABEL_82:
          v45 = *(_QWORD *)(v4 - 16);
          if ( v38 > v45 )
          {
            v56 = v44;
            sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
            *(_QWORD *)(v4 - 16) = 77LL;
            v44 = v56;
            if ( v38 > 0x4D )
              goto LABEL_121;
            v45 = 77LL;
          }
          *(_QWORD *)(v4 - 16) = v45 - v38;
          goto LABEL_84;
        }
      }
      else if ( v44 != 10 )
      {
        goto LABEL_82;
      }
      *(_BYTE *)(v4 - 23) = 1;
    }
LABEL_84:
    if ( !wcrtomb(&v65, v44, (mbstate_t *)(v6 + 8)) )
    {
LABEL_51:
      v19 = *(_QWORD *)(v4 - 64);
      v15 = 1LL;
      if ( v19 <= 1 )
        goto LABEL_52;
      goto LABEL_19;
    }
    sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
    v19 = *(_QWORD *)(v4 - 64);
    v15 = 1LL;
    if ( v19 <= 1 )
    {
LABEL_52:
      v40 = v15 - v19;
      if ( v5 < v40 )
        __assert_fail("consumed_from_main_string <= len", "stripctrl.c", 0x14Du, "stripctrl_locale_BinarySink_write");
      v3 = (char *)a2 + v40;
      v5 -= v40;
      goto LABEL_54;
    }
LABEL_19:
    v20 = v19 - v15;
    *(_QWORD *)(v4 - 64) = v20;
    memmove((void *)(v6 + 24), (const void *)(v8 + v15), v20);
    v7 = *(_QWORD *)(v4 - 64);
    if ( !v7 )
      goto LABEL_20;
  }
  v35 = *(_QWORD *)(v4 - 64);
  *(_QWORD *)(v4 - 152) = v11;
  if ( v35 )
  {
    if ( v5 > 64 - v7 )
      __assert_fail("to_copy == len", "stripctrl.c", 0x15Fu, "stripctrl_locale_BinarySink_write");
    *(_QWORD *)(v4 - 64) = v35 + v5;
    goto LABEL_44;
  }
LABEL_54:
  *(_QWORD *)(v4 - 64) = 0LL;
LABEL_20:
  if ( !v5 )
    goto LABEL_36;
  while ( 2 )
  {
    v21 = *(_QWORD *)(v4 - 152);
    v22 = mbrtowc((wchar_t *)&v64, v3, v5, (mbstate_t *)(v4 - 152));
    v23 = v22;
    if ( v22 != -2LL )
    {
      if ( v22 == -1LL )
      {
        *(_QWORD *)v6 = 0LL;
        v23 = 1LL;
        goto LABEL_34;
      }
      if ( v22 )
      {
        v24 = v64;
        s = sub_BD8A0(v64);
        v25 = iswprint(v24);
        if ( s >= 0 && v25 )
        {
LABEL_26:
          v26 = (char *)s;
          goto LABEL_27;
        }
        if ( v24 == 10 || v24 == 13 && *(_BYTE *)(v4 - 136) )
        {
          v26 = 0LL;
          if ( s >= 0 )
            goto LABEL_26;
LABEL_27:
          if ( *(_BYTE *)(v4 - 24) )
          {
            if ( *(_BYTE *)(v4 - 23) )
            {
              v50 = v26;
              sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
              *(_BYTE *)(v4 - 23) = 0;
              *(_QWORD *)(v4 - 16) = 77LL;
              v26 = v50;
              if ( v24 == 10 )
                goto LABEL_106;
LABEL_30:
              v27 = *(_QWORD *)(v4 - 16);
              if ( (unsigned __int64)v26 > v27 )
              {
                v55 = v26;
                sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
                v26 = v55;
                *(_QWORD *)(v4 - 16) = 77LL;
                if ( (unsigned __int64)v55 > 0x4D )
                  goto LABEL_121;
                v27 = 77LL;
              }
              *(_QWORD *)(v4 - 16) = v27 - (_QWORD)v26;
            }
            else
            {
              if ( v24 != 10 )
                goto LABEL_30;
LABEL_106:
              *(_BYTE *)(v4 - 23) = 1;
            }
          }
          if ( wcrtomb(&v65, v24, (mbstate_t *)(v6 + 8)) )
            sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
        }
        else
        {
          v24 = *(_DWORD *)(v4 - 132);
          if ( v24 )
          {
            LODWORD(v26) = sub_BD8A0(v24);
            if ( (signed int)v26 < 0 )
              goto LABEL_110;
            v26 = (char *)(signed int)v26;
            goto LABEL_27;
          }
        }
LABEL_34:
        if ( v23 > v5 )
          __assert_fail("consumed <= len", "stripctrl.c", 0x17Bu, "stripctrl_locale_BinarySink_write");
        v3 += v23;
        v5 -= v23;
        if ( !v5 )
          goto LABEL_36;
        continue;
      }
      v41 = (signed int)sub_BD8A0(0);
      v42 = iswprint(0);
      if ( (v41 & 0x80000000) == 0LL && v42 )
      {
        v43 = 0;
      }
      else
      {
        v43 = *(_DWORD *)(v4 - 132);
        if ( !v43 )
          goto LABEL_58;
        v54 = sub_BD8A0(v43);
        v41 = v54;
        if ( v54 < 0 )
          goto LABEL_110;
      }
      if ( *(_BYTE *)(v4 - 24) )
      {
        if ( *(_BYTE *)(v4 - 23) )
        {
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
          *(_BYTE *)(v4 - 23) = 0;
          *(_QWORD *)(v4 - 16) = 77LL;
          if ( v43 == 10 )
            goto LABEL_102;
LABEL_91:
          v46 = *(_QWORD *)(v4 - 16);
          if ( v41 > v46 )
          {
            sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
            *(_QWORD *)(v4 - 16) = 77LL;
            if ( v41 > 0x4D )
              goto LABEL_121;
            v46 = 77LL;
          }
          *(_QWORD *)(v4 - 16) = v46 - v41;
        }
        else
        {
          if ( v43 != 10 )
            goto LABEL_91;
LABEL_102:
          *(_BYTE *)(v4 - 23) = 1;
        }
      }
      if ( wcrtomb(&v65, v43, (mbstate_t *)(v6 + 8)) )
      {
        v23 = 1LL;
        sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v4 - 8) + 8LL));
        goto LABEL_34;
      }
LABEL_58:
      v23 = 1LL;
      goto LABEL_34;
    }
    break;
  }
  *(_QWORD *)(v4 - 152) = v21;
  if ( v5 > 0x40 )
    __assert_fail("len <= SCC_BUFSIZE", "stripctrl.c", 0x184u, "stripctrl_locale_BinarySink_write");
LABEL_36:
  v28 = v6 + 24;
  if ( (unsigned int)v5 < 8 )
  {
    if ( v5 & 4 )
    {
      *(_DWORD *)(v4 - 128) = *(_DWORD *)v3;
      *(_DWORD *)(v28 + (unsigned int)v5 - 4) = *(_DWORD *)&v3[(unsigned int)v5 - 4];
    }
    else if ( (_DWORD)v5 )
    {
      *(_BYTE *)(v4 - 128) = *v3;
      if ( v5 & 2 )
        *(_WORD *)(v28 + (unsigned int)v5 - 2) = *(_WORD *)&v3[(unsigned int)v5 - 2];
    }
  }
  else
  {
    v29 = (v6 + 32) & 0xFFFFFFFFFFFFFFF8LL;
    *(_QWORD *)(v4 - 128) = *(_QWORD *)v3;
    *(_QWORD *)(v28 + (unsigned int)v5 - 8) = *(_QWORD *)&v3[(unsigned int)v5 - 8];
    v30 = v28 - v29;
    v31 = &v3[-v30];
    if ( (((_DWORD)v5 + (_DWORD)v30) & 0xFFFFFFF8) >= 8 )
    {
      v32 = (v5 + v30) & 0xFFFFFFF8;
      v33 = 0;
      do
      {
        v34 = v33;
        v33 += 8;
        *(_QWORD *)(v29 + v34) = *(_QWORD *)&v31[v34];
      }
      while ( v33 < v32 );
    }
  }
  *(_QWORD *)(v4 - 64) = v5;
LABEL_44:
  setlocale(0, locale);
  v37 = __readfsqword(0x28u);
  result = v37 ^ v66;
  if ( v37 != v66 )
LABEL_121:
    sub_1AF22();
  return result;
}

unsigned __int64 __fastcall sub_87340(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // r14
  unsigned __int8 *v4; // rbx
  __int64 v5; // rdi
  char v6; // al
  __int64 i; // rax
  int v8; // eax
  unsigned __int64 v9; // r12
  char v10; // al
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // rbp
  __int64 v13; // rax
  unsigned int v14; // edi
  signed int v15; // er13
  bool v16; // r12
  signed int v17; // edi
  unsigned __int64 result; // rax
  unsigned __int64 v19; // rt1
  signed __int64 v20; // r9
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  int v23; // eax
  unsigned __int64 v24; // r12
  signed int v25; // er8
  unsigned __int64 v26; // r15
  signed __int64 v27; // r13
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // r12
  __int64 v31; // rax
  signed __int64 v32; // ST18_8
  signed int v33; // er8
  __int64 v34; // rdi
  int v35; // eax
  char v36; // al
  signed int v37; // ST18_4
  signed __int64 v38; // [rsp+8h] [rbp-60h]
  unsigned __int8 *v39; // [rsp+10h] [rbp-58h]
  signed int v40; // [rsp+18h] [rbp-50h]
  signed __int64 v41; // [rsp+18h] [rbp-50h]
  char v42; // [rsp+22h] [rbp-46h]
  unsigned __int64 v43; // [rsp+28h] [rbp-40h]

  v3 = a1;
  v4 = a2;
  v5 = *(_QWORD *)(a1 - 56);
  v43 = __readfsqword(0x28u);
  v6 = *(_BYTE *)(v5 + 305);
  if ( !v6 )
    v6 = *(_DWORD *)(*(_QWORD *)(v5 + 4352) + 16LL) == 55;
  if ( *(_BYTE *)(v3 - 48) != v6 )
  {
    *(_BYTE *)(v3 - 48) = v6;
    *(_DWORD *)(v3 - 44) = 0;
  }
  if ( a3 )
  {
    v38 = v3 - 44;
    v39 = &a2[a3];
    for ( i = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v3 - 32))(v5, v3 - 44, *a2);
          ;
          i = (*(__int64 (__fastcall **)(_QWORD, signed __int64, _QWORD))(v3 - 32))(*(_QWORD *)(v3 - 56), v38, *v4) )
    {
      v12 = i;
      if ( i != 2147483681LL )
        goto LABEL_21;
      if ( *(_BYTE *)(*(_QWORD *)(v3 - 56) + 4528LL) )
      {
        v23 = sub_BD9A0(0xFFFDu);
        if ( v23 >= 0 )
          goto LABEL_55;
      }
      else
      {
        v23 = sub_BD8A0(0xFFFDu);
        if ( v23 >= 0 )
        {
LABEL_55:
          if ( !*(_BYTE *)(v3 - 24) )
          {
            v31 = *(_QWORD *)(v3 - 56);
            v26 = 65533LL;
            if ( *(_BYTE *)(v31 + 305) )
              goto LABEL_65;
            goto LABEL_81;
          }
          v24 = v23;
          v25 = 65533;
          v26 = 65533LL;
LABEL_57:
          v27 = 0LL;
          if ( *(_BYTE *)(v3 - 23) )
            goto LABEL_96;
          goto LABEL_58;
        }
      }
      v33 = *(_DWORD *)(v3 - 132);
      v34 = *(_QWORD *)(v3 - 56);
      if ( v33 )
      {
        v26 = v33;
        v40 = *(_DWORD *)(v3 - 132);
        if ( *(_BYTE *)(v34 + 4528) )
          v35 = sub_BD9A0(v33);
        else
          v35 = sub_BD8A0(v33);
        v25 = v40;
        if ( v35 < 0 )
LABEL_32:
          sub_1AF68();
        v24 = v35;
        v36 = *(_BYTE *)(v3 - 24);
        if ( v26 != 10 )
        {
          if ( !v36 )
          {
            if ( v26 - 55296 < 0x800 )
              v26 = (unsigned __int8)v26;
LABEL_64:
            v31 = *(_QWORD *)(v3 - 56);
            if ( *(_BYTE *)(v31 + 305) )
            {
LABEL_65:
              if ( !sub_BD410(&v42, v26) )
                goto LABEL_84;
              goto LABEL_83;
            }
LABEL_81:
            if ( *(_DWORD *)(*(_QWORD *)(v31 + 4352) + 16LL) == 55 )
              goto LABEL_65;
            v42 = v26;
LABEL_83:
            sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
LABEL_84:
            v34 = *(_QWORD *)(v3 - 56);
            goto LABEL_85;
          }
          goto LABEL_57;
        }
        if ( v36 )
        {
          if ( !*(_BYTE *)(v3 - 23) )
          {
            *(_BYTE *)(v3 - 23) = 1;
            goto LABEL_89;
          }
          v27 = 1LL;
          v25 = 10;
LABEL_96:
          v37 = v25;
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
          *(_BYTE *)(v3 - 23) = 0;
          *(_QWORD *)(v3 - 16) = 77LL;
          v25 = v37;
LABEL_58:
          if ( v25 == 10 )
          {
            v30 = v26 - 55296;
            *(_BYTE *)(v3 - 23) = 1;
          }
          else
          {
            v28 = *(_QWORD *)(v3 - 16);
            if ( v28 < v24 )
            {
              sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
              *(_QWORD *)(v3 - 16) = 77LL;
              if ( v24 > 0x4D )
                goto LABEL_102;
              v28 = 77LL;
            }
            v29 = v28 - v24;
            v30 = v26 - 55296;
            *(_QWORD *)(v3 - 16) = v29;
          }
          if ( !v27 )
          {
            if ( v30 < 0x800 )
              v26 = (unsigned __int8)v26;
            goto LABEL_64;
          }
        }
        else
        {
LABEL_89:
          v30 = -55286LL;
        }
        sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
        if ( v30 < 0x800 )
          v26 = (unsigned __int8)v26;
        goto LABEL_64;
      }
LABEL_85:
      v12 = (*(__int64 (__fastcall **)(__int64, signed __int64, _QWORD))(v3 - 32))(v34, v38, *v4);
LABEL_21:
      if ( v12 == 2147483711 )
        goto LABEL_18;
      if ( v12 == 2147483690 )
      {
        v15 = 65533;
        v14 = 65533;
        v16 = 0;
        v12 = 65533LL;
      }
      else
      {
        v14 = v12;
        v15 = v12;
        v16 = (v12 & 0xFFFFFFFFFFFFFF60LL) == 0;
      }
      if ( *(_BYTE *)(*(_QWORD *)(v3 - 56) + 4528LL) )
      {
        v8 = sub_BD9A0(v14);
        if ( v8 < 0 )
          goto LABEL_26;
      }
      else
      {
        v8 = sub_BD8A0(v14);
        if ( v8 < 0 )
          goto LABEL_26;
      }
      if ( !v16 )
      {
        v9 = v8;
        v10 = *(_BYTE *)(v3 - 24);
        goto LABEL_10;
      }
LABEL_26:
      if ( v15 == 10 || v15 == 13 && *(_BYTE *)(v3 - 136) )
      {
        if ( v8 < 0 )
          v8 = 0;
      }
      else
      {
        v17 = *(_DWORD *)(v3 - 132);
        if ( !v17 )
          goto LABEL_18;
        v12 = v17;
        if ( *(_BYTE *)(*(_QWORD *)(v3 - 56) + 4528LL) )
          v8 = sub_BD9A0(v17);
        else
          v8 = sub_BD8A0(v17);
        if ( v8 < 0 )
          goto LABEL_32;
      }
      v9 = v8;
      v15 = v12;
      v10 = *(_BYTE *)(v3 - 24);
      if ( v12 == 10 )
      {
        if ( !v10 )
          goto LABEL_45;
        if ( !*(_BYTE *)(v3 - 23) )
        {
          *(_BYTE *)(v3 - 23) = 1;
LABEL_45:
          v11 = -55286LL;
LABEL_46:
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
          goto LABEL_12;
        }
        v20 = 1LL;
        v15 = 10;
LABEL_68:
        v32 = v20;
        sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
        *(_BYTE *)(v3 - 23) = 0;
        *(_QWORD *)(v3 - 16) = 77LL;
        v20 = v32;
        goto LABEL_48;
      }
LABEL_10:
      if ( !v10 )
      {
        v11 = v12 - 55296;
        goto LABEL_12;
      }
      v20 = 0LL;
      if ( *(_BYTE *)(v3 - 23) )
        goto LABEL_68;
LABEL_48:
      if ( v15 == 10 )
      {
        v11 = v12 - 55296;
        *(_BYTE *)(v3 - 23) = 1;
      }
      else
      {
        v21 = *(_QWORD *)(v3 - 16);
        if ( v9 > v21 )
        {
          v41 = v20;
          sub_2EC30(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
          *(_QWORD *)(v3 - 16) = 77LL;
          if ( v9 > 0x4D )
            goto LABEL_102;
          v21 = 77LL;
          v20 = v41;
        }
        v22 = v21 - v9;
        v11 = v12 - 55296;
        *(_QWORD *)(v3 - 16) = v22;
      }
      if ( v20 )
        goto LABEL_46;
LABEL_12:
      if ( v11 < 0x800 )
        v12 = (unsigned __int8)v12;
      v13 = *(_QWORD *)(v3 - 56);
      if ( !*(_BYTE *)(v13 + 305) && *(_DWORD *)(*(_QWORD *)(v13 + 4352) + 16LL) != 55 )
      {
        v42 = v12;
LABEL_17:
        sub_2EC20(*(__int64 (***)(void))(*(_QWORD *)(v3 - 8) + 8LL));
LABEL_18:
        if ( ++v4 == v39 )
          break;
        continue;
      }
      if ( sub_BD410(&v42, v12) )
        goto LABEL_17;
      if ( ++v4 == v39 )
        break;
    }
  }
  v19 = __readfsqword(0x28u);
  result = v19 ^ v43;
  if ( v19 != v43 )
LABEL_102:
    sub_1AF22();
  return result;
}

void __fastcall sub_87AA0(__int64 a1)
{
  *(_QWORD *)(a1 - 44) = 0LL;
  *(_DWORD *)(a1 - 36) = 0;
  *(_QWORD *)(a1 - 152) = 0LL;
  *(_QWORD *)(a1 - 144) = 0LL;
  *(_BYTE *)(a1 - 23) = 1;
}

void __fastcall sub_87AD0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 8) = a2;
  sub_87AA0(a1);
}

void __fastcall sub_87AE0(__int64 a1)
{
  sub_BD070((void *)(a1 - 152), 0xA8uLL);
  sub_2F4D0((void *)(a1 - 152));
}

void __fastcall sub_87B00(__int64 a1)
{
  *(_BYTE *)(a1 - 24) = 1;
  *(_BYTE *)(a1 - 23) = 1;
}

void __fastcall sub_87B70(__int64 a1, int a2)
{
  *(_DWORD *)(a1 - 48) = a2;
}

void nullsub_33()
{
  ;
}

__int64 __fastcall sub_87B90(__int64 a1)
{
  return *(signed int *)(a1 - 56);
}

void __fastcall sub_87BA0(__int64 a1, int a2, int a3)
{
  *(_DWORD *)(a1 - 104) = a2;
  *(_DWORD *)(a1 - 100) = a3;
}

void nullsub_34()
{
  ;
}

__int64 sub_87BC0()
{
  return 0LL;
}

bool __fastcall sub_87BD0(__int64 a1)
{
  return *(_QWORD *)(a1 - 136) != 0LL;
}

signed __int64 sub_87BE0()
{
  return 1LL;
}

__int64 __fastcall sub_87BF0(__int64 a1, unsigned __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 136) + 40LL))(*(_QWORD *)(a1 - 136), a2 > 0x1000);
}

__int64 sub_87C10()
{
  return 0LL;
}

signed __int64 __fastcall sub_87C20(__int64 a1)
{
  signed __int64 result; // rax

  result = 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 - 136) )
    result = *(_BYTE *)(a1 - 128) >= 1u ? 0x7FFFFFFF : 0;
  return result;
}

__int64 sub_87C40()
{
  return 0LL;
}

void __fastcall sub_87C50(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi
  void *v4; // rdi

  v1 = (void *)(a1 - 136);
  v2 = a1;
  v3 = *(_QWORD *)(a1 - 136);
  if ( v3 )
    (*(void (**)(void))(*(_QWORD *)v3 + 8LL))();
  v4 = *(void **)(v2 - 16);
  if ( v4 )
    sub_370D0(v4);
  sub_1ED50(*(_QWORD **)(v2 - 64));
  sub_2F4D0(v1);
}

char *__fastcall sub_87CA0(__int64 a1, __int64 *a2, _QWORD *a3, __int64 *a4, char *a5, char *a6, unsigned int a7, __int64 *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  _QWORD *v10; // r13
  char *v11; // rbp
  __int64 *v12; // ST30_8
  char *v13; // ST28_8
  signed int v14; // ebx
  __int64 **v15; // rax
  __int64 **v16; // r15
  __int64 *v17; // rax
  int v18; // eax
  __int64 *v19; // rdi
  int v20; // eax
  __int64 *v21; // rdi
  int v22; // eax
  unsigned int v23; // eax
  char *v24; // rdx
  unsigned int v25; // ST30_4
  char *v26; // ST28_8
  struct addrinfo **v27; // rbp
  __int64 *v28; // rax
  __int64 v29; // rdx
  char *v30; // rax
  char *result; // rax
  __int64 *v32; // rax
  __int64 *v33; // rdi
  char *v34; // rax
  int v35; // ebp
  char v36; // bl
  char v37; // al
  signed __int64 v38; // rdx
  signed int v39; // ebp
  int v40; // eax
  char v41; // cl
  signed int v42; // ebp
  char v43; // cl
  unsigned __int64 v44; // r12
  signed int v45; // ebp
  char v46; // cl
  unsigned __int64 v47; // r12
  signed int v48; // ebp
  char v49; // cl
  unsigned __int64 v50; // r12
  signed int v51; // ebp
  char v52; // cl
  signed int v53; // ebp
  char v54; // cl
  __int64 *v55; // rdi
  unsigned __int64 v56; // rax
  char *v57; // ST28_8
  char *v58; // rax
  _BYTE *v59; // rax
  char *src; // [rsp+8h] [rbp-60h]
  char v61; // [rsp+27h] [rbp-41h]
  unsigned __int64 v62; // [rsp+28h] [rbp-40h]

  v10 = a3;
  v11 = a6;
  v12 = a4;
  v13 = a5;
  v14 = a7;
  v62 = __readfsqword(0x28u);
  v15 = (__int64 **)sub_2F450(1uLL, 0x90uLL, 0LL);
  v16 = v15;
  v15[16] = (__int64 *)off_322100;
  v15[3] = v12;
  v15[17] = (__int64 *)&off_322140;
  v17 = sub_1EED0(v13);
  v16[2] = a2;
  v16[9] = v17;
  *v16 = 0LL;
  *((_BYTE *)v16 + 8) = 0;
  v18 = sub_1EFD0(v17, 123);
  v19 = v16[9];
  *((_DWORD *)v16 + 8) = v18;
  v20 = sub_1EFD0(v19, 124);
  v21 = v16[9];
  *((_DWORD *)v16 + 9) = v20;
  v16[15] = 0LL;
  *((_BYTE *)v16 + 64) = 0;
  *v10 = v16 + 17;
  v22 = sub_1EFD0(v21, 68);
  switch ( v22 )
  {
    case 1:
      v16[14] = (__int64 *)sub_88210;
      break;
    case 2:
      v16[14] = (__int64 *)sub_881D0;
      break;
    case 0:
      v16[14] = (__int64 *)sub_88250;
      break;
  }
  v23 = sub_1EFD0(v16[9], 3);
  if ( v23 == 1 )
  {
    v24 = " (IPv4)";
  }
  else
  {
    v24 = " (IPv6)";
    if ( v23 != 2 )
      v24 = &locale;
  }
  v25 = v23;
  v26 = sub_BC360((__int64)"Looking up host \"%s\"%s", v11, v24);
  sub_2D2C0((__int64)v16[3], v26, (__int64)&locale, (__int64)v16);
  sub_2F4D0(v26);
  v27 = (struct addrinfo **)sub_3A770(v11, a7, a8, v16[9], v25, 0LL, (__int64)&locale);
  src = (char *)sub_B72A0((__int64)v27);
  if ( src )
  {
    sub_B62D0(v27);
    result = sub_BC120(src);
  }
  else
  {
    if ( (a7 & 0x80000000) != 0 )
      v14 = 95;
    v28 = (__int64 *)sub_3A8A0(
                       (__int64)v27,
                       (const char *)*a8,
                       v14,
                       0,
                       1LL,
                       a9,
                       a10,
                       (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))v16 + 16,
                       v16[9]);
    v29 = *v28;
    *v16 = v28;
    v30 = (char *)(*(__int64 (__fastcall **)(__int64 *))(v29 + 48))(v28);
    if ( v30 )
    {
      result = sub_BC120(v30);
    }
    else
    {
      v32 = sub_37030(v16[9], (__int64)(v16 + 17));
      v33 = v16[2];
      v16[15] = v32;
      (*(void (__fastcall **)(__int64 *, __int64 **))(*v33 + 40))(v33, v16 + 17);
      v34 = (char *)sub_1F170(v16[9], 9);
      if ( *v34 )
      {
        v57 = v34;
        sub_2F4D0((void *)*a8);
        v58 = sub_BC120(v57);
        *a8 = (__int64)v58;
        v59 = sub_BC0D0(v58, 58);
        if ( v59 )
          *v59 = 0;
      }
      v35 = sub_1EFD0(v16[9], 68);
      v36 = sub_1EF00(v16[9], 69);
      v37 = sub_1EF00(v16[9], 70);
      v38 = 6246105128LL;
      if ( !v35 )
        v38 = 5440798760LL;
      v39 = 30;
      if ( v37 )
        v38 |= 0x1000000uLL;
      if ( v36 )
        v38 |= 0x2000000uLL;
      v40 = *((_DWORD *)v16 + 8);
      v16[5] = (__int64 *)v38;
      v16[7] = (__int64 *)(v40 - 1);
      v16[6] = (__int64 *)*((signed int *)v16 + 9);
      do
      {
        v41 = v39;
        v39 -= 6;
        v61 = (0xFFFEC0000uLL >> v41) & 0x3F;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v39 != -6 );
      v42 = 30;
      do
      {
        v43 = v42;
        v42 -= 6;
        v61 = 7uLL >> v43;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v42 != -6 );
      v44 = (unsigned __int64)v16[5];
      v45 = 30;
      do
      {
        v46 = v45;
        v45 -= 6;
        v61 = (v44 >> v46) & 0x3F;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v45 != -6 );
      v47 = (unsigned __int64)v16[6];
      v48 = 30;
      do
      {
        v49 = v48;
        v48 -= 6;
        v61 = (v47 >> v49) & 0x3F;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v48 != -6 );
      v50 = (unsigned __int64)v16[7];
      v51 = 30;
      do
      {
        v52 = v51;
        v51 -= 6;
        v61 = (v50 >> v52) & 0x3F;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v51 != -6 );
      v53 = 30;
      do
      {
        v54 = v53;
        v53 -= 6;
        v61 = 1uLL >> v54;
        (*(void (__fastcall **)(__int64 *, char *, signed __int64))(**v16 + 16))(*v16, &v61, 1LL);
      }
      while ( v53 != -6 );
      v55 = v16[2];
      *((_DWORD *)v16 + 21) = 0;
      (*(void (__fastcall **)(__int64 *, _QWORD))(*v55 + 136))(v55, 0LL);
      v56 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, const char *, signed __int64))*v16[2])(
              v16[2],
              0LL,
              "\x1B%G",
              3LL);
      (*(void (__fastcall **)(__int64 *, bool))(**v16 + 40))(*v16, v56 > 0x1000);
      result = 0LL;
    }
  }
  return result;
}

__int64 __fastcall sub_881D0(__int64 a1, int a2)
{
  strlen((&off_321D00)[a2]);
  return sub_2EC20((__int64 (**)(void))(a1 + 24));
}

__int64 __fastcall sub_88210(__int64 a1, int a2)
{
  strlen((const char *)*(&off_321900 + a2));
  return sub_2EC20((__int64 (**)(void))(a1 + 24));
}

__int64 __fastcall sub_88250(__int64 a1, int a2)
{
  __int64 result; // rax

  result = (unsigned int)(a2 - 32);
  if ( (unsigned int)result <= 0x5E )
    result = sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), a2);
  return result;
}

unsigned __int64 __usercall sub_88270@<rax>(__int64 a1@<rdi>, unsigned int a2@<esi>, __int64 a3@<rdx>, unsigned int a4@<ecx>, __int64 a5@<r8>, __int64 a6@<r9>, void (__fastcall ***a7)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 a8@<r15>)
{
  return sub_1B7C0(
           *(void (__fastcall ****)(_QWORD, signed __int64, const char *, __int64))(a1 - 112),
           *(_QWORD *)(a1 - 104),
           a2,
           a3,
           a4,
           a5,
           a7,
           a8,
           a6,
           *(_QWORD *)(a1 - 56),
           *(_DWORD *)(a1 - 44) != 0);
}

__int64 __fastcall sub_882B0(__int64 a1, char *a2, __int64 a3)
{
  __int64 v3; // r13
  __int64 v4; // rdi
  __int64 result; // rax
  char *v6; // rbx
  char *v7; // rbp
  char v8; // al
  __int64 (__fastcall *v9)(__int64, void *, signed __int64); // rcx
  char v10; // [rsp+7h] [rbp-31h]
  unsigned __int64 v11; // [rsp+8h] [rbp-30h]

  v3 = a1;
  v4 = *(_QWORD *)(a1 - 136);
  v11 = __readfsqword(0x28u);
  result = 0LL;
  if ( v4 )
  {
    if ( a3 )
    {
      v6 = a2;
      v7 = &a2[a3];
      while ( 1 )
      {
        v8 = *v6;
        v9 = *(__int64 (__fastcall **)(__int64, void *, signed __int64))(*(_QWORD *)v4 + 16LL);
        if ( *v6 == 28 )
        {
          ++v6;
          *(_DWORD *)(v3 - 56) = v9(v4, &unk_F3D9D, 2LL);
          if ( v7 == v6 )
            break;
        }
        else
        {
          ++v6;
          v10 = v8 & 0x7F;
          *(_DWORD *)(v3 - 56) = v9(v4, &v10, 1LL);
          if ( v7 == v6 )
            break;
        }
        v4 = *(_QWORD *)(v3 - 136);
      }
    }
    result = *(signed int *)(v3 - 56);
  }
  return result;
}

unsigned __int64 __fastcall sub_88370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // r13
  __int64 v6; // rbx
  __int64 v7; // r15
  __int64 v8; // rsi
  int v9; // eax
  __int64 v10; // rdx
  int v11; // eax
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  __int64 v14; // rcx
  unsigned __int64 v15; // rax
  __int64 *v17; // rdi
  const char *v18; // rbp
  size_t v19; // rax
  signed int v20; // eax
  __int64 v21; // rcx
  int v22; // eax
  bool v23; // zf
  __int64 v24; // rdi
  char v25; // al
  char v26; // dl
  __int64 v27; // rdi
  int v28; // edx
  __int64 v29; // rcx
  __int16 *v30; // [rsp+0h] [rbp-68h]
  int v31; // [rsp+1Ch] [rbp-4Ch]
  int v32; // [rsp+20h] [rbp-48h]
  __int16 v33; // [rsp+24h] [rbp-44h]
  char v34; // [rsp+26h] [rbp-42h]
  char v35; // [rsp+27h] [rbp-41h]
  unsigned __int64 v36; // [rsp+28h] [rbp-40h]

  v4 = a1;
  v5 = a3;
  v6 = a3 + a4;
  v36 = __readfsqword(0x28u);
  v7 = sub_BC640();
  v30 = &v33;
LABEL_2:
  while ( v5 != v6 )
  {
    v8 = *(unsigned __int8 *)(++v5 - 1);
    v9 = *(_DWORD *)(v4 - 44);
    v10 = *(unsigned __int8 *)(v5 - 1);
    if ( v9 )
    {
      if ( v9 == 1 )
      {
        v11 = *(_DWORD *)(v4 - 40);
        if ( v11 )
        {
          if ( v11 == 1 )
          {
            v20 = *(_DWORD *)(v4 - 24);
            if ( v20 > 3 )
              goto LABEL_28;
            v21 = v20;
            v22 = v20 + 1;
            *(_BYTE *)(v4 + v21 - 28) = v8;
            v23 = v22 == *(_DWORD *)(v4 - 32);
            *(_DWORD *)(v4 - 24) = v22;
            if ( v23 )
            {
              *(_DWORD *)(v4 - 40) = 2;
              LODWORD(v8) = *(_DWORD *)(v4 - 36);
              goto LABEL_21;
            }
          }
          else
          {
            if ( v11 != 2 )
              goto LABEL_8;
LABEL_20:
            LODWORD(v8) = *(_DWORD *)(v4 - 36);
LABEL_21:
            switch ( (_DWORD)v8 )
            {
              case 0x80:
                v28 = *(char *)(v4 - 26);
                v29 = (unsigned int)(*(char *)(v4 - 25) + 1);
                goto LABEL_32;
              case 0x81:
              case 0x8F:
                v28 = *(char *)(v4 - 28);
                v29 = (unsigned int)(*(char *)(v4 - 27) + 1);
LABEL_32:
                sub_BC720(v7, (__int64)"\x1B[%d;%dH", (unsigned int)(v28 + 1), v29, v30);
                break;
              case 0x82:
                sub_BC720(v7, (__int64)"\x1B[J", v10, v30);
                break;
              case 0x83:
                sub_BC720(v7, (__int64)"\x1B[K", v10, v30);
                break;
              case 0x84:
                sub_BC720(v7, (__int64)"\x1B[X", v10, v30);
                break;
              case 0x87:
                sub_BC720(v7, (__int64)"\r\n", v10, v30);
                break;
              case 0x89:
                sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 24), 8);
                break;
              case 0x8A:
                sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 24), 10);
                break;
              case 0x8B:
                sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 24), 13);
                break;
              case 0x8C:
                v24 = *(_QWORD *)(v4 - 112);
                *(_QWORD *)(v7 + 16) = 0LL;
                if ( (*(unsigned __int8 (__fastcall **)(__int64, int *, int *))(*(_QWORD *)v24 + 160LL))(
                       v24,
                       &v31,
                       &v32) )
                {
                  v26 = v32;
                  v25 = v31;
                }
                else
                {
                  v32 = 0;
                  v31 = 0;
                  v25 = 0;
                  v26 = 0;
                }
                v27 = *(_QWORD *)(v4 - 128);
                v34 = v26;
                v33 = 4124;
                v35 = v25;
                (*(void (__fastcall **)(__int64, __int16 *, signed __int64))(*(_QWORD *)v27 + 16LL))(v27, v30, 4LL);
                break;
              case 0x8D:
                sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 24), *(_BYTE *)(v4 - 28));
                break;
              case 0x8E:
                sub_BC720(v7, (__int64)"\x1B[C", v10, v30);
                break;
              case 0x90:
                sub_BC720(v7, (__int64)"\x1B[2J\x1B[H", v10, v30);
                break;
              case 0x91:
                sub_BC720(v7, (__int64)"\a", v10, v30);
                break;
              case 0x93:
                sub_BC720(v7, (__int64)"\x1B[%dL", (unsigned int)*(char *)(v4 - 28), v30);
                break;
              case 0x94:
                sub_BC720(v7, (__int64)"\x1B[%dM", (unsigned int)*(char *)(v4 - 28), v30);
                break;
              case 0x95:
                sub_BC720(v7, (__int64)"\x1B[%d@", (unsigned int)*(char *)(v4 - 28), v30);
                break;
              case 0x96:
                sub_BC720(v7, (__int64)"\x1B[%dP", (unsigned int)*(char *)(v4 - 28), v30);
                break;
              default:
                break;
            }
LABEL_28:
            *(_DWORD *)(v4 - 40) = 0;
          }
        }
        else
        {
          if ( (v8 & 0x80u) != 0LL )
          {
            *(_DWORD *)(v4 - 24) = 0;
            *(_DWORD *)(v4 - 36) = v8;
            v10 = (unsigned __int8)(v10 + -128);
            switch ( (_BYTE)v10 )
            {
              case 0:
                *(_DWORD *)(v4 - 32) = 4;
                *(_DWORD *)(v4 - 40) = 1;
                break;
              case 1:
              case 0xF:
                *(_DWORD *)(v4 - 32) = 2;
                *(_DWORD *)(v4 - 40) = 1;
                break;
              case 2:
              case 3:
              case 4:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
              case 0xE:
              case 0x10:
              case 0x11:
              case 0x17:
              case 0x18:
                *(_DWORD *)(v4 - 32) = 0;
                *(_DWORD *)(v4 - 40) = 2;
                goto LABEL_21;
              case 0xD:
              case 0x13:
              case 0x14:
              case 0x15:
              case 0x16:
                *(_DWORD *)(v4 - 32) = 1;
                *(_DWORD *)(v4 - 40) = 1;
                break;
              default:
                goto LABEL_8;
            }
            goto LABEL_8;
          }
          (*(void (__fastcall **)(__int64, __int64, __int64))(v4 - 16))(v7, v8, v10);
          if ( *(_DWORD *)(v4 - 40) == 2 )
            goto LABEL_20;
        }
LABEL_8:
        if ( !*(_BYTE *)(v4 - 64) )
        {
          v17 = *(__int64 **)(v4 - 56);
          v33 = -15680;
          v18 = (const char *)sub_1F170(v17, 67);
          (*(void (__fastcall **)(_QWORD, __int16 *, signed __int64))(**(_QWORD **)(v4 - 128) + 16LL))(
            *(_QWORD *)(v4 - 128),
            v30,
            2LL);
          v19 = strlen(v18);
          (*(void (__fastcall **)(_QWORD, const char *, size_t))(**(_QWORD **)(v4 - 128) + 16LL))(
            *(_QWORD *)(v4 - 128),
            v18,
            v19 + 1);
          *(_BYTE *)(v4 - 64) = 1;
        }
        goto LABEL_10;
      }
    }
    else if ( (_BYTE)v8 == -120 )
    {
      *(_DWORD *)(v4 - 44) = 1;
      *(_DWORD *)(v4 - 40) = 0;
    }
    else
    {
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v7 + 24), v8);
    }
LABEL_10:
    v12 = *(_QWORD *)(v7 + 16);
    if ( v12 <= 0xFFF )
      goto LABEL_2;
    v13 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, _QWORD, _QWORD))(v4 - 112))(
            *(_QWORD *)(v4 - 112),
            0LL,
            *(_QWORD *)(v7 + 8),
            (signed int)v12);
    (*(void (__fastcall **)(_QWORD, bool))(**(_QWORD **)(v4 - 128) + 40LL))(*(_QWORD *)(v4 - 128), v13 > 0x1000);
    *(_QWORD *)(v7 + 16) = 0LL;
  }
  v14 = *(_QWORD *)(v7 + 16);
  if ( v14 )
  {
    v15 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, _QWORD, _QWORD))(v4 - 112))(
            *(_QWORD *)(v4 - 112),
            0LL,
            *(_QWORD *)(v7 + 8),
            (signed int)v14);
    (*(void (__fastcall **)(_QWORD, bool))(**(_QWORD **)(v4 - 128) + 40LL))(*(_QWORD *)(v4 - 128), v15 > 0x1000);
  }
  sub_BC660((void **)v7);
  return __readfsqword(0x28u) ^ v36;
}

unsigned __int64 __usercall sub_88830@<rax>(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  unsigned __int64 result; // rax

  v4 = a1;
  v5 = *(_QWORD *)(a1 - 128);
  if ( v5 )
  {
    (*(void (**)(void))(*(_QWORD *)v5 + 8LL))();
    *(_QWORD *)(v4 - 128) = 0LL;
    if ( a2 )
      *(_BYTE *)(v4 - 120) = 1;
    result = (*(__int64 (**)(void))(**(_QWORD **)(v4 - 112) + 24LL))();
  }
  if ( a2 )
  {
    sub_2D2C0(*(_QWORD *)(v4 - 104), a2, a3, a4);
    result = sub_31A30(*(_QWORD *)(v4 - 112), (__int64)"%s", a2);
  }
  return result;
}

void nullsub_35()
{
  ;
}

char *__fastcall sub_888B0(int a1)
{
  char *result; // rax

  switch ( a1 )
  {
    case 0:
      result = "BINARY";
      break;
    case 1:
      result = "ECHO";
      break;
    case 2:
      result = "RCP";
      break;
    case 3:
      result = "SGA";
      break;
    case 4:
      result = "NAMS";
      break;
    case 5:
      result = "STATUS";
      break;
    case 6:
      result = "TM";
      break;
    case 7:
      result = "RCTE";
      break;
    case 8:
      result = "NAOL";
      break;
    case 9:
      result = "NAOP";
      break;
    case 10:
      result = "NAOCRD";
      break;
    case 11:
      result = "NAOHTS";
      break;
    case 12:
      result = "NAOHTD";
      break;
    case 13:
      result = "NAOFFD";
      break;
    case 14:
      result = "NAOVTS";
      break;
    case 15:
      result = "NAOVTD";
      break;
    case 16:
      result = "NAOLFD";
      break;
    case 17:
      result = (char *)&unk_F3F87;
      break;
    case 18:
      result = "LOGOUT";
      break;
    case 19:
      result = "BM";
      break;
    case 20:
      result = "DET";
      break;
    case 21:
      result = "SUPDUP";
      break;
    case 22:
      result = "SUPDUPOUTPUT";
      break;
    case 23:
      result = "SNDLOC";
      break;
    case 24:
      result = "TTYPE";
      break;
    case 25:
      result = "EOR";
      break;
    case 26:
      result = "TUID";
      break;
    case 27:
      result = "OUTMRK";
      break;
    case 28:
      result = "TTYLOC";
      break;
    case 29:
      result = "3270REGIME";
      break;
    case 30:
      result = "X3PAD";
      break;
    case 31:
      result = "NAWS";
      break;
    case 32:
      result = "TSPEED";
      break;
    case 33:
      result = "LFLOW";
      break;
    case 34:
      result = "LINEMODE";
      break;
    case 35:
      result = "XDISPLOC";
      break;
    case 36:
      result = "OLD_ENVIRON";
      break;
    case 37:
      result = "AUTHENTICATION";
      break;
    case 38:
      result = "ENCRYPT";
      break;
    case 39:
      result = "NEW_ENVIRON";
      break;
    case 40:
      result = "TN3270E";
      break;
    case 41:
      result = "XAUTH";
      break;
    case 42:
      result = "CHARSET";
      break;
    case 43:
      result = "RSP";
      break;
    case 44:
      result = "COM_PORT_OPTION";
      break;
    case 45:
      result = "SLE";
      break;
    case 46:
      result = "STARTTLS";
      break;
    case 47:
      result = "KERMIT";
      break;
    case 48:
      result = "SEND_URL";
      break;
    case 49:
      result = "FORWARD_X";
      break;
    case 138:
      result = "PRAGMA_LOGON";
      break;
    case 139:
      result = "SSPI_LOGON";
      break;
    case 140:
      result = "PRAGMA_HEARTBEAT";
      break;
    case 255:
      result = "EXOPL";
      break;
    default:
      result = "<unknown>";
      break;
  }
  return result;
}

void __fastcall sub_88C40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 48) = a2;
}

__int64 __fastcall sub_88C50(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rbp
  __int64 v5; // rdi
  _BYTE *v6; // r12
  _BYTE *v7; // rbx
  bool v8; // dl
  signed __int64 v9; // rdx
  void *__ptr32 *v10; // rsi
  signed __int64 i; // rdx

  result = 0LL;
  v4 = a1;
  v5 = *(_QWORD *)(a1 - 152);
  if ( v5 )
  {
    v6 = &a2[a3];
    if ( a2 >= &a2[a3] )
      return *(_QWORD *)(v4 - 56);
    if ( v6 <= a2 )
      goto LABEL_23;
LABEL_4:
    if ( *a2 == -1 )
    {
      v7 = a2;
    }
    else
    {
      v7 = a2;
      v8 = *(_DWORD *)(v4 - 72) == 1;
      if ( *a2 != 13 || v8 )
      {
        while ( v6 != ++v7 )
        {
          if ( *v7 == -1 || *v7 == 13 && !v8 )
          {
            v9 = v7 - a2;
            goto LABEL_12;
          }
        }
        for ( i = v6 - a2; ; i = 0LL )
        {
          *(_QWORD *)(v4 - 56) = (*(__int64 (__fastcall **)(__int64, _BYTE *, signed __int64))(*(_QWORD *)v5 + 16LL))(
                                   v5,
                                   a2,
                                   i);
LABEL_21:
          if ( v6 <= v7 )
            break;
          a2 = v7;
          v5 = *(_QWORD *)(v4 - 152);
          if ( v6 > v7 )
            goto LABEL_4;
LABEL_23:
          v7 = a2;
        }
        return *(_QWORD *)(v4 - 56);
      }
    }
    v9 = 0LL;
LABEL_12:
    *(_QWORD *)(v4 - 56) = (*(__int64 (__fastcall **)(__int64, _BYTE *, signed __int64))(*(_QWORD *)v5 + 16LL))(
                             v5,
                             a2,
                             v9);
    do
    {
      if ( *v7 == -1 )
      {
        v10 = &off_F46C6;
      }
      else
      {
        if ( *(_DWORD *)(v4 - 72) == 1 || *v7 != 13 )
          goto LABEL_21;
        v10 = (void *__ptr32 *)&unk_F46C4;
      }
      ++v7;
      result = (*(__int64 (__fastcall **)(_QWORD, void *__ptr32 *, signed __int64))(**(_QWORD **)(v4 - 152) + 16LL))(
                 *(_QWORD *)(v4 - 152),
                 v10,
                 2LL);
      *(_QWORD *)(v4 - 56) = result;
    }
    while ( v6 > v7 );
  }
  return result;
}

__int64 __fastcall sub_88D70(__int64 a1)
{
  return *(_QWORD *)(a1 - 56);
}

unsigned __int64 __fastcall sub_88D80(__int64 a1, int a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 (__fastcall *v5)(__int64, const char *, signed __int64); // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  char v8; // [rsp+6h] [rbp-22h]
  char v9; // [rsp+7h] [rbp-21h]
  unsigned __int64 v10; // [rsp+8h] [rbp-20h]

  v2 = a1;
  v3 = *(_QWORD *)(a1 - 152);
  v10 = __readfsqword(0x28u);
  if ( v3 )
  {
    v8 = -1;
    switch ( a2 )
    {
      case 0:
        v9 = -13;
        goto LABEL_5;
      case 1:
        v9 = -20;
        goto LABEL_5;
      case 2:
        goto LABEL_4;
      case 3:
        if ( *(_DWORD *)(v2 - 76) != 1 )
          return __readfsqword(0x28u) ^ v10;
LABEL_4:
        v9 = -15;
        goto LABEL_5;
      case 4:
        v9 = -10;
        goto LABEL_5;
      case 5:
        v9 = -14;
        v6 = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v3 + 16LL))(v3, &v8, 1LL);
        v7 = *(_QWORD *)(v2 - 152);
        *(_QWORD *)(v2 - 56) = v6;
        *(_QWORD *)(v2 - 56) = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v7 + 24LL))(
                                 v7,
                                 &v9,
                                 1LL);
        return __readfsqword(0x28u) ^ v10;
      case 6:
        v9 = -9;
        goto LABEL_5;
      case 7:
        v9 = -8;
        goto LABEL_5;
      case 8:
        v9 = -7;
        goto LABEL_5;
      case 9:
        v9 = -18;
        goto LABEL_5;
      case 10:
        v9 = -11;
        goto LABEL_5;
      case 11:
        v9 = -12;
        goto LABEL_5;
      case 12:
        v9 = -19;
        goto LABEL_5;
      case 13:
        v9 = -17;
LABEL_5:
        *(_QWORD *)(v2 - 56) = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v3 + 16LL))(
                                 v3,
                                 &v8,
                                 2LL);
        break;
      case 14:
        v5 = *(__int64 (__fastcall **)(__int64, const char *, signed __int64))(*(_QWORD *)v3 + 16LL);
        if ( *(_DWORD *)(v2 - 72) == 1 )
          *(_QWORD *)(v2 - 56) = v5(v3, "\r", 1LL);
        else
          *(_QWORD *)(v2 - 56) = v5(v3, "\r\n", 2LL);
        break;
      default:
        return __readfsqword(0x28u) ^ v10;
    }
  }
  return __readfsqword(0x28u) ^ v10;
}

char **sub_88F50()
{
  return &off_322200;
}

bool __fastcall sub_88F60(__int64 a1)
{
  return *(_QWORD *)(a1 - 152) != 0LL;
}

signed __int64 sub_88F70()
{
  return 1LL;
}

__int64 __fastcall sub_88F80(__int64 a1, unsigned __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, bool))(**(_QWORD **)(a1 - 152) + 40LL))(*(_QWORD *)(a1 - 152), a2 > 0x1000);
}

__int64 __fastcall sub_88FA0(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a2 == 1 )
    return *(unsigned __int8 *)(a1 - 64);
  result = 0LL;
  if ( !a2 )
    result = *(unsigned __int8 *)(a1 - 63);
  return result;
}

void __fastcall sub_88FC0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 120) = a2;
}

signed __int64 __fastcall sub_88FD0(__int64 a1)
{
  signed __int64 result; // rax

  result = 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 - 152) )
    result = *(_BYTE *)(a1 - 144) >= 1u ? 0x7FFFFFFF : 0;
  return result;
}

__int64 sub_89000()
{
  return 0LL;
}

unsigned __int64 __usercall sub_89010@<rax>(int a1@<edx>, __int64 a2@<rdi>, int a3@<esi>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  __int64 v5; // rbx
  __int64 v6; // rdi
  int v8; // ecx
  signed int v9; // er8
  signed __int64 v10; // rax
  int v11; // ecx
  int v12; // eax
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rdi
  __int16 v17; // [rsp+0h] [rbp-28h]
  char v18; // [rsp+2h] [rbp-26h]
  char v19; // [rsp+3h] [rbp-25h]
  char v20; // [rsp+4h] [rbp-24h]
  unsigned __int64 v21; // [rsp+18h] [rbp-10h]

  v5 = a2;
  *(_DWORD *)(a2 - 112) = a3;
  *(_DWORD *)(a2 - 108) = a1;
  v6 = *(_QWORD *)(a2 - 152);
  v21 = __readfsqword(0x28u);
  if ( v6 && *(_DWORD *)(v5 - 104) == 1 )
  {
    v18 = 31;
    v8 = a3 >> 8;
    v17 = -1281;
    v9 = 4;
    v19 = BYTE1(a3);
    v10 = 5LL;
    if ( BYTE1(a3) == -1 )
    {
      v20 = v8;
      v10 = 6LL;
      v9 = 5;
    }
    *((_BYTE *)&v17 + v9) = a3;
    if ( (_BYTE)a3 == -1 )
    {
      *((_BYTE *)&v17 + v10) = -1;
      LODWORD(v10) = v9 + 2;
    }
    v11 = v10 + 1;
    *((_BYTE *)&v17 + (signed int)v10) = BYTE1(a1);
    if ( BYTE1(a1) == -1 )
    {
      *((_BYTE *)&v17 + v11) = -1;
      v11 = v10 + 2;
    }
    v12 = v11 + 1;
    *((_BYTE *)&v17 + v11) = a1;
    if ( (_BYTE)a1 == -1 )
    {
      *((_BYTE *)&v17 + v12) = -1;
      v12 = v11 + 2;
    }
    *((_BYTE *)&v17 + v12) = -1;
    *((_BYTE *)&v17 + v12 + 1) = -16;
    v13 = (*(__int64 (__fastcall **)(__int64, __int16 *, _QWORD))(*(_QWORD *)v6 + 16LL))(v6, &v17, v12 + 2);
    v14 = *(unsigned int *)(v5 - 108);
    v15 = *(unsigned int *)(v5 - 112);
    v16 = *(_QWORD *)(v5 - 128);
    *(_QWORD *)(v5 - 56) = v13;
    sub_2D3F0(v16, (__int64)"client:\tSB NAWS %d,%d", a4, a5, *(_QWORD *)&v17);
  }
  return __readfsqword(0x28u) ^ v21;
}

_QWORD *__fastcall sub_89150(__int64 a1, __int64 *a2)
{
  _QWORD *result; // rax

  sub_37080(*(unsigned int **)(a1 - 16), *(__int64 **)(a1 - 24), a2);
  sub_1ED50(*(_QWORD **)(a1 - 24));
  result = sub_1EED0(a2);
  *(_QWORD *)(a1 - 24) = result;
  return result;
}

void __fastcall sub_89190(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi
  void *v4; // rdi

  v1 = (void *)(a1 - 152);
  v2 = a1;
  sub_BC660(*(void ***)(a1 - 40));
  v3 = *(_QWORD *)(a1 - 152);
  if ( v3 )
    (*(void (**)(void))(*(_QWORD *)v3 + 8LL))();
  v4 = *(void **)(v2 - 16);
  if ( v4 )
    sub_370D0(v4);
  sub_1ED50(*(_QWORD **)(v2 - 24));
  sub_2F4D0(v1);
}

unsigned __int64 __usercall sub_891E0@<rax>(__int64 a1@<rdi>, unsigned int a2@<esi>, __int64 a3@<rdx>, unsigned int a4@<ecx>, __int64 a5@<r8>, __int64 a6@<r9>, void (__fastcall ***a7)(_QWORD, signed __int64, const char *, __int64)@<r13>, __int64 a8@<r15>)
{
  return sub_1B7C0(
           *(void (__fastcall ****)(_QWORD, signed __int64, const char *, __int64))(a1 - 128),
           *(_QWORD *)(a1 - 120),
           a2,
           a3,
           a4,
           a5,
           a7,
           a8,
           a6,
           *(_QWORD *)(a1 - 16),
           *(_BYTE *)(a1 - 24));
}

unsigned __int64 __usercall sub_89220@<rax>(int a1@<ecx>, __int64 a2@<r13>, __int64 a3@<r15>)
{
  __int64 v3; // r10

  sub_888B0(a1);
  return sub_2D3F0(v3, (__int64)"%s:\t%s %s", a2, a3);
}

unsigned __int64 __usercall sub_892A0@<rax>(int a1@<edx>, _QWORD *a2@<rdi>, char a3@<sil>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  int v5; // er12
  _QWORD *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rdi
  char v11; // [rsp+5h] [rbp-23h]
  char v12; // [rsp+6h] [rbp-22h]
  char v13; // [rsp+7h] [rbp-21h]
  unsigned __int64 v14; // [rsp+8h] [rbp-20h]

  v5 = a1;
  v6 = a2;
  v7 = *a2;
  v14 = __readfsqword(0x28u);
  v12 = a3;
  v13 = a1;
  v11 = -1;
  v8 = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(*(_QWORD *)v7 + 16LL))(v7, &v11, 3LL);
  v9 = v6[3];
  v6[12] = v8;
  sub_89220(v5, a4, a5);
  return __readfsqword(0x28u) ^ v14;
}

char *__fastcall sub_89320(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, _QWORD *a5, char *a6, unsigned int a7, __int64 *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  _QWORD *v10; // r15
  char *v11; // ST20_8
  __int64 v12; // ST30_8
  _QWORD *v13; // ST28_8
  signed int v14; // ebp
  char *v15; // rbx
  _QWORD *v16; // rax
  signed __int64 v17; // rax
  __int64 *v18; // rdi
  int v19; // eax
  __int64 *v20; // rdi
  int v21; // eax
  __int64 *v22; // rdi
  unsigned int v23; // eax
  struct addrinfo **v24; // r14
  __int64 v25; // rsi
  __int64 *v26; // rax
  __int64 v27; // rdx
  char *v28; // rax
  _QWORD *v30; // rax
  __int64 *v31; // rdi
  signed __int64 v32; // rsi
  void **v33; // rcx
  __int64 v34; // rax
  void ***i; // rdx
  __int64 v36; // rdi
  char *v37; // rbx
  char *v38; // rax
  _BYTE *v39; // rax
  int v40; // ecx
  int **v41; // rbp
  int *j; // rax
  __int64 v43; // [rsp+0h] [rbp-58h]

  v10 = a3;
  v11 = a6;
  v12 = a4;
  v13 = a5;
  v14 = a7;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a2 + 136LL))(a2, 0LL);
  v15 = (char *)sub_2F450(1uLL, 0xA0uLL, 0LL);
  *((_QWORD *)v15 + 19) = a1;
  *((_QWORD *)v15 + 18) = off_3223C0;
  v16 = sub_1EED0(v13);
  *(_QWORD *)v15 = 0LL;
  *((_QWORD *)v15 + 16) = v16;
  v15[8] = 0;
  v15[88] = 1;
  v15[89] = 1;
  v15[90] = 0;
  v17 = sub_BC640();
  v18 = (__int64 *)*((_QWORD *)v15 + 16);
  *((_QWORD *)v15 + 2) = a2;
  *((_QWORD *)v15 + 14) = v17;
  *((_QWORD *)v15 + 3) = v12;
  v19 = sub_1EFD0(v18, 123);
  v20 = (__int64 *)*((_QWORD *)v15 + 16);
  *((_DWORD *)v15 + 10) = v19;
  v21 = sub_1EFD0(v20, 124);
  v22 = (__int64 *)*((_QWORD *)v15 + 16);
  *((_DWORD *)v15 + 11) = v21;
  *((_DWORD *)v15 + 31) = 0;
  *((_QWORD *)v15 + 4) = 0LL;
  *((_QWORD *)v15 + 17) = 0LL;
  v15[120] = 1;
  *v10 = v15 + 152;
  v23 = sub_1EFD0(v22, 3);
  v24 = (struct addrinfo **)sub_3A770(
                              v11,
                              a7,
                              a8,
                              *((__int64 **)v15 + 16),
                              v23,
                              *((_QWORD *)v15 + 3),
                              (__int64)"Telnet connection");
  v43 = sub_B72A0((__int64)v24);
  if ( v43 )
  {
    sub_B62D0(v24);
    v28 = (char *)v43;
    return sub_BC120(v28);
  }
  if ( (a7 & 0x80000000) != 0 )
    v14 = 23;
  v25 = *a8;
  v26 = (__int64 *)sub_3A8A0(
                     (__int64)v24,
                     (const char *)*a8,
                     v14,
                     0,
                     1LL,
                     a9,
                     a10,
                     (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))v15 + 18,
                     *((__int64 **)v15 + 16));
  v27 = *v26;
  *(_QWORD *)v15 = v26;
  v28 = (char *)(*(__int64 (__fastcall **)(__int64 *, __int64))(v27 + 48))(v26, v25);
  if ( v28 )
    return sub_BC120(v28);
  v30 = sub_37030(*((__int64 **)v15 + 16), (__int64)(v15 + 152));
  v31 = (__int64 *)*((_QWORD *)v15 + 16);
  *((_QWORD *)v15 + 17) = v30;
  v32 = 60LL;
  if ( (unsigned __int8)sub_1EF00(v31, 60) )
  {
    v33 = &off_F47D0;
    v34 = 0LL;
    for ( i = off_322400; ; v33 = i[1] )
    {
      ++i;
      *(_DWORD *)&v15[4 * v34 + 48] = 2;
      if ( !v33 )
        break;
      v34 = *((signed int *)v33 + 5);
    }
  }
  else
  {
    i = 0LL;
    v40 = 0;
    v41 = (int **)off_322400;
    for ( j = (int *)&off_F47F0; ; v40 = j[6] )
    {
      *(_DWORD *)&v15[4 * (_QWORD)i + 48] = v40;
      if ( !v40 )
      {
        v32 = (unsigned int)*j;
        sub_892A0(j[4], v15, v32, (__int64)a8, (__int64)v10);
      }
      ++v41;
      j = *v41;
      if ( !*v41 )
        break;
      i = (void ***)j[5];
    }
    v15[90] = 1;
  }
  v36 = *((_QWORD *)v15 + 2);
  v15[104] = 0;
  (*(void (__fastcall **)(__int64, signed __int64, void ***))(*(_QWORD *)v36 + 40LL))(v36, v32, i);
  v37 = (char *)sub_1F170(*((__int64 **)v15 + 16), 9);
  if ( *v37 )
  {
    sub_2F4D0((void *)*a8);
    v38 = sub_BC120(v37);
    *a8 = (__int64)v38;
    v39 = sub_BC0D0(v38, 58);
    if ( v39 )
      *v39 = 0;
  }
  return 0LL;
}

unsigned __int64 __usercall sub_89610@<rax>(char a1@<dl>, __int64 a2@<rdi>, _DWORD *a3@<rsi>, __int64 a4@<r13>, __int64 a5@<r15>)
{
  unsigned __int64 result; // rax
  __int64 v6; // rbx
  __int64 v7; // rdi

  result = (unsigned int)a3[4];
  v6 = a2;
  if ( (_DWORD)result == 1 )
  {
    if ( *a3 == 253 )
      *(_BYTE *)(a2 + 88) = a1 ^ 1;
  }
  else if ( (_DWORD)result == 3 && *a3 == 253 )
  {
    *(_BYTE *)(a2 + 89) = a1 ^ 1;
  }
  v7 = *(_QWORD *)(a2 + 32);
  if ( v7 )
    result = sub_2C080(v7);
  if ( !*(_BYTE *)(v6 + 90) )
  {
    if ( *(_DWORD *)(v6 + 68) == 2 )
    {
      *(_DWORD *)(v6 + 68) = 0;
      result = sub_892A0(1, (_QWORD *)v6, 253, a4, a5);
      if ( *(_DWORD *)(v6 + 72) != 2 )
      {
LABEL_8:
        if ( *(_DWORD *)(v6 + 76) != 2 )
        {
LABEL_9:
          *(_BYTE *)(v6 + 90) = 1;
          return result;
        }
        goto LABEL_17;
      }
    }
    else if ( *(_DWORD *)(v6 + 72) != 2 )
    {
      goto LABEL_8;
    }
    *(_DWORD *)(v6 + 72) = 0;
    result = sub_892A0(3, (_QWORD *)v6, 251, a4, a5);
    if ( *(_DWORD *)(v6 + 76) != 2 )
      goto LABEL_9;
LABEL_17:
    *(_DWORD *)(v6 + 76) = 0;
    result = sub_892A0(3, (_QWORD *)v6, 253, a4, a5);
    *(_BYTE *)(v6 + 90) = 1;
  }
  return result;
}

unsigned __int64 __usercall sub_896D0@<rax>(__int64 a1@<rdi>, _DWORD *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  int v5; // eax
  void **v6; // r12
  __int64 v7; // rcx

  if ( *a2 == 251 )
  {
    v5 = a2[4];
    if ( v5 == 31 )
    {
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 152) + 40LL))(
        a1 + 152,
        *(unsigned int *)(a1 + 40),
        *(unsigned int *)(a1 + 44));
      if ( *a2 != 251 )
        return sub_89610(1, a1, a2, a3, a4);
      v5 = a2[4];
    }
    if ( v5 == 39 || v5 == 36 )
    {
      v6 = &off_F4790;
      v7 = (v5 != 39) + 3;
      if ( v5 != 39 )
        v6 = &off_F4770;
      if ( *(_DWORD *)(a1 + 4LL * (signed int)v7 + 48) <= 1u )
      {
        sub_892A0(3 * (v5 != 39) + 36, (_QWORD *)a1, 252, a3, a4);
        v7 = *((signed int *)v6 + 5);
      }
      *(_DWORD *)(a1 + 4 * v7 + 48) = 3;
    }
  }
  return sub_89610(1, a1, a2, a3, a4);
}

signed __int64 __usercall sub_89790@<rax>(int a1@<edx>, __int64 a2@<rdi>, unsigned int a3@<esi>, __int64 a4@<r15>)
{
  __int64 v4; // r14
  __int64 v5; // rdi
  __int64 v6; // r13
  int v7; // er12
  void ***v8; // rbp
  void **v9; // rbx
  int i; // edx
  signed __int64 result; // rax
  int v12; // ecx
  int v13; // esi
  void **v14; // rsi
  int v15; // esi
  signed __int64 v16; // rcx
  bool v17; // zf
  void **v18; // rsi
  int v19; // esi

  v4 = a2;
  v5 = *(_QWORD *)(a2 + 24);
  v6 = a3;
  v7 = a1;
  v8 = off_322400;
  v9 = &off_F47F0;
  sub_89220(a1, a3, a4);
  for ( i = 31; ; i = *((_DWORD *)v9 + 4) )
  {
    if ( i == v7 )
    {
      if ( *((_DWORD *)v9 + 2) == a3 )
      {
        v16 = v4 + 4LL * *((signed int *)v9 + 5);
        result = *(unsigned int *)(v16 + 48);
        if ( (_DWORD)result == 2 )
        {
          v19 = *(_DWORD *)v9;
          *(_DWORD *)(v16 + 48) = 1;
          sub_892A0(i, (_QWORD *)v4, v19, v6, a4);
          v18 = *v8;
        }
        else
        {
          if ( (_DWORD)result == 3 )
          {
            v15 = *((_DWORD *)v9 + 1);
            return sub_892A0(i, (_QWORD *)v4, v15, v6, a4);
          }
          if ( (_DWORD)result )
            return result;
          *(_DWORD *)(v16 + 48) = 1;
          v18 = v9;
        }
        return sub_896D0(v4, v18, v6, a4);
      }
      if ( *((_DWORD *)v9 + 3) == a3 )
        break;
    }
    ++v8;
    v9 = *v8;
    if ( !*v8 )
    {
      result = (a3 - 251) & 0xFFFFFFFD;
      if ( (a3 - 251) & 0xFFFFFFFD )
        return result;
      i = v7;
      v15 = 2 * (a3 == 251) + 252;
      return sub_892A0(i, (_QWORD *)v4, v15, v6, a4);
    }
  }
  result = v4 + 4LL * *((signed int *)v9 + 5);
  v12 = *(_DWORD *)(result + 48);
  if ( v12 )
  {
    if ( v12 != 1 )
      return result;
    v13 = *((_DWORD *)v9 + 1);
    *(_DWORD *)(result + 48) = 2;
    sub_892A0(i, (_QWORD *)v4, v13, v6, a4);
    v14 = *v8;
  }
  else
  {
    v17 = *(_DWORD *)v9 == 251;
    *(_DWORD *)(result + 48) = 2;
    if ( v17 && i == 39 && *(_DWORD *)(v4 + 60) == 2 )
    {
      sub_892A0(36, (_QWORD *)v4, 251, a3, a4);
      *(_DWORD *)(v4 + 60) = 0;
    }
    v14 = v9;
  }
  return sub_89610(0, v4, v14, v6, a4);
}

__int64 __usercall sub_89910@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<rdi>, __int64 a4@<rsi>, char *a5@<r14>)
{
  __int64 v5; // r15
  __int64 v6; // r13
  __int64 v7; // r12
  signed __int64 v8; // rbx
  int v9; // edx
  int v10; // ecx
  __int64 v11; // r8
  __int64 *v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  signed int v16; // er8
  __int64 result; // rax
  unsigned __int64 v18; // rt1
  int v19; // edi
  __int64 v20; // rax
  signed int v21; // er14
  __int64 v22; // rax
  const char *v23; // rbx
  char *v24; // r12
  int v25; // er13
  char *v26; // rax
  char *v27; // rax
  char *v28; // rax
  char *v29; // rbx
  __int64 v30; // r14
  int v31; // er12
  __int64 v32; // rdx
  __int64 v33; // r13
  __int64 v34; // r15
  int v35; // edx
  char v36; // si
  __int64 v37; // rcx
  char *v38; // r11
  char v39; // cl
  __int64 v40; // rdx
  char *v41; // rax
  signed __int64 v42; // rcx
  __int64 v43; // rax
  signed __int64 v44; // rax
  int v45; // er9
  char *v46; // rcx
  char v47; // cl
  __int64 v48; // rax
  char *v49; // rsi
  int v50; // edx
  int v51; // eax
  char *v52; // rcx
  __int64 v53; // rdx
  char *v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  char v57; // ST20_1
  char *v58; // rax
  size_t v59; // rax
  char *v60; // rax
  int v61; // eax
  __int64 v62; // rdx
  __int64 v63; // rax
  __int64 v64; // rdi
  const char *v65; // rax
  size_t v66; // rax
  char *v67; // rax
  char v68; // al
  signed __int64 i; // rcx
  int v70; // edx
  signed __int64 v71; // r8
  char *v72; // r8
  int v73; // ST20_4
  unsigned __int8 v74; // al
  bool v75; // r8
  bool v76; // di
  char *v77; // r14
  char v78; // al
  __int64 v79; // [rsp+8h] [rbp-80h]
  char *v80; // [rsp+18h] [rbp-70h]
  char *v81; // [rsp+18h] [rbp-70h]
  signed __int64 v82; // [rsp+18h] [rbp-70h]
  char *v83; // [rsp+18h] [rbp-70h]
  bool v84; // [rsp+20h] [rbp-68h]
  bool v85; // [rsp+24h] [rbp-64h]
  __int64 v86; // [rsp+28h] [rbp-60h]
  __int64 v87; // [rsp+30h] [rbp-58h]
  signed __int64 v88; // [rsp+38h] [rbp-50h]
  char *s; // [rsp+40h] [rbp-48h]
  unsigned __int64 v90; // [rsp+48h] [rbp-40h]

  v5 = a3;
  v6 = a1;
  v90 = __readfsqword(0x28u);
  v79 = a3 - 144;
  if ( (_DWORD)a4 )
    *(_BYTE *)(a3 - 40) = 1;
  *(_BYTE *)(a3 - 24) = 1;
  v7 = a1 + a2;
  v8 = sub_BC650();
LABEL_4:
  if ( v6 != v7 )
  {
LABEL_5:
    v9 = *(unsigned __int8 *)(++v6 - 1);
    v10 = *(_DWORD *)(v5 - 20);
    v11 = *(unsigned __int8 *)(v6 - 1);
    switch ( v10 )
    {
      case 0:
      case 9:
        if ( !(_BYTE)v9 && v10 == 9 )
          goto LABEL_24;
        if ( (_BYTE)v11 == -1 )
        {
          *(_DWORD *)(v5 - 20) = 1;
        }
        else
        {
          if ( *(_BYTE *)(v5 - 40) )
          {
            if ( v9 == 242 )
            {
              *(_BYTE *)(v5 - 40) = 0;
              goto LABEL_24;
            }
            if ( v9 != 13 )
              goto LABEL_24;
          }
          else
          {
            LODWORD(v80) = *(unsigned __int8 *)(v6 - 1);
            sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 24), *(_BYTE *)(v6 - 1));
            if ( (_DWORD)v80 != 13 )
              goto LABEL_24;
          }
          if ( *(_DWORD *)(v5 - 60) == 1 )
            goto LABEL_24;
          *(_DWORD *)(v5 - 20) = 9;
        }
        break;
      case 1:
        if ( (_BYTE)v9 == -3 )
        {
          *(_DWORD *)(v5 - 20) = 4;
        }
        else if ( v9 == 254 )
        {
          *(_DWORD *)(v5 - 20) = 5;
        }
        else if ( v9 == 251 )
        {
          *(_DWORD *)(v5 - 20) = 2;
        }
        else if ( v9 == 252 )
        {
          *(_DWORD *)(v5 - 20) = 3;
        }
        else if ( v9 == 250 )
        {
          *(_DWORD *)(v5 - 20) = 6;
        }
        else
        {
          if ( v9 != 242 )
          {
            if ( v9 == 255 )
              sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v8 + 24), 255);
            goto LABEL_24;
          }
          *(_BYTE *)(v5 - 40) = 0;
          *(_DWORD *)(v5 - 20) = 0;
        }
        break;
      case 2:
        sub_89790(v9, v79, 0xFBu, v5);
        *(_DWORD *)(v5 - 20) = 0;
        break;
      case 3:
        sub_89790(v9, v79, 0xFCu, v5);
        *(_DWORD *)(v5 - 20) = 0;
        break;
      case 4:
        sub_89790(v9, v79, 0xFDu, v5);
        *(_DWORD *)(v5 - 20) = 0;
        break;
      case 5:
        sub_89790(v9, v79, 0xFEu, v5);
        *(_DWORD *)(v5 - 20) = 0;
        break;
      case 6:
        v12 = *(__int64 **)(v5 - 32);
        *(_DWORD *)(v5 - 36) = v9;
        sub_BC590(v12, 0LL);
        *(_DWORD *)(v5 - 20) = 7;
        break;
      case 7:
        if ( (_BYTE)v9 != -1 )
          goto LABEL_7;
        *(_DWORD *)(v5 - 20) = 8;
        break;
      case 8:
        if ( (_BYTE)v9 == -16 )
        {
          v19 = *(_DWORD *)(v5 - 36);
          if ( v19 == 32 )
          {
            v56 = *(_QWORD *)(v5 - 32);
            if ( *(_QWORD *)(v56 + 16) == 1LL && **(_BYTE **)(v56 + 8) == 1 )
            {
              v57 = *(_BYTE *)(v6 - 1);
              v58 = (char *)sub_1F170(*(__int64 **)(v5 - 16), 53);
              a5 = v58;
              v59 = strlen(v58);
              v60 = (char *)sub_2F450(v59 + 20, 1uLL, 0LL);
              *(_DWORD *)v60 = 2161407;
              v80 = v60;
              strcpy(v60 + 4, a5);
              v61 = strlen(a5);
              v62 = v61 + 4;
              v80[v62] = -1;
              v80[v62 + 1] = v57;
              v63 = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v5 - 144) + 16LL))(
                      *(_QWORD *)(v5 - 144),
                      v80,
                      v61 + 6);
              v64 = *(_QWORD *)(v5 - 120);
              *(_QWORD *)(v5 - 48) = v63;
              sub_2D2C0(v64, "server:\tSB TSPEED SEND", v6, v5);
              sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"client:\tSB TSPEED IS %s", v6, v5);
              sub_2F4D0(v80);
            }
            else
            {
              sub_2D2C0(*(_QWORD *)(v5 - 120), "server:\tSB TSPEED <something weird>", v6, v5);
            }
            goto LABEL_24;
          }
          if ( v19 <= 32 )
          {
            if ( v19 == 24 )
            {
              v55 = *(_QWORD *)(v5 - 32);
              if ( *(_QWORD *)(v55 + 16) == 1LL && **(_BYTE **)(v55 + 8) == 1 )
              {
                v65 = (const char *)sub_1F170(*(__int64 **)(v5 - 16), 52);
                v83 = (char *)v65;
                v66 = strlen(v65);
                v67 = (char *)sub_2F450(v66 + 20, 1uLL, 0LL);
                a5 = v67;
                *(_DWORD *)v67 = 1637119;
                v68 = *v83;
                if ( *v83 )
                {
                  for ( i = 1LL; ; ++i )
                  {
                    if ( (unsigned __int8)(v68 - 97) < 0x1Au )
                      v68 -= 32;
                    v70 = i;
                    a5[i + 3] = v68;
                    v68 = v83[i];
                    if ( !v68 )
                      break;
                  }
                  v71 = i + 4;
                }
                else
                {
                  v71 = 4LL;
                  v70 = 0;
                  i = 0LL;
                }
                v72 = &a5[v71];
                *v72 = -1;
                a5[i + 5] = -16;
                v80 = v72;
                *(_QWORD *)(v5 - 48) = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v5 - 144) + 16LL))(
                                         *(_QWORD *)(v5 - 144),
                                         a5,
                                         v70 + 6);
                *v80 = 0;
                sub_2D2C0(*(_QWORD *)(v5 - 120), "server:\tSB TTYPE SEND", v6, v5);
                sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"client:\tSB TTYPE IS %s", v6, v5);
                sub_2F4D0(a5);
              }
              else
              {
                sub_2D2C0(*(_QWORD *)(v5 - 120), "server:\tSB TTYPE <something weird>\r\n", v6, v5);
              }
            }
            goto LABEL_24;
          }
          if ( v19 != 36 && v19 != 39 )
            goto LABEL_24;
          v20 = *(_QWORD *)(v5 - 32);
          a5 = *(char **)(v20 + 8);
          if ( a5 >= &a5[*(_QWORD *)(v20 + 16)] || *a5 != 1 )
            goto LABEL_24;
          v81 = &a5[*(_QWORD *)(v20 + 16)];
          sub_888B0(v19);
          sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"server:\tSB %s SEND", v6, v5);
          v85 = 1;
          v84 = 0;
          if ( *(_DWORD *)(v5 - 36) == 36 )
          {
            v74 = sub_1EF00(*(__int64 **)(v5 - 16), 59);
            v75 = v74 >= 1u;
            v76 = v74 < 1u;
            v77 = a5 + 1;
            v85 = v74 >= 1u;
            v84 = v74 < 1u;
            if ( v81 > v77 )
            {
              do
              {
                v78 = *v77;
                if ( *v77 )
                {
                  if ( v78 == 1 )
                    v75 = 0;
                  if ( v78 == 1 )
                    v76 = 1;
                }
                else
                {
                  v75 = 1;
                  v76 = 0;
                }
                ++v77;
              }
              while ( v81 != v77 );
              v84 = v76;
              v85 = v75;
            }
          }
          v21 = 20;
          v22 = sub_1F330(*(__int64 **)(v5 - 16), 55, 0LL, &s);
          if ( v22 )
          {
            v82 = v8;
            v86 = v7;
            v23 = (const char *)v22;
            v87 = v6;
            do
            {
              v24 = s;
              v25 = strlen(s);
              v21 += strlen(v23) + v25 + 2;
              v23 = (const char *)sub_1F330(*(__int64 **)(v5 - 16), 55, v24, &s);
            }
            while ( v23 );
            v8 = v82;
            v7 = v86;
            v6 = v87;
          }
          v26 = sub_3D010(*(__int64 **)(v5 - 16));
          v80 = v26;
          if ( v26 )
            v21 += strlen(v26) + 6;
          v27 = (char *)sub_2F450(v21, 1uLL, 0LL);
          a5 = v27;
          *(_WORD *)v27 = -1281;
          LODWORD(v27) = *(_DWORD *)(v5 - 36);
          a5[3] = 0;
          a5[2] = (char)v27;
          v28 = (char *)sub_1F330(*(__int64 **)(v5 - 16), 55, 0LL, &s);
          if ( v28 )
          {
            v88 = v8;
            v29 = a5;
            v30 = v7;
            v31 = 4;
            v32 = v6;
            v33 = v5;
            v34 = v32;
            do
            {
              v35 = v31 + 1;
              v29[v31] = v84;
              v36 = *s;
              if ( *s )
              {
                v37 = v31 + 2;
                v38 = &s[-v37];
                do
                {
                  v29[v37 - 1] = v36;
                  v35 = v37++;
                  v36 = v38[v37];
                }
                while ( v36 );
              }
              v31 = v35 + 1;
              v29[v35] = v85;
              v39 = *v28;
              if ( *v28 )
              {
                v40 = v35 + 2;
                v41 = &v28[-v40];
                do
                {
                  v29[v40 - 1] = v39;
                  v31 = v40++;
                  v39 = v41[v40];
                }
                while ( v39 );
              }
              v28 = (char *)sub_1F330(*(__int64 **)(v33 - 16), 55, s, &s);
            }
            while ( v28 );
            v42 = v31;
            v43 = v34;
            v7 = v30;
            v5 = v33;
            a5 = v29;
            v6 = v43;
            v8 = v88;
            v16 = v42;
            v44 = (signed int)v42 + 1;
          }
          else
          {
            v44 = 5LL;
            v42 = 4LL;
            v16 = 4;
          }
          v45 = v16 + 2;
          v46 = &a5[v42];
          result = (__int64)&a5[v44];
          if ( v80 )
          {
            *v46 = v84;
            *(_BYTE *)result = 85;
            a5[v45] = 83;
            a5[v16 + 3] = 69;
            a5[v16 + 4] = 82;
            a5[v16 + 5] = v85;
            LODWORD(result) = v16 + 6;
            v47 = *v80;
            if ( !*v80 )
              goto LABEL_99;
            v48 = v16 + 7;
            v49 = &v80[-v48];
            do
            {
              a5[v48 - 1] = v47;
              v50 = v48++;
              v47 = v49[v48];
            }
            while ( v47 );
            v51 = v50 + 1;
            v52 = &a5[v50];
            v53 = v50 + 2;
            v54 = &a5[v51];
            goto LABEL_54;
          }
          *v46 = -1;
          *(_BYTE *)result = -16;
          v73 = v16 + 2;
          *(_QWORD *)(v5 - 48) = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(**(_QWORD **)(v5 - 144) + 16LL))(
                                   *(_QWORD *)(v5 - 144),
                                   a5,
                                   v45);
          if ( v73 != 6 )
            goto LABEL_55;
          sub_888B0(*(_DWORD *)(v5 - 36));
          sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"client:\tSB %s IS <nothing>", v6, v5);
          goto LABEL_59;
        }
LABEL_7:
        sub_2ECE0(
          (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v5 - 32) + 24LL),
          *(_BYTE *)(v6 - 1));
        *(_DWORD *)(v5 - 20) = 7;
        break;
      default:
        goto LABEL_9;
    }
    goto LABEL_9;
  }
  while ( 1 )
  {
    if ( *(_QWORD *)(v8 + 16) )
    {
      v15 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, _QWORD))(v5 - 128))(
              *(_QWORD *)(v5 - 128),
              0LL,
              *(_QWORD *)(v8 + 8));
      (*(void (__fastcall **)(_QWORD, bool))(**(_QWORD **)(v5 - 144) + 40LL))(*(_QWORD *)(v5 - 144), v15 > 0x1000);
    }
    sub_BC660((void **)v8);
    v18 = __readfsqword(0x28u);
    result = v18 ^ v90;
    if ( v18 == v90 )
      return result;
LABEL_99:
    v52 = &a5[(signed int)result];
    v53 = v16 + 8;
    v54 = &a5[v16 + 7];
LABEL_54:
    *v52 = -1;
    *v54 = -16;
    *(_QWORD *)(v5 - 48) = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(**(_QWORD **)(v5 - 144) + 16LL))(
                             *(_QWORD *)(v5 - 144),
                             a5,
                             v53);
LABEL_55:
    sub_888B0(*(_DWORD *)(v5 - 36));
    sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"client:\tSB %s IS:", v6, v5);
    if ( sub_1F330(*(__int64 **)(v5 - 16), 55, 0LL, &s) )
    {
      do
        sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"\t%s=%s", v6, v5);
      while ( sub_1F330(*(__int64 **)(v5 - 16), 55, s, &s) );
    }
    if ( v80 )
      sub_2D3F0(*(_QWORD *)(v5 - 120), (__int64)"\tUSER=%s", v6, v5);
LABEL_59:
    sub_2F4D0(a5);
    sub_2F4D0(v80);
LABEL_24:
    *(_DWORD *)(v5 - 20) = 0;
LABEL_9:
    v13 = *(_QWORD *)(v8 + 16);
    if ( v13 <= 0xFFF )
      goto LABEL_4;
    v14 = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, _QWORD, unsigned __int64, __int64))(v5 - 128))(
            *(_QWORD *)(v5 - 128),
            0LL,
            *(_QWORD *)(v8 + 8),
            v13,
            v11);
    (*(void (__fastcall **)(_QWORD, bool))(**(_QWORD **)(v5 - 144) + 40LL))(*(_QWORD *)(v5 - 144), v14 > 0x1000);
    sub_BC590((__int64 *)v8, 0LL);
    if ( v6 != v7 )
      goto LABEL_5;
  }
}

unsigned __int64 __usercall sub_8A320@<rax>(__int64 a1@<rdi>, char *a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  unsigned __int64 result; // rax

  v4 = a1;
  v5 = *(_QWORD *)(a1 - 144);
  if ( v5 )
  {
    (*(void (**)(void))(*(_QWORD *)v5 + 8LL))();
    *(_QWORD *)(v4 - 144) = 0LL;
    if ( a2 )
      *(_BYTE *)(v4 - 136) = 1;
    result = (*(__int64 (**)(void))(**(_QWORD **)(v4 - 128) + 24LL))();
  }
  if ( a2 )
  {
    sub_2D2C0(*(_QWORD *)(v4 - 120), a2, a3, a4);
    result = sub_31A30(*(_QWORD *)(v4 - 128), (__int64)"%s", a2);
  }
  return result;
}

__int64 __fastcall sub_8A3A0(__int64 a1, int a2, signed int a3, int a4)
{
  int v4; // eax
  signed int v5; // er8
  signed int v6; // eax
  bool v7; // cl
  signed int v8; // eax
  __int64 result; // rax

  if ( a2 < 0 )
    a2 = 0;
  v4 = *(_DWORD *)(a1 + 416);
  if ( v4 <= a2 )
    a2 = v4 - 1;
  if ( a4 )
  {
    v5 = *(_DWORD *)(a1 + 232);
    v6 = *(_DWORD *)(a1 + 248);
    v7 = a4 == 2;
    if ( (v5 >= v6 || v7) && a3 < v6 )
      a3 = *(_DWORD *)(a1 + 248);
    v8 = *(_DWORD *)(a1 + 252);
    if ( (v5 <= v8 || v7) && a3 > v8 )
      a3 = *(_DWORD *)(a1 + 252);
  }
  *(_DWORD *)(a1 + 236) = a2;
  if ( a3 < 0 )
    a3 = 0;
  result = *(unsigned int *)(a1 + 412);
  *(_BYTE *)(a1 + 258) = 0;
  if ( (signed int)result <= a3 )
    a3 = result - 1;
  *(_DWORD *)(a1 + 232) = a3;
  return result;
}

signed __int64 __fastcall sub_8A420(__int64 a1, signed int a2)
{
  __int64 v2; // rdx
  __int64 v3; // rax
  void **v4; // rax
  signed int v5; // edx

  v2 = *(_QWORD *)(a1 + 4352);
  v3 = a2 & 0xFFFFFF00;
  if ( v3 == 55552 )
  {
    a2 = *(_DWORD *)(v2 + 4LL * (unsigned __int8)a2 + 3092);
    v3 = a2 & 0xFFFFFF00;
LABEL_4:
    if ( v3 != 56320 )
      goto LABEL_5;
LABEL_16:
    a2 = *(_DWORD *)(v2 + 4LL * (unsigned __int8)a2 + 4116);
    goto LABEL_7;
  }
  if ( v3 == 55808 )
  {
    a2 = *(_DWORD *)(v2 + 4LL * (unsigned __int8)a2 + 20);
    v3 = a2 & 0xFFFFFF00;
    goto LABEL_4;
  }
  if ( v3 != 55296 )
    goto LABEL_4;
  a2 = *(_DWORD *)(v2 + 4LL * (unsigned __int8)a2 + 1044);
  v3 = a2 & 0xFFFFFF00;
  if ( v3 == 56320 )
    goto LABEL_16;
LABEL_5:
  if ( v3 == 56576 )
    a2 = *(_DWORD *)(v2 + 4LL * (unsigned __int8)a2 + 2068);
LABEL_7:
  if ( *(_BYTE *)(v2 + 8) && *(_DWORD *)(v2 + 12) == *(_DWORD *)(v2 + 16) )
    return a2 != 32;
  v4 = &off_F5680;
  v5 = 128;
  if ( a2 <= 127 )
    return (unsigned int)*(signed __int16 *)(a1 + 2LL * a2 + 3784);
  while ( a2 < v5 || *((_DWORD *)v4 + 1) < a2 )
  {
    v4 = (void **)((char *)v4 + 12);
    v5 = *(_DWORD *)v4;
    if ( !*(_DWORD *)v4 )
      return 2LL;
  }
  return *((unsigned int *)v4 + 2);
}

__int64 __fastcall sub_8A550(__int64 a1)
{
  __int64 result; // rax

  result = sub_9AFB0(*(__int64 **)(a1 + 8));
  if ( *(_BYTE *)(a1 + 4541) && *(_DWORD *)(a1 + 508) )
  {
    if ( *(_QWORD *)(a1 + 24) )
      result = (unsigned int)(*(_DWORD *)(a1 + 512) + result);
  }
  return result;
}

_QWORD *__fastcall sub_8A580(const __m128i *a1, int a2, char a3)
{
  char v3; // r12
  _QWORD *v4; // rbp
  __m128i *v5; // rax
  signed __int64 v6; // rdx
  _QWORD *result; // rax

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x28uLL, 0LL);
  v5 = (__m128i *)sub_2F450(a2, 0x20uLL, 0LL);
  v4[3] = v5;
  if ( a2 > 0 )
  {
    v6 = (signed __int64)v5[2 * (unsigned int)(a2 - 1) + 2].m128i_i64;
    do
    {
      while ( v3 )
      {
        v5 += 2;
        v5[-2] = _mm_loadu_si128(a1 + 10);
        v5[-1] = _mm_loadu_si128(a1 + 11);
        if ( v5 == (__m128i *)v6 )
          goto LABEL_6;
      }
      v5 += 2;
      v5[-2] = _mm_loadu_si128(a1 + 8);
      v5[-1] = _mm_loadu_si128(a1 + 9);
    }
    while ( v5 != (__m128i *)v6 );
  }
LABEL_6:
  *(_WORD *)v4 = 0;
  *((_DWORD *)v4 + 2) = a2;
  result = v4;
  *((_DWORD *)v4 + 1) = a2;
  *((_BYTE *)v4 + 32) = 0;
  *((_BYTE *)v4 + 12) = 0;
  *((_DWORD *)v4 + 4) = 0;
  return result;
}

unsigned __int64 __fastcall sub_8A650(__int64 a1, __int64 a2, void (__fastcall *a3)(__int64, signed __int64, __int64, __int64 *))
{
  int v3; // er15
  void (__fastcall *v4)(__int64, signed __int64, __int64, __int64 *); // r12
  __int64 v5; // rbp
  int v6; // eax
  bool v7; // zf
  unsigned __int8 v8; // al
  __int64 v9; // r9
  __int64 v10; // r13
  int v11; // er15
  signed __int64 v12; // r14
  signed __int64 v13; // rsi
  int v14; // edx
  int v15; // eax
  signed __int64 v17; // r14
  unsigned __int64 v18; // r13
  __int64 v19; // [rsp+10h] [rbp-58h]
  signed __int64 v20; // [rsp+18h] [rbp-50h]
  __int64 v21; // [rsp+20h] [rbp-48h]
  unsigned __int64 v22; // [rsp+28h] [rbp-40h]

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v22 = __readfsqword(0x28u);
  v6 = *(_DWORD *)(a2 + 4);
  v21 = 0LL;
  while ( 1 )
  {
    v7 = v3 == v6;
    if ( v3 >= v6 )
      break;
    while ( 1 )
    {
      v8 = sub_2F080(*(_QWORD *)(a1 + 32));
      if ( (signed int)v8 <= 127 )
        break;
      v19 = *(_QWORD *)(a1 + 8);
      v20 = v8 - 126 - 1LL;
      if ( v3 >= *(_DWORD *)(v5 + 4) )
LABEL_16:
        __assert_fail("n < ldata->cols", "terminal.c", 0x325u, "readrle");
      v9 = v3;
      v10 = 0LL;
      v11 = v3 + 1;
      v12 = 32 * v9;
      while ( 1 )
      {
        v13 = v12 + *(_QWORD *)(v5 + 24);
        *(_QWORD *)(a1 + 8) = v19;
        v4(a1, v13, v5, &v21);
        v14 = v11 + v10;
        if ( v20 == v10 )
          break;
        ++v10;
        v12 += 32LL;
        if ( *(_DWORD *)(v5 + 4) <= v14 )
          goto LABEL_16;
      }
      v15 = *(_DWORD *)(v5 + 4);
      v3 = v11 + v10;
      v7 = v14 == v15;
      if ( v14 >= v15 )
        goto LABEL_9;
    }
    if ( v3 >= *(_DWORD *)(v5 + 4) )
LABEL_17:
      __assert_fail("n < ldata->cols", "terminal.c", 0x32Fu, "readrle");
    v17 = 32LL * v3;
    v18 = 32 * (v3 + (unsigned __int64)v8);
    while ( 1 )
    {
      ++v3;
      v4(a1, v17 + *(_QWORD *)(v5 + 24), v5, &v21);
      if ( v17 == v18 )
        break;
      v17 += 32LL;
      if ( *(_DWORD *)(v5 + 4) <= v3 )
        goto LABEL_17;
    }
    v6 = *(_DWORD *)(v5 + 4);
  }
LABEL_9:
  if ( !v7 )
    __assert_fail("n == ldata->cols", "terminal.c", 0x336u, "readrle");
  return __readfsqword(0x28u) ^ v22;
}

_QWORD *__fastcall sub_8A820(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // er12
  int v3; // ebp
  __int64 v4; // rax
  __int64 *v5; // rdi
  char v6; // al
  char v7; // cl
  _QWORD *v8; // r12
  char *v9; // rax
  _DWORD *v10; // rdx
  signed __int64 v11; // rax
  int v12; // er13
  int v13; // ebp
  char v14; // al
  char v15; // cl
  _QWORD *result; // rax
  __int64 v17; // [rsp+0h] [rbp-58h]
  __int64 v18; // [rsp+8h] [rbp-50h]
  __int64 v19; // [rsp+10h] [rbp-48h]
  int v20; // [rsp+18h] [rbp-40h]
  __int64 *v21; // [rsp+20h] [rbp-38h]
  unsigned __int64 v22; // [rsp+28h] [rbp-30h]

  v1 = a1 + 8;
  v2 = 0;
  v3 = 0;
  v22 = __readfsqword(0x28u);
  v4 = *(_QWORD *)(v1 - 8);
  v17 = v1;
  v18 = 0LL;
  v20 = 0;
  v5 = &v17;
  v21 = &v17;
  v19 = v4;
  while ( 1 )
  {
    v6 = sub_2F080((__int64)v5);
    v7 = v2;
    v2 += 7;
    v3 |= (v6 & 0x7F) << v7;
    if ( v6 >= 0 )
      break;
    v5 = v21;
  }
  v8 = sub_2F450(1uLL, 0x28uLL, 0LL);
  v9 = (char *)sub_2F450(v3, 0x20uLL, 0LL);
  v8[3] = v9;
  *((_DWORD *)v8 + 2) = v3;
  *((_DWORD *)v8 + 1) = v3;
  *((_BYTE *)v8 + 12) = 1;
  *((_DWORD *)v8 + 4) = 0;
  if ( v3 > 0 )
  {
    v10 = v9 + 24;
    v11 = (signed __int64)&v9[32 * (v3 - 1) + 56];
    do
    {
      *v10 = 0;
      v10 += 8;
    }
    while ( v10 != (_DWORD *)v11 );
  }
  v12 = 0;
  v13 = 0;
  do
  {
    v14 = sub_2F080((__int64)v21);
    v15 = v13;
    v13 += 7;
    v12 |= (v14 & 0x7F) << v15;
  }
  while ( v14 < 0 );
  *(_WORD *)v8 = v12;
  *((_BYTE *)v8 + 32) = (unsigned __int16)v12 >> 16;
  sub_8A650((__int64)&v17, (__int64)v8, (void (__fastcall *)(__int64, signed __int64, __int64, __int64 *))sub_8AA70);
  sub_8A650((__int64)&v17, (__int64)v8, (void (__fastcall *)(__int64, signed __int64, __int64, __int64 *))sub_8A9F0);
  sub_8A650((__int64)&v17, (__int64)v8, (void (__fastcall *)(__int64, signed __int64, __int64, __int64 *))sub_8E1F0);
  sub_8A650((__int64)&v17, (__int64)v8, (void (__fastcall *)(__int64, signed __int64, __int64, __int64 *))sub_8BDD0);
  if ( *((_DWORD *)v21 + 6) )
    __assert_fail("!get_err(bs)", "terminal.c", 0x3D8u, "decompressline");
  if ( v21[2] != v21[1] || (result = v8, __readfsqword(0x28u) != v22) )
    __assert_fail("get_avail(bs) == 0", "terminal.c", 0x3D9u, "decompressline");
  return result;
}

__int64 __fastcall sub_8A9F0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 result; // rax

  v2 = sub_2F100(*(_QWORD *)(a1 + 32));
  if ( v2 > 0x7FFF )
    v2 = (v2 << 16) & 0x7FFF0000 | (unsigned __int64)sub_2F100(*(_QWORD *)(a1 + 32));
  result = ((v2 & 0xF | 16 * v2 & 0x7FFFF00) >> 13 << 17) | (v2 & 0xF | 16 * v2 & 0x7FFFF00) & 0x1FFF | (unsigned __int8)(16 * (v2 >> 23)) | ((unsigned int)(unsigned __int8)(v2 >> 23) >> 4 << 13);
  *(_QWORD *)(a2 + 8) = (unsigned int)result;
  return result;
}

char __fastcall sub_8AA70(__int64 a1, __int64 *a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // r12
  __int64 *v5; // rbx
  unsigned __int8 v6; // al
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdi

  v4 = a1;
  v5 = a4;
  v6 = sub_2F080(*(_QWORD *)(a1 + 32));
  if ( (signed int)v6 <= 127 )
  {
    v7 = *v5 | v6;
    *a2 = v7;
    LOBYTE(v7) = 0;
    *v5 = v7;
    return v7;
  }
  if ( (signed int)v6 <= 191 )
  {
    v8 = *(_QWORD *)(a1 + 32);
    *a2 = (v6 << 8) & 0x3F00;
    v7 = *a2 | (unsigned __int8)sub_2F080(v8);
    *a2 = v7;
    LOBYTE(v7) = 0;
    *v5 = v7;
    return v7;
  }
  if ( (signed int)v6 <= 223 )
  {
    *a2 = (v6 << 16) & 0x1F0000;
    goto LABEL_10;
  }
  if ( (signed int)v6 <= 239 )
  {
    v9 = *(_QWORD *)(a1 + 32);
    *a2 = (v6 << 24) & 0xF000000;
    *a2 = ((unsigned int)sub_2F080(v9) << 16) & 0xFF0000 | (unsigned __int64)*a2;
LABEL_10:
    v7 = *a2 | (unsigned int)sub_2F100(*(_QWORD *)(v4 + 32));
    *a2 = v7;
    LOBYTE(v7) = 0;
    *v5 = v7;
    return v7;
  }
  if ( v6 != 240 )
    __assert_fail("byte == 0xF0", "terminal.c", 0x353u, "readliteral_chr");
  v7 = sub_2F150(*(_QWORD *)(a1 + 32));
  *a2 = v7;
  LOBYTE(v7) = 0;
  *v5 = v7;
  return v7;
}

signed __int64 __fastcall sub_8AB90(__int64 a1, int a2, int a3, __int64 a4)
{
  int v4; // er13
  __int64 v5; // rbp
  size_t *v6; // rbx
  int v7; // er12
  unsigned __int64 v8; // rcx
  char *v9; // rdx
  _DWORD *v10; // rax
  _DWORD *v11; // rax
  signed __int64 result; // rax
  char *v13; // rax
  __int64 v14; // rdx
  void *v15; // rdi
  size_t v16; // rsi
  char *v17; // rax
  size_t v18; // rdx
  void *v19; // rdi
  size_t v20; // rsi
  char *v21; // rax

  v4 = a2;
  v5 = a4;
  v6 = (size_t *)a1;
  v7 = a3;
  v8 = *(_QWORD *)(a1 + 8);
  if ( v8 >= *(_QWORD *)a1 )
  {
    v13 = (char *)sub_2F4F0(*(void **)(a1 + 16), (unsigned __int64 *)a1, 4uLL, v8, 1uLL, 0);
    v14 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 16) = v13;
    v15 = *(void **)(a1 + 32);
    v16 = *v6;
    v6[3] = (size_t)&v13[4 * v14];
    v17 = (char *)sub_2F490(v15, v16, 4uLL);
    v18 = v6[1];
    v6[4] = (size_t)v17;
    v19 = (void *)v6[6];
    v20 = *v6;
    v6[5] = (size_t)&v17[4 * v18];
    v21 = (char *)sub_2F490(v19, v20, 8uLL);
    v8 = v6[1];
    v6[6] = (size_t)v21;
    v9 = &v21[8 * v8];
  }
  else
  {
    v9 = *(char **)(a1 + 56);
  }
  v10 = (_DWORD *)v6[3];
  v6[3] = (size_t)(v10 + 1);
  *v10 = v4;
  v11 = (_DWORD *)v6[5];
  v6[5] = (size_t)(v11 + 1);
  *v11 = v7;
  result = (signed __int64)(v9 + 8);
  v6[7] = (size_t)(v9 + 8);
  *(_QWORD *)v9 = v5;
  v6[1] = v8 + 1;
  return result;
}

unsigned __int64 __fastcall sub_8AC60(__int64 a1)
{
  __int64 i; // rbp
  unsigned __int64 v2; // rbx
  const void *v3; // rax
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax

  for ( i = a1 + 328; ; sub_BCE20(i, v2) )
  {
    result = sub_BCD00(i);
    if ( result <= 5 )
      break;
    v2 = result - 5;
    v3 = (const void *)sub_BCF00(i);
    if ( v2 > v4 )
      v2 = v4;
    sub_B8190(*(FILE ***)(a1 + 368), v3, v2);
  }
  return result;
}

__int64 __fastcall sub_8ACC0(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  bool v3; // zf
  char v4; // si
  __int64 (__fastcall **v5)(_QWORD, char *, signed __int64); // rbp
  __int64 result; // rax

  v2 = a2;
  v3 = a2[20] == 0;
  v4 = a2[16];
  if ( !v3 )
    v4 |= 2u;
  v5 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24);
  result = sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), v4);
  if ( v2[16] )
  {
    sub_2ECE0(v5, v2[17]);
    sub_2ECE0(v5, v2[18]);
    result = sub_2ECE0(v5, v2[19]);
  }
  if ( v2[20] )
  {
    sub_2ECE0(v5, v2[21]);
    sub_2ECE0(v5, v2[22]);
    result = sub_2ECE0(v5, v2[23]);
  }
  return result;
}

__int64 __fastcall sub_8AD60(__int64 a1, __int64 a2)
{
  __int64 (__fastcall **v2)(_QWORD, char *, signed __int64); // rbp
  __int64 v3; // rax
  unsigned int v4; // ebx
  char v5; // r12
  unsigned int v6; // er13
  unsigned int v7; // esi

  v2 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = 16 * ((*(unsigned __int64 *)(a2 + 8) & 0x1FFF | ((unsigned int)v3 >> 17 << 13)) >> 8) | ((((unsigned int)v3 >> 9) & 0xF0 | ((unsigned int)*(_QWORD *)(a2 + 8) >> 4) & 0xF) << 23) | *(_QWORD *)(a2 + 8) & 0xF;
  v5 = 16 * ((unsigned __int16)(*(_QWORD *)(a2 + 8) & 0x1FFF | ((unsigned int)v3 >> 17 << 13)) >> 8) | *(_QWORD *)(a2 + 8) & 0xF;
  v6 = v4 >> 8;
  v7 = v4 >> 8;
  if ( v4 > 0x7FFF )
  {
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), HIBYTE(v4) | 0x80);
    sub_2ECE0(v2, SBYTE2(v4));
    LOBYTE(v7) = v6;
  }
  sub_2ECE0(v2, v7);
  return sub_2ECE0(v2, v5);
}

char __fastcall sub_8AE10(__int64 a1, char *a2, _QWORD *a3)
{
  _QWORD *v3; // r12
  char *v4; // rbx
  unsigned __int64 v5; // rsi
  __int64 (__fastcall **v6)(_QWORD, char *, signed __int64); // rbp
  __int64 v7; // rax

  v3 = a3;
  v4 = a2;
  v5 = *(_QWORD *)a2;
  v6 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24);
  if ( (v5 & 0xFFFFFFFFFFFFFF80LL) == *a3 )
  {
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), v5 & 0x7F);
    v7 = *(_QWORD *)v4;
    LOBYTE(v7) = 0;
    *v3 = v7;
    return v7;
  }
  if ( v5 <= 0x3FFF )
  {
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), BYTE1(v5) | 0x80);
    sub_2ECE0(v6, *v4);
    v7 = *(_QWORD *)v4;
    LOBYTE(v7) = 0;
    *v3 = v7;
    return v7;
  }
  if ( v5 <= 0x1FFFFF )
  {
    LODWORD(v5) = (v5 >> 16) | 0xFFFFFFC0;
LABEL_8:
    sub_2ECE0(v6, v5);
    sub_2ED40((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v6, *(_WORD *)v4);
    v7 = *(_QWORD *)v4;
    LOBYTE(v7) = 0;
    *v3 = v7;
    return v7;
  }
  if ( v5 <= 0xFFFFFFF )
  {
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), BYTE3(v5) | 0xE0);
    LOBYTE(v5) = v4[2];
    goto LABEL_8;
  }
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), 240);
  sub_2ED90((void (__fastcall **)(_QWORD, char *, signed __int64, _QWORD))v6, *(_QWORD *)v4);
  v7 = *(_QWORD *)v4;
  LOBYTE(v7) = 0;
  *v3 = v7;
  return v7;
}

__int64 __fastcall sub_8AF20(__int64 a1, signed int *a2, int a3)
{
  signed int *v3; // r15
  int v4; // ebx
  __int64 v5; // r14
  char *v6; // rax
  int v7; // eax
  signed int *v9; // r12
  unsigned __int64 v10; // rsi
  char v11; // [rsp+2h] [rbp-46h]
  unsigned __int64 v12; // [rsp+8h] [rbp-40h]

  v3 = a2;
  v4 = a3;
  v12 = __readfsqword(0x28u);
  v5 = sub_BC640();
  if ( *(_BYTE *)(a1 + 305) || *(_DWORD *)(*(_QWORD *)(a1 + 4352) + 16LL) == 55 )
  {
    if ( v4 > 0 )
    {
      v9 = &a2[v4 - 1 + 1];
      do
      {
        v10 = *v3;
        if ( v10 - 55296 <= 0x7FF )
          v10 = 46LL;
        ++v3;
        sub_BD410(&v11, v10);
        sub_2EC20((__int64 (**)(void))(v5 + 24));
      }
      while ( v9 != v3 );
    }
  }
  else
  {
    v6 = sub_BC510(v5, v4 + 1);
    v7 = sub_BB550(*(_DWORD *)(*(_QWORD *)(a1 + 4352) + 16LL), 0LL, (__int64)a2, v4, (__int64)v6, v4 + 1, 0LL);
    if ( v7 < 0 )
      v7 = 0;
    sub_BC590((__int64 *)v5, v7);
  }
  return v5;
}

bool __fastcall sub_8B030(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool result; // al
  __int64 v5; // rdx
  __int64 v6; // rax

  result = 0;
  if ( *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
    && *(_QWORD *)a1 == a3
    && !((*(_QWORD *)(a1 + 8) ^ a4) & 0xFFFFFFFF0FFFFFFFLL) )
  {
    do
    {
      v5 = *(signed int *)(a1 + 24);
      v6 = *(signed int *)(a2 + 24);
      if ( !(_DWORD)v5 )
        return (_DWORD)v6 == 0;
      if ( !(_DWORD)v6 )
        break;
      a2 += 32 * v6;
      a1 += 32 * v5;
    }
    while ( *(_QWORD *)a1 == *(_QWORD *)a2 );
    result = 0;
  }
  return result;
}

__int64 __fastcall sub_8B0A0(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // r10
  signed int v4; // er9
  __int64 v5; // rbp
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 v10; // r11
  _QWORD *v11; // rdi
  __int64 *v12; // r13
  __int64 *v13; // r8
  _QWORD *v14; // rdx
  signed int v15; // esi
  __int64 v16; // rax
  signed __int64 v17; // rcx
  __int64 v19; // rcx
  int v20; // er8
  _WORD *v21; // rax
  signed int v22; // er12
  int v23; // ecx
  size_t v24; // rsi
  void *v25; // rdi
  __int64 v26; // rax
  char *v27; // r13
  char *v28; // rdi
  unsigned __int16 v29; // r10
  signed int v30; // edx
  signed __int64 v31; // r9
  signed __int64 v32; // rcx
  __int64 v33; // r11
  __int64 v34; // rsi
  __int32 v35; // esi
  __m128i *v36; // rax
  signed __int64 v37; // rsi
  unsigned int v38; // esi
  signed int v39; // er15
  char *v40; // rdi
  char v41; // r13
  unsigned __int64 v42; // r12
  void *v43; // rax
  unsigned __int64 v44; // rbp
  signed __int64 v45; // rbp
  signed __int64 v46; // r14
  unsigned __int64 v47; // rdi
  size_t v48; // r12
  signed __int64 v49; // r14
  __int64 v50; // r14
  __int64 v51; // r14
  unsigned __int64 v52; // r9
  unsigned __int16 *v53; // r8
  __int64 v54; // rcx
  __int64 v55; // rsi
  __int64 v56; // rax
  signed __int64 v57; // rdx
  signed __int64 v58; // r10
  signed __int64 v59; // r12
  void *v60; // rax
  size_t v61; // rsi
  void *v62; // rdi
  char *v63; // rax
  unsigned __int64 v64; // rsi
  signed __int64 v65; // rbp
  char *v66; // rdx
  char *v67; // rcx
  signed __int64 v68; // rax
  __int64 v69; // rsi
  char v70; // r12
  __int64 v71; // r15
  __int64 *v72; // r10
  signed __int64 v73; // r14
  __int64 v74; // r10
  void *v75; // rax
  size_t v76; // rsi
  void *v77; // rdi
  void *v78; // rax
  void *v79; // rax
  char *v80; // [rsp+0h] [rbp-58h]
  void *v81; // [rsp+0h] [rbp-58h]
  char *src; // [rsp+8h] [rbp-50h]
  void *srca; // [rsp+8h] [rbp-50h]
  int v84; // [rsp+14h] [rbp-44h]
  __int64 v85; // [rsp+18h] [rbp-40h]

  v3 = *(_BYTE *)(a2 + 32);
  if ( *(_BYTE *)(a1 + 4524) && *(_BYTE *)(a1 + 4500) )
  {
    if ( !v3 )
      return 0LL;
    v4 = *(_DWORD *)(a1 + 416);
    if ( v4 <= 3 )
      return 0LL;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 416);
  }
  v5 = a2;
  v6 = a1;
  v7 = *(_QWORD *)(a1 + 4456);
  v84 = a3;
  if ( v7 )
  {
    a3 = (signed int)a3;
    if ( (unsigned __int64)(signed int)a3 < *(_QWORD *)(a1 + 4472) )
    {
      v8 = 32 * a3;
      v9 = v8 + v7;
      v10 = v8;
      if ( *(_QWORD *)(v9 + 8) )
      {
        if ( v4 == *(_DWORD *)v9 )
        {
          v70 = *(_BYTE *)(v9 + 4);
          if ( v70 == v3 )
          {
            if ( v4 <= 0 )
              return *(_QWORD *)(*(_QWORD *)(a1 + 4464) + v10 + 8);
            v12 = *(__int64 **)(a2 + 24);
            v71 = *(_QWORD *)(v9 + 8);
            v72 = v12;
            v73 = (signed __int64)&v12[4 * (unsigned int)(v4 - 1) + 4];
            while ( sub_8B030(v71, (__int64)v72, *v72, v72[1]) )
            {
              v72 = (__int64 *)(v74 + 32);
              v71 += 32LL;
              if ( (__int64 *)v73 == v72 )
                return *(_QWORD *)(*(_QWORD *)(a1 + 4464) + v10 + 8);
            }
            v11 = *(_QWORD **)(a1 + 4432);
            v3 = v70;
            if ( v4 <= *(_DWORD *)(v6 + 4448) )
              goto LABEL_11;
            goto LABEL_86;
          }
        }
      }
    }
  }
  v11 = *(_QWORD **)(a1 + 4432);
  if ( *(_DWORD *)(v6 + 4448) < v4 )
  {
LABEL_86:
    *(_DWORD *)(v6 + 4448) = v4;
    v75 = sub_2F490(v11, v4, 0xCuLL);
    v76 = *(signed int *)(v6 + 4448);
    v77 = *(void **)(v6 + 4440);
    *(_QWORD *)(v6 + 4432) = v75;
    v78 = sub_2F490(v77, v76, 0xCuLL);
    v4 = *(_DWORD *)(v6 + 416);
    *(_QWORD *)(v6 + 4440) = v78;
    v3 = *(_BYTE *)(v5 + 32);
    v11 = *(_QWORD **)(v6 + 4432);
  }
  if ( v4 > 0 )
  {
    v12 = *(__int64 **)(v5 + 24);
LABEL_11:
    v13 = v12;
    v14 = v11;
    v15 = 0;
    while ( 1 )
    {
      v16 = *v13;
      v17 = *v13 & 0xFFFFFF00LL;
      if ( v17 == 55552 )
        break;
      if ( v17 == 55808 )
      {
        LODWORD(v16) = *(_DWORD *)(*(_QWORD *)(v6 + 4352) + 4LL * (unsigned __int8)v16 + 20);
        v17 = (unsigned int)v16 & 0xFFFFFF00;
        goto LABEL_18;
      }
      if ( v17 == 55296 )
      {
        v19 = *(_QWORD *)(v6 + 4352);
        v16 = (unsigned __int8)v16;
LABEL_24:
        LODWORD(v16) = *(_DWORD *)(v19 + 4 * v16 + 1044);
        v17 = (unsigned int)v16 & 0xFFFFFF00;
      }
LABEL_18:
      if ( v17 == 56320 )
      {
        LODWORD(v16) = *(_DWORD *)(*(_QWORD *)(v6 + 4352) + 4LL * (unsigned __int8)v16 + 4116);
      }
      else if ( v17 == 56576 )
      {
        LODWORD(v16) = *(_DWORD *)(*(_QWORD *)(v6 + 4352) + 4LL * (unsigned __int8)v16 + 2068);
      }
      *((_DWORD *)v14 + 1) = v16;
      *(_DWORD *)v14 = v16;
      *((_WORD *)v14 + 4) = v15++;
      *((_WORD *)v14 + 5) = 1;
      v13 += 4;
      v14 = (_QWORD *)((char *)v14 + 12);
      if ( v4 <= v15 )
        goto LABEL_28;
    }
    v19 = *(_QWORD *)(v6 + 4352);
    v16 = (unsigned __int8)v16;
    if ( !*(_BYTE *)(v6 + 4567) )
    {
      LODWORD(v16) = *(_DWORD *)(v19 + 4 * v16 + 3092);
      v17 = (unsigned int)v16 & 0xFFFFFF00;
      goto LABEL_18;
    }
    goto LABEL_24;
  }
LABEL_28:
  if ( v4 > 3 && v3 )
  {
    memmove((char *)v11 + 36, v11, 12LL * (v4 - 3));
    v11 = *(_QWORD **)(v6 + 4432);
    *v11 = 246282014744574LL;
    *((_DWORD *)v11 + 8) = 0x1FFFF;
    v11[1] = 246286309785599LL;
    v11[2] = 562945658511359LL;
    v11[3] = 137438953504LL;
  }
  v20 = *(_DWORD *)(v6 + 416);
  if ( v20 <= 0 )
  {
    v22 = 0;
  }
  else
  {
    v21 = (_WORD *)((char *)v11 + 10);
    v22 = 0;
    v23 = 0;
    while ( 1 )
    {
      *(_QWORD *)(v21 - 5) = *(_QWORD *)((char *)v11 + 12 * v23);
      *(_DWORD *)(v21 - 1) = *((_DWORD *)v11 + 3 * v23 + 2);
      if ( v23 + 1 >= v20 )
        break;
      if ( *((_DWORD *)v11 + 3 * v23 + 4) == 57343 )
      {
        v23 += 2;
        ++*v21;
        ++v22;
        v21 += 6;
        if ( v20 <= v23 )
          goto LABEL_37;
      }
      else
      {
        ++v22;
        v21 += 6;
        ++v23;
      }
    }
    ++v22;
  }
LABEL_37:
  if ( !*(_BYTE *)(v6 + 4524) )
  {
    sub_2FA50((__int64)v11, v22);
    v11 = *(_QWORD **)(v6 + 4432);
  }
  if ( *(_BYTE *)(v6 + 4500) )
    memcpy(*(void **)(v6 + 4440), v11, 12LL * v22);
  else
    sub_2F6D0((__int64)v11, *(_QWORD *)(v6 + 4440), v22);
  v24 = *(signed int *)(v5 + 8);
  v25 = *(void **)(v6 + 4416);
  if ( *(_DWORD *)(v6 + 4424) < (signed int)v24 )
  {
    *(_DWORD *)(v6 + 4424) = v24;
    v79 = sub_2F490(v25, v24, 0x20uLL);
    v24 = *(signed int *)(v5 + 8);
    v25 = v79;
    *(_QWORD *)(v6 + 4416) = v79;
  }
  memcpy(v25, *(const void **)(v5 + 24), 32 * v24);
  if ( v22 )
  {
    v26 = (unsigned int)(v22 - 1);
    v27 = 0LL;
    v22 = 0;
    v80 = (char *)(4 * (3 * v26 + 3));
    src = *(char **)(v6 + 4440);
    do
    {
      v28 = &v27[(_QWORD)src];
      v29 = *(_WORD *)&v27[(_QWORD)src + 8];
      if ( *(_WORD *)&v27[(_QWORD)src + 10] )
      {
        v30 = 0;
        v31 = 32LL * v29;
        v32 = 32LL * v22;
        v33 = *(_QWORD *)(v6 + 4416);
        do
        {
          v36 = (__m128i *)(v33 + v32);
          if ( v29 == -1 )
          {
            v37 = 57343LL;
            *v36 = _mm_loadu_si128((const __m128i *)(v6 + 128));
            v36[1] = _mm_loadu_si128((const __m128i *)(v6 + 144));
            if ( !v30 )
              v37 = *(unsigned int *)v28;
            v36->m128i_i64[0] = v37;
          }
          else
          {
            v34 = *(_QWORD *)(v5 + 24);
            *v36 = _mm_loadu_si128((const __m128i *)(v34 + v31));
            v36[1] = _mm_loadu_si128((const __m128i *)(v34 + v31 + 16));
            v35 = v36[1].m128i_i32[2];
            if ( v35 )
              v36[1].m128i_i32[2] = v35 - (v22 - v29);
            if ( v30 )
            {
              v36->m128i_i64[0] = 57343LL;
            }
            else
            {
              v38 = *((_DWORD *)v28 + 1);
              if ( *(_DWORD *)v28 != v38 )
                v36->m128i_i64[0] = v38;
            }
          }
          ++v30;
          ++v22;
          v32 += 32LL;
          v28 = &v27[(_QWORD)src];
        }
        while ( *(unsigned __int16 *)&v27[(_QWORD)src + 10] > v30 );
      }
      v27 += 12;
    }
    while ( v80 != v27 );
  }
  v39 = *(_DWORD *)(v6 + 416);
  if ( v39 != v22 )
    __assert_fail("opos == term->cols", "terminal.c", 0x1649u, "term_bidi_line");
  v40 = *(char **)(v6 + 4456);
  v41 = *(_BYTE *)(v5 + 32);
  v42 = *(signed int *)(v5 + 8);
  v85 = *(_QWORD *)(v6 + 4440);
  v81 = *(void **)(v6 + 4416);
  v43 = *(void **)(v5 + 24);
  v44 = *(_QWORD *)(v6 + 4472);
  srca = v43;
  if ( !v40 || v84 >= v44 )
  {
    v60 = sub_2F4F0(v40, (unsigned __int64 *)(v6 + 4472), 0x20uLL, v84, 1uLL, 0);
    v61 = *(_QWORD *)(v6 + 4472);
    v62 = *(void **)(v6 + 4464);
    *(_QWORD *)(v6 + 4456) = v60;
    v63 = (char *)sub_2F490(v62, v61, 0x20uLL);
    v64 = *(_QWORD *)(v6 + 4472);
    *(_QWORD *)(v6 + 4464) = v63;
    v40 = *(char **)(v6 + 4456);
    if ( v64 > v44 )
    {
      v65 = 32 * v44;
      v66 = &v40[v65];
      v67 = &v63[v65];
      v68 = (signed __int64)&v63[32 * v64];
      do
      {
        *((_QWORD *)v67 + 1) = 0LL;
        *((_QWORD *)v66 + 1) = 0LL;
        v67 += 32;
        *((_DWORD *)v67 - 8) = -1;
        *(_DWORD *)v66 = -1;
        v66 += 32;
        *(v66 - 28) = 0;
        *(v67 - 28) = 0;
        *((_QWORD *)v67 - 2) = 0LL;
        *((_QWORD *)v66 - 2) = 0LL;
        *((_QWORD *)v67 - 1) = 0LL;
        *((_QWORD *)v66 - 1) = 0LL;
      }
      while ( (char *)v68 != v67 );
    }
  }
  v45 = 32LL * v84;
  sub_2F4D0(*(void **)&v40[32 * v84 + 8]);
  sub_2F4D0(*(void **)(*(_QWORD *)(v6 + 4464) + 32LL * v84 + 8));
  sub_2F4D0(*(void **)(*(_QWORD *)(v6 + 4464) + 32LL * v84 + 16));
  sub_2F4D0(*(void **)(*(_QWORD *)(v6 + 4464) + 32LL * v84 + 24));
  v46 = *(_QWORD *)(v6 + 4456) + 32LL * v84;
  *(_BYTE *)(v46 + 4) = v41;
  *(_DWORD *)v46 = v39;
  *(_QWORD *)(v46 + 8) = sub_2F450(v42, 0x20uLL, 0LL);
  v47 = v42;
  v48 = 32 * v42;
  v49 = v45 + *(_QWORD *)(v6 + 4464);
  *(_BYTE *)(v49 + 4) = v41;
  *(_DWORD *)v49 = v39;
  *(_QWORD *)(v49 + 8) = sub_2F450(v47, 0x20uLL, 0LL);
  v50 = *(_QWORD *)(v6 + 4464);
  *(_QWORD *)(v45 + v50 + 16) = sub_2F450(v39, 4uLL, 0LL);
  v51 = *(_QWORD *)(v6 + 4464);
  *(_QWORD *)(v45 + v51 + 24) = sub_2F450(v39, 4uLL, 0LL);
  memcpy(*(void **)(*(_QWORD *)(v6 + 4456) + v45 + 8), srca, v48);
  memcpy(*(void **)(*(_QWORD *)(v6 + 4464) + v45 + 8), v81, v48);
  memset(*(void **)(*(_QWORD *)(v6 + 4464) + v45 + 16), 0, 4LL * v39);
  memset(*(void **)(*(_QWORD *)(v6 + 4464) + v45 + 24), 0, 4LL * v39);
  if ( v39 )
  {
    v52 = 0LL;
    v53 = (unsigned __int16 *)(v85 + 10);
    do
    {
      while ( 1 )
      {
        v54 = *(v53 - 1);
        if ( (_DWORD)v54 != 0xFFFF )
          break;
        v69 = *v53;
        v53 += 6;
        v52 += v69;
        if ( v39 <= v52 )
          return *(_QWORD *)(v6 + 4416);
      }
      if ( v39 <= (signed int)v54 )
        __assert_fail("0 <= p && p < width", "terminal.c", 0x15C3u, "term_bidi_cache_store");
      v55 = *v53;
      if ( (_WORD)v55 )
      {
        v56 = 0LL;
        v57 = v45 + *(_QWORD *)(v6 + 4464);
        v58 = *(_QWORD *)(v57 + 24) + 4 * v52;
        v59 = *(_QWORD *)(v57 + 16) + 4 * v54;
        do
        {
          *(_DWORD *)(v58 + 4 * v56) = v54 + v56;
          *(_DWORD *)(v59 + 4 * v56) = v52 + v56;
          ++v56;
        }
        while ( (unsigned int)(unsigned __int16)v55 - 1 + 1LL != v56 );
      }
      v52 += v55;
      v53 += 6;
    }
    while ( v39 > v52 );
  }
  return *(_QWORD *)(v6 + 4416);
}

__int64 __fastcall sub_8B960(__int64 a1, __int64 a2)
{
  signed int v2; // ebp
  __int64 v3; // rax
  int v4; // er11
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // r10
  int v8; // er9
  __int64 v9; // r10

  v2 = (unsigned __int64)sub_9AFB0((__int64 *)a2) - 1;
  if ( v2 >= 0 )
  {
    do
    {
      v3 = sub_9B010((__int64 *)a2, v2);
      v4 = *(_DWORD *)(v3 + 4);
      if ( v4 <= 0 )
      {
        v8 = 0;
      }
      else
      {
        v5 = *(_QWORD *)(a1 + 168);
        v6 = *(_QWORD *)(a1 + 160);
        v7 = *(_QWORD *)(v3 + 24);
        while ( sub_8B030(v7, a1 + 160, v6, v5) )
        {
          v7 = v9 + 32;
          if ( v8 + 1 == v4 )
            goto LABEL_7;
        }
      }
      if ( v8 != v4 )
        break;
LABEL_7:
      --v2;
    }
    while ( v2 != -1 );
  }
  return (unsigned int)v2;
}

__int64 __fastcall sub_8BA10(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 168) = *(_DWORD *)(a1 + 100) & 0x3FFFF;
  result = *(unsigned int *)(a1 + 112);
  *(_DWORD *)(a1 + 180) = result;
  return result;
}

__int64 __fastcall sub_8BA30(__int64 a1)
{
  __int64 v1; // rax
  int v2; // edx
  int v3; // eax
  char v4; // cl
  __int64 v5; // rax
  char v6; // cl
  __int64 v7; // rax
  bool v8; // zf
  __m128i v9; // xmm0
  __int64 result; // rax
  __m128i v11; // xmm0

  v1 = *(_QWORD *)(a1 + 240);
  v2 = *(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 232) = v1;
  if ( SHIDWORD(v1) >= v2 )
    *(_DWORD *)(a1 + 236) = v2 - 1;
  v3 = *(_DWORD *)(a1 + 412);
  if ( *(_DWORD *)(a1 + 232) >= v3 )
    *(_DWORD *)(a1 + 232) = v3 - 1;
  v4 = *(_BYTE *)(a1 + 272);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 104);
  v5 = *(_QWORD *)(a1 + 116);
  *(_BYTE *)(a1 + 305) = v4;
  v6 = *(_BYTE *)(a1 + 273);
  *(_QWORD *)(a1 + 108) = v5;
  v7 = *(signed int *)(a1 + 264);
  *(_BYTE *)(a1 + 258) = v6;
  *(_DWORD *)(a1 + 260) = v7;
  if ( v6 && *(_DWORD *)(a1 + 236) < v2 - 1 )
    *(_BYTE *)(a1 + 258) = 0;
  v8 = *(_BYTE *)(a1 + 290) == 0;
  v9 = _mm_loadu_si128((const __m128i *)(a1 + 128));
  *(_DWORD *)(a1 + 4 * v7 + 468) = *(_DWORD *)(a1 + 268);
  result = *(unsigned int *)(a1 + 300);
  *(__m128i *)(a1 + 160) = v9;
  v11 = _mm_loadu_si128((const __m128i *)(a1 + 144));
  *(_DWORD *)(a1 + 296) = result;
  *(__m128i *)(a1 + 176) = v11;
  if ( !v8 )
    result = sub_8BA10(a1);
  return result;
}

char __fastcall sub_8BB10(_DWORD *a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  bool v4; // sf
  unsigned __int8 v5; // of
  char result; // al

  v3 = a1[943];
  v5 = __OFSUB__((_DWORD)a2, a1[942]);
  v4 = (signed int)a2 - a1[942] < 0;
  if ( (_DWORD)a2 == a1[942] )
  {
    v5 = __OFSUB__(HIDWORD(a2), v3);
    v4 = HIDWORD(a2) - v3 < 0;
  }
  result = v4 ^ v5;
  if ( v4 ^ v5 )
  {
    if ( a1[940] != (_DWORD)a3 )
    {
      result = a1[940] < (signed int)a3;
      if ( !result )
        return result;
      goto LABEL_6;
    }
    result = a1[941] < SHIDWORD(a3);
    if ( result )
    {
LABEL_6:
      a1[937] = 0;
      *((_QWORD *)a1 + 470) = 0LL;
      *((_QWORD *)a1 + 471) = 0LL;
      return result;
    }
  }
  return result;
}

void __fastcall sub_8BB80(__int64 a1, int a2)
{
  __int64 v2; // r8
  signed __int64 v3; // rcx
  int v4; // edx
  int v5; // esi
  int v6; // er9
  signed __int64 v7; // rax
  int v8; // edx

  if ( a2 < 0 || *(_DWORD *)(a1 + 4) <= a2 )
    __assert_fail("col >= 0 && col < line->cols", "terminal.c", 0x132u, "clear_cc");
  v2 = *(_QWORD *)(a1 + 24);
  v3 = v2 + 32LL * a2;
  v4 = *(_DWORD *)(v3 + 24);
  if ( v4 )
  {
    v5 = v4 + a2;
    v6 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v5;
    while ( 1 )
    {
      v7 = v2 + 32LL * v5;
      v8 = *(_DWORD *)(v7 + 24);
      if ( !v8 )
        break;
      v5 += v8;
    }
    if ( v6 )
      *(_DWORD *)(v7 + 24) = v6 - v5;
    *(_DWORD *)(v3 + 24) = 0;
  }
}

__int64 __fastcall sub_8BC00(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r12
  char *v4; // rax
  signed __int64 v5; // r14
  __int64 v6; // r13
  int v7; // ebp
  signed __int64 v8; // rcx
  signed __int64 v9; // rbx
  char *v10; // r8
  int v11; // edx
  int v12; // er14
  unsigned __int64 v13; // r15
  signed __int64 v14; // rax
  int v15; // ecx
  int v16; // edx
  __int64 result; // rax
  unsigned __int64 v18; // rt1
  void *v19; // rdi
  unsigned __int64 v20; // rcx
  char *v21; // rdx
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // [rsp+0h] [rbp-48h]
  unsigned __int64 v24; // [rsp+8h] [rbp-40h]

  v24 = __readfsqword(0x28u);
  if ( a2 < 0 || (v3 = a1, *(_DWORD *)(a1 + 4) <= a2) )
    __assert_fail("col >= 0 && col < line->cols", "terminal.c", 0xD8u, "add_cc");
  v4 = *(char **)(a1 + 24);
  v5 = 32LL * a2;
  if ( *(_QWORD *)&v4[v5] != 65533LL )
  {
    v6 = a3;
    v7 = a2;
    v8 = 32LL;
    while ( 1 )
    {
      v9 = 32LL * v7;
      v10 = &v4[v9];
      v11 = *(_DWORD *)&v4[v9 + 24];
      if ( !v11 )
        break;
      v7 += v11;
      if ( !--v8 )
      {
        sub_8BB80(a1, a2);
        *(_QWORD *)(*(_QWORD *)(a1 + 24) + v5) = 65533LL;
        goto LABEL_11;
      }
    }
    v12 = *(_DWORD *)(a1 + 16);
    v13 = v12;
    if ( !v12 )
    {
      v13 = *(signed int *)(a1 + 8);
      v19 = *(void **)(a1 + 24);
      v23 = *(signed int *)(v3 + 8);
      v12 = v13;
      v4 = (char *)sub_2F4F0(v19, &v23, 0x20uLL, v13, 1uLL, 0);
      v20 = v23;
      *(_QWORD *)(v3 + 24) = v4;
      if ( v20 > 0x7FFFFFFF )
LABEL_22:
        __assert_fail("tmpsize <= INT_MAX", "terminal.c", 0x10Cu, "add_cc");
      *(_DWORD *)(v3 + 8) = v20;
      *(_DWORD *)(v3 + 16) = v13;
      if ( (signed int)v20 > (signed int)v13 )
      {
        v21 = &v4[32 * v13 + 24];
        v22 = 32 * (v13 + (unsigned int)(v20 - 1 - v13));
        while ( v21 != &v4[v22 + 24] )
        {
          *(_DWORD *)v21 = 1;
          v21 += 32;
        }
        *(_DWORD *)&v4[v22 + 24] = 0;
      }
      v10 = &v4[v9];
    }
    v14 = (signed __int64)&v4[32 * v13];
    v15 = *(_DWORD *)(v14 + 24);
    v16 = v15 + v12;
    if ( !v15 )
      v16 = 0;
    *(_DWORD *)(v3 + 16) = v16;
    *(_DWORD *)(v14 + 24) = 0;
    *(_QWORD *)v14 = v6;
    *((_DWORD *)v10 + 6) = v12 - v7;
  }
LABEL_11:
  v18 = __readfsqword(0x28u);
  result = v18 ^ v24;
  if ( v18 != v24 )
    goto LABEL_22;
  return result;
}

unsigned __int64 __fastcall sub_8BDD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rbp
  __int64 i; // rbp
  __int64 v10; // [rsp+8h] [rbp-60h]
  __int64 v11; // [rsp+10h] [rbp-58h]
  unsigned __int64 v12; // [rsp+38h] [rbp-30h]

  v6 = a3;
  v7 = a2 - *(_QWORD *)(a3 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  v12 = __readfsqword(0x28u);
  for ( i = v7 >> 5; ; sub_8BC00(v6, i, v11) )
  {
    v10 = 0LL;
    sub_8AA70(a1, &v11, v6, &v10);
    if ( !v11 )
      break;
  }
  return __readfsqword(0x28u) ^ v12;
}

__int64 __fastcall sub_8BE60(__int64 a1, int a2, const __m128i *a3)
{
  const __m128i *v3; // rbx
  __m128i *v4; // rax
  __int64 result; // rax

  v3 = a3;
  sub_8BB80(a1, a2);
  v4 = (__m128i *)(*(_QWORD *)(a1 + 24) + 32LL * a2);
  *v4 = _mm_loadu_si128(v3);
  v4[1] = _mm_loadu_si128(v3 + 1);
  v4[1].m128i_i32[2] = 0;
  for ( result = v3[1].m128i_i32[2]; (_DWORD)result; result = v3[1].m128i_i32[2] )
  {
    v3 += 2 * result;
    sub_8BC00(a1, a2, v3->m128i_i64[0]);
  }
  return result;
}

void __fastcall sub_8BED0(const __m128i *a1, __int64 a2, int a3)
{
  int v3; // er12
  int v4; // ebp
  __int64 v5; // rbx
  int v6; // er14
  const __m128i *v7; // r15
  int v8; // er13
  int v9; // esi
  void *v10; // rdi
  int v11; // esi
  void *v12; // rax
  int v13; // edx
  __int64 v14; // rcx
  _DWORD *v15; // rax
  signed __int64 v16; // rcx
  int v17; // eax
  __int64 v18; // rdx
  signed __int64 v19; // rax
  unsigned __int64 v20; // rdx
  void *v21; // rdi
  int v22; // esi
  char *v23; // rax

  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 != a3 )
  {
    v4 = a3;
    v5 = a2;
    v6 = a3 - v3;
    v7 = a1;
    if ( v3 <= a3 )
    {
      v21 = *(void **)(a2 + 24);
      v22 = v6 + *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v5 + 8) = v22;
      v23 = (char *)sub_2F490(v21, v22, 0x20uLL);
      *(_QWORD *)(v5 + 24) = v23;
      *(_DWORD *)(v5 + 4) = v4;
      if ( v3 < v4 )
        memmove(&v23[32 * v4], &v23[32 * v3], 32LL * (*(_DWORD *)(v5 + 8) - v4));
    }
    else
    {
      v8 = a3;
      do
      {
        v9 = v8++;
        sub_8BB80(v5, v9);
      }
      while ( v3 != v8 );
      memmove(
        (void *)(32LL * v4 + *(_QWORD *)(v5 + 24)),
        (const void *)(*(_QWORD *)(v5 + 24) + 32LL * v3),
        32LL * (*(_DWORD *)(v5 + 8) - *(_DWORD *)(v5 + 4)));
      v10 = *(void **)(v5 + 24);
      v11 = v6 + *(_DWORD *)(v5 + 8);
      *(_DWORD *)(v5 + 8) = v11;
      v12 = sub_2F490(v10, v11, 0x20uLL);
      *(_DWORD *)(v5 + 4) = v4;
      *(_QWORD *)(v5 + 24) = v12;
    }
    v13 = v4;
    if ( v3 <= v4 )
      v13 = v3;
    if ( v13 > 0 )
    {
      v14 = *(_QWORD *)(v5 + 24);
      v15 = (_DWORD *)(v14 + 24);
      v16 = v14 + 32LL * (unsigned int)(v13 - 1) + 56;
      do
      {
        if ( *v15 )
          *v15 += v6;
        v15 += 8;
      }
      while ( v15 != (_DWORD *)v16 );
    }
    v17 = *(_DWORD *)(v5 + 16);
    if ( v17 )
      *(_DWORD *)(v5 + 16) = v17 + v6;
    if ( v3 < v4 )
    {
      v18 = *(_QWORD *)(v5 + 24);
      v19 = v18 + 32LL * v3;
      v20 = v18 + 32 * (v3 + (unsigned __int64)(unsigned int)(v4 - 1 - v3)) + 32;
      do
      {
        v19 += 32LL;
        *(__m128i *)(v19 - 32) = _mm_loadu_si128(v7 + 8);
        *(__m128i *)(v19 - 16) = _mm_loadu_si128(v7 + 9);
      }
      while ( v19 != v20 );
    }
  }
}

__int64 __fastcall sub_8C080(const __m128i *a1, int a2, __int64 a3, int a4)
{
  unsigned int v4; // er14
  int v5; // ebp
  const __m128i *v6; // rbx
  __int64 v7; // r12
  int v8; // er13
  signed int v9; // esi
  __int64 *v10; // rdi
  __int64 result; // rax
  int v12; // edx
  __int64 v13; // ST08_8
  __int32 v14; // eax
  __int64 v15; // rax
  const char *v16; // r9

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( a2 >= 0 )
  {
    v7 = a1[1].m128i_i64[0];
    v8 = a2;
    goto LABEL_3;
  }
  if ( a4 )
    __assert_fail("!screen", "terminal.c", 0x45Du, "lineptr");
  if ( !a1[283].m128i_i8[13] || !a1[31].m128i_i32[3] || (v7 = a1[1].m128i_i64[1]) == 0 )
  {
    v8 = a2;
    goto LABEL_16;
  }
  v14 = a1[32].m128i_i32[0];
  v8 = a2 + v14;
  if ( -v14 > a2 )
  {
LABEL_16:
    v7 = a1->m128i_i64[1];
    v8 += sub_9AFB0((__int64 *)a1->m128i_i64[1]);
    v10 = (__int64 *)v7;
    v9 = v8;
    if ( v6->m128i_i64[1] != v7 )
      goto LABEL_4;
    goto LABEL_17;
  }
LABEL_3:
  v9 = v8;
  v10 = (__int64 *)v7;
  if ( v6->m128i_i64[1] != v7 )
  {
LABEL_4:
    result = sub_9B010(v10, v9);
    goto LABEL_5;
  }
LABEL_17:
  v15 = sub_9B010(v10, v9);
  if ( !v15 )
  {
    v16 = "cline";
LABEL_20:
    sub_1AF8B((__int64)v6, v5, v4, v7, v8, (__int64)v16);
  }
  result = (__int64)sub_8A820(v15);
LABEL_5:
  if ( !result )
  {
    v16 = "line";
    goto LABEL_20;
  }
  v12 = v6[26].m128i_i32[0];
  if ( v12 > *(_DWORD *)(result + 4) )
  {
    v13 = result;
    sub_8BED0(v6, result, v12);
    result = v13;
  }
  return result;
}

__int64 __fastcall sub_8C1C0(const __m128i *a1, _WORD *a2)
{
  int v2; // ebx
  __int64 result; // rax

  sub_8BED0(a1, (__int64)a2, a1[26].m128i_i32[0]);
  if ( a1[26].m128i_i32[0] > 0 )
  {
    v2 = 0;
    do
      sub_8BE60((__int64)a2, v2++, a1 + 10);
    while ( a1[26].m128i_i32[0] > v2 );
  }
  result = 0LL;
  *a2 = 0;
  return result;
}

__int64 __fastcall sub_8C220(__int64 a1, unsigned __int16 *a2, _BYTE *a3, unsigned int a4, unsigned int a5, _DWORD *a6, unsigned int a7, __int64 a8, __int64 a9)
{
  unsigned int v9; // er13
  __int64 v10; // r12
  unsigned int v11; // er14
  _DWORD *v12; // rbx
  __int64 result; // rax
  unsigned __int64 v14; // rt1
  __int64 v15; // rdi
  __int64 v16; // rdx
  __int64 v17; // [rsp+0h] [rbp-48h]
  unsigned __int64 v18; // [rsp+8h] [rbp-40h]

  v9 = a4;
  v10 = a1;
  v11 = a5;
  v18 = __readfsqword(0x28u);
  if ( *a6 == 57342 )
  {
    if ( !*a3 )
      __assert_fail("ldata->trusted", "terminal.c", 0x165Eu, "do_paint_draw");
    if ( a7 != 1 )
      __assert_fail("ccount == 1", "terminal.c", 0x165Fu, "do_paint_draw");
    if ( !(a8 & 0x400000) )
LABEL_10:
      __assert_fail("attr & ATTR_WIDE", "terminal.c", 0x1660u, "do_paint_draw");
    v15 = *(_QWORD *)(a1 + 4336);
    v16 = *a2;
    v17 = 137438953504LL;
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, __int64 *, signed __int64, _QWORD, __int64, _QWORD, signed __int64))(*(_QWORD *)v15 + 8LL))(
      v15,
      a4,
      a5,
      &v17,
      2LL,
      *(_QWORD *)(v10 + 136),
      v16,
      *(_QWORD *)(v10 + 144),
      137438953504LL);
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v10 + 4336) + 24LL))(
      *(_QWORD *)(v10 + 4336),
      v9,
      v11);
  }
  else
  {
    v12 = a6;
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _DWORD *, _QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 4336) + 8LL))(
      *(_QWORD *)(a1 + 4336),
      a4,
      a5,
      a6,
      a7,
      a8,
      *a2);
    if ( a8 & 0x60000000 )
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _DWORD *, _QWORD, __int64, _QWORD, __int64))(**(_QWORD **)(a1 + 4336)
                                                                                                 + 16LL))(
        *(_QWORD *)(a1 + 4336),
        v9,
        v11,
        v12,
        a7,
        a8,
        *a2,
        a9);
  }
  v14 = __readfsqword(0x28u);
  result = v14 ^ v18;
  if ( v14 != v18 )
    goto LABEL_10;
  return result;
}

void __fastcall sub_8C3C0(void **a1)
{
  sub_2F4D0(a1[3]);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_8C3E0(const __m128i *a1, __int64 a2, int a3)
{
  int v3; // er15
  const __m128i *v4; // rbx
  __int64 v5; // rbp
  signed __int64 v6; // r13
  __int64 v7; // r14
  __int64 v8; // r12
  unsigned int v9; // eax
  __int32 v11; // ecx
  unsigned __int64 v12; // rsi
  int v13; // eax
  int v14; // eax
  unsigned __int64 i; // rax
  __int64 v16; // rdx
  signed __int64 v17; // rax
  unsigned int v18; // er8
  __int64 v19; // rdx
  __int64 v20; // rsi
  __int16 v21; // ax
  __int64 v22; // rdx
  __int64 v23; // rsi
  unsigned int v24; // er15
  __int64 v25; // r13
  __int32 v26; // ecx
  int v27; // ecx
  __int16 v28; // ax
  __int64 v29; // rdi
  __int64 v30; // rsi
  int v31; // ecx
  __int16 v32; // r9
  char v33; // r10
  int v34; // ecx
  int v35; // eax
  int v36; // eax
  __int64 v37; // rdx
  signed __int64 v38; // rax
  __int64 v39; // rsi
  unsigned int v40; // er15
  void **v41; // rdi
  __int16 v42; // [rsp+8h] [rbp-40h]
  int v43; // [rsp+8h] [rbp-40h]
  int v44; // [rsp+Ch] [rbp-3Ch]
  int v45; // [rsp+Ch] [rbp-3Ch]

  v3 = a3;
  v4 = a1;
  v5 = (unsigned int)a2;
  v6 = a2 >> 32;
  v44 = sub_8A550((__int64)a1);
  v7 = HIDWORD(a2);
  v8 = sub_8C080(a1, a2, 6650LL, 0);
  v9 = a1[234].m128i_u32[3];
  if ( v9 == 1 )
  {
    v19 = *(_QWORD *)(v8 + 24);
    v20 = *(_QWORD *)(v19 + 32 * v6);
    if ( (signed int)v6 > 0 && v20 == 57343 )
      LODWORD(v20) = *(_DWORD *)(v19 + 32 * v6 - 32);
    v21 = sub_8A420((__int64)a1, v20);
    v42 = v21;
    if ( v3 == 1 )
    {
      v32 = *(_WORD *)v8;
      v33 = *(_BYTE *)(v8 + 32);
      v34 = a1[26].m128i_i32[0];
      while ( 1 )
      {
        while ( 1 )
        {
          v35 = v34 - 3;
          if ( !v33 )
            v35 = v34;
          v36 = ((v32 & 0x20u) < 1) + v35 - 1;
          if ( v36 < 0 )
            v36 = 0;
          if ( v36 - 1 <= (signed int)v7 )
            break;
          v37 = *(_QWORD *)(v8 + 24);
          v38 = 32 * ((signed int)v7 + 1LL);
          v39 = *(_QWORD *)(v37 + v38);
          if ( (signed int)v7 >= 0 && v39 == 57343 )
            LODWORD(v39) = *(_DWORD *)(v37 + v38 - 32);
          if ( (unsigned int)sub_8A420((__int64)a1, v39) != v42 )
            goto LABEL_4;
          v7 = (unsigned int)(v7 + 1);
        }
        v40 = v5 + 1;
        if ( (signed int)v5 + 1 >= a1[25].m128i_i32[3] || !(v32 & 0x10) )
          goto LABEL_4;
        v25 = sub_8C080(a1, v40, 6687LL, 0);
        if ( (unsigned int)sub_8A420((__int64)a1, **(_QWORD **)(v25 + 24)) != v42 )
          break;
        if ( *(_BYTE *)(v8 + 12) )
          sub_8C3C0((void **)v8);
        v34 = a1[26].m128i_i32[0];
        v32 = *(_WORD *)v25;
        v5 = v40;
        v33 = *(_BYTE *)(v25 + 32);
        v8 = v25;
        v7 = 0LL;
      }
LABEL_68:
      if ( *(_BYTE *)(v25 + 12) )
        sub_8C3C0((void **)v25);
    }
    else
    {
      v43 = v21;
      v45 = -v44;
      while ( (signed int)v7 <= 0 )
      {
LABEL_37:
        if ( (signed int)v5 <= v45 )
          goto LABEL_4;
        v24 = v5 - 1;
        v25 = sub_8C080(v4, (signed int)v5 - 1, 6714LL, 0);
        v26 = v4[26].m128i_i32[0];
        if ( *(_BYTE *)(v25 + 32) )
          v26 -= 3;
        v27 = ((*(_WORD *)v25 & 0x20u) < 1) + v26 - 1;
        v28 = *(_WORD *)v25 & 0x10;
        if ( v27 < 0 )
        {
          if ( !v28 )
            goto LABEL_4;
          v30 = *(_QWORD *)(*(_QWORD *)(v25 + 24) - 32LL);
        }
        else
        {
          if ( !v28 )
            goto LABEL_4;
          v29 = *(_QWORD *)(v25 + 24);
          v30 = *(_QWORD *)(v29 + 32LL * v27 - 32);
          if ( v27 > 1 && v30 == 57343 )
            LODWORD(v30) = *(_DWORD *)(v29 + 32LL * (v27 - 1) - 32);
        }
        if ( (unsigned int)sub_8A420((__int64)v4, v30) != v43 )
          goto LABEL_68;
        v7 = (unsigned int)(v31 - 1);
        if ( *(_BYTE *)(v8 + 12) )
        {
          v41 = (void **)v8;
          v5 = v24;
          v8 = v25;
          sub_8C3C0(v41);
        }
        else
        {
          v5 = v24;
          v8 = v25;
        }
      }
      while ( 1 )
      {
        v22 = *(_QWORD *)(v8 + 24);
        v23 = *(_QWORD *)(v22 + 32LL * (signed int)v7 - 32);
        if ( (_DWORD)v7 != 1 && v23 == 57343 )
          LODWORD(v23) = *(_DWORD *)(v22 + 32LL * ((signed int)v7 - 1) - 32);
        if ( (unsigned int)sub_8A420((__int64)v4, v23) != v43 )
          break;
        v7 = (unsigned int)(v7 - 1);
        if ( (signed int)v7 <= 0 )
          goto LABEL_37;
      }
    }
  }
  else if ( v9 < 1 )
  {
    if ( !(*(_WORD *)v8 & 0x10) )
    {
      v11 = a1[26].m128i_i32[0];
      v12 = *(_QWORD *)(v8 + 24);
      v13 = a1[26].m128i_i32[0];
      if ( *(_BYTE *)(v8 + 32) )
        v13 = v11 - 3;
      v14 = ((*(_WORD *)v8 & 0x20u) < 1) + v13 - 1;
      if ( v14 < 0 )
        v14 = 0;
      for ( i = v12 + 32LL * v14; v12 < i; i -= 32LL )
      {
        v16 = *(_QWORD *)(i - 32);
        if ( v16 != 32 && (*(_QWORD *)(i - 32) & 0xFFFFFCFFLL) != 55328 )
          break;
        if ( *(_DWORD *)(i - 8) )
          break;
      }
      if ( i == v12 + 32LL * v11 )
        i -= 32LL;
      v17 = (signed __int64)(i - v12) >> 5;
      if ( v6 >= v17 )
      {
        v18 = v11 - 1;
        if ( v3 == -1 )
          v18 = v17;
        v7 = v18;
      }
    }
  }
  else if ( v9 == 2 )
  {
    v7 = 0LL;
    if ( v3 != -1 )
      v7 = (unsigned int)(a1[26].m128i_i32[0] - 1);
  }
LABEL_4:
  if ( *(_BYTE *)(v8 + 12) )
    sub_8C3C0((void **)v8);
  return (v7 << 32) | v5;
}

unsigned __int64 __fastcall sub_8C7E0(const __m128i *a1)
{
  const __m128i *v1; // r15
  _DWORD *v2; // r13
  __int32 v3; // er14
  __int64 v4; // rax
  __int32 v5; // ebp
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  __int32 v9; // edx
  _QWORD *v10; // rax
  __int32 v11; // eax
  __int64 v12; // r14
  _DWORD *v13; // r15
  signed int v14; // er11
  __int64 v15; // rax
  __int64 v16; // r10
  __int64 v17; // rsi
  _BYTE *v18; // rbp
  __int64 v19; // r12
  __int64 v20; // r15
  char v21; // r9
  char v22; // r10
  char v23; // cl
  __int64 v24; // rdi
  __int64 v25; // r13
  unsigned __int64 v26; // rbx
  unsigned __int64 v27; // rbx
  _QWORD *v28; // rax
  char v29; // ST48_1
  char v30; // ST7A_1
  char v31; // ST79_1
  int v32; // eax
  int v33; // edx
  __int64 v34; // rax
  int v35; // eax
  int v36; // edi
  int v37; // er11
  bool v38; // di
  bool v39; // sf
  unsigned __int8 v40; // of
  int v41; // edi
  char v42; // al
  __int64 v43; // rax
  bool v44; // zf
  bool v45; // al
  __int64 v46; // rdx
  __int64 v47; // rcx
  _QWORD *v48; // rdi
  signed __int64 v49; // rbx
  unsigned __int64 v50; // r10
  _DWORD *v51; // rax
  __int32 v52; // eax
  signed __int64 v53; // rdi
  int v54; // eax
  int v55; // er9
  signed __int64 v56; // rax
  char *v57; // rbx
  const __m128i *v58; // r12
  _QWORD *v59; // rax
  __int64 v60; // r13
  __int64 v61; // rcx
  char v62; // al
  __int64 v63; // rbp
  __int64 v64; // rdx
  _DWORD *v65; // rax
  unsigned __int64 v66; // r11
  const __m128i *v67; // rbp
  __int64 v68; // rdx
  char *v69; // rax
  signed int v70; // er12
  unsigned __int64 v71; // r15
  signed __int64 v72; // r13
  __int64 v73; // rbx
  unsigned __int64 v74; // rcx
  signed __int64 v75; // rdx
  bool v76; // bl
  int v77; // er9
  __int64 v78; // r10
  bool v79; // al
  bool v80; // bl
  void **v81; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v83; // rt1
  __int64 v84; // rcx
  __int64 v85; // rsi
  signed __int64 v86; // rax
  char v87; // r9
  int v88; // ebp
  int v89; // ecx
  __int64 v90; // rdx
  __int64 v91; // rdi
  __int64 v92; // r8
  __int32 v93; // edi
  _QWORD *v94; // rdx
  char v95; // [rsp+4h] [rbp-F4h]
  int v96; // [rsp+4h] [rbp-F4h]
  char v97; // [rsp+8h] [rbp-F0h]
  __int64 v98; // [rsp+8h] [rbp-F0h]
  char v99; // [rsp+10h] [rbp-E8h]
  signed int v100; // [rsp+10h] [rbp-E8h]
  __int64 v101; // [rsp+10h] [rbp-E8h]
  char v102; // [rsp+18h] [rbp-E0h]
  signed __int64 v103; // [rsp+20h] [rbp-D8h]
  __int64 v104; // [rsp+28h] [rbp-D0h]
  signed __int64 v105; // [rsp+30h] [rbp-C8h]
  __int64 v106; // [rsp+38h] [rbp-C0h]
  char v107; // [rsp+38h] [rbp-C0h]
  unsigned __int8 v108; // [rsp+40h] [rbp-B8h]
  __int64 v109; // [rsp+48h] [rbp-B0h]
  _BYTE *v110; // [rsp+50h] [rbp-A8h]
  char v111; // [rsp+58h] [rbp-A0h]
  bool v112; // [rsp+58h] [rbp-A0h]
  bool v113; // [rsp+59h] [rbp-9Fh]
  char v114; // [rsp+5Ah] [rbp-9Eh]
  unsigned __int8 v115; // [rsp+5Bh] [rbp-9Dh]
  int v116; // [rsp+5Ch] [rbp-9Ch]
  unsigned __int8 v117; // [rsp+5Ch] [rbp-9Ch]
  _DWORD *v118; // [rsp+60h] [rbp-98h]
  __int64 v119; // [rsp+60h] [rbp-98h]
  __int64 v120; // [rsp+68h] [rbp-90h]
  unsigned __int8 v121; // [rsp+72h] [rbp-86h]
  unsigned __int8 v122; // [rsp+73h] [rbp-85h]
  unsigned int v123; // [rsp+74h] [rbp-84h]
  __int64 v124; // [rsp+78h] [rbp-80h]
  __int32 v125; // [rsp+84h] [rbp-74h]
  const __m128i *v126; // [rsp+88h] [rbp-70h]
  __int64 v127; // [rsp+90h] [rbp-68h]
  bool v128; // [rsp+9Ah] [rbp-5Eh]
  char v129; // [rsp+9Bh] [rbp-5Dh]
  __int32 v130; // [rsp+9Ch] [rbp-5Ch]
  __int64 v131; // [rsp+A0h] [rbp-58h]
  int v132; // [rsp+A8h] [rbp-50h]
  int v133; // [rsp+ACh] [rbp-4Ch]
  __int64 v134; // [rsp+B0h] [rbp-48h]
  unsigned __int64 v135; // [rsp+B8h] [rbp-40h]

  v1 = a1;
  v135 = __readfsqword(0x28u);
  v134 = 1024LL;
  v2 = sub_2F450(0x400uLL, 4uLL, 0LL);
  v110 = sub_2F450(a1[26].m128i_i32[0], 0x20uLL, 0LL);
  v132 = 0;
  v133 = (v1[17].m128i_i8[2] != v1[26].m128i_i8[9]) << 20;
  if ( !a1[18].m128i_i8[0] )
    goto LABEL_5;
  v132 = 0x20000000;
  if ( !a1[26].m128i_i8[8] || (v132 = 0x40000000, a1[18].m128i_i8[3]) )
  {
    if ( !a1[16].m128i_i8[2] )
      goto LABEL_5;
    goto LABEL_180;
  }
  v132 = (a1[282].m128i_i8[14] == 0) << 30;
  if ( a1[16].m128i_i8[2] )
LABEL_180:
    v132 |= 0x10000000u;
LABEL_5:
  v3 = a1[14].m128i_i32[2] - a1[2].m128i_i32[0];
  v130 = a1[14].m128i_i32[2] - a1[2].m128i_i32[0];
  v4 = sub_8C080(a1, a1[14].m128i_i32[2], 5792LL, 0);
  v5 = a1[14].m128i_i32[3];
  v6 = v4;
  v125 = a1[14].m128i_i32[3];
  v7 = sub_8B0A0((__int64)a1, v4, (unsigned int)v3);
  if ( v7 )
    v125 = *(_DWORD *)(*(_QWORD *)(a1[279].m128i_i64[0] + 32LL * v3 + 16) + 4LL * v5);
  else
    v7 = *(_QWORD *)(v6 + 24);
  if ( v125 > 0 )
    v125 -= *(_QWORD *)(v7 + 32LL * v125) == 57343LL;
  if ( *(_BYTE *)(v6 + 12) )
    sub_8C3C0((void **)v6);
  v8 = a1[3].m128i_i32[1];
  if ( (signed int)v8 < 0 )
    goto LABEL_18;
  v9 = a1[3].m128i_i32[0];
  if ( a1[3].m128i_i32[2] == v132 && (_DWORD)v8 == v130 && v125 == v9 )
    goto LABEL_18;
  v10 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2].m128i_i64[1] + 8 * v8) + 24LL) + 32LL * v9);
  if ( v9 > 0 && *v10 == 57343LL )
  {
    v93 = a1[26].m128i_i32[0];
    *(v10 - 3) |= 0x3FFFFuLL;
    if ( v93 - 1 <= v9 )
      goto LABEL_17;
LABEL_178:
    if ( v10[4] == 57343LL )
      v10[5] |= 0x3FFFFuLL;
    goto LABEL_17;
  }
  if ( a1[26].m128i_i32[0] - 1 > v9 )
    goto LABEL_178;
LABEL_17:
  v10[1] |= 0x3FFFFuLL;
  v1[3].m128i_i32[2] = 0;
LABEL_18:
  v11 = v1[25].m128i_i32[3];
  v1[3].m128i_i64[0] = -1LL;
  if ( v11 <= 0 )
    goto LABEL_156;
  v12 = (__int64)v1;
  v131 = 0LL;
  v13 = v2;
  do
  {
    v116 = *(_DWORD *)(v12 + 32) + v131;
    v127 = sub_8C080((const __m128i *)v12, v116, 5846LL, 0);
    v109 = sub_8B0A0(v12, v127, (unsigned int)v131);
    if ( v109 )
    {
      v106 = *(_QWORD *)(*(_QWORD *)(v12 + 4464) + 32 * v131 + 24);
    }
    else
    {
      v106 = 0LL;
      v109 = *(_QWORD *)(v127 + 24);
    }
    v14 = *(_DWORD *)(v12 + 416);
    v103 = 8 * v131;
    v15 = *(_QWORD *)(v12 + 40);
    v16 = *(_QWORD *)(v15 + 8 * v131);
    if ( v14 <= 0 )
      goto LABEL_79;
    v17 = *(_QWORD *)(v15 + 8 * v131);
    v118 = v13;
    v18 = v110;
    v19 = v109;
    v20 = 0LL;
    do
    {
      v33 = v20;
      v35 = v20;
      if ( v106 )
        v35 = *(_DWORD *)(v106 + 4 * v20);
      v25 = *(_QWORD *)v19;
      v26 = *(_QWORD *)(v19 + 8);
      if ( !*(_BYTE *)(v12 + 4481) )
        v26 = (unsigned int)v26 & 0xFFFC0000 | 0x20500LL;
      if ( !*(_BYTE *)(v12 + 4579) )
      {
        if ( (v26 & 0x1FF) - 16 <= 0xEF )
        {
          v26 = (unsigned int)v26 & 0xFFFFFE00;
          BYTE1(v26) |= 1u;
        }
        if ( ((v26 >> 9) & 0x1FF) - 16 <= 0xEF )
          v26 = (unsigned int)v26 & 0xFFFC01FF | 0x20400LL;
      }
      if ( *(_BYTE *)(v12 + 4580) )
      {
        v21 = *(_BYTE *)(v19 + 22);
        v22 = *(_BYTE *)(v19 + 23);
        v95 = *(_BYTE *)(v19 + 16);
        v99 = *(_BYTE *)(v19 + 19);
        v97 = *(_BYTE *)(v19 + 17);
        v102 = *(_BYTE *)(v19 + 21);
        v111 = *(_BYTE *)(v19 + 18);
        v23 = *(_BYTE *)(v19 + 20);
      }
      else
      {
        v22 = 0;
        v21 = 0;
        v102 = 0;
        v23 = 0;
        v99 = 0;
        v111 = 0;
        v97 = 0;
        v95 = 0;
      }
      v24 = (unsigned int)v25 & 0xFFFFFF00;
      switch ( v24 )
      {
        case 55552LL:
          v25 = *(signed int *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v25 + 3092);
          break;
        case 55808LL:
          v25 = *(signed int *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v25 + 20);
          break;
        case 55296LL:
          v25 = *(signed int *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v25 + 1044);
          break;
      }
      if ( v14 - 1 > (signed int)v20 && *(_QWORD *)(v19 + 32) == 57343LL )
        v26 |= 0x400000uLL;
      v27 = v133 ^ v26;
      if ( (unsigned int)(*(_DWORD *)(v12 + 3748) - 2) <= 1 )
      {
        v36 = *(_DWORD *)(v12 + 3760);
        v37 = *(_DWORD *)(v12 + 3764);
        if ( *(_DWORD *)(v12 + 3752) )
        {
          if ( v35 < v37 || v116 < v36 )
            goto LABEL_33;
          v42 = v35 < *(_DWORD *)(v12 + 3772) && v116 <= *(_DWORD *)(v12 + 3768);
        }
        else
        {
          if ( v116 == v36 )
            v38 = v35 >= v37;
          else
            v38 = v116 > v36;
          if ( !v38 )
            goto LABEL_33;
          v40 = __OFSUB__(v116, *(_DWORD *)(v12 + 3768));
          v39 = v116 - *(_DWORD *)(v12 + 3768) < 0;
          v41 = *(_DWORD *)(v12 + 3772);
          if ( v116 == *(_DWORD *)(v12 + 3768) )
          {
            v40 = __OFSUB__(v35, v41);
            v39 = v35 - v41 < 0;
          }
          v42 = v39 ^ v40;
        }
        if ( v42 )
          v27 ^= 0x100000uLL;
      }
LABEL_33:
      if ( *(_BYTE *)(v12 + 293) && v27 & 0x200000 )
      {
        if ( *(_BYTE *)(v12 + 424) && *(_BYTE *)(v12 + 292) )
          v25 = *(signed int *)(*(_QWORD *)(v12 + 4352) + 1172LL);
        v27 = (unsigned int)v27 & 0xFFDFFFFF;
      }
      v28 = (_QWORD *)(32 * v20 + *(_QWORD *)(v17 + 24));
      if ( *v28 != v25 || (v43 = v28[1], (v43 & 0xFFFFFFFF0F7FFFFFLL) != v27) )
      {
        if ( !(v27 & 0x400000) )
        {
          v29 = v22;
          v30 = v21;
          v31 = v23;
          v32 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v12 + 4336) + 32LL))(
                  *(_QWORD *)(v12 + 4336),
                  (unsigned int)v25);
          v23 = v31;
          v21 = v30;
          v22 = v29;
          v33 = v20;
          if ( v32 == 2 )
          {
            v34 = *(_QWORD *)(v12 + 40);
            v27 |= 0x800000uLL;
          }
          else
          {
            v34 = *(_QWORD *)(v12 + 40);
          }
          v17 = *(_QWORD *)(v34 + v103);
        }
      }
      else if ( v43 & 0x800000 )
      {
        v27 |= 0x800000uLL;
      }
      if ( v125 == v33 && v130 == (_DWORD)v131 )
      {
        *(_DWORD *)(v12 + 48) = v33;
        v27 |= v132;
        *(_DWORD *)(v12 + 56) = v132;
        *(_DWORD *)(v12 + 52) = v131;
      }
      v18[20] = v23;
      v19 += 32LL;
      v18[22] = v21;
      v18[23] = v22;
      v18 += 32;
      *((_DWORD *)v18 - 2) = 0;
      *((_QWORD *)v18 - 3) = v27;
      *((_QWORD *)v18 - 4) = v25;
      *(v18 - 16) = v95;
      *(v18 - 15) = v97;
      *(v18 - 14) = v111;
      *(v18 - 13) = v99;
      *(v18 - 11) = v102;
      v14 = *(_DWORD *)(v12 + 416);
      ++v20;
    }
    while ( v14 > (signed int)v20 );
    v13 = v118;
    v16 = v17;
    if ( v14 > 0 )
    {
      v85 = *(_QWORD *)(v17 + 24);
      v86 = 8LL;
      v87 = 0;
      v88 = 0;
      v89 = 0;
      do
      {
        v90 = *(_QWORD *)(v85 + v86);
        v91 = *(_QWORD *)(v85 + v86 - 8);
        v92 = *(_QWORD *)&v110[v86 - 8];
        if ( (signed int)v90 >= 0 )
        {
          if ( v92 != v91 || (v90 & 0xFFFFFFFF0FFFFFFFLL) != *(_QWORD *)&v110[v86] )
          {
            if ( !v87 && v88 < v89 )
            {
              v94 = (_QWORD *)(v85 + 32LL * v88 + 8);
              do
              {
                *v94 |= 0x3FFFFuLL;
                v94 += 4;
              }
              while ( (_QWORD *)(v85 + 40 + 32 * (v88 + (unsigned __int64)(unsigned int)(v89 - 1 - v88))) != v94 );
              v90 = *(_QWORD *)(v85 + v86);
            }
          }
          else if ( !v87 )
          {
            goto LABEL_168;
          }
        }
        else
        {
          v88 = v89;
          if ( v92 == v91 )
          {
            v87 = 0;
            if ( *(_QWORD *)&v110[v86] == (v90 & 0xFFFFFFFF0FFFFFFFLL) )
              goto LABEL_168;
          }
        }
        v87 = 1;
        *(_QWORD *)(v85 + v86) = v90 | 0x3FFFF;
LABEL_168:
        ++v89;
        v86 += 32LL;
      }
      while ( v14 != v89 );
    }
LABEL_79:
    v44 = *(_WORD *)v16 == *(_WORD *)v127;
    *(_WORD *)v16 = *(_WORD *)v127;
    v112 = !v44;
    v124 = *(_QWORD *)(v12 + 176);
    v114 = *(_BYTE *)(v12 + 176);
    v107 = *(_BYTE *)(v12 + 177);
    v108 = *(_BYTE *)(v12 + 178);
    v115 = *(_BYTE *)(v12 + 179);
    v117 = *(_BYTE *)(v12 + 180);
    v121 = *(_BYTE *)(v12 + 181);
    v122 = *(_BYTE *)(v12 + 182);
    LOBYTE(v120) = *(_BYTE *)(v12 + 183);
    if ( v14 <= 0 )
      goto LABEL_153;
    v113 = !v44;
    v128 = 0;
    v100 = 0;
    v123 = 0;
    v104 = 0LL;
    v119 = 0LL;
    v96 = 0;
    while ( 2 )
    {
      v56 = 32LL * v96;
      v57 = &v110[v56];
      v58 = (const __m128i *)(v56 + v109);
      v105 = 32LL * v96;
      v59 = (_QWORD *)(*(_QWORD *)(v16 + 24) + v56);
      v60 = *(_QWORD *)v57;
      v98 = *((_QWORD *)v57 + 1);
      v61 = v59[1];
      v48 = v59;
      v62 = v112;
      if ( ((unsigned int)v61 ^ (unsigned int)*((_QWORD *)v57 + 1)) & 0x400000 )
        v62 = 1;
      v112 = v62;
      v45 = 1;
      if ( v57[16] == v114
        && v57[17] == v107
        && v57[18] == v108
        && v57[19] == v115
        && v57[20] == v117
        && v57[21] == v121
        && v57[22] == v122
        && v57[23] == (_BYTE)v120 )
      {
        v45 = (*(signed int *)(v12 + 4296) & (v119 ^ v98)) != 0;
      }
      v63 = (unsigned int)v60 & 0xFFFFFC00;
      if ( v63 == 55296 || (v64 = 0LL, (v60 & 0xFFFFFE00) == 56320) )
        v64 = (unsigned int)v60 & 0xFFFFFF00;
      if ( v64 != v104 )
        v45 = 1;
      if ( !v58[1].m128i_i32[2] )
      {
        if ( v96 > 0 && v58[-1].m128i_i32[2] )
          v45 = 1;
        if ( v58->m128i_i64[0] != 57342 )
          goto LABEL_85;
        goto LABEL_119;
      }
      v45 = 1;
      if ( v58->m128i_i64[0] == 57342 )
        goto LABEL_119;
LABEL_85:
      if ( v96 <= 1 || v58[-2].m128i_i64[0] != 57343 || v58[-4].m128i_i64[0] != 57342 )
      {
        v46 = *(_QWORD *)(v12 + 4352);
        if ( *(_BYTE *)(v46 + 8) || v112 )
        {
LABEL_124:
          if ( v45 )
            goto LABEL_92;
          v49 = v100++;
          goto LABEL_100;
        }
        if ( *v48 == v60 )
          goto LABEL_122;
LABEL_90:
        if ( v113 == 1 )
          goto LABEL_124;
        goto LABEL_91;
      }
LABEL_119:
      v46 = *(_QWORD *)(v12 + 4352);
      if ( *(_BYTE *)(v46 + 8) )
        goto LABEL_92;
      v45 = 1;
      if ( v112 )
        goto LABEL_92;
      if ( *v48 != v60 )
        goto LABEL_90;
LABEL_122:
      if ( (v61 & 0xFFFFFFFF0FFFFFFFLL) != v98 )
      {
        if ( v113 == 1 )
          goto LABEL_124;
LABEL_91:
        if ( v100 != 1 )
          goto LABEL_124;
      }
LABEL_92:
      if ( v100 && (v113 || v128) )
      {
        LOBYTE(v124) = v114;
        v47 = v124;
        BYTE1(v47) = v107;
        sub_8C220(
          v12,
          (unsigned __int16 *)v127,
          (_BYTE *)(v127 + 32),
          v123,
          v131,
          v13,
          v100,
          v119,
          (v120 << 56) | (((unsigned __int64)v122 << 48) | (((unsigned __int64)v121 << 40) | (((unsigned __int64)v117 << 32) | (((unsigned __int64)v115 << 24) | (((unsigned __int64)v108 << 16) | v47 & 0xFFFFFFFFFF00FFFFLL) & 0xFFFFFFFF00FFFFFFLL) & 0xFFFFFF00FFFFFFFFLL) & 0xFFFF00FFFFFFFFFFLL) & 0xFF00FFFFFFFFFFFFLL) & 0xFFFFFFFFFFFFFFLL);
        v46 = *(_QWORD *)(v12 + 4352);
        v48 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 40) + v103) + 24LL) + v105);
      }
      v124 = *((_QWORD *)v57 + 2);
      v114 = v57[16];
      v107 = v57[17];
      v108 = v57[18];
      v115 = v57[19];
      v117 = v57[20];
      v121 = v57[21];
      v122 = v57[22];
      LOBYTE(v120) = v57[23];
      if ( v63 == 55296 || (v104 = 0LL, (v60 & 0xFFFFFE00) == 56320) )
        v104 = (unsigned int)v60 & 0xFFFFFF00;
      if ( *(_BYTE *)(v46 + 8) )
        v128 = v113;
      v100 = 1;
      v49 = 0LL;
      v123 = v96;
      v119 = v98;
      v113 = v112;
LABEL_100:
      if ( sub_8B030((__int64)v48, (__int64)v58, v60, v98) )
      {
        v65 = sub_2F4F0(v13, (unsigned __int64 *)&v134, 4uLL, v50, 2uLL, 0);
        v13 = v65;
        v65[v49] = v60;
        v52 = v58[1].m128i_i32[2];
        if ( v52 )
        {
          v129 = 0;
          goto LABEL_129;
        }
      }
      else
      {
        v51 = sub_2F4F0(v13, (unsigned __int64 *)&v134, 4uLL, v50, 2uLL, 0);
        v13 = v51;
        v51[v49] = v60;
        v52 = v58[1].m128i_i32[2];
        if ( !v52 )
        {
          v113 = 1;
          goto LABEL_103;
        }
        v129 = 1;
        v113 = 1;
LABEL_129:
        v66 = v100;
        v67 = v58;
        v68 = v52;
        v126 = v58;
        v101 = v60;
        v69 = (char *)v13;
        v70 = v66;
        v71 = v66;
        v72 = 4 * v66;
        do
        {
          v67 += 2 * v68;
          v73 = v67->m128i_i64[0];
          v75 = v67->m128i_i64[0] & 0xFFFFFF00LL;
          switch ( v75 )
          {
            case 55552LL:
              LODWORD(v73) = *(_DWORD *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v73 + 3092);
              break;
            case 55808LL:
              LODWORD(v73) = *(_DWORD *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v73 + 20);
              break;
            case 55296LL:
              LODWORD(v73) = *(_DWORD *)(*(_QWORD *)(v12 + 4352) + 4LL * (unsigned __int8)v73 + 1044);
              break;
          }
          v74 = v71;
          ++v70;
          ++v71;
          v69 = (char *)sub_2F4F0(v69, (unsigned __int64 *)&v134, 4uLL, v74, 2uLL, 0);
          *(_DWORD *)&v69[v72] = v73;
          v68 = v67[1].m128i_i32[2];
          v72 += 4LL;
        }
        while ( (_DWORD)v68 );
        v13 = v69;
        v119 |= 0x80000000uLL;
        v60 = v101;
        v100 = v70;
        v58 = v126;
        if ( v129 )
        {
LABEL_103:
          sub_8BE60(*(_QWORD *)(*(_QWORD *)(v12 + 40) + v103), v96, v58);
          v53 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 40) + v103) + 24LL) + v105;
          *(_QWORD *)(v53 + 8) = v98;
          *(_QWORD *)v53 = v60;
          *(_BYTE *)(v53 + 16) = v114;
          *(_BYTE *)(v53 + 17) = v107;
          *(_BYTE *)(v53 + 18) = v108;
          *(_BYTE *)(v53 + 19) = v115;
          *(_BYTE *)(v53 + 20) = v117;
          *(_BYTE *)(v53 + 21) = v121;
          *(_BYTE *)(v53 + 22) = v122;
          *(_BYTE *)(v53 + 23) = v120;
          if ( v123 == v96 )
            *(_QWORD *)(v53 + 8) = v98 | 0x80000000LL;
        }
      }
      v54 = *(_DWORD *)(v12 + 416);
      v55 = v96 + 1;
      if ( !(v98 & 0x400000) )
      {
LABEL_108:
        if ( v54 <= v55 )
          goto LABEL_152;
LABEL_109:
        v96 = v55;
        v16 = *(_QWORD *)(*(_QWORD *)(v12 + 40) + v103);
        continue;
      }
      break;
    }
    if ( v54 <= v55 )
    {
      v55 = v96 + 2;
      goto LABEL_108;
    }
    v76 = v125 != v55 || v130 != (_DWORD)v131;
    if ( !v76 )
      goto LABEL_192;
    v44 = sub_8B030(
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 40) + v103) + 24LL) + v105 + 32,
            (__int64)v58[2].m128i_i64,
            v58[2].m128i_i64[0],
            v58[2].m128i_i64[1]) == 0;
    v79 = v113;
    if ( v44 )
      v79 = v76;
    v80 = v79;
    sub_8BE60(v78, v77, v58 + 2);
    v113 = v80;
    v55 = v96 + 2;
    if ( *(_DWORD *)(v12 + 416) > v96 + 2 )
      goto LABEL_109;
LABEL_152:
    if ( v113 )
    {
      LOBYTE(v124) = v114;
      v84 = v124;
      BYTE1(v84) = v107;
      sub_8C220(
        v12,
        (unsigned __int16 *)v127,
        (_BYTE *)(v127 + 32),
        v123,
        v131,
        v13,
        v100,
        v119,
        (v120 << 56) | (((unsigned __int64)v122 << 48) | (((unsigned __int64)v121 << 40) | (((unsigned __int64)v117 << 32) | (((unsigned __int64)v115 << 24) | (((unsigned __int64)v108 << 16) | v84 & 0xFFFFFFFFFF00FFFFLL) & 0xFFFFFFFF00FFFFFFLL) & 0xFFFFFF00FFFFFFFFLL) & 0xFFFF00FFFFFFFFFFLL) & 0xFF00FFFFFFFFFFFFLL) & 0xFFFFFFFFFFFFFFLL);
      v81 = (void **)v127;
      if ( *(_BYTE *)(v127 + 12) )
        goto LABEL_162;
    }
    else
    {
LABEL_153:
      v81 = (void **)v127;
      if ( !*(_BYTE *)(v127 + 12) )
        goto LABEL_154;
LABEL_162:
      sub_8C3C0(v81);
    }
LABEL_154:
    ++v131;
  }
  while ( *(_DWORD *)(v12 + 412) > (signed int)v131 );
  v2 = v13;
LABEL_156:
  sub_2F4D0(v110);
  sub_2F4D0(v2);
  v83 = __readfsqword(0x28u);
  result = v83 ^ v135;
  if ( v83 != v135 )
LABEL_192:
    __assert_fail("!(i == our_curs_y && j == our_curs_x)", "terminal.c", 0x17F8u, "do_paint");
  return result;
}

unsigned __int64 __fastcall sub_8DA80(__int64 a1, __int64 a2, unsigned __int64 a3, char a4, unsigned __int8 a5, unsigned int *a6, int a7)
{
  __int64 v7; // rbp
  char v8; // r12
  void *v9; // rax
  void *v10; // rax
  void *v11; // rax
  signed int v12; // eax
  bool v13; // sf
  unsigned __int8 v14; // of
  __int64 v15; // r14
  char v16; // bp
  __int64 v17; // rax
  __int64 v18; // rbx
  signed int v19; // eax
  signed int v20; // ecx
  int v21; // eax
  bool v22; // sf
  unsigned __int8 v23; // of
  bool v24; // al
  __int64 v25; // r12
  __int64 v26; // rdx
  __int64 v27; // rax
  signed __int64 v28; // r12
  int v29; // er8
  signed __int64 v30; // rdx
  int v31; // ebx
  __int64 v32; // rbp
  __int64 v33; // rdx
  int *v34; // r13
  int v35; // esi
  int v36; // eax
  char v37; // ST40_1
  __int64 v38; // rdi
  char v39; // al
  int v40; // eax
  __int64 v41; // r13
  __int64 v42; // rdx
  unsigned int *v43; // rbx
  signed __int64 v44; // r12
  __int64 v45; // rsi
  signed __int64 v46; // rdx
  int v47; // ecx
  __int64 v48; // rax
  bool v49; // sf
  unsigned __int8 v50; // of
  signed int v52; // [rsp+8h] [rbp-130h]
  signed int v53; // [rsp+Ch] [rbp-12Ch]
  __int64 v54; // [rsp+10h] [rbp-128h]
  int v55; // [rsp+18h] [rbp-120h]
  int v56; // [rsp+1Ch] [rbp-11Ch]
  int v57; // [rsp+28h] [rbp-110h]
  int v58; // [rsp+2Ch] [rbp-10Ch]
  int v59; // [rsp+34h] [rbp-104h]
  unsigned __int64 v60; // [rsp+48h] [rbp-F0h]
  signed int v61; // [rsp+50h] [rbp-E8h]
  char v62; // [rsp+55h] [rbp-E3h]
  char v63; // [rsp+56h] [rbp-E2h]
  unsigned __int8 v64; // [rsp+57h] [rbp-E1h]
  unsigned int *v65; // [rsp+58h] [rbp-E0h]
  __int64 v66; // [rsp+60h] [rbp-D8h]
  __int64 v67; // [rsp+68h] [rbp-D0h]
  void *v68; // [rsp+70h] [rbp-C8h]
  void *v69; // [rsp+78h] [rbp-C0h]
  void *v70; // [rsp+80h] [rbp-B8h]
  void *v71; // [rsp+88h] [rbp-B0h]
  void *v72; // [rsp+90h] [rbp-A8h]
  void *v73; // [rsp+98h] [rbp-A0h]
  char v74; // [rsp+A0h] [rbp-98h]
  int v75; // [rsp+B0h] [rbp-88h]
  int v76; // [rsp+B4h] [rbp-84h]
  char v77; // [rsp+F4h] [rbp-44h]
  char v78; // [rsp+F5h] [rbp-43h]
  unsigned __int64 v79; // [rsp+F8h] [rbp-40h]

  v7 = a2 >> 32;
  v8 = a4;
  v57 = a3;
  v65 = a6;
  v60 = a3 >> 32;
  v63 = a4;
  v64 = a5;
  v53 = HIDWORD(a2);
  v79 = __readfsqword(0x28u);
  v66 = 5120LL;
  v67 = 0LL;
  v9 = sub_2F450(0x1400uLL, 4uLL, 0LL);
  v68 = v9;
  v69 = v9;
  v10 = sub_2F450(0x1400uLL, 4uLL, 0LL);
  v70 = v10;
  v71 = v10;
  v11 = sub_2F450(0x1400uLL, 8uLL, 0LL);
  v72 = v11;
  v73 = v11;
  v12 = 0;
  v56 = a2;
  if ( v8 )
    v12 = v7;
  v14 = __OFSUB__((_DWORD)a2, v57);
  v13 = (signed int)a2 - v57 < 0;
  v61 = v12;
  v15 = a1;
  if ( (_DWORD)a2 == v57 )
    goto LABEL_55;
  while ( 1 )
  {
    v16 = v13 ^ v14;
    if ( !(v13 ^ v14) )
      break;
    while ( 1 )
    {
      v17 = sub_8C080((const __m128i *)v15, v56, 6288LL, 0);
      v18 = v17;
      v54 = v17;
      v19 = *(_DWORD *)(v15 + 416);
      if ( *(_WORD *)v18 & 0x10 )
      {
        v59 = *(_DWORD *)(v15 + 416);
        if ( *(_BYTE *)(v54 + 32) )
        {
          v20 = 3;
          if ( v19 >= 3 )
            v20 = *(_DWORD *)(v15 + 416);
          v59 = v20 - 3;
        }
        if ( *(_WORD *)v18 & 0x20 )
        {
          if ( v59 )
          {
            --v59;
            v62 = 0;
            v58 = v56;
          }
          else
          {
            v59 = *(_DWORD *)(v15 + 416);
            v62 = 0;
            v58 = v56 - 1;
          }
        }
        else
        {
          v62 = 0;
          v58 = v56;
        }
      }
      else
      {
        if ( v19 )
        {
          v46 = *(_QWORD *)(v18 + 24) + 32LL * v19 - 32;
          v47 = *(_DWORD *)(v15 + 416);
          do
          {
            v48 = *(_QWORD *)v46;
            if ( *(_QWORD *)v46 != 32LL && (v48 & 0xFFFFFCFF) != 55328 )
              break;
            if ( *(_DWORD *)(v46 + 24) )
              break;
            if ( v53 >= v47 )
              break;
            v46 -= 32LL;
            --v47;
          }
          while ( v47 );
          v59 = v47;
        }
        else
        {
          v59 = 0;
        }
        v50 = __OFSUB__(v56, v57);
        v49 = v56 - v57 < 0;
        if ( v56 == v57 )
        {
          v50 = __OFSUB__(v59, (_DWORD)v60);
          v49 = v59 - (signed int)v60 < 0;
        }
        v62 = v49 ^ v50;
        v58 = v56;
      }
      if ( v63 )
      {
        v21 = v59;
        if ( v59 > (signed int)v60 )
          v21 = v60;
        v59 = v21;
        v62 = v56 < v57;
      }
      while ( 1 )
      {
        v23 = __OFSUB__(v56, v57);
        v22 = v56 - v57 < 0;
        if ( v56 == v57 )
          goto LABEL_49;
LABEL_18:
        if ( !(v22 ^ v23) )
          break;
LABEL_19:
        v24 = v56 == v58 ? v59 > v53 : v56 < v58;
        if ( !v24 )
          break;
        v25 = v53;
        v26 = *(_QWORD *)(v54 + 24);
        v52 = v53;
        v27 = *(_QWORD *)(v26 + 32LL * v53);
        if ( v27 != 57343 )
        {
          while ( 1 )
          {
            v28 = 32 * v25;
            v29 = v27;
            v30 = v28 + v26;
            v31 = *(_DWORD *)(v30 + 8);
            v32 = *(_QWORD *)(v30 + 16);
            v33 = (unsigned int)v27 & 0xFFFFFF00;
            v27 = (unsigned __int8)v27;
            switch ( v33 )
            {
              case 55552LL:
                v42 = *(_QWORD *)(v15 + 4352);
                if ( *(_BYTE *)(v15 + 4567) )
                  goto LABEL_44;
                v29 = *(_DWORD *)(v42 + 4 * v27 + 3092);
                v27 = (unsigned __int8)v29;
                v33 = v29 & 0xFFFFFF00;
                break;
              case 55808LL:
                v29 = *(_DWORD *)(*(_QWORD *)(v15 + 4352) + 4 * v27 + 20);
                v27 = (unsigned __int8)v29;
                v33 = v29 & 0xFFFFFF00;
                break;
              case 55296LL:
                v42 = *(_QWORD *)(v15 + 4352);
LABEL_44:
                v29 = *(_DWORD *)(v42 + 4 * v27 + 1044);
                v27 = (unsigned __int8)v29;
                v33 = v29 & 0xFFFFFF00;
                break;
              default:
                break;
            }
            if ( v33 == 56320 )
            {
              v29 = *(_DWORD *)(*(_QWORD *)(v15 + 4352) + 4 * v27 + 4116);
              LODWORD(v27) = (unsigned __int8)v29;
            }
            else if ( v33 == 56576 )
            {
              v29 = *(_DWORD *)(*(_QWORD *)(v15 + 4352) + 4 * v27 + 2068);
              LODWORD(v27) = (unsigned __int8)v29;
            }
            v75 = v29;
            v76 = 0;
            v55 = v53 + 1;
            if ( (v29 & 0xFFFFFE00) != 56320 )
              goto LABEL_30;
            if ( (signed int)v27 > 31 && (_DWORD)v27 != 127 )
            {
              v37 = v29;
              v38 = *(unsigned int *)(*(_QWORD *)(v15 + 4352) + 12LL);
              v39 = sub_BB400();
              v77 = v37;
              if ( v39 )
              {
                v78 = *(_QWORD *)(*(_QWORD *)(v54 + 24) + 32 * (v53 + 1LL));
                v40 = sub_BB410(*(_DWORD *)(*(_QWORD *)(v15 + 4352) + 12LL), 0LL, (__int64)&v77, 2, (__int64)&v74, 4);
                v55 = v53++ + 2;
              }
              else
              {
                v40 = sub_BB410(*(_DWORD *)(*(_QWORD *)(v15 + 4352) + 12LL), 0LL, (__int64)&v77, 1, (__int64)&v74, 4);
              }
              if ( v40 > 0 )
              {
                v41 = v40;
                __memcpy_chk(&v75, &v74, 4LL * v40, 64LL);
                *(&v75 + v41) = 0;
              }
              v29 = v75;
LABEL_30:
              if ( !v29 )
                goto LABEL_33;
            }
            v34 = &v75;
            v35 = v29;
            do
            {
              ++v34;
              sub_8AB90((__int64)&v66, v35, v31, v32);
              v35 = *v34;
            }
            while ( *v34 );
LABEL_33:
            v26 = *(_QWORD *)(v54 + 24);
            v36 = *(_DWORD *)(v26 + v28 + 24);
            if ( !v36 )
            {
              v23 = __OFSUB__(v56, v57);
              v22 = v56 - v57 < 0;
              v53 = v55;
              if ( v56 != v57 )
                goto LABEL_18;
LABEL_49:
              if ( (signed int)v60 <= v53 )
                goto LABEL_50;
              goto LABEL_19;
            }
            v52 += v36;
            v25 = v52;
            v27 = *(_QWORD *)(v26 + 32LL * v52);
          }
        }
        ++v53;
      }
LABEL_50:
      if ( v62 )
        sub_8AB90((__int64)&v66, 10, 0, *(_QWORD *)(v15 + 144));
      if ( *(_BYTE *)(v54 + 12) )
        sub_8C3C0((void **)v54);
      v14 = __OFSUB__(++v56, v57);
      v13 = v56 - v57 < 0;
      v53 = v61;
      if ( v56 != v57 )
        break;
LABEL_55:
      v16 = (signed int)v60 > v53;
      if ( (signed int)v60 <= v53 )
        goto LABEL_56;
    }
  }
  if ( a7 <= 0 )
    goto LABEL_86;
LABEL_56:
  v43 = v65;
  v44 = (signed __int64)&v65[a7 - 1 + 1];
  do
  {
    while ( 1 )
    {
      v45 = *v43;
      if ( (_DWORD)v45 != 1 )
        break;
      ++v43;
      v16 = 1;
      if ( (unsigned int *)v44 == v43 )
        goto LABEL_63;
    }
    if ( (_DWORD)v45 )
      (*(void (__fastcall **)(_QWORD, __int64, void *, void *, void *, _QWORD, _QWORD))(**(_QWORD **)(v15 + 4336) + 88LL))(
        *(_QWORD *)(v15 + 4336),
        v45,
        v68,
        v70,
        v72,
        (unsigned int)v67,
        v64);
    ++v43;
  }
  while ( (unsigned int *)v44 != v43 );
LABEL_63:
  if ( v16 )
  {
    sub_2F4D0(*(void **)(v15 + 4584));
    sub_2F4D0(*(void **)(v15 + 4592));
    sub_2F4D0(*(void **)(v15 + 4600));
    *(_QWORD *)(v15 + 4584) = v68;
    *(_QWORD *)(v15 + 4592) = v70;
    *(_QWORD *)(v15 + 4600) = v72;
    *(_QWORD *)(v15 + 4608) = v67;
  }
  else
  {
LABEL_86:
    sub_2F4D0(v68);
    sub_2F4D0(v70);
    sub_2F4D0(v72);
  }
  return __readfsqword(0x28u) ^ v79;
}

__int64 __fastcall sub_8E1F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  char v3; // r12
  __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // rdi

  v2 = a1;
  v3 = sub_2F080(*(_QWORD *)(a1 + 32));
  if ( v3 & 1 )
  {
    v5 = *(_QWORD *)(a1 + 32);
    *(_BYTE *)(a2 + 16) = 1;
    *(_BYTE *)(a2 + 17) = sub_2F080(v5);
    *(_BYTE *)(a2 + 18) = sub_2F080(*(_QWORD *)(v2 + 32));
    *(_BYTE *)(a2 + 19) = sub_2F080(*(_QWORD *)(v2 + 32));
    if ( !(v3 & 2) )
      goto LABEL_3;
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 0;
    *(_WORD *)(a2 + 17) = 0;
    *(_BYTE *)(a2 + 19) = 0;
    if ( !(v3 & 2) )
    {
LABEL_3:
      result = 0LL;
      *(_BYTE *)(a2 + 20) = 0;
      *(_BYTE *)(a2 + 23) = 0;
      *(_WORD *)(a2 + 21) = 0;
      return result;
    }
  }
  v6 = *(_QWORD *)(v2 + 32);
  *(_BYTE *)(a2 + 20) = 1;
  *(_BYTE *)(a2 + 21) = sub_2F080(v6);
  *(_BYTE *)(a2 + 22) = sub_2F080(*(_QWORD *)(v2 + 32));
  result = sub_2F080(*(_QWORD *)(v2 + 32));
  *(_BYTE *)(a2 + 23) = result;
  return result;
}

_QWORD *__fastcall sub_8E2A0(__int64 a1)
{
  *(_BYTE *)(a1 + 4377) = 1;
  return sub_1BD80((__int64)sub_90160, a1);
}

_QWORD *__fastcall sub_8E2C0(__int64 a1)
{
  bool v1; // bp
  __int64 v2; // rsi
  _QWORD *result; // rax
  bool v4; // zf

  v1 = 0;
  v2 = *(unsigned int *)(a1 + 452);
  if ( (_DWORD)v2 )
  {
    v1 = *(_BYTE *)(a1 + 448) < 1u;
    v2 = v1;
  }
  result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 4336) + 56LL))(
                       *(_QWORD *)(a1 + 4336),
                       v2);
  v4 = *(_BYTE *)(a1 + 4377) == 0;
  *(_BYTE *)(a1 + 8652) = 1;
  *(_BYTE *)(a1 + 8653) = v1;
  if ( v4 )
    result = sub_8E2A0(a1);
  return result;
}

void __fastcall sub_8E330(__int64 a1)
{
  if ( !*(_BYTE *)(a1 + 4392) )
    *(_QWORD *)(a1 + 4400) = sub_99D00(450LL, (__int64)sub_8FFF0, a1);
  *(_BYTE *)(a1 + 4392) = 1;
}

void __fastcall sub_8E370(__int64 a1)
{
  if ( !*(_BYTE *)(a1 + 4393) )
    *(_QWORD *)(a1 + 4408) = sub_99D00(450LL, (__int64)sub_8FFF0, a1);
  *(_BYTE *)(a1 + 4393) = 1;
}

unsigned __int64 __fastcall sub_8E3B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rbp
  unsigned __int64 result; // rax
  char v4; // [rsp+7h] [rbp-31h]
  unsigned __int64 v5; // [rsp+8h] [rbp-30h]

  v1 = a1 + 328;
  v5 = __readfsqword(0x28u);
  sub_8AC60(a1);
  while ( 1 )
  {
    v2 = sub_BCD00(v1);
    if ( !v2 )
      break;
    v4 = *(_BYTE *)sub_BCF00(v1);
    if ( (v4 & 0x7F) == 27 )
    {
      sub_BCE20(v1, v2);
      break;
    }
    sub_B8190(*(FILE ***)(a1 + 368), &v4, 1uLL);
    sub_BCE20(v1, 1uLL);
  }
  sub_B81C0(*(FILE ***)(a1 + 368));
  result = __readfsqword(0x28u) ^ v5;
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_BYTE *)(a1 + 321) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  return result;
}

unsigned __int64 __fastcall sub_8E4A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  signed __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v6; // [rsp+8h] [rbp-50h]
  __int64 v7; // [rsp+10h] [rbp-48h]
  unsigned __int64 v8; // [rsp+38h] [rbp-20h]

  v2 = *(signed int *)(a2 + 24);
  v8 = __readfsqword(0x28u);
  if ( (_DWORD)v2 )
  {
    v3 = a2 + 32 * v2;
    if ( !*(_QWORD *)v3 )
LABEL_8:
      __assert_fail("c->chr != 0", "terminal.c", 0x2A5u, "makeliteral_cc");
    while ( 1 )
    {
      v6 = 0LL;
      sub_8AE10(a1, (char *)v3, &v6);
      v4 = *(signed int *)(v3 + 24);
      if ( !(_DWORD)v4 )
        break;
      v3 += 32 * v4;
      if ( !*(_QWORD *)v3 )
        goto LABEL_8;
    }
  }
  v7 = 0LL;
  v6 = 0LL;
  sub_8AE10(a1, (char *)&v7, &v6);
  return __readfsqword(0x28u) ^ v8;
}

unsigned __int64 __fastcall sub_8E580(__int64 a1, int a2, signed __int64 a3, void (__fastcall *a4)(__int64, signed __int64, __int64 *))
{
  signed __int64 v4; // r14
  int v5; // ebp
  signed int v6; // er13
  signed int v7; // er12
  int v8; // eax
  signed __int64 v9; // rsi
  int v10; // ebx
  signed __int64 v11; // rbp
  int v12; // er14
  int v13; // eax
  signed int v14; // er8
  signed int v15; // ST00_4
  int v16; // eax
  int v17; // er14
  int v18; // er12
  __int64 v19; // r13
  unsigned __int64 result; // rax
  unsigned __int64 v21; // rt1
  __int64 v22; // [rsp+0h] [rbp-88h]
  __int64 v23; // [rsp+0h] [rbp-88h]
  void (__fastcall *v24)(__int64, signed __int64, __int64 *); // [rsp+8h] [rbp-80h]
  char v25; // [rsp+18h] [rbp-70h]
  int v26; // [rsp+20h] [rbp-68h]
  signed int v27; // [rsp+20h] [rbp-68h]
  int v28; // [rsp+24h] [rbp-64h]
  size_t n; // [rsp+28h] [rbp-60h]
  __int64 v30; // [rsp+30h] [rbp-58h]
  __int64 (__fastcall **v31)(_QWORD, char *, signed __int64); // [rsp+38h] [rbp-50h]
  __int64 v32; // [rsp+40h] [rbp-48h]
  unsigned __int64 v33; // [rsp+48h] [rbp-40h]

  v4 = a3;
  v5 = a2;
  v6 = 0;
  v7 = 0;
  v33 = __readfsqword(0x28u);
  v8 = *(_DWORD *)(a1 + 16);
  v24 = a4;
  v32 = 0LL;
  v28 = v8;
  v31 = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24);
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a1 + 24), 0);
  v25 = 0;
  v26 = 0;
  v9 = v4;
  while ( 1 )
  {
    v10 = v5 - 1;
    if ( v5 <= 0 )
      break;
    v11 = v9 + 32;
    v22 = *(_QWORD *)(a1 + 16);
    v12 = v22;
    v24(a1, v9, &v32);
    v13 = v22;
    v14 = *(_DWORD *)(a1 + 16) - v22;
    if ( v14 != v6
      || (v15 = *(_DWORD *)(a1 + 16) - v22,
          n = v6,
          v30 = *(_QWORD *)(a1 + 8),
          v16 = memcmp((const void *)(*(_QWORD *)(a1 + 8) + v26), (const void *)(*(_QWORD *)(a1 + 8) + v13), v6),
          v14 = v15,
          v16) )
    {
      ++v7;
      v25 = 0;
      if ( v7 != 128 )
        goto LABEL_3;
LABEL_10:
      v12 = 0;
      v7 = 0;
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + v28) = 127;
      v28 = *(_DWORD *)(a1 + 16);
      sub_2ECE0(v31, 0);
      v25 = 0;
      v14 = 0;
      goto LABEL_3;
    }
    if ( v6 <= 1 && !v25 )
    {
      ++v7;
      v25 = 1;
      if ( v7 != 128 )
        goto LABEL_3;
      goto LABEL_10;
    }
    v17 = v7 - 1;
    if ( v25 )
    {
      if ( v17 <= 0 )
        __assert_fail("hdrsize > 0", "terminal.c", 0x1C6u, "makerle");
      v26 -= v6;
      v17 = v7 - 2;
    }
    if ( v17 )
    {
      memmove((void *)(v30 + v26 + 1), (const void *)(v30 + v26), v6);
      sub_BC590((__int64 *)a1, v6 + v26 + 1);
      if ( (unsigned int)(v17 - 1) > 0x7F )
        __assert_fail("hdrsize >= 1 && hdrsize <= 128", "terminal.c", 0x1D7u, "makerle");
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + v28) = v17 - 1;
      v28 = v26;
    }
    else
    {
      if ( v28 + 1 != v26 )
        __assert_fail("prevpos == hdrpos + 1", "terminal.c", 0x1CCu, "makerle");
      sub_BC590((__int64 *)a1, v6 + v26);
    }
    v18 = (v25 & 1) + 2;
    if ( v10 > 0 )
    {
      v27 = v6;
      while ( 1 )
      {
        v19 = *(_QWORD *)(a1 + 16);
        v23 = v32;
        v24(a1, v11, &v32);
        if ( v27 != *(_DWORD *)(a1 + 16) - (_DWORD)v19
          || memcmp(
               (const void *)(*(_QWORD *)(a1 + 8) + v28 + 1LL),
               (const void *)(*(_QWORD *)(a1 + 8) + (signed int)v19),
               n) )
        {
          break;
        }
        --v10;
        sub_BC590((__int64 *)a1, (signed int)v19);
        v11 += 32LL;
        ++v18;
        if ( v10 <= 0 || v18 > 128 )
          goto LABEL_21;
      }
      sub_BC590((__int64 *)a1, (signed int)v19);
      v32 = v23;
    }
LABEL_21:
    if ( (unsigned int)(v18 - 2) > 0x7F )
      __assert_fail("runlen >= 2 && runlen <= 129", "terminal.c", 0x1EDu, "makerle");
    v12 = 0;
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + v28) = v18 + 126;
    v7 = 0;
    v28 = *(_DWORD *)(a1 + 16);
    sub_2ECE0(v31, 0);
    v14 = 0;
    v25 = 0;
LABEL_3:
    v9 = v11;
    v26 = v12;
    v6 = v14;
    v5 = v10;
  }
  if ( v7 )
  {
    if ( v7 <= 128 )
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 8) + v28) = v7 - 1;
      goto LABEL_30;
    }
    goto LABEL_39;
  }
  sub_BC590((__int64 *)a1, v28);
LABEL_30:
  v21 = __readfsqword(0x28u);
  result = v21 ^ v33;
  if ( v21 != v33 )
LABEL_39:
    __assert_fail("hdrsize <= 128", "terminal.c", 0x21Bu, "makerle");
  return result;
}

signed __int64 *__fastcall sub_8E9A0(unsigned __int16 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // ebx
  char v4; // si
  signed int v5; // ebx
  char v6; // si
  signed __int64 v7; // rbx
  signed __int64 *result; // rax

  v2 = sub_BC640();
  sub_BC510(v2, 8uLL);
  v3 = *((_DWORD *)a1 + 1);
  while ( v3 > 127 )
  {
    v4 = v3;
    v3 >>= 7;
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24), v4 | 0x80);
  }
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24), v3);
  v5 = *a1;
  if ( !*((_BYTE *)a1 + 32) )
    goto LABEL_6;
  v5 |= 0x10000u;
  do
  {
    v6 = v5;
    v5 >>= 7;
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24), v6 | 0x80);
LABEL_6:
    ;
  }
  while ( v5 > 127 );
  sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v2 + 24), v5);
  sub_8E580(
    v2,
    *((_DWORD *)a1 + 1),
    *((_QWORD *)a1 + 3),
    (void (__fastcall *)(__int64, signed __int64, __int64 *))sub_8AE10);
  sub_8E580(
    v2,
    *((_DWORD *)a1 + 1),
    *((_QWORD *)a1 + 3),
    (void (__fastcall *)(__int64, signed __int64, __int64 *))sub_8AD60);
  sub_8E580(
    v2,
    *((_DWORD *)a1 + 1),
    *((_QWORD *)a1 + 3),
    (void (__fastcall *)(__int64, signed __int64, __int64 *))sub_8ACC0);
  sub_8E580(
    v2,
    *((_DWORD *)a1 + 1),
    *((_QWORD *)a1 + 3),
    (void (__fastcall *)(__int64, signed __int64, __int64 *))sub_8E4A0);
  v7 = *(_QWORD *)(v2 + 16) - 8LL;
  result = (signed __int64 *)sub_BC6B0((__int64 *)v2);
  *result = v7;
  return result;
}

__int64 __fastcall sub_8EAC0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // r13
  int v5; // ebx
  int v6; // er14
  signed int *v7; // rax
  signed int *v8; // rbp
  int v9; // eax
  signed __int64 v10; // r12

  v4 = a3;
  v5 = a4;
  if ( (signed int)a2 < 0 )
  {
    v10 = sub_BC640();
    sub_2EC20((__int64 (**)(void))(v10 + 24));
  }
  else
  {
    v6 = 2 * a4;
    v7 = (signed int *)sub_2F450((signed int)(2 * a4), 4uLL, 0LL);
    v8 = v7;
    v9 = sub_BB410(a2, 0LL, v4, v5, (__int64)v7, v6);
    v10 = sub_8AF20(a1, v8, v9);
    sub_2F4D0(v8);
  }
  return v10;
}

void __fastcall sub_8EB60(__int64 a1)
{
  __int64 v1; // rax
  unsigned int v2; // edx
  __int16 v3; // si
  unsigned __int8 *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  int v7; // ecx
  __int64 v8; // rbx
  bool v9; // cf
  bool v10; // zf
  _BYTE *v11; // rsi
  void *__ptr32 *v12; // rdi
  signed __int64 v13; // rcx
  __int64 v14; // rsi
  char *v15; // rax
  char *v16; // rbp
  unsigned int v17; // eax
  char *v18; // rax
  char *v19; // rax

  v1 = *(signed int *)(a1 + 652);
  if ( *(_BYTE *)(a1 + 2705) )
  {
    v2 = v1 - 1;
    *(_DWORD *)(a1 + 652) = v1 - 1;
    if ( (_DWORD)v1 )
    {
      v3 = *(_WORD *)(a1 + 516);
      v4 = (unsigned __int8 *)(a1 + (signed int)v2 + 656);
      v5 = a1 + (signed int)v2 + 655 - v2;
      do
      {
        v6 = *v4--;
        *(_WORD *)(a1 + 2 * v6 + 3784) = v3;
      }
      while ( v4 != (unsigned __int8 *)v5 );
      *(_DWORD *)(a1 + 652) = -1;
    }
  }
  else
  {
    *(_BYTE *)(a1 + v1 + 656) = 0;
    v7 = *(_DWORD *)(a1 + 516);
    v8 = a1;
    switch ( v7 )
    {
      case 0:
      case 1:
        if ( !*(_BYTE *)(a1 + 4565) )
        {
          sub_2F4D0(*(void **)(a1 + 4664));
          v19 = sub_BC120((char *)(a1 + 656));
          v10 = *(_BYTE *)(a1 + 4377) == 0;
          *(_QWORD *)(a1 + 4664) = v19;
          *(_BYTE *)(a1 + 8651) = 1;
          if ( v10 )
            sub_8E2A0(a1);
          v7 = *(_DWORD *)(a1 + 516);
        }
        if ( v7 != 1 )
          goto LABEL_9;
        break;
      case 2:
      case 21:
LABEL_9:
        if ( !*(_BYTE *)(a1 + 4565) )
        {
          sub_2F4D0(*(void **)(a1 + 4656));
          v18 = sub_BC120((char *)(a1 + 656));
          v10 = *(_BYTE *)(a1 + 4377) == 0;
          *(_QWORD *)(a1 + 4656) = v18;
          *(_BYTE *)(a1 + 8650) = 1;
          if ( v10 )
            sub_8E2A0(a1);
        }
        break;
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
        return;
      case 4:
        v9 = 0;
        v10 = *(_QWORD *)(a1 + 4328) == 0LL;
        if ( *(_QWORD *)(a1 + 4328) )
        {
          v11 = (_BYTE *)(a1 + 656);
          v12 = &off_F4B6B;
          v13 = 2LL;
          do
          {
            if ( !v13 )
              break;
            v9 = *v11 < *(_BYTE *)v12;
            v10 = *v11++ == *(_BYTE *)v12;
            v12 = (void *__ptr32 *)((char *)v12 + 1);
            --v13;
          }
          while ( v10 );
          if ( (!v9 && !v10) == v9 )
          {
            v14 = *(unsigned int *)(v8 + 520);
            if ( (unsigned int)v14 <= 0x105 )
            {
              v15 = sub_BC360(
                      (__int64)"\x1B]4;%u;rgb:%04x/%04x/%04x\a",
                      v14,
                      257 * (unsigned int)*(unsigned __int8 *)(v8 + 3LL * (unsigned int)v14 + 7817),
                      257 * (unsigned int)*(unsigned __int8 *)(v8 + 3LL * (unsigned int)v14 + 7817 + 1),
                      257 * (unsigned int)*(unsigned __int8 *)(v8 + 3LL * (unsigned int)v14 + 7817 + 2));
              v16 = v15;
              v17 = strlen(v15);
              sub_2C0F0(*(_QWORD *)(v8 + 4328), v16, v17, 0);
              sub_2F4D0(v16);
            }
          }
        }
        break;
    }
  }
}

__int64 __fastcall sub_8ED60(const __m128i *a1, signed int a2, signed int a3, int a4, char a5)
{
  char v5; // r15
  unsigned int v6; // er14
  int v7; // er13
  __int64 result; // rax
  int i; // er12
  signed int v10; // edx
  signed int v11; // edx
  signed int v12; // edx
  __int64 v13; // rsi
  __int64 v14; // rax
  __int64 v15; // rbp
  int v16; // edx
  int v17; // ST08_4
  signed __int64 *v18; // rax
  __int32 v19; // edx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  unsigned int v23; // er15
  int v24; // er12
  _WORD *v25; // rbp
  signed int v26; // eax
  int v27; // eax
  int v28; // ST08_4
  void *v29; // rax

  v5 = 0;
  v6 = a2;
  v7 = a3;
  if ( !a2 )
  {
    v5 = a5;
    if ( a1[31].m128i_i32[3] )
      v5 = 0;
  }
  result = (unsigned int)(a3 - a2 + 1);
  if ( a4 < 0 )
  {
    v23 = a3 + 1;
    v24 = -a4;
    if ( -a4 > (signed int)result )
      v24 = a3 - a2 + 1;
    while ( v24 > 0 )
    {
      v25 = (_WORD *)sub_9B400((__int64 *)a1[1].m128i_i64[0], v7);
      sub_8BED0(a1, (__int64)v25, a1[26].m128i_i32[0]);
      sub_8C1C0(a1, v25);
      sub_9AFF0((_QWORD *)a1[1].m128i_i64[0], (__int64)v25, a2);
      v26 = a1[235].m128i_i32[0];
      if ( v26 <= v7 && v26 >= a2 )
      {
        v27 = v26 + 1;
        if ( v27 > v7 )
          a1[235].m128i_i64[0] = v23;
        else
          a1[235].m128i_i32[0] = v27;
      }
      result = a1[235].m128i_u32[2];
      if ( (signed int)result >= a2 && (signed int)result <= v7 )
      {
        result = (unsigned int)(result + 1);
        if ( (signed int)result > v7 )
          a1[235].m128i_i64[1] = v23;
        else
          a1[235].m128i_i32[2] = result;
      }
      --v24;
    }
  }
  else
  {
    if ( (signed int)result <= a4 )
      a4 = a3 - a2 + 1;
    for ( i = a4; i > 0; --i )
    {
      v13 = v6;
      v14 = sub_9B400((__int64 *)a1[1].m128i_i64[0], v6);
      v15 = v14;
      if ( v5 )
      {
        if ( a1[26].m128i_i32[1] > 0 )
        {
          v16 = sub_9AFB0((__int64 *)a1->m128i_i64[1]);
          if ( a1[26].m128i_i32[1] == v16 )
          {
            v13 = 0LL;
            v28 = v16 - 1;
            v29 = (void *)sub_9B400((__int64 *)a1->m128i_i64[1], 0);
            sub_2F4D0(v29);
            v16 = v28;
          }
          else
          {
            ++a1[2].m128i_i32[1];
          }
          v17 = v16;
          v18 = sub_8E9A0((unsigned __int16 *)v15, v13);
          sub_9AFF0((_QWORD *)a1->m128i_i64[1], (__int64)v18, v17);
          v19 = a1[2].m128i_i32[0];
          if ( v19 > -a1[26].m128i_i32[1] && v19 < 0 )
            a1[2].m128i_i32[0] = v19 - 1;
        }
        sub_8BED0(a1, v15, a1[26].m128i_i32[0]);
        sub_8C1C0(a1, (_WORD *)v15);
        if ( *(_BYTE *)(v15 + 32) != a1[280].m128i_i8[0] )
        {
          sub_8C1C0(a1, (_WORD *)v15);
          *(_BYTE *)(v15 + 32) = a1[280].m128i_i8[0];
        }
        sub_9AFF0((_QWORD *)a1[1].m128i_i64[0], v15, v7);
        result = (unsigned int)-a1[26].m128i_i32[1];
      }
      else
      {
        sub_8BED0(a1, v14, a1[26].m128i_i32[0]);
        sub_8C1C0(a1, (_WORD *)v15);
        if ( *(_BYTE *)(v15 + 32) != a1[280].m128i_i8[0] )
        {
          sub_8C1C0(a1, (_WORD *)v15);
          *(_BYTE *)(v15 + 32) = a1[280].m128i_i8[0];
        }
        sub_9AFF0((_QWORD *)a1[1].m128i_i64[0], v15, v7);
        result = v6;
      }
      if ( a1[234].m128i_i32[1] )
      {
        v10 = a1[235].m128i_i32[0];
        if ( v10 <= v7 && v10 >= (signed int)result )
        {
          v22 = v10 - 1;
          if ( v22 < (signed int)result )
            a1[235].m128i_i64[0] = (unsigned int)result;
          else
            a1[235].m128i_i32[0] = v22;
        }
        v11 = a1[235].m128i_i32[2];
        if ( v11 <= v7 && v11 >= (signed int)result )
        {
          v21 = v11 - 1;
          if ( v21 < (signed int)result )
            a1[235].m128i_i64[1] = (unsigned int)result;
          else
            a1[235].m128i_i32[2] = v21;
        }
        v12 = a1[236].m128i_i32[0];
        if ( v12 >= (signed int)result && v12 <= v7 )
        {
          v20 = v12 - 1;
          if ( v20 < (signed int)result )
            a1[236].m128i_i64[0] = (unsigned int)result;
          else
            a1[236].m128i_i32[0] = v20;
        }
      }
    }
  }
  return result;
}

unsigned __int64 __fastcall sub_8F100(const __m128i *a1)
{
  __int32 v1; // eax
  int v2; // eax
  unsigned __int64 v3; // rax
  unsigned __int64 result; // rax

  a1[235].m128i_i64[0] = sub_8C3E0(a1, a1[235].m128i_i64[0], -1);
  v1 = a1[235].m128i_i32[3];
  if ( v1 )
  {
    v2 = v1 - 1;
  }
  else
  {
    v2 = a1[26].m128i_i32[0];
    --a1[235].m128i_i32[2];
  }
  a1[235].m128i_i32[3] = v2;
  v3 = sub_8C3E0(a1, a1[235].m128i_i64[1], 1);
  a1[235].m128i_i64[1] = v3;
  result = v3 >> 32;
  if ( a1[26].m128i_i32[0] == (_DWORD)result )
  {
    a1[235].m128i_i32[3] = 0;
    ++a1[235].m128i_i32[2];
  }
  else
  {
    result = (unsigned int)(result + 1);
    a1[235].m128i_i32[3] = result;
  }
  return result;
}

__int64 __fastcall sub_8F1A0(const __m128i *a1, int a2, int a3)
{
  __int64 v3; // rbx
  int v4; // edx
  __int64 result; // rax
  signed __int64 v6; // rbp
  __m128i *v7; // rdx

  v3 = sub_8C080(a1, a3, 2752LL, 1);
  if ( *(_BYTE *)(v3 + 32) != a1[280].m128i_i8[0] )
  {
    sub_8C1C0(a1, (_WORD *)v3);
    *(_BYTE *)(v3 + 32) = a1[280].m128i_i8[0];
  }
  v4 = a1[26].m128i_i32[0];
  result = *(unsigned int *)(v3 + 4);
  if ( v4 != (_DWORD)result )
  {
    sub_8BED0(a1, v3, v4);
    result = a1[26].m128i_u32[0];
  }
  if ( a2 == (_DWORD)result )
  {
    *(_WORD *)v3 &= 0xFFDFu;
  }
  else
  {
    result = *(_QWORD *)(v3 + 24);
    v6 = 32LL * a2;
    if ( *(_QWORD *)(result + v6) == 57343LL )
    {
      sub_8BB80(v3, a2 - 1);
      sub_8BB80(v3, a2);
      result = *(_QWORD *)(v3 + 24);
      v7 = (__m128i *)(result + v6 - 32);
      v7->m128i_i64[0] = 55328LL;
      *(__m128i *)(result + v6) = _mm_loadu_si128(v7);
      *(__m128i *)(result + v6 + 16) = _mm_loadu_si128(v7 + 1);
    }
  }
  return result;
}

__int64 __fastcall sub_8F270(const __m128i *a1, int a2)
{
  const __m128i *v2; // rbp
  int v3; // edx
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  int v7; // esi
  int v8; // er9
  int v9; // er15
  __int32 v10; // ecx
  bool v11; // sf
  unsigned __int8 v12; // of
  int v13; // edi
  int v14; // er10
  __int64 v15; // r13
  int v16; // eax
  signed __int64 v17; // rcx
  signed __int64 v18; // r14
  __int64 v19; // rax
  const __m128i *v20; // r15
  signed __int64 v21; // rbx
  __m128i *v22; // r12
  __int32 v23; // esi
  __int64 result; // rax
  int v25; // ebx
  int v26; // esi
  int v27; // er13
  int v28; // er11
  bool v29; // di
  bool v30; // cl
  int v31; // er10
  int v32; // er9
  int v33; // eax
  __int64 v34; // r13
  __int64 v35; // r14
  __int64 v36; // rax
  __int64 v37; // rbx
  __int64 v38; // r9
  signed __int64 v39; // rbx
  const __m128i *v40; // r12
  __int32 v41; // esi
  int v42; // er12
  int v43; // esi
  signed __int64 v44; // [rsp+8h] [rbp-60h]
  __m128i *v45; // [rsp+8h] [rbp-60h]
  signed __int64 v46; // [rsp+10h] [rbp-58h]
  __int64 v47; // [rsp+10h] [rbp-58h]
  int v48; // [rsp+24h] [rbp-44h]

  v2 = a1;
  v3 = a1[26].m128i_i32[0];
  v4 = a1[14].m128i_i32[3];
  v5 = (a2 >> 31) | 1;
  v6 = abs(a2);
  v7 = a1[14].m128i_i32[2];
  v8 = a1[235].m128i_i32[3];
  if ( a1[26].m128i_i32[0] - v4 <= v6 )
    v6 = a1[26].m128i_i32[0] - v4;
  v9 = a1[26].m128i_i32[0] - v4 - v6;
  v48 = v6;
  v10 = a1[235].m128i_i32[2];
  v12 = __OFSUB__(v7, v10);
  v11 = v7 - v10 < 0;
  if ( v7 == v10 )
  {
    v12 = __OFSUB__(v4, v8);
    v11 = v4 - v8 < 0;
  }
  if ( v11 ^ v12 )
  {
    v13 = a1[235].m128i_i32[0];
    v14 = v2[235].m128i_i32[1];
    if ( v7 == v13 )
    {
      if ( v3 <= v14 )
        goto LABEL_8;
    }
    else if ( v7 <= v13 )
    {
      goto LABEL_8;
    }
    if ( v5 == 1 )
    {
      v27 = v3 - v48;
      v28 = v4;
    }
    else
    {
      v27 = v3;
      v28 = v4 + v48;
    }
    if ( v7 == v13 )
      v29 = v14 >= v28;
    else
      v29 = v7 < v13;
    if ( v29 && (v7 == v10 ? (v30 = v8 <= v27) : (v30 = v7 > v10), v30) )
    {
      v31 = v5 * v48 + v14;
      v32 = v5 * v48 + v8;
      v2[235].m128i_i32[1] = v31;
      v2[235].m128i_i32[3] = v32;
      if ( v4 > v31 )
        __assert_fail("term->selstart.x >= term->curs.x", "terminal.c", 0xB6Cu, "insch");
      if ( v3 <= v31 )
        __assert_fail("term->selstart.x < term->cols", "terminal.c", 0xB6Du, "insch");
      if ( v4 >= v32 )
        __assert_fail("term->selend.x > term->curs.x", "terminal.c", 0xB6Eu, "insch");
      if ( v3 < v32 )
        __assert_fail("term->selend.x <= term->cols", "terminal.c", 0xB6Fu, "insch");
    }
    else
    {
      v2[234].m128i_i32[1] = 0;
      v2[235].m128i_i64[0] = 0LL;
      v2[235].m128i_i64[1] = 0LL;
    }
  }
LABEL_8:
  if ( v4 > 0 && v3 >= v4 )
  {
    sub_8F1A0(v2, v4, v7);
    v7 = v2[14].m128i_i32[2];
    if ( v5 != -1 )
      goto LABEL_11;
  }
  else if ( v5 != -1 )
  {
LABEL_11:
    v15 = sub_8C080(v2, v7, 2938LL, 1);
    if ( v2[280].m128i_i8[0] != *(_BYTE *)(v15 + 32) )
    {
      sub_8C1C0(v2, (_WORD *)v15);
      *(_BYTE *)(v15 + 32) = v2[280].m128i_i8[0];
    }
    v16 = v9 - 1;
    if ( v9 )
    {
      v17 = v16;
      v18 = v16 - 1LL;
      v46 = v18 - (unsigned int)v16;
      while ( 1 )
      {
        v19 = *(_QWORD *)(v15 + 24);
        v20 = (const __m128i *)(v19 + 32 * (v17 + v2[14].m128i_i32[3]));
        v44 = 32 * (v17 + v2[14].m128i_i32[3]);
        v21 = 32 * (v48 + v17 + v2[14].m128i_i32[3]);
        v22 = (__m128i *)(v19 + v21);
        sub_8BB80(v15, v21 >> 5);
        *v22 = _mm_loadu_si128(v20);
        v22[1] = _mm_loadu_si128(v20 + 1);
        v23 = v20[1].m128i_i32[2];
        if ( v23 )
          v22[1].m128i_i32[2] = v23 - (unsigned __int64)((v21 - v44) >> 5);
        v20[1].m128i_i32[2] = 0;
        v17 = v18;
        if ( v46 == v18 )
          break;
        --v18;
      }
    }
    result = (unsigned int)v48;
    v25 = v48 - 1;
    if ( v48 )
    {
      do
      {
        v26 = v25-- + v2[14].m128i_i32[3];
        result = sub_8BE60(v15, v26, v2 + 10);
      }
      while ( v25 != -1 );
    }
    return result;
  }
  v33 = v2[14].m128i_i32[3] + v48;
  if ( v33 > 0 && v33 <= v2[26].m128i_i32[0] )
  {
    sub_8F1A0(v2, v33, v7);
    v7 = v2[14].m128i_i32[2];
  }
  v34 = sub_8C080(v2, v7, 2938LL, 1);
  if ( v2[280].m128i_i8[0] != *(_BYTE *)(v34 + 32) )
  {
    sub_8C1C0(v2, (_WORD *)v34);
    *(_BYTE *)(v34 + 32) = v2[280].m128i_i8[0];
  }
  if ( v9 > 0 )
  {
    v35 = 0LL;
    do
    {
      v36 = *(_QWORD *)(v34 + 24);
      v37 = v35 + v2[14].m128i_i32[3];
      v38 = v37 + v48;
      v39 = 32 * v37;
      v38 *= 32LL;
      v40 = (const __m128i *)(v36 + v38);
      v47 = v38;
      v45 = (__m128i *)(v39 + v36);
      sub_8BB80(v34, v39 >> 5);
      *v45 = _mm_loadu_si128(v40);
      v45[1] = _mm_loadu_si128(v40 + 1);
      v41 = v40[1].m128i_i32[2];
      if ( v41 )
        v45[1].m128i_i32[2] = v41 - (unsigned __int64)((v39 - v47) >> 5);
      ++v35;
      v40[1].m128i_i32[2] = 0;
    }
    while ( v35 != (unsigned int)(v9 - 1) + 1LL );
  }
  result = (unsigned int)v48;
  if ( v48 )
  {
    v42 = v9 + result;
    do
    {
      v43 = v9++ + v2[14].m128i_i32[3];
      result = sub_8BE60(v34, v43, v2 + 10);
    }
    while ( v9 != v42 );
  }
  return result;
}

signed __int64 __usercall sub_8F760@<rax>(__m128i *a1@<rdi>, signed __int64 a2@<rsi>, __int64 a3@<r15>)
{
  signed __int64 v3; // r13
  __m128i *v4; // rbx
  __int64 v5; // r12
  int v6; // er14
  __int32 v7; // ecx
  unsigned __int32 v8; // eax
  __int64 v9; // rdx
  signed __int64 result; // rax
  int v11; // ecx
  int v12; // ebp
  int v13; // esi
  int v14; // eax
  __int32 v15; // edx
  __int64 v16; // rcx
  int v17; // edx
  bool v18; // zf
  int v19; // esi
  __int64 v20; // rcx
  __int64 v21; // rdi
  signed int v22; // edx
  signed int v23; // esi
  int v24; // esi
  int v25; // edx
  int v26; // eax
  signed __int64 *v27; // rax
  int v28; // esi
  signed __int64 v29; // rdx
  __int64 v30; // rcx
  signed int v31; // esi
  __int64 v32; // rax
  int v33; // edx
  int v34; // eax

  v3 = a2;
  v4 = a1;
  v5 = sub_8C080(a1, a1[14].m128i_i32[2], 3198LL, 1);
  if ( (a2 & 0xFFFFFC00) == 55296 )
  {
    a3 = a1[16].m128i_u8[2];
    v6 = 1;
    if ( !(_BYTE)a3 )
      goto LABEL_55;
    a3 = a1[16].m128i_u8[1];
    if ( !(_BYTE)a3 )
      goto LABEL_55;
    a3 = 0LL;
LABEL_51:
    *(_WORD *)v5 |= 0x10u;
    v23 = a1[14].m128i_i32[2];
    if ( v23 == a1[15].m128i_i32[3] )
    {
      sub_8ED60(a1, a1[15].m128i_i32[2], v23, 1, 1);
      v23 = a1[14].m128i_i32[2];
    }
    else if ( v23 < a1[25].m128i_i32[3] - 1 )
    {
      a1[14].m128i_i32[2] = ++v23;
    }
    a1[14].m128i_i32[3] = 0;
    a1[16].m128i_i8[2] = 0;
    v5 = sub_8C080(a1, v23, 3213LL, 1);
LABEL_55:
    if ( !a1[16].m128i_i8[3] )
      goto LABEL_7;
    goto LABEL_56;
  }
  if ( a1[283].m128i_i8[0] )
    v6 = sub_BD9A0(a2);
  else
    v6 = sub_BD8A0(a2);
  LOBYTE(a3) = v6 == 2;
  if ( *(__int16 *)((char *)a1[16].m128i_i16 + 1) )
  {
    if ( v6 <= 0 )
      goto LABEL_7;
    goto LABEL_51;
  }
  if ( a1[16].m128i_i8[3] && v6 > 0 )
LABEL_56:
    sub_8F270(a1, v6);
LABEL_7:
  if ( a1[234].m128i_i32[1] )
  {
    v7 = a1[14].m128i_i32[3];
    v8 = a1[14].m128i_u32[2];
    v9 = (unsigned int)(v7 + 1);
    if ( a1[26].m128i_i32[0] == v7 )
    {
      ++v8;
      v9 = 0LL;
    }
    sub_8BB10(a1, a1[14].m128i_i64[1], (v9 << 32) | v8);
  }
  if ( (v3 & 0xFFFFFF00) == 55296 || !(v3 & 0xFFFFFF00) )
  {
    v21 = a1[271].m128i_i64[1];
    if ( v21 )
      sub_2D280(1, v21, v3, v3, a3);
  }
  result = v4[280].m128i_u8[0];
  if ( *(_BYTE *)(v5 + 32) != (_BYTE)result )
  {
    sub_8C1C0(v4, (_WORD *)v5);
    result = v4[280].m128i_u8[0];
    *(_BYTE *)(v5 + 32) = result;
  }
  v11 = v4[26].m128i_i32[0];
  v12 = v11 - 3;
  if ( !(_BYTE)result )
    v12 = v4[26].m128i_i32[0];
  if ( v12 <= 1 && (_BYTE)a3 )
  {
    v3 = 65533LL;
    goto LABEL_20;
  }
  switch ( v6 )
  {
    case 1:
LABEL_20:
      v13 = v4[14].m128i_i32[3];
      if ( v13 > 0 && v13 <= v11 )
      {
        sub_8F1A0(v4, v13, v4[14].m128i_i32[2]);
        v13 = v4[14].m128i_i32[3];
      }
      v14 = v13 + 1;
      if ( v13 + 1 > 0 && v14 <= v4[26].m128i_i32[0] )
      {
        sub_8F1A0(v4, v14, v4[14].m128i_i32[2]);
        v13 = v4[14].m128i_i32[3];
      }
      sub_8BB80(v5, v13);
      v15 = v4[14].m128i_i32[3];
      result = *(_QWORD *)(v5 + 24) + 32LL * v4[14].m128i_i32[3];
      *(_QWORD *)(result + 8) = v4[6].m128i_i32[1];
      v16 = *(__int64 *)((char *)&v4[6].m128i_i64[1] + 4);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 16) = v16;
LABEL_27:
      v17 = v15 + 1;
      if ( v17 >= v12 )
      {
        v18 = v4[16].m128i_i8[1] == 0;
        v4[16].m128i_i8[2] = 1;
        v4[14].m128i_i32[3] = v12 - 1;
        if ( !v18 && v4[27].m128i_i8[10] )
        {
          *(_WORD *)v5 |= 0x10u;
          v22 = v4[14].m128i_i32[2];
          if ( v22 == v4[15].m128i_i32[3] )
          {
            result = sub_8ED60(v4, v4[15].m128i_i32[2], v22, 1, 1);
          }
          else
          {
            result = (unsigned int)(v4[25].m128i_i32[3] - 1);
            if ( v22 < (signed int)result )
              v4[14].m128i_i32[2] = v22 + 1;
          }
          v4[14].m128i_i32[3] = 0;
          v4[16].m128i_i8[2] = 0;
        }
      }
      else
      {
        v4[14].m128i_i32[3] = v17;
      }
LABEL_29:
      v18 = v4[273].m128i_i8[9] == 0;
      v4[27].m128i_i8[14] = 1;
      if ( v18 )
        result = (signed __int64)sub_8E2A0((__int64)v4);
      return result;
    case 2:
      v24 = v4[14].m128i_i32[3];
      v25 = v4[14].m128i_i32[2];
      if ( v24 <= v11 && v24 > 0 )
      {
        sub_8F1A0(v4, v24, v25);
        v25 = v4[14].m128i_i32[2];
        v24 = v4[14].m128i_i32[3];
      }
      v26 = v24 + 2;
      if ( v24 + 2 > 0 && v26 <= v4[26].m128i_i32[0] )
      {
        sub_8F1A0(v4, v26, v25);
        v24 = v4[14].m128i_i32[3];
      }
      if ( v12 - 1 <= v24 )
      {
        sub_8BE60(v5, v24, v4 + 10);
        *(_WORD *)v5 |= 0x30u;
        v31 = v4[14].m128i_i32[2];
        if ( v31 == v4[15].m128i_i32[3] )
        {
          sub_8ED60(v4, v4[15].m128i_i32[2], v31, 1, 1);
          v31 = v4[14].m128i_i32[2];
        }
        else if ( v31 < v4[25].m128i_i32[3] - 1 )
        {
          v4[14].m128i_i32[2] = ++v31;
        }
        v4[14].m128i_i32[3] = 0;
        v32 = sub_8C080(v4, v31, 3270LL, 1);
        v24 = v4[14].m128i_i32[3];
        v5 = v32;
        v33 = v4[14].m128i_i32[2];
        if ( v24 > 0 && v24 <= v4[26].m128i_i32[0] )
        {
          sub_8F1A0(v4, v24, v33);
          v33 = v4[14].m128i_i32[2];
          v24 = v4[14].m128i_i32[3];
        }
        v34 = v24 + 2;
        if ( v24 + 2 > 0 && v34 <= v4[26].m128i_i32[0] )
        {
          sub_8F1A0(v4, v34, v33);
          v24 = v4[14].m128i_i32[3];
        }
      }
      sub_8BB80(v5, v24);
      v27 = (signed __int64 *)(*(_QWORD *)(v5 + 24) + 32LL * v4[14].m128i_i32[3]);
      v28 = v4[14].m128i_i32[3] + 1;
      v27[1] = v4[6].m128i_i32[1];
      v29 = *(__int64 *)((char *)&v4[6].m128i_i64[1] + 4);
      *v27 = v3;
      v27[2] = v29;
      v4[14].m128i_i32[3] = v28;
      sub_8BB80(v5, v28);
      v15 = v4[14].m128i_i32[3];
      result = *(_QWORD *)(v5 + 24) + 32LL * v4[14].m128i_i32[3];
      *(_QWORD *)(result + 8) = v4[6].m128i_i32[1];
      v30 = *(__int64 *)((char *)&v4[6].m128i_i64[1] + 4);
      *(_QWORD *)result = 57343LL;
      *(_QWORD *)(result + 16) = v30;
      goto LABEL_27;
    case 0:
      result = v4[14].m128i_u32[3];
      if ( (signed int)result > 0 )
      {
        v19 = result - 1;
        v20 = *(_QWORD *)(v5 + 24);
        if ( v4[16].m128i_i8[2] )
        {
          if ( *(_QWORD *)(v20 + 32LL * (signed int)result) != 57343LL )
            v19 = v4[14].m128i_i32[3];
        }
        else if ( *(_QWORD *)(v20 + 32LL * v19) == 57343LL )
        {
          if ( (_DWORD)result == 1 )
            __assert_fail("x > 0", "terminal.c", 0xCF7u, "term_display_graphic_char");
          v19 = result - 2;
        }
        result = sub_8BC00(v5, v19, v3);
        goto LABEL_29;
      }
      break;
  }
  return result;
}

__int64 __fastcall sub_8FD90(const __m128i *a1)
{
  const __m128i *v1; // rbx
  bool v2; // zf
  __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 *v5; // rdi
  __int64 result; // rax
  int v7; // eax

  v1 = a1;
  a1[273].m128i_i8[9] = 0;
  v2 = a1[538].m128i_i8[12] == 0;
  v3 = (__int64 *)a1[271].m128i_i64[0];
  v4 = *v3;
  if ( !v2 )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v4 + 152))(v3, v1[539].m128i_u32[0], v1[539].m128i_u32[1]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[538].m128i_i8[12] = 0;
    v4 = *v3;
  }
  if ( v1[539].m128i_i8[8] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v4 + 112))(v3, v1[539].m128i_u32[3], v1[540].m128i_u32[0]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[539].m128i_i8[8] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[4] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD))(v4 + 160))(v3, v1[540].m128i_u8[5]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[4] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[6] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD))(v4 + 136))(v3, v1[540].m128i_u8[7]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[6] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[8] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD))(v4 + 144))(v3, v1[540].m128i_u8[9]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[8] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[10] )
  {
    (*(void (__fastcall **)(__int64 *, __int64))(v4 + 120))(v3, v1[291].m128i_i64[0]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[10] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[11] )
  {
    (*(void (__fastcall **)(__int64 *, __int64))(v4 + 128))(v3, v1[291].m128i_i64[1]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[11] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[12] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD))(v4 + 64))(v3, v1[540].m128i_u8[13]);
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[12] = 0;
    v4 = *v3;
  }
  if ( v1[540].m128i_i8[14] )
  {
    (*(void (**)(void))(v4 + 104))();
    v3 = (__int64 *)v1[271].m128i_i64[0];
    v1[540].m128i_i8[14] = 0;
    v4 = *v3;
  }
  if ( v1[541].m128i_i8[0] )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD, signed __int64))(v4 + 168))(
      v3,
      v1[541].m128i_u32[1],
      (unsigned int)(v1[541].m128i_i32[2] - v1[541].m128i_i32[1]),
      (signed __int64)&v1[488].m128i_i64[1] + 3 * v1[541].m128i_u32[1] + 1);
    v5 = (__int64 *)v1[271].m128i_i64[0];
    v1[541].m128i_i8[0] = 0;
    v4 = *v5;
  }
  result = (*(__int64 (**)(void))v4)();
  if ( (_BYTE)result )
  {
    if ( v1[27].m128i_i8[14] )
    {
      v2 = v1[286].m128i_i8[1] == 0;
      v1[540].m128i_i8[15] = 0;
      if ( !v2 )
      {
        v1[2].m128i_i32[0] = 0;
        v1[27].m128i_i8[14] = 0;
      }
    }
    else
    {
      if ( !v1[540].m128i_i8[15] )
        goto LABEL_26;
      v1[540].m128i_i8[15] = 0;
    }
    v7 = sub_8A550((__int64)v1);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v1[271].m128i_i64[0] + 72LL))(
      v1[271].m128i_i64[0],
      (unsigned int)(v7 + v1[25].m128i_i32[3]),
      (unsigned int)(v7 + v1[2].m128i_i32[0]));
LABEL_26:
    sub_8C7E0(v1);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v1[271].m128i_i64[0] + 48LL))(
      v1[271].m128i_i64[0],
      v1[14].m128i_u32[3],
      (unsigned int)(v1[14].m128i_i32[2] - v1[2].m128i_i32[0]));
    result = (*(__int64 (**)(void))(*(_QWORD *)v1[271].m128i_i64[0] + 40LL))();
  }
  return result;
}

__int64 __fastcall sub_8FFF0(const __m128i *a1, __int64 a2)
{
  __int64 result; // rax
  bool v3; // zf

  if ( a1[274].m128i_i8[8] && a1[275].m128i_i64[0] == a2 )
  {
    a1[18].m128i_i8[4] ^= 1u;
    v3 = a1[18].m128i_i8[5] == 0;
    a1[274].m128i_i8[8] = 0;
    if ( v3 )
      a1[18].m128i_i8[4] = 1;
    else
      sub_8E330((__int64)a1);
    a1[273].m128i_i8[9] = 1;
  }
  if ( a1[274].m128i_i8[9] && a1[275].m128i_i64[1] == a2 )
  {
    a1[18].m128i_i8[3] ^= 1u;
    v3 = a1[282].m128i_i8[14] == 0;
    a1[274].m128i_i8[9] = 0;
    if ( !v3 && a1[26].m128i_i8[8] )
      sub_8E370((__int64)a1);
    else
      a1[18].m128i_i8[3] = 1;
    a1[273].m128i_i8[9] = 1;
  }
  if ( a1[26].m128i_i8[9] && a1[27].m128i_i64[0] == a2 )
  {
    result = a1[273].m128i_u8[10];
    a1[26].m128i_i8[9] = 0;
    a1[273].m128i_i8[9] = 1;
    if ( !(_BYTE)result )
      goto LABEL_20;
  }
  else
  {
    result = a1[273].m128i_u8[9];
    if ( !a1[273].m128i_i8[10] )
      goto LABEL_10;
  }
  if ( a1[274].m128i_i64[0] != a2 )
    return result;
  a1[273].m128i_i8[10] = 0;
LABEL_10:
  if ( (_BYTE)result )
  {
LABEL_20:
    sub_8FD90(a1);
    a1[273].m128i_i8[10] = 1;
    result = sub_99D00(20LL, (__int64)sub_8FFF0, (__int64)a1);
    a1[274].m128i_i64[0] = result;
  }
  return result;
}

void __fastcall sub_90160(const __m128i *a1)
{
  if ( a1[273].m128i_i8[9] )
  {
    if ( !a1[273].m128i_i8[10] )
    {
      sub_8FD90(a1);
      a1[273].m128i_i8[10] = 1;
      a1[274].m128i_i64[0] = sub_99D00(20LL, (__int64)sub_8FFF0, (__int64)a1);
    }
  }
}

void __fastcall sub_901B0(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *i; // rdi
  bool v3; // zf

  v1 = a1;
  *(_BYTE *)(a1 + 84) = 0;
  for ( i = *(_QWORD **)(a1 + 64); i; i = *(_QWORD **)(v1 + 64) )
  {
    *(_QWORD *)(v1 + 64) = *i;
    sub_2F4D0(i);
  }
  v3 = *(_BYTE *)(v1 + 4578) == 0;
  *(_QWORD *)(v1 + 72) = 0LL;
  *(_DWORD *)(v1 + 80) = 0;
  if ( !v3 )
  {
    v3 = *(_BYTE *)(v1 + 4377) == 0;
    *(_DWORD *)(v1 + 32) = 0;
    *(_BYTE *)(v1 + 446) = 1;
    if ( v3 )
      sub_8E2A0(v1);
  }
}

unsigned __int64 __fastcall sub_90220(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rdi
  char v3; // al
  __int64 *v4; // rdi
  char v5; // al
  __int64 *v6; // rdi
  int v7; // eax
  __int64 *v8; // rdi
  char v9; // al
  __int64 *v10; // rdi
  int v11; // eax
  __int64 *v12; // rdi
  int v13; // eax
  __int64 *v14; // rdi
  int v15; // eax
  __int64 *v16; // rdi
  char v17; // al
  __int64 *v18; // rdi
  char v19; // al
  __int64 *v20; // rdi
  char v21; // al
  __int64 *v22; // rdi
  char v23; // al
  __int64 *v24; // rdi
  char v25; // al
  __int64 *v26; // rdi
  int v27; // eax
  __int64 *v28; // rdi
  int v29; // eax
  __int64 *v30; // rdi
  char v31; // al
  __int64 *v32; // rdi
  char v33; // al
  __int64 *v34; // rdi
  int v35; // eax
  __int64 *v36; // rdi
  char v37; // al
  __int64 *v38; // rdi
  char v39; // al
  __int64 *v40; // rdi
  int v41; // eax
  __int64 *v42; // rdi
  char v43; // al
  __int64 *v44; // rdi
  char v45; // al
  __int64 *v46; // rdi
  char v47; // al
  __int64 *v48; // rdi
  char v49; // al
  __int64 *v50; // rdi
  char v51; // al
  __int64 *v52; // rdi
  char v53; // al
  __int64 *v54; // rdi
  char v55; // al
  __int64 *v56; // rdi
  char v57; // al
  __int64 *v58; // rdi
  char v59; // al
  __int64 *v60; // rdi
  char v61; // al
  __int64 *v62; // rdi
  char v63; // al
  __int64 *v64; // rdi
  char v65; // al
  __int64 *v66; // rdi
  char v67; // al
  __int64 *v68; // rdi
  char v69; // al
  __int64 *v70; // rdi
  int v71; // eax
  __int64 *v72; // rdi
  char v73; // al
  __int64 *v74; // rdi
  char v75; // al
  __int64 *v76; // rdi
  char v77; // al
  __int64 *v78; // rdi
  char v79; // al
  __int64 *v80; // rdi
  char v81; // al
  __int64 *v82; // rdi
  char v83; // al
  __int64 *v84; // rdi
  const char *v85; // rax
  const char *v86; // rbp
  int v87; // eax
  void *v88; // rax
  __int64 v89; // rdx
  __int64 v90; // rcx
  char v91; // al
  __int64 v92; // rax
  __int64 v93; // rdx
  const char *v95; // [rsp+0h] [rbp-28h]
  unsigned __int64 v96; // [rsp+8h] [rbp-20h]

  v1 = a1;
  v2 = *(__int64 **)(a1 + 4368);
  v96 = __readfsqword(0x28u);
  v3 = sub_1EF00(v2, 141);
  v4 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4481) = v3;
  v5 = sub_1EF00(v4, 139);
  v6 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4500) = v5;
  v7 = sub_1EFD0(v6, 110);
  v8 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4504) = v7;
  v9 = sub_1EF00(v8, 112);
  v10 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4508) = v9;
  v11 = sub_1EFD0(v10, 113);
  v12 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4512) = v11;
  v13 = sub_1EFD0(v12, 115);
  v14 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4516) = v13;
  v15 = sub_1EFD0(v14, 114);
  v16 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4520) = v15;
  v17 = sub_1EF00(v16, 140);
  v18 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4524) = v17;
  v19 = sub_1EF00(v18, 71);
  v20 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4525) = v19;
  v21 = sub_1EF00(v20, 109);
  v22 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4526) = v21;
  v23 = sub_1EF00(v22, 121);
  v24 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4527) = v23;
  v25 = sub_1EF00(v24, 165);
  v26 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4528) = v25;
  v27 = sub_1EFD0(v26, 124);
  v28 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4532) = v27;
  v29 = sub_1EFD0(v28, 123);
  v30 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4536) = v29;
  v31 = sub_1EF00(v30, 201);
  v32 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4540) = v31;
  v33 = sub_1EF00(v32, 98);
  v34 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4541) = v33;
  v35 = sub_1EFD0(v34, 73);
  v36 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4544) = v35;
  v37 = sub_1EF00(v36, 107);
  v38 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4548) = v37;
  v39 = sub_1EF00(v38, 130);
  v40 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4549) = v39;
  v41 = sub_1EFD0(v40, 128);
  v42 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4552) = v41;
  v43 = sub_1EF00(v42, 154);
  v44 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4556) = v43;
  v45 = sub_1EF00(v44, 86);
  v46 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4557) = v45;
  v47 = sub_1EF00(v46, 78);
  v48 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4558) = v47;
  v49 = sub_1EF00(v48, 74);
  v50 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4559) = v49;
  v51 = sub_1EF00(v50, 75);
  v52 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4560) = v51;
  v53 = sub_1EF00(v52, 81);
  v54 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4561) = v53;
  v55 = sub_1EF00(v54, 76);
  v56 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4562) = v55;
  v57 = sub_1EF00(v56, 82);
  v58 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4563) = v57;
  v59 = sub_1EF00(v58, 77);
  v60 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4564) = v59;
  v61 = sub_1EF00(v60, 79);
  v62 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4565) = v61;
  v63 = sub_1EF00(v62, 80);
  v64 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4566) = v63;
  v65 = sub_1EF00(v64, 151);
  v66 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4567) = v65;
  v67 = sub_1EF00(v66, 152);
  v68 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4568) = v67;
  v69 = sub_1EF00(v68, 149);
  v70 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4569) = v69;
  v71 = sub_1EFD0(v70, 83);
  v72 = *(__int64 **)(v1 + 4368);
  *(_DWORD *)(v1 + 4572) = v71;
  v73 = sub_1EF00(v72, 72);
  v74 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4576) = v73;
  v75 = sub_1EF00(v74, 97);
  v76 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4577) = v75;
  v77 = sub_1EF00(v76, 96);
  v78 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4578) = v77;
  v79 = sub_1EF00(v78, 76);
  v80 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 448) = v79;
  v81 = sub_1EF00(v80, 142);
  v82 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4579) = v81;
  v83 = sub_1EF00(v82, 143);
  v84 = *(__int64 **)(v1 + 4368);
  *(_BYTE *)(v1 + 4580) = v83;
  v85 = (const char *)sub_1F170(v84, 137);
  v86 = v85;
  v87 = strlen(v85);
  v88 = sub_2F450(v87, 1uLL, 0LL);
  *(_DWORD *)(v1 + 4496) = 0;
  for ( *(_QWORD *)(v1 + 4488) = v88; *v86; *(_BYTE *)(v93 + v92) = *(v86 - 1) )
  {
    while ( 1 )
    {
      v91 = sub_BBFA0(v86, (char **)&v95);
      if ( !v95 )
        break;
      v89 = *(signed int *)(v1 + 4496);
      v90 = *(_QWORD *)(v1 + 4488);
      *(_DWORD *)(v1 + 4496) = v89 + 1;
      *(_BYTE *)(v90 + v89) = v91;
      v86 = v95;
      if ( !*v95 )
        return __readfsqword(0x28u) ^ v96;
    }
    v92 = *(signed int *)(v1 + 4496);
    v93 = *(_QWORD *)(v1 + 4488);
    ++v86;
    *(_DWORD *)(v1 + 4496) = v92 + 1;
  }
  return __readfsqword(0x28u) ^ v96;
}

signed int *__fastcall sub_906C0(__int64 a1, _QWORD *a2)
{
  return sub_1F890(a2, 103, *(char **)(a1 + 4656));
}

void __fastcall sub_906E0(const __m128i *a1)
{
  void *v1; // rax
  int v2; // ebp
  __int64 v3; // rax
  int v4; // edx
  bool v5; // zf

  a1[2].m128i_i32[0] = 0;
  while ( 1 )
  {
    v1 = (void *)sub_9B400((__int64 *)a1->m128i_i64[1], 0);
    if ( !v1 )
      break;
    sub_2F4D0(v1);
  }
  if ( a1[25].m128i_i32[3] > 0 )
  {
    v2 = 0;
    do
    {
      v3 = sub_8C080(a1, v2, 1768LL, 1);
      v4 = a1[26].m128i_i32[0];
      if ( v4 != *(_DWORD *)(v3 + 4) )
        sub_8BED0(a1, v3, v4);
      ++v2;
    }
    while ( a1[25].m128i_i32[3] > v2 );
  }
  if ( a1[234].m128i_i32[1] && a1[235].m128i_i32[0] < 0 )
  {
    a1[234].m128i_i32[1] = 0;
    a1[235] = 0uLL;
  }
  v5 = a1[273].m128i_i8[9] == 0;
  a1[2].m128i_i32[1] = 0;
  a1[32].m128i_i32[0] = 0;
  a1[540].m128i_i8[15] = 1;
  if ( v5 )
    sub_8E2A0((__int64)a1);
}

char *__fastcall sub_907E0(__int64 a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbx
  char *v11; // rbp
  double v12; // xmm4_8
  double v13; // xmm5_8
  char *v14; // rdi
  char *result; // rax

  v10 = a1;
  v11 = (char *)sub_1F170(*(__int64 **)(a1 + 4368), 103);
  sub_2F4D0(*(void **)(a1 + 4656));
  sub_2F4D0(*(void **)(a1 + 4664));
  if ( *v11 )
  {
    *(_QWORD *)(a1 + 4656) = sub_BC120(v11);
    result = sub_BC120(v11);
    *(_QWORD *)(a1 + 4664) = result;
  }
  else
  {
    if ( a2 && *a2 )
    {
      v14 = sub_BC160(a2, a3, a4, a5, a6, v12, v13, a9, a10, " - ", "PuTTY", 0LL);
      *(_QWORD *)(v10 + 4656) = v14;
    }
    else
    {
      v14 = sub_BC120("PuTTY");
      *(_QWORD *)(v10 + 4656) = v14;
    }
    result = sub_BC120(v14);
    *(_QWORD *)(v10 + 4664) = result;
  }
  *(_BYTE *)(v10 + 8650) = 1;
  *(_BYTE *)(v10 + 8651) = 1;
  return result;
}

void __fastcall sub_908E0(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rax
  void **v3; // rax
  void **v4; // rax
  char *v5; // rax
  __int64 v6; // r12
  int v7; // ebp
  void **v8; // rdi
  _QWORD *i; // rdi
  FILE **v10; // rdi
  unsigned __int64 v11; // r12
  __int64 v12; // rbp

  v1 = a1;
  while ( 1 )
  {
    v2 = (void *)sub_9B400(*(__int64 **)(a1 + 8), 0);
    if ( !v2 )
      break;
    sub_2F4D0(v2);
  }
  sub_9AF90(*(_QWORD ***)(a1 + 8));
  while ( 1 )
  {
    v3 = (void **)sub_9B400(*(__int64 **)(a1 + 16), 0);
    if ( !v3 )
      break;
    sub_8C3C0(v3);
  }
  sub_9AF90(*(_QWORD ***)(a1 + 16));
  while ( 1 )
  {
    v4 = (void **)sub_9B400(*(__int64 **)(a1 + 24), 0);
    if ( !v4 )
      break;
    sub_8C3C0(v4);
  }
  sub_9AF90(*(_QWORD ***)(a1 + 24));
  v5 = *(char **)(a1 + 40);
  if ( v5 && *(_DWORD *)(a1 + 412) > 0 )
  {
    v6 = 0LL;
    v7 = 0;
    do
    {
      v8 = *(void ***)&v5[v6];
      if ( v8 )
      {
        sub_8C3C0(v8);
        v5 = *(char **)(v1 + 40);
      }
      ++v7;
      v6 += 8LL;
    }
    while ( *(_DWORD *)(v1 + 412) > v7 );
  }
  sub_2F4D0(v5);
  for ( i = *(_QWORD **)(v1 + 64); i; i = *(_QWORD **)(v1 + 64) )
  {
    *(_QWORD *)(v1 + 64) = *i;
    sub_2F4D0(i);
  }
  sub_BCCA0(v1 + 192);
  v10 = *(FILE ***)(v1 + 368);
  if ( v10 )
    sub_B81C0(v10);
  sub_BCCA0(v1 + 328);
  sub_2F4D0(*(void **)(v1 + 4304));
  sub_2F4D0(*(void **)(v1 + 4416));
  sub_2F4D0(*(void **)(v1 + 4432));
  sub_2F4D0(*(void **)(v1 + 4440));
  sub_2F4D0(*(void **)(v1 + 4488));
  if ( *(_QWORD *)(v1 + 4472) )
  {
    v11 = 0LL;
    do
    {
      v12 = v11++;
      v12 *= 32LL;
      sub_2F4D0(*(void **)(*(_QWORD *)(v1 + 4456) + v12 + 8));
      sub_2F4D0(*(void **)(*(_QWORD *)(v1 + 4464) + v12 + 8));
      sub_2F4D0(*(void **)(*(_QWORD *)(v1 + 4464) + v12 + 16));
      sub_2F4D0(*(void **)(*(_QWORD *)(v1 + 4464) + v12 + 24));
    }
    while ( *(_QWORD *)(v1 + 4472) > v11 );
  }
  sub_2F4D0(*(void **)(v1 + 4456));
  sub_2F4D0(*(void **)(v1 + 4464));
  sub_2F4D0(*(void **)(v1 + 3736));
  sub_99EF0(v1);
  sub_1BCD0(v1);
  sub_1ED50(*(_QWORD **)(v1 + 4368));
  sub_2F4D0(*(void **)(v1 + 4656));
  sub_2F4D0(*(void **)(v1 + 4664));
  sub_2F4D0((void *)v1);
}

void __fastcall sub_90B00(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 4480) = a2;
}

__int64 __fastcall sub_90B10(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  __int64 result; // rax

  *a2 = *(_DWORD *)(a1 + 236);
  result = *(unsigned int *)(a1 + 232);
  *a3 = result;
  return result;
}

__int64 __fastcall sub_90B30(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(a1 + 4320) = a2;
  if ( a2 && *(_DWORD *)(a1 + 416) > 0 && *(_DWORD *)(a1 + 412) > 0 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 40LL))(a2);
  return result;
}

signed __int16 __fastcall sub_90B70(__int64 a1, int *a2, unsigned __int64 a3)
{
  signed __int16 result; // ax
  __int64 v4; // r8
  int v5; // ecx
  signed int v6; // ecx
  unsigned __int8 v7; // dl
  signed int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  signed __int64 v12; // rsi
  char v13; // dl
  signed __int16 v14; // cx

  result = (unsigned __int8)a3;
  if ( !*(_BYTE *)(a1 + 305) )
  {
    v4 = *(_QWORD *)(a1 + 4352);
    if ( *(_DWORD *)(v4 + 16) != 55 )
    {
      v5 = *(_DWORD *)(a1 + 296);
      if ( v5 )
      {
        if ( (unsigned __int8)a3 > 0x1Bu || (v12 = 134227200LL, !_bittest64(&v12, a3)) )
        {
          v13 = a3 | 0x80;
          if ( v5 == 2 )
            LOBYTE(result) = v13;
          HIBYTE(result) = -38;
          return result;
        }
      }
      v6 = *(_DWORD *)(a1 + 4LL * *(signed int *)(a1 + 260) + 468);
      if ( v6 != 55552 )
      {
        if ( v6 <= 55552 )
        {
          if ( v6 != 55296 )
            return result;
        }
        else
        {
          if ( v6 == 55808 )
          {
            LOBYTE(v14) = a3;
            HIBYTE(v14) = -38;
            if ( (unsigned __int8)a3 > 0x1Fu )
              result = v14;
            return result;
          }
          if ( v6 != 56064 )
            return result;
          if ( (_BYTE)a3 == 35 )
            return -9859;
        }
        v7 = *(_BYTE *)(v4 + (unsigned __int8)a3 + 5140);
        if ( v7 == -1 )
        {
LABEL_10:
          HIBYTE(result) |= 0xD8u;
          return result;
        }
        return v7;
      }
      v7 = *(_BYTE *)(v4 + (unsigned __int8)a3 + 5140);
      if ( v7 != -1 )
        return v7;
LABEL_47:
      HIBYTE(result) |= 0xD9u;
      return result;
    }
  }
  v8 = *a2;
  if ( !*a2 )
  {
    if ( (a3 & 0x80u) == 0LL )
    {
      v7 = *(_BYTE *)(*(_QWORD *)(a1 + 4352) + (unsigned __int8)a3 + 5140LL);
      if ( v7 != -1 )
        return v7;
      if ( !*(_BYTE *)(a1 + 4568) || *(_DWORD *)(a1 + 4LL * *(signed int *)(a1 + 260) + 468) != 55552 )
        goto LABEL_10;
      goto LABEL_47;
    }
    if ( (a3 & 0xE0) == -64 )
    {
      *a2 = 1;
      a2[2] = 1;
      a2[1] = a3 & 0x1F;
      return 63;
    }
    if ( (a3 & 0xF0) == -32 )
    {
      *a2 = 2;
      a2[2] = 2;
      a2[1] = a3 & 0xF;
      return 63;
    }
    if ( (a3 & 0xF8) == -16 )
    {
      *a2 = 3;
      a2[2] = 3;
      a2[1] = a3 & 7;
      return 63;
    }
    if ( (a3 & 0xFC) == -8 )
    {
      *a2 = 4;
      a2[2] = 4;
      a2[1] = a3 & 3;
      return 63;
    }
    if ( (a3 & 0xFE) == -4 )
    {
      *a2 = 5;
      a2[2] = 5;
      a2[1] = a3 & 1;
      return 63;
    }
    return 42;
  }
  if ( v8 < 0 || v8 > 5 )
    return result;
  if ( (a3 & 0xC0) != -128 )
  {
    *a2 = 0;
    return 33;
  }
  v9 = a2[1];
  v10 = v8 - 1;
  *a2 = v10;
  v11 = (v9 << 6) | a3 & 0x3F;
  result = 63;
  a2[1] = v11;
  if ( v10 )
    return result;
  result = v11;
  if ( (unsigned __int64)v11 <= 0x7F )
    return 42;
  if ( (unsigned __int64)v11 > 0x7FF )
  {
    if ( (unsigned __int64)v11 <= 0xFFFF )
    {
      if ( a2[2] > 2 )
        return 42;
    }
    else if ( (unsigned __int64)v11 <= 0x1FFFFF )
    {
      if ( a2[2] > 3 )
        return 42;
    }
    else if ( (unsigned __int64)v11 <= 0x3FFFFFF && a2[2] > 4 )
    {
      return 42;
    }
  }
  else if ( a2[2] > 1 )
  {
    return 42;
  }
  if ( (unsigned __int64)(v11 - 8232LL) <= 1 )
    return 133;
  if ( (unsigned __int64)v11 <= 0x9F )
    return -3;
  if ( (unsigned __int64)(v11 - 55296LL) <= 0x7FF || v11 > (unsigned __int64)&unk_10FFFF )
    return 42;
  if ( (unsigned __int64)(v11 - 917504LL) <= 0x7F || v11 == 65279LL )
    return 63;
  if ( (unsigned __int64)(v11 - 65534LL) <= 1 )
    return 42;
  return result;
}

signed __int64 __fastcall sub_90EF0(__int64 a1)
{
  signed __int64 result; // rax
  int v2; // er8
  __int64 v3; // rcx
  signed __int64 v4; // r9
  __int64 v5; // rdx
  signed __int64 v6; // rdx

  result = *(unsigned int *)(a1 + 412);
  if ( (signed int)result > 0 )
  {
    v2 = *(_DWORD *)(a1 + 416);
    result = (unsigned int)(result - 1);
    v3 = 0LL;
    v4 = 8 * result + 8;
    do
    {
      if ( v2 > 0 )
      {
        v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + v3) + 24LL);
        result = v5 + 8;
        v6 = 32LL * (unsigned int)(v2 - 1) + 40 + v5;
        do
        {
          *(_QWORD *)result |= 0x3FFFFuLL;
          result += 32LL;
        }
        while ( result != v6 );
      }
      v3 += 8LL;
    }
    while ( v3 != v4 );
  }
  if ( !*(_BYTE *)(a1 + 4377) )
    result = (signed __int64)sub_8E2A0(a1);
  return result;
}

void __fastcall sub_90F70(__m128i *a1, char a2, char a3, char a4)
{
  int v4; // eax
  unsigned int v5; // ebp
  unsigned int v6; // er13
  char v7; // r12
  int v8; // esi
  __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // r14
  bool v12; // zf
  bool v13; // sf
  unsigned __int8 v14; // of
  int v15; // edx
  __int32 v16; // ecx
  signed int v17; // [rsp+8h] [rbp-40h]
  char v18; // [rsp+Fh] [rbp-39h]

  v4 = a1[14].m128i_i32[2];
  if ( a2 )
  {
    v5 = v4 + 1;
    v6 = a1[14].m128i_u32[2];
    v7 = 0;
  }
  else
  {
    v5 = a1[25].m128i_u32[3];
    v6 = 0;
    v7 = 1;
  }
  v8 = a1[14].m128i_i32[3];
  if ( !a3 )
  {
    if ( a1[16].m128i_i8[2] )
    {
      if ( a1[26].m128i_i32[0] == v8 )
      {
        ++v4;
        v8 = 0;
      }
      else
      {
        ++v8;
      }
    }
    v6 = v4;
    v9 = (unsigned int)v8;
    if ( a4 )
    {
      v17 = 0;
      v10 = 0LL;
      goto LABEL_8;
    }
LABEL_6:
    if ( a1[26].m128i_i32[0] == v8 )
    {
      v5 = v4 + 1;
      v17 = 0;
      v10 = 0LL;
LABEL_11:
      sub_8BB10(a1, (v9 << 32) | v6, (v10 << 32) | v5);
      if ( v6 || (_DWORD)v9 )
        goto LABEL_13;
      v6 = v17;
      goto LABEL_28;
    }
    v10 = (unsigned int)(v8 + 1);
    v5 = v4;
    v8 = v10;
    v17 = v10;
LABEL_8:
    if ( v8 > 0 && a1[26].m128i_i32[0] >= v8 )
      sub_8F1A0(a1, v8, v4);
    goto LABEL_11;
  }
  if ( !a4 )
  {
    v9 = 0LL;
    goto LABEL_6;
  }
  sub_8BB10(a1, v6, v5);
  if ( v6 )
  {
    v17 = 0;
    LODWORD(v9) = 0;
    goto LABEL_13;
  }
LABEL_28:
  if ( a1[25].m128i_i32[3] == v5 )
    sub_90EF0((__int64)a1);
  v18 = v7 & (v6 == 0);
  if ( !((unsigned __int8)v7 & (v6 == 0)) )
  {
    v17 = v6;
    LODWORD(v9) = 0;
    v6 = 0;
LABEL_13:
    v18 = 0;
    goto LABEL_14;
  }
  if ( a1[283].m128i_i8[13] )
  {
    if ( a1[25].m128i_i32[3] == v5 )
      v5 = (unsigned __int64)sub_8B960((__int64)a1, a1[1].m128i_i64[0]) + 1;
    if ( (signed int)v5 > 0 )
      sub_8ED60(a1, 0, v5 - 1, v5, 1);
LABEL_47:
    if ( !a1[31].m128i_i32[3] )
      a1[2].m128i_i32[1] = 0;
    return;
  }
  v17 = 0;
  LODWORD(v9) = 0;
  v6 = 0;
LABEL_14:
  v11 = sub_8C080(a1, v6, 2856LL, 1);
  if ( *(_BYTE *)(v11 + 32) != a1[280].m128i_i8[0] )
  {
    sub_8C1C0(a1, (_WORD *)v11);
    *(_BYTE *)(v11 + 32) = a1[280].m128i_i8[0];
  }
LABEL_16:
  v14 = __OFSUB__(v5, v6);
  v12 = v5 == v6;
  v13 = (signed int)(v5 - v6) < 0;
  if ( v5 == v6 )
  {
    while ( (signed int)v9 < v17 )
    {
LABEL_18:
      v15 = a1[26].m128i_i32[0];
      v16 = *(_DWORD *)(v11 + 4);
      if ( v15 != v16 )
      {
        sub_8BED0(a1, v11, v15);
        v16 = a1[26].m128i_i32[0];
      }
      if ( (_DWORD)v9 == v16 )
      {
        if ( v7 )
          *(_WORD *)v11 = 0;
        else
          *(_WORD *)v11 &= 0xFFCFu;
LABEL_23:
        ++v6;
        LODWORD(v9) = 0;
        if ( a1[25].m128i_i32[3] > (signed int)v6 )
        {
          LODWORD(v9) = 0;
          v11 = sub_8C080(a1, v6, 2869LL, 1);
          if ( *(_BYTE *)(v11 + 32) != a1[280].m128i_i8[0] )
          {
            sub_8C1C0(a1, (_WORD *)v11);
            *(_BYTE *)(v11 + 32) = a1[280].m128i_i8[0];
          }
        }
        goto LABEL_16;
      }
      sub_8BE60(v11, v9, a1 + 10);
      if ( a1[26].m128i_i32[0] == (_DWORD)v9 )
        goto LABEL_23;
      LODWORD(v9) = v9 + 1;
      v14 = __OFSUB__(v5, v6);
      v12 = v5 == v6;
      v13 = (signed int)(v5 - v6) < 0;
      if ( v5 != v6 )
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    if ( !((unsigned __int8)(v13 ^ v14) | v12) )
      goto LABEL_18;
  }
  if ( v18 )
    goto LABEL_47;
}

void __fastcall sub_912F0(__int64 a1, int a2, char a3, char a4)
{
  char v4; // r12
  __int64 v5; // rbx
  int v6; // edi
  char v7; // bp
  char v8; // al
  __int64 v9; // rdx
  int v10; // ecx
  __int64 v11; // rsi
  int v12; // edx
  char v13; // cl
  int v14; // er15
  int v15; // er13
  int v16; // er14
  int v17; // er11
  char v18; // r10
  char v19; // r9
  char v20; // r8
  char v21; // di
  int v22; // esi
  int v23; // eax
  int v24; // er12
  int v25; // er12
  int v26; // er12
  int v27; // ecx
  int v28; // er12
  char v29; // r11
  char v30; // r10
  char v31; // r9
  char v32; // r8
  int v33; // edi
  char v34; // si
  __int64 v35; // rcx
  __int64 v36; // rcx
  int v37; // ecx
  int v38; // eax
  int v39; // [rsp+8h] [rbp-60h]
  char v40; // [rsp+Dh] [rbp-5Bh]
  char v41; // [rsp+Eh] [rbp-5Ah]
  char v42; // [rsp+Fh] [rbp-59h]
  char v43; // [rsp+10h] [rbp-58h]
  char v44; // [rsp+11h] [rbp-57h]
  char v45; // [rsp+12h] [rbp-56h]
  char v46; // [rsp+13h] [rbp-55h]
  char v47; // [rsp+14h] [rbp-54h]
  char v48; // [rsp+15h] [rbp-53h]
  char v49; // [rsp+16h] [rbp-52h]
  char v50; // [rsp+17h] [rbp-51h]
  int v51; // [rsp+18h] [rbp-50h]
  int v52; // [rsp+1Ch] [rbp-4Ch]
  int v53; // [rsp+20h] [rbp-48h]
  int v54; // [rsp+24h] [rbp-44h]
  int v55; // [rsp+28h] [rbp-40h]
  int v56; // [rsp+2Ch] [rbp-3Ch]

  v4 = a4;
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 508);
  if ( a2 )
  {
    v7 = a3;
    if ( a2 == v6 )
      goto LABEL_16;
    v4 = a3 | a4;
  }
  else
  {
    v7 = 0;
    if ( !v6 )
      return;
  }
  v8 = *(_BYTE *)(v5 + 4541);
  v9 = *(_QWORD *)(v5 + 24);
  if ( v8 )
  {
    if ( v6 )
    {
      if ( v9 )
      {
        v10 = *(_DWORD *)(v5 + 32);
        if ( v10 < 0 )
        {
          v37 = *(_DWORD *)(v5 + 512) + v10;
          if ( v37 > 0 )
            v37 = 0;
          *(_DWORD *)(v5 + 32) = v37;
        }
      }
    }
  }
  *(_DWORD *)(v5 + 508) = a2;
  v11 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 16) = v9;
  v12 = 0;
  *(_QWORD *)(v5 + 24) = v11;
  if ( v11 )
  {
    v12 = (unsigned __int64)sub_8B960(v5, v11) + 1;
    v8 = *(_BYTE *)(v5 + 4541);
  }
  v13 = *(_BYTE *)(v5 + 305);
  *(_DWORD *)(v5 + 512) = v12;
  v14 = *(_DWORD *)(v5 + 236);
  v15 = *(_DWORD *)(v5 + 248);
  v16 = *(_DWORD *)(v5 + 232);
  v17 = *(_DWORD *)(v5 + 252);
  v18 = *(_BYTE *)(v5 + 256);
  v19 = *(_BYTE *)(v5 + 257);
  v40 = v13;
  v20 = *(_BYTE *)(v5 + 258);
  v21 = *(_BYTE *)(v5 + 259);
  v22 = *(_DWORD *)(v5 + 260);
  v56 = *(_DWORD *)(v5 + 296);
  v55 = *(_DWORD *)(v5 + 240);
  v54 = *(_DWORD *)(v5 + 244);
  v53 = *(_DWORD *)(v5 + 264);
  v52 = *(_DWORD *)(v5 + 268);
  v51 = *(_DWORD *)(v5 + 104);
  v50 = *(_BYTE *)(v5 + 116);
  v49 = *(_BYTE *)(v5 + 117);
  v48 = *(_BYTE *)(v5 + 118);
  v47 = *(_BYTE *)(v5 + 119);
  v46 = *(_BYTE *)(v5 + 120);
  v45 = *(_BYTE *)(v5 + 121);
  v44 = *(_BYTE *)(v5 + 122);
  v43 = *(_BYTE *)(v5 + 123);
  v42 = *(_BYTE *)(v5 + 272);
  v41 = *(_BYTE *)(v5 + 273);
  v39 = *(_DWORD *)(v5 + 300);
  if ( !v4 )
  {
    v24 = *(_DWORD *)(v5 + 476);
    *(_DWORD *)(v5 + 476) = v14;
    *(_DWORD *)(v5 + 236) = v24;
    v25 = *(_DWORD *)(v5 + 480);
    *(_DWORD *)(v5 + 480) = v16;
    *(_DWORD *)(v5 + 232) = v25;
LABEL_22:
    v26 = *(_DWORD *)(v5 + 500);
    v27 = *(_DWORD *)(v5 + 492);
    *(_DWORD *)(v5 + 500) = v15;
    *(_DWORD *)(v5 + 248) = v26;
    v28 = *(_DWORD *)(v5 + 504);
    *(_DWORD *)(v5 + 504) = v17;
    v29 = *(_BYTE *)(v5 + 486);
    *(_BYTE *)(v5 + 486) = v18;
    v30 = *(_BYTE *)(v5 + 487);
    *(_BYTE *)(v5 + 487) = v19;
    v31 = *(_BYTE *)(v5 + 484);
    *(_BYTE *)(v5 + 484) = v20;
    v32 = *(_BYTE *)(v5 + 485);
    *(_BYTE *)(v5 + 485) = v21;
    v33 = *(_DWORD *)(v5 + 488);
    *(_DWORD *)(v5 + 488) = v22;
    v34 = *(_BYTE *)(v5 + 496);
    *(_DWORD *)(v5 + 296) = v27;
    v35 = *(_QWORD *)(v5 + 376);
    *(_DWORD *)(v5 + 260) = v33;
    *(_DWORD *)(v5 + 252) = v28;
    *(_BYTE *)(v5 + 256) = v29;
    *(_BYTE *)(v5 + 305) = v34;
    *(_DWORD *)(v5 + 492) = v56;
    *(_QWORD *)(v5 + 240) = v35;
    *(_BYTE *)(v5 + 257) = v30;
    *(_BYTE *)(v5 + 258) = v31;
    *(_BYTE *)(v5 + 259) = v32;
    *(_BYTE *)(v5 + 496) = v40;
    *(_DWORD *)(v5 + 376) = v55;
    LODWORD(v35) = *(_DWORD *)(v5 + 396);
    *(_DWORD *)(v5 + 380) = v54;
    *(_DWORD *)(v5 + 264) = v35;
    LODWORD(v35) = *(_DWORD *)(v5 + 400);
    *(_DWORD *)(v5 + 396) = v53;
    *(_DWORD *)(v5 + 268) = v35;
    LODWORD(v35) = *(_DWORD *)(v5 + 384);
    *(_DWORD *)(v5 + 384) = v51;
    *(_DWORD *)(v5 + 400) = v52;
    *(_DWORD *)(v5 + 104) = v35;
    v36 = *(_QWORD *)(v5 + 388);
    *(_BYTE *)(v5 + 389) = v49;
    *(_BYTE *)(v5 + 388) = v50;
    *(_QWORD *)(v5 + 116) = v36;
    *(_BYTE *)(v5 + 391) = v47;
    *(_BYTE *)(v5 + 390) = v48;
    *(_BYTE *)(v5 + 393) = v45;
    *(_BYTE *)(v5 + 392) = v46;
    *(_BYTE *)(v5 + 395) = v43;
    *(_BYTE *)(v5 + 394) = v44;
    *(_BYTE *)(v5 + 272) = *(_BYTE *)(v5 + 404);
    LOBYTE(v36) = *(_BYTE *)(v5 + 405);
    *(_BYTE *)(v5 + 404) = v42;
    *(_BYTE *)(v5 + 405) = v41;
    *(_BYTE *)(v5 + 273) = v36;
    LODWORD(v36) = *(_DWORD *)(v5 + 408);
    *(_DWORD *)(v5 + 408) = v39;
    *(_DWORD *)(v5 + 300) = v36;
    if ( !v8 )
      return;
    if ( !*(_QWORD *)(v5 + 24) || !*(_DWORD *)(v5 + 508) )
      goto LABEL_16;
    goto LABEL_15;
  }
  *(_DWORD *)(v5 + 476) = v14;
  *(_DWORD *)(v5 + 480) = v16;
  if ( !v7 )
    goto LABEL_22;
  *(_BYTE *)(v5 + 485) = v21;
  *(_DWORD *)(v5 + 488) = v22;
  *(_DWORD *)(v5 + 500) = v15;
  *(_DWORD *)(v5 + 504) = v17;
  *(_BYTE *)(v5 + 486) = v18;
  *(_BYTE *)(v5 + 487) = v19;
  *(_BYTE *)(v5 + 496) = v13;
  *(_DWORD *)(v5 + 492) = v56;
  *(_BYTE *)(v5 + 484) = v20;
  *(_DWORD *)(v5 + 376) = v55;
  *(_DWORD *)(v5 + 380) = v54;
  *(_DWORD *)(v5 + 396) = v53;
  *(_DWORD *)(v5 + 400) = v52;
  *(_DWORD *)(v5 + 384) = v51;
  *(_BYTE *)(v5 + 388) = v50;
  *(_BYTE *)(v5 + 389) = v49;
  *(_BYTE *)(v5 + 390) = v48;
  *(_BYTE *)(v5 + 391) = v47;
  *(_BYTE *)(v5 + 392) = v46;
  *(_BYTE *)(v5 + 393) = v45;
  *(_BYTE *)(v5 + 394) = v44;
  *(_BYTE *)(v5 + 395) = v43;
  *(_BYTE *)(v5 + 404) = v42;
  *(_BYTE *)(v5 + 405) = v41;
  *(_DWORD *)(v5 + 408) = v39;
  if ( v8 && *(_QWORD *)(v5 + 24) && *(_DWORD *)(v5 + 508) )
  {
LABEL_15:
    v23 = *(_DWORD *)(v5 + 32);
    if ( v23 < 0 )
    {
      *(_DWORD *)(v5 + 32) = v23 - v12;
      v38 = -sub_8A550(v5);
      if ( *(_DWORD *)(v5 + 32) < v38 )
        *(_DWORD *)(v5 + 32) = v38;
    }
LABEL_16:
    if ( !v7 )
      return;
  }
  if ( *(_QWORD *)(v5 + 16) )
    sub_90F70((__m128i *)v5, 0, 1, 1);
}

void __fastcall sub_91860(const __m128i *a1, signed int a2, int a3, signed int a4)
{
  signed int v4; // ebp
  const __m128i *v5; // r15
  signed int v6; // er12
  bool v7; // zf
  int v8; // eax
  __int32 v9; // er14
  int v10; // ebx
  __int32 i; // esi
  void *v12; // r13
  _QWORD *v13; // r14
  __int32 v14; // eax
  _QWORD *v15; // r14
  int v16; // eax
  void **v17; // rax
  int v18; // esi
  __int64 *v19; // rdi
  unsigned __int16 *v20; // rax
  void **v21; // r14
  signed __int64 *v22; // rax
  void *v23; // rax
  __int64 v24; // r14
  _QWORD *v25; // rbx
  _QWORD *v26; // rax
  signed int v27; // edx
  _QWORD *v28; // rax
  char *v29; // rdx
  __int64 v30; // r14
  void **v31; // rdi
  signed int v32; // ebx
  _QWORD *v33; // r14
  _QWORD *v34; // rax
  int v35; // edx
  __int64 *v36; // rdi
  void **v37; // rax
  void *v38; // rdi
  _BYTE *v39; // rax
  __int32 v40; // edx
  bool v41; // sf
  signed int v42; // edx
  __int64 v43; // rcx
  signed int v44; // eax
  signed int v45; // eax
  signed int v46; // eax
  __int64 v47; // rdi
  unsigned __int8 v48; // of
  _QWORD *v49; // rax
  signed int v50; // [rsp+0h] [rbp-48h]
  int v51; // [rsp+4h] [rbp-44h]
  int v52; // [rsp+8h] [rbp-40h]
  __int32 v53; // [rsp+Ch] [rbp-3Ch]

  v53 = a1[25].m128i_i32[3];
  v52 = a1[31].m128i_i32[3];
  if ( a1[25].m128i_i32[3] == a2 && a1[26].m128i_i64[0] == __PAIR__(a4, a3) )
    return;
  v4 = 1;
  v5 = a1;
  if ( a2 <= 0 )
    a2 = 1;
  v50 = a4;
  if ( a3 > 0 )
    v4 = a3;
  v6 = a2;
  a1[234].m128i_i32[1] = 0;
  a1[235] = 0uLL;
  sub_912F0((__int64)a1, 0, 0, 0);
  v7 = a1[25].m128i_i32[3] == -1;
  a1[15].m128i_i32[2] = 0;
  a1[31].m128i_i32[1] = 0;
  v51 = a2 - 1;
  a1[15].m128i_i32[3] = a2 - 1;
  a1[31].m128i_i32[2] = a2 - 1;
  if ( v7 )
  {
    a1->m128i_i64[1] = (__int64)sub_9AF60(0LL);
    v49 = sub_9AF60(0LL);
    a1[2].m128i_i32[1] = 0;
    a1[1].m128i_i64[0] = (__int64)v49;
    a1[25].m128i_i32[3] = 0;
  }
  v8 = sub_9AFB0((__int64 *)a1->m128i_i64[1]);
  v9 = a1[25].m128i_i32[3];
  v10 = v8;
  if ( v9 != (unsigned int)sub_9AFB0((__int64 *)a1[1].m128i_i64[0]) )
    __assert_fail("term->rows == count234(term->screen)", "terminal.c", 0x883u, "term_size");
  for ( i = a1[25].m128i_i32[3]; v6 > i; a1[25].m128i_i32[3] = i )
  {
    v14 = a1[2].m128i_i32[1];
    if ( v14 > 0 )
    {
      if ( v14 > v10 )
        __assert_fail("sblen >= term->tempsblines", "terminal.c", 0x888u, "term_size");
      v12 = (void *)sub_9B400((__int64 *)a1->m128i_i64[1], --v10);
      v13 = sub_8A820((__int64)v12);
      sub_2F4D0(v12);
      *((_BYTE *)v13 + 12) = 0;
      --a1[2].m128i_i32[1];
      sub_9AFF0((_QWORD *)a1[1].m128i_i64[0], (__int64)v13, 0);
      ++a1[14].m128i_i32[2];
      ++a1[15].m128i_i32[0];
      ++a1[30].m128i_i32[0];
      ++a1[23].m128i_i32[2];
    }
    else
    {
      v15 = sub_8A580(a1, v4, 0);
      v16 = sub_9AFB0((__int64 *)a1[1].m128i_i64[0]);
      sub_9AFF0((_QWORD *)a1[1].m128i_i64[0], (__int64)v15, v16);
    }
    i = a1[25].m128i_i32[3] + 1;
  }
  while ( v6 < i )
  {
    v18 = i - 1;
    v19 = (__int64 *)v5[1].m128i_i64[0];
    if ( v5[14].m128i_i32[2] < v18 )
    {
      v17 = (void **)sub_9B400(v19, v18);
      if ( v17 )
        sub_8C3C0(v17);
    }
    else
    {
      v20 = (unsigned __int16 *)sub_9B400(v19, 0);
      v21 = (void **)v20;
      v22 = sub_8E9A0(v20, 0LL);
      sub_9AFF0((_QWORD *)v5->m128i_i64[1], (__int64)v22, v10);
      if ( v21 )
        sub_8C3C0(v21);
      ++v5[2].m128i_i32[1];
      --v5[14].m128i_i32[2];
      ++v10;
      --v5[15].m128i_i32[0];
      --v5[30].m128i_i32[0];
      --v5[23].m128i_i32[2];
    }
    i = v5[25].m128i_i32[3] - 1;
    v5[25].m128i_i32[3] = i;
  }
  if ( v6 != i )
    __assert_fail("term->rows == newrows", "terminal.c", 0x8ADu, "term_size");
  if ( v6 != (unsigned int)sub_9AFB0((__int64 *)v5[1].m128i_i64[0]) )
    __assert_fail("count234(term->screen) == newrows", "terminal.c", 0x8AEu, "term_size");
  if ( v50 < v10 )
  {
    do
    {
      --v10;
      v23 = (void *)sub_9B400((__int64 *)v5->m128i_i64[1], 0);
      sub_2F4D0(v23);
    }
    while ( v50 != v10 );
    v10 = v50;
  }
  if ( v5[2].m128i_i32[1] > v10 )
    v5[2].m128i_i32[1] = v10;
  if ( (signed int)sub_9AFB0((__int64 *)v5->m128i_i64[1]) > v50 )
    __assert_fail("count234(term->scrollback) <= newsavelines", "terminal.c", 0x8B8u, "term_size");
  if ( (signed int)sub_9AFB0((__int64 *)v5->m128i_i64[1]) < v5[2].m128i_i32[1] )
    __assert_fail("count234(term->scrollback) >= term->tempsblines", "terminal.c", 0x8B9u, "term_size");
  v5[2].m128i_i32[0] = 0;
  v24 = 0LL;
  v25 = sub_2F450(v6, 8uLL, 0LL);
  do
  {
    v26 = sub_8A580(v5, v4, 0);
    v25[v24] = v26;
    v27 = 0;
    v28 = (_QWORD *)(v26[3] + 8LL);
    do
    {
      ++v27;
      *v28 = &loc_3FFFF;
      v28 += 4;
    }
    while ( v4 > v27 );
    ++v24;
  }
  while ( v6 > (signed int)v24 );
  v29 = (char *)v5[2].m128i_i64[1];
  if ( v29 && v53 > 0 )
  {
    v30 = 0LL;
    do
    {
      v31 = *(void ***)&v29[v30];
      if ( v31 )
      {
        sub_8C3C0(v31);
        v29 = (char *)v5[2].m128i_i64[1];
      }
      v30 += 8LL;
    }
    while ( 8LL * (unsigned int)(v53 - 1) + 8 != v30 );
  }
  sub_2F4D0(v29);
  v5[2].m128i_i64[1] = (__int64)v25;
  v5[3].m128i_i64[0] = -1LL;
  v32 = 0;
  v33 = sub_9AF60(0LL);
  do
  {
    v34 = sub_8A580(v5, v4, 1);
    v35 = v32++;
    sub_9AFF0(v33, (__int64)v34, v35);
  }
  while ( v6 > v32 );
  v36 = (__int64 *)v5[1].m128i_i64[1];
  if ( v36 )
  {
    while ( 1 )
    {
      v37 = (void **)sub_9B400(v36, 0);
      if ( !v37 )
        break;
      sub_8C3C0(v37);
      v36 = (__int64 *)v5[1].m128i_i64[1];
    }
    sub_9AF90((_QWORD **)v5[1].m128i_i64[1]);
  }
  v38 = (void *)v5[233].m128i_i64[1];
  v5[1].m128i_i64[1] = (__int64)v33;
  v5[32].m128i_i32[0] = 0;
  v39 = sub_2F490(v38, v4, 1uLL);
  v40 = v5[26].m128i_i32[0];
  v5[233].m128i_i64[1] = (__int64)v39;
  v41 = v40 < 0;
  v42 = 0;
  if ( !v41 )
    v42 = v5[26].m128i_i32[0];
  if ( v4 > v42 )
  {
    v43 = v42;
    while ( 1 )
    {
      v39[v43++] = (v42++ & 7) == 0;
      if ( v4 == v42 )
        break;
      v39 = (_BYTE *)v5[233].m128i_i64[1];
    }
  }
  v44 = v5[15].m128i_i32[0];
  if ( v44 < 0 )
  {
    v48 = __OFSUB__(v4, v5[15].m128i_i32[1]);
    v7 = v4 == v5[15].m128i_i32[1];
    v41 = v4 - v5[15].m128i_i32[1] < 0;
    v5[15].m128i_i32[0] = 0;
    if ( !((unsigned __int8)(v41 ^ v48) | v7) )
      goto LABEL_60;
  }
  else
  {
    if ( v6 <= v44 )
      v5[15].m128i_i32[0] = v51;
    if ( v4 > v5[15].m128i_i32[1] )
    {
LABEL_60:
      v45 = v5[23].m128i_i32[2];
      if ( v45 >= 0 )
        goto LABEL_61;
LABEL_77:
      v48 = __OFSUB__(v4, v5[23].m128i_i32[3]);
      v7 = v4 == v5[23].m128i_i32[3];
      v41 = v4 - v5[23].m128i_i32[3] < 0;
      v5[23].m128i_i32[2] = 0;
      if ( !((unsigned __int8)(v41 ^ v48) | v7) )
        goto LABEL_64;
      goto LABEL_73;
    }
  }
  v5[15].m128i_i32[1] = v4 - 1;
  v45 = v5[23].m128i_i32[2];
  if ( v45 < 0 )
    goto LABEL_77;
LABEL_61:
  if ( v6 <= v45 )
    v5[23].m128i_i32[2] = v51;
  if ( v4 > v5[23].m128i_i32[3] )
  {
LABEL_64:
    v46 = v5[14].m128i_i32[2];
    if ( v46 >= 0 )
      goto LABEL_65;
LABEL_74:
    v48 = __OFSUB__(v4, v5[14].m128i_i32[3]);
    v7 = v4 == v5[14].m128i_i32[3];
    v41 = v4 - v5[14].m128i_i32[3] < 0;
    v5[14].m128i_i32[2] = 0;
    if ( !((unsigned __int8)(v41 ^ v48) | v7) )
      goto LABEL_68;
    goto LABEL_72;
  }
LABEL_73:
  v5[23].m128i_i32[3] = v4 - 1;
  v46 = v5[14].m128i_i32[2];
  if ( v46 < 0 )
    goto LABEL_74;
LABEL_65:
  if ( v6 <= v46 )
    v5[14].m128i_i32[2] = v51;
  if ( v4 > v5[14].m128i_i32[3] )
    goto LABEL_68;
LABEL_72:
  v5[14].m128i_i32[3] = v4 - 1;
LABEL_68:
  *(__int64 *)((char *)&v5[29].m128i_i64[1] + 4) = 0LL;
  v5[16].m128i_i8[2] = 0;
  v5[30].m128i_i8[4] = 0;
  v5[25].m128i_i32[3] = v6;
  v5[26].m128i_i32[0] = v4;
  v5[26].m128i_i32[1] = v50;
  sub_912F0((__int64)v5, v52, 0, 0);
  v7 = v5[273].m128i_i8[9] == 0;
  v5[540].m128i_i8[15] = 1;
  if ( v7 )
    sub_8E2A0((__int64)v5);
  v47 = v5[270].m128i_i64[0];
  if ( v47 )
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v47 + 40LL))(
      v47,
      v5[26].m128i_u32[0],
      v5[25].m128i_u32[3]);
}

void __fastcall sub_91F80(__int64 a1, char a2)
{
  int v2; // eax
  __int64 v3; // rbp
  int v4; // eax
  __int64 v5; // rax
  int v6; // edx
  char v7; // al
  __int64 *v8; // rdi
  char v9; // al
  __int64 *v10; // rdi
  int v11; // eax
  __int64 v12; // rax
  char v13; // al
  __int64 *v14; // rdi
  char v15; // al
  __int64 *v16; // rdi
  char v17; // al
  __int64 *v18; // rdi
  char v19; // al
  __m128i v20; // xmm0
  bool v21; // zf
  __int64 v22; // rdi
  __int64 v23; // rbx
  signed int v24; // eax

  v2 = *(_DWORD *)(a1 + 412);
  v3 = a1;
  *(_QWORD *)(a1 + 476) = 0LL;
  *(_QWORD *)(a1 + 376) = 0LL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 500) = 0;
  if ( v2 == -1 )
  {
    *(_DWORD *)(a1 + 252) = 0;
    *(_DWORD *)(a1 + 504) = 0;
  }
  else
  {
    v4 = v2 - 1;
    *(_DWORD *)(a1 + 252) = v4;
    *(_DWORD *)(a1 + 504) = v4;
  }
  if ( *(_DWORD *)(a1 + 416) > 0 )
  {
    v5 = 0LL;
    do
    {
      v6 = v5;
      *(_BYTE *)(*(_QWORD *)(a1 + 3736) + v5) = (v5 & 7) == 0;
      ++v5;
    }
    while ( *(_DWORD *)(a1 + 416) > v6 + 1 );
  }
  v7 = sub_1EF00(*(__int64 **)(a1 + 4368), 105);
  v8 = *(__int64 **)(a1 + 4368);
  *(_BYTE *)(v3 + 256) = v7;
  *(_BYTE *)(v3 + 486) = v7;
  *(_BYTE *)(v3 + 485) = 0;
  *(_BYTE *)(v3 + 259) = 0;
  *(_BYTE *)(v3 + 484) = 0;
  *(_BYTE *)(v3 + 258) = 0;
  *(_BYTE *)(v3 + 273) = 0;
  *(_BYTE *)(v3 + 405) = 0;
  v9 = sub_1EF00(v8, 106);
  *(_BYTE *)(v3 + 257) = v9;
  *(_BYTE *)(v3 + 487) = v9;
  *(_QWORD *)(v3 + 396) = 237494511599616LL;
  *(_BYTE *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 468) = 237494511654912LL;
  *(_BYTE *)(v3 + 115) = 0;
  *(_QWORD *)(v3 + 96) = 568447511692544LL;
  v10 = *(__int64 **)(v3 + 4368);
  *(_WORD *)(v3 + 113) = 0;
  v11 = *(_DWORD *)(v3 + 112);
  *(_BYTE *)(v3 + 496) = 0;
  *(_BYTE *)(v3 + 305) = 0;
  *(_BYTE *)(v3 + 272) = 0;
  *(_BYTE *)(v3 + 404) = 0;
  *(_DWORD *)(v3 + 108) = v11;
  v12 = *(_QWORD *)(v3 + 108);
  *(_DWORD *)(v3 + 308) = 0;
  *(_DWORD *)(v3 + 408) = 0;
  *(_QWORD *)(v3 + 296) = 0LL;
  *(_QWORD *)(v3 + 488) = 0LL;
  *(_QWORD *)(v3 + 260) = 0LL;
  *(_DWORD *)(v3 + 268) = 55296;
  *(_BYTE *)(v3 + 274) = 0;
  *(_BYTE *)(v3 + 425) = 0;
  *(_BYTE *)(v3 + 288) = 1;
  *(_BYTE *)(v3 + 447) = 0;
  *(_DWORD *)(v3 + 384) = 132352;
  *(_DWORD *)(v3 + 104) = 132352;
  *(_QWORD *)(v3 + 388) = v12;
  *(_QWORD *)(v3 + 116) = v12;
  v13 = sub_1EF00(v10, 84);
  v14 = *(__int64 **)(v3 + 4368);
  *(_BYTE *)(v3 + 440) = v13;
  v15 = sub_1EF00(v14, 85);
  v16 = *(__int64 **)(v3 + 4368);
  *(_BYTE *)(v3 + 441) = v15;
  v17 = sub_1EF00(v16, 120);
  v18 = *(__int64 **)(v3 + 4368);
  *(_BYTE *)(v3 + 290) = v17;
  v19 = sub_1EF00(v18, 121);
  v20 = _mm_loadu_si128((const __m128i *)(v3 + 128));
  v21 = *(_BYTE *)(v3 + 320) == 0;
  *(_BYTE *)(v3 + 293) = v19;
  *(__m128i *)(v3 + 160) = v20;
  *(_DWORD *)(v3 + 508) = 0;
  *(__m128i *)(v3 + 176) = _mm_loadu_si128((const __m128i *)(v3 + 144));
  if ( !v21 || *(_BYTE *)(v3 + 321) )
    sub_8E3B0(v3);
  v22 = *(_QWORD *)(v3 + 4336);
  *(_DWORD *)(v3 + 452) = 0;
  *(_BYTE *)(v3 + 456) = 0;
  *(_BYTE *)(v3 + 457) = 0;
  v23 = 0LL;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v22 + 56LL))(v22, 0LL);
  *(_BYTE *)(v3 + 8652) = 1;
  *(_BYTE *)(v3 + 8653) = 0;
  *(_BYTE *)(v3 + 464) = 0;
  *(_BYTE *)(v3 + 444) = 0;
  do
  {
    *(_WORD *)(v3 + 2 * v23 + 3784) = sub_1F0A0(*(__int64 **)(v3 + 4368), 155, v23);
    ++v23;
  }
  while ( v23 != 256 );
  if ( *(_QWORD *)(v3 + 16) )
  {
    sub_912F0(v3, 1, 0, 0);
    sub_90F70((__m128i *)v3, 0, 1, 1);
    sub_912F0(v3, 0, 0, 0);
    if ( a2 )
      sub_90F70((__m128i *)v3, 0, 1, 1);
    v24 = sub_8B960(v3, *(_QWORD *)(v3 + 16));
    v21 = v24 + 1 == *(_DWORD *)(v3 + 412);
    *(_DWORD *)(v3 + 232) = v24 + 1;
    if ( v21 )
    {
      *(_DWORD *)(v3 + 232) = v24;
      sub_8ED60((const __m128i *)v3, 0, v24, 1, 1);
    }
  }
  else
  {
    *(_DWORD *)(v3 + 232) = 0;
  }
  v21 = *(_BYTE *)(v3 + 293) == 0;
  *(_DWORD *)(v3 + 236) = 0;
  if ( v21 )
  {
    *(_BYTE *)(v3 + 292) = 1;
    *(_BYTE *)(v3 + 4392) = 0;
  }
  else
  {
    sub_8E330(v3);
  }
  if ( *(_BYTE *)(v3 + 4526) && *(_BYTE *)(v3 + 424) )
  {
    sub_8E370(v3);
  }
  else
  {
    *(_BYTE *)(v3 + 291) = 1;
    *(_BYTE *)(v3 + 4393) = 0;
  }
  if ( !*(_BYTE *)(v3 + 4377) )
    sub_8E2A0(v3);
}

__int64 __fastcall sub_923A0(__int64 a1, char a2)
{
  const __m128i *v2; // rbx
  __int64 v3; // rdi

  v2 = (const __m128i *)a1;
  sub_91F80(a1, a2);
  v3 = *(_QWORD *)(a1 + 4328);
  if ( v3 )
    sub_2C080(v3);
  v2[2].m128i_i32[0] = 0;
  v2[234].m128i_i32[1] = 0;
  v2[235].m128i_i64[0] = 0LL;
  v2[235].m128i_i64[1] = 0LL;
  return sub_8FD90(v2);
}

void __fastcall sub_923F0(__int64 a1, __int64 a2, int a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // bp
  __m128i *v5; // rbx
  int v6; // er12
  bool v7; // zf
  char v8; // cl
  char v9; // dl
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // edx
  char v14; // al
  __int64 v15; // r12
  __int64 v16; // rax
  char v17; // dl
  int v18; // eax
  char v19; // dl
  __int64 v20; // rax
  __int64 v21; // rax
  char v22; // dl
  int v23; // eax
  char v24; // dl
  __int64 v25; // rax
  __int64 v26; // rax

  v4 = a4;
  v5 = (__m128i *)a1;
  if ( a3 != 1 )
  {
    if ( a3 )
      return;
    if ( (_DWORD)a2 == 12 )
    {
      *(_BYTE *)(a1 + 444) = a4 ^ 1;
    }
    else if ( (signed int)a2 <= 12 )
    {
      if ( (_DWORD)a2 == 4 )
      {
        if ( !(*(_BYTE *)a1 & 8) )
          goto LABEL_30;
        *(_BYTE *)(a1 + 259) = a4;
      }
    }
    else
    {
      if ( (_DWORD)a2 != 20 )
      {
        if ( (_DWORD)a2 != 34 )
          return;
        if ( *(_DWORD *)a1 & 0x4010 )
        {
          *(_BYTE *)(a1 + 447) = a4 ^ 1;
          return;
        }
LABEL_30:
        *(_DWORD *)(a1 + 3744) = 0;
        return;
      }
      *(_BYTE *)(a1 + 445) = a4;
    }
    return;
  }
  v6 = a4;
  if ( (_DWORD)a2 == 47 )
  {
    if ( !(*(_DWORD *)a1 & 0x4000) )
      goto LABEL_30;
    v7 = *(_BYTE *)(a1 + 4558) == 0;
    *(_DWORD *)(a1 + 3748) = 0;
    *(_QWORD *)(a1 + 3760) = 0LL;
    *(_QWORD *)(a1 + 3768) = 0LL;
    if ( !v7 )
      v6 = 0;
    v8 = 0;
    v9 = 0;
    goto LABEL_47;
  }
  if ( (signed int)a2 > 47 )
  {
    if ( (_DWORD)a2 == 1015 )
    {
      *(_BYTE *)(a1 + 457) = a4;
      return;
    }
    if ( (signed int)a2 <= 1015 )
    {
      switch ( (_DWORD)a2 )
      {
        case 0x3EA:
          *(_DWORD *)(a1 + 452) = 2 * (a4 != 0);
          break;
        case 0x3EE:
          *(_BYTE *)(a1 + 456) = a4;
          return;
        case 0x3E8:
          *(_DWORD *)(a1 + 452) = a4;
          break;
        default:
          return;
      }
      sub_8E2C0(a1);
      return;
    }
    if ( (_DWORD)a2 != 1048 )
    {
      if ( (signed int)a2 > 1048 )
      {
        if ( (_DWORD)a2 != 1049 )
        {
          if ( (_DWORD)a2 == 2004 )
            *(_BYTE *)(a1 + 464) = a4;
          return;
        }
        if ( a4 )
        {
          if ( !*(_BYTE *)(a1 + 4558) )
          {
            v17 = *(_BYTE *)(a1 + 305);
            *(_QWORD *)(a1 + 240) = *(_QWORD *)(a1 + 232);
            v18 = *(_DWORD *)(a1 + 100);
            *(_BYTE *)(a1 + 272) = v17;
            v19 = *(_BYTE *)(a1 + 258);
            *(_DWORD *)(a1 + 104) = v18;
            v20 = *(_QWORD *)(a1 + 108);
            *(_BYTE *)(a1 + 273) = v19;
            *(_QWORD *)(a1 + 116) = v20;
            v21 = *(signed int *)(a1 + 260);
            *(_DWORD *)(a1 + 264) = v21;
            *(_DWORD *)(a1 + 268) = *(_DWORD *)(a1 + 4 * v21 + 468);
            *(_DWORD *)(a1 + 300) = *(_DWORD *)(a1 + 296);
          }
        }
        else
        {
          v7 = *(_BYTE *)(a1 + 4377) == 0;
          *(_BYTE *)(a1 + 446) = 1;
          if ( v7 )
            sub_8E2A0(a1);
        }
        if ( !(*(_DWORD *)a1 & 0x4000) )
          goto LABEL_30;
        v7 = *(_BYTE *)(a1 + 4558) == 0;
        *(_DWORD *)(a1 + 3748) = 0;
        *(_QWORD *)(a1 + 3760) = 0LL;
        *(_QWORD *)(a1 + 3768) = 0LL;
        if ( !v7 )
          v6 = 0;
        sub_912F0(a1, v6, 1, 0);
        if ( !v4 && !*(_BYTE *)(a1 + 4558) )
          sub_8BA30(a1);
        goto LABEL_48;
      }
      if ( (_DWORD)a2 != 1047 )
        return;
      if ( !(*(_DWORD *)a1 & 0x4000) )
        goto LABEL_30;
      v7 = *(_BYTE *)(a1 + 4558) == 0;
      *(_DWORD *)(a1 + 3748) = 0;
      *(_QWORD *)(a1 + 3760) = 0LL;
      *(_QWORD *)(a1 + 3768) = 0LL;
      v8 = 1;
      v9 = 1;
      if ( !v7 )
        v6 = 0;
LABEL_47:
      sub_912F0(a1, v6, v9, v8);
LABEL_48:
      if ( *(_BYTE *)(a1 + 4577) )
        *(_DWORD *)(a1 + 32) = 0;
      return;
    }
    if ( *(_BYTE *)(a1 + 4558) )
    {
      if ( a4 )
        return;
    }
    else
    {
      if ( a4 )
      {
        v22 = *(_BYTE *)(a1 + 305);
        *(_QWORD *)(a1 + 240) = *(_QWORD *)(a1 + 232);
        v23 = *(_DWORD *)(a1 + 100);
        *(_BYTE *)(a1 + 272) = v22;
        v24 = *(_BYTE *)(a1 + 258);
        *(_DWORD *)(a1 + 104) = v23;
        v25 = *(_QWORD *)(a1 + 108);
        *(_BYTE *)(a1 + 273) = v24;
        *(_QWORD *)(a1 + 116) = v25;
        v26 = *(signed int *)(a1 + 260);
        *(_DWORD *)(a1 + 264) = v26;
        *(_DWORD *)(a1 + 268) = *(_DWORD *)(a1 + 4 * v26 + 468);
        *(_DWORD *)(a1 + 300) = *(_DWORD *)(a1 + 296);
        return;
      }
      sub_8BA30(a1);
    }
    goto LABEL_70;
  }
  if ( (_DWORD)a2 == 5 )
  {
    if ( *(_BYTE *)(a1 + 274) )
    {
      if ( !a4 )
      {
        v15 = *(_QWORD *)(a1 + 280);
        v16 = sub_B4D20() - v15;
        if ( v16 <= 99 )
        {
          *(_BYTE *)(a1 + 425) = 1;
          *(_QWORD *)(a1 + 432) = sub_99D00((unsigned int)(100 - v16), (__int64)sub_8FFF0, a1);
        }
        else
        {
          *(_BYTE *)(a1 + 425) = 0;
        }
      }
    }
    else if ( a4 )
    {
      *(_QWORD *)(a1 + 280) = sub_B4D20();
    }
    *(_BYTE *)(a1 + 274) = v4;
LABEL_70:
    v7 = *(_BYTE *)(a1 + 4377) == 0;
    *(_BYTE *)(a1 + 446) = 1;
    if ( !v7 )
      return;
    goto LABEL_27;
  }
  if ( (signed int)a2 <= 5 )
  {
    switch ( (_DWORD)a2 )
    {
      case 2:
        *(_BYTE *)(a1 + 442) = a4 ^ 1;
        if ( a4 ^ 1 )
        {
          *(_BYTE *)(a1 + 293) = 0;
          *(_BYTE *)(a1 + 304) = 0;
        }
        else
        {
          v14 = *(_BYTE *)(a1 + 4527);
          *(_BYTE *)(a1 + 293) = v14;
          if ( v14 )
          {
            sub_8E330(a1);
            return;
          }
        }
        *(_BYTE *)(a1 + 292) = 1;
        *(_BYTE *)(a1 + 4392) = 0;
        break;
      case 3:
        v7 = *(_BYTE *)(a1 + 4564) == 0;
        *(_DWORD *)(a1 + 3748) = 0;
        *(_QWORD *)(a1 + 3760) = 0LL;
        *(_QWORD *)(a1 + 3768) = 0LL;
        v10 = *(_DWORD *)(a1 + 412);
        if ( v7 )
        {
          *(_BYTE *)(a1 + 8632) = 1;
          *(_DWORD *)(a1 + 8640) = v10;
          v7 = *(_BYTE *)(a1 + 4377) == 0;
          *(_DWORD *)(a1 + 8636) = v4 < 1u ? 80 : 132;
          if ( v7 )
          {
            sub_8E2A0(a1);
            v10 = *(_DWORD *)(a1 + 412);
          }
        }
        v11 = *(_DWORD *)(a1 + 416);
        v12 = v10 - 1;
        v5[18].m128i_i8[1] = v4;
        v5[15].m128i_i32[2] = 0;
        v5[15].m128i_i32[3] = v10 - 1;
        v5[31].m128i_i32[2] = v10 - 1;
        v13 = v11 - 1;
        v5[31].m128i_i32[1] = 0;
        v5[16].m128i_i8[2] = 0;
        if ( v11 > 0 )
          v13 = 0;
        if ( v10 > 0 )
          v12 = 0;
        v5[14].m128i_i32[3] = v13;
        v5[14].m128i_i32[2] = v12;
        sub_90F70(v5, 0, 1, 1);
        break;
      case 1:
        *(_BYTE *)(a1 + 440) = a4;
        break;
    }
    return;
  }
  if ( (_DWORD)a2 == 7 )
  {
    *(_BYTE *)(a1 + 257) = a4;
    return;
  }
  if ( (signed int)a2 < 7 )
  {
    *(_BYTE *)(a1 + 256) = a4;
    return;
  }
  if ( (_DWORD)a2 == 8 )
  {
    *(_BYTE *)(a1 + 443) = a4 ^ 1;
    return;
  }
  if ( (_DWORD)a2 == 25 )
  {
    if ( !(*(_DWORD *)a1 & 0x4010) )
      goto LABEL_30;
    v7 = *(_BYTE *)(a1 + 4377) == 0;
    *(_BYTE *)(a1 + 288) = a4;
    *(_BYTE *)(a1 + 446) = 1;
    if ( v7 )
    {
LABEL_27:
      sub_8E2A0(a1);
      return;
    }
  }
}

signed __int64 __fastcall sub_92A60(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // esi
  unsigned int v3; // edx
  signed __int64 result; // rax
  signed __int64 v5; // r8
  signed __int64 v6; // rdi
  char *v7; // r8
  char v8; // r9
  char v9; // r10
  char v10; // r8

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8656) )
  {
    v2 = *(_DWORD *)(a1 + 8660);
    v3 = *(_DWORD *)(a1 + 8664) - 1;
  }
  else
  {
    v3 = 0;
    v2 = 262;
  }
  result = 0LL;
  do
  {
    if ( *(_BYTE *)(v1 + result + 7555) )
    {
      v5 = 2096LL;
    }
    else if ( *(_BYTE *)(v1 + result + 6507) )
    {
      v5 = 1048LL;
    }
    else
    {
      if ( !*(_BYTE *)(v1 + result + 5459) )
        __assert_fail("found", "terminal.c", 0x730u, "palette_rebuild");
      v5 = 0LL;
    }
    v6 = 3 * result;
    v7 = (char *)(v1 + v5 + 3 * result + 4673);
    v8 = *v7;
    v9 = v7[1];
    v10 = v7[2];
    if ( *(_BYTE *)(v1 + 3 * result + 7817) != v8
      || *(_BYTE *)(v1 + v6 + 7818) != v9
      || *(_BYTE *)(v1 + v6 + 7819) != v10 )
    {
      *(_BYTE *)(v1 + v6 + 7817) = v8;
      *(_BYTE *)(v1 + v6 + 7818) = v9;
      if ( v2 > (unsigned int)result )
        v2 = result;
      *(_BYTE *)(v1 + v6 + 7819) = v10;
      if ( v3 < (unsigned int)result )
        v3 = result;
    }
    ++result;
  }
  while ( result != 262 );
  if ( v2 <= v3 )
  {
    *(_BYTE *)(v1 + 8656) = 1;
    *(_DWORD *)(v1 + 8660) = v2;
    *(_DWORD *)(v1 + 8664) = v3 + 1;
    result = sub_90EF0(v1);
    if ( !*(_BYTE *)(v1 + 4377) )
      result = (signed __int64)sub_8E2A0(v1);
  }
  return result;
}

signed __int64 __fastcall sub_92BA0(__int64 a1, char a2)
{
  _BYTE *v2; // rax
  __int64 v3; // rbp
  char v4; // bl
  void *__ptr32 *v5; // r14
  int v6; // er12
  signed int v7; // er13
  char v8; // al
  __int64 *v9; // rdi
  _BYTE *v10; // r13
  char v11; // al
  __int64 *v12; // rdi
  int v13; // edx
  _BYTE *v14; // r8
  unsigned int v15; // esi
  __int64 v16; // rcx
  unsigned int v17; // eax
  int v18; // edx
  int v19; // eax
  signed __int64 v20; // rdx
  signed int v21; // eax
  _BYTE *v22; // rax
  signed __int64 v23; // rdx
  _BYTE *v24; // rax

  v2 = (_BYTE *)(a1 + 5459);
  v3 = a1;
  v4 = a2;
  do
    *v2++ = 1;
  while ( v2 != (_BYTE *)(a1 + 5721) );
  v5 = &off_F59A4;
  v6 = 0;
  v7 = 256;
  while ( 1 )
  {
    v8 = sub_1F0A0(*(__int64 **)(v3 + 4368), 147, v6);
    v9 = *(__int64 **)(v3 + 4368);
    v10 = (_BYTE *)(v3 + 3LL * v7);
    v10[4673] = v8;
    v11 = sub_1F0A0(v9, 147, v6 + 1);
    v12 = *(__int64 **)(v3 + 4368);
    v13 = v6 + 2;
    v10[4674] = v11;
    v6 += 3;
    v10[4675] = sub_1F0A0(v12, 147, v13);
    if ( v6 == 66 )
      break;
    v7 = (signed int)*v5;
    ++v5;
  }
  v14 = (_BYTE *)(v3 + 4721);
  v15 = 0;
  v16 = 0LL;
  v17 = 0;
  LOBYTE(v18) = 0;
  while ( 1 )
  {
    *v14 = v18;
    LOBYTE(v18) = 0;
    if ( v17 )
      v18 = 40 * v17 + 55;
    LOBYTE(v19) = 0;
    v14[1] = v18;
    if ( (_DWORD)v16 )
    {
      v16 = (unsigned int)(5 * v16);
      v19 = 8 * v16 + 55;
    }
    ++v15;
    v14[2] = v19;
    if ( v15 == 216 )
      break;
    v17 = v15 / 6 % 6;
    v16 = v15 % 6;
    LOBYTE(v18) = 0;
    if ( v15 / 0x24 )
      v18 = 40 * (v15 / 0x24) + 55;
    v14 += 3;
  }
  v20 = v3 + 5369;
  v21 = 8;
  do
  {
    *(_BYTE *)(v20 + 2) = v21;
    *(_BYTE *)(v20 + 1) = v21;
    v20 += 3LL;
    *(_BYTE *)(v20 - 3) = v21;
    v21 += 10;
  }
  while ( (_BYTE)v21 != -8 );
  v22 = (_BYTE *)(v3 + 6507);
  v23 = v3 + 6769;
  do
    *v22++ = 0;
  while ( v22 != (_BYTE *)v23 );
  (*(void (__fastcall **)(_QWORD, __int64, signed __int64, __int64, _BYTE *, signed __int64))(**(_QWORD **)(v3 + 4336)
                                                                                            + 176LL))(
    *(_QWORD *)(v3 + 4336),
    v3,
    v23,
    v16,
    v14,
    2863311531LL);
  if ( !v4 )
  {
    v24 = (_BYTE *)(v3 + 7555);
    do
      *v24++ = 0;
    while ( (_BYTE *)(v3 + 7817) != v24 );
  }
  return sub_92A60(v3);
}

__int64 __fastcall sub_92D80(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13
  _QWORD *v4; // rax
  __int64 v5; // rbx
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  char *v8; // rax

  v3 = a3;
  v4 = sub_2F450(1uLL, 0x21E0uLL, 0LL);
  v5 = (__int64)v4;
  v4[542] = v3;
  v4[544] = a2;
  v4[546] = sub_1EED0(a1);
  *(_WORD *)(v5 + 2710) = 99;
  *(_QWORD *)(v5 + 4344) = 0LL;
  *(_DWORD *)v5 = 0xFFFF;
  *(_DWORD *)(v5 + 2706) = 910121755;
  *(_BYTE *)(v5 + 4392) = 0;
  *(_BYTE *)(v5 + 4393) = 0;
  *(_QWORD *)(v5 + 4304) = 0LL;
  *(_DWORD *)(v5 + 4312) = 0;
  sub_BCC70((_QWORD *)(v5 + 192));
  sub_BCC70((_QWORD *)(v5 + 328));
  *(_BYTE *)(v5 + 321) = 0;
  *(_BYTE *)(v5 + 320) = 0;
  *(_QWORD *)(v5 + 368) = 0LL;
  *(_BYTE *)(v5 + 442) = 0;
  *(_BYTE *)(v5 + 445) = 0;
  *(_BYTE *)(v5 + 446) = 0;
  *(_DWORD *)(v5 + 460) = 0;
  *(_BYTE *)(v5 + 289) = 0;
  *(_BYTE *)(v5 + 291) = 0;
  *(_BYTE *)(v5 + 292) = 0;
  *(_BYTE *)(v5 + 424) = 1;
  *(_BYTE *)(v5 + 443) = 0;
  *(_DWORD *)(v5 + 3744) = 0;
  *(_DWORD *)(v5 + 3748) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  sub_90220(v5);
  *(_QWORD *)(v5 + 48) = -1LL;
  *(_QWORD *)(v5 + 412) = -1LL;
  *(_DWORD *)(v5 + 512) = 0;
  *(_QWORD *)(v5 + 8) = 0LL;
  *(_QWORD *)(v5 + 16) = 0LL;
  *(_QWORD *)(v5 + 24) = 0LL;
  *(_QWORD *)(v5 + 32) = 0LL;
  *(_QWORD *)(v5 + 40) = 0LL;
  *(_QWORD *)(v5 + 3736) = 0LL;
  *(_DWORD *)(v5 + 3748) = 0;
  *(_QWORD *)(v5 + 3760) = 0LL;
  *(_QWORD *)(v5 + 3768) = 0LL;
  sub_91F80(v5, 1);
  *(_QWORD *)(v5 + 128) = 55328LL;
  *(_QWORD *)(v5 + 136) = 132352LL;
  v6 = _mm_loadu_si128((const __m128i *)(v5 + 128));
  *(_WORD *)(v5 + 145) = 0;
  *(_WORD *)(v5 + 153) = 0;
  *(_BYTE *)(v5 + 144) = 0;
  *(_BYTE *)(v5 + 147) = 0;
  *(_BYTE *)(v5 + 148) = 0;
  *(_DWORD *)(v5 + 149) = 0;
  *(_BYTE *)(v5 + 155) = 0;
  *(_DWORD *)(v5 + 4296) = -1;
  *(__m128i *)(v5 + 160) = v6;
  *(_QWORD *)(v5 + 72) = 0LL;
  *(_QWORD *)(v5 + 64) = 0LL;
  v7 = _mm_loadu_si128((const __m128i *)(v5 + 144));
  *(_DWORD *)(v5 + 80) = 0;
  *(_QWORD *)(v5 + 88) = 0LL;
  *(__m128i *)(v5 + 176) = v7;
  *(_BYTE *)(v5 + 84) = 0;
  *(_QWORD *)(v5 + 4320) = 0LL;
  *(_BYTE *)(v5 + 4376) = 0;
  *(_QWORD *)(v5 + 4416) = 0LL;
  *(_DWORD *)(v5 + 4424) = 0;
  *(_QWORD *)(v5 + 4432) = 0LL;
  *(_QWORD *)(v5 + 4440) = 0LL;
  *(_DWORD *)(v5 + 4448) = 0;
  *(_BYTE *)(v5 + 4377) = 0;
  *(_BYTE *)(v5 + 4378) = 0;
  *(_QWORD *)(v5 + 4472) = 0LL;
  *(_QWORD *)(v5 + 4464) = 0LL;
  *(_QWORD *)(v5 + 4456) = 0LL;
  *(_QWORD *)(v5 + 4584) = 0LL;
  *(_QWORD *)(v5 + 4592) = 0LL;
  *(_QWORD *)(v5 + 4600) = 0LL;
  *(_QWORD *)(v5 + 4608) = 0LL;
  *(_DWORD *)(v5 + 4616) = 1;
  *(_QWORD *)(v5 + 4644) = 1LL;
  *(_QWORD *)(v5 + 4360) = 0LL;
  *(_BYTE *)(v5 + 4480) = 1;
  *(_BYTE *)(v5 + 465) = 0;
  *(_QWORD *)(v5 + 4656) = sub_BC120(&locale);
  v8 = sub_BC120(&locale);
  *(_BYTE *)(v5 + 4672) = 0;
  *(_QWORD *)(v5 + 4664) = v8;
  *(_QWORD *)(v5 + 8604) = 0LL;
  *(_QWORD *)(v5 + 8612) = 0LL;
  *(_BYTE *)(v5 + 8620) = 0;
  *(_BYTE *)(v5 + 8632) = 0;
  *(_BYTE *)(v5 + 8644) = 0;
  *(_BYTE *)(v5 + 8646) = 0;
  *(_BYTE *)(v5 + 8648) = 0;
  *(_BYTE *)(v5 + 8650) = 0;
  *(_BYTE *)(v5 + 8651) = 0;
  *(_BYTE *)(v5 + 8652) = 0;
  *(_BYTE *)(v5 + 8654) = 0;
  *(_BYTE *)(v5 + 8655) = 0;
  *(_BYTE *)(v5 + 8656) = 0;
  sub_92BA0(v5, 0);
  return v5;
}

_QWORD *__fastcall sub_93130(__int64 a1, __int64 *a2)
{
  __int64 v2; // r15
  int v3; // ebx
  char v4; // bp
  int v5; // er12
  char v6; // bl
  __int64 v7; // rax
  unsigned __int64 v8; // r12
  __int64 v9; // rbx
  __int64 v10; // rdx
  __int64 v11; // rbx
  bool v12; // cf
  bool v13; // zf
  const char *v14; // r12
  char *v15; // rbx
  int v16; // ebx
  __int64 v17; // r12
  int v18; // er14
  char v19; // bl
  __int64 *v20; // rdi
  char v21; // al
  char v22; // al
  char v23; // al
  __int64 v24; // rbp
  char v26; // al
  __m128i v27; // xmm0
  char *v28; // rax
  char v29; // bl
  char v30; // [rsp+8h] [rbp-40h]
  char v31; // [rsp+9h] [rbp-3Fh]
  char v32; // [rsp+Ah] [rbp-3Eh]
  char v33; // [rsp+Bh] [rbp-3Dh]
  char v34; // [rsp+Ch] [rbp-3Ch]
  char v35; // [rsp+Dh] [rbp-3Bh]
  char v36; // [rsp+Eh] [rbp-3Ah]
  char v37; // [rsp+Fh] [rbp-39h]

  v2 = a1;
  v3 = 0;
  v4 = 0;
  v30 = sub_1EF00(*(__int64 **)(a1 + 4368), 106);
  v31 = sub_1EF00(a2, 106);
  v32 = sub_1EF00(*(__int64 **)(a1 + 4368), 105);
  v33 = sub_1EF00(a2, 105);
  v34 = sub_1EF00(*(__int64 **)(a1 + 4368), 120);
  v35 = sub_1EF00(a2, 120);
  v36 = sub_1EF00(*(__int64 **)(a1 + 4368), 121);
  v37 = sub_1EF00(a2, 121);
  do
  {
    v5 = sub_1F0A0(*(__int64 **)(a1 + 4368), 155, v3);
    if ( v5 != (unsigned int)sub_1F0A0(a2, 155, v3) )
      v4 = 1;
    ++v3;
  }
  while ( v3 != 256 );
  v6 = sub_1EF00(*(__int64 **)(a1 + 4368), 139);
  if ( v6 != (unsigned __int8)sub_1EF00(a2, 139)
    || (v29 = sub_1EF00(*(__int64 **)(a1 + 4368), 140), v29 != (unsigned __int8)sub_1EF00(a2, 140)) )
  {
    if ( *(_QWORD *)(a1 + 4472) )
    {
      v7 = *(_QWORD *)(a1 + 4456);
      v8 = 0LL;
      do
      {
        v9 = v8++;
        v9 *= 32LL;
        sub_2F4D0(*(void **)(v7 + v9 + 8));
        sub_2F4D0(*(void **)(*(_QWORD *)(a1 + 4464) + v9 + 8));
        v7 = *(_QWORD *)(a1 + 4456);
        v10 = v7 + v9;
        v11 = *(_QWORD *)(a1 + 4464) + v9;
        v12 = *(_QWORD *)(a1 + 4472) < v8;
        v13 = *(_QWORD *)(a1 + 4472) == v8;
        *(_DWORD *)v10 = -1;
        *(_QWORD *)(v10 + 8) = 0LL;
        *(_DWORD *)v11 = -1;
        *(_QWORD *)(v11 + 8) = 0LL;
      }
      while ( !v12 && !v13 );
    }
  }
  v14 = (const char *)sub_1F170(*(__int64 **)(a1 + 4368), 103);
  v15 = (char *)sub_1F170(a2, 103);
  if ( strcmp(v14, v15) )
  {
    sub_2F4D0(*(void **)(a1 + 4656));
    v28 = sub_BC120(v15);
    v13 = *(_BYTE *)(a1 + 4377) == 0;
    *(_QWORD *)(a1 + 4656) = v28;
    *(_BYTE *)(a1 + 8650) = 1;
    if ( v13 )
      sub_8E2A0(a1);
  }
  v16 = 0;
  while ( 2 )
  {
    v17 = 0LL;
    do
    {
      v18 = sub_1F0A0(*(__int64 **)(a1 + 4368), 147, v16 + (signed int)v17);
      if ( v18 != (unsigned int)sub_1F0A0(a2, 147, v16 + (signed int)v17) )
      {
        v19 = 1;
        goto LABEL_17;
      }
      ++v17;
    }
    while ( v17 != 3 );
    v16 += 3;
    if ( v16 != 66 )
      continue;
    break;
  }
  v19 = 0;
LABEL_17:
  sub_1ED50(*(_QWORD **)(a1 + 4368));
  v20 = sub_1EED0(a2);
  *(_QWORD *)(v2 + 4368) = v20;
  if ( v30 != v31 )
  {
    v21 = sub_1EF00(v20, 106);
    v20 = *(__int64 **)(v2 + 4368);
    *(_BYTE *)(v2 + 257) = v21;
    *(_BYTE *)(v2 + 487) = v21;
  }
  if ( v32 != v33 )
  {
    v22 = sub_1EF00(v20, 105);
    v20 = *(__int64 **)(v2 + 4368);
    *(_BYTE *)(v2 + 256) = v22;
    *(_BYTE *)(v2 + 486) = v22;
  }
  if ( v34 != v35 )
  {
    v26 = sub_1EF00(v20, 120);
    v27 = _mm_loadu_si128((const __m128i *)(v2 + 128));
    *(_BYTE *)(v2 + 290) = v26;
    *(__m128i *)(v2 + 160) = v27;
    *(__m128i *)(v2 + 176) = _mm_loadu_si128((const __m128i *)(v2 + 144));
    if ( v26 )
      sub_8BA10(v2);
    v20 = *(__int64 **)(v2 + 4368);
  }
  if ( v36 != v37 )
  {
    v23 = sub_1EF00(v20, 121);
    v20 = *(__int64 **)(v2 + 4368);
    *(_BYTE *)(v2 + 293) = v23;
  }
  if ( v4 )
  {
    v24 = 0LL;
    do
    {
      *(_WORD *)(v2 + 2 * v24 + 3784) = sub_1F0A0(v20, 155, v24);
      ++v24;
      v20 = *(__int64 **)(v2 + 4368);
    }
    while ( v24 != 256 );
  }
  if ( (unsigned __int8)sub_1EF00(v20, 78) )
    sub_912F0(v2, 0, 0, 0);
  if ( (unsigned __int8)sub_1EF00(*(__int64 **)(v2 + 4368), 82) )
  {
    *(_DWORD *)(v2 + 492) = 0;
    *(_DWORD *)(v2 + 296) = 0;
    *(_QWORD *)(v2 + 468) = 237494511654912LL;
    *(_BYTE *)(v2 + 305) = 0;
  }
  if ( !sub_1F170(*(__int64 **)(v2 + 4368), 138) && (*(_BYTE *)(v2 + 320) || *(_BYTE *)(v2 + 321)) )
    sub_8E3B0(v2);
  if ( v19 )
    sub_92BA0(v2, 1);
  if ( *(_BYTE *)(v2 + 293) )
  {
    sub_8E330(v2);
  }
  else
  {
    *(_BYTE *)(v2 + 292) = 1;
    *(_BYTE *)(v2 + 4392) = 0;
  }
  if ( *(_BYTE *)(v2 + 4526) && *(_BYTE *)(v2 + 424) )
  {
    sub_8E370(v2);
  }
  else
  {
    *(_BYTE *)(v2 + 291) = 1;
    *(_BYTE *)(v2 + 4393) = 0;
  }
  sub_90220(v2);
  return sub_8E2C0(v2);
}

unsigned __int64 __fastcall sub_93640(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r15
  __int64 v3; // r13
  unsigned __int64 v4; // rbx
  __m128i *v5; // rbp
  __int64 v6; // r14
  const __m128i *v7; // rax
  unsigned __int64 v8; // rdx
  __m128i *v9; // rdi
  bool v10; // zf
  unsigned int v11; // eax
  unsigned __int64 v12; // r14
  unsigned int v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // er14
  int v17; // esi
  int v18; // eax
  __int64 v19; // rax
  int v20; // ecx
  unsigned int v21; // eax
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  signed int v24; // edx
  __int64 v25; // rdi
  unsigned __int64 v26; // r14
  _BYTE *v27; // rax
  __int64 v28; // rcx
  int v29; // er8
  int v30; // edi
  int v31; // edx
  signed __int64 v32; // rcx
  int v34; // er9
  int v35; // er8
  __int64 v36; // r14
  _QWORD *v37; // rdi
  int v38; // eax
  __int64 v39; // r14
  signed int v40; // edx
  __int64 v41; // rdi
  int v42; // edx
  int v43; // eax
  int v44; // esi
  int v45; // edx
  bool v46; // sf
  int v47; // eax
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // edx
  int v52; // eax
  int v53; // er14
  int v54; // ecx
  unsigned __int8 v55; // of
  int v56; // edx
  int v57; // ecx
  int v58; // eax
  int v59; // ecx
  int v60; // er14
  int v61; // edx
  __int64 v62; // rax
  __int64 v63; // rdx
  char v64; // cl
  __int64 v65; // rax
  __int64 v66; // rcx
  _BYTE *v67; // rax
  __int64 v68; // rax
  signed __int64 v69; // rax
  unsigned int v70; // edx
  unsigned int v71; // eax
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // rax
  unsigned __int64 v74; // r14
  __int64 v75; // rdi
  int v76; // edx
  __int64 v77; // rdx
  __int64 v78; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v80; // rt1
  signed __int64 v81; // rax
  unsigned int v82; // edx
  int v83; // edx
  int v84; // eax
  unsigned __int64 v85; // r14
  unsigned int v86; // ecx
  signed int v87; // edx
  signed int v88; // edx
  __int64 v89; // rax
  _QWORD *v90; // rax
  int v91; // edx
  __int64 v92; // rdi
  __int64 v93; // rax
  int v94; // edx
  int v95; // esi
  __int64 v96; // rbp
  __int64 v97; // rbx
  int v98; // er15
  __int64 v99; // r14
  unsigned int v100; // eax
  int v101; // edx
  signed int v102; // edx
  signed int v103; // edx
  __m128i v104; // xmm0
  __m128i v105; // xmm0
  char v106; // al
  __int64 v107; // rdi
  int v108; // eax
  int v109; // esi
  int v110; // edx
  int v111; // eax
  int v112; // eax
  int v113; // edx
  int v114; // eax
  int v115; // eax
  int v116; // edx
  int v117; // edx
  char v118; // dl
  int v119; // eax
  char v120; // dl
  __int64 v121; // rax
  __int64 v122; // rax
  __int64 v123; // rdi
  char v124; // al
  int v125; // edx
  int v126; // edx
  int v127; // edx
  __int64 v128; // rax
  int v129; // edx
  unsigned __int64 v130; // r14
  signed int v131; // edx
  int v132; // edx
  unsigned int v133; // eax
  int v134; // eax
  unsigned int v135; // eax
  char v136; // cl
  int v137; // edx
  int v138; // edx
  int v139; // eax
  unsigned int v140; // ecx
  int v141; // edx
  unsigned int v142; // eax
  unsigned int v143; // er14
  signed int v144; // ecx
  unsigned int v145; // eax
  int v146; // edx
  int v147; // eax
  int v148; // edx
  int v149; // eax
  signed int v150; // edi
  unsigned int v151; // edx
  int v152; // eax
  int v153; // ecx
  int v154; // eax
  unsigned int v155; // eax
  int v156; // esi
  signed int v157; // edx
  unsigned int v158; // eax
  int v159; // edx
  int v160; // ecx
  int v161; // edx
  int v162; // eax
  signed int v163; // er14
  __int64 v164; // rax
  int v165; // esi
  int v166; // edx
  int v167; // esi
  int v168; // er14
  int v169; // ST10_4
  unsigned int v170; // eax
  char v171; // cl
  int v172; // edx
  int v173; // edx
  unsigned int v174; // eax
  __m128i v175; // xmm0
  int v176; // edx
  int v177; // edx
  __m128i v178; // xmm0
  int v179; // eax
  int v180; // edx
  int v181; // eax
  __m128i v182; // xmm0
  unsigned int v183; // eax
  unsigned int v184; // eax
  int v185; // edx
  unsigned int v186; // eax
  signed int v187; // edx
  char v188; // dl
  int v189; // eax
  char v190; // dl
  __int64 v191; // rax
  __int64 v192; // rax
  int v193; // edx
  unsigned int v194; // eax
  int v195; // ecx
  int v196; // edi
  signed __int64 v197; // rdx
  int v198; // eax
  int v199; // edx
  int v200; // eax
  unsigned int v201; // edx
  unsigned int v202; // edx
  unsigned int v203; // eax
  int v204; // edx
  unsigned int v205; // eax
  int v206; // edx
  int v207; // er9
  int v208; // eax
  unsigned int v209; // eax
  int v210; // edx
  int v211; // eax
  int v212; // edx
  unsigned int v213; // eax
  __int64 v214; // rdi
  int v215; // eax
  int v216; // edx
  unsigned int v217; // edx
  __m128i v218; // xmm0
  int v219; // eax
  int v220; // eax
  __m128i v221; // xmm0
  int v222; // edx
  int v223; // edx
  int v224; // eax
  signed __int64 v225; // r14
  int v226; // eax
  unsigned int v227; // eax
  unsigned int v228; // esi
  int v229; // edi
  int v230; // ecx
  signed int v231; // edx
  int v232; // edi
  unsigned int v233; // eax
  signed int v234; // edx
  int v235; // ecx
  int v236; // edx
  signed int v237; // eax
  int v238; // ecx
  signed __int64 v239; // rdx
  char v240; // di
  int v241; // edx
  unsigned int v242; // eax
  int v243; // esi
  int v244; // ecx
  signed int v245; // edx
  int v246; // esi
  int v247; // edx
  int v248; // ecx
  int v249; // eax
  int v250; // esi
  int v251; // edx
  int v252; // ecx
  __int64 v253; // rax
  unsigned int v254; // edx
  signed __int64 v255; // r14
  int v256; // eax
  __int64 v257; // r9
  int v258; // edx
  char *v259; // r14
  int v260; // eax
  int v261; // eax
  int v262; // eax
  int v263; // eax
  int v264; // eax
  int v265; // eax
  __int64 i; // rax
  signed __int64 v267; // r9
  size_t v268; // rax
  _WORD *v269; // rax
  int v270; // edx
  int v271; // eax
  int v272; // eax
  int v273; // edx
  unsigned int v274; // edx
  unsigned int v275; // edx
  unsigned int v276; // eax
  int v277; // edx
  int v278; // eax
  int v279; // edx
  int v280; // eax
  const char *v281; // r14
  unsigned __int64 v282; // kr18_8
  __int64 v283; // r9
  unsigned int v284; // eax
  __int64 v285; // r9
  unsigned int v286; // eax
  __int64 v287; // r9
  unsigned int v288; // eax
  __int64 v289; // rdi
  int v290; // eax
  int v291; // eax
  int v292; // eax
  const char *v293; // r14
  unsigned __int64 v294; // kr20_8
  int v295; // eax
  int s; // [rsp+0h] [rbp-1C8h]
  signed __int16 sa; // [rsp+0h] [rbp-1C8h]
  char *sb; // [rsp+0h] [rbp-1C8h]
  char *sc; // [rsp+0h] [rbp-1C8h]
  signed __int64 v300; // [rsp+8h] [rbp-1C0h]
  unsigned __int64 v301; // [rsp+10h] [rbp-1B8h]
  int v302; // [rsp+10h] [rbp-1B8h]
  int v303; // [rsp+18h] [rbp-1B0h]
  __int64 v304; // [rsp+18h] [rbp-1B0h]
  __int64 v305; // [rsp+28h] [rbp-1A0h]
  char v306; // [rsp+30h] [rbp-198h]
  char v307; // [rsp+32h] [rbp-196h]
  __m128i v308; // [rsp+80h] [rbp-148h]
  __m128i v309; // [rsp+90h] [rbp-138h]
  __m128i v310; // [rsp+A0h] [rbp-128h]
  __m128i v311; // [rsp+B0h] [rbp-118h]
  __m128i v312; // [rsp+C0h] [rbp-108h]
  __m128i v313; // [rsp+D0h] [rbp-F8h]
  __m128i v314; // [rsp+E0h] [rbp-E8h]
  __m128i v315; // [rsp+F0h] [rbp-D8h]
  __m128i v316; // [rsp+100h] [rbp-C8h]
  __m128i v317; // [rsp+110h] [rbp-B8h]
  __m128i v318; // [rsp+120h] [rbp-A8h]
  __m128i v319; // [rsp+130h] [rbp-98h]
  __m128i v320; // [rsp+140h] [rbp-88h]
  __m128i v321; // [rsp+150h] [rbp-78h]
  __m128i v322; // [rsp+160h] [rbp-68h]
  __m128i v323; // [rsp+170h] [rbp-58h]
  unsigned __int64 v324; // [rsp+188h] [rbp-40h]

  v2 = -1LL;
  v3 = a1;
  v4 = 0LL;
  v5 = 0LL;
  v324 = __readfsqword(0x28u);
  while ( 1 )
  {
    if ( v4 )
      goto LABEL_30;
LABEL_3:
    if ( (_DWORD)v2 == -1 )
      break;
LABEL_30:
    if ( (_DWORD)v2 == -1 )
    {
      if ( !v4 )
      {
        v6 = v3 + 192;
        goto LABEL_5;
      }
LABEL_7:
      --v4;
LABEL_8:
      v9 = v5;
      v10 = *(_DWORD *)(v3 + 4552) == 2;
      v5 = (__m128i *)((char *)v5 + 1);
      a2 = LOBYTE(v9->m128i_i64[0]);
      v305 = LOBYTE(v9->m128i_i64[0]);
      if ( v10 )
      {
        v75 = *(_QWORD *)(v3 + 4344);
        if ( v75 )
          sub_2D280(2, v75, a2, v3, v2);
      }
      if ( !*(_BYTE *)(v3 + 320) )
        goto LABEL_10;
    }
    else
    {
      v10 = *(_BYTE *)(v3 + 320) == 0;
      v305 = v2;
      if ( v10 )
        goto LABEL_10;
    }
    a2 = (unsigned __int64)&v305;
    sub_BCD20(v3 + 328, (char *)&v305, 1uLL);
    if ( *(_BYTE *)(v3 + 321) )
    {
      if ( v305 == 27 )
      {
        *(_DWORD *)(v3 + 324) = 1;
        goto LABEL_40;
      }
      if ( v305 != 155 )
      {
        if ( v305 != 91 )
        {
          if ( v305 == 52 )
          {
            if ( *(_DWORD *)(v3 + 324) == 2 )
            {
              *(_DWORD *)(v3 + 324) = 3;
              goto LABEL_40;
            }
          }
          else if ( v305 == 105 && *(_DWORD *)(v3 + 324) == 3 )
          {
            *(_DWORD *)(v3 + 324) = 4;
            v2 = -1LL;
            sub_8E3B0(v3);
            continue;
          }
          goto LABEL_39;
        }
        if ( *(_DWORD *)(v3 + 324) != 1 )
        {
LABEL_39:
          *(_DWORD *)(v3 + 324) = 0;
LABEL_40:
          v2 = -1LL;
          continue;
        }
      }
      *(_DWORD *)(v3 + 324) = 2;
      goto LABEL_40;
    }
LABEL_10:
    v11 = *(_DWORD *)(v3 + 3744);
    v12 = v305;
    v13 = *(_DWORD *)(v3 + 3744);
    if ( v11 )
    {
      if ( (v305 & 0xFFFFFFFFFFFFFFE0LL) != 128 )
        goto LABEL_12;
    }
    else
    {
      a2 = v3 + 308;
      LOWORD(v73) = sub_90B70(v3, (int *)(v3 + 308), (unsigned __int8)v305);
      v12 = v73;
      switch ( v73 )
      {
        case 0x8000002AuLL:
          v2 = -1LL;
LABEL_42:
          v13 = *(_DWORD *)(v3 + 3744);
          v305 = 55649LL;
          v12 = 55649LL;
LABEL_43:
          v23 = v12 & 0xFFFFFFFFFFFFFFE0LL;
          goto LABEL_44;
        case 0x8000003FuLL:
          goto LABEL_40;
        case 0x80000021uLL:
          v2 = (signed int)v305;
          goto LABEL_42;
      }
      v11 = *(_DWORD *)(v3 + 3744);
      v305 = v12;
      v13 = v11;
      if ( (v12 & 0xFFFFFFFFFFFFFFE0LL) != 128 )
      {
LABEL_12:
        v2 = -1LL;
        if ( v12 == 127 )
        {
          if ( v11 <= 4 && (v14 = *(_DWORD *)v3, BYTE1(v14) & 0x40) )
          {
            v15 = *(_DWORD *)(v3 + 236);
            if ( v15 && !*(_BYTE *)(v3 + 258) )
              *(_DWORD *)(v3 + 236) = v15 - 1;
            v10 = *(_BYTE *)(v3 + 4561) == 0;
            *(_BYTE *)(v3 + 258) = 0;
            v2 = -1LL;
            if ( v10 )
            {
              v16 = *(_DWORD *)(v3 + 236);
              v17 = *(_DWORD *)(v3 + 232);
              if ( v16 > 0 && v16 <= *(_DWORD *)(v3 + 416) )
              {
                sub_8F1A0((const __m128i *)v3, v16, v17);
                v17 = *(_DWORD *)(v3 + 232);
                v16 = *(_DWORD *)(v3 + 236);
              }
              v18 = v16 + 1;
              if ( v16 + 1 > 0 && v18 <= *(_DWORD *)(v3 + 416) )
              {
                sub_8F1A0((const __m128i *)v3, v18, v17);
                v16 = *(_DWORD *)(v3 + 236);
                v17 = *(_DWORD *)(v3 + 232);
              }
              v19 = sub_8C080((const __m128i *)v3, v17, 3723LL, 1);
              a2 = (unsigned int)v16;
              v2 = -1LL;
              sub_8BE60(v19, v16, (const __m128i *)(v3 + 160));
            }
          }
          else
          {
            switch ( v11 )
            {
              case 0u:
                v2 = -1LL;
                goto LABEL_119;
              case 1u:
                v48 = *(_DWORD *)(v3 + 648);
                v2 = -1LL;
                goto LABEL_197;
              case 2u:
                v2 = -1LL;
                goto LABEL_172;
              case 3u:
                v2 = -1LL;
                goto LABEL_170;
              case 4u:
                v2 = -1LL;
                goto LABEL_179;
              case 6u:
                v2 = -1LL;
                goto LABEL_161;
              case 7u:
                v2 = -1LL;
                goto LABEL_153;
              case 8u:
                v2 = -1LL;
                goto LABEL_114;
              case 9u:
                v2 = -1LL;
                goto LABEL_147;
              case 0xAu:
                v2 = -1LL;
                goto LABEL_137;
              case 0xBu:
                v2 = -1LL;
                goto LABEL_127;
              case 0xCu:
                v2 = -1LL;
                goto LABEL_124;
              case 0xDu:
                v2 = -1LL;
                goto LABEL_121;
              default:
                v2 = -1LL;
                break;
            }
          }
          goto LABEL_26;
        }
        goto LABEL_43;
      }
    }
    if ( v11 > 4 )
    {
      v2 = -1LL;
      goto LABEL_43;
    }
    if ( !*(_BYTE *)(v3 + 442) && *(_BYTE *)v3 & 0x10 )
    {
      if ( v12 == 154 )
      {
        v305 = 0LL;
        v2 = -1LL;
        goto LABEL_26;
      }
      v11 = 1;
      *(_DWORD *)(v3 + 3744) = 1;
      v12 = (v12 & 0x1F) + 64;
      *(_DWORD *)(v3 + 648) = 0;
      v305 = v12;
    }
    v13 = v11;
    v2 = -1LL;
    v23 = v12 & 0xFFFFFFFFFFFFFFE0LL;
LABEL_44:
    if ( !v23 && v13 <= 4 )
    {
      switch ( v12 )
      {
        case 5uLL:
          if ( *(_BYTE *)v3 & 1 )
          {
            if ( *(_QWORD *)(v3 + 4328) )
            {
              v39 = sub_8EAC0(v3, 0xFFFFLL, *(_QWORD *)(v3 + 4488), *(_DWORD *)(v3 + 4496));
              a2 = *(_QWORD *)v39;
              sub_2C0F0(*(_QWORD *)(v3 + 4328), *(const char **)v39, *(_DWORD *)(v39 + 16), 0);
              sub_BC660((void **)v39);
            }
          }
          else
          {
            *(_DWORD *)(v3 + 3744) = 0;
          }
          goto LABEL_26;
        case 7uLL:
          v36 = sub_B4D20();
          if ( *(_BYTE *)(v3 + 84) )
          {
            v37 = *(_QWORD **)(v3 + 64);
            if ( !v37 )
              goto LABEL_71;
          }
          else
          {
            v90 = sub_2F450(1uLL, 0x10uLL, 0LL);
            v37 = *(_QWORD **)(v3 + 64);
            v90[1] = v36;
            *v90 = 0LL;
            if ( v37 )
            {
              **(_QWORD **)(v3 + 72) = v90;
            }
            else
            {
              *(_QWORD *)(v3 + 64) = v90;
              v37 = v90;
            }
            *(_QWORD *)(v3 + 72) = v90;
            ++*(_DWORD *)(v3 + 80);
          }
          while ( 2 )
          {
            a2 = v36 - *(signed int *)(v3 + 4520);
            if ( v37[1] < a2 )
            {
              *(_QWORD *)(v3 + 64) = *v37;
              sub_2F4D0(v37);
              v37 = *(_QWORD **)(v3 + 64);
              if ( v37 )
              {
                --*(_DWORD *)(v3 + 80);
                continue;
              }
              --*(_DWORD *)(v3 + 80);
              *(_QWORD *)(v3 + 72) = 0LL;
            }
            break;
          }
LABEL_71:
          if ( !*(_BYTE *)(v3 + 4508) )
            goto LABEL_72;
          if ( *(_BYTE *)(v3 + 84) )
          {
            if ( v36 - *(_QWORD *)(v3 + 88) < (unsigned __int64)*(unsigned int *)(v3 + 4516) )
            {
              *(_QWORD *)(v3 + 88) = v36;
              goto LABEL_75;
            }
            *(_BYTE *)(v3 + 84) = 0;
            *(_QWORD *)(v3 + 88) = v36;
          }
          else
          {
            if ( *(_DWORD *)(v3 + 80) >= *(_DWORD *)(v3 + 4512) )
            {
              *(_BYTE *)(v3 + 84) = 1;
              *(_QWORD *)(v3 + 88) = v36;
              goto LABEL_75;
            }
LABEL_72:
            *(_QWORD *)(v3 + 88) = v36;
          }
          a2 = *(unsigned int *)(v3 + 4504);
          (*(void (__fastcall **)(_QWORD, unsigned __int64))(**(_QWORD **)(v3 + 4336) + 80LL))(
            *(_QWORD *)(v3 + 4336),
            a2);
          if ( *(_DWORD *)(v3 + 4504) == 2 )
          {
            a2 = (unsigned __int64)sub_8FFF0;
            *(_BYTE *)(v3 + 425) = 1;
            *(_QWORD *)(v3 + 432) = sub_99D00(100LL, (__int64)sub_8FFF0, v3);
          }
LABEL_75:
          v10 = *(_BYTE *)(v3 + 4377) == 0;
          *(_BYTE *)(v3 + 446) = 1;
          if ( v10 )
            sub_8E2A0(v3);
          goto LABEL_26;
        case 8uLL:
          v38 = *(_DWORD *)(v3 + 236);
          if ( v38 )
            goto LABEL_78;
          v83 = *(_DWORD *)(v3 + 232);
          if ( v83 && *(_BYTE *)(v3 + 257) )
          {
            if ( v83 <= 0 )
            {
LABEL_78:
              if ( *(_BYTE *)(v3 + 258) )
                *(_BYTE *)(v3 + 258) = 0;
              else
                *(_DWORD *)(v3 + 236) = v38 - 1;
            }
            else
            {
              v84 = *(_DWORD *)(v3 + 416);
              *(_DWORD *)(v3 + 232) = v83 - 1;
              *(_DWORD *)(v3 + 236) = v84 - 1;
            }
          }
          v10 = *(_BYTE *)(v3 + 4377) == 0;
          *(_BYTE *)(v3 + 446) = 1;
          if ( v10 )
            sub_8E2A0(v3);
          goto LABEL_26;
        case 9uLL:
          v26 = *(_QWORD *)(v3 + 232);
          v27 = (_BYTE *)sub_8C080((const __m128i *)v3, *(_DWORD *)(v3 + 232), 3879LL, 1);
          v28 = *(signed int *)(v3 + 236);
          v29 = *(_DWORD *)(v3 + 416);
          v30 = v29 - 1;
          v31 = v28 + 1;
          v32 = v28 + 1;
          do
          {
            v34 = v31;
            *(_DWORD *)(v3 + 236) = v31;
            if ( v31 >= v30 )
              break;
            ++v31;
          }
          while ( !*(_BYTE *)(*(_QWORD *)(v3 + 3736) + v32++) );
          if ( *v27 & 3 )
          {
            v35 = v29 / 2;
            if ( v34 >= v35 )
              *(_DWORD *)(v3 + 236) = v35 - 1;
          }
          else if ( v34 >= v29 )
          {
            *(_DWORD *)(v3 + 236) = v30;
          }
          a2 = v26;
          sub_8BB10((_DWORD *)v3, v26, *(_QWORD *)(v3 + 232));
          v10 = *(_BYTE *)(v3 + 4377) == 0;
          *(_BYTE *)(v3 + 446) = 1;
          if ( v10 )
            sub_8E2A0(v3);
          goto LABEL_26;
        case 0xAuLL:
          goto LABEL_47;
        case 0xBuLL:
          v42 = *(_DWORD *)v3;
          goto LABEL_110;
        case 0xCuLL:
          v42 = *(_DWORD *)v3;
          if ( v42 & 0x1000 )
          {
            v43 = *(_DWORD *)(v3 + 416);
            v44 = *(_DWORD *)(v3 + 412);
            *(_BYTE *)(v3 + 258) = 0;
            v45 = v43 - 1;
            v10 = v43 == 0;
            v46 = v43 < 0;
            v47 = v44 - 1;
            if ( !v46 && !v10 )
              v45 = 0;
            if ( v44 > 0 )
              v47 = 0;
            *(_DWORD *)(v3 + 236) = v45;
            a2 = 0LL;
            *(_DWORD *)(v3 + 232) = v47;
            sub_90F70((__m128i *)v3, 0, 0, 1);
            if ( *(_BYTE *)(v3 + 4577) )
              *(_DWORD *)(v3 + 32) = 0;
            v10 = *(_BYTE *)(v3 + 4377) == 0;
            *(_BYTE *)(v3 + 258) = 0;
            *(_BYTE *)(v3 + 446) = 1;
            if ( v10 )
              sub_8E2A0(v3);
          }
          else
          {
LABEL_110:
            if ( v42 & 2 )
            {
LABEL_47:
              v24 = *(_DWORD *)(v3 + 232);
              if ( v24 == *(_DWORD *)(v3 + 252) )
              {
                a2 = *(unsigned int *)(v3 + 248);
                sub_8ED60((const __m128i *)v3, a2, v24, 1, 1);
              }
              else if ( v24 < *(_DWORD *)(v3 + 412) - 1 )
              {
                *(_DWORD *)(v3 + 232) = v24 + 1;
              }
              if ( *(_BYTE *)(v3 + 4548) )
                *(_DWORD *)(v3 + 236) = 0;
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 258) = 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
              v25 = *(_QWORD *)(v3 + 4344);
              if ( v25 )
              {
                a2 = (unsigned __int8)v305;
                sub_2D280(1, v25, v305, v3, v2);
              }
            }
            else
            {
              *(_DWORD *)(v3 + 3744) = 0;
            }
          }
          goto LABEL_26;
        case 0xDuLL:
          v10 = *(_BYTE *)(v3 + 4377) == 0;
          *(_DWORD *)(v3 + 236) = 0;
          *(_BYTE *)(v3 + 258) = 0;
          *(_BYTE *)(v3 + 446) = 1;
          if ( v10 )
            sub_8E2A0(v3);
          if ( !*(_BYTE *)(v3 + 4540) )
            goto LABEL_98;
          v40 = *(_DWORD *)(v3 + 232);
          if ( v40 == *(_DWORD *)(v3 + 252) )
          {
            a2 = *(unsigned int *)(v3 + 248);
            sub_8ED60((const __m128i *)v3, a2, v40, 1, 1);
            v41 = *(_QWORD *)(v3 + 4344);
            if ( v41 )
              goto LABEL_99;
          }
          else
          {
            if ( v40 < *(_DWORD *)(v3 + 412) - 1 )
              *(_DWORD *)(v3 + 232) = v40 + 1;
LABEL_98:
            v41 = *(_QWORD *)(v3 + 4344);
            if ( v41 )
            {
LABEL_99:
              a2 = (unsigned __int8)v305;
              sub_2D280(1, v41, v305, v3, v2);
              goto LABEL_26;
            }
          }
          break;
        case 0xEuLL:
          if ( *(_BYTE *)v3 & 2 )
            *(_DWORD *)(v3 + 260) = 1;
          else
            *(_DWORD *)(v3 + 3744) = 0;
          goto LABEL_26;
        case 0xFuLL:
          if ( *(_BYTE *)v3 & 2 )
            *(_DWORD *)(v3 + 260) = 0;
          else
            *(_DWORD *)(v3 + 3744) = 0;
          goto LABEL_26;
        case 0x1BuLL:
          if ( *(_BYTE *)(v3 + 442) )
          {
            *(_DWORD *)(v3 + 3744) = 9;
          }
          else if ( *(_BYTE *)v3 & 1 )
          {
            *(_DWORD *)(v3 + 3744) = 1;
            *(_DWORD *)(v3 + 648) = 0;
          }
          else
          {
            *(_DWORD *)(v3 + 3744) = 0;
          }
          goto LABEL_26;
        default:
          goto LABEL_26;
      }
      goto LABEL_26;
    }
    switch ( v13 )
    {
      case 0u:
LABEL_119:
        a2 = v12;
        sub_8F760((__m128i *)v3, v12, v2);
        *(_QWORD *)(v3 + 4360) = v305;
        goto LABEL_26;
      case 1u:
        goto LABEL_114;
      case 2u:
LABEL_172:
        *(_DWORD *)(v3 + 3744) = 0;
        if ( (*__ctype_b_loc())[(signed int)v12] & 0x800 )
        {
          v68 = *(signed int *)(v3 + 644);
          if ( (signed int)v68 <= 32 )
          {
            v69 = v3 + 4 * v68;
            v70 = *(_DWORD *)(v69 + 512);
            if ( v70 > 0x19999999 || (a2 = 10 * v70, a2 > 4294967247u - v12) )
            {
              *(_DWORD *)(v69 + 512) = -1;
              *(_DWORD *)(v3 + 3744) = 2;
              goto LABEL_26;
            }
            *(_DWORD *)(v69 + 512) = a2 + v12 - 48;
          }
          *(_DWORD *)(v3 + 3744) = 2;
LABEL_26:
          if ( !*(_DWORD *)(v3 + 3748) )
            continue;
          v20 = *(_DWORD *)(v3 + 236);
          v21 = *(_DWORD *)(v3 + 232);
          v22 = (unsigned int)(v20 + 1);
          if ( *(_DWORD *)(v3 + 416) == v20 )
          {
            ++v21;
            v22 = 0LL;
          }
          a2 = *(_QWORD *)(v3 + 232);
          sub_8BB10((_DWORD *)v3, a2, (v22 << 32) | v21);
          if ( !v4 )
            goto LABEL_3;
          goto LABEL_30;
        }
        if ( v12 == 59 )
        {
          v89 = *(signed int *)(v3 + 644);
          if ( (signed int)v89 <= 31 )
          {
            *(_DWORD *)(v3 + 644) = v89 + 1;
            *(_DWORD *)(v3 + 4 * v89 + 516) = 0;
          }
          *(_DWORD *)(v3 + 3744) = 2;
          goto LABEL_26;
        }
        v76 = *(_DWORD *)(v3 + 648);
        if ( v12 <= 0x3F )
        {
          if ( v76 )
          {
            *(_DWORD *)(v3 + 648) = -1;
          }
          else
          {
            if ( v12 == 63 )
              LODWORD(v12) = 1;
            *(_DWORD *)(v3 + 648) = v12;
          }
          *(_DWORD *)(v3 + 3744) = 2;
          goto LABEL_26;
        }
        v85 = (signed int)(*(_DWORD *)(v3 + 648) << 8) + v12;
        if ( v85 == 102 )
          goto LABEL_756;
        if ( v85 <= 0x66 )
        {
          if ( v85 == 76 )
          {
            if ( *(_BYTE *)v3 & 8 )
            {
              v233 = *(_DWORD *)(v3 + 412);
              if ( *(_DWORD *)(v3 + 516) <= v233 )
                v233 = *(_DWORD *)(v3 + 516);
              a2 = *(unsigned int *)(v3 + 232);
              v234 = *(_DWORD *)(v3 + 252);
              *(_DWORD *)(v3 + 516) = v233;
              if ( (signed int)a2 <= v234 )
              {
                v235 = -1;
                if ( v233 )
                  v235 = -v233;
                sub_8ED60((const __m128i *)v3, a2, v234, v235, 0);
              }
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
            }
            goto LABEL_26;
          }
          if ( v85 <= 0x4C )
          {
            if ( v85 == 69 )
            {
              v204 = *(_DWORD *)v3;
              if ( v204 & 0x2000 )
              {
                v205 = *(_DWORD *)(v3 + 412);
                if ( *(_DWORD *)(v3 + 516) <= v205 )
                  v205 = *(_DWORD *)(v3 + 516);
                *(_DWORD *)(v3 + 516) = v205;
                if ( !v205 )
                  v205 = 1;
                a2 = 0LL;
                sub_8A3A0(v3, 0, *(_DWORD *)(v3 + 232) + v205, 1);
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
              goto LABEL_26;
            }
            if ( v85 <= 0x45 )
            {
              if ( v85 != 66 )
              {
                if ( v85 <= 0x42 )
                {
                  if ( v85 == 64 )
                  {
                    if ( *(_BYTE *)v3 & 8 )
                    {
                      a2 = *(unsigned int *)(v3 + 416);
                      if ( *(_DWORD *)(v3 + 516) <= (unsigned int)a2 )
                        a2 = *(unsigned int *)(v3 + 516);
                      *(_DWORD *)(v3 + 516) = a2;
                      if ( !(_DWORD)a2 )
                        a2 = 1LL;
                      sub_8F270((const __m128i *)v3, a2);
                      v10 = *(_BYTE *)(v3 + 4377) == 0;
                      *(_BYTE *)(v3 + 446) = 1;
                      if ( v10 )
                        sub_8E2A0(v3);
                    }
                  }
                  else if ( v85 == 65 )
                  {
                    v183 = *(_DWORD *)(v3 + 412);
                    if ( *(_DWORD *)(v3 + 516) <= v183 )
                      v183 = *(_DWORD *)(v3 + 516);
                    a2 = *(unsigned int *)(v3 + 236);
                    *(_DWORD *)(v3 + 516) = v183;
                    if ( !v183 )
                      v183 = 1;
                    sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232) - v183, 1);
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_BYTE *)(v3 + 446) = 1;
                    if ( v10 )
                      sub_8E2A0(v3);
                  }
                  goto LABEL_26;
                }
                if ( v85 != 67 )
                {
                  if ( v85 == 68 )
                  {
                    v155 = *(_DWORD *)(v3 + 416);
                    if ( *(_DWORD *)(v3 + 516) <= v155 )
                      v155 = *(_DWORD *)(v3 + 516);
                    v156 = *(_DWORD *)(v3 + 236);
                    v157 = *(_DWORD *)(v3 + 232);
                    *(_DWORD *)(v3 + 516) = v155;
                    if ( !v155 )
                      v155 = 1;
                    a2 = v156 - v155;
                    sub_8A3A0(v3, a2, v157, 1);
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_BYTE *)(v3 + 446) = 1;
                    if ( v10 )
                      sub_8E2A0(v3);
                  }
                  goto LABEL_26;
                }
LABEL_665:
                v186 = *(_DWORD *)(v3 + 416);
                if ( *(_DWORD *)(v3 + 516) <= v186 )
                  v186 = *(_DWORD *)(v3 + 516);
                v187 = *(_DWORD *)(v3 + 232);
                *(_DWORD *)(v3 + 516) = v186;
                if ( !v186 )
                  v186 = 1;
                a2 = *(_DWORD *)(v3 + 236) + v186;
                sub_8A3A0(v3, a2, v187, 1);
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
                goto LABEL_26;
              }
LABEL_513:
              v133 = *(_DWORD *)(v3 + 412);
              if ( *(_DWORD *)(v3 + 516) <= v133 )
                v133 = *(_DWORD *)(v3 + 516);
              a2 = *(unsigned int *)(v3 + 236);
              *(_DWORD *)(v3 + 516) = v133;
              if ( !v133 )
                v133 = 1;
              sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232) + v133, 1);
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
              goto LABEL_26;
            }
            if ( v85 == 72 )
            {
LABEL_756:
              v227 = 0;
              if ( *(_DWORD *)(v3 + 644) > 1 )
                v227 = *(_DWORD *)(v3 + 520);
              v228 = *(_DWORD *)(v3 + 412);
              if ( *(_DWORD *)(v3 + 516) <= v228 )
                v228 = *(_DWORD *)(v3 + 516);
              if ( *(_DWORD *)(v3 + 416) <= v227 )
                v227 = *(_DWORD *)(v3 + 416);
              v10 = *(_BYTE *)(v3 + 256) == 0;
              *(_DWORD *)(v3 + 516) = v228;
              *(_DWORD *)(v3 + 520) = v227;
              if ( v10 )
              {
                v229 = -1;
                v230 = 0;
                v231 = 0;
              }
              else
              {
                v231 = *(_DWORD *)(v3 + 248);
                v230 = 2;
                v229 = v231 - 1;
              }
              v232 = v228 + v229;
              v10 = v228 == 0;
              a2 = v227 - 1;
              if ( !v10 )
                v231 = v232;
              if ( !v227 )
                a2 = 0LL;
              sub_8A3A0(v3, a2, v231, v230);
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
              goto LABEL_26;
            }
            if ( v85 > 0x48 )
            {
              if ( v85 == 74 )
              {
                v134 = *(_DWORD *)(v3 + 516);
                if ( v134 == 3 )
                {
                  if ( !*(_BYTE *)(v3 + 4566) )
                    sub_906E0((const __m128i *)v3);
                }
                else
                {
                  v135 = v134 + 1;
                  if ( v135 > 3 )
                  {
                    LOBYTE(v137) = 0;
                    v136 = 0;
                  }
                  else
                  {
                    v136 = v135 & 1;
                    v137 = (v135 >> 1) & 1;
                  }
                  a2 = 0LL;
                  sub_90F70((__m128i *)v3, 0, v137, v136);
                }
                if ( *(_BYTE *)(v3 + 4577) )
                  *(_DWORD *)(v3 + 32) = 0;
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
              else if ( v85 == 75 )
              {
                v170 = *(_DWORD *)(v3 + 516) + 1;
                if ( v170 > 3 )
                {
                  LOBYTE(v172) = 0;
                  v171 = 0;
                }
                else
                {
                  v171 = v170 & 1;
                  v172 = (v170 >> 1) & 1;
                }
                a2 = 1LL;
                sub_90F70((__m128i *)v3, 1, v172, v171);
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
              goto LABEL_26;
            }
            if ( v85 == 70 )
            {
              v193 = *(_DWORD *)v3;
              if ( v193 & 0x2000 )
              {
                v194 = *(_DWORD *)(v3 + 412);
                if ( *(_DWORD *)(v3 + 516) <= v194 )
                  v194 = *(_DWORD *)(v3 + 516);
                *(_DWORD *)(v3 + 516) = v194;
                if ( !v194 )
                  v194 = 1;
                a2 = 0LL;
                sub_8A3A0(v3, 0, *(_DWORD *)(v3 + 232) - v194, 1);
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
              goto LABEL_26;
            }
            if ( v85 == 71 )
            {
LABEL_803:
              v247 = *(_DWORD *)v3;
              if ( v247 & 0x2000 )
              {
                v248 = *(_DWORD *)(v3 + 416);
                v249 = *(_DWORD *)(v3 + 232);
                v250 = *(_DWORD *)(v3 + 416);
                if ( *(_DWORD *)(v3 + 516) <= (unsigned int)v248 )
                  v250 = *(_DWORD *)(v3 + 516);
                v251 = 0;
                *(_DWORD *)(v3 + 516) = v250;
                if ( v250 )
                {
                  v251 = v250 - 1;
                  if ( v250 - 1 < 0 )
                    v251 = 0;
                }
                *(_BYTE *)(v3 + 258) = 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v248 <= v251 )
                  v251 = v248 - 1;
                if ( v249 < 0 )
                  v249 = 0;
                v252 = *(_DWORD *)(v3 + 412);
                *(_DWORD *)(v3 + 236) = v251;
                a2 = (unsigned int)(v252 - 1);
                if ( v249 >= v252 )
                  v249 = v252 - 1;
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_DWORD *)(v3 + 232) = v249;
                if ( v10 )
                  sub_8E2A0(v3);
              }
              goto LABEL_26;
            }
          }
          else if ( v85 == 90 )
          {
            v236 = *(_DWORD *)v3;
            if ( v236 & 0x4000 )
            {
              v237 = *(_DWORD *)(v3 + 416);
              if ( *(_DWORD *)(v3 + 516) <= (unsigned int)v237 )
                v237 = *(_DWORD *)(v3 + 516);
              v77 = *(_QWORD *)(v3 + 232);
              a2 = *(_QWORD *)(v3 + 232);
              *(_DWORD *)(v3 + 516) = v237;
              if ( v237 )
              {
                if ( v237 > 0 )
                {
LABEL_784:
                  v238 = *(_DWORD *)(v3 + 236);
                  if ( v238 > 0 )
                  {
LABEL_785:
                    v239 = v238 - 1LL;
                    while ( 1 )
                    {
                      *(_DWORD *)(v3 + 236) = --v238;
                      if ( !v238 )
                        break;
                      v240 = *(_BYTE *)(*(_QWORD *)(v3 + 3736) + v239--);
                      if ( v240 )
                      {
                        if ( --v237 )
                          goto LABEL_785;
                        break;
                      }
                    }
                    v77 = *(_QWORD *)(v3 + 232);
                  }
                }
                sub_8BB10((_DWORD *)v3, a2, v77);
                goto LABEL_26;
              }
LABEL_838:
              v237 = 1;
              goto LABEL_784;
            }
          }
          else if ( v85 > 0x5A )
          {
            if ( v85 == 98 )
            {
              v142 = *(_DWORD *)(v3 + 416) * *(_DWORD *)(v3 + 412);
              if ( v142 > *(_DWORD *)(v3 + 516) )
                v142 = *(_DWORD *)(v3 + 516);
              v10 = *(_QWORD *)(v3 + 4360) == 0LL;
              *(_DWORD *)(v3 + 516) = v142;
              if ( !v10 && v142 )
              {
                v143 = 0;
                do
                {
                  a2 = *(_QWORD *)(v3 + 4360);
                  ++v143;
                  sub_8F760((__m128i *)v3, a2, v2);
                }
                while ( *(_DWORD *)(v3 + 516) > v143 );
              }
              goto LABEL_26;
            }
            if ( v85 <= 0x62 )
            {
              if ( v85 == 96 )
                goto LABEL_803;
              if ( v85 == 97 )
              {
                v185 = *(_DWORD *)v3;
                if ( v185 & 0x2000 )
                  goto LABEL_665;
              }
            }
            else
            {
              if ( v85 == 100 )
              {
                v241 = *(_DWORD *)v3;
                if ( v241 & 0x2000 )
                {
                  v242 = *(_DWORD *)(v3 + 412);
                  if ( *(_DWORD *)(v3 + 516) <= v242 )
                    v242 = *(_DWORD *)(v3 + 516);
                  v10 = *(_BYTE *)(v3 + 256) == 0;
                  *(_DWORD *)(v3 + 516) = v242;
                  if ( v10 )
                  {
                    v243 = -1;
                    v244 = 0;
                    v245 = 0;
                  }
                  else
                  {
                    v245 = *(_DWORD *)(v3 + 248);
                    v244 = 2;
                    v243 = v245 - 1;
                  }
                  v246 = v242 + v243;
                  if ( v242 )
                    v245 = v246;
                  a2 = *(unsigned int *)(v3 + 236);
                  sub_8A3A0(v3, a2, v245, v244);
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 446) = 1;
                  if ( v10 )
                    sub_8E2A0(v3);
                }
                goto LABEL_26;
              }
              if ( v85 <= 0x64 )
              {
                if ( *(_BYTE *)v3 & 2 && *(_QWORD *)(v3 + 4328) )
                {
                  a2 = v3 + 2706;
                  sub_2C0F0(*(_QWORD *)(v3 + 4328), (const char *)(v3 + 2706), strlen((const char *)(v3 + 2706)), 0);
                }
                goto LABEL_26;
              }
              v132 = *(_DWORD *)v3;
              if ( v132 & 0x2000 )
                goto LABEL_513;
            }
          }
          else if ( v85 == 83 )
          {
            v140 = *(_DWORD *)(v3 + 412);
            if ( *(_DWORD *)(v3 + 516) <= v140 )
              v140 = *(_DWORD *)(v3 + 516);
            v141 = *(_DWORD *)v3;
            *(_DWORD *)(v3 + 516) = v140;
            if ( v141 & 0x1000 )
            {
              a2 = *(unsigned int *)(v3 + 248);
              if ( !v140 )
                v140 = 1;
              sub_8ED60((const __m128i *)v3, a2, *(_DWORD *)(v3 + 252), v140, 1);
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 258) = 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
            }
          }
          else if ( v85 > 0x53 )
          {
            if ( v85 == 84 )
            {
              v158 = *(_DWORD *)(v3 + 412);
              if ( *(_DWORD *)(v3 + 516) <= v158 )
                v158 = *(_DWORD *)(v3 + 516);
              v159 = *(_DWORD *)v3;
              *(_DWORD *)(v3 + 516) = v158;
              if ( v159 & 0x1000 )
              {
                a2 = *(unsigned int *)(v3 + 248);
                v160 = -v158;
                if ( !v158 )
                  v160 = -1;
                sub_8ED60((const __m128i *)v3, a2, *(_DWORD *)(v3 + 252), v160, 1);
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 258) = 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
            }
            else if ( v85 == 88 && *(_BYTE *)v3 & 1 )
            {
              v163 = *(_DWORD *)(v3 + 416);
              if ( *(_DWORD *)(v3 + 516) <= (unsigned int)v163 )
                v163 = *(_DWORD *)(v3 + 516);
              *(_DWORD *)(v3 + 516) = v163;
              if ( !v163 )
                v163 = 1;
              v302 = *(_DWORD *)(v3 + 236);
              v164 = sub_8C080((const __m128i *)v3, *(_DWORD *)(v3 + 232), 4862LL, 1);
              sb = (char *)v164;
              if ( *(_BYTE *)(v164 + 32) != *(_BYTE *)(v3 + 4480) )
              {
                sub_8C1C0((const __m128i *)v3, (_WORD *)v164);
                sb[32] = *(_BYTE *)(v3 + 4480);
              }
              v165 = *(_DWORD *)(v3 + 236);
              v304 = *(_QWORD *)(v3 + 232);
              if ( *(_DWORD *)(v3 + 416) - v165 <= v163 )
                v163 = *(_DWORD *)(v3 + 416) - v165;
              v166 = *(_DWORD *)(v3 + 232);
              LODWORD(v300) = v165 + v163;
              if ( *(_DWORD *)(v3 + 416) >= v165 && v165 > 0 )
              {
                sub_8F1A0((const __m128i *)v3, v165, v166);
                v165 = *(_DWORD *)(v3 + 236);
                v166 = *(_DWORD *)(v3 + 232);
              }
              v167 = v163 + v165;
              if ( v167 > 0 && v167 <= *(_DWORD *)(v3 + 416) )
                sub_8F1A0((const __m128i *)v3, v167, v166);
              a2 = *(_QWORD *)(v3 + 232);
              sub_8BB10((_DWORD *)v3, a2, (v300 << 32) | (unsigned int)v304);
              if ( v163 )
              {
                LODWORD(a2) = v302;
                v300 = v3 + 160;
                v168 = v302 + v163;
                do
                {
                  v169 = a2 + 1;
                  sub_8BE60((__int64)sb, a2, (const __m128i *)v300);
                  a2 = (unsigned int)(a2 + 1);
                }
                while ( v169 != v168 );
              }
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
            }
          }
          else if ( v85 == 77 )
          {
            if ( *(_BYTE *)v3 & 8 )
            {
              v86 = *(_DWORD *)(v3 + 412);
              if ( *(_DWORD *)(v3 + 516) <= v86 )
                v86 = *(_DWORD *)(v3 + 516);
              a2 = *(unsigned int *)(v3 + 232);
              v87 = *(_DWORD *)(v3 + 252);
              *(_DWORD *)(v3 + 516) = v86;
              if ( (signed int)a2 <= v87 )
              {
                if ( !v86 )
                  v86 = 1;
                sub_8ED60((const __m128i *)v3, a2, v87, v86, 1);
              }
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
            }
          }
          else if ( v85 == 80 && *(_BYTE *)v3 & 8 )
          {
            v184 = *(_DWORD *)(v3 + 416);
            if ( *(_DWORD *)(v3 + 516) <= v184 )
              v184 = *(_DWORD *)(v3 + 516);
            *(_DWORD *)(v3 + 516) = v184;
            a2 = -v184;
            if ( !v184 )
              a2 = 0xFFFFFFFFLL;
            sub_8F270((const __m128i *)v3, a2);
            v10 = *(_BYTE *)(v3 + 4377) == 0;
            *(_BYTE *)(v3 + 446) = 1;
            if ( v10 )
              sub_8E2A0(v3);
          }
          goto LABEL_26;
        }
        if ( v85 == 361 )
          goto LABEL_700;
        if ( v85 > 0x169 )
        {
          if ( v85 == 15684 )
          {
            v206 = *(_DWORD *)v3;
            if ( v206 & 0x1000 )
            {
              v207 = *(_DWORD *)(v3 + 516);
              *(_BYTE *)(v3 + 293) = 0;
              *(_BYTE *)(v3 + 292) = 1;
              *(_BYTE *)(v3 + 4392) = 0;
              v208 = *(_DWORD *)(v3 + 100);
              if ( v207 )
                v209 = v208 | 0x200000;
              else
                v209 = v208 & 0xFFDFFFFF;
              *(_DWORD *)(v3 + 100) = v209;
            }
            goto LABEL_26;
          }
          if ( v85 <= 0x3D44 )
          {
            if ( v85 == 9340 )
            {
              v223 = *(_DWORD *)v3;
              if ( v223 & 0x100 && *(_DWORD *)(v3 + 644) <= 1 )
              {
                if ( !*(_BYTE *)(v3 + 4564) )
                {
                  v224 = *(_DWORD *)(v3 + 516);
                  *(_BYTE *)(v3 + 8632) = 1;
                  if ( !v224 )
                    v224 = *(_DWORD *)(v3 + 4536);
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_DWORD *)(v3 + 8636) = v224;
                  *(_DWORD *)(v3 + 8640) = *(_DWORD *)(v3 + 412);
                  if ( v10 )
                    goto LABEL_723;
                }
                goto LABEL_562;
              }
            }
            else if ( v85 <= 0x247C )
            {
              if ( v85 == 364 )
                goto LABEL_822;
              if ( v85 == 8816 )
              {
                v162 = *(_DWORD *)(v3 + 516);
                switch ( v162 )
                {
                  case 0:
                    *(_DWORD *)v3 = 0xFFFF;
                    break;
                  case 40:
                    *(_DWORD *)v3 &= 0x1FFu;
                    break;
                  case 41:
                    *(_DWORD *)v3 = 0xFFFF;
                    break;
                  case 42:
                    *(_DWORD *)v3 = 4097;
                    break;
                  case 50:
                    v55 = __OFSUB__(*(_DWORD *)(v3 + 644), 1);
                    v10 = *(_DWORD *)(v3 + 644) == 1;
                    v46 = *(_DWORD *)(v3 + 644) - 1 < 0;
                    *(_DWORD *)(v3 + 2706) = 4152091;
                    sc = (char *)(v3 + 2706);
                    if ( !((unsigned __int8)(v46 ^ v55) | v10) )
                    {
                      v267 = 2LL;
                      while ( 1 )
                      {
                        v300 = v267;
                        __sprintf_chk(&v306, 1LL, 64LL, "%u", *(unsigned int *)(v3 + 4 * v267 + 512));
                        v268 = strlen(sc);
                        v269 = (_WORD *)__stpcpy_chk(&sc[v268], &v306, 1024LL);
                        if ( *(_DWORD *)(v3 + 644) <= (signed int)v300 )
                          break;
                        v267 = v300 + 1;
                        *v269 = 59;
                      }
                    }
                    a2 = (unsigned __int64)"c";
                    __strcat_chk(sc, "c", 1024LL);
                    break;
                  case 61:
                    *(_DWORD *)v3 = *(_DWORD *)v3 & 0xFFFFFE00 | 0xF;
                    break;
                  case 62:
                    *(_DWORD *)v3 = *(_DWORD *)v3 & 0xFFFFFE00 | 0x1F;
                    break;
                  default:
                    if ( (unsigned int)(v162 - 61) <= 8 )
                      *(_DWORD *)v3 |= 0x1FFu;
                    break;
                }
              }
            }
            else if ( v85 == 10876 )
            {
              if ( *(_BYTE *)v3 & 0x40 )
              {
                if ( *(_DWORD *)(v3 + 644) == 1 )
                {
                  v147 = *(_DWORD *)(v3 + 516);
                  if ( v147 )
                  {
                    if ( !*(_BYTE *)(v3 + 4564) )
                    {
                      v10 = *(_BYTE *)(v3 + 4377) == 0;
                      v148 = *(_DWORD *)(v3 + 416);
                      *(_BYTE *)(v3 + 8632) = 1;
                      *(_DWORD *)(v3 + 8640) = v147;
                      *(_DWORD *)(v3 + 8636) = v148;
                      if ( v10 )
                        goto LABEL_723;
                    }
                    goto LABEL_562;
                  }
                }
              }
            }
            else if ( v85 == 15683 )
            {
              v161 = *(_DWORD *)v3;
              if ( v161 & 0x1000 )
              {
                if ( *(_DWORD *)(v3 + 644) > 1 )
                  *(_BYTE *)(v3 + 288) = *(_DWORD *)(v3 + 516) <= *(_DWORD *)(v3 + 520);
              }
            }
          }
          else if ( v85 == 15687 )
          {
            v216 = *(_DWORD *)v3;
            if ( v216 & 0x1000 )
            {
              v217 = *(_DWORD *)(v3 + 516);
              if ( v217 <= 0xF )
              {
                v218 = _mm_loadu_si128((const __m128i *)(v3 + 128));
                v219 = byte_F5A60[v217 & 7];
                *(_BYTE *)(v3 + 112) = 0;
                *(__m128i *)(v3 + 160) = v218;
                *(_WORD *)(v3 + 113) = 0;
                *(_BYTE *)(v3 + 115) = 0;
                v220 = (v217 & 8 | v219) << 9;
                v221 = _mm_loadu_si128((const __m128i *)(v3 + 144));
                *(_DWORD *)(v3 + 100) = v220 | *(_DWORD *)(v3 + 100) & 0xFFFC01FF;
                v222 = *(_DWORD *)(v3 + 96);
                *(__m128i *)(v3 + 176) = v221;
                v10 = *(_BYTE *)(v3 + 290) == 0;
                *(_DWORD *)(v3 + 96) = v222 & 0xFFFC01FF | v220;
                if ( !v10 )
                  sub_8BA10(v3);
              }
            }
          }
          else if ( v85 <= 0x3D47 )
          {
            if ( v85 == 15685 )
            {
              v138 = *(_DWORD *)v3;
              if ( v138 & 0x1000 )
              {
                v139 = *(_DWORD *)(v3 + 516);
                *(_BYTE *)(v3 + 293) = v139 != 0;
                if ( v139 )
                {
                  sub_8E330(v3);
                }
                else
                {
                  *(_BYTE *)(v3 + 292) = 1;
                  *(_BYTE *)(v3 + 4392) = 0;
                }
              }
            }
            else if ( v85 == 15686 )
            {
              v173 = *(_DWORD *)v3;
              if ( v173 & 0x1000 )
              {
                v174 = *(_DWORD *)(v3 + 516);
                if ( v174 <= 0xF )
                {
                  v175 = _mm_loadu_si128((const __m128i *)(v3 + 128));
                  v176 = byte_F5A60[v174 & 7];
                  *(_BYTE *)(v3 + 108) = 0;
                  *(__m128i *)(v3 + 160) = v175;
                  *(_WORD *)(v3 + 109) = 0;
                  *(_BYTE *)(v3 + 111) = 0;
                  v177 = v174 & 8 | v176;
                  v178 = _mm_loadu_si128((const __m128i *)(v3 + 144));
                  *(_DWORD *)(v3 + 100) = v177 | *(_DWORD *)(v3 + 100) & 0xFFFFFE00;
                  v179 = *(_DWORD *)(v3 + 96);
                  *(__m128i *)(v3 + 176) = v178;
                  v10 = *(_BYTE *)(v3 + 290) == 0;
                  *(_DWORD *)(v3 + 96) = v177 | v179 & 0xFFFFFE00;
                  if ( !v10 )
                    sub_8BA10(v3);
                }
              }
            }
          }
          else
          {
            switch ( v85 )
            {
              case 0x3D63uLL:
                v212 = *(_DWORD *)v3;
                if ( v212 & 0x1000 )
                {
                  v213 = *(_DWORD *)(v3 + 516);
                  if ( v213 == 1 )
                  {
                    *(_BYTE *)(v3 + 447) = 0;
                    *(_BYTE *)(v3 + 288) = 1;
                  }
                  else if ( v213 < 1 )
                  {
                    *(_BYTE *)(v3 + 288) = 0;
                  }
                  else if ( v213 == 2 )
                  {
                    *(_BYTE *)(v3 + 447) = 1;
                    *(_BYTE *)(v3 + 288) = 1;
                  }
                }
                break;
              case 0x3E63uLL:
                v91 = *(_DWORD *)v3;
                if ( v91 & 0x4000 )
                {
                  v92 = *(_QWORD *)(v3 + 4328);
                  if ( v92 )
                  {
                    a2 = (unsigned __int64)"\x1B[>0;136;0c";
                    sub_2C0F0(v92, "\x1B[>0;136;0c", 0xBu, 0);
                  }
                }
                break;
              case 0x3D4CuLL:
                v180 = *(_DWORD *)v3;
                if ( v180 & 0x1000 )
                {
                  v181 = *(_DWORD *)(v3 + 516);
                  *(__m128i *)(v3 + 160) = _mm_loadu_si128((const __m128i *)(v3 + 128));
                  v182 = _mm_loadu_si128((const __m128i *)(v3 + 144));
                  *(_BYTE *)(v3 + 290) = v181 == 0;
                  *(__m128i *)(v3 + 176) = v182;
                  if ( !v181 )
                    sub_8BA10(v3);
                }
                break;
            }
          }
          goto LABEL_26;
        }
        if ( v85 == 110 )
        {
          v214 = *(_QWORD *)(v3 + 4328);
          if ( v214 )
          {
            v215 = *(_DWORD *)(v3 + 516);
            if ( v215 == 6 )
            {
              v257 = (unsigned int)(*(_DWORD *)(v3 + 236) + 1);
              __sprintf_chk(&v306, 1LL, 32LL, "\x1B[%d;%dR", (unsigned int)(*(_DWORD *)(v3 + 232) + 1));
              a2 = (unsigned __int64)&v306;
              sub_2C0F0(*(_QWORD *)(v3 + 4328), &v306, strlen(&v306), 0);
            }
            else if ( v215 == 5 )
            {
              a2 = (unsigned __int64)"\x1B[0n";
              sub_2C0F0(v214, "\x1B[0n", 4u, 0);
            }
          }
          goto LABEL_26;
        }
        if ( v85 <= 0x6E )
        {
          if ( v85 == 105 )
          {
LABEL_700:
            if ( *(_BYTE *)v3 & 2 && *(_DWORD *)(v3 + 644) == 1 )
            {
              if ( *(_DWORD *)(v3 + 516) == 5
                && (a2 = 138LL, v259 = (char *)sub_1F170(*(__int64 **)(v3 + 4368), 138), *v259) )
              {
                v10 = *(_DWORD *)(v3 + 648) == 0;
                *(_BYTE *)(v3 + 320) = 1;
                *(_DWORD *)(v3 + 324) = 0;
                *(_BYTE *)(v3 + 321) = v10;
                sub_BCCA0(v3 + 328);
                *(_QWORD *)(v3 + 368) = sub_B8140(v259);
              }
              else if ( *(_DWORD *)(v3 + 516) == 4 && *(_BYTE *)(v3 + 320) )
              {
                sub_8E3B0(v3);
              }
            }
            goto LABEL_26;
          }
          if ( v85 > 0x69 )
          {
            if ( v85 != 108 )
            {
              if ( v85 == 109 )
              {
                v195 = *(_DWORD *)(v3 + 644);
                v196 = 0;
                for ( a2 = v3 + 516; v196 < v195; ++v196 )
                {
                  v197 = v3 + 4LL * v196;
                  v198 = *(_DWORD *)(v197 + 516);
                  switch ( v198 )
                  {
                    case 0:
                      *(_DWORD *)(v3 + 100) = *(_DWORD *)(v3 + 96);
                      *(_QWORD *)(v3 + 108) = *(_QWORD *)(v3 + 144);
                      continue;
                    case 1:
                      if ( !(*(_BYTE *)v3 & 4) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) |= 0x40000u;
                      continue;
                    case 2:
                      v265 = *(_DWORD *)v3;
                      if ( !(v265 & 0x4000) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) |= 0x1000000u;
                      continue;
                    case 4:
                      v260 = *(_DWORD *)v3;
                      goto LABEL_856;
                    case 5:
                      if ( !(*(_BYTE *)v3 & 4) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) |= 0x200000u;
                      continue;
                    case 6:
                      v264 = *(_DWORD *)v3;
                      if ( !(v264 & 0x1000) )
                        goto LABEL_847;
                      *(_BYTE *)(v3 + 293) = 0;
                      *(_DWORD *)(v3 + 100) |= 0x200000u;
                      *(_BYTE *)(v3 + 292) = 1;
                      *(_BYTE *)(v3 + 4392) = 0;
                      continue;
                    case 7:
                      *(_DWORD *)(v3 + 100) |= 0x100000u;
                      continue;
                    case 9:
                      *(_DWORD *)(v3 + 100) |= 0x2000000u;
                      continue;
                    case 10:
                      v263 = *(_DWORD *)v3;
                      if ( !(v263 & 0x1000) )
                        goto LABEL_847;
                      if ( !*(_BYTE *)(v3 + 4563) )
                        *(_DWORD *)(v3 + 296) = 0;
                      continue;
                    case 11:
                      v262 = *(_DWORD *)v3;
                      if ( !(v262 & 0x1000) )
                        goto LABEL_847;
                      if ( !*(_BYTE *)(v3 + 4563) )
                        *(_DWORD *)(v3 + 296) = 1;
                      continue;
                    case 12:
                      v261 = *(_DWORD *)v3;
                      if ( !(v261 & 0x1000) )
                        goto LABEL_847;
                      if ( !*(_BYTE *)(v3 + 4563) )
                        *(_DWORD *)(v3 + 296) = 2;
                      continue;
                    case 21:
                      v260 = *(_DWORD *)v3;
                      if ( !(v260 & 0x4000) )
                        goto LABEL_847;
LABEL_856:
                      if ( !(v260 & 4) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) |= 0x80000u;
                      continue;
                    case 22:
                      if ( !(*(_DWORD *)v3 & 0x4010) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) &= 0xFEFBFFFF;
                      continue;
                    case 24:
                      if ( !(*(_DWORD *)v3 & 0x4010) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) &= 0xFFF7FFFF;
                      continue;
                    case 25:
                      if ( !(*(_DWORD *)v3 & 0x4010) )
                        goto LABEL_847;
                      *(_DWORD *)(v3 + 100) &= 0xFFDFFFFF;
                      break;
                    case 27:
                      if ( *(_DWORD *)v3 & 0x4010 )
                        *(_DWORD *)(v3 + 100) &= 0xFFEFFFFF;
                      else
LABEL_847:
                        *(_DWORD *)(v3 + 3744) = 0;
                      break;
                    case 29:
                      *(_DWORD *)(v3 + 100) &= 0xFDFFFFFF;
                      break;
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                      v279 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 108) = 0;
                      *(_DWORD *)(v3 + 100) = v279 & 0xFFFFFE00 | (v198 - 30);
                      break;
                    case 38:
                      if ( v196 + 2 < v195 && *(_DWORD *)(v197 + 520) == 5 )
                      {
                        v199 = *(unsigned __int8 *)(v197 + 524);
                        v200 = *(_DWORD *)(v3 + 100);
                        v196 += 2;
                        *(_BYTE *)(v3 + 108) = 0;
                        *(_WORD *)(v3 + 109) = 0;
                        *(_BYTE *)(v3 + 111) = 0;
                        *(_DWORD *)(v3 + 100) = v199 | v200 & 0xFFFFFE00;
                      }
                      if ( v196 + 4 < v195 && *(_DWORD *)(v3 + 4LL * (v196 + 1) + 516) == 2 )
                      {
                        *(_BYTE *)(v3 + 108) = 1;
                        v201 = *(_DWORD *)(a2 + 4LL * v196 + 8);
                        if ( v201 > 0xFF )
                          LOBYTE(v201) = 0;
                        *(_BYTE *)(v3 + 109) = v201;
                        v202 = *(_DWORD *)(a2 + 4LL * v196 + 12);
                        if ( v202 > 0xFF )
                          LOBYTE(v202) = 0;
                        *(_BYTE *)(v3 + 110) = v202;
                        v203 = *(_DWORD *)(a2 + 4LL * v196 + 16);
                        if ( v203 > 0xFF )
                          LOBYTE(v203) = 0;
                        *(_BYTE *)(v3 + 111) = v203;
                        v196 += 4;
                      }
                      break;
                    case 39:
                      v278 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 108) = 0;
                      v278 &= 0xFFFFFE00;
                      BYTE1(v278) |= 1u;
                      *(_DWORD *)(v3 + 100) = v278;
                      break;
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                      v277 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 112) = 0;
                      *(_DWORD *)(v3 + 100) = v277 & 0xFFFC01FF | ((v198 - 40) << 9);
                      break;
                    case 48:
                      if ( v196 + 2 < v195 && *(_DWORD *)(v197 + 520) == 5 )
                      {
                        v272 = *(_DWORD *)(v197 + 524);
                        v273 = *(_DWORD *)(v3 + 100);
                        v196 += 2;
                        *(_BYTE *)(v3 + 112) = 0;
                        *(_WORD *)(v3 + 113) = 0;
                        *(_BYTE *)(v3 + 115) = 0;
                        *(_DWORD *)(v3 + 100) = v273 & 0xFFFC01FF | (v272 << 9) & 0x1FE00;
                      }
                      if ( v196 + 4 < v195 && *(_DWORD *)(v3 + 4LL * (v196 + 1) + 516) == 2 )
                      {
                        *(_BYTE *)(v3 + 112) = 1;
                        v274 = *(_DWORD *)(a2 + 4LL * v196 + 8);
                        if ( v274 > 0xFF )
                          LOBYTE(v274) = 0;
                        *(_BYTE *)(v3 + 113) = v274;
                        v275 = *(_DWORD *)(a2 + 4LL * v196 + 12);
                        if ( v275 > 0xFF )
                          LOBYTE(v275) = 0;
                        *(_BYTE *)(v3 + 114) = v275;
                        v276 = *(_DWORD *)(a2 + 4LL * v196 + 16);
                        if ( v276 > 0xFF )
                          LOBYTE(v276) = 0;
                        *(_BYTE *)(v3 + 115) = v276;
                        v196 += 4;
                      }
                      break;
                    case 49:
                      v271 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 112) = 0;
                      *(_DWORD *)(v3 + 100) = v271 & 0xFFFC01FF | 0x20400;
                      break;
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                      v270 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 108) = 0;
                      *(_DWORD *)(v3 + 100) = v270 & 0xFFFFFE00 | (v198 - 82);
                      break;
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                      v258 = *(_DWORD *)(v3 + 100);
                      *(_BYTE *)(v3 + 112) = 0;
                      *(_DWORD *)(v3 + 100) = v258 & 0xFFFC01FF | ((v198 - 92) << 9);
                      break;
                    default:
                      continue;
                  }
                }
                v10 = *(_BYTE *)(v3 + 290) == 0;
                *(__m128i *)(v3 + 160) = _mm_loadu_si128((const __m128i *)(v3 + 128));
                *(__m128i *)(v3 + 176) = _mm_loadu_si128((const __m128i *)(v3 + 144));
                if ( !v10 )
                  sub_8BA10(v3);
              }
              goto LABEL_26;
            }
LABEL_822:
            if ( *(_BYTE *)v3 & 2 && *(_DWORD *)(v3 + 644) > 0 )
            {
              v255 = 1LL;
              while ( 1 )
              {
                a2 = *(unsigned int *)(v3 + 4 * v255 + 512);
                sub_923F0(v3, a2, v76, 0);
                v256 = v255++;
                if ( *(_DWORD *)(v3 + 644) <= v256 )
                  break;
                v76 = *(_DWORD *)(v3 + 648);
              }
            }
            goto LABEL_26;
          }
          if ( v85 == 103 )
          {
            if ( *(_BYTE *)v3 & 2 && *(_DWORD *)(v3 + 644) == 1 )
            {
              v149 = *(_DWORD *)(v3 + 516);
              if ( v149 )
              {
                if ( v149 == 3 )
                {
                  for ( i = 0LL; *(_DWORD *)(v3 + 416) > (signed int)i; ++i )
                    *(_BYTE *)(*(_QWORD *)(v3 + 3736) + i) = 0;
                }
              }
              else
              {
                *(_BYTE *)(*(_QWORD *)(v3 + 3736) + *(signed int *)(v3 + 236)) = 0;
              }
            }
            goto LABEL_26;
          }
          if ( v85 == 104 )
            goto LABEL_750;
          goto LABEL_26;
        }
        if ( v85 != 116 )
        {
          if ( v85 <= 0x74 )
          {
            if ( v85 == 114 )
            {
              if ( *(_BYTE *)v3 & 2 )
              {
                v150 = *(_DWORD *)(v3 + 644);
                if ( v150 <= 2 )
                {
                  v151 = *(_DWORD *)(v3 + 412);
                  a2 = *(unsigned int *)(v3 + 412);
                  if ( *(_DWORD *)(v3 + 516) <= v151 )
                    a2 = *(unsigned int *)(v3 + 516);
                  v152 = *(_DWORD *)(v3 + 412);
                  if ( *(_DWORD *)(v3 + 520) <= v151 )
                    v152 = *(_DWORD *)(v3 + 520);
                  v153 = 0;
                  *(_DWORD *)(v3 + 516) = a2;
                  *(_DWORD *)(v3 + 520) = v152;
                  if ( (_DWORD)a2 )
                    v153 = a2 - 1;
                  if ( v152 && v150 == 2 )
                    v154 = v152 - 1;
                  else
                    v154 = v151 - 1;
                  if ( (signed int)v151 <= v154 )
                    v154 = v151 - 1;
                  if ( v154 - v153 > 0 )
                  {
                    v10 = *(_BYTE *)(v3 + 256) == 0;
                    *(_DWORD *)(v3 + 252) = v154;
                    *(_DWORD *)(v3 + 248) = v153;
                    *(_DWORD *)(v3 + 236) = 0;
                    *(_BYTE *)(v3 + 446) = 1;
                    if ( v10 )
                      v153 = 0;
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_DWORD *)(v3 + 232) = v153;
                    if ( v10 )
                      sub_8E2A0(v3);
                  }
                }
              }
            }
            else if ( v85 == 115 )
            {
              v188 = *(_BYTE *)(v3 + 305);
              *(_QWORD *)(v3 + 240) = *(_QWORD *)(v3 + 232);
              v189 = *(_DWORD *)(v3 + 100);
              *(_BYTE *)(v3 + 272) = v188;
              v190 = *(_BYTE *)(v3 + 258);
              *(_DWORD *)(v3 + 104) = v189;
              v191 = *(_QWORD *)(v3 + 108);
              *(_BYTE *)(v3 + 273) = v190;
              *(_QWORD *)(v3 + 116) = v191;
              v192 = *(signed int *)(v3 + 260);
              *(_DWORD *)(v3 + 264) = v192;
              *(_DWORD *)(v3 + 268) = *(_DWORD *)(v3 + 4 * v192 + 468);
              *(_DWORD *)(v3 + 300) = *(_DWORD *)(v3 + 296);
            }
            goto LABEL_26;
          }
          switch ( v85 )
          {
            case 0x78uLL:
              if ( *(_BYTE *)v3 & 2 )
              {
                v253 = *(_QWORD *)(v3 + 4328);
                if ( v253 )
                {
                  v254 = *(_DWORD *)(v3 + 516);
                  if ( v254 <= 1 )
                  {
                    qmemcpy(&v306, "\x1B[2;1;1;112;112;1;0x", 0x15uLL);
                    a2 = (unsigned __int64)&v306;
                    v307 += v254;
                    sub_2C0F0(v253, &v306, 0x14u, 0);
                  }
                }
              }
              goto LABEL_26;
            case 0x168uLL:
LABEL_750:
              if ( *(_BYTE *)v3 & 2 && *(_DWORD *)(v3 + 644) > 0 )
              {
                v225 = 1LL;
                while ( 1 )
                {
                  a2 = *(unsigned int *)(v3 + 4 * v225 + 512);
                  sub_923F0(v3, a2, v76, 1u);
                  v226 = v225++;
                  if ( *(_DWORD *)(v3 + 644) <= v226 )
                    break;
                  v76 = *(_DWORD *)(v3 + 648);
                }
              }
              goto LABEL_26;
            case 0x75uLL:
              sub_8BA30(v3);
              v10 = *(_BYTE *)(v3 + 4377) == 0;
              *(_BYTE *)(v3 + 446) = 1;
              if ( v10 )
                sub_8E2A0(v3);
              break;
          }
          goto LABEL_26;
        }
        v144 = *(_DWORD *)(v3 + 644);
        a2 = *(unsigned int *)(v3 + 516);
        v145 = a2 - 1;
        if ( v144 > 1 )
        {
          if ( v145 <= 0x16 )
            goto LABEL_552;
          goto LABEL_26;
        }
        if ( v145 <= 0x16 )
        {
          if ( v144 == 1 )
          {
LABEL_552:
            v146 = *(_DWORD *)v3;
            if ( v146 & 0x4000 )
            {
              switch ( (_DWORD)a2 )
              {
                case 1:
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 8646) = 1;
                  *(_BYTE *)(v3 + 8647) = 0;
                  if ( v10 )
                    goto LABEL_931;
                  break;
                case 2:
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 8646) = 1;
                  *(_BYTE *)(v3 + 8647) = 1;
                  if ( v10 )
                    goto LABEL_931;
                  break;
                case 3:
                  if ( v144 > 2 && !*(_BYTE *)(v3 + 4564) )
                  {
                    v295 = *(_DWORD *)(v3 + 520);
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_BYTE *)(v3 + 8620) = 1;
                    *(_DWORD *)(v3 + 8624) = v295;
                    *(_DWORD *)(v3 + 8628) = *(_DWORD *)(v3 + 524);
                    if ( v10 )
                      goto LABEL_931;
                  }
                  break;
                case 5:
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 8644) = 1;
                  *(_BYTE *)(v3 + 8645) = 1;
                  if ( v10 )
                    goto LABEL_931;
                  break;
                case 6:
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 8644) = 1;
                  *(_BYTE *)(v3 + 8645) = 0;
                  if ( v10 )
                    goto LABEL_931;
                  break;
                case 7:
                  v10 = *(_BYTE *)(v3 + 4377) == 0;
                  *(_BYTE *)(v3 + 8654) = 1;
                  if ( v10 )
                    goto LABEL_931;
                  break;
                case 8:
                  if ( v144 > 2 && !*(_BYTE *)(v3 + 4564) )
                  {
                    v290 = *(_DWORD *)(v3 + 524);
                    *(_BYTE *)(v3 + 8632) = 1;
                    if ( !v290 )
                      v290 = *(_DWORD *)(v3 + 4536);
                    *(_DWORD *)(v3 + 8636) = v290;
                    v291 = *(_DWORD *)(v3 + 520);
                    if ( !v291 )
                      v291 = *(_DWORD *)(v3 + 4532);
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_DWORD *)(v3 + 8640) = v291;
                    if ( v10 )
                      goto LABEL_931;
                  }
                  break;
                case 9:
                  if ( v144 != 1 )
                  {
                    v10 = *(_DWORD *)(v3 + 520) == 0;
                    *(_BYTE *)(v3 + 8648) = 1;
                    *(_BYTE *)(v3 + 8649) = !v10;
                    if ( !*(_BYTE *)(v3 + 4377) )
LABEL_931:
                      sub_8E2A0(v3);
                  }
                  break;
                case 0xB:
                  v289 = *(_QWORD *)(v3 + 4328);
                  if ( v289 )
                  {
                    a2 = (unsigned __int64)"\x1B[1t";
                    if ( *(_BYTE *)(v3 + 4672) )
                      a2 = (unsigned __int64)"\x1B[2t";
                    sub_2C0F0(v289, (const char *)a2, 4u, 0);
                  }
                  break;
                case 0xD:
                  if ( *(_QWORD *)(v3 + 4328) )
                  {
                    v287 = *(unsigned int *)(v3 + 8608);
                    v288 = __sprintf_chk(&v306, 1LL, 80LL, "\x1B[3;%u;%ut", *(unsigned int *)(v3 + 8604));
                    a2 = (unsigned __int64)&v306;
                    sub_2C0F0(*(_QWORD *)(v3 + 4328), &v306, v288, 0);
                  }
                  break;
                case 0xE:
                  if ( *(_QWORD *)(v3 + 4328) )
                  {
                    v285 = *(unsigned int *)(v3 + 8612);
                    v286 = __sprintf_chk(&v306, 1LL, 80LL, "\x1B[4;%u;%ut", *(unsigned int *)(v3 + 8616));
                    a2 = (unsigned __int64)&v306;
                    sub_2C0F0(*(_QWORD *)(v3 + 4328), &v306, v286, 0);
                  }
                  break;
                case 0x12:
                  if ( *(_QWORD *)(v3 + 4328) )
                  {
                    v283 = *(unsigned int *)(v3 + 416);
                    v284 = __sprintf_chk(&v306, 1LL, 80LL, "\x1B[8;%d;%dt", *(unsigned int *)(v3 + 412));
                    a2 = (unsigned __int64)&v306;
                    sub_2C0F0(*(_QWORD *)(v3 + 4328), &v306, v284, 0);
                  }
                  break;
                case 0x14:
                  if ( *(_QWORD *)(v3 + 4328) )
                  {
                    v292 = *(_DWORD *)(v3 + 4572);
                    if ( v292 )
                    {
                      v293 = &locale;
                      if ( v292 == 2 )
                        v293 = *(const char **)(v3 + 4664);
                      v294 = strlen(v293) + 1;
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), "\x1B]L", 3u, 0);
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), v293, v294 - 1, 0);
                      a2 = (unsigned __int64)"\x1B\\";
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), "\x1B\\", 2u, 0);
                    }
                  }
                  break;
                case 0x15:
                  if ( *(_QWORD *)(v3 + 4328) )
                  {
                    v280 = *(_DWORD *)(v3 + 4572);
                    if ( v280 )
                    {
                      v281 = &locale;
                      if ( v280 == 2 )
                        v281 = *(const char **)(v3 + 4656);
                      v282 = strlen(v281) + 1;
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), "\x1B]l", 3u, 0);
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), v281, v282 - 1, 0);
                      a2 = (unsigned __int64)"\x1B\\";
                      sub_2C0F0(*(_QWORD *)(v3 + 4328), "\x1B\\", 2u, 0);
                    }
                  }
                  break;
                default:
                  goto LABEL_26;
              }
            }
            goto LABEL_26;
          }
          goto LABEL_26;
        }
        v210 = *(_DWORD *)v3;
        if ( !(v210 & 0x100) )
          goto LABEL_26;
        if ( !*(_BYTE *)(v3 + 4564) )
        {
          v211 = *(_DWORD *)(v3 + 416);
          *(_BYTE *)(v3 + 8632) = 1;
          *(_DWORD *)(v3 + 8636) = v211;
          if ( !(_DWORD)a2 )
            a2 = 24LL;
          v10 = *(_BYTE *)(v3 + 4377) == 0;
          *(_DWORD *)(v3 + 8640) = a2;
          if ( v10 )
LABEL_723:
            sub_8E2A0(v3);
        }
LABEL_562:
        *(_DWORD *)(v3 + 3748) = 0;
        *(_QWORD *)(v3 + 3760) = 0LL;
        *(_QWORD *)(v3 + 3768) = 0LL;
        break;
      case 3u:
LABEL_170:
        *(_BYTE *)(v3 + 2705) = 0;
        switch ( v12 )
        {
          case 0x30uLL:
          case 0x31uLL:
          case 0x32uLL:
          case 0x33uLL:
          case 0x34uLL:
          case 0x35uLL:
          case 0x36uLL:
          case 0x37uLL:
          case 0x38uLL:
          case 0x39uLL:
            v81 = v3 + 4LL * *(signed int *)(v3 + 644);
            v82 = *(_DWORD *)(v81 + 512);
            if ( v82 > 0x19999999 || (a2 = 10 * v82, a2 > 4294967247u - v12) )
              *(_DWORD *)(v81 + 512) = -1;
            else
              *(_DWORD *)(v81 + 512) = a2 + v12 - 48;
            goto LABEL_26;
          case 0x50uLL:
            *(_DWORD *)(v3 + 3744) = 6;
            *(_DWORD *)(v3 + 652) = 0;
            goto LABEL_26;
          case 0x52uLL:
            a2 = 0LL;
            sub_92BA0(v3, 0);
            sub_90EF0(v3);
            *(_DWORD *)(v3 + 3744) = 0;
            goto LABEL_26;
          case 0x57uLL:
            *(_DWORD *)(v3 + 3744) = 4;
            *(_BYTE *)(v3 + 2705) = 1;
            goto LABEL_26;
          default:
            if ( v12 == 76 )
            {
              if ( *(_DWORD *)(v3 + 516) != 2 )
                goto LABEL_285;
              *(_DWORD *)(v3 + 516) = 1;
            }
            else
            {
              if ( v12 != 59 || *(_DWORD *)(v3 + 644) != 1 || *(_DWORD *)(v3 + 516) != 4 )
              {
LABEL_285:
                *(_DWORD *)(v3 + 3744) = 7;
                *(_DWORD *)(v3 + 652) = 0;
                goto LABEL_26;
              }
              *(_DWORD *)(v3 + 644) = 2;
              *(_DWORD *)(v3 + 520) = 0;
            }
            break;
        }
        goto LABEL_26;
      case 4u:
LABEL_179:
        if ( v12 - 48 > 9 )
        {
          *(_DWORD *)(v3 + 3744) = 7;
          *(_DWORD *)(v3 + 652) = 0;
        }
        else
        {
          v71 = *(_DWORD *)(v3 + 516);
          if ( v71 > 0x19999999 || (v72 = 10 * v71, v72 > 4294967247u - v12) )
            *(_DWORD *)(v3 + 516) = -1;
          else
            *(_DWORD *)(v3 + 516) = v72 + v12 - 48;
        }
        goto LABEL_26;
      case 6u:
LABEL_161:
        v63 = *(signed int *)(v3 + 652);
        v64 = v12 - 48;
        if ( (unsigned int)(v12 - 48) <= 9 )
          goto LABEL_166;
        if ( (signed int)v12 <= 64 )
          goto LABEL_242;
        if ( (signed int)v12 <= ((unsigned int)v63 < 1 ? 76 : 70) )
        {
          v64 = v12 - 55;
        }
        else if ( (signed int)v12 <= 96 || (v64 = v12 - 87, (signed int)v12 > ((unsigned int)v63 < 1 ? 108 : 102)) )
        {
LABEL_242:
          *(_DWORD *)(v3 + 3744) = 0;
          goto LABEL_26;
        }
LABEL_166:
        *(_DWORD *)(v3 + 652) = v63 + 1;
        *(_BYTE *)(v3 + v63 + 656) = v64;
        if ( (signed int)v63 + 1 > 6 )
        {
          v65 = (unsigned int)*(char *)(v3 + 656);
          if ( (unsigned int)v65 > 0x15 )
            __assert_fail("oscp_index < OSCP_NCOLOURS", "terminal.c", 0x1435u, "term_out");
          v66 = dword_F5940[v65];
          v67 = (_BYTE *)(v3 + 3 * v66);
          v67[6769] = *(_BYTE *)(v3 + 658) + 16 * *(_BYTE *)(v3 + 657);
          v67[6770] = *(_BYTE *)(v3 + 660) + 16 * *(_BYTE *)(v3 + 659);
          v67[6771] = *(_BYTE *)(v3 + 662) + 16 * *(_BYTE *)(v3 + 661);
          *(_BYTE *)(v3 + v66 + 7555) = 1;
          sub_92A60(v3);
          *(_DWORD *)(v3 + 3744) = 0;
        }
        goto LABEL_26;
      case 7u:
LABEL_153:
        switch ( v12 )
        {
          case 0xAuLL:
          case 0xDuLL:
            *(_DWORD *)(v3 + 3744) = 0;
            break;
          case 0x9CuLL:
          case 7uLL:
            sub_8EB60(v3);
            *(_DWORD *)(v3 + 3744) = 0;
            break;
          case 0x1BuLL:
            *(_DWORD *)(v3 + 3744) = 8;
            break;
          default:
            v62 = *(signed int *)(v3 + 652);
            if ( (signed int)v62 <= 2047 )
            {
              *(_DWORD *)(v3 + 652) = v62 + 1;
              *(_BYTE *)(v3 + v62 + 656) = v12;
            }
            break;
        }
        goto LABEL_26;
      case 8u:
        if ( v12 == 92 )
        {
          sub_8EB60(v3);
          *(_DWORD *)(v3 + 3744) = 0;
          goto LABEL_26;
        }
LABEL_114:
        v48 = *(_DWORD *)(v3 + 648);
        if ( v12 - 32 > 0xF )
        {
LABEL_197:
          *(_DWORD *)(v3 + 3744) = 0;
          v74 = (v48 << 8) + v12;
          if ( v74 <= 0x2336 )
          {
            if ( v74 >= 0x2333 )
            {
              if ( *(_BYTE *)v3 & 2 )
              {
                sa = 1;
                if ( v74 != 9014 )
                  sa = word_F5578[2 * (v74 - 9011)];
                a2 = *(unsigned int *)(v3 + 232);
                v128 = sub_8C080((const __m128i *)v3, a2, 4065LL, 1);
                v129 = *(_DWORD *)(v3 + 416);
                v130 = v128;
                if ( v129 != *(_DWORD *)(v128 + 4) )
                {
                  a2 = v128;
                  sub_8BED0((const __m128i *)v3, v128, v129);
                }
                if ( *(_BYTE *)(v130 + 32) != *(_BYTE *)(v3 + 4480) )
                {
                  a2 = v130;
                  sub_8C1C0((const __m128i *)v3, (_WORD *)v130);
                  *(_BYTE *)(v130 + 32) = *(_BYTE *)(v3 + 4480);
                }
                *(_WORD *)v130 = sa;
              }
            }
            else if ( v74 == 69 )
            {
              if ( *(_BYTE *)v3 & 2 )
              {
                v131 = *(_DWORD *)(v3 + 232);
                v10 = v131 == *(_DWORD *)(v3 + 252);
                *(_DWORD *)(v3 + 236) = 0;
                if ( v10 )
                {
                  a2 = *(unsigned int *)(v3 + 248);
                  sub_8ED60((const __m128i *)v3, a2, v131, 1, 1);
                }
                else if ( v131 < *(_DWORD *)(v3 + 412) - 1 )
                {
                  *(_DWORD *)(v3 + 232) = v131 + 1;
                }
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 258) = 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
            }
            else if ( v74 <= 0x45 )
            {
              if ( v74 == 61 )
              {
                if ( *(_BYTE *)v3 & 2 )
                  *(_BYTE *)(v3 + 441) = 1;
              }
              else if ( v74 <= 0x3D )
              {
                if ( v74 == 55 )
                {
                  if ( *(_BYTE *)v3 & 2 )
                  {
                    v118 = *(_BYTE *)(v3 + 305);
                    *(_QWORD *)(v3 + 240) = *(_QWORD *)(v3 + 232);
                    v119 = *(_DWORD *)(v3 + 100);
                    *(_BYTE *)(v3 + 272) = v118;
                    v120 = *(_BYTE *)(v3 + 258);
                    *(_DWORD *)(v3 + 104) = v119;
                    v121 = *(_QWORD *)(v3 + 108);
                    *(_BYTE *)(v3 + 273) = v120;
                    *(_QWORD *)(v3 + 116) = v121;
                    v122 = *(signed int *)(v3 + 260);
                    *(_DWORD *)(v3 + 264) = v122;
                    *(_DWORD *)(v3 + 268) = *(_DWORD *)(v3 + 4 * v122 + 468);
                    *(_DWORD *)(v3 + 300) = *(_DWORD *)(v3 + 296);
                  }
                }
                else if ( v74 == 56 )
                {
                  if ( *(_BYTE *)v3 & 2 )
                  {
                    sub_8BA30(v3);
                    v10 = *(_BYTE *)(v3 + 4377) == 0;
                    *(_BYTE *)(v3 + 446) = 1;
                    if ( v10 )
                      sub_8E2A0(v3);
                  }
                }
              }
              else if ( v74 == 62 )
              {
                if ( *(_BYTE *)v3 & 2 )
                  *(_BYTE *)(v3 + 441) = 0;
              }
              else if ( v74 == 68 && *(_BYTE *)v3 & 2 )
              {
                v88 = *(_DWORD *)(v3 + 232);
                if ( v88 == *(_DWORD *)(v3 + 252) )
                {
                  a2 = *(unsigned int *)(v3 + 248);
                  sub_8ED60((const __m128i *)v3, a2, v88, 1, 1);
                }
                else if ( v88 < *(_DWORD *)(v3 + 412) - 1 )
                {
                  *(_DWORD *)(v3 + 232) = v88 + 1;
                }
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 258) = 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
            }
            else if ( v74 == 90 )
            {
              if ( *(_BYTE *)v3 & 2 )
              {
                v99 = *(_QWORD *)(v3 + 4328);
                if ( v99 )
                {
                  v100 = strlen((const char *)(v3 + 2706));
                  a2 = v3 + 2706;
                  sub_2C0F0(v99, (const char *)(v3 + 2706), v100, 0);
                }
              }
            }
            else if ( v74 <= 0x5A )
            {
              if ( v74 == 72 )
              {
                if ( *(_BYTE *)v3 & 2 )
                  *(_BYTE *)(*(_QWORD *)(v3 + 3736) + *(signed int *)(v3 + 236)) = 1;
              }
              else if ( v74 == 77 && *(_BYTE *)v3 & 2 )
              {
                a2 = *(unsigned int *)(v3 + 232);
                if ( (_DWORD)a2 == *(_DWORD *)(v3 + 248) )
                {
                  sub_8ED60((const __m128i *)v3, a2, *(_DWORD *)(v3 + 252), -1, 1);
                }
                else if ( (signed int)a2 > 0 )
                {
                  a2 = (unsigned int)(a2 - 1);
                  *(_DWORD *)(v3 + 232) = a2;
                }
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 258) = 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
              }
            }
            else
            {
              switch ( v74 )
              {
                case 0x5DuLL:
                  v101 = *(_DWORD *)v3;
                  if ( v101 & 0x4000 )
                  {
                    *(_DWORD *)(v3 + 3744) = 3;
                    *(_DWORD *)(v3 + 516) = 0;
                    *(_DWORD *)(v3 + 644) = 1;
                  }
                  break;
                case 0x63uLL:
                  if ( *(_BYTE *)v3 & 2 )
                  {
                    a2 = 1LL;
                    sub_91F80(v3, 1);
                    v123 = *(_QWORD *)(v3 + 4328);
                    if ( v123 )
                      sub_2C080(v123);
                    v124 = *(_BYTE *)(v3 + 4377);
                    if ( *(_BYTE *)(v3 + 289) )
                    {
                      if ( !*(_BYTE *)(v3 + 4564) )
                      {
                        v125 = *(_DWORD *)(v3 + 412);
                        *(_BYTE *)(v3 + 8632) = 1;
                        *(_DWORD *)(v3 + 8636) = 80;
                        *(_DWORD *)(v3 + 8640) = v125;
                        if ( !v124 )
                        {
                          sub_8E2A0(v3);
                          v124 = *(_BYTE *)(v3 + 4377);
                        }
                      }
                      *(_BYTE *)(v3 + 289) = 0;
                    }
                    if ( *(_BYTE *)(v3 + 4577) )
                      *(_DWORD *)(v3 + 32) = 0;
                    *(_BYTE *)(v3 + 446) = 1;
                    if ( !v124 )
                      sub_8E2A0(v3);
                  }
                  break;
                case 0x5BuLL:
                  *(_DWORD *)(v3 + 3744) = 2;
                  *(_DWORD *)(v3 + 516) = 0;
                  *(_QWORD *)(v3 + 644) = 1LL;
                  break;
              }
            }
            goto LABEL_26;
          }
          if ( v74 == 10305 )
          {
            if ( *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
              *(_DWORD *)(v3 + 468) = 56064;
          }
          else
          {
            if ( v74 > 0x2841 )
            {
              if ( v74 == 10544 )
              {
                if ( *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
                  *(_DWORD *)(v3 + 472) = 55552;
              }
              else if ( v74 <= 0x2930 )
              {
                if ( v74 == 10306 )
                {
                  if ( *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
                    *(_DWORD *)(v3 + 468) = 55296;
                }
                else if ( v74 == 10325 )
                {
                  v116 = *(_DWORD *)v3;
                  if ( v116 & 0x4000 )
                  {
                    if ( !*(_BYTE *)(v3 + 4563) )
                      *(_DWORD *)(v3 + 468) = 55808;
                  }
                }
              }
              else if ( v74 == 10562 )
              {
                if ( *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
                  *(_DWORD *)(v3 + 472) = 55296;
              }
              else if ( v74 == 10581 )
              {
                v127 = *(_DWORD *)v3;
                if ( v127 & 0x4000 && !*(_BYTE *)(v3 + 4563) )
                  *(_DWORD *)(v3 + 472) = 55808;
              }
              else if ( v74 == 10561 && *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
              {
                *(_DWORD *)(v3 + 472) = 56064;
              }
              goto LABEL_26;
            }
            if ( v74 == 9536 )
            {
              v117 = *(_DWORD *)v3;
              if ( v117 & 0x4000 && !*(_BYTE *)(v3 + 4563) )
                *(_BYTE *)(v3 + 305) = 0;
            }
            else
            {
              if ( v74 > 0x2540 )
              {
                if ( v74 != 9543 )
                {
                  if ( v74 == 10288 && *(_BYTE *)v3 & 2 && !*(_BYTE *)(v3 + 4563) )
                    *(_DWORD *)(v3 + 468) = 55552;
                  goto LABEL_26;
                }
                goto LABEL_480;
              }
              if ( v74 != 9016 )
              {
                if ( v74 != 9528 )
                  goto LABEL_26;
LABEL_480:
                v126 = *(_DWORD *)v3;
                if ( v126 & 0x4000 && !*(_BYTE *)(v3 + 4563) )
                  *(_BYTE *)(v3 + 305) = 1;
                goto LABEL_26;
              }
              if ( *(_BYTE *)v3 & 2 )
              {
                if ( *(_DWORD *)(v3 + 412) > 0 )
                {
                  s = 0;
                  v300 = (signed __int64)v5;
                  v301 = v4;
                  v303 = v2;
                  do
                  {
                    v93 = sub_8C080((const __m128i *)v3, s, 4024LL, 1);
                    v94 = *(_DWORD *)(v3 + 416);
                    v95 = *(_DWORD *)(v93 + 4);
                    v96 = v93;
                    if ( v94 != v95 )
                    {
                      sub_8BED0((const __m128i *)v3, v93, v94);
                      v95 = *(_DWORD *)(v3 + 416);
                    }
                    v97 = 0LL;
                    v98 = 0;
                    if ( v95 > 0 )
                    {
                      do
                      {
                        sub_8BE60(v96, v98++, (const __m128i *)(v3 + 128));
                        *(_QWORD *)(*(_QWORD *)(v96 + 24) + v97) = 69LL;
                        v97 += 32LL;
                      }
                      while ( *(_DWORD *)(v3 + 416) > v98 );
                    }
                    v55 = __OFSUB__(*(_DWORD *)(v3 + 412), ++s);
                    v10 = *(_DWORD *)(v3 + 412) == s;
                    v46 = *(_DWORD *)(v3 + 412) - s < 0;
                    *(_WORD *)v96 = 0;
                  }
                  while ( !((unsigned __int8)(v46 ^ v55) | v10) );
                  v2 = v303;
                  v5 = (__m128i *)v300;
                  v4 = v301;
                }
                if ( *(_BYTE *)(v3 + 4577) )
                  *(_DWORD *)(v3 + 32) = 0;
                v10 = *(_BYTE *)(v3 + 4377) == 0;
                *(_BYTE *)(v3 + 446) = 1;
                if ( v10 )
                  sub_8E2A0(v3);
                a2 = 0LL;
                sub_8BB10((_DWORD *)v3, 0LL, *(unsigned int *)(v3 + 412));
              }
            }
          }
        }
        else
        {
          a2 = 0xFFFFFFFFLL;
          if ( v48 )
            LODWORD(v12) = -1;
          *(_DWORD *)(v3 + 648) = v12;
        }
        goto LABEL_26;
      case 9u:
LABEL_147:
        v10 = *(_BYTE *)(v3 + 4377) == 0;
        *(_DWORD *)(v3 + 3744) = 0;
        *(_BYTE *)(v3 + 446) = 1;
        if ( v10 )
          sub_8E2A0(v3);
        switch ( v305 )
        {
          case 60LL:
            v106 = *(_BYTE *)(v3 + 4527);
            *(_BYTE *)(v3 + 442) = 0;
            *(_BYTE *)(v3 + 293) = v106;
            if ( v106 )
            {
              sub_8E330(v3);
            }
            else
            {
              *(_BYTE *)(v3 + 292) = 1;
              *(_BYTE *)(v3 + 4392) = 0;
            }
            break;
          case 61LL:
            *(_BYTE *)(v3 + 441) = 1;
            break;
          case 62LL:
            *(_BYTE *)(v3 + 441) = 0;
            break;
          case 65LL:
            a2 = *(unsigned int *)(v3 + 236);
            sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232) - 1, 1);
            break;
          case 66LL:
            a2 = *(unsigned int *)(v3 + 236);
            sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232) + 1, 1);
            break;
          case 67LL:
            a2 = (unsigned int)(*(_DWORD *)(v3 + 236) + 1);
            sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232), 1);
            break;
          case 68LL:
            a2 = (unsigned int)(*(_DWORD *)(v3 + 236) - 1);
            sub_8A3A0(v3, a2, *(_DWORD *)(v3 + 232), 1);
            break;
          case 69LL:
            v108 = *(_DWORD *)(v3 + 416);
            v109 = *(_DWORD *)(v3 + 412);
            *(_BYTE *)(v3 + 258) = 0;
            v110 = v108 - 1;
            v10 = v108 == 0;
            v46 = v108 < 0;
            v111 = v109 - 1;
            if ( !v46 && !v10 )
              v110 = 0;
            if ( v109 > 0 )
              v111 = 0;
            *(_DWORD *)(v3 + 236) = v110;
            a2 = 0LL;
            *(_DWORD *)(v3 + 232) = v111;
            sub_90F70((__m128i *)v3, 0, 0, 1);
            if ( *(_BYTE *)(v3 + 4577) )
              *(_DWORD *)(v3 + 32) = 0;
            break;
          case 70LL:
            *(_DWORD *)(v3 + 260) = 0;
            *(_DWORD *)(v3 + 468) = 55552;
            break;
          case 71LL:
            *(_DWORD *)(v3 + 260) = 0;
            *(_DWORD *)(v3 + 468) = 55296;
            break;
          case 72LL:
            v112 = *(_DWORD *)(v3 + 416);
            a2 = *(unsigned int *)(v3 + 412);
            *(_BYTE *)(v3 + 258) = 0;
            v113 = v112 - 1;
            v10 = v112 == 0;
            v46 = v112 < 0;
            v114 = a2 - 1;
            if ( !v46 && !v10 )
              v113 = 0;
            if ( (signed int)a2 > 0 )
              v114 = 0;
            *(_DWORD *)(v3 + 236) = v113;
            *(_DWORD *)(v3 + 232) = v114;
            break;
          case 73LL:
            v115 = *(_DWORD *)(v3 + 232);
            if ( v115 )
            {
              if ( v115 > 0 )
                *(_DWORD *)(v3 + 232) = v115 - 1;
            }
            else
            {
              a2 = 0LL;
              sub_8ED60((const __m128i *)v3, 0, *(_DWORD *)(v3 + 412) - 1, -1, 1);
            }
            *(_BYTE *)(v3 + 258) = 0;
            break;
          case 74LL:
            a2 = 0LL;
            sub_90F70((__m128i *)v3, 0, 0, 1);
            if ( *(_BYTE *)(v3 + 4577) )
              *(_DWORD *)(v3 + 32) = 0;
            break;
          case 75LL:
            a2 = 1LL;
            sub_90F70((__m128i *)v3, 1, 0, 1);
            break;
          case 76LL:
            a2 = *(unsigned int *)(v3 + 232);
            v102 = *(_DWORD *)(v3 + 252);
            if ( (signed int)a2 <= v102 )
              sub_8ED60((const __m128i *)v3, a2, v102, -1, 0);
            break;
          case 77LL:
            a2 = *(unsigned int *)(v3 + 232);
            v103 = *(_DWORD *)(v3 + 252);
            if ( (signed int)a2 <= v103 )
              sub_8ED60((const __m128i *)v3, a2, v103, 1, 1);
            break;
          case 82LL:
            a2 = 0LL;
            v10 = *(_BYTE *)(v3 + 290) == 0;
            v104 = _mm_loadu_si128((const __m128i *)(v3 + 128));
            *(_BYTE *)(v3 + 304) = 0;
            *(_DWORD *)(v3 + 100) = 132352;
            *(__m128i *)(v3 + 160) = v104;
            *(_BYTE *)(v3 + 108) = 0;
            *(_WORD *)(v3 + 109) = 0;
            v105 = _mm_loadu_si128((const __m128i *)(v3 + 144));
            *(_BYTE *)(v3 + 111) = 0;
            *(_BYTE *)(v3 + 112) = 0;
            *(_WORD *)(v3 + 113) = 0;
            *(_BYTE *)(v3 + 115) = 0;
            *(__m128i *)(v3 + 176) = v105;
            if ( !v10 )
              sub_8BA10(v3);
            break;
          case 83LL:
            *(_DWORD *)(v3 + 100) |= 0x80000u;
            break;
          case 84LL:
            *(_BYTE *)(v3 + 304) = 0;
            *(_DWORD *)(v3 + 100) &= 0xFFFBFFFF;
            break;
          case 85LL:
            *(_BYTE *)(v3 + 304) = 1;
            *(_DWORD *)(v3 + 100) |= 0x40000u;
            break;
          case 87LL:
            *(_DWORD *)(v3 + 100) &= 0xFFF7FFFF;
            break;
          case 89LL:
            *(_DWORD *)(v3 + 3744) = 10;
            break;
          case 90LL:
            v107 = *(_QWORD *)(v3 + 4328);
            if ( v107 )
            {
              a2 = (unsigned __int64)"\x1B/Z";
              sub_2C0F0(v107, "\x1B/Z", 3u, 0);
            }
            break;
          case 98LL:
            *(_DWORD *)(v3 + 3744) = 12;
            break;
          case 99LL:
            *(_DWORD *)(v3 + 3744) = 13;
            break;
          case 100LL:
            a2 = 0LL;
            sub_90F70((__m128i *)v3, 0, 1, 0);
            if ( *(_BYTE *)(v3 + 4577) )
              *(_DWORD *)(v3 + 32) = 0;
            break;
          case 101LL:
            *(_BYTE *)(v3 + 288) = 1;
            break;
          case 102LL:
            *(_BYTE *)(v3 + 288) = 0;
            break;
          case 108LL:
            a2 = 1LL;
            sub_90F70((__m128i *)v3, 1, 1, 1);
            *(_DWORD *)(v3 + 236) = 0;
            *(_BYTE *)(v3 + 258) = 0;
            break;
          case 111LL:
            a2 = 1LL;
            sub_90F70((__m128i *)v3, 1, 1, 0);
            break;
          case 112LL:
            *(_DWORD *)(v3 + 100) |= 0x100000u;
            break;
          case 113LL:
            *(_DWORD *)(v3 + 100) &= 0xFFEFFFFF;
            break;
          case 118LL:
            *(_BYTE *)(v3 + 257) = 1;
            break;
          case 119LL:
            *(_BYTE *)(v3 + 257) = 0;
            break;
          default:
            goto LABEL_26;
        }
        goto LABEL_26;
      case 0xAu:
LABEL_137:
        v57 = *(_DWORD *)(v3 + 236);
        *(_DWORD *)(v3 + 3744) = 11;
        v58 = 0;
        *(_BYTE *)(v3 + 258) = 0;
        v46 = v57 < 0;
        v59 = *(_DWORD *)(v3 + 416);
        if ( !v46 )
          v58 = *(_DWORD *)(v3 + 236);
        a2 = (unsigned int)(v59 - 1);
        if ( v58 >= v59 )
          v58 = v59 - 1;
        v60 = v12 - 32;
        if ( v60 < 0 )
          v60 = 0;
        v61 = *(_DWORD *)(v3 + 412);
        *(_DWORD *)(v3 + 236) = v58;
        if ( v60 >= v61 )
          v60 = v61 - 1;
        *(_DWORD *)(v3 + 232) = v60;
        goto LABEL_26;
      case 0xBu:
LABEL_127:
        v51 = *(_DWORD *)(v3 + 416);
        v52 = 0;
        v53 = v12 - 32;
        v54 = *(_DWORD *)(v3 + 232);
        if ( v53 < 0 )
          v53 = 0;
        *(_DWORD *)(v3 + 3744) = 0;
        *(_BYTE *)(v3 + 258) = 0;
        v55 = __OFSUB__(v53, v51);
        v46 = v53 - v51 < 0;
        a2 = (unsigned int)(v51 - 1);
        v56 = *(_DWORD *)(v3 + 412);
        if ( !(v46 ^ v55) )
          v53 = a2;
        if ( v54 >= 0 )
          v52 = v54;
        *(_DWORD *)(v3 + 236) = v53;
        if ( v52 >= v56 )
          v52 = v56 - 1;
        *(_DWORD *)(v3 + 232) = v52;
        goto LABEL_26;
      case 0xCu:
LABEL_124:
        v50 = *(_DWORD *)(v3 + 100);
        *(_DWORD *)(v3 + 3744) = 0;
        v10 = *(_BYTE *)(v3 + 290) == 0;
        *(__m128i *)(v3 + 160) = _mm_loadu_si128((const __m128i *)(v3 + 128));
        *(_DWORD *)(v3 + 100) = v50 & 0xFFFBFE00 | v12 & 0xF;
        *(__m128i *)(v3 + 176) = _mm_loadu_si128((const __m128i *)(v3 + 144));
        if ( !v10 )
          sub_8BA10(v3);
        goto LABEL_26;
      case 0xDu:
LABEL_121:
        v49 = *(_DWORD *)(v3 + 100);
        *(_DWORD *)(v3 + 3744) = 0;
        v10 = *(_BYTE *)(v3 + 290) == 0;
        *(__m128i *)(v3 + 160) = _mm_loadu_si128((const __m128i *)(v3 + 128));
        *(_DWORD *)(v3 + 100) = v49 & 0xFFDC01FF | ((_WORD)v12 << 9) & 0x1E00;
        *(__m128i *)(v3 + 176) = _mm_loadu_si128((const __m128i *)(v3 + 144));
        if ( !v10 )
          sub_8BA10(v3);
        goto LABEL_26;
      default:
        goto LABEL_26;
    }
  }
  v6 = v3 + 192;
  if ( sub_BCD00(v3 + 192) )
  {
LABEL_5:
    v7 = (const __m128i *)sub_BCF00(v6);
    v4 = v8;
    if ( v8 <= 0x100 )
    {
      v5 = &v308;
      __memcpy_chk(&v308, v7, v8, 256LL);
      sub_BCE20(v6, v4);
      if ( !v4 )
        __assert_fail("nchars > 0", "terminal.c", 0xE2Cu, "term_out");
      goto LABEL_7;
    }
    v4 = 255LL;
    v5 = &v308;
    v308 = _mm_loadu_si128(v7);
    v309 = _mm_loadu_si128(v7 + 1);
    v310 = _mm_loadu_si128(v7 + 2);
    v311 = _mm_loadu_si128(v7 + 3);
    v312 = _mm_loadu_si128(v7 + 4);
    v313 = _mm_loadu_si128(v7 + 5);
    v314 = _mm_loadu_si128(v7 + 6);
    v315 = _mm_loadu_si128(v7 + 7);
    v316 = _mm_loadu_si128(v7 + 8);
    v317 = _mm_loadu_si128(v7 + 9);
    v318 = _mm_loadu_si128(v7 + 10);
    v319 = _mm_loadu_si128(v7 + 11);
    v320 = _mm_loadu_si128(v7 + 12);
    v321 = _mm_loadu_si128(v7 + 13);
    v322 = _mm_loadu_si128(v7 + 14);
    v323 = _mm_loadu_si128(v7 + 15);
    sub_BCE20(v6, 0x100uLL);
    goto LABEL_8;
  }
  sub_8AC60(v3);
  if ( *(_BYTE *)(v3 + 4549) )
  {
    v78 = *(_QWORD *)(v3 + 4344);
    if ( v78 )
      sub_2CA30(v78);
  }
  v80 = __readfsqword(0x28u);
  result = v80 ^ v324;
  if ( v80 != v324 )
    goto LABEL_838;
  return result;
}

void __fastcall sub_97850(__int64 a1, unsigned __int64 a2)
{
  bool v2; // zf

  v2 = *(_BYTE *)(a1 + 4377) == 0;
  *(_BYTE *)(a1 + 4376) = 1;
  *(_BYTE *)(a1 + 446) = 1;
  if ( v2 )
    sub_8E2A0(a1);
  v2 = *(_BYTE *)(a1 + 4526) == 0;
  *(_BYTE *)(a1 + 291) = 1;
  *(_BYTE *)(a1 + 4393) = 0;
  if ( !v2 && *(_BYTE *)(a1 + 424) )
    sub_8E370(a1);
  if ( *(_DWORD *)(a1 + 3748) != 2 )
    sub_93640(a1, a2);
  *(_BYTE *)(a1 + 4376) = 0;
}

void __fastcall sub_978C0(__int64 a1)
{
  int v1; // er8
  __int64 v2; // r12
  __int64 v3; // rbp
  int v4; // edx
  int v5; // ebx
  _DWORD *v6; // rax
  __int64 v7; // r13
  __int64 v8; // r14
  char *v9; // r15
  int v10; // eax
  __int64 v11; // rdi
  __int64 v12; // rdi

  v1 = *(_DWORD *)(a1 + 4312);
  if ( v1 )
  {
    v2 = a1 + 192;
    v3 = a1;
    v4 = *(_DWORD *)(a1 + 4316);
    while ( v1 > v4 )
    {
      v5 = 0;
      v6 = (_DWORD *)(*(_QWORD *)(v3 + 4304) + 4LL * v4);
      do
      {
        ++v5;
        if ( *v6 == 13 )
          break;
        ++v6;
      }
      while ( v5 != v1 - v4 );
      if ( *(_QWORD *)(v3 + 4328) )
      {
        v7 = sub_8AF20(v3, (signed int *)(*(_QWORD *)(v3 + 4304) + 4LL * v4), v5);
        v8 = *(_QWORD *)(v7 + 16);
        v9 = *(char **)v7;
        if ( *(_BYTE *)(v3 + 444) )
        {
          v10 = *(_QWORD *)(v7 + 16);
          if ( (signed int)v8 < 0 )
            v10 = strlen(v9);
          sub_BCD20(v2, v9, v10);
          if ( !*(_BYTE *)(v3 + 4376) )
            sub_97850(v3, (unsigned __int64)v9);
        }
        v11 = *(_QWORD *)(v3 + 4328);
        if ( v11 )
          sub_2C0F0(v11, v9, v8, 0);
        sub_901B0(v3);
        sub_BC660((void **)v7);
        v4 = *(_DWORD *)(v3 + 4316);
        v1 = *(_DWORD *)(v3 + 4312);
      }
      v4 += v5;
      *(_DWORD *)(v3 + 4316) = v4;
      if ( v4 < v1 )
      {
        sub_1BD80((__int64)sub_978C0, v3);
        return;
      }
    }
    if ( *(_BYTE *)(v3 + 465) )
    {
      v12 = *(_QWORD *)(v3 + 4328);
      if ( v12 )
        sub_2C0F0(v12, "\x1B[201~", 6u, 0);
      *(_BYTE *)(v3 + 465) = 0;
    }
    sub_2F4D0(*(void **)(v3 + 4304));
    *(_QWORD *)(v3 + 4304) = 0LL;
    *(_DWORD *)(v3 + 4312) = 0;
  }
}

__int64 __fastcall sub_97BB0(__int64 a1, int a2, int a3)
{
  int v3; // ebp
  __int64 result; // rax
  int v5; // edx
  bool v6; // zf

  v3 = a3;
  result = sub_8A550(a1);
  v5 = -(signed int)result;
  if ( a2 >= 0 )
  {
    if ( a2 )
      v3 -= result;
    else
      v3 += *(_DWORD *)(a1 + 32);
  }
  if ( v5 > v3 )
  {
    *(_DWORD *)(a1 + 32) = v5;
    v3 = -(signed int)result;
  }
  else
  {
    *(_DWORD *)(a1 + 32) = v3;
  }
  if ( v3 > 0 )
    *(_DWORD *)(a1 + 32) = 0;
  v6 = *(_BYTE *)(a1 + 4377) == 0;
  *(_BYTE *)(a1 + 8655) = 1;
  if ( v6 )
    result = (__int64)sub_8E2A0(a1);
  return result;
}

__int64 __fastcall sub_97C20(_DWORD *a1, int a2)
{
  __int64 result; // rax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // eax

  result = sub_8A550((__int64)a1);
  if ( a1[937] == 3 )
  {
    if ( a2 )
      v3 = a1[942];
    else
      v3 = a1[940];
    v4 = -(signed int)result;
    v5 = v3 - a1[103] / 2;
    if ( -(signed int)result <= v5 )
    {
      v6 = 0;
      if ( v5 <= 0 )
        v6 = v5;
      v4 = v6;
    }
    result = sub_97BB0((__int64)a1, -1, v4);
  }
  return result;
}

__int64 __fastcall sub_97D00(__int64 a1, unsigned int *a2, int a3)
{
  unsigned int *v3; // rbp
  __int64 v4; // rsi
  __int64 result; // rax
  signed __int64 v6; // rbp
  signed __int64 v7; // r12
  __int64 v8; // ST00_8

  if ( a3 > 0 )
  {
    v3 = a2;
    v4 = *a2;
    if ( (_DWORD)v4 == 1 )
LABEL_10:
      __assert_fail("clipboards[i] != CLIP_LOCAL", "terminal.c", 0x195Au, "term_request_copy");
    result = (unsigned int)(a3 - 1);
    v6 = (signed __int64)(v3 + 1);
    v7 = v6 + 4 * result;
    while ( 1 )
    {
      if ( (_DWORD)v4 )
      {
        (*(void (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 4336) + 88LL))(
          *(_QWORD *)(a1 + 4336),
          v4,
          *(_QWORD *)(a1 + 4584),
          *(_QWORD *)(a1 + 4592),
          *(_QWORD *)(a1 + 4600),
          *(unsigned int *)(a1 + 4608),
          0LL);
        result = v8;
      }
      if ( v6 == v7 )
        break;
      v6 += 4LL;
      v4 = *(unsigned int *)(v6 - 4);
      if ( (_DWORD)v4 == 1 )
        goto LABEL_10;
    }
  }
  return result;
}

_QWORD *__fastcall sub_97DA0(__int64 a1, int a2)
{
  _QWORD *result; // rax

  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1BD80((__int64)sub_980A0, a1);
    else
      result = (_QWORD *)(*(__int64 (**)(void))(**(_QWORD **)(a1 + 4336) + 96LL))();
  }
  return result;
}

__int64 __fastcall sub_97DE0(__int64 a1, const wchar_t *a2, int a3)
{
  const wchar_t *v3; // r15
  __int64 v4; // rbx
  __int64 v5; // r12
  __int64 result; // rax
  char v7; // bp
  void *v8; // rdi
  void *v9; // rax
  bool v10; // zf
  const wchar_t *v11; // r14
  signed int v12; // er12
  __int64 v13; // rax
  __int64 v14; // rdx
  int v15; // edx
  signed int *v16; // rsi
  __int64 v17; // rbp
  __int64 v18; // r12
  char *v19; // r13
  __int64 v20; // rdi
  signed int v21; // eax
  __int64 v22; // rdi
  __int64 v23; // rdi
  int v24; // eax

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = sub_1EF00(*(__int64 **)(a1 + 4368), 150);
  if ( (_DWORD)v5 )
  {
    v7 = result;
    sub_901B0(a1);
    v8 = *(void **)(a1 + 4304);
    if ( v8 )
      sub_2F4D0(v8);
    *(_QWORD *)(v4 + 4312) = 0LL;
    v9 = sub_2F450((signed int)v5 + 12, 4uLL, 0LL);
    v10 = *(_BYTE *)(v4 + 464) == 0;
    *(_QWORD *)(v4 + 4304) = v9;
    if ( !v10 )
    {
      v22 = *(_QWORD *)(v4 + 4328);
      if ( v22 )
        sub_2C0F0(v22, "\x1B[200~", 6u, 0);
      *(_BYTE *)(v4 + 465) = 1;
    }
    v11 = &a2[v5];
    if ( v11 > a2 )
    {
      do
      {
        v12 = *v3;
        if ( *v3 == 10 )
        {
          if ( !wcsncmp(v3, &dword_F5A58, 1uLL) )
            v12 = 13;
        }
        else if ( !(v12 & 0xFFFFFF60) )
        {
          if ( v7 )
          {
            if ( v12 == 27
              && *(_BYTE *)(v4 + 464)
              && (unsigned __int64)((char *)v11 - (char *)v3) > 0x17
              && !wcsncmp(v3, &dword_F5A68, 6uLL) )
            {
              goto LABEL_14;
            }
          }
          else
          {
            if ( v12 > 15 )
              goto LABEL_14;
            v21 = 9984;
            if ( !_bittest(&v21, v12) )
              goto LABEL_14;
          }
        }
        v13 = *(signed int *)(v4 + 4312);
        v14 = *(_QWORD *)(v4 + 4304);
        *(_DWORD *)(v4 + 4312) = v13 + 1;
        *(_DWORD *)(v14 + 4 * v13) = v12;
LABEL_14:
        ++v3;
      }
      while ( v11 > v3 );
    }
    v15 = *(_DWORD *)(v4 + 4312);
    if ( v15 <= 255 )
    {
      v16 = *(signed int **)(v4 + 4304);
      if ( *(_QWORD *)(v4 + 4328) )
      {
        v17 = sub_8AF20(v4, v16, v15);
        v18 = *(_QWORD *)(v17 + 16);
        v19 = *(char **)v17;
        if ( *(_BYTE *)(v4 + 444) )
        {
          v24 = *(_QWORD *)(v17 + 16);
          if ( (signed int)v18 < 0 )
            v24 = strlen(v19);
          sub_BCD20(v4 + 192, v19, v24);
          if ( !*(_BYTE *)(v4 + 4376) )
            sub_97850(v4, (unsigned __int64)v19);
        }
        v20 = *(_QWORD *)(v4 + 4328);
        if ( v20 )
          sub_2C0F0(v20, v19, v18, 0);
        sub_901B0(v4);
        sub_BC660((void **)v17);
        v16 = *(signed int **)(v4 + 4304);
      }
      if ( v16 )
        sub_2F4D0(v16);
      if ( *(_BYTE *)(v4 + 465) )
      {
        v23 = *(_QWORD *)(v4 + 4328);
        if ( v23 )
          sub_2C0F0(v23, "\x1B[201~", 6u, 0);
        *(_BYTE *)(v4 + 465) = 0;
      }
      *(_QWORD *)(v4 + 4304) = 0LL;
      *(_QWORD *)(v4 + 4312) = 0LL;
    }
    result = (__int64)sub_1BD80((__int64)sub_978C0, v4);
  }
  return result;
}

__int64 __fastcall sub_980A0(__int64 a1)
{
  return sub_97DE0(a1, *(const wchar_t **)(a1 + 4584), *(_DWORD *)(a1 + 4608));
}

unsigned __int64 __fastcall sub_980C0(const __m128i *a1, __int32 a2, int a3, int a4, int a5, int a6, char a7, char a8, char a9)
{
  const __m128i *v9; // r15
  int v10; // er14
  int v11; // er12
  int v12; // ebx
  __int32 v13; // er10
  int v14; // eax
  char v15; // dl
  unsigned int v16; // er13
  __int32 v17; // eax
  int v18; // ebp
  void **v19; // rcx
  __int64 v20; // rsi
  __int32 v21; // eax
  unsigned __int8 v22; // bl
  bool v23; // dl
  __int32 v25; // ecx
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rdx
  bool v28; // zf
  bool v29; // sf
  unsigned __int8 v30; // of
  int v31; // ecx
  int v32; // er8
  int v33; // eax
  int v34; // er8
  __int32 v35; // eax
  __int32 v36; // er9
  __int8 v37; // al
  __int64 v38; // r8
  const char *v39; // rcx
  unsigned int v40; // eax
  bool v41; // sf
  unsigned __int8 v42; // of
  __int32 v43; // edx
  __int64 v44; // rax
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // rax
  __int32 v47; // edi
  __int32 v48; // esi
  __int32 v49; // er9
  unsigned __int64 v50; // rdx
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rax
  int v53; // er11
  int v54; // [rsp+4h] [rbp-84h]
  void **v55; // [rsp+8h] [rbp-80h]
  __int32 v56; // [rsp+14h] [rbp-74h]
  char v57; // [rsp+20h] [rbp-68h]
  unsigned __int64 v58; // [rsp+48h] [rbp-40h]

  v9 = a1;
  v10 = a5;
  v11 = a4;
  v12 = a6;
  v13 = a1[28].m128i_i32[1];
  v56 = a2;
  v54 = a3;
  v58 = __readfsqword(0x28u);
  if ( v13 && !a1[285].m128i_i8[2] && (!a1[284].m128i_i8[12] || !a7) )
  {
    v15 = 1;
    if ( a6 < 0 )
      v12 = 0;
    v16 = 1;
    goto LABEL_58;
  }
  if ( a6 >= 0 )
  {
    v14 = a1[25].m128i_i32[3];
    if ( v14 > a6 )
    {
      v15 = 0;
      v16 = 0;
      goto LABEL_6;
    }
    v15 = 0;
    v16 = 0;
    v12 = v14 - 1;
    if ( a4 != 4 )
    {
      v17 = a1[26].m128i_i32[0];
      if ( a5 >= 0 )
        goto LABEL_7;
      goto LABEL_27;
    }
    goto LABEL_65;
  }
  if ( a4 != 4 )
  {
    v15 = 0;
    v16 = 0;
    v12 = 0;
LABEL_58:
    v35 = a1[25].m128i_i32[3];
    if ( v12 >= v35 )
      v12 = v35 - 1;
LABEL_6:
    v17 = a1[26].m128i_i32[0];
    if ( v10 >= 0 )
      goto LABEL_7;
LABEL_27:
    v10 = 0;
    if ( v12 > 0 && !v15 && a1[234].m128i_i32[2] != 1 )
    {
      v10 = v17 - 1;
      --v12;
    }
    goto LABEL_7;
  }
  sub_97BB0((__int64)a1, 0, -1);
  v36 = a1[25].m128i_i32[3];
  if ( v36 <= 0 )
  {
    v12 = v36 - 1;
LABEL_65:
    sub_97BB0((__int64)a1, 0, 1);
    v16 = 0;
    v15 = 0;
    goto LABEL_6;
  }
  v17 = a1[26].m128i_i32[0];
  if ( v10 < 0 )
    v10 = 0;
  v16 = 0;
  v12 = 0;
LABEL_7:
  if ( v10 >= v17 )
    v10 = v17 - 1;
  v18 = v12 + a1[2].m128i_i32[0];
  v19 = (void **)sub_8C080(a1, v18, 6927LL, 0);
  if ( *(_BYTE *)v19 & 3 )
    v10 /= 2;
  v20 = (__int64)v19;
  v55 = v19;
  if ( sub_8B0A0((__int64)a1, (__int64)v19, (unsigned int)v12) )
    v10 = *(_DWORD *)(*(_QWORD *)(a1[279].m128i_i64[0] + 32LL * v12 + 24) + 4LL * v10);
  if ( *((_BYTE *)v55 + 12) )
    sub_8C3C0(v55);
  v21 = a1[234].m128i_i32[1];
  if ( v16 )
  {
    if ( (unsigned int)(v21 - 1) <= 1 )
    {
      v22 = a1[285].m128i_i8[9] ^ a9;
      goto LABEL_18;
    }
    if ( !a1[270].m128i_i64[1] )
      return __readfsqword(0x28u) ^ v58;
    switch ( v56 )
    {
      case 1:
        v16 = 0;
        goto LABEL_73;
      case 2:
        goto LABEL_73;
      case 3:
        v16 = 2;
LABEL_73:
        if ( v11 == 4 )
        {
          if ( a1[28].m128i_i32[1] == 1 )
            return __readfsqword(0x28u) ^ v58;
          v16 += 32;
          v37 = a1[28].m128i_i8[8];
        }
        else if ( v11 == 5 )
        {
          v37 = a1[28].m128i_i8[8];
          a1[28].m128i_i32[3] = 0;
          if ( !v37 )
            v16 = 3;
        }
        else
        {
          if ( v11 != 1 || a1[28].m128i_i32[3] == v56 )
            return __readfsqword(0x28u) ^ v58;
          a1[28].m128i_i32[3] = v56;
LABEL_78:
          v37 = a1[28].m128i_i8[8];
        }
        if ( a7 )
          v16 += 4;
        if ( a8 )
          v16 += 16;
        if ( v37 )
        {
          v38 = v16;
          v39 = "\x1B[<%d;%d;%d%c";
        }
        else
        {
          if ( !a1[28].m128i_i8[9] )
          {
            if ( v10 + 1 > 223 || v12 + 1 > 223 )
              return __readfsqword(0x28u) ^ v58;
            __sprintf_chk(&v57, 1LL, 32LL, "\x1B[M%c%c%c", v16 + 32);
            v40 = 6;
LABEL_86:
            sub_2C0F0(a1[270].m128i_i64[1], &v57, v40, 0);
            return __readfsqword(0x28u) ^ v58;
          }
          v38 = v16 + 32;
          v39 = "\x1B[%d;%d;%dM";
        }
        v40 = __sprintf_chk(&v57, 1LL, 32LL, v39, v38);
        goto LABEL_86;
      case 7:
        v16 = 64;
        goto LABEL_112;
      case 8:
        v16 = 65;
LABEL_112:
        if ( v11 == 1 )
          goto LABEL_78;
        return __readfsqword(0x28u) ^ v58;
      default:
        return __readfsqword(0x28u) ^ v58;
    }
  }
  v22 = a1[285].m128i_i8[9] ^ a9;
  if ( !v21 )
  {
    a1[234].m128i_i32[2] = v22;
    v23 = v11 == 1;
    if ( v54 != 4 )
      goto LABEL_38;
    goto LABEL_19;
  }
LABEL_18:
  v23 = v11 == 1;
  if ( v54 != 4 )
    goto LABEL_38;
LABEL_19:
  if ( v23 )
  {
    a1[235] = 0uLL;
    a1[234].m128i_i32[1] = 1;
    a1[234].m128i_i32[2] = v22;
    a1[236].m128i_i32[0] = v18;
    a1[236].m128i_i32[1] = v10;
    a1[234].m128i_i32[3] = 0;
LABEL_21:
    sub_93640((__int64)v9, v20);
    goto LABEL_22;
  }
LABEL_38:
  if ( v54 == 4 )
  {
    if ( (unsigned int)(v11 - 2) <= 1 )
    {
      a1[236].m128i_i32[0] = v18;
      a1[236].m128i_i32[1] = v10;
      a1[234].m128i_i32[1] = 2;
      a1[234].m128i_i32[3] = (v11 != 2) + 1;
      v51 = a1[236].m128i_u64[0];
      a1[235].m128i_i64[0] = v51;
      a1[235].m128i_i64[1] = v51;
      v52 = v51 >> 32;
      if ( a1[26].m128i_i32[0] == (_DWORD)v52 )
        a1[235].m128i_i64[1] = (unsigned int)(a1[235].m128i_i32[2] + 1);
      else
        a1[235].m128i_i32[3] = v52 + 1;
      if ( a1[234].m128i_i32[2] )
        goto LABEL_22;
LABEL_100:
      sub_8F100(v9);
      if ( v9[234].m128i_i32[1] != 2 )
        goto LABEL_21;
      goto LABEL_22;
    }
    if ( v11 == 4 )
    {
LABEL_89:
      if ( !v21 || v21 == 3 )
        return __readfsqword(0x28u) ^ v58;
LABEL_42:
      if ( v21 == 1 )
      {
        if ( a1[236].m128i_i64[0] == __PAIR__(v10, v18) )
          return __readfsqword(0x28u) ^ v58;
        v25 = a1[234].m128i_i32[2];
      }
      else
      {
        v25 = a1[234].m128i_i32[2];
        LOBYTE(v20) = v54 == 5;
        if ( v11 != 4 && v54 == 5 && v21 == 3 )
        {
          v47 = a1[235].m128i_i32[1];
          v48 = v9[235].m128i_i32[3];
          v49 = v9[235].m128i_i32[0];
          LODWORD(v27) = v9[235].m128i_i32[2];
          if ( v25 )
          {
            v53 = v47 + v48;
            LODWORD(v26) = v48 - 1;
            v20 = (unsigned int)(v27 + v49);
            if ( 2 * v10 >= v53 )
              LODWORD(v26) = v9[235].m128i_i32[1];
            v9[236].m128i_i32[1] = v26;
            if ( 2 * v18 >= (signed int)v20 )
            {
              v9[236].m128i_i32[0] = v49;
              LODWORD(v27) = v49;
            }
            else
            {
              v9[236].m128i_i32[0] = v27;
            }
          }
          else
          {
            LODWORD(v26) = v9[26].m128i_i32[0];
            v20 = (((signed int)v26 + 1) * ((signed int)v27 - v49) + v48 - v47) / 2;
            if ( (signed int)v20 <= v10 - v47 + ((signed int)v26 + 1) * (v18 - v49) )
            {
              v27 = v9[235].m128i_u64[0];
              v9[236].m128i_i64[0] = v27;
              v26 = v27 >> 32;
            }
            else
            {
              v50 = v9[235].m128i_u64[1];
              v9[236].m128i_i64[0] = v50;
              v27 = v50 >> 32;
              if ( (_DWORD)v27 )
              {
                LODWORD(v26) = v27 - 1;
                LODWORD(v27) = v9[236].m128i_i32[0];
                v9[236].m128i_i32[1] = v26;
              }
              else
              {
                v20 = v9[236].m128i_u32[0];
                v9[236].m128i_i32[1] = v26;
                LODWORD(v27) = v20 - 1;
                v9[236].m128i_i32[0] = v20 - 1;
              }
            }
          }
LABEL_95:
          v9[234].m128i_i32[1] = 2;
          if ( v25 )
            goto LABEL_47;
          v42 = __OFSUB__(v18, (_DWORD)v27);
          v41 = v18 - (signed int)v27 < 0;
          if ( v18 != (_DWORD)v27 )
            goto LABEL_97;
          goto LABEL_127;
        }
        if ( v21 != 2 )
        {
          a1[236].m128i_i32[0] = v18;
          a1[236].m128i_i32[1] = v10;
          a1[234].m128i_i32[1] = 2;
          LODWORD(v26) = v10;
          LODWORD(v27) = v18;
          if ( v25 )
          {
LABEL_47:
            v30 = __OFSUB__(v10, (_DWORD)v26);
            v28 = v10 == (_DWORD)v26;
            v29 = v10 - (signed int)v26 < 0;
            v31 = v26;
            if ( v10 >= (signed int)v26 )
              LODWORD(v26) = v10;
            if ( (unsigned __int8)(v29 ^ v30) | v28 )
              v31 = v10;
            v32 = v26;
            v33 = v27;
            v9[235].m128i_i32[1] = v31;
            v34 = v32 + 1;
            if ( v18 <= (signed int)v27 )
              v33 = v18;
            if ( v18 < (signed int)v27 )
              v18 = v27;
            v9[235].m128i_i32[3] = v34;
            v9[235].m128i_i32[0] = v33;
            v9[235].m128i_i32[2] = v18;
            goto LABEL_22;
          }
LABEL_127:
          v42 = __OFSUB__(v10, (_DWORD)v26);
          v41 = v10 - (signed int)v26 < 0;
LABEL_97:
          v43 = v9[26].m128i_i32[0];
          if ( v41 ^ v42 )
          {
            v45 = v9[236].m128i_u64[0];
            v9[235].m128i_i32[0] = v18;
            v9[235].m128i_i32[1] = v10;
            v9[235].m128i_i64[1] = v45;
            v46 = v45 >> 32;
            if ( (_DWORD)v46 == v43 )
            {
              v9[235].m128i_i32[3] = 0;
              ++v9[235].m128i_i32[2];
            }
            else
            {
              v9[235].m128i_i32[3] = v46 + 1;
            }
          }
          else
          {
            v44 = v9[236].m128i_i64[0];
            v9[235].m128i_i32[2] = v18;
            v9[235].m128i_i32[3] = v10;
            v9[235].m128i_i64[0] = v44;
            if ( v10 == v43 )
              v9[235].m128i_i64[1] = (unsigned int)(v18 + 1);
            else
              v9[235].m128i_i32[3] = v10 + 1;
          }
          goto LABEL_100;
        }
      }
      LODWORD(v26) = a1[236].m128i_i32[1];
      LODWORD(v27) = a1[236].m128i_i32[0];
      goto LABEL_95;
    }
  }
  else
  {
    if ( v54 == 5 && v11 != 5 )
    {
      if ( v11 != 4 )
        goto LABEL_42;
      goto LABEL_89;
    }
    if ( (unsigned int)(v54 - 4) > 1 )
    {
      if ( v54 == 6 && v23 )
      {
        v20 = a1[290].m128i_u32[2];
        sub_97DA0((__int64)a1, v20);
        v21 = a1[234].m128i_i32[1];
      }
      goto LABEL_70;
    }
  }
  if ( v11 == 5 )
  {
    if ( v21 == 2 )
    {
      v20 = a1[235].m128i_i64[0];
      sub_8DA80(
        (__int64)a1,
        v20,
        a1[235].m128i_u64[1],
        a1[234].m128i_i32[2] == 1,
        0,
        &a1[288].m128i_u32[2],
        a1[290].m128i_i32[1]);
      a1[234].m128i_i32[1] = 3;
    }
    else
    {
      a1[234].m128i_i32[1] = 0;
    }
    goto LABEL_21;
  }
LABEL_70:
  if ( v21 != 2 )
    goto LABEL_21;
LABEL_22:
  if ( !v9[273].m128i_i8[9] )
    sub_8E2A0((__int64)v9);
  return __readfsqword(0x28u) ^ v58;
}

signed __int64 __fastcall sub_98A60(__int64 a1, _BYTE *a2, unsigned int a3, char a4)
{
  const char *v4; // rcx

  if ( !a2[442] )
  {
    if ( !a2[440] || a2[4559] )
    {
      if ( !a4 )
        goto LABEL_5;
    }
    else if ( a4 )
    {
LABEL_5:
      v4 = "\x1B[%c";
LABEL_6:
      __sprintf_chk(a1, 1LL, -1LL, v4, a3);
      return 3LL;
    }
    v4 = "\x1BO%c";
    goto LABEL_6;
  }
  __sprintf_chk(a1, 1LL, -1LL, "\x1B%c", a3);
  return 2LL;
}

signed __int64 __fastcall sub_98AF0(__int64 a1, __int64 a2, signed int a3, char a4, char a5)
{
  __int64 v5; // rbx
  int v6; // edi
  int v7; // eax
  __int64 v8; // r8
  char v9; // dl
  __int64 v10; // r8
  unsigned int v12; // edx
  bool v13; // zf
  const char *v14; // rcx
  signed __int64 v15; // rax

  if ( a3 <= 0 )
    __assert_fail("key_number > 0", "terminal.c", 0x1C32u, "format_function_key");
  if ( a3 > 20 )
    __assert_fail("key_number < lenof(key_number_to_tilde_code)", "terminal.c", 0x1C33u, "format_function_key");
  v5 = a1;
  if ( a3 <= 10 )
  {
    v6 = a3 + 10;
    if ( a4 )
    {
      v7 = *(_DWORD *)(a2 + 4544);
      if ( v7 != 5 )
        goto LABEL_6;
LABEL_12:
      v12 = a3 - 1;
      if ( v12 > 0xB )
        v12 = 0;
      v13 = a4 == 0;
      v14 = "\x1B[%c";
      if ( !v13 )
        v12 += 12;
      if ( a5 )
        v12 += 24;
      v10 = (unsigned int)aMnopqrstuvwxyz[v12];
      goto LABEL_19;
    }
  }
  v7 = *(_DWORD *)(a2 + 4544);
  v6 = a3;
  if ( v7 == 5 )
    goto LABEL_12;
LABEL_6:
  v8 = dword_F5600[v6];
  v9 = *(_BYTE *)(a2 + 442);
  if ( (v7 == 4 || v9) && (unsigned int)(v8 - 11) <= 0xD )
  {
    v10 = (_DWORD)v8 + 69 - (((signed int)v8 > 21) + (unsigned int)((signed int)v8 > 15));
    if ( v9 )
    {
LABEL_10:
      __sprintf_chk(v5, 1LL, -1LL, "\x1B%c", v10);
      return 2LL;
    }
    goto LABEL_26;
  }
  if ( v7 == 1 )
  {
    if ( (unsigned int)(v8 - 11) <= 4 )
    {
      __sprintf_chk(v5, 1LL, -1LL, "\x1B[[%c", (unsigned int)(v8 + 54));
      v15 = v5 + 4;
      return v15 - v5;
    }
  }
  else if ( v7 == 2 && (unsigned int)(v8 - 11) <= 3 )
  {
    v10 = (unsigned int)(v8 + 69);
    if ( v9 )
      goto LABEL_10;
LABEL_26:
    v14 = "\x1BO%c";
LABEL_19:
    __sprintf_chk(v5, 1LL, -1LL, v14, v10);
    return 3LL;
  }
  v15 = v5 + (signed int)__sprintf_chk(v5, 1LL, -1LL, "\x1B[%d~", v8);
  return v15 - v5;
}

signed __int64 __fastcall sub_98CD0(_BYTE *a1, __int64 a2, int a3)
{
  signed __int64 v3; // r8
  int v4; // eax
  char v5; // dl
  signed __int64 result; // rax
  char *v7; // rcx

  switch ( a3 )
  {
    case 0:
      v3 = 1LL;
      break;
    case 1:
      v3 = 4LL;
      break;
    case 2:
      v3 = 2LL;
      break;
    case 3:
      v3 = 3LL;
      break;
    case 4:
      v3 = 5LL;
      break;
    case 5:
      v3 = 6LL;
      break;
    default:
      __assert_fail("false && \"bad small keypad key enum value\"", "terminal.c", 0x1C65u, "format_small_keypad_key");
      return result;
  }
  v4 = *(_DWORD *)(a2 + 4544);
  v5 = *(_BYTE *)(a2 + 442);
  if ( v4 == 3 )
  {
    v3 = byte_F53D8[v3];
    if ( v5 && (unsigned int)(v3 - 1) <= 5 )
      goto LABEL_5;
  }
  else
  {
    if ( v5 )
    {
LABEL_5:
      __sprintf_chk(a1, 1LL, -1LL, "\x1B%c", (unsigned int)aHlmeig[v3]);
      return 2LL;
    }
    if ( v4 == 5 )
    {
      if ( (_DWORD)v3 == 3 )
      {
        *a1 = 127;
        result = 1LL;
      }
      else
      {
        __sprintf_chk(a1, 1LL, -1LL, "\x1B[%c", (unsigned int)aHlFig[(signed int)v3 - 1]);
        result = 3LL;
      }
      return result;
    }
  }
  if ( (_DWORD)v3 != 1 && (_DWORD)v3 != 4 || !*(_BYTE *)(a2 + 4576) )
    return (signed int)__sprintf_chk(a1, 1LL, -1LL, "\x1B[%d~", v3);
  v7 = "\x1BOw";
  if ( (_DWORD)v3 == 1 )
    v7 = "\x1B[H";
  return (signed int)__sprintf_chk(a1, 1LL, -1LL, v7, v3);
}

signed __int64 __fastcall sub_98EC0(char *a1, __int64 a2, char a3, char a4, char a5)
{
  signed __int64 result; // rax
  char v6; // al
  signed int v7; // er9
  signed __int64 v8; // r8
  const char *v9; // rcx
  _BOOL4 v10; // er8

  result = 0LL;
  if ( *(_BYTE *)(a2 + 441) )
    result = (unsigned __int8)(*(_BYTE *)(a2 + 4560) ^ 1);
  if ( !*(_BYTE *)(a2 + 4557) || (unsigned __int8)(a3 - 49) > 8u )
  {
    v7 = *(_DWORD *)(a2 + 4544);
    if ( v7 == 3 )
    {
      if ( (unsigned __int8)(a3 - 42) <= 0x1Du )
      {
        v8 = off_F5500[(unsigned __int8)(a3 - 42)];
        if ( !(_DWORD)result )
          goto LABEL_16;
        goto LABEL_28;
      }
    }
    else if ( v7 <= 1 && result & 1 && (unsigned __int8)(a3 - 42) <= 0x1Du )
    {
      v8 = off_F5500[(unsigned __int8)(a3 - 42)];
LABEL_28:
      switch ( a3 )
      {
        case 42:
          if ( v7 == 2 )
            goto LABEL_51;
          break;
        case 43:
          goto LABEL_46;
        case 45:
          if ( v7 == 2 )
            goto LABEL_53;
          break;
        case 46:
          goto LABEL_33;
        case 47:
          goto LABEL_35;
        case 48:
          goto LABEL_37;
        case 49:
          goto LABEL_38;
        case 50:
          goto LABEL_39;
        case 51:
          goto LABEL_40;
        case 52:
          goto LABEL_41;
        case 53:
          goto LABEL_42;
        case 54:
          goto LABEL_43;
        case 55:
          goto LABEL_44;
        case 56:
          goto LABEL_45;
        case 57:
          goto LABEL_21;
        default:
          break;
      }
LABEL_16:
      if ( (_DWORD)v8 )
      {
LABEL_17:
        if ( *(_BYTE *)(a2 + 442) )
        {
          if ( (unsigned int)(v8 - 80) <= 3 )
          {
            __sprintf_chk(a1, 1LL, -1LL, "\x1B%c", v8);
            return 2LL;
          }
LABEL_23:
          v9 = "\x1B?%c";
        }
        else
        {
LABEL_25:
          v9 = "\x1BO%c";
        }
        __sprintf_chk(a1, 1LL, -1LL, v9, v8);
        return 3LL;
      }
      return 0LL;
    }
    if ( !(_DWORD)result )
      return result;
    switch ( a3 )
    {
      case 13:
        v8 = 77LL;
        goto LABEL_22;
      case 42:
        if ( v7 != 2 )
          return 0LL;
LABEL_51:
        v8 = 106LL;
        goto LABEL_22;
      case 43:
LABEL_46:
        v10 = a4 != 0;
        if ( v7 == 2 )
          v8 = (unsigned int)(v10 + 107);
        else
          v8 = (unsigned int)(v10 + 108);
        goto LABEL_22;
      case 45:
        if ( v7 != 2 )
          return 0LL;
LABEL_53:
        v8 = 109LL;
        goto LABEL_22;
      case 46:
LABEL_33:
        v8 = 110LL;
        goto LABEL_22;
      case 47:
        v8 = 0LL;
LABEL_35:
        if ( v7 != 2 )
          goto LABEL_16;
        v8 = 111LL;
        goto LABEL_22;
      case 48:
LABEL_37:
        v8 = 112LL;
        goto LABEL_17;
      case 49:
LABEL_38:
        v8 = 113LL;
        goto LABEL_22;
      case 50:
LABEL_39:
        v8 = 114LL;
        goto LABEL_22;
      case 51:
LABEL_40:
        v8 = 115LL;
        goto LABEL_22;
      case 52:
LABEL_41:
        v8 = 116LL;
        goto LABEL_22;
      case 53:
LABEL_42:
        v8 = 117LL;
        goto LABEL_22;
      case 54:
LABEL_43:
        v8 = 118LL;
        goto LABEL_22;
      case 55:
LABEL_44:
        v8 = 119LL;
        goto LABEL_22;
      case 56:
LABEL_45:
        v8 = 120LL;
        goto LABEL_22;
      case 57:
LABEL_21:
        v8 = 121LL;
LABEL_22:
        if ( *(_BYTE *)(a2 + 442) )
          goto LABEL_23;
        goto LABEL_25;
      default:
        return 0LL;
    }
    return 0LL;
  }
  v6 = aBjnhLyku[a3 - 49];
  if ( v6 != 46 )
  {
    if ( a5 )
    {
      v6 &= 0x1Fu;
    }
    else if ( a4 )
    {
      v6 -= 32;
    }
  }
  *a1 = v6;
  return 1LL;
}

void __fastcall sub_991B0(__int64 a1, signed int *a2, int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // r12
  void **v6; // rbp
  char *v7; // r13
  int v8; // eax
  __int64 v9; // rdi

  v3 = a1;
  v4 = sub_8AF20(a1, a2, a3);
  v5 = *(_QWORD *)(v4 + 16);
  v6 = (void **)v4;
  if ( v5 )
  {
    v7 = *(char **)v4;
    if ( *(_BYTE *)(a1 + 444) )
    {
      v8 = *(_QWORD *)(v4 + 16);
      if ( (signed int)v5 < 0 )
        v8 = strlen(v7);
      sub_BCD20(a1 + 192, v7, v8);
      if ( !*(_BYTE *)(a1 + 4376) )
        sub_97850(a1, (unsigned __int64)v7);
    }
    v9 = *(_QWORD *)(a1 + 4328);
    if ( *(_BYTE *)(v3 + 465) )
    {
      if ( !v9 )
      {
        *(_BYTE *)(v3 + 465) = 0;
LABEL_11:
        sub_901B0(v3);
        goto LABEL_2;
      }
      sub_2C0F0(v9, "\x1B[201~", 6u, 0);
      v9 = *(_QWORD *)(v3 + 4328);
      *(_BYTE *)(v3 + 465) = 0;
    }
    if ( v9 )
      sub_2C0F0(v9, v7, v5, 1);
    goto LABEL_11;
  }
LABEL_2:
  sub_BC660(v6);
}

void __fastcall sub_99290(__int64 a1, __int64 a2, const char *a3, signed int a4)
{
  char *v4; // r12
  signed int v5; // ebp
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // r12
  void **v9; // rbp
  int v10; // eax
  __int64 v11; // rdi
  char *v12; // r13
  int v13; // eax
  __int64 v14; // rdi

  v4 = (char *)a3;
  v5 = a4;
  v6 = a1;
  if ( (signed int)a2 >= 0 && *(_DWORD *)(*(_QWORD *)(a1 + 4352) + 16LL) != (_DWORD)a2 )
  {
    v7 = sub_8EAC0(a1, a2, (__int64)a3, a4);
    v8 = *(_QWORD *)(v7 + 16);
    v9 = (void **)v7;
    if ( !v8 )
    {
LABEL_4:
      sub_BC660(v9);
      return;
    }
    v12 = *(char **)v7;
    if ( *(_BYTE *)(a1 + 444) )
    {
      v13 = *(_QWORD *)(v7 + 16);
      if ( (signed int)v8 < 0 )
        v13 = strlen(v12);
      sub_BCD20(a1 + 192, v12, v13);
      if ( !*(_BYTE *)(a1 + 4376) )
        sub_97850(a1, (unsigned __int64)v12);
    }
    v14 = *(_QWORD *)(a1 + 4328);
    if ( *(_BYTE *)(v6 + 465) )
    {
      if ( !v14 )
      {
        *(_BYTE *)(v6 + 465) = 0;
LABEL_24:
        sub_901B0(v6);
        goto LABEL_4;
      }
      sub_2C0F0(v14, "\x1B[201~", 6u, 0);
      v14 = *(_QWORD *)(v6 + 4328);
      *(_BYTE *)(v6 + 465) = 0;
    }
    if ( v14 )
      sub_2C0F0(v14, v12, v8, 1);
    goto LABEL_24;
  }
  if ( *(_BYTE *)(a1 + 444) )
  {
    v10 = a4;
    if ( a4 < 0 )
      v10 = strlen(a3);
    sub_BCD20(a1 + 192, v4, v10);
    if ( !*(_BYTE *)(a1 + 4376) )
      sub_97850(a1, (unsigned __int64)v4);
  }
  v11 = *(_QWORD *)(a1 + 4328);
  if ( !*(_BYTE *)(v6 + 465) )
    goto LABEL_11;
  if ( v11 )
  {
    sub_2C0F0(v11, "\x1B[201~", 6u, 0);
    v11 = *(_QWORD *)(v6 + 4328);
    *(_BYTE *)(v6 + 465) = 0;
LABEL_11:
    if ( v11 )
      sub_2C0F0(v11, v4, v5, 1);
    goto LABEL_13;
  }
  *(_BYTE *)(v6 + 465) = 0;
LABEL_13:
  sub_901B0(v6);
}

void __fastcall sub_99470(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi

  if ( *(_DWORD *)(a1 + 4312) )
  {
    v1 = a1;
    sub_2F4D0(*(void **)(a1 + 4304));
    if ( *(_BYTE *)(a1 + 465) )
    {
      v2 = *(_QWORD *)(a1 + 4328);
      if ( v2 )
        sub_2C0F0(v2, "\x1B[201~", 6u, 0);
      *(_BYTE *)(v1 + 465) = 0;
    }
    *(_QWORD *)(v1 + 4304) = 0LL;
    *(_DWORD *)(v1 + 4312) = 0;
  }
}

__int64 __fastcall sub_994E0(const __m128i *a1, unsigned __int64 a2)
{
  __int64 result; // rax

  if ( a1[290].m128i_i32[1] > 1 && a1[288].m128i_i32[3] == (_DWORD)a2 )
  {
    a1[234].m128i_i32[1] = 0;
    a1[235] = 0uLL;
    result = sub_8FD90(a1);
    if ( a1[234].m128i_i32[1] != 2 )
      result = sub_93640((__int64)a1, a2);
  }
  return result;
}

__int64 __fastcall sub_99540(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rsi

  v4 = a3;
  sub_BCD20(a1 + 192, (char *)a3, a4);
  if ( !*(_BYTE *)(a1 + 4376) )
    sub_97850(a1, v4);
  return 0LL;
}

void __fastcall sub_99570(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 4344) = a2;
}

void __fastcall sub_99580(__int64 a1, char a2)
{
  bool v2; // zf

  v2 = *(_BYTE *)(a1 + 4526) == 0;
  *(_BYTE *)(a1 + 424) = a2;
  if ( !v2 && a2 )
  {
    sub_8E370(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 291) = 1;
    *(_BYTE *)(a1 + 4393) = 0;
  }
}

signed __int64 __fastcall sub_99630(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbp
  _BYTE *v5; // r13
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rax
  __int64 v8; // rbx
  __int64 *v9; // rdi
  __int64 v11; // rax
  __int64 *i; // rdi
  size_t v13; // rax
  _BYTE *v14; // rax
  bool v15; // zf
  char *v16; // rbx
  size_t v17; // r15
  char *v18; // rbx
  unsigned __int64 v19; // rax
  __int64 v20; // rbx
  signed int v21; // er15
  __int64 v22; // rdi
  char *v23; // [rsp+8h] [rbp-50h]
  size_t v24; // [rsp+8h] [rbp-50h]
  unsigned __int8 v25; // [rsp+17h] [rbp-41h]
  unsigned __int64 v26; // [rsp+18h] [rbp-40h]

  v3 = a1;
  v4 = a3;
  v5 = *(_BYTE **)(a2 + 64);
  v26 = __readfsqword(0x28u);
  if ( v5 )
  {
    v6 = *(_QWORD *)(a2 + 40);
  }
  else
  {
    v14 = sub_2F450(1uLL, 0x10uLL, 0LL);
    v15 = *(_BYTE *)(a2 + 16) == 0;
    *(_QWORD *)(a2 + 64) = v14;
    v5 = v14;
    *(_QWORD *)v14 = 0LL;
    v14[8] = 0;
    if ( !v15 )
    {
      v16 = *(char **)(a2 + 8);
      if ( v16 )
      {
        v17 = strlen(*(const char **)(a2 + 8));
        sub_BCD20(a1 + 192, v16, v17);
        if ( !*(_BYTE *)(a1 + 4376) )
          sub_97850(a1, (unsigned __int64)v16);
        if ( !(unsigned __int8)sub_BD220((__int64)v16, v17, "\n", 1uLL, 0LL) )
        {
          sub_BCD20(a1 + 192, "\r\n", 2uLL);
          if ( !*(_BYTE *)(a1 + 4376) )
            sub_97850(a1, (unsigned __int64)"\r\n");
        }
      }
    }
    v18 = *(char **)(a2 + 24);
    if ( v18 )
    {
      v24 = strlen(*(const char **)(a2 + 24));
      sub_BCD20(a1 + 192, v18, v24);
      v19 = v24;
      if ( !*(_BYTE *)(a1 + 4376) )
      {
        sub_97850(a1, (unsigned __int64)v18);
        v19 = v24;
      }
      if ( !(unsigned __int8)sub_BD220((__int64)v18, v19, "\n", 1uLL, 0LL) )
      {
        sub_BCD20(a1 + 192, "\r\n", 2uLL);
        if ( !*(_BYTE *)(a1 + 4376) )
          sub_97850(a1, (unsigned __int64)"\r\n");
      }
    }
    v6 = *(_QWORD *)(a2 + 40);
    if ( (signed int)v6 > 0 )
    {
      v20 = 0LL;
      v21 = 0;
      do
      {
        ++v21;
        v22 = *(_QWORD *)(*(_QWORD *)(a2 + 56) + v20);
        v20 += 8LL;
        sub_31BF0(v22, &locale);
        v6 = *(_QWORD *)(a2 + 40);
      }
      while ( v21 < (signed int)v6 );
    }
  }
  v7 = *(_QWORD *)v5;
  while ( 1 )
  {
LABEL_4:
    if ( v7 >= v6 )
      goto LABEL_64;
    v8 = *(_QWORD *)(*(_QWORD *)(a2 + 56) + 8 * v7);
    if ( !v5[8] )
    {
      v23 = *(char **)v8;
      v13 = strlen(*(const char **)v8);
      sub_BCD20(v3 + 192, v23, v13);
      if ( !*(_BYTE *)(v3 + 4376) )
        sub_97850(v3, (unsigned __int64)v23);
      v5[8] = 1;
    }
    if ( !v4 || !sub_BCD00(v4) )
    {
      if ( *(_QWORD *)v5 < *(_QWORD *)(a2 + 40) )
        return 0xFFFFFFFFLL;
LABEL_64:
      sub_2F4D0(v5);
      *(_QWORD *)(a2 + 64) = 0LL;
      return 1LL;
    }
LABEL_8:
    if ( sub_BCD00(v4) )
      break;
LABEL_18:
    v7 = *(_QWORD *)v5;
    v6 = *(_QWORD *)(a2 + 40);
  }
  while ( 1 )
  {
    sub_BCFC0(v4, (char *)&v25, 1uLL);
    if ( v25 == 10 )
      goto LABEL_32;
    if ( (char)v25 <= 10 )
      break;
    if ( v25 == 21 )
      goto LABEL_35;
    if ( (char)v25 <= 21 )
    {
      if ( v25 != 13 )
      {
LABEL_20:
        if ( !*(_BYTE *)(v8 + 8) || (unsigned __int8)(v25 - 32) <= 0x5Eu || v25 > 0x9Fu )
        {
          sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(*(_QWORD *)(v8 + 16) + 24LL), v25);
          if ( *(_BYTE *)(v8 + 8) )
          {
            sub_BCD20(v3 + 192, (char *)&v25, 1uLL);
            if ( !*(_BYTE *)(v3 + 4376) )
              sub_97850(v3, (unsigned __int64)&v25);
          }
        }
        goto LABEL_8;
      }
LABEL_32:
      sub_BCD20(v3 + 192, "\r\n", 2uLL);
      if ( !*(_BYTE *)(v3 + 4376) )
        sub_97850(v3, (unsigned __int64)"\r\n");
      v11 = *(_QWORD *)v5;
      v5[8] = 0;
      v6 = *(_QWORD *)(a2 + 40);
      v7 = v11 + 1;
      *(_QWORD *)v5 = v7;
      goto LABEL_4;
    }
    if ( v25 == 27 )
    {
LABEL_35:
      for ( i = *(__int64 **)(v8 + 16); i[2]; i = *(__int64 **)(v8 + 16) )
      {
        if ( *(_BYTE *)(v8 + 8) )
        {
          sub_BCD20(v3 + 192, (char *)&off_E337C, 3uLL);
          if ( !*(_BYTE *)(v3 + 4376) )
            sub_97850(v3, (unsigned __int64)&off_E337C);
          i = *(__int64 **)(v8 + 16);
        }
        sub_BC5D0(i, 1uLL);
      }
      goto LABEL_8;
    }
    if ( v25 != 127 )
      goto LABEL_20;
    v9 = *(__int64 **)(v8 + 16);
    if ( !v9[2] )
      goto LABEL_8;
LABEL_16:
    if ( *(_BYTE *)(v8 + 8) )
    {
      sub_BCD20(v3 + 192, (char *)&off_E337C, 3uLL);
      if ( !*(_BYTE *)(v3 + 4376) )
        sub_97850(v3, (unsigned __int64)&off_E337C);
      v9 = *(__int64 **)(v8 + 16);
    }
    sub_BC5D0(v9, 1uLL);
    if ( !sub_BCD00(v4) )
      goto LABEL_18;
  }
  if ( (char)v25 < 3 )
    goto LABEL_20;
  if ( (char)v25 > 4 )
  {
    if ( v25 != 8 )
      goto LABEL_20;
    v9 = *(__int64 **)(v8 + 16);
    if ( !v9[2] )
      goto LABEL_8;
    goto LABEL_16;
  }
  sub_BCD20(v3 + 192, "\r\n", 2uLL);
  if ( !*(_BYTE *)(v3 + 4376) )
    sub_97850(v3, (unsigned __int64)"\r\n");
  sub_2F4D0(v5);
  *(_QWORD *)(a2 + 64) = 0LL;
  return 0LL;
}

void __fastcall sub_99B90(__int64 a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 8604) = a2;
  *(_DWORD *)(a1 + 8608) = a3;
}

void __fastcall sub_99BA0(__int64 a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 8612) = a2;
  *(_DWORD *)(a1 + 8616) = a3;
}

__m128i *__fastcall sub_99BB0(__m128i *a1)
{
  const __m128i *v1; // rax
  __m128i v2; // xmm0
  __int64 v3; // rax
  __int64 vars0; // [rsp+0h] [rbp+0h]
  unsigned __int64 vars8; // [rsp+8h] [rbp+8h]

  vars8 = __readfsqword(0x28u);
  time(&vars0);
  if ( vars0 == -1 )
    __assert_fail("t != ((time_t)-1)", "time.c", 0xEu, "ltime");
  v1 = (const __m128i *)localtime(&vars0);
  *a1 = _mm_loadu_si128(v1);
  a1[1] = _mm_loadu_si128(v1 + 1);
  v2 = _mm_loadu_si128(v1 + 2);
  v3 = v1[3].m128i_i64[0];
  a1[2] = v2;
  a1[3].m128i_i64[0] = v3;
  return a1;
}

signed __int64 __fastcall sub_99C50(unsigned __int64 a1, unsigned __int64 a2)
{
  signed __int64 result; // rax

  if ( a1 < a2 )
    result = 0xFFFFFFFFLL;
  else
    result = a1 > a2;
  return result;
}

signed __int64 __fastcall sub_99C70(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  signed __int64 result; // rax
  unsigned __int64 v5; // rax

  v2 = a1[2] - qword_326478;
  v3 = a2[2] - qword_326478;
  if ( v2 < v3 )
    goto LABEL_10;
  result = 1LL;
  if ( v2 > v3 )
    return result;
  if ( *a1 < *a2 )
    goto LABEL_10;
  if ( *a1 > *a2 )
    return result;
  v5 = a2[1];
  if ( a1[1] < v5 )
LABEL_10:
    result = 0xFFFFFFFFLL;
  else
    result = a1[1] > v5;
  return result;
}

__int64 __fastcall sub_99CC0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  qword_326488 = (__int64)sub_9AF60((__int64)sub_99C70);
  qword_326480 = (__int64)sub_9AF60((__int64)sub_99C50);
  result = sub_B4D20();
  qword_326478 = result;
  return result;
}

__int64 __fastcall sub_99D00(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  __int64 *v5; // rbp
  __int64 *v6; // rdi

  v3 = a3;
  if ( !qword_326488 )
    sub_99CC0(a1, a2);
  qword_326478 = sub_B4D20();
  v4 = (qword_326478 == qword_326478 + (signed int)a1) + qword_326478 + (signed int)a1;
  v5 = (__int64 *)sub_2F450(1uLL, 0x20uLL, 0LL);
  *v5 = a2;
  v5[1] = v3;
  v5[2] = v4;
  v6 = (__int64 *)qword_326488;
  v5[3] = qword_326478;
  if ( (__int64 *)sub_9AFD0(v6, (__int64)v5) == v5 )
    sub_9AFD0((__int64 *)qword_326480, v5[1]);
  else
    sub_2F4D0(v5);
  if ( v5 == (__int64 *)sub_9B010((__int64 *)qword_326488, 0) )
    sub_9DA70(v5[2], 0LL);
  return v4;
}

__int64 sub_99DF0()
{
  return qword_326478;
}

signed __int64 __fastcall sub_99E00(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbp
  __int64 v3; // rax
  _QWORD *v4; // rbx
  __int64 v5; // rsi

  v2 = (_QWORD *)a2;
  if ( !qword_326488 )
    sub_99CC0(a1, a2);
  qword_326478 = sub_B4D20();
  while ( 1 )
  {
    while ( 1 )
    {
      v3 = sub_9B010((__int64 *)qword_326488, 0);
      v4 = (_QWORD *)v3;
      if ( !v3 )
        return 0LL;
      if ( sub_9B3D0((__int64 *)qword_326480, *(_QWORD *)(v3 + 8), 0LL) )
        break;
      sub_9B400((__int64 *)qword_326488, 0);
      sub_2F4D0(v4);
    }
    v5 = v4[2];
    if ( qword_326478 + 10 - v4[3] <= (unsigned __int64)(v5 + 10 - v4[3]) )
      break;
    sub_9B400((__int64 *)qword_326488, 0);
    ((void (__fastcall *)(_QWORD, _QWORD))*v4)(v4[1], v4[2]);
    sub_2F4D0(v4);
  }
  *v2 = v5;
  return 1LL;
}

__int64 __fastcall sub_99EF0(__int64 a1)
{
  if ( !qword_326488 )
    sub_99CC0(a1, a1);
  return sub_9B440((__int64 *)qword_326480, a1);
}

void __fastcall sub_99F40(_QWORD *a1)
{
  if ( a1 )
  {
    sub_99F40(a1[1]);
    sub_99F40(a1[2]);
    sub_99F40(a1[3]);
    sub_99F40(a1[4]);
    sub_2F4D0(a1);
  }
}

__int64 __fastcall sub_99F90(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 40) + *(_DWORD *)(a1 + 44));
  if ( *(_QWORD *)(a1 + 56) )
    result = (unsigned int)(result + 1);
  if ( *(_QWORD *)(a1 + 64) )
    result = (unsigned int)(result + 1);
  if ( *(_QWORD *)(a1 + 72) )
    result = (unsigned int)(result + 1);
  return result;
}

__int64 __fastcall sub_9A740(void **a1, int a2)
{
  __int64 v2; // r14
  signed __int64 v3; // r13
  int v4; // er12
  _QWORD *v5; // rbx
  int v6; // eax
  __int64 v7; // rdx
  _QWORD *v8; // rdx
  _QWORD *v9; // rax
  _QWORD *v10; // r12
  __int64 v11; // r15
  _QWORD *v12; // rax
  _QWORD *v13; // rdx
  _QWORD *v14; // rcx
  __int64 v15; // rdx
  int v16; // er12
  int v17; // eax
  int v18; // eax
  __int64 v19; // rdi
  signed int v20; // ebp
  __int64 *v21; // rax
  __int64 *v22; // rdx
  signed int v23; // esi
  __int64 v24; // rcx
  signed __int64 v25; // rdx
  int v26; // edx
  __int64 v27; // rbp
  signed __int64 v28; // r8
  signed int v29; // esi
  signed __int64 v30; // rdi
  int v31; // er9
  __int64 *v32; // rax
  __int64 v33; // rax
  __int64 v34; // rdi
  __int64 v35; // rax
  __int64 v36; // rdi
  signed __int64 v37; // rax
  signed __int64 v38; // rdi
  int v39; // eax
  __int64 v40; // r8
  _QWORD *v41; // rdx
  signed __int64 v43; // r9
  __int64 v44; // rcx
  int v45; // esi
  __int64 v46; // r15
  __int64 *v47; // rax
  int v48; // edi
  __int64 *v49; // rax
  int v50; // edi
  __int64 *v51; // rax
  int v52; // eax
  __int64 v53; // r8
  void *v54; // rdx
  __int64 v55; // rax
  __int64 v56; // rdx
  __int64 v57; // rsi
  __int64 v58; // rsi
  __int64 v59; // rdi
  signed __int64 v60; // rax
  __int64 v61; // rdx
  int v62; // edx
  __int64 *v63; // rax
  __int64 v64; // rsi
  _QWORD *v65; // rax
  signed __int64 v66; // rdx
  signed __int64 v67; // rax
  bool v68; // zf
  __int64 v69; // rcx
  signed __int64 v70; // r10
  int v71; // eax
  bool v72; // cf
  signed __int64 v73; // r11
  signed __int64 v74; // rax
  __int64 *v75; // rdi
  signed __int64 v76; // rsi
  int v77; // eax
  __int64 v78; // r8
  __int64 v79; // r9
  int v80; // er12
  __int64 v81; // rcx
  int v82; // eax
  __int64 v83; // r8
  void *v84; // rdi
  _QWORD *v85; // [rsp+8h] [rbp-40h]

  v2 = 0LL;
  v3 = -1LL;
  v4 = a2;
  v5 = *a1;
  v85 = a1;
  while ( 1 )
  {
LABEL_2:
    if ( !v5 )
    {
LABEL_6:
      if ( v2 )
      {
        if ( (_DWORD)v3 == -1 )
          return 0LL;
      }
      else
      {
        v2 = *(_QWORD *)&word_38[4 * (signed int)v3];
        if ( (_DWORD)v3 == -1 )
          return 0LL;
      }
LABEL_8:
      v8 = (_QWORD *)*v5;
      v9 = (_QWORD *)v5[1];
      if ( !*v5 )
        goto LABEL_35;
LABEL_9:
      if ( v9 || !v5[8] )
        goto LABEL_10;
      v9 = v8;
LABEL_37:
      if ( (_DWORD)v3 != 2 )
      {
        v23 = v3 + 1;
        v24 = v5[(signed int)v3 + 8];
        if ( !v24 )
          goto LABEL_43;
        v25 = (signed __int64)&v5[v3];
        while ( 1 )
        {
          *(_QWORD *)(v25 + 56) = v24;
          if ( v23 == 2 )
            break;
          v25 += 8LL;
          v24 = *(_QWORD *)(v25 + 64);
          v23 = 2;
          if ( !v24 )
          {
            v3 = 1LL;
            goto LABEL_43;
          }
        }
      }
      v3 = 2LL;
LABEL_43:
      v5[v3 + 7] = 0LL;
      if ( v9 )
      {
        while ( 1 )
        {
          v26 = 0;
          if ( (_QWORD *)v9[1] != v5 )
          {
            v26 = 1;
            if ( (_QWORD *)v9[2] != v5 )
              v26 = (v9[3] != (_QWORD)v5) + 2;
          }
          v5 = v9;
          --*((_DWORD *)v9 + v26 + 10);
          if ( !*v9 )
            break;
          v9 = (_QWORD *)*v9;
        }
      }
      return v2;
    }
    while ( 1 )
    {
      v6 = *((_DWORD *)v5 + 10);
      if ( v6 > v4 )
      {
        v7 = v5[1];
        if ( !*(_QWORD *)(v7 + 64) )
        {
          v27 = v5[2];
          v28 = 0LL;
          v29 = 1;
          if ( v27 )
            goto LABEL_54;
          v45 = 0;
          v46 = 0LL;
LABEL_69:
          *(_QWORD *)(v27 + 32) = *(_QWORD *)(v27 + 16);
          *(_DWORD *)(v27 + 52) = *(_DWORD *)(v27 + 44);
          *(_QWORD *)(v27 + 72) = *(_QWORD *)(v27 + 56);
          *(_QWORD *)(v27 + 24) = *(_QWORD *)(v27 + 8);
          *(_DWORD *)(v27 + 48) = *(_DWORD *)(v27 + 40);
          v48 = *(_DWORD *)(v7 + 44);
          *(_QWORD *)(v27 + 64) = v5[v46 + 7];
          v49 = *(__int64 **)(v7 + 16);
          *(_DWORD *)(v27 + 44) = v48;
          *(_QWORD *)(v27 + 16) = v49;
          if ( v49 )
            *v49 = v27;
          v50 = *(_DWORD *)(v7 + 40);
          *(_QWORD *)(v27 + 56) = *(_QWORD *)(v7 + 56);
          v51 = *(__int64 **)(v7 + 8);
          *(_DWORD *)(v27 + 40) = v50;
          *(_QWORD *)(v27 + 8) = v51;
          if ( v51 )
            *v51 = v27;
          v52 = sub_99F90(v27);
          *((_DWORD *)v5 + v53 + 10) = v52;
          sub_2F4D0(v54);
          v55 = v46;
          v56 = v45 + 1;
          while ( 1 )
          {
            v58 = v5[v56 + 1];
            v59 = (signed int)v55;
            if ( !v58 )
              break;
            v5[v55 + 1] = v58;
            *((_DWORD *)v5 + v55 + 10) = *((_DWORD *)v5 + v56 + 10);
            if ( (_DWORD)v55 == 2 )
            {
              v5[9] = 0LL;
LABEL_106:
              v68 = v5[7] == 0LL;
              v5[4] = 0LL;
              *((_DWORD *)v5 + 13) = 0;
              if ( v68 )
              {
LABEL_107:
                v84 = v5;
                v5 = (_QWORD *)v27;
                *v85 = v27;
                *(_QWORD *)v27 = 0LL;
                sub_2F4D0(v84);
                goto LABEL_2;
              }
LABEL_78:
              v5 = (_QWORD *)v27;
              goto LABEL_2;
            }
            v57 = v5[v56++ + 7];
            v5[v55++ + 7] = v57;
            if ( (_DWORD)v55 == 3 )
              goto LABEL_106;
          }
          v60 = (signed __int64)&v5[(signed int)v55];
          *(_QWORD *)(v60 + 8) = 0LL;
          *((_DWORD *)v5 + v59 + 10) = 0;
          *(_QWORD *)(v60 + 56) = 0LL;
          if ( !v5[7] )
            goto LABEL_107;
          goto LABEL_78;
        }
        goto LABEL_5;
      }
      v4 -= v6 + 1;
      if ( v4 < 0 )
        break;
      v17 = *((_DWORD *)v5 + 11);
      if ( v4 < v17 )
      {
        v7 = v5[2];
        if ( !*(_QWORD *)(v7 + 64) )
        {
          v43 = 0LL;
          v28 = 1LL;
          goto LABEL_66;
        }
      }
      else
      {
        v4 -= v17 + 1;
        if ( v4 < 0 )
        {
          v3 = 1LL;
          if ( !v2 )
            v2 = v5[8];
          goto LABEL_8;
        }
        v18 = *((_DWORD *)v5 + 12);
        if ( v4 < v18 )
        {
          v7 = v5[3];
          if ( !*(_QWORD *)(v7 + 64) )
          {
            v43 = 1LL;
            v28 = 2LL;
LABEL_66:
            v44 = v5[v43 + 1];
            if ( !*(_QWORD *)(v44 + 64) )
            {
              v29 = v28 + 1;
              v27 = v5[(signed int)v28 + 2];
              if ( !v27 )
                goto LABEL_68;
LABEL_54:
              if ( !*(_QWORD *)(v27 + 64) )
              {
                if ( (_DWORD)v28 )
                {
LABEL_68:
                  v45 = v28 - 1;
                  v46 = (signed int)v28 - 1;
                  v4 += *((_DWORD *)v5 + v46 + 10) + 1;
                  v47 = &v5[v28];
                  v7 = *v47;
                  v27 = v47[1];
                }
                else
                {
                  v7 = v5[1];
                  v27 = v5[2];
                  v45 = 0;
                  v46 = 0LL;
                }
                goto LABEL_69;
              }
              v30 = (signed __int64)&v5[v28];
              v31 = *(_DWORD *)(v27 + 40);
              *(_QWORD *)(v7 + 64) = *(_QWORD *)(v30 + 56);
              v32 = *(__int64 **)(v27 + 8);
              *(_DWORD *)(v7 + 48) = v31;
              *(_QWORD *)(v7 + 24) = v32;
              if ( v32 )
                *v32 = v7;
              *(_QWORD *)(v30 + 56) = *(_QWORD *)(v27 + 56);
              *(_QWORD *)(v27 + 8) = *(_QWORD *)(v27 + 16);
              *(_DWORD *)(v27 + 40) = *(_DWORD *)(v27 + 44);
              v33 = *(_QWORD *)(v27 + 64);
              if ( v33 )
              {
                v34 = *(_QWORD *)(v27 + 24);
                *(_QWORD *)(v27 + 56) = v33;
                v35 = *(_QWORD *)(v27 + 72);
                *(_QWORD *)(v27 + 16) = v34;
                *(_DWORD *)(v27 + 44) = *(_DWORD *)(v27 + 48);
                if ( v35 )
                {
                  v36 = *(_QWORD *)(v27 + 32);
                  *(_QWORD *)(v27 + 64) = v35;
                  v37 = 3LL;
                  *(_QWORD *)(v27 + 24) = v36;
                  *(_DWORD *)(v27 + 48) = *(_DWORD *)(v27 + 52);
                  v38 = 2LL;
                }
                else
                {
                  v37 = 2LL;
                  v38 = 1LL;
                }
              }
              else
              {
                v37 = 1LL;
                v38 = 0LL;
              }
              *(_QWORD *)(v27 + 8 * v37 + 8) = 0LL;
              *(_DWORD *)(v27 + 4 * v37 + 40) = 0;
              *(_QWORD *)(v27 + 8 * v38 + 56) = 0LL;
              v39 = sub_99F90(v7);
              *((_DWORD *)v5 + v40 + 10) = v39;
              *((_DWORD *)v5 + v29 + 10) = sub_99F90(v27);
              v5 = v41;
              goto LABEL_2;
            }
            goto LABEL_97;
          }
        }
        else
        {
          v4 -= v18 + 1;
          if ( v4 < 0 )
          {
            v3 = 2LL;
            if ( !v2 )
              v2 = v5[9];
            goto LABEL_8;
          }
          v7 = v5[4];
          if ( !*(_QWORD *)(v7 + 64) )
          {
            v44 = v5[3];
            v28 = 3LL;
            if ( !*(_QWORD *)(v44 + 64) )
              goto LABEL_68;
            v43 = 2LL;
LABEL_97:
            v70 = (signed __int64)&v5[v43];
            v71 = 3 - (*(_QWORD *)(v44 + 72) < 1uLL);
            v72 = *(_QWORD *)(v44 + 72) < 1uLL;
            *(_QWORD *)(v7 + 24) = *(_QWORD *)(v7 + 16);
            v73 = v44 + 8LL * v71;
            v74 = v44 + 4LL * v71;
            *(_DWORD *)(v7 + 48) = *(_DWORD *)(v7 + 44);
            *(_QWORD *)(v7 + 64) = *(_QWORD *)(v7 + 56);
            *(_QWORD *)(v7 + 16) = *(_QWORD *)(v7 + 8);
            *(_DWORD *)(v7 + 44) = *(_DWORD *)(v7 + 40);
            *(_QWORD *)(v7 + 56) = *(_QWORD *)(v70 + 56);
            v75 = *(__int64 **)(v73 + 8);
            *(_QWORD *)(v7 + 8) = v75;
            *(_DWORD *)(v7 + 40) = *(_DWORD *)(v74 + 40);
            if ( v75 )
              *v75 = v7;
            v76 = v44 + 8LL * (2 - v72);
            *(_QWORD *)(v70 + 56) = *(_QWORD *)(v76 + 56);
            *(_QWORD *)(v73 + 8) = 0LL;
            *(_DWORD *)(v74 + 40) = 0;
            *(_QWORD *)(v76 + 56) = 0LL;
            v77 = sub_99F90(v7);
            *((_DWORD *)v5 + v78 + 10) = v77;
            v80 = *((_DWORD *)v5 + v79 + 10) + v4;
            v82 = sub_99F90(v81);
            *(_DWORD *)(v83 + 40) = v82;
            v4 = v80 - v82;
            goto LABEL_5;
          }
        }
      }
LABEL_5:
      v5 = (_QWORD *)v7;
      if ( !v7 )
        goto LABEL_6;
    }
    v3 = 0LL;
    if ( v2 )
      goto LABEL_8;
    v8 = (_QWORD *)*v5;
    v2 = v5[7];
    v9 = (_QWORD *)v5[1];
    if ( *v5 )
      goto LABEL_9;
LABEL_35:
    if ( !v5[8] )
      break;
    if ( !v9 )
      goto LABEL_37;
LABEL_10:
    v10 = &v5[(signed int)v3];
    v11 = v10[1];
    v12 = (_QWORD *)v10[1];
    if ( *(_QWORD *)(v11 + 64) )
    {
      while ( 1 )
      {
        v14 = (_QWORD *)v12[1];
        if ( !v14 )
          break;
        v13 = (_QWORD *)v12[4];
        if ( v13 || (v13 = (_QWORD *)v12[3]) != 0LL )
        {
          v12 = v13;
        }
        else
        {
          v12 = (_QWORD *)v12[2];
          if ( !v12 )
            v12 = v14;
        }
      }
      v15 = v12[9];
      if ( !v15 )
      {
        v15 = v12[8];
        if ( !v15 )
          v15 = v12[7];
      }
      v10[7] = v15;
      v16 = *((_DWORD *)v5 + (signed int)v3 + 10);
      v5 = (_QWORD *)v11;
      v4 = v16 - 1;
    }
    else
    {
      v19 = v10[2];
      v20 = v3 + 1;
      v21 = *(__int64 **)(v19 + 8);
      if ( *(_QWORD *)(v19 + 64) )
      {
        v22 = (__int64 *)v10[2];
        while ( v21 )
        {
          v22 = v21;
          v21 = (__int64 *)v21[1];
        }
        v5 = (_QWORD *)v10[2];
        v10[7] = v22[7];
        v4 = 0;
        continue;
      }
      v61 = v10[7];
      *(_QWORD *)(v11 + 24) = v21;
      *(_QWORD *)(v11 + 64) = v61;
      *(_DWORD *)(v11 + 48) = *(_DWORD *)(v19 + 40);
      if ( v21 )
        *v21 = v11;
      v62 = *(_DWORD *)(v19 + 44);
      *(_QWORD *)(v11 + 72) = *(_QWORD *)(v19 + 56);
      v63 = *(__int64 **)(v19 + 16);
      *(_DWORD *)(v11 + 52) = v62;
      *(_QWORD *)(v11 + 32) = v63;
      if ( v63 )
        *v63 = v11;
      sub_2F4D0((void *)v19);
      *((_DWORD *)v5 + (signed int)v3 + 10) = sub_99F90(v11);
      if ( (_DWORD)v3 == 2 )
      {
LABEL_90:
        v20 = 3;
        v67 = 2LL;
      }
      else
      {
        v64 = v10[8];
        if ( v64 )
        {
          v65 = &v5[(signed int)v3];
          v66 = (signed __int64)v5 + 4 * ((signed int)v3 + 2);
          while ( 1 )
          {
            v65[7] = v64;
            v65[2] = v65[3];
            *(_DWORD *)(v66 + 36) = *(_DWORD *)(v66 + 40);
            if ( v20 == 2 )
              goto LABEL_90;
            v64 = v65[9];
            v66 += 4LL;
            ++v65;
            v20 = 2;
            if ( !v64 )
            {
              v67 = 1LL;
              goto LABEL_91;
            }
          }
        }
        v67 = (signed int)v3;
      }
LABEL_91:
      v5[v67 + 7] = 0LL;
      v68 = v5[7] == 0LL;
      v69 = v20;
      v5[v69 + 1] = 0LL;
      *((_DWORD *)v5 + v69 + 10) = 0;
      if ( v68 )
      {
        *v85 = v11;
        *(_QWORD *)v11 = 0LL;
        sub_2F4D0(v5);
      }
      v5 = (_QWORD *)v11;
      v4 = *(_DWORD *)(v11 + 40) + *(_DWORD *)(v11 + 44) + 1;
    }
  }
  if ( v9 )
    goto LABEL_10;
  sub_2F4D0(v5);
  *v85 = 0LL;
  return v2;
}

_QWORD *__fastcall sub_9AF60(__int64 a1)
{
  _QWORD *result; // rax

  result = sub_2F450(1uLL, 0x10uLL, 0LL);
  *result = 0LL;
  result[1] = a1;
  return result;
}

void __fastcall sub_9AF90(_QWORD **a1)
{
  sub_99F40(*a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_9AFB0(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    result = sub_99F90(v1);
  else
    result = 0LL;
  return result;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9AFF0(_QWORD *a1, __int64 a2, int a3)
{
  if ( a3 >= 0 && !a1[1] )
  {
    JUMPOUT(*a1, 0LL, &loc_9A044);
    JUMPOUT(&loc_9A4A8);
  }
  return 0LL;
}

__int64 __fastcall sub_9AFD0(__int64 *a1, __int64 a2)
{
  __int64 v2; // r13
  signed int v3; // er12
  __int64 v4; // rbx
  int v5; // eax
  int v6; // eax
  __int64 *v7; // rbp
  signed __int64 v8; // r15
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // r15
  signed __int64 v12; // r8
  signed __int64 v13; // r13
  __int64 *v14; // r14
  signed __int64 v15; // r15
  __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r11
  int v21; // er10
  __int64 v22; // r9
  __int64 v23; // rcx
  _QWORD *v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rax
  int v27; // eax
  __int64 v28; // rdx
  _QWORD *v29; // r12
  __int64 v30; // rax
  int v31; // eax
  signed int v32; // eax
  signed int v33; // eax
  signed int v34; // eax
  __int64 v35; // rcx
  int v36; // edx
  int v37; // edx
  __int64 *v38; // rax
  _QWORD *v39; // rax
  int v40; // eax
  __int64 v41; // rdx
  _QWORD *v42; // rcx
  int v43; // esi
  _QWORD *v44; // rax
  _QWORD *v45; // rax
  __int64 *v46; // rcx
  int v47; // eax
  __int64 v48; // rcx
  __int64 v49; // rax
  int v50; // eax
  int v51; // esi
  __int64 v52; // rcx
  __int64 v53; // rax
  _QWORD *v54; // rsi
  int v55; // ecx
  __int64 v56; // rsi
  signed __int64 v57; // rdx
  int v59; // [rsp+0h] [rbp-58h]
  int v60; // [rsp+4h] [rbp-54h]
  __int64 v61; // [rsp+8h] [rbp-50h]
  __int64 v62; // [rsp+10h] [rbp-48h]
  __int64 *v63; // [rsp+18h] [rbp-40h]

  if ( !a1[1] )
    return 0LL;
  v57 = 0xFFFFFFFFLL;
  v2 = a2;
  v3 = -1;
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *a1 = (__int64)v44;
    v44[9] = 0LL;
    v44[8] = 0LL;
    *v44 = 0LL;
    v44[1] = 0LL;
    v44[2] = 0LL;
    v44[3] = 0LL;
    v44[4] = 0LL;
    v44[5] = 0LL;
    v44[6] = 0LL;
    v44[7] = a2;
    return a2;
  }
  while ( v3 >= 0 )
  {
    v7 = *(__int64 **)(v4 + 8);
    if ( v7 )
    {
      v32 = *(_DWORD *)(v4 + 40);
      if ( v32 >= v3 )
        goto LABEL_15;
      v3 -= v32 + 1;
      v33 = *(_DWORD *)(v4 + 44);
      if ( v33 >= v3 )
      {
LABEL_45:
        v7 = *(__int64 **)(v4 + 16);
        v8 = 16LL;
        goto LABEL_14;
      }
      v3 -= v33 + 1;
      v34 = *(_DWORD *)(v4 + 48);
      if ( v34 < v3 )
      {
        v3 -= v34 + 1;
        if ( *(_DWORD *)(v4 + 52) < v3 )
          return 0LL;
LABEL_13:
        v7 = *(__int64 **)(v4 + 32);
        v8 = 32LL;
        goto LABEL_14;
      }
      goto LABEL_50;
    }
    v7 = *(__int64 **)(v4 + 8LL * v3 + 8);
    v8 = 8LL * v3 + 8;
LABEL_14:
    if ( !v7 )
      goto LABEL_19;
LABEL_15:
    v4 = (__int64)v7;
  }
  v9 = ((__int64 (__fastcall *)(__int64, _QWORD, signed __int64))a1[1])(a2, *(_QWORD *)(v4 + 56), v57);
  if ( v9 >= 0 )
  {
    if ( !v9 )
      return *(_QWORD *)(v4 + 56);
    if ( !*(_QWORD *)(v4 + 64) )
      goto LABEL_45;
    v5 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
    if ( v5 < 0 )
      goto LABEL_45;
    if ( !v5 )
      return *(_QWORD *)(v4 + 64);
    if ( *(_QWORD *)(v4 + 72) )
    {
      v6 = ((__int64 (__fastcall *)(__int64))a1[1])(a2);
      if ( v6 >= 0 )
      {
        if ( !v6 )
          return *(_QWORD *)(v4 + 72);
        goto LABEL_13;
      }
    }
LABEL_50:
    v7 = *(__int64 **)(v4 + 24);
    v8 = 24LL;
    goto LABEL_14;
  }
  v7 = *(__int64 **)(v4 + 8);
  v8 = 8LL;
  if ( v7 )
    goto LABEL_15;
LABEL_19:
  v10 = *(_QWORD *)(v4 + 64);
  v11 = v4 + v8;
  v12 = v4 + 8;
  if ( !v10 )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
LABEL_58:
    if ( v11 == v12 )
    {
      v47 = *(_DWORD *)(v28 + 44);
      v48 = *(_QWORD *)(v28 + 16);
      *(_QWORD *)(v28 + 8) = v29;
      *(_QWORD *)(v28 + 16) = v4;
      *(_DWORD *)(v28 + 48) = v47;
      v49 = *(_QWORD *)(v28 + 56);
      *(_QWORD *)(v28 + 24) = v48;
      *(_QWORD *)(v28 + 64) = v49;
      *(_DWORD *)(v28 + 44) = v59;
      *(_QWORD *)(v28 + 56) = v61;
      *(_DWORD *)(v28 + 40) = v60;
      v39 = v29;
      v29 = (_QWORD *)v4;
      v4 = v48;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = v4;
      *(_QWORD *)(v28 + 16) = v29;
      *(_DWORD *)(v28 + 48) = v59;
      *(_QWORD *)(v28 + 64) = v61;
      *(_DWORD *)(v28 + 44) = v60;
      v39 = *(_QWORD **)(v28 + 8);
    }
    goto LABEL_60;
  }
  if ( !*(_QWORD *)(v4 + 72) )
  {
    v28 = v4;
    v29 = 0LL;
    v4 = 0LL;
    v61 = a2;
    v59 = 0;
    v60 = 0;
    goto LABEL_78;
  }
  v61 = a2;
  v63 = a1;
  v62 = a2;
  v59 = 0;
  v13 = v11;
  v60 = 0;
  v14 = 0LL;
  v15 = v4 + 8;
  while ( 2 )
  {
    v29 = sub_2F450(1uLL, 0x50uLL, 0LL);
    *v29 = *(_QWORD *)v4;
    if ( v13 == v15 )
    {
      v29[1] = v7;
      v29[2] = v14;
      *((_DWORD *)v29 + 10) = v60;
      v29[7] = v61;
      *((_DWORD *)v29 + 11) = v59;
      v29[8] = *(_QWORD *)(v4 + 56);
      v29[3] = *(_QWORD *)(v4 + 16);
      v7 = *(__int64 **)(v4 + 24);
      *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 44);
      v30 = *(_QWORD *)(v4 + 64);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v30;
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v4 + 48);
      v19 = *(_QWORD *)(v4 + 72);
      goto LABEL_44;
    }
    v16 = *(_QWORD *)(v4 + 8);
    v17 = *(_DWORD *)(v4 + 40);
    v18 = *(_QWORD *)(v4 + 56);
    v19 = *(_QWORD *)(v4 + 72);
    if ( v13 == v4 + 16 )
    {
      v29[7] = v18;
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[2] = v7;
      v29[3] = v14;
      *((_DWORD *)v29 + 11) = v60;
      v7 = *(__int64 **)(v4 + 24);
      v29[8] = v61;
      *((_DWORD *)v29 + 12) = v59;
      v35 = *(_QWORD *)(v4 + 64);
      v36 = *(_DWORD *)(v4 + 48);
      *(_QWORD *)(v4 + 8) = v7;
      v61 = v35;
      *(_DWORD *)(v4 + 40) = v36;
LABEL_44:
      *(_QWORD *)(v4 + 56) = v19;
      v14 = *(__int64 **)(v4 + 32);
      v31 = *(_DWORD *)(v4 + 52);
      *(_QWORD *)(v4 + 16) = v14;
      *(_DWORD *)(v4 + 44) = v31;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 16);
      v21 = *(_DWORD *)(v4 + 44);
      v22 = *(_QWORD *)(v4 + 64);
      v29[1] = v16;
      *((_DWORD *)v29 + 10) = v17;
      v29[7] = v18;
      v29[2] = v20;
      *((_DWORD *)v29 + 11) = v21;
      v29[8] = v22;
      if ( v13 == v4 + 24 )
      {
        v29[3] = v7;
        v7 = v14;
        *((_DWORD *)v29 + 12) = v60;
        *(_QWORD *)(v4 + 56) = v19;
        v37 = *(_DWORD *)(v4 + 52);
        v38 = *(__int64 **)(v4 + 32);
        *(_QWORD *)(v4 + 8) = v14;
        *(_DWORD *)(v4 + 40) = v59;
        *(_DWORD *)(v4 + 44) = v37;
        *(_QWORD *)(v4 + 16) = v38;
        v14 = v38;
      }
      else
      {
        v29[3] = *(_QWORD *)(v4 + 24);
        *((_DWORD *)v29 + 12) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 40) = v60;
        v23 = v61;
        *(_QWORD *)(v4 + 8) = v7;
        *(_QWORD *)(v4 + 16) = v14;
        v61 = v19;
        *(_QWORD *)(v4 + 56) = v23;
        *(_DWORD *)(v4 + 44) = v59;
      }
    }
    *(_QWORD *)(v4 + 24) = 0LL;
    *(_QWORD *)(v4 + 32) = 0LL;
    v24 = (_QWORD *)v29[1];
    v29[4] = 0LL;
    *(_QWORD *)(v4 + 48) = 0LL;
    *((_DWORD *)v29 + 13) = 0;
    *(_QWORD *)(v4 + 64) = 0LL;
    *(_QWORD *)(v4 + 72) = 0LL;
    v29[9] = 0LL;
    if ( v24 )
      *v24 = v29;
    v25 = (_QWORD *)v29[2];
    if ( v25 )
      *v25 = v29;
    v26 = (_QWORD *)v29[3];
    if ( v26 )
      *v26 = v29;
    if ( v7 )
      *v7 = v4;
    if ( v14 )
      *v14 = v4;
    v60 = sub_99F90((__int64)v29);
    v27 = sub_99F90(v4);
    v28 = *(_QWORD *)v4;
    v59 = v27;
    if ( !*(_QWORD *)v4 )
    {
      v2 = v62;
      v45 = sub_2F450(1uLL, 0x50uLL, 0LL);
      *v63 = (__int64)v45;
      v45[1] = v29;
      v45[2] = v4;
      v45[8] = 0LL;
      *((_DWORD *)v45 + 10) = v60;
      v45[3] = 0LL;
      v45[9] = 0LL;
      v45[4] = 0LL;
      v45[6] = 0LL;
      v45[7] = v61;
      *v45 = 0LL;
      *((_DWORD *)v45 + 11) = v59;
      *v29 = v45;
      *(_QWORD *)v4 = v45;
      return v2;
    }
    v15 = v28 + 8;
    v13 = v28 + 8;
    if ( *(_QWORD *)(v28 + 8) != v4
      && (v13 = v28 + 16, *(_QWORD *)(v28 + 16) != v4)
      && (v13 = v28 + 32, *(_QWORD *)(v28 + 24) == v4) )
    {
      v10 = *(_QWORD *)(v28 + 64);
      v13 = v28 + 24;
      if ( !v10 )
      {
LABEL_57:
        v12 = v28 + 8;
        v11 = v13;
        v2 = v62;
        goto LABEL_58;
      }
    }
    else
    {
      v10 = *(_QWORD *)(v28 + 64);
      if ( !v10 )
        goto LABEL_57;
    }
    v7 = v29;
    v14 = (__int64 *)v4;
    if ( *(_QWORD *)(v28 + 72) )
    {
      v4 = *(_QWORD *)v4;
      continue;
    }
    break;
  }
  v12 = v28 + 8;
  v11 = v13;
  v2 = v62;
LABEL_78:
  if ( v11 == v12 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v50 = *(_DWORD *)(v28 + 44);
    v51 = *(_DWORD *)(v28 + 48);
    v52 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 8) = v29;
    *(_DWORD *)(v28 + 48) = v50;
    v53 = *(_QWORD *)(v28 + 56);
    *(_DWORD *)(v28 + 52) = v51;
    v54 = *(_QWORD **)(v28 + 16);
    *(_QWORD *)(v28 + 32) = v52;
    *(_QWORD *)(v28 + 16) = v4;
    *(_QWORD *)(v28 + 64) = v53;
    *(_QWORD *)(v28 + 24) = v54;
    *(_DWORD *)(v28 + 44) = v59;
    *(_QWORD *)(v28 + 56) = v61;
    *(_DWORD *)(v28 + 40) = v60;
    v39 = (_QWORD *)v4;
    v4 = v52;
    v46 = v29;
    v29 = v54;
  }
  else if ( v11 == v28 + 16 )
  {
    *(_QWORD *)(v28 + 72) = v10;
    v55 = *(_DWORD *)(v28 + 48);
    v56 = *(_QWORD *)(v28 + 24);
    *(_QWORD *)(v28 + 16) = v29;
    *(_QWORD *)(v28 + 24) = v4;
    *(_DWORD *)(v28 + 48) = v59;
    *(_DWORD *)(v28 + 52) = v55;
    *(_QWORD *)(v28 + 32) = v56;
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 64) = v61;
    *(_DWORD *)(v28 + 44) = v60;
    v39 = v29;
    v29 = (_QWORD *)v4;
    v4 = v56;
  }
  else
  {
    v46 = *(__int64 **)(v28 + 8);
    *(_QWORD *)(v28 + 32) = v4;
    *(_QWORD *)(v28 + 24) = v29;
    *(_DWORD *)(v28 + 52) = v59;
    *(_QWORD *)(v28 + 72) = v61;
    *(_DWORD *)(v28 + 48) = v60;
    v39 = *(_QWORD **)(v28 + 16);
  }
  if ( v46 )
    *v46 = v28;
LABEL_60:
  if ( v39 )
    *v39 = v28;
  if ( v29 )
    *v29 = v28;
  if ( v4 )
    *(_QWORD *)v4 = v28;
  if ( *(_QWORD *)v28 )
  {
    do
    {
      v40 = sub_99F90(v28);
      v43 = 0;
      if ( v42[1] != v41 )
      {
        v43 = 1;
        if ( v42[2] != v41 )
          v43 = (v42[3] != v41) + 2;
      }
      v28 = (__int64)v42;
      *((_DWORD *)v42 + v43 + 10) = v40;
    }
    while ( *v42 );
  }
  return v2;
}

__int64 __fastcall sub_9B010(__int64 *a1, signed int a2)
{
  __int64 v2; // rdx
  signed int v3; // eax
  signed int v4; // eax
  signed int v6; // eax

  if ( a2 < 0 || !*a1 || a2 >= (signed int)sub_99F90(*a1) )
    return 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v2 + 40);
      if ( v3 <= a2 )
        break;
      v2 = *(_QWORD *)(v2 + 8);
LABEL_6:
      if ( !v2 )
        return 0LL;
    }
    a2 -= v3 + 1;
    if ( a2 < 0 )
      return *(_QWORD *)(v2 + 56);
    v4 = *(_DWORD *)(v2 + 44);
    if ( v4 <= a2 )
      break;
    v2 = *(_QWORD *)(v2 + 16);
    if ( !v2 )
      return 0LL;
  }
  a2 -= v4 + 1;
  if ( a2 < 0 )
    return *(_QWORD *)(v2 + 64);
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 > a2 )
  {
    v2 = *(_QWORD *)(v2 + 24);
    goto LABEL_6;
  }
  a2 -= v6 + 1;
  if ( a2 >= 0 )
  {
    v2 = *(_QWORD *)(v2 + 32);
    goto LABEL_6;
  }
  return *(_QWORD *)(v2 + 72);
}

void __fastcall sub_9B0A0(__int64 a1, int a2)
{
  _QWORD *v2; // rcx
  int v3; // eax
  int v4; // esi
  int v5; // eax
  int v6; // edx
  int *v7; // rsi
  int v8; // er8
  int v9; // eax
  int v10; // eax
  __int64 v11; // rsi
  int v12; // edx
  __int64 v13; // r8
  _DWORD *v14; // rax
  signed __int64 v15; // rcx

  v2 = *(_QWORD **)(a1 + 32);
  if ( !v2 )
  {
    *(_QWORD *)a1 = 0LL;
    *(_DWORD *)(a1 + 8) = 0;
    return;
  }
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 == -1 )
  {
    v6 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 12) = 0;
  }
  else
  {
    if ( !a2 )
      __assert_fail("direction", "tree234.c", 0x27Fu, "search234_step");
    if ( a2 <= 0 )
    {
      v4 = v3 - 1;
      v5 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = v4;
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 16);
      v5 = v3 + 1;
      *(_DWORD *)(a1 + 12) = v5;
    }
    v6 = *(_DWORD *)(a1 + 24);
    if ( v5 <= v4 )
      goto LABEL_18;
    if ( v5 > 0 )
    {
      v7 = (int *)(v2 + 5);
      do
      {
        v8 = *v7;
        ++v7;
        v6 += v8 + 1;
      }
      while ( v7 != (int *)((char *)v2 + 4 * (unsigned int)(v5 - 1) + 44) );
      *(_DWORD *)(a1 + 24) = v6;
    }
    v2 = (_QWORD *)v2[v5 + 1];
    *(_DWORD *)(a1 + 20) = -1;
    *(_DWORD *)(a1 + 12) = 0;
    *(_QWORD *)(a1 + 32) = v2;
    if ( !v2 )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_QWORD *)a1 = 0LL;
      *(_DWORD *)(a1 + 8) = v6;
      return;
    }
  }
  v9 = -1;
  if ( v2[7] )
  {
    if ( v2[8] )
      v9 = (v2[9] != 0LL) + 1;
    else
      v9 = 0;
  }
  *(_DWORD *)(a1 + 16) = v9;
LABEL_18:
  v10 = (*(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 16)) / 2;
  v11 = v10;
  v12 = v10 + v6;
  v13 = v2[v10 + 7];
  *(_DWORD *)(a1 + 20) = v10;
  *(_DWORD *)(a1 + 8) = v12;
  *(_QWORD *)a1 = v13;
  if ( v10 >= 0 )
  {
    v14 = v2 + 5;
    v15 = (signed __int64)v2 + 4 * v11 + 44;
    do
    {
      v12 += *v14;
      ++v14;
    }
    while ( v14 != (_DWORD *)v15 );
    *(_DWORD *)(a1 + 8) = v12;
  }
}

void __fastcall sub_9B200(__int64 a1, _QWORD *a2)
{
  *(_QWORD *)(a1 + 32) = *a2;
  *(_QWORD *)(a1 + 20) = 0xFFFFFFFFLL;
  sub_9B0A0(a1, 0);
}

__int64 __fastcall sub_9B220(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64), int a4, _DWORD *a5)
{
  int v5; // er15
  signed int v6; // er13
  __int64 (__fastcall *v7)(__int64); // rbp
  __int64 v8; // rbx
  int v9; // esi
  signed int v10; // ecx
  __int64 result; // rax
  int v12; // ecx
  _DWORD *v13; // [rsp+10h] [rbp-78h]
  unsigned int v14; // [rsp+18h] [rbp-70h]
  __int64 v15; // [rsp+20h] [rbp-68h]
  int v16; // [rsp+28h] [rbp-60h]
  __int64 v17; // [rsp+34h] [rbp-54h]
  __int64 v18; // [rsp+40h] [rbp-48h]
  unsigned __int64 v19; // [rsp+48h] [rbp-40h]

  v5 = a4;
  v6 = -1;
  v7 = a3;
  v8 = a2;
  v19 = __readfsqword(0x28u);
  v13 = a5;
  v14 = a4 - 1;
  if ( (unsigned int)(a4 - 1) > 1 )
    v6 = (unsigned int)(a4 - 3) <= 1;
  if ( (a4 & 0xFFFFFFFD) != 1 && !a2 )
    goto LABEL_30;
  if ( !a3 )
    v7 = (__int64 (__fastcall *)(__int64))a1[1];
  v18 = *a1;
  v17 = 0xFFFFFFFFLL;
  sub_9B0A0((__int64)&v15, 0);
  if ( !v15 )
  {
LABEL_14:
    if ( v5 )
    {
      v10 = v16;
      if ( v14 <= 1 )
        v10 = v16-- - 1;
      result = sub_9B010(a1, v10);
      if ( result )
      {
        if ( v13 )
          *v13 = v12;
      }
    }
    else
    {
      result = 0LL;
    }
    goto LABEL_20;
  }
  while ( 1 )
  {
    if ( v8 )
      v9 = v7(v8);
    else
      v9 = -v6;
    if ( v9 )
      goto LABEL_13;
    if ( (v5 & 0xFFFFFFFD) != 1 )
      break;
    v9 = v6;
LABEL_13:
    sub_9B0A0((__int64)&v15, v9);
    if ( !v15 )
      goto LABEL_14;
  }
  if ( v13 )
    *v13 = v16;
  result = v15;
LABEL_20:
  if ( __readfsqword(0x28u) != v19 )
LABEL_30:
    __assert_fail("!(equal_permitted && !e)", "tree234.c", 0x219u, "findrelpos234");
  return result;
}

__int64 __fastcall sub_9B3D0(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64))
{
  return sub_9B220(a1, a2, a3, 0, 0LL);
}

__int64 __fastcall sub_9B3E0(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64), int a4)
{
  return sub_9B220(a1, a2, a3, a4, 0LL);
}

__int64 __fastcall sub_9B3F0(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64), _DWORD *a4)
{
  return sub_9B220(a1, a2, a3, 0, a4);
}

__int64 __fastcall sub_9B400(__int64 *a1, int a2)
{
  __int64 v2; // rdi
  void **v3; // rdx

  if ( a2 < 0 )
    return 0LL;
  v2 = *a1;
  if ( !v2 )
    return 0LL;
  if ( a2 >= (signed int)sub_99F90(v2) )
    return 0LL;
  return sub_9A740(v3, a2);
}

__int64 __fastcall sub_9B440(__int64 *a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  result = sub_9B220(a1, a2, 0LL, 0, &v3);
  if ( result )
    result = sub_9A740((void **)a1, v3);
  return result;
}

__int64 __fastcall sub_9B4A0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdi
  __int64 result; // rax

  if ( a4 == 1 )
  {
    v4 = *(_QWORD *)(a1 + 32);
    JUMPOUT(qword_3264B8, 0LL, sub_A3238);
    result = gtk_widget_grab_focus(qword_3264B8);
  }
  return result;
}

__int64 __fastcall sub_9B4A0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdi
  __int64 result; // rax

  if ( a4 == 1 )
  {
    v4 = *(_QWORD *)(a1 + 32);
    JUMPOUT(qword_3264B8, 0LL, sub_A3238);
    result = gtk_widget_grab_focus(qword_3264B8);
  }
  return result;
}

__int64 __fastcall sub_9B4C0(unsigned __int64 *a1, char a2, __int64 a3)
{
  char v3; // r12
  unsigned __int64 *v4; // rbx
  __int64 v5; // r13
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdi
  unsigned __int64 v10; // rax
  _DWORD *v11; // rdx
  __int64 v12; // rax
  unsigned __int64 v13; // r8
  _QWORD *v14; // r13
  _QWORD *v15; // r9
  signed __int64 v16; // rax
  signed __int64 v17; // rcx
  __int64 v18; // r13
  __int64 v19; // r14
  __int64 v20; // rax
  __int64 v21; // r15
  __int64 v22; // rax
  __int64 v23; // r13
  __int64 v24; // r15
  __int64 v25; // rax
  __int64 v26; // r15
  __int64 v27; // rax
  __int64 v28; // r14
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // r15
  __int64 v32; // r14
  __int64 v33; // rax
  __int64 v34; // r13
  __int64 v35; // r15
  __int64 v36; // rax
  __int64 result; // rax
  __int64 v38; // rbx
  __int64 v39; // r12
  __int64 v40; // rbp
  __int64 v41; // rax
  __int64 v42; // ST00_8
  __int64 v43; // rbp
  __int64 v44; // r13
  __int64 v45; // rbp
  __int64 v46; // rax
  signed __int64 v47; // r14
  __int64 v48; // r15
  _QWORD *v49; // rdi
  signed __int64 v50; // rsi

  v3 = a2;
  v4 = a1;
  if ( !a2 )
  {
    v43 = a3;
    v44 = sub_28A10(a1, &locale, &locale, &locale);
    v45 = sub_28770(v43);
    v46 = sub_28770(0LL);
    *(_DWORD *)(sub_290C0(v44, "About", 97, v46, (__int64)sub_9B4A0, v45) + 20) = 0;
  }
  v5 = sub_28A10(a1, "Window", "scrollback", "Control the scrollback in the window");
  v6 = sub_28760(0xC3u);
  v7 = sub_28770(0LL);
  sub_29380(v5, "Scrollbar on left", 108, v7, (__int64)sub_1FF00, v6);
  v8 = *(_QWORD *)(v5 + 32);
  if ( v8 )
  {
    v9 = *(_QWORD *)(v5 + 48);
    v10 = 0LL;
    while ( 1 )
    {
      v11 = *(_DWORD **)(v9 + 8 * v10);
      if ( *v11 == 3 && v11[8] == 117 )
        break;
      if ( v8 == ++v10 )
        goto LABEL_10;
    }
    if ( v10 < v8 - 2 )
    {
      v47 = v10 + 1;
      v48 = *(_QWORD *)(v9 + 8 * v8 - 8);
      memmove((void *)(v9 + 8 * (v10 + 1) + 8), (const void *)(v9 + 8 * (v10 + 1)), 8 * (v8 - v10) - 16);
      *(_QWORD *)(*(_QWORD *)(v5 + 48) + 8 * v47) = v48;
    }
  }
LABEL_10:
  v12 = sub_28A10(v4, "Window/Appearance", "font", "Font settings");
  v13 = *v4;
  v14 = (_QWORD *)v12;
  if ( *v4 )
  {
    v15 = (_QWORD *)v4[2];
    v16 = 1LL;
    v17 = (signed __int64)(v15 + 1);
    if ( (_QWORD *)*v15 == v14 )
    {
      v49 = (_QWORD *)v4[2];
      v50 = 1LL;
LABEL_20:
      memmove(v49, &v15[v50], 8 * v13 - 8);
      --*v4;
      sub_29470(v14);
    }
    else
    {
      while ( v13 != v16 )
      {
        v49 = (_QWORD *)v17;
        v17 += 8LL;
        if ( (_QWORD *)*v49 == v14 )
        {
          v50 = v16 + 1;
          v13 -= v16;
          goto LABEL_20;
        }
        ++v16;
      }
    }
  }
  sub_28930(v4, "Window/Fonts", "Options controlling font usage");
  v18 = sub_28A10(v4, "Window/Fonts", "font", "Fonts for displaying non-bold text");
  v19 = sub_28760(0x7Du);
  v20 = sub_28770(0LL);
  sub_292F0(v18, "Font used for ordinary text", 102, v20, (__int64)sub_201D0, v19);
  v21 = sub_28760(0xC6u);
  v22 = sub_28770(0LL);
  sub_292F0(v18, "Font used for wide (CJK) text", 119, v22, (__int64)sub_201D0, v21);
  v23 = sub_28A10(v4, "Window/Fonts", "fontbold", "Fonts for displaying bolded text");
  v24 = sub_28760(0xC5u);
  v25 = sub_28770(0LL);
  sub_292F0(v23, "Font used for bolded text", 98, v25, (__int64)sub_201D0, v24);
  v26 = sub_28760(0xC7u);
  v27 = sub_28770(0LL);
  sub_292F0(v23, "Font used for bold wide text", 105, v27, (__int64)sub_201D0, v26);
  v28 = sub_28760(0xC4u);
  v29 = sub_28770(0LL);
  sub_29380(v23, "Use shadow bold instead of bold fonts", 117, v29, (__int64)sub_1FF00, v28);
  v30 = sub_28770(0LL);
  sub_29350(
    v23,
    "(Note that bold fonts or shadow bolding are only used if you have not requested bolding to be done by changing the text colour.)",
    v30);
  v31 = sub_28760(0xFFFFFFFF);
  v32 = sub_28760(0xC8u);
  v33 = sub_28770(0LL);
  sub_28D60(v23, "Horizontal offset for shadow bold:", 122, 20, v33, (__int64)sub_1FF90, v32, v31);
  v34 = sub_28A10(v4, "Window/Translation", "trans", "Character set translation on received data");
  v35 = sub_28760(0xA6u);
  v36 = sub_28770(0LL);
  result = sub_29380(v34, "Override with UTF-8 if locale says so", 108, v36, (__int64)sub_1FF00, v35);
  if ( !v3 )
  {
    v38 = sub_28A10(v4, "Window/Behaviour", "x11", "X Window System settings");
    v39 = sub_28760(1u);
    v40 = sub_28760(0xCAu);
    v41 = sub_28770(0LL);
    sub_28D60(v38, "Window class name:", 122, 50, v41, (__int64)sub_1FF90, v40, v39);
    result = v42;
  }
  return result;
}

__int64 __fastcall j__gtk_widget_get_type(__int64 a1, __int64 a2)
{
  return gtk_widget_get_type(a1, a2);
}

__int64 __fastcall sub_9B940(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 result; // rax

  v2 = gtk_widget_get_type(a1, a2);
  v3 = g_type_check_instance_cast(a1, v2);
  result = gtk_widget_set_has_window(v3, 0LL);
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 56) = 0;
  return result;
}

__int64 (__fastcall *__fastcall sub_9B970(__int64 a1))()
{
  __int64 v1; // r13
  __int64 v2; // rax
  _QWORD *v3; // rbx
  __int64 v4; // rax
  _QWORD *v5; // rbp
  bool v6; // zf
  __int64 (__fastcall *result)(); // rax

  v1 = g_type_check_class_cast(a1, 80LL);
  v2 = gtk_widget_get_type(a1, 80LL);
  v3 = (_QWORD *)g_type_check_class_cast(a1, v2);
  v4 = gtk_container_get_type(a1);
  v5 = (_QWORD *)g_type_check_class_cast(a1, v4);
  qword_3264A0 = g_type_class_peek_parent(a1);
  v6 = qword_326498 == 0LL;
  *(_QWORD *)(v1 + 48) = sub_9D0B0;
  v3[23] = sub_9CFB0;
  v3[24] = sub_9CEB0;
  v3[40] = sub_9CDF0;
  v3[38] = sub_9CD30;
  v3[39] = sub_9CC60;
  v3[41] = sub_9CB80;
  v3[27] = sub_9C9C0;
  v5[103] = sub_9D460;
  v5[104] = sub_9C7E0;
  v5[106] = sub_9C720;
  v5[108] = j__gtk_widget_get_type;
  if ( v6 )
    qword_326498 = (__int64 (__fastcall *)(_QWORD, _QWORD))v3[44];
  result = (__int64 (__fastcall *)())sub_9C490;
  v3[44] = sub_9C490;
  return result;
}

__int64 __fastcall sub_9BAA0(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 40) )
    ((void (*)(void))g_free)();
  return g_free(a1);
}

__int64 __fastcall sub_9BAC0(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  unsigned int v4; // [rsp+4h] [rbp-14h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v1 = *((unsigned int *)a1 + 14);
  v2 = *a1;
  v5 = __readfsqword(0x28u);
  gtk_widget_get_preferred_height_for_width(v2, v1, &v4, 0LL);
  return v4;
}

__int64 __fastcall sub_9BB10(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  unsigned int v4; // [rsp+4h] [rbp-14h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v1 = *((unsigned int *)a1 + 14);
  v2 = *a1;
  v5 = __readfsqword(0x28u);
  gtk_widget_get_preferred_height_for_width(v2, v1, 0LL, &v4);
  return v4;
}

__int64 __fastcall sub_9BB60(__int64 *a1)
{
  __int64 v1; // rdi
  unsigned int v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v1 = *a1;
  v4 = __readfsqword(0x28u);
  gtk_widget_get_preferred_width(v1, &v3, 0LL);
  return v3;
}

__int64 __fastcall sub_9BBB0(__int64 a1, int a2, __int64 (__fastcall *a3)(__int64))
{
  int v3; // er12
  __int64 v4; // rbp
  __int64 v5; // rax
  signed __int64 v6; // rsi
  __int64 v7; // rax
  int v8; // ebx
  _DWORD *v9; // rax
  __int64 *v10; // r15
  _DWORD *v11; // r14
  int v12; // er12
  __int64 v13; // rbx
  signed int v14; // er13
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  bool v18; // zf
  __int64 v19; // r11
  int v20; // edi
  __int64 (__fastcall *v22)(__int64); // [rsp+8h] [rbp-40h]

  v3 = a2;
  v4 = a1;
  v22 = a3;
  v5 = gtk_container_get_type(a1);
  v6 = v5;
  v7 = g_type_check_instance_cast(a1, v5);
  v8 = gtk_container_get_border_width(v7, v6);
  v9 = (_DWORD *)g_malloc(8LL);
  v10 = *(__int64 **)(a1 + 40);
  v11 = v9;
  *v9 = 0;
  v12 = v3 - 2 * v8;
  v9[1] = v12 + *(_DWORD *)(a1 + 56);
  if ( v10 )
  {
    v13 = *v10;
    if ( *v10 )
    {
      v14 = 1;
      while ( !*(_QWORD *)v13 )
      {
        v14 = *(_DWORD *)(v13 + 32);
        v6 = v14 + 1;
        v11 = (_DWORD *)g_realloc_n(v11, v6, 4LL);
        *v11 = 0;
        if ( v14 <= 0 )
          goto LABEL_10;
        v19 = *(_QWORD *)(v13 + 40);
        v6 = 0LL;
        v20 = 0;
        do
        {
          v20 += *(_DWORD *)(v19 + v6);
          *(_DWORD *)((char *)v11 + v6 + 4) = v20 * (v12 + *(_DWORD *)(v4 + 56)) / 100;
          v6 += 4LL;
        }
        while ( 4LL * (unsigned int)(v14 - 1) + 4 != v6 );
        v10 = (__int64 *)v10[1];
        if ( !v10 )
          return g_free(v11);
LABEL_11:
        v13 = *v10;
        if ( !*v10 )
          return g_free(v11);
      }
      if ( (unsigned int)gtk_widget_get_visible(*(_QWORD *)v13, v6) )
      {
        v15 = v22(v13);
        v16 = *(_DWORD *)(v13 + 12);
        v17 = *(_DWORD *)(v13 + 8);
        if ( !v16 )
          v16 = v14 - v17;
        v18 = *(_BYTE *)(v13 + 16) == 0;
        v6 = (signed __int64)&v11[v17];
        *(_DWORD *)(v13 + 48) = *(_DWORD *)v6;
        if ( v18 )
          v15 = v11[v17 + v16] - *(_DWORD *)v6 - *(_DWORD *)(v4 + 56);
        *(_DWORD *)(v13 + 56) = v15;
      }
LABEL_10:
      v10 = (__int64 *)v10[1];
      if ( !v10 )
        return g_free(v11);
      goto LABEL_11;
    }
  }
  return g_free(v11);
}

__int64 __fastcall sub_9BD30(__int64 a1, __int64 (__fastcall *a2)(__int64))
{
  __int64 v2; // r12
  __int64 (__fastcall *v3)(__int64); // r13
  int v4; // ebp
  signed __int64 v5; // rdi
  _DWORD *v6; // rax
  __int64 *v7; // rbx
  _DWORD *v8; // r15
  __int64 v9; // r14
  unsigned int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdi
  unsigned int v14; // er8
  int v15; // ST08_4
  int v16; // eax
  int v17; // er9
  __int64 v18; // r10
  int *v19; // rcx
  int v20; // edx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // edx
  int v25; // eax
  __int64 v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rax
  unsigned int v29; // ebx
  _DWORD *v31; // rax
  __int64 v32; // rax
  signed __int64 v33; // rax
  signed int v34; // [rsp+Ch] [rbp-3Ch]

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 56);
  v5 = 4LL;
  v6 = (_DWORD *)g_malloc(4LL);
  v7 = *(__int64 **)(v2 + 40);
  v8 = v6;
  *v6 = 0;
  if ( v7 )
  {
    v9 = *v7;
    if ( *v7 )
    {
      v34 = 1;
      do
      {
        v5 = *(_QWORD *)v9;
        if ( *(_QWORD *)v9 )
        {
          if ( (unsigned int)gtk_widget_get_visible(v5, a2) )
          {
            v10 = v3(v9);
            v13 = *(_QWORD *)(v9 + 24);
            v14 = v10;
            if ( v13 )
            {
              v15 = v10;
              v16 = ((__int64 (__fastcall *)(__int64, __int64 (__fastcall *)(__int64), __int64, __int64, _QWORD))v3)(
                      v13,
                      a2,
                      v11,
                      v12,
                      v10);
              v14 = v15;
              if ( v15 < v16 )
                v14 = v16;
            }
            v5 = *(unsigned int *)(v9 + 12);
            if ( !(_DWORD)v5 )
              v5 = (unsigned int)(v34 - *(_DWORD *)(v9 + 8));
            v17 = *(_DWORD *)(v2 + 56);
            if ( (signed int)v5 <= 0 )
            {
              v23 = v14 + v17;
            }
            else
            {
              v18 = *(signed int *)(v9 + 8);
              v19 = &v8[v18];
              v20 = *(_DWORD *)(v9 + 8);
              v21 = 0;
              do
              {
                if ( v21 < *v19 )
                  v21 = *v19;
                ++v19;
              }
              while ( v19 != &v8[v18 + 1 + (unsigned int)(v5 - 1)] );
              v22 = 0;
              v23 = v17 + v14 + v21;
              while ( 1 )
              {
                v24 = v22++ + v20;
                v8[v24] = v23;
                if ( (_DWORD)v5 == v22 )
                  break;
                v20 = *(_DWORD *)(v9 + 8);
              }
              v17 = *(_DWORD *)(v2 + 56);
            }
            v25 = v23 - v17;
            if ( v4 < v25 )
              v4 = v25;
          }
        }
        else
        {
          if ( v34 > 1 )
          {
            v31 = v8 + 1;
            do
            {
              if ( *v8 < *v31 )
                *v8 = *v31;
              ++v31;
            }
            while ( &v8[v34 - 2 + 2] != v31 );
          }
          a2 = (__int64 (__fastcall *)(__int64))*(signed int *)(v9 + 32);
          v5 = (signed __int64)v8;
          v34 = *(_DWORD *)(v9 + 32);
          v32 = g_realloc_n(v8, a2, 4LL);
          v8 = (_DWORD *)v32;
          if ( (signed int)a2 > 1 )
          {
            v33 = v32 + 4;
            do
            {
              v33 += 4LL;
              *(_DWORD *)(v33 - 4) = *v8;
            }
            while ( &v8[(_DWORD)a2 - 2 + 2] != (_DWORD *)v33 );
          }
        }
        v7 = (__int64 *)v7[1];
        if ( !v7 )
          break;
        v9 = *v7;
      }
      while ( *v7 );
    }
  }
  v26 = gtk_container_get_type(v5);
  v27 = v26;
  v28 = g_type_check_instance_cast(v2, v26);
  v29 = v4 + 2 * (unsigned __int64)gtk_container_get_border_width(v28, v27);
  g_free(v8);
  return v29;
}

__int64 __fastcall sub_9BF10(_QWORD *a1)
{
  _QWORD *v1; // r12
  _QWORD **v2; // rbx
  __int64 v3; // rax
  _QWORD *v4; // rbp
  __int64 v5; // r13
  __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // rsi
  unsigned int v10; // [rsp+4h] [rbp-34h]
  unsigned __int64 v11; // [rsp+8h] [rbp-30h]

  v1 = a1;
  v2 = (_QWORD **)*a1;
  v11 = __readfsqword(0x28u);
  v3 = gtk_label_get_type(a1);
  if ( v2 )
  {
    v4 = *v2;
    v5 = v3;
    if ( !*v2 || *v4 != v3 )
    {
      v6 = v3;
      if ( !(unsigned int)g_type_check_instance_is_a(v2, v3) )
      {
        v8 = gtk_entry_get_type(v2, v6);
LABEL_8:
        if ( (!v4 || *v4 != v8) && !(unsigned int)g_type_check_instance_is_a(v2, v8) )
          goto LABEL_11;
LABEL_14:
        gtk_widget_get_preferred_width(*v1, &v10, 0LL);
        return v10;
      }
    }
    v7 = g_type_check_instance_cast(v2, v5);
    if ( (unsigned int)gtk_label_get_line_wrap(v7, v5) )
      goto LABEL_14;
    v2 = (_QWORD **)*v1;
    v8 = gtk_entry_get_type(v7, v5);
    if ( v2 )
    {
      v4 = *v2;
      goto LABEL_8;
    }
  }
LABEL_11:
  gtk_widget_get_preferred_width(v2, 0LL, &v10);
  return v10;
}

__int64 __fastcall sub_9C000(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  unsigned int v4; // [rsp+4h] [rbp-14h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v1 = *((unsigned int *)a1 + 15);
  v2 = *a1;
  v5 = __readfsqword(0x28u);
  gtk_widget_get_preferred_width_for_height(v2, v1, 0LL, &v4);
  return v4;
}

__int64 __fastcall sub_9C050(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  unsigned int v4; // [rsp+4h] [rbp-14h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v1 = *((unsigned int *)a1 + 15);
  v2 = *a1;
  v5 = __readfsqword(0x28u);
  gtk_widget_get_preferred_width_for_height(v2, v1, &v4, 0LL);
  return v4;
}

__int64 __fastcall sub_9C0A0(__int64 *a1)
{
  __int64 v1; // rdi
  unsigned int v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v1 = *a1;
  v4 = __readfsqword(0x28u);
  gtk_widget_get_preferred_height(v1, 0LL, &v3);
  return v3;
}

__int64 __fastcall sub_9C0F0(__int64 *a1)
{
  __int64 v1; // rdi
  unsigned int v3; // [rsp+4h] [rbp-14h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v1 = *a1;
  v4 = __readfsqword(0x28u);
  gtk_widget_get_preferred_height(v1, &v3, 0LL);
  return v3;
}

__int64 __fastcall sub_9C140(__int64 a1, __int64 (__fastcall *a2)(__int64 *))
{
  __int64 v2; // r12
  __int64 *v3; // r14
  __int64 v4; // r15
  void **v5; // rbp
  int v6; // ebx
  int v7; // eax
  int v8; // ecx
  __int64 v9; // rdi
  _DWORD *v10; // rdx
  signed __int64 v11; // rdi
  int v12; // ecx
  int v13; // eax
  __int64 v14; // rax
  __int64 v15; // rsi
  __int64 v16; // rax
  signed int v18; // [rsp+Ch] [rbp-3Ch]

  v2 = a1;
  v3 = *(__int64 **)(a1 + 40);
  if ( v3 && (v4 = *v3) != 0 )
  {
    v5 = &off_F6028;
    v6 = 0;
    v18 = 1;
    do
    {
      a1 = *(_QWORD *)v4;
      if ( *(_QWORD *)v4 )
      {
        if ( (unsigned int)gtk_widget_get_visible(a1, a2) )
        {
          v7 = a2((__int64 *)v4);
          v8 = *(_DWORD *)(v4 + 12);
          if ( !v8 )
            v8 = v18 - *(_DWORD *)(v4 + 8);
          if ( v8 <= 0 )
            __assert_fail("colspan > 0", "unix/gtkcols.c", 0x29Au, "columns_compute_width");
          v9 = *(signed int *)(v4 + 8);
          v10 = (_DWORD *)((char *)v5 + 4 * v9);
          v11 = (signed __int64)v5 + 4 * (v9 + (unsigned int)(v8 - 1)) + 4;
          v12 = 0;
          do
          {
            v12 += *v10;
            ++v10;
          }
          while ( (_DWORD *)v11 != v10 );
          a1 = *(unsigned int *)(v2 + 56);
          v13 = (v12 + 100 * ((signed int)a1 + v7) - 1) / v12 - a1;
          if ( v6 < v13 )
            v6 = v13;
        }
      }
      else
      {
        v5 = *(void ***)(v4 + 40);
        v18 = *(_DWORD *)(v4 + 32);
      }
      v3 = (__int64 *)v3[1];
      if ( !v3 )
        break;
      v4 = *v3;
    }
    while ( *v3 );
  }
  else
  {
    v6 = 0;
  }
  v14 = gtk_container_get_type(a1);
  v15 = v14;
  v16 = g_type_check_instance_cast(v2, v14);
  return v6 + 2 * (unsigned int)gtk_container_get_border_width(v16, v15);
}

__int64 __fastcall sub_9C270(__int64 a1, __int64 (*a2)(void))
{
  __int64 (*v2)(void); // rbp
  _DWORD *v3; // rax
  __int64 *v4; // rbx
  _DWORD *v5; // r13
  __int64 v6; // r14
  signed int v7; // er12
  int v8; // eax
  int v9; // er15
  int v10; // er8
  int v11; // er9
  int v12; // er10
  __int64 v13; // rdi
  int *v14; // rcx
  int v15; // edx
  int v16; // esi
  int v17; // ecx
  int v18; // edx
  _DWORD *v20; // rax
  __int64 v21; // rax
  signed __int64 v22; // rax
  __int64 v23; // [rsp+8h] [rbp-40h]

  v2 = a2;
  v23 = a1;
  v3 = (_DWORD *)g_malloc(4LL);
  v4 = *(__int64 **)(a1 + 40);
  v5 = v3;
  *v3 = 0;
  if ( v4 )
  {
    v6 = *v4;
    if ( *v4 )
    {
      v7 = 1;
      do
      {
        if ( *(_QWORD *)v6 )
        {
          if ( (unsigned int)gtk_widget_get_visible(*(_QWORD *)v6, a2) )
          {
            v8 = ((__int64 (__fastcall *)(__int64))v2)(v6);
            v9 = v8;
            if ( *(_QWORD *)(v6 + 24) )
            {
              v8 = v2();
              if ( v9 >= v8 )
                v8 = v9;
            }
            v10 = *(_DWORD *)(v6 + 12);
            if ( !v10 )
              v10 = v7 - *(_DWORD *)(v6 + 8);
            v11 = v8 / 2;
            v12 = v9 / -2;
            if ( v10 <= 0 )
            {
              *(_DWORD *)(v6 + 60) = v9;
              *(_DWORD *)(v6 + 52) = v12 + v11;
            }
            else
            {
              v13 = *(signed int *)(v6 + 8);
              v14 = &v5[v13];
              v15 = *(_DWORD *)(v6 + 8);
              v16 = 0;
              do
              {
                if ( v16 < *v14 )
                  v16 = *v14;
                ++v14;
              }
              while ( v14 != &v5[v13 + 1 + (unsigned int)(v10 - 1)] );
              *(_DWORD *)(v6 + 60) = v9;
              v17 = 0;
              *(_DWORD *)(v6 + 52) = v16 + v11 + v12;
              a2 = (__int64 (*)(void))(unsigned int)(*(_DWORD *)(v23 + 56) + v8 + v16);
              while ( 1 )
              {
                v18 = v17++ + v15;
                v5[v18] = (_DWORD)a2;
                if ( v10 == v17 )
                  break;
                v15 = *(_DWORD *)(v6 + 8);
              }
            }
          }
        }
        else
        {
          if ( v7 > 1 )
          {
            v20 = v5 + 1;
            do
            {
              if ( *v5 < *v20 )
                *v5 = *v20;
              ++v20;
            }
            while ( &v5[v7 - 2 + 2] != v20 );
          }
          a2 = (__int64 (*)(void))*(signed int *)(v6 + 32);
          v7 = *(_DWORD *)(v6 + 32);
          v21 = g_realloc_n(v5, a2, 4LL);
          v5 = (_DWORD *)v21;
          if ( v7 > 1 )
          {
            v22 = v21 + 4;
            do
            {
              v22 += 4LL;
              *(_DWORD *)(v22 - 4) = *v5;
            }
            while ( &v5[v7 - 2 + 2] != (_DWORD *)v22 );
          }
        }
        v4 = (__int64 *)v4[1];
        if ( !v4 )
          break;
        v6 = *v4;
      }
      while ( *v4 );
    }
  }
  return g_free(v5);
}

__int64 __fastcall sub_9C450(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rax

  result = qword_326490;
  if ( !qword_326490 )
  {
    v2 = gtk_container_get_type(a1);
    result = g_type_register_static(v2, "Columns", &off_322460, 0LL);
    qword_326490 = result;
  }
  return result;
}

__int64 __fastcall sub_9C490(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // rbx
  unsigned int v3; // er13
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // r12
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 v15; // rax
  _QWORD *v16; // r15
  __int64 v17; // rax
  __int64 v18; // rsi
  __int64 v19; // rbx
  __int64 v20; // rax
  _QWORD *v21; // rbp
  _QWORD *v22; // rdi
  __int64 v23; // rax

  if ( a1 )
  {
    v2 = a1;
    v3 = a2;
    v4 = sub_9C450((__int64)a1);
    if ( (!*a1 || *(_QWORD *)*a1 != v4) && !(unsigned int)g_type_check_instance_is_a(a1, v4) )
    {
      g_return_if_fail_warning(0LL, "columns_focus", "IS_COLUMNS(super)");
      return 0LL;
    }
    v6 = sub_9C450((__int64)a1);
    v7 = g_type_check_instance_cast(a1, v6);
    v8 = gtk_widget_get_type(a1, v6);
    v9 = g_type_check_instance_cast(v7, v8);
    if ( !(unsigned int)gtk_widget_is_drawable(v9, v8) )
      goto LABEL_7;
    v10 = g_type_check_instance_cast(v7, v8);
    if ( !(unsigned int)gtk_widget_is_sensitive(v10, v8) )
      goto LABEL_7;
    v11 = g_type_check_instance_cast(v7, v8);
    v12 = gtk_widget_get_can_focus(v11, v8);
    if ( v3 > 1 || v12 )
      return qword_326498(v2, v3);
    v13 = gtk_container_get_type(v11);
    v14 = v13;
    v15 = g_type_check_instance_cast(v7, v13);
    v16 = (_QWORD *)gtk_container_get_focus_child(v15, v13);
    v17 = g_type_check_instance_cast(v7, v13);
    v18 = 0LL;
    gtk_container_set_focus_child(v17, 0LL);
    v19 = v3 ? g_list_last(*(_QWORD *)(v7 + 48)) : *(_QWORD *)(v7 + 48);
    if ( v19 )
    {
      while ( 1 )
      {
        v21 = *(_QWORD **)v19;
        if ( !v16 )
          goto LABEL_31;
        if ( v16 == v21 )
          break;
        v20 = *(_QWORD *)(v19 + 8);
        if ( v3 )
          v20 = *(_QWORD *)(v19 + 16);
        v19 = v20;
        if ( !v20 )
          goto LABEL_7;
      }
      if ( (unsigned int)gtk_widget_is_drawable(v16, 0LL) )
      {
        if ( *v16 && v14 == *(_QWORD *)*v16 || (v18 = v14, (unsigned int)g_type_check_instance_is_a(v16, v14)) )
        {
          v18 = v8;
          v22 = v16;
          if ( !(unsigned int)gtk_widget_has_focus(v16) )
            goto LABEL_37;
        }
      }
      do
      {
        while ( 1 )
        {
          do
          {
            if ( v3 )
            {
              v19 = *(_QWORD *)(v19 + 16);
              if ( !v19 )
                goto LABEL_7;
            }
            else
            {
              v19 = *(_QWORD *)(v19 + 8);
              if ( !v19 )
                goto LABEL_7;
            }
            v21 = *(_QWORD **)v19;
LABEL_31:
            ;
          }
          while ( !(unsigned int)gtk_widget_is_drawable(v21, v18) );
          if ( !v21 )
            break;
          if ( !*v21 || v14 != *(_QWORD *)*v21 )
          {
            v18 = v14;
            if ( !(unsigned int)g_type_check_instance_is_a(v21, v14) )
              break;
          }
          v18 = v8;
          v22 = v21;
LABEL_37:
          v23 = g_type_check_instance_cast(v22, v18);
          v18 = v3;
          if ( (unsigned int)gtk_widget_child_focus(v23, v3) )
            goto LABEL_38;
        }
      }
      while ( !(unsigned int)gtk_widget_get_can_focus(v21, v18) );
      gtk_widget_grab_focus(v21);
LABEL_38:
      result = 1LL;
    }
    else
    {
LABEL_7:
      result = 0LL;
    }
  }
  else
  {
    g_return_if_fail_warning(0LL, "columns_focus", "super != NULL");
    result = 0LL;
  }
  return result;
}

_QWORD *__fastcall sub_9C720(_QWORD *a1, __int64 a2, __int64 (__fastcall *a3)(_QWORD, __int64), __int64 a4)
{
  __int64 v4; // r12
  __int64 (__fastcall *v5)(_QWORD, __int64); // rbp
  __int64 v6; // rax
  int v7; // eax
  const char *v8; // rdx
  _QWORD *result; // rax
  __int64 v10; // rax
  _QWORD *v11; // rbx

  if ( !a1 )
    return (_QWORD *)g_return_if_fail_warning(0LL, "columns_forall", "container != NULL");
  v4 = a4;
  v5 = a3;
  v6 = sub_9C450((__int64)a1);
  if ( !*a1 || *(_QWORD *)*a1 != v6 )
  {
    v7 = g_type_check_instance_is_a(a1, v6);
    v8 = "IS_COLUMNS(container)";
    if ( !v7 )
      return (_QWORD *)g_return_if_fail_warning(0LL, "columns_forall", v8);
  }
  if ( !v5 )
  {
    v8 = "callback != NULL";
    return (_QWORD *)g_return_if_fail_warning(0LL, "columns_forall", v8);
  }
  v10 = sub_9C450((__int64)a1);
  result = (_QWORD *)g_type_check_instance_cast(a1, v10);
  v11 = (_QWORD *)result[5];
LABEL_8:
  while ( v11 )
  {
    result = (_QWORD *)*v11;
    if ( !*v11 )
      break;
    v11 = (_QWORD *)v11[1];
    if ( !*result )
      goto LABEL_8;
    result = (_QWORD *)v5(*result, v4);
  }
  return result;
}

__int64 __fastcall sub_9C7E0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // r13
  __int64 v3; // rbx
  __int64 v4; // rax
  int v5; // eax
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rbp
  __int64 v12; // r14
  _QWORD *v13; // r12
  int v14; // er15
  __int64 v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rax
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  _QWORD *v24; // rdi
  _QWORD *v25; // rbp
  __int64 v26; // [rsp-38h] [rbp-38h]

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_remove", "container != NULL");
  v2 = a1;
  v3 = a2;
  v4 = sub_9C450((__int64)a1);
  if ( !*a1 || *(_QWORD *)*a1 != v4 )
  {
    v5 = g_type_check_instance_is_a(a1, v4);
    v6 = "IS_COLUMNS(container)";
    if ( !v5 )
      return g_return_if_fail_warning(0LL, "columns_remove", v6);
  }
  if ( !a2 )
  {
    v6 = "widget != NULL";
    return g_return_if_fail_warning(0LL, "columns_remove", v6);
  }
  v7 = sub_9C450((__int64)a1);
  v8 = v7;
  v9 = g_type_check_instance_cast(a1, v7);
  v11 = *(_QWORD *)(v9 + 40);
  v12 = v9;
  if ( v11 )
  {
    v13 = *(_QWORD **)v11;
    if ( *(_QWORD *)v11 )
    {
      while ( *v13 != v3 )
      {
        v11 = *(_QWORD *)(v11 + 8);
        if ( !v11 )
          goto LABEL_19;
        v13 = *(_QWORD **)v11;
        if ( !*(_QWORD *)v11 )
          goto LABEL_19;
      }
      v14 = gtk_widget_get_visible(v3, v8);
      gtk_widget_unparent(v3);
      v15 = v11;
      *(_QWORD *)(v12 + 40) = g_list_remove_link(*(_QWORD *)(v12 + 40), v11, v16);
      g_list_free(v11);
      v17 = v13[3];
      if ( v17 )
      {
        v6 = "child->same_height_as->same_height_as == child";
        if ( *(_QWORD **)(v17 + 24) != v13 )
          return g_return_if_fail_warning(0LL, "columns_remove", v6);
        *(_QWORD *)(v17 + 24) = 0LL;
        v19 = *(_QWORD *)v13[3];
        if ( (unsigned int)gtk_widget_get_visible(v19, v11) )
        {
          v20 = gtk_widget_get_type(v19, v11);
          v15 = v20;
          v21 = g_type_check_instance_cast(v2, v20);
          gtk_widget_queue_resize(v21);
        }
      }
      g_free(v13);
      if ( v14 )
      {
        v22 = gtk_widget_get_type(v13, v15);
        v23 = g_type_check_instance_cast(v2, v22);
        gtk_widget_queue_resize(v23);
      }
    }
  }
LABEL_19:
  v24 = *(_QWORD **)(v12 + 48);
  if ( v24 && *v24 )
  {
    v25 = *(_QWORD **)(v12 + 48);
    if ( *v24 == v3 )
    {
LABEL_25:
      *(_QWORD *)(v12 + 48) = g_list_remove_link(v24, v25, v10);
      return g_list_free(v25);
    }
    while ( 1 )
    {
      v25 = (_QWORD *)v25[1];
      if ( !v25 || !*v25 )
        break;
      if ( v3 == *v25 )
        goto LABEL_25;
    }
  }
  return v26;
}

unsigned __int64 __fastcall sub_9C9C0(_QWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r12
  __int64 v3; // rax
  __int64 v5; // rax
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  int v10; // er13
  __int64 (__fastcall *v11)(__int64 *); // rsi
  __int64 **v12; // rbx
  __int64 *i; // rbp
  __int64 v14; // rdi
  int v15; // [rsp+0h] [rbp-48h]
  int v16; // [rsp+4h] [rbp-44h]
  int v17; // [rsp+8h] [rbp-40h]
  int v18; // [rsp+Ch] [rbp-3Ch]
  unsigned __int64 v19; // [rsp+18h] [rbp-30h]

  v19 = __readfsqword(0x28u);
  if ( a1 )
  {
    v2 = a2;
    v3 = sub_9C450((__int64)a1);
    if ( *a1 && *(_QWORD *)*a1 == v3 || (unsigned int)g_type_check_instance_is_a(a1, v3) )
    {
      if ( a2 )
      {
        v5 = sub_9C450((__int64)a1);
        v6 = g_type_check_instance_cast(a1, v5);
        gtk_widget_set_allocation(a1, a2);
        v7 = gtk_container_get_type(a1);
        v8 = v7;
        v9 = g_type_check_instance_cast(v6, v7);
        v10 = gtk_container_get_border_width(v9, v8);
        sub_9BBB0(v6, v2[2], (__int64 (__fastcall *)(__int64))sub_9BB60);
        v11 = sub_9BAC0;
        sub_9C270(v6, (__int64 (*)(void))sub_9BAC0);
        v12 = *(__int64 ***)(v6 + 40);
        if ( v12 )
        {
          for ( i = *v12; *v12; i = *v12 )
          {
            if ( *i && (unsigned int)gtk_widget_get_visible(*i, v11) )
            {
              v14 = *i;
              v11 = (__int64 (__fastcall *)(__int64 *))&v15;
              v15 = *((_DWORD *)i + 12) + v10 + *v2;
              v16 = *((_DWORD *)i + 13) + v10 + v2[1];
              v17 = *((_DWORD *)i + 14);
              v18 = *((_DWORD *)i + 15);
              gtk_widget_size_allocate(v14, &v15);
            }
            v12 = (__int64 **)v12[1];
            if ( !v12 )
              break;
          }
        }
      }
      else
      {
        g_return_if_fail_warning(0LL, "columns_size_allocate", "alloc != NULL");
      }
    }
    else
    {
      g_return_if_fail_warning(0LL, "columns_size_allocate", "IS_COLUMNS(widget)");
    }
  }
  else
  {
    g_return_if_fail_warning(0LL, "columns_size_allocate", "widget != NULL");
  }
  return __readfsqword(0x28u) ^ v19;
}

__int64 __fastcall sub_9CB80(_QWORD *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // r12
  _DWORD *v5; // rbp
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rbx

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_height_for_width", "widget != NULL");
  v4 = a3;
  v5 = a4;
  v6 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v6) && !(unsigned int)g_type_check_instance_is_a(a1, v6) )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_height_for_width", "IS_COLUMNS(widget)");
  v8 = sub_9C450((__int64)a1);
  v9 = g_type_check_instance_cast(a1, v8);
  result = sub_9BBB0(v9, a2, (__int64 (__fastcall *)(__int64))sub_9BF10);
  if ( v4 )
  {
    result = sub_9BD30(v9, (__int64 (__fastcall *)(__int64))sub_9BAC0);
    *v4 = result;
  }
  if ( v5 )
  {
    result = sub_9BD30(v9, (__int64 (__fastcall *)(__int64))sub_9BB10);
    *v5 = result;
  }
  return result;
}

__int64 __fastcall sub_9CC60(_QWORD *a1, __int64 a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // r12
  _DWORD *v5; // rbp
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rbx

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_width_for_height", "widget != NULL");
  v4 = a3;
  v5 = a4;
  v6 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v6) && !(unsigned int)g_type_check_instance_is_a(a1, v6) )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_width_for_height", "IS_COLUMNS(widget)");
  v8 = sub_9C450((__int64)a1);
  v9 = g_type_check_instance_cast(a1, v8);
  result = sub_9C270(v9, (__int64 (*)(void))sub_9C0A0);
  if ( v4 )
  {
    result = sub_9C140(v9, sub_9C050);
    *v4 = result;
  }
  if ( v5 )
  {
    result = sub_9C140(v9, sub_9C000);
    *v5 = result;
  }
  return result;
}

__int64 __fastcall sub_9CD30(_QWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // rbp
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // rbx

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_height", "widget != NULL");
  v3 = a3;
  v4 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v4) && !(unsigned int)g_type_check_instance_is_a(a1, v4) )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_height", "IS_COLUMNS(widget)");
  v6 = sub_9C450((__int64)a1);
  result = g_type_check_instance_cast(a1, v6);
  v7 = result;
  if ( a2 )
  {
    result = sub_9BD30(result, (__int64 (__fastcall *)(__int64))sub_9C0F0);
    *a2 = result;
  }
  if ( v3 )
  {
    result = sub_9BD30(v7, (__int64 (__fastcall *)(__int64))sub_9C0A0);
    *v3 = result;
  }
  return result;
}

__int64 __fastcall sub_9CDF0(_QWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // rbp
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // rbx

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_width", "widget != NULL");
  v3 = a3;
  v4 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v4) && !(unsigned int)g_type_check_instance_is_a(a1, v4) )
    return g_return_if_fail_warning(0LL, "columns_get_preferred_width", "IS_COLUMNS(widget)");
  v6 = sub_9C450((__int64)a1);
  result = g_type_check_instance_cast(a1, v6);
  v7 = result;
  if ( a2 )
  {
    result = sub_9C140(result, sub_9BB60);
    *a2 = result;
  }
  if ( v3 )
  {
    result = sub_9C140(v7, sub_9BF10);
    *v3 = result;
  }
  return result;
}

__int64 __fastcall sub_9CEB0(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 result; // rax
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // rbp

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_unmap", "widget != NULL");
  v1 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v1) && !(unsigned int)g_type_check_instance_is_a(a1, v1) )
    return g_return_if_fail_warning(0LL, "columns_unmap", "IS_COLUMNS(widget)");
  v3 = sub_9C450((__int64)a1);
  v4 = g_type_check_instance_cast(a1, v3);
  v5 = gtk_widget_get_type(a1, v3);
  v6 = g_type_check_instance_cast(v4, v5);
  result = gtk_widget_set_mapped(v6, 0LL);
  v7 = *(_QWORD **)(v4 + 40);
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = (_QWORD *)*v7;
      if ( !*v7 )
        break;
      if ( *v8
        && (result = gtk_widget_get_visible(*v8, 0LL), (_DWORD)result)
        && (result = gtk_widget_get_mapped(*v8, 0LL), (_DWORD)result) )
      {
        result = gtk_widget_unmap(*v8);
        v7 = (_QWORD *)v7[1];
        if ( !v7 )
          return result;
      }
      else
      {
        v7 = (_QWORD *)v7[1];
        if ( !v7 )
          return result;
      }
    }
  }
  return result;
}

__int64 __fastcall sub_9CFB0(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 result; // rax
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // rbp

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_map", "widget != NULL");
  v1 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v1) && !(unsigned int)g_type_check_instance_is_a(a1, v1) )
    return g_return_if_fail_warning(0LL, "columns_map", "IS_COLUMNS(widget)");
  v3 = sub_9C450((__int64)a1);
  v4 = g_type_check_instance_cast(a1, v3);
  v5 = gtk_widget_get_type(a1, v3);
  v6 = g_type_check_instance_cast(v4, v5);
  result = gtk_widget_set_mapped(v6, 1LL);
  v7 = *(_QWORD **)(v4 + 40);
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = (_QWORD *)*v7;
      if ( !*v7 )
        break;
      if ( *v8
        && (result = gtk_widget_get_visible(*v8, 1LL), (_DWORD)result)
        && (result = gtk_widget_get_mapped(*v8, 1LL), !(_DWORD)result) )
      {
        result = gtk_widget_map(*v8);
        v7 = (_QWORD *)v7[1];
        if ( !v7 )
          return result;
      }
      else
      {
        v7 = (_QWORD *)v7[1];
        if ( !v7 )
          return result;
      }
    }
  }
  return result;
}

__int64 __fastcall sub_9D0B0(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rdi
  __int64 v7; // rax

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_finalize", "object != NULL");
  v1 = a1;
  v2 = sub_9C450((__int64)a1);
  if ( (!*a1 || *(_QWORD *)*a1 != v2) && !(unsigned int)g_type_check_instance_is_a(a1, v2) )
    return g_return_if_fail_warning(0LL, "columns_finalize", "IS_COLUMNS(object)");
  v4 = sub_9C450((__int64)a1);
  v5 = g_type_check_instance_cast(a1, v4);
  g_list_free_full(*(_QWORD *)(v5 + 40), sub_9BAA0);
  v6 = qword_3264A0;
  *(_QWORD *)(v5 + 40) = 0LL;
  v7 = g_type_check_class_cast(v6, 80LL);
  return (*(__int64 (__fastcall **)(_QWORD *, signed __int64))(v7 + 48))(v1, 80LL);
}

__int64 __fastcall sub_9D170(__int64 a1)
{
  int v1; // ebp
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax

  v1 = a1;
  v2 = sub_9C450(a1);
  v3 = v2;
  v4 = g_object_new(v2, 0LL);
  *(_DWORD *)(v4 + 56) = v1;
  v5 = v4;
  v6 = gtk_widget_get_type(v3, 0LL);
  return g_type_check_instance_cast(v5, v6);
}

__int64 __fastcall sub_9D1B0(_QWORD *a1, int a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  int v5; // eax
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r13
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 result; // rax

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_set_cols", "cols != NULL");
  v3 = a3;
  v4 = sub_9C450((__int64)a1);
  if ( !*a1 || *(_QWORD *)*a1 != v4 )
  {
    v5 = g_type_check_instance_is_a(a1, v4);
    v6 = "IS_COLUMNS(cols)";
    if ( !v5 )
      return g_return_if_fail_warning(0LL, "columns_set_cols", v6);
  }
  v6 = "ncols > 0";
  if ( a2 <= 0 )
    return g_return_if_fail_warning(0LL, "columns_set_cols", v6);
  if ( !v3 )
  {
    v6 = "percentages != NULL";
    return g_return_if_fail_warning(0LL, "columns_set_cols", v6);
  }
  v7 = g_malloc(64LL);
  *(_QWORD *)v7 = 0LL;
  *(_DWORD *)(v7 + 32) = a2;
  v8 = v7;
  v9 = g_malloc_n(a2, 4LL);
  *(_QWORD *)(v8 + 40) = v9;
  *(_BYTE *)(v8 + 16) = 0;
  v10 = 0LL;
  do
  {
    *(_DWORD *)(v9 + v10) = *(_DWORD *)(v3 + v10);
    v10 += 4LL;
  }
  while ( 4LL * (unsigned int)(a2 - 1) + 4 != v10 );
  result = g_list_append(a1[5], v8);
  a1[5] = result;
  return result;
}

__int64 __fastcall sub_9D2C0(const char **a1, __int64 a2, int a3, int a4)
{
  int v4; // er13
  const char **v5; // rbx
  int v6; // er12
  __int64 v7; // rbp
  __int64 v8; // rax
  const char *v9; // rdx
  int v10; // eax
  __int64 v11; // rax
  __int64 v13; // rax
  const char *v14; // rdi
  __int64 v15; // rax
  const char *v16; // rdi
  __int64 v17; // rax
  __int64 v18; // r12
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // [rsp-28h] [rbp-28h]

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_add", "cols != NULL");
  v4 = a3;
  v5 = a1;
  v6 = a4;
  v7 = a2;
  v8 = sub_9C450((__int64)a1);
  v9 = *a1;
  if ( !*a1 || *(_QWORD *)v9 != v8 )
  {
    a2 = v8;
    v10 = g_type_check_instance_is_a(a1, v8);
    v9 = "IS_COLUMNS(cols)";
    if ( !v10 )
      return g_return_if_fail_warning(0LL, "columns_add", v9);
  }
  if ( !v7 )
  {
    v9 = "child != NULL";
    return g_return_if_fail_warning(0LL, "columns_add", v9);
  }
  v11 = gtk_widget_get_parent(v7, a2, v9);
  v9 = "gtk_widget_get_parent(child) == NULL";
  if ( v11 )
    return g_return_if_fail_warning(0LL, "columns_add", v9);
  v13 = g_malloc(64LL);
  v14 = a1[5];
  *(_DWORD *)(v13 + 12) = v6;
  *(_QWORD *)v13 = v7;
  *(_DWORD *)(v13 + 8) = v4;
  *(_BYTE *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0LL;
  *(_QWORD *)(v13 + 40) = 0LL;
  v15 = g_list_append(v14, v13);
  v16 = v5[6];
  v5[5] = (const char *)v15;
  v5[6] = (const char *)g_list_append(v16, v7);
  v17 = gtk_widget_get_type(v16, v7);
  v18 = v17;
  v19 = g_type_check_instance_cast(v5, v17);
  gtk_widget_set_parent(v7, v19);
  v20 = g_type_check_instance_cast(v5, v18);
  if ( (unsigned int)gtk_widget_get_realized(v20, v18) )
    gtk_widget_realize(v7);
  v21 = g_type_check_instance_cast(v5, v18);
  if ( !(unsigned int)gtk_widget_get_visible(v21, v18) || !(unsigned int)gtk_widget_get_visible(v7, v18) )
    return v23;
  v22 = g_type_check_instance_cast(v5, v18);
  if ( (unsigned int)gtk_widget_get_mapped(v22, v18) )
    gtk_widget_map(v7);
  return gtk_widget_queue_resize(v7);
}

__int64 __fastcall sub_9D460(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  int v3; // eax
  const char *v4; // rdx
  __int64 v6; // rax
  const char **v7; // rax

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_base_add", "container != NULL");
  v2 = sub_9C450((__int64)a1);
  if ( !*a1 || *(_QWORD *)*a1 != v2 )
  {
    v3 = g_type_check_instance_is_a(a1, v2);
    v4 = "IS_COLUMNS(container)";
    if ( !v3 )
      return g_return_if_fail_warning(0LL, "columns_base_add", v4);
  }
  if ( !a2 )
  {
    v4 = "widget != NULL";
    return g_return_if_fail_warning(0LL, "columns_base_add", v4);
  }
  v6 = sub_9C450((__int64)a1);
  v7 = (const char **)g_type_check_instance_cast(a1, v6);
  return sub_9D2C0(v7, a2, 0, 0);
}

__int64 __fastcall sub_9D510(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  int v4; // eax
  const char *v5; // rdx
  __int64 *i; // rax
  __int64 v7; // rdx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // [rsp-18h] [rbp-18h]

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_force_left_align", "cols != NULL");
  v2 = a2;
  v3 = sub_9C450((__int64)a1);
  if ( *a1 && *(_QWORD *)*a1 == v3 || (a2 = v3, v4 = g_type_check_instance_is_a(a1, v3), v5 = "IS_COLUMNS(cols)", v4) )
  {
    v5 = "widget != NULL";
    if ( v2 )
    {
      for ( i = (__int64 *)a1[5]; i; i = (__int64 *)i[1] )
      {
        v7 = *i;
        if ( !*i )
          break;
        if ( v2 == *(_QWORD *)v7 )
        {
          *(_BYTE *)(v7 + 16) = 1;
          if ( !(unsigned int)gtk_widget_get_visible(v2, a2) )
            return v11;
          v9 = gtk_widget_get_type(v2, a2);
          v10 = g_type_check_instance_cast(a1, v9);
          return gtk_widget_queue_resize(v10);
        }
      }
      v5 = "child != NULL";
    }
  }
  return g_return_if_fail_warning(0LL, "columns_force_left_align", v5);
}

__int64 __fastcall sub_9D600(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v4; // r12
  __int64 v5; // rbx
  __int64 v6; // rax
  int v7; // eax
  const char *v8; // rdx
  __int64 v9; // rax
  _QWORD *v10; // r8
  __int64 v11; // rcx
  _QWORD *v12; // r9
  __int64 result; // rax
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // rax

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_force_same_height", "cols != NULL");
  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = sub_9C450((__int64)a1);
  if ( !*a1 || *(_QWORD *)*a1 != v6 )
  {
    a2 = v6;
    v7 = g_type_check_instance_is_a(a1, v6);
    v8 = "IS_COLUMNS(cols)";
    if ( !v7 )
      return g_return_if_fail_warning(0LL, "columns_force_same_height", v8);
  }
  v8 = "cw1 != NULL";
  if ( !v5 )
    return g_return_if_fail_warning(0LL, "columns_force_same_height", v8);
  v8 = "cw2 != NULL";
  if ( !v4 )
    return g_return_if_fail_warning(0LL, "columns_force_same_height", v8);
  v9 = a1[5];
  if ( !v9 || (v10 = *(_QWORD **)v9) == 0LL )
  {
LABEL_14:
    v8 = "child1 != NULL";
    return g_return_if_fail_warning(0LL, "columns_force_same_height", v8);
  }
  if ( v5 != *v10 )
  {
    v11 = a1[5];
    while ( 1 )
    {
      v11 = *(_QWORD *)(v11 + 8);
      if ( !v11 )
        goto LABEL_14;
      v12 = *(_QWORD **)v11;
      if ( !*(_QWORD *)v11 )
        goto LABEL_14;
      if ( v5 == *v12 )
        goto LABEL_18;
    }
  }
  v12 = *(_QWORD **)v9;
LABEL_18:
  if ( v4 != *v10 )
  {
    while ( 1 )
    {
      v9 = *(_QWORD *)(v9 + 8);
      if ( !v9 )
        break;
      v10 = *(_QWORD **)v9;
      if ( !*(_QWORD *)v9 )
        break;
      if ( v4 == *v10 )
        goto LABEL_19;
    }
    v8 = "child2 != NULL";
    return g_return_if_fail_warning(0LL, "columns_force_same_height", v8);
  }
LABEL_19:
  v12[3] = v10;
  v14 = v5;
  v10[3] = v12;
  if ( (unsigned int)gtk_widget_get_visible(v5, a2)
    || (v14 = v4, result = gtk_widget_get_visible(v4, a2), (_DWORD)result) )
  {
    v15 = gtk_widget_get_type(v14, a2);
    v16 = g_type_check_instance_cast(v3, v15);
    result = gtk_widget_queue_resize(v16);
  }
  return result;
}

__int64 __fastcall sub_9D740(const char **a1, __int64 a2)
{
  const char **v2; // rbp
  __int64 result; // rax
  const char *v4; // rdx
  __int64 *v5; // rdi
  __int64 *v6; // rbx

  if ( !a1 )
    return g_return_if_fail_warning(0LL, "columns_taborder_last", "cols != NULL");
  v2 = a1;
  result = sub_9C450((__int64)a1);
  v4 = *a1;
  if ( !*a1 || *(_QWORD *)v4 != result )
  {
    result = g_type_check_instance_is_a(a1, result);
    v4 = "IS_COLUMNS(cols)";
    if ( !(_DWORD)result )
      return g_return_if_fail_warning(0LL, "columns_taborder_last", v4);
  }
  if ( !a2 )
  {
    v4 = "widget != NULL";
    return g_return_if_fail_warning(0LL, "columns_taborder_last", v4);
  }
  v5 = (__int64 *)a1[6];
  if ( v5 )
  {
    result = *v5;
    if ( *v5 )
    {
      v6 = (__int64 *)v2[6];
      if ( result == a2 )
      {
LABEL_13:
        v2[6] = (const char *)g_list_remove_link(v5, v6, v4);
        g_list_free(v6);
        result = g_list_append(v2[6], a2);
        v2[6] = (const char *)result;
      }
      else
      {
        while ( 1 )
        {
          v6 = (__int64 *)v6[1];
          if ( !v6 )
            break;
          result = *v6;
          if ( !*v6 )
            break;
          if ( a2 == result )
            goto LABEL_13;
        }
      }
    }
  }
  return result;
}

signed __int64 __usercall sub_9D820@<rax>(__int64 a1@<rdi>, char a2@<sil>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  unsigned int v6; // eax
  unsigned int v7; // ebp

  v6 = g_io_channel_unix_get_fd(a1);
  v7 = v6;
  if ( a2 & 2 )
    sub_B8830(v6, 4u, a3, a4, a5, a6);
  if ( a2 & 0x11 )
    sub_B8830(v7, 1u, a3, a4, a5, a6);
  if ( a2 & 4 )
    sub_B8830(v7, 2u, a3, a4, a5, a6);
  return 1LL;
}

__int64 __fastcall sub_9D880(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // [rsp+0h] [rbp-18h]
  unsigned __int64 v6; // [rsp+8h] [rbp-10h]

  v1 = a1;
  v6 = __readfsqword(0x28u);
  if ( dword_3264B0 )
  {
    g_source_remove((unsigned int)dword_3264B0);
    dword_3264B0 = 0;
  }
  if ( (unsigned __int8)sub_99E00(a1, (__int64)&v5) && !dword_3264B0 )
  {
    v3 = sub_B4D20();
    v4 = 0LL;
    if ( v3 - v1 <= (unsigned __int64)(v5 - v1) )
      v4 = (unsigned int)(v5 - v3);
    dword_3264B0 = g_timeout_add(v4, sub_9D880);
  }
  return 0LL;
}

void sub_9D930()
{
  int v0; // eax

  if ( !byte_3264A8 )
  {
    v0 = g_idle_add(sub_9D970, 0LL);
    byte_3264A8 = 1;
    dword_3264AC = v0;
  }
}

signed __int64 sub_9D970()
{
  sub_1BE50();
  if ( sub_1BEC0() || !byte_3264A8 )
    return 1LL;
  g_source_remove((unsigned int)dword_3264AC);
  byte_3264A8 = 0;
  return 1LL;
}

_DWORD *__fastcall sub_9D9C0(unsigned int a1, char a2)
{
  unsigned int v2; // ebx
  _DWORD *v3; // rbp
  __int64 v4; // rax

  v2 = a2 & 1;
  v3 = sub_2F450(1uLL, 0x10uLL, 0LL);
  if ( a2 & 1 )
    v2 = 17;
  if ( a2 & 2 )
    v2 |= 4u;
  if ( a2 & 4 )
    v2 |= 2u;
  v4 = g_io_channel_unix_new(a1, 16LL);
  *(_QWORD *)v3 = v4;
  g_io_channel_set_encoding(v4, 0LL, 0LL);
  v3[2] = g_io_add_watch_full(*(_QWORD *)v3, 121LL, v2, sub_9D820, 0LL, 0LL);
  return v3;
}

void __fastcall sub_9DA50(unsigned int *a1)
{
  g_source_remove(a1[2]);
  g_io_channel_unref(*(_QWORD *)a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_9DA70(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 result; // rax

  if ( dword_3264B0 )
    g_source_remove((unsigned int)dword_3264B0);
  v2 = a1 - sub_B4D20();
  if ( v2 <= 0 )
    v2 = 1LL;
  result = g_timeout_add(v2, sub_9D880);
  dword_3264B0 = result;
  return result;
}

void sub_9DAC0()
{
  sub_B86D0();
  sub_1BCC0((__int64)sub_9D930, 0LL);
}

signed __int64 __fastcall sub_9DAE0(_QWORD *a1, _QWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_9DB00(unsigned __int64 a1, unsigned __int64 *a2)
{
  signed __int64 result; // rax

  if ( *a2 > a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *a2 < a1;
  return result;
}

signed __int64 __fastcall sub_9DB20(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  signed __int64 result; // rax

  v2 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)(a1 + 8) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_QWORD *)(a1 + 8) > v2;
  return result;
}

signed __int64 __fastcall sub_9DB40(unsigned __int64 a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( *(_QWORD *)(a2 + 8) > a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_QWORD *)(a2 + 8) < a1;
  return result;
}

void nullsub_36()
{
  ;
}

void __fastcall sub_9DB70(__int64 a1)
{
  *(_QWORD *)(a1 + 72) = 0LL;
}

void sub_9DB80()
{
  qword_3264B8 = 0LL;
}

__int64 __fastcall sub_9DB90(_QWORD **a1)
{
  (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD, signed __int64))(**a1 + 24LL))(**a1, a1[1], a1[1][2], 2LL);
  sub_2F4D0(a1);
  return 0LL;
}

void __fastcall sub_9DBC0(__int64 a1, int a2)
{
  int v2; // er12
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r13
  unsigned __int8 *v7; // rax
  __int64 v8; // rbx
  unsigned __int8 *v9; // rbp
  __int64 v10; // rsi
  const __int32_t *v11; // rax
  char *v12; // rbx

  v2 = a2;
  v3 = gtk_label_get_type(a1);
  v4 = v3;
  v5 = g_type_check_instance_cast(a1, v3);
  v6 = v5;
  v7 = (unsigned __int8 *)gtk_label_get_text(v5, v4);
  v8 = *v7;
  if ( (_BYTE)v8 )
  {
    v9 = v7;
    v10 = 0LL;
    v11 = *__ctype_tolower_loc();
    while ( v2 != v11[v8] )
    {
      v8 = v9[++v10];
      if ( !(_BYTE)v8 )
        return;
    }
    v12 = sub_BC360((__int64)"%*s_", v10, &locale);
    gtk_label_set_pattern(v6, v12);
    sub_2F4D0(v12);
  }
}

__int64 sub_9DC60()
{
  __int64 result; // rax

  result = gtk_widget_destroy(qword_3264B8);
  qword_3264B8 = 0LL;
  return result;
}

unsigned __int64 __fastcall sub_9DC80(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // r12
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  double v13; // xmm1_8
  double v14; // xmm0_8
  double v15; // [rsp+0h] [rbp-58h]
  double v16; // [rsp+8h] [rbp-50h]
  double v17; // [rsp+10h] [rbp-48h]
  unsigned __int64 v18; // [rsp+28h] [rbp-30h]

  v3 = a1;
  v4 = a3;
  v18 = __readfsqword(0x28u);
  v5 = g_type_check_instance_cast(a1, 80LL);
  v6 = (_QWORD *)g_object_get_data(v5, "user-data");
  if ( a2 == -5 )
  {
    v11 = gtk_color_chooser_get_type();
    v12 = g_type_check_instance_cast(a1, v11);
    gtk_color_chooser_get_rgba(v12, &v15);
    *(_BYTE *)(v4 + 27) = 1;
    v13 = v16 * 255.0;
    v14 = 255.0 * v17;
    *(_BYTE *)(v4 + 24) = (signed int)(v15 * 255.0);
    *(_BYTE *)(v4 + 25) = (signed int)v13;
    *(_BYTE *)(v4 + 26) = (signed int)v14;
  }
  else
  {
    *(_BYTE *)(v4 + 27) = 0;
  }
  v7 = *v6;
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*v6 + 24LL))(*v6, v4, *(_QWORD *)(v4 + 16), 4LL);
  v8 = gtk_widget_get_type(v7, v4);
  v9 = g_type_check_instance_cast(v3, v8);
  gtk_widget_destroy(v9);
  return __readfsqword(0x28u) ^ v18;
}

__int64 __fastcall sub_9DD80(__int64 a1, int a2)
{
  int v2; // ebp
  __int64 v3; // rbx
  const char *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v10; // r12
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rbp
  __int64 v14; // rax
  __int64 v15; // rax

  v2 = a2;
  v3 = a1;
  v4 = "user-data";
  v5 = g_type_check_instance_cast(a1, 80LL);
  v6 = g_object_get_data(v5, "user-data");
  if ( v2 == -3 )
  {
    v10 = v6;
    v11 = gtk_file_chooser_get_type(v5, "user-data");
    v12 = g_type_check_instance_cast(v3, v11);
    v13 = gtk_file_chooser_get_filename(v12, v11);
    v14 = gtk_entry_get_type(v12, v11);
    v15 = g_type_check_instance_cast(*(_QWORD *)(v10 + 32), v14);
    v4 = (const char *)v13;
    gtk_entry_set_text(v15, v13);
    v5 = v13;
    g_free(v13);
  }
  v7 = gtk_widget_get_type(v5, v4);
  v8 = g_type_check_instance_cast(v3, v7);
  return gtk_widget_destroy(v8);
}

__int64 __fastcall sub_9DE10(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r12
  __int64 v6; // rax
  __int64 v7; // rax
  unsigned int v8; // [rsp+4h] [rbp-24h]
  unsigned __int64 v9; // [rsp+8h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  v3 = gtk_widget_get_parent(a1, a2, a3);
  if ( *(_DWORD *)(a2 + 28) != 65293 )
    return 0LL;
  v4 = v3;
  if ( !v3 )
    return 0LL;
  v6 = g_type_check_instance_cast(a1, 80LL);
  g_signal_stop_emission_by_name(v6, "key_press_event");
  v7 = g_type_check_instance_cast(v4, 80LL);
  g_signal_emit_by_name(v7, "key_press_event", a2, &v8);
  return v8;
}

_QWORD *__fastcall sub_9DEB0(__int64 a1)
{
  _QWORD *result; // rax

  *(_QWORD *)a1 = sub_9AF60((__int64)sub_9DAE0);
  result = sub_9AF60((__int64)sub_9DB20);
  *(_BYTE *)(a1 + 27) = 0;
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 56) = 0LL;
  return result;
}

__int64 __fastcall sub_9DF00(__int64 a1, __int64 *a2)
{
  __int64 v2; // rbp
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rax

  v2 = a1;
  v3 = gtk_box_new(0LL, 10LL);
  v4 = v3;
  v5 = v3;
  gtk_widget_show(v3);
  v6 = gtk_box_get_type(v5, 10LL);
  v7 = v6;
  v8 = g_type_check_instance_cast(v4, v6);
  gtk_box_pack_end(v8, v2, 0LL, 1LL, 0LL);
  v9 = gtk_button_new_with_label("More info...");
  gtk_widget_show(v9);
  v10 = g_type_check_instance_cast(v4, v7);
  gtk_box_pack_start(v10, v9, 0LL, 1LL, 0LL);
  *a2 = v9;
  return v4;
}

void __fastcall sub_9DFA0(void **a1, int a2)
{
  void **v2; // rbx
  int v3; // eax
  _BOOL8 v4; // rsi
  void *v5; // rdi
  __int64 v6; // rsi
  void *v7; // rcx
  void *v8; // rdx
  void *v9; // rdi

  v2 = a1;
  if ( a2 >= 0 )
  {
    v3 = a2;
    v4 = a2 == 1;
    if ( v3 == 2 )
    {
      v6 = *((unsigned int *)a1 + 2);
      v7 = a1[3];
      v8 = a1[2];
      v9 = *a1;
      sub_BAFD0();
      v4 = 1LL;
    }
    ((void (__fastcall *)(void *, _BOOL8))v2[5])(v2[6], v4);
  }
  sub_AFC30((__int64 (__fastcall ***)())v2[7], 1u);
  v5 = v2[9];
  if ( v5 )
    gtk_widget_destroy(v5);
  sub_2F4D0(*v2);
  sub_2F4D0(v2[2]);
  sub_2F4D0(v2[3]);
  sub_2F4D0(v2[4]);
  sub_2F4D0(v2);
}

void __fastcall sub_9E030(_QWORD *a1, unsigned int a2)
{
  sub_AFC30((__int64 (__fastcall ***)())a1[2], *((_DWORD *)a1 + 6));
  if ( (a2 & 0x80000000) == 0 )
    ((void (__fastcall *)(_QWORD, _QWORD))*a1)(a1[1], a2);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_9E070(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rax
  __int64 v6; // r12
  __int64 v7; // rbp
  __int64 v8; // rax

  v5 = *(_QWORD *)(a5 + 3264);
  v6 = *(_QWORD *)(v5 + 16);
  v7 = *(_QWORD *)(v5 + 8);
  v8 = gtk_selection_data_get_target(a2);
  return gtk_selection_data_set(a2, v8, 8LL, v7, (unsigned int)v6);
}

void __fastcall sub_9E0B0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // r12
  int v7; // ebx
  __int64 v8; // rax
  int v9; // esi
  signed __int64 v10; // rax

  if ( a3 )
  {
    v5 = a2;
    v6 = a5;
    v7 = a4;
    v8 = (*__ctype_tolower_loc())[(unsigned __int8)a3];
    v9 = v8;
    v10 = a1 + 24 * v8;
    if ( *(_DWORD *)(v10 + 16) )
      __assert_fail("scs->sc[chr].action == SHORTCUT_EMPTY", "unix/gtkdlg.c", 0xB25u, "shortcut_add");
    *(_DWORD *)(v10 + 16) = v7;
    if ( v7 == 3 )
    {
      *(_QWORD *)v10 = 0LL;
      *(_QWORD *)(v10 + 8) = v6;
    }
    else
    {
      *(_QWORD *)(v10 + 8) = 0LL;
      *(_QWORD *)v10 = v6;
    }
    sub_9DBC0(v5, v9);
  }
}

__int64 __fastcall sub_9E160(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a2 + 28) == 65307 )
  {
    if ( qword_3264B8 )
    {
      result = gtk_widget_destroy(qword_3264B8);
      qword_3264B8 = 0LL;
    }
  }
  return result;
}

__int64 __fastcall sub_9E1A0(__int64 **a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdx
  __int64 v4; // rbp

  v2 = a2;
  do
  {
    v4 = sub_9B3D0(*a1, v2, (__int64 (__fastcall *)(__int64))sub_9DB40);
    if ( v4 )
      break;
    v2 = gtk_widget_get_parent(v2, v2, v3);
  }
  while ( v2 );
  return v4;
}

_QWORD *__fastcall sub_9E200(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *result; // rax

  v4 = a4;
  v5 = gtk_widget_get_type(a1, a2);
  result = (_QWORD *)g_type_check_instance_cast(a1, v5);
  if ( *(_QWORD *)(v4 + 8) )
  {
    result = (_QWORD *)sub_9E1A0((__int64 **)(v4 + 8), (__int64)result);
    if ( result )
      result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*result + 24LL))(
                           *result,
                           v4,
                           *(_QWORD *)(v4 + 16),
                           1LL);
  }
  return result;
}

_QWORD *__fastcall sub_9E260(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *result; // rax

  v2 = gtk_widget_get_type(a1, a2);
  result = (_QWORD *)g_type_check_instance_cast(a1, v2);
  if ( *(_QWORD *)(a2 + 8) )
  {
    result = (_QWORD *)sub_9E1A0((__int64 **)(a2 + 8), (__int64)result);
    if ( result )
      result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*result + 24LL))(
                           *result,
                           a2,
                           *(_QWORD *)(a2 + 16),
                           3LL);
  }
  return result;
}

__int64 __fastcall sub_9E2C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  _QWORD *v6; // rax

  v3 = a3;
  v4 = gtk_widget_get_type(a1, a2);
  v5 = g_type_check_instance_cast(a1, v4);
  if ( !*(_QWORD *)(v3 + 8) )
    BUG();
  v6 = (_QWORD *)sub_9E1A0((__int64 **)(v3 + 8), v5);
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(*v6 + 24LL))(*v6, v3, *(_QWORD *)(v3 + 16), 0LL);
  return 0LL;
}

__int64 __fastcall sub_9E320(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  _QWORD *v4; // rax

  v2 = gtk_widget_get_type(a1, a2);
  v3 = g_type_check_instance_cast(a1, v2);
  if ( !*(_QWORD *)(a2 + 8) )
    BUG();
  v4 = (_QWORD *)sub_9E1A0((__int64 **)(a2 + 8), v3);
  return (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*v4 + 24LL))(
           *v4,
           a2,
           *(_QWORD *)(a2 + 16),
           2LL);
}

__int64 __fastcall sub_9E380(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rax

  v3 = a3;
  if ( *(_QWORD *)(a3 + 8) && (v4 = (__int64 *)sub_9E1A0((__int64 **)(a3 + 8), a1)) != 0LL )
    v5 = *v4;
  else
    v5 = 0LL;
  v6 = *(_QWORD *)(v3 + 56);
  if ( v6 != v5 )
  {
    *(_QWORD *)(v3 + 64) = v6;
    *(_QWORD *)(v3 + 56) = v5;
  }
  return 0LL;
}

__int64 __fastcall sub_9E3C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  _QWORD *v4; // rax

  v2 = gtk_widget_get_type(a1, a2);
  v3 = g_type_check_instance_cast(a1, v2);
  if ( !*(_QWORD *)(a2 + 8) )
    BUG();
  v4 = (_QWORD *)sub_9E1A0((__int64 **)(a2 + 8), v3);
  return (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*v4 + 24LL))(
           *v4,
           a2,
           *(_QWORD *)(a2 + 16),
           1LL);
}

_QWORD *__fastcall sub_9E420(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = gtk_tree_selection_get_tree_view();
  v3 = gtk_widget_get_type(a1, a2);
  result = (_QWORD *)g_type_check_instance_cast(v2, v3);
  if ( *(_QWORD *)(a2 + 8) )
  {
    result = (_QWORD *)sub_9E1A0((__int64 **)(a2 + 8), (__int64)result);
    if ( result )
      result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*result + 24LL))(
                           *result,
                           a2,
                           *(_QWORD *)(a2 + 16),
                           3LL);
  }
  return result;
}

__int64 __fastcall sub_9E480(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // r13
  __int64 v4; // rax
  __int64 v5; // rdi
  char *v6; // rsi
  unsigned int **v7; // rax
  unsigned int *v8; // rdx
  unsigned int **v9; // rbp
  __int64 result; // rax
  __int64 v11; // rax
  __int64 v12; // rsi
  __int64 v13; // rax
  const char *v14; // r14
  _QWORD *v15; // r12
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned int v22; // er12
  __int64 v23; // rax
  __int64 v24; // r14
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r12
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax

  v2 = a2;
  v3 = gtk_widget_get_type(a1, a2);
  v4 = g_type_check_instance_cast(a1, v3);
  if ( !*(_QWORD *)(a2 + 8) )
    BUG();
  v5 = a2 + 8;
  v6 = (char *)v4;
  v7 = (unsigned int **)sub_9E1A0((__int64 **)(v2 + 8), v4);
  v8 = *v7;
  v9 = v7;
  result = **v7;
  if ( (_DWORD)result == 7 )
  {
    v22 = *((unsigned __int8 *)v8 + 72);
    v23 = gtk_window_get_type(v5, v6);
    v24 = v23;
    v25 = g_type_check_instance_cast(*(_QWORD *)(v2 + 40), v23);
    v26 = gtk_file_chooser_dialog_new(*((_QWORD *)*v9 + 10), v25, v22, "_Cancel", 4294967290LL, "_Open", -3LL, 0LL);
    v27 = v26;
    v28 = g_type_check_instance_cast(v26, v24);
    gtk_window_set_modal(v28, 1LL);
    v29 = g_type_check_instance_cast(v27, 80LL);
    g_object_set_data(v29, "user-data", v9);
    v30 = g_type_check_instance_cast(v27, 80LL);
    v6 = "response";
    g_signal_connect_data(v30, "response", sub_9DD80, v2, 0LL, 0LL);
    v5 = v27;
    gtk_widget_show(v27);
    result = **v9;
  }
  if ( (_DWORD)result == 8 )
  {
    v11 = gtk_entry_get_type(v5, v6);
    v12 = v11;
    v13 = g_type_check_instance_cast(v9[4], v11);
    v14 = (const char *)gtk_entry_get_text(v13, v12);
    v15 = (_QWORD *)sub_A8E50((__int64)&unk_F615E);
    gtk_window_set_modal(v15[1], 1LL);
    sub_A9DF0((__int64)v15, v14);
    v16 = g_type_check_instance_cast(v15[2], 80LL);
    g_object_set_data(v16, "user-data", v15);
    v17 = v15[2];
    *v15 = v9;
    v18 = g_type_check_instance_cast(v17, 80LL);
    g_signal_connect_data(v18, "clicked", sub_9E7E0, v2, 0LL, 0LL);
    v19 = g_type_check_instance_cast(v15[2], 80LL);
    g_signal_connect_data(v19, "clicked", sub_A9D80, v15, 0LL, 2LL);
    v20 = g_type_check_instance_cast(v15[3], 80LL);
    g_signal_connect_data(v20, "clicked", sub_A9D80, v15, 0LL, 2LL);
    v21 = g_type_check_instance_cast(v15[1], v3);
    result = gtk_widget_show(v21);
  }
  return result;
}

void __fastcall sub_9E6D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rbp
  _QWORD *v10; // rax

  if ( !(*(_BYTE *)(a4 + 28) & 2) )
  {
    v4 = a4;
    v5 = g_type_check_instance_cast(a1, 80LL);
    v6 = g_object_get_data(v5, "user-data");
    v7 = gtk_widget_get_type(v5, "user-data");
    v8 = g_type_check_instance_cast(v6, v7);
    if ( *(_QWORD *)(v4 + 8) )
    {
      v9 = sub_9E1A0((__int64 **)(v4 + 8), v8);
      if ( v9 )
      {
        v10 = sub_2F450(1uLL, 0x10uLL, 0LL);
        *v10 = v9;
        v10[1] = v4;
        g_idle_add(sub_9DB90, v10);
      }
    }
  }
}

void __fastcall sub_9E770(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  _QWORD *v4; // rax

  if ( !(*(_BYTE *)(a2 + 28) & 1) )
  {
    v2 = gtk_widget_get_type(a1, a2);
    v3 = g_type_check_instance_cast(a1, v2);
    if ( !*(_QWORD *)(a2 + 8) )
      BUG();
    v4 = (_QWORD *)sub_9E1A0((__int64 **)(a2 + 8), v3);
    (*(void (__fastcall **)(_QWORD, __int64, _QWORD, signed __int64))(*v4 + 24LL))(*v4, a2, *(_QWORD *)(a2 + 16), 2LL);
  }
}

void __fastcall sub_9E7E0(__int64 a1)
{
  __int64 v1; // rax
  _QWORD *v2; // rax
  _QWORD *v3; // rdi
  __int64 v4; // rbp
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  void *v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  char v13; // [rsp+0h] [rbp-18h]

  v1 = g_type_check_instance_cast(a1, 80LL);
  v2 = (_QWORD *)g_object_get_data(v1, "user-data");
  v3 = v2;
  v4 = *v2;
  v9 = sub_A9FA0((__int64)v2, (__int64)"user-data", v5, v6, v7, v8, v13);
  if ( !v9 )
    __assert_fail("name", "unix/gtkdlg.c", 0x648u, "fontsel_ok");
  v10 = (void *)v9;
  v11 = gtk_entry_get_type(v3, "user-data");
  v12 = g_type_check_instance_cast(*(_QWORD *)(v4 + 32), v11);
  gtk_entry_set_text(v12, v10);
  sub_2F4D0(v10);
}

signed __int64 __fastcall sub_9E860(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  signed __int64 result; // rax
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  int v8; // ebx
  __int64 v9; // rsi
  signed __int64 v10; // rcx
  signed int v11; // edx
  signed __int64 v12; // rbp
  _QWORD *v13; // rax
  __int64 v14; // rcx
  _QWORD *v15; // r12
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rsi
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // rdx
  __int64 v27; // r12
  __int64 v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rdi
  __int64 v32; // rsi
  __int64 v33; // rbx
  __int64 v34; // r13
  __int64 v35; // rax

  if ( *(_DWORD *)(a2 + 28) == 65307 )
  {
    a1 = *(_QWORD *)(a3 + 48);
    if ( a1 )
    {
      v5 = g_type_check_instance_cast(a1, 80LL);
      g_signal_emit_by_name(v5, "clicked", v6, v7);
      return 1LL;
    }
  }
  if ( !(*(_BYTE *)(a2 + 24) & 8) )
    return 0LL;
  v3 = **(char **)(a2 + 40);
  if ( (char)v3 <= 0 )
    return 0LL;
  v8 = (char)v3;
  v9 = *(_QWORD *)(a3 + 32);
  v10 = v9 + 24LL * (char)v3;
  v11 = *(_DWORD *)(v10 + 16);
  if ( v11 < 1 )
    return 0LL;
  if ( v11 > 2 )
  {
    if ( v11 == 3 )
    {
      v12 = v9 + 24 * v3;
      v13 = *(_QWORD **)(v12 + 8);
      v14 = *v13;
      v15 = *(_QWORD **)(v12 + 8);
      switch ( *(_DWORD *)*v13 )
      {
        case 2:
          if ( v8 == *(char *)(v14 + 56) )
          {
            v32 = *(unsigned int *)(v14 + 64);
            if ( (signed int)v32 > 0 )
            {
              v33 = 0LL;
              v34 = gtk_toggle_button_get_type(a1, v32);
              do
              {
                v35 = g_type_check_instance_cast(*(_QWORD *)(v15[2] + 8 * v33), v34);
                if ( (unsigned int)gtk_toggle_button_get_active(v35, v34) )
                  gtk_widget_grab_focus(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 16LL) + 8 * v33));
                v15 = *(_QWORD **)(v12 + 8);
                ++v33;
              }
              while ( *(_DWORD *)(*v15 + 64LL) > (signed int)v33 );
            }
          }
          else
          {
            v26 = *(_QWORD *)(v14 + 80);
            if ( v26 && *(_DWORD *)(v14 + 64) > 0 )
            {
              v27 = 0LL;
              while ( 1 )
              {
                if ( v8 == *(char *)(v26 + v27) )
                {
                  gtk_widget_grab_focus(*(_QWORD *)(v13[2] + 8 * v27));
                  v28 = g_type_check_instance_cast(
                          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 16LL) + 8 * v27),
                          80LL);
                  g_signal_emit_by_name(v28, "clicked", v29, v30);
                  v13 = *(_QWORD **)(v12 + 8);
                }
                if ( *(_DWORD *)(*v13 + 64LL) <= (signed int)++v27 )
                  break;
                v26 = *(_QWORD *)(*v13 + 80LL);
              }
            }
          }
          return 0LL;
        case 3:
        case 4:
          gtk_widget_grab_focus(v13[1]);
          v23 = g_type_check_instance_cast(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL), 80LL);
          g_signal_emit_by_name(v23, "clicked", v24, v25);
          return 0LL;
        case 5:
          v19 = v13[6];
          if ( v19 )
          {
            gtk_widget_grab_focus(v19);
            v20 = gtk_combo_box_get_type(v19, off_F6FE0);
            v21 = v20;
            v22 = g_type_check_instance_cast(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 48LL), v20);
            gtk_combo_box_popup(v22, v21);
            result = 0LL;
          }
          else
          {
            v31 = v13[7];
            if ( !v31 )
              __assert_fail("false && \"bad listbox type in win_key_press\"", "unix/gtkdlg.c", 0xAB6u, "win_key_press");
            gtk_widget_grab_focus(v31);
            result = 0LL;
          }
          return result;
        case 7:
        case 8:
          v16 = g_type_check_instance_cast(v13[5], 80LL);
          g_signal_emit_by_name(v16, "clicked", v17, v18);
          gtk_widget_grab_focus(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 32LL));
          return 0LL;
        default:
          return 0LL;
      }
    }
    return 0LL;
  }
  gtk_widget_grab_focus(*(_QWORD *)v10);
  return 0LL;
}

void __fastcall sub_9EAF0(_QWORD ***a1, __int64 **a2)
{
  __int64 v2; // rax
  void **v3; // rbx

  sub_9AF90(*a1);
  *a1 = 0LL;
  while ( 1 )
  {
    v2 = sub_9B010(*a2, 0);
    v3 = (void **)v2;
    if ( !v2 )
      break;
    sub_9B440(*a2, v2);
    sub_2F4D0(v3[2]);
    sub_2F4D0(v3);
  }
  sub_9AF90((_QWORD **)*a2);
  *a2 = 0LL;
}

void __fastcall sub_9EB60(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rsi
  _QWORD *v4; // rdi
  unsigned __int64 v5; // rbp
  _QWORD *v6; // rdi

  v2 = a2;
  (*(void (__fastcall **)(_QWORD, _QWORD))(v2 + 112))(*(_QWORD *)(v2 + 120), *(unsigned int *)(a2 + 104));
  v3 = a2 + 8;
  sub_9EAF0((_QWORD ***)v2, (__int64 **)(v2 + 8));
  sub_294D0(*(unsigned __int64 **)(v2 + 96));
  v4 = *(_QWORD **)(v2 + 80);
  if ( v4 )
  {
    if ( *(_QWORD *)(v2 + 72) )
    {
      v5 = 0LL;
      do
      {
        v6 = (_QWORD *)v4[v5];
        if ( v6[4] )
        {
          gtk_tree_path_free(v6[4], v3);
          v6 = *(_QWORD **)(*(_QWORD *)(v2 + 80) + 8 * v5);
        }
        sub_2F4D0(v6);
        ++v5;
        v4 = *(_QWORD **)(v2 + 80);
      }
      while ( *(_QWORD *)(v2 + 72) > v5 );
    }
    sub_2F4D0(v4);
  }
  sub_2F4D0((void *)v2);
}

void __fastcall sub_9EBF0(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a2 + 8) = 0LL;
  sub_9EAF0((_QWORD ***)(a2 + 3096), (__int64 **)(a2 + 3104));
  sub_294D0(*(unsigned __int64 **)(a2 + 16));
}

signed __int64 __fastcall sub_9EC20(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax

  v3 = *(__int64 **)(a3 + 3096);
  v4 = *(_QWORD *)(a3 + 3224);
  if ( !v3 )
  {
    *(_BYTE *)(a3 + 3276) = 1;
    BUG();
  }
  v5 = a3;
  v6 = *(_QWORD *)(sub_9B3D0(v3, v4, (__int64 (__fastcall *)(__int64))sub_9DB00) + 56);
  *(_BYTE *)(v5 + 3276) = 1;
  if ( !v6 )
    __assert_fail("uc->treeview", "unix/gtkdlg.c", 0xF9Bu, "eventlog_selection_clear");
  v7 = gtk_tree_view_get_type(v3, v4);
  v8 = v7;
  v9 = g_type_check_instance_cast(v6, v7);
  v10 = gtk_tree_view_get_selection(v9, v8);
  gtk_tree_selection_unselect_all(v10);
  *(_BYTE *)(v5 + 3276) = 0;
  return 1LL;
}

__int64 __fastcall sub_9ECC0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v4; // eax
  __int64 v5; // rdi
  __int64 result; // rax

  if ( a4 == 1 )
  {
    v4 = *(_DWORD *)(a1 + 32);
    v5 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)(a2 + 104) = v4;
    result = gtk_widget_destroy(v5);
  }
  return result;
}

__int64 __fastcall sub_9ECE0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdi
  __int64 result; // rax

  if ( a4 == 1 )
  {
    v4 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)(a2 + 104) = 0;
    result = gtk_widget_destroy(v4);
  }
  return result;
}

__int64 __fastcall sub_9ED00(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a2 + 56);
  if ( result == a1 )
    result = *(_QWORD *)(a2 + 64);
  return result;
}

__int64 __fastcall sub_9ED20(__int64 a1, __int64 **a2, int a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rax

  v3 = a1;
  v4 = *a2;
  if ( !*a2 )
    BUG();
  v5 = a3;
  v6 = v3;
  v7 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v7 != 2 )
    __assert_fail("uc->ctrl->generic.type == CTRL_RADIO", "unix/gtkdlg.c", 0x10Fu, "dlg_radiobutton_set");
  v8 = *(_QWORD *)(v7 + 16);
  if ( !v8 )
    __assert_fail("uc->buttons != NULL", "unix/gtkdlg.c", 0x110u, "dlg_radiobutton_set");
  v9 = gtk_toggle_button_get_type(v4, v6);
  v10 = g_type_check_instance_cast(*(_QWORD *)(v8 + 8 * v5), v9);
  return gtk_toggle_button_set_active(v10, 1LL);
}

__int64 __fastcall sub_9EDD0(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // r12
  __int64 v6; // r13
  __int64 v7; // rbp
  __int64 v8; // r14
  unsigned int v9; // ebx
  __int64 v10; // rax

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v5 != 2 )
    __assert_fail("uc->ctrl->generic.type == CTRL_RADIO", "unix/gtkdlg.c", 0x119u, "dlg_radiobutton_get");
  v6 = *(_QWORD *)(v5 + 16);
  if ( !v6 )
    __assert_fail("uc->buttons != NULL", "unix/gtkdlg.c", 0x11Au, "dlg_radiobutton_get");
  if ( *(_DWORD *)(v5 + 24) <= 0 )
    return 0LL;
  v7 = 0LL;
  v8 = gtk_toggle_button_get_type(v3, v4);
  v9 = 0;
  while ( 1 )
  {
    v10 = g_type_check_instance_cast(*(_QWORD *)(v6 + v7), v8);
    if ( (unsigned int)gtk_toggle_button_get_active(v10, v8) )
      break;
    ++v9;
    v7 += 8LL;
    if ( *(_DWORD *)(v5 + 24) <= (signed int)v9 )
      return 0LL;
    v6 = *(_QWORD *)(v5 + 16);
  }
  return v9;
}

__int64 __fastcall sub_9EED0(__int64 a1, __int64 **a2, unsigned __int8 a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  unsigned __int8 v5; // bp
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rax

  v3 = a1;
  v4 = *a2;
  if ( !*a2 )
    BUG();
  v5 = a3;
  v6 = v3;
  v7 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v7 != 3 )
    __assert_fail("uc->ctrl->generic.type == CTRL_CHECKBOX", "unix/gtkdlg.c", 0x124u, "dlg_checkbox_set");
  v8 = gtk_toggle_button_get_type(v4, v6);
  v9 = g_type_check_instance_cast(*(_QWORD *)(v7 + 8), v8);
  return gtk_toggle_button_set_active(v9, v5);
}

bool __fastcall sub_9EF50(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v5 != 3 )
    __assert_fail("uc->ctrl->generic.type == CTRL_CHECKBOX", "unix/gtkdlg.c", 0x12Bu, "dlg_checkbox_get");
  v6 = gtk_toggle_button_get_type(v3, v4);
  v7 = v6;
  v8 = g_type_check_instance_cast(*(_QWORD *)(v5 + 8), v6);
  return (unsigned int)gtk_toggle_button_get_active(v8, v7) != 0;
}

void __fastcall sub_9EFD0(__int64 a1, __int64 **a2, char *a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  char *v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rbp
  char *v12; // rdi
  char *v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rax

  v3 = a1;
  v4 = *a2;
  if ( !*a2 )
    BUG();
  v5 = a3;
  v6 = v3;
  v7 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v7 != 1 )
    __assert_fail("uc->ctrl->generic.type == CTRL_EDITBOX", "unix/gtkdlg.c", 0x134u, "dlg_editbox_set");
  v8 = *(_QWORD *)(v7 + 48);
  if ( v8 )
  {
    v9 = gtk_bin_get_type(v4, v6);
    v6 = v9;
    v10 = g_type_check_instance_cast(v8, v9);
    v11 = gtk_bin_get_child(v10, v6);
  }
  else
  {
    v11 = *(_QWORD *)(v7 + 32);
  }
  if ( !v11 )
    __assert_fail("entry != NULL", "unix/gtkdlg.c", 0x13Du, "dlg_editbox_set");
  v12 = v5;
  v13 = sub_BC120(v5);
  v14 = gtk_entry_get_type(v12, v6);
  v15 = g_type_check_instance_cast(v11, v14);
  gtk_entry_set_text(v15, v13);
  sub_2F4D0(v13);
}

char *__fastcall sub_9F0C0(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // rax
  char *v12; // rax
  __int64 v14; // rbp
  __int64 v15; // rax
  __int64 v16; // rsi
  __int64 v17; // rax
  __int64 v18; // rax

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v5 != 1 )
    __assert_fail("uc->ctrl->generic.type == CTRL_EDITBOX", "unix/gtkdlg.c", 0x158u, "dlg_editbox_get");
  v6 = *(_QWORD *)(v5 + 48);
  if ( v6 )
  {
    v14 = gtk_entry_get_type(v3, v4);
    v15 = gtk_bin_get_type(v3, v4);
    v16 = v15;
    v17 = g_type_check_instance_cast(v6, v15);
    v18 = gtk_bin_get_child(v17, v16);
    v10 = v14;
    v9 = v18;
  }
  else
  {
    v7 = *(_QWORD *)(v5 + 32);
    if ( !v7 )
      __assert_fail("false && \"bad control type in editbox_get\"", "unix/gtkdlg.c", 0x165u, "dlg_editbox_get");
    v8 = gtk_entry_get_type(v3, v4);
    v9 = v7;
    v10 = v8;
  }
  v11 = g_type_check_instance_cast(v9, v10);
  v12 = (char *)gtk_entry_get_text(v11, v10);
  return sub_BC120(v12);
}

__int64 __fastcall sub_9F1A0(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rdi

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( (**(_DWORD **)v5 & 0xFFFFFFFB) != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x177u,
      "dlg_listbox_clear");
  v6 = *(_QWORD *)(v5 + 64);
  if ( !v6 )
    __assert_fail("false && \"bad control type in listbox_clear\"", "unix/gtkdlg.c", 0x18Bu, "dlg_listbox_clear");
  return gtk_list_store_clear(v6, v4);
}

unsigned __int64 __fastcall sub_9F340(__int64 a1, __int64 a2, const char *a3, unsigned int a4)
{
  __int64 v4; // rbx
  __int64 *v5; // rdi
  const char *v6; // r15
  unsigned int v7; // ebp
  __int64 v8; // r12
  int v9; // eax
  __int64 v10; // rdi
  signed int v11; // ebp
  int v12; // eax
  size_t v13; // rbx
  void *v14; // r13
  unsigned __int64 result; // rax
  unsigned __int64 v16; // rt1
  int v17; // eax
  signed int v18; // [rsp+4h] [rbp-74h]
  char v19; // [rsp+10h] [rbp-68h]
  unsigned __int64 v20; // [rsp+38h] [rbp-40h]

  v4 = a1;
  v5 = *(__int64 **)a2;
  v20 = __readfsqword(0x28u);
  if ( !v5 )
    BUG();
  v6 = a3;
  v7 = a4;
  v8 = sub_9B3D0(v5, v4, (__int64 (__fastcall *)(__int64))sub_9DB00);
  v18 = **(_DWORD **)v8 & 0xFFFFFFFB;
  if ( v18 != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x1C2u,
      "dlg_listbox_addwithid");
  v9 = *(_DWORD *)(a2 + 28);
  v10 = *(_QWORD *)(v8 + 64);
  *(_DWORD *)(a2 + 28) |= 1u;
  if ( !v10 )
LABEL_13:
    __assert_fail(
      "false && \"bad control type in listbox_addwithid\"",
      "unix/gtkdlg.c",
      0x24Bu,
      "dlg_listbox_addwithid");
  *(_DWORD *)(a2 + 28) = v9 | 3;
  gtk_list_store_append(v10, &v19);
  *(_DWORD *)(a2 + 28) &= 0xFFFFFFFD;
  gtk_list_store_set(*(_QWORD *)(v8 + 64), &v19, 0LL, v7, 0xFFFFFFFFLL);
  if ( **(_DWORD **)v8 == 5 )
  {
    v17 = *(_DWORD *)(v4 + 76);
    if ( v17 )
    {
      if ( v17 <= 0 )
        goto LABEL_7;
      v18 = *(_DWORD *)(v4 + 76);
    }
  }
  v11 = 0;
  do
  {
    ++v11;
    v12 = strcspn(v6, "\t");
    v13 = v12;
    v14 = sub_2F450(v12 + 1, 1uLL, 0LL);
    memcpy(v14, v6, v13);
    *((_BYTE *)v14 + v13) = 0;
    gtk_list_store_set(*(_QWORD *)(v8 + 64), &v19, (unsigned int)v11, v14, 0xFFFFFFFFLL);
    sub_2F4D0(v14);
    v6 = &v6[v13 + 1 - (v6[v13] < 1u)];
  }
  while ( v11 < v18 );
LABEL_7:
  *(_DWORD *)(a2 + 28) &= 0xFFFFFFFE;
  v16 = __readfsqword(0x28u);
  result = v16 ^ v20;
  if ( v16 != v20 )
    goto LABEL_13;
  return result;
}

unsigned __int64 __fastcall sub_9F520(__int64 a1, __int64 a2, const char *a3)
{
  return sub_9F340(a1, a2, a3, 0);
}

__int64 __fastcall sub_9F530(__int64 a1, __int64 **a2, unsigned int a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  unsigned int v5; // ebp
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // r13
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 result; // rax
  unsigned int v14; // [rsp+Ch] [rbp-5Ch]
  char v15; // [rsp+10h] [rbp-58h]
  unsigned __int64 v16; // [rsp+38h] [rbp-30h]

  v3 = a1;
  v4 = *a2;
  v16 = __readfsqword(0x28u);
  if ( !v4 )
    BUG();
  v5 = a3;
  v6 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( (**(_DWORD **)v6 & 0xFFFFFFFB) != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x255u,
      "dlg_listbox_getid");
  if ( !*(_QWORD *)(v6 + 64) )
    goto LABEL_11;
  v7 = v5;
  v8 = gtk_tree_path_new_from_indices(v5, 0xFFFFFFFFLL);
  v9 = gtk_tree_model_get_type(v7);
  v10 = v9;
  v11 = g_type_check_instance_cast(*(_QWORD *)(v6 + 64), v9);
  gtk_tree_model_get_iter(v11, &v15, v8);
  v12 = g_type_check_instance_cast(*(_QWORD *)(v6 + 64), v10);
  gtk_tree_model_get(v12, &v15, 0LL, &v14, 0xFFFFFFFFLL);
  gtk_tree_path_free(v8, &v15);
  result = v14;
  if ( __readfsqword(0x28u) != v16 )
LABEL_11:
    __assert_fail("false && \"bad control type in listbox_getid\"", "unix/gtkdlg.c", 0x272u, "dlg_listbox_getid");
  return result;
}

__int64 __fastcall sub_9F660(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rbx
  int v12; // edx
  __int64 result; // rax
  __int64 v14; // rax
  __int64 v15; // rsi
  __int64 v16; // rax
  _QWORD *v17; // rax
  _QWORD *v18; // rbx
  __int64 v19; // rbp
  signed int v20; // eax
  unsigned int v21; // ST0C_4
  signed int *v22; // rax
  char v23; // [rsp+10h] [rbp-28h]
  unsigned __int64 v24; // [rsp+18h] [rbp-20h]

  v2 = a1;
  v3 = *a2;
  v24 = __readfsqword(0x28u);
  if ( !v3 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( (**(_DWORD **)v5 & 0xFFFFFFFB) != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x27Cu,
      "dlg_listbox_index");
  v6 = *(_QWORD *)(v5 + 48);
  if ( v6 )
  {
    v14 = gtk_combo_box_get_type(v3, v4);
    v15 = v14;
    v16 = g_type_check_instance_cast(v6, v14);
    result = gtk_combo_box_get_active(v16, v15);
  }
  else
  {
    v7 = *(_QWORD *)(v5 + 56);
    if ( !v7 )
      goto LABEL_18;
    v8 = gtk_tree_view_get_type(v3, v4);
    v9 = v8;
    v10 = g_type_check_instance_cast(v7, v8);
    v11 = gtk_tree_view_get_selection(v10, v9);
    v12 = gtk_tree_selection_count_selected_rows(v11);
    result = 0xFFFFFFFFLL;
    if ( v12 == 1 )
    {
      v17 = (_QWORD *)gtk_tree_selection_get_selected_rows(v11, &v23);
      v18 = v17;
      if ( !v17 || (v19 = *v17) == 0 )
        __assert_fail("sellist && sellist->data", "unix/gtkdlg.c", 0x2B3u, "dlg_listbox_index");
      if ( (unsigned int)gtk_tree_path_get_depth(*v17) == 1
        && (v22 = (signed int *)gtk_tree_path_get_indices(v19)) != 0LL )
      {
        v20 = *v22;
      }
      else
      {
        v20 = -1;
      }
      v21 = v20;
      g_list_foreach(v18, &gtk_tree_path_free, 0LL);
      g_list_free(v18);
      result = v21;
    }
  }
  if ( __readfsqword(0x28u) != v24 )
LABEL_18:
    __assert_fail("false && \"bad control type in listbox_index\"", "unix/gtkdlg.c", 0x2C7u, "dlg_listbox_index");
  return result;
}

__int64 __fastcall sub_9F810(__int64 a1, __int64 **a2, unsigned int a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  __int64 v5; // rsi
  unsigned int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rsi
  __int64 v16; // rbp
  __int64 result; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rax

  v3 = a1;
  v4 = *a2;
  if ( !*a2 )
    BUG();
  v5 = v3;
  v6 = a3;
  v7 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( (**(_DWORD **)v7 & 0xFFFFFFFB) != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x2D0u,
      "dlg_listbox_issel");
  v8 = *(_QWORD *)(v7 + 48);
  if ( v8 )
  {
    v18 = gtk_combo_box_get_type(v4, v5);
    v19 = v18;
    v20 = g_type_check_instance_cast(v8, v18);
    LOBYTE(v6) = (unsigned int)gtk_combo_box_get_active(v20, v19) == v6;
    result = v6;
  }
  else
  {
    v9 = *(_QWORD *)(v7 + 56);
    if ( !v9 )
      __assert_fail("false && \"bad control type in listbox_issel\"", "unix/gtkdlg.c", 0x300u, "dlg_listbox_issel");
    v10 = gtk_tree_view_get_type(v4, v5);
    v11 = v10;
    v12 = g_type_check_instance_cast(v9, v10);
    v13 = gtk_tree_view_get_selection(v12, v11);
    v14 = gtk_tree_path_new_from_indices(v6, 0xFFFFFFFFLL);
    v15 = v14;
    v16 = v14;
    LOBYTE(v6) = (unsigned int)gtk_tree_selection_path_is_selected(v13, v14) != 0;
    gtk_tree_path_free(v16, v15);
    result = v6;
  }
  return result;
}

void __fastcall sub_9F930(__int64 a1, __int64 **a2, __int64 a3, int a4)
{
  int v4; // er13
  __int64 v5; // r12
  __int64 v6; // r13
  int v7; // er15
  __int64 v8; // r14
  const char *v9; // rdx
  int v10; // eax
  int v11; // er13

  v4 = a4;
  v5 = a3;
  if ( a4 )
  {
    if ( a4 == 3 && !*(_BYTE *)(a3 + 3276) )
    {
      sub_BC590(*(__int64 **)(a3 + 3264), 0LL);
      if ( *(_DWORD *)(v5 + 3248) > 0 )
      {
        v6 = 0LL;
        do
        {
          if ( (unsigned __int8)sub_9F810(a1, a2, v6) )
            sub_BC720(*(_QWORD *)(v5 + 3264), (__int64)&off_F813B, *(_QWORD *)(*(_QWORD *)(v5 + 3232) + 8 * v6));
          ++v6;
        }
        while ( *(_DWORD *)(v5 + 3248) > (signed int)v6 );
      }
      if ( *(_DWORD *)(v5 + 3252) > 0 )
      {
        v11 = 0;
        do
        {
          if ( (unsigned __int8)sub_9F810(a1, a2, v11 + *(_DWORD *)(v5 + 3248)) )
            sub_BC720(
              *(_QWORD *)(v5 + 3264),
              (__int64)&off_F813B,
              *(_QWORD *)(*(_QWORD *)(v5 + 3240) + 8LL * ((v11 + *(_DWORD *)(v5 + 3256)) % 128)));
          ++v11;
        }
        while ( *(_DWORD *)(v5 + 3252) > v11 );
      }
      if ( (unsigned int)gtk_selection_owner_set(*(_QWORD *)(v5 + 8), 1LL, 0LL) )
      {
        gtk_selection_add_target(*(_QWORD *)(v5 + 8), 1LL, 31LL, 1LL);
        gtk_selection_add_target(*(_QWORD *)(v5 + 8), 1LL, qword_326540, 1LL);
      }
    }
  }
  else
  {
    sub_9F1A0(a1, a2);
    if ( *(_DWORD *)(v5 + 3248) > 0 )
    {
      v7 = 0;
      v8 = 0LL;
      do
      {
        ++v7;
        v9 = *(const char **)(*(_QWORD *)(v5 + 3232) + v8);
        v8 += 8LL;
        sub_9F340(a1, (__int64)a2, v9, 0);
      }
      while ( *(_DWORD *)(v5 + 3248) > v7 );
    }
    if ( *(_DWORD *)(v5 + 3252) > 0 )
    {
      do
      {
        v10 = v4++ + *(_DWORD *)(v5 + 3256);
        sub_9F340(a1, (__int64)a2, *(const char **)(*(_QWORD *)(v5 + 3240) + 8LL * (v10 % 128)), 0);
      }
      while ( *(_DWORD *)(v5 + 3252) > v4 );
    }
  }
}

__int64 __fastcall sub_9FB80(__int64 a1, __int64 **a2, unsigned int a3)
{
  __int64 v3; // rax
  __int64 *v4; // rdi
  __int64 v5; // rsi
  unsigned int v6; // ebp
  __int64 v7; // rbx
  __int64 v8; // r12
  __int64 v9; // r12
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // r13
  __int64 v13; // rax
  __int64 v14; // r12
  __int64 v15; // rbp
  __int64 v16; // rax
  __int64 result; // rax
  __int64 v18; // rax
  __int64 v19; // rax

  v3 = a1;
  v4 = *a2;
  if ( !*a2 )
    BUG();
  v5 = v3;
  v6 = a3;
  v7 = sub_9B3D0(v4, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( (**(_DWORD **)v7 & 0xFFFFFFFB) != 1 )
    __assert_fail(
      "uc->ctrl->generic.type == CTRL_EDITBOX || uc->ctrl->generic.type == CTRL_LISTBOX",
      "unix/gtkdlg.c",
      0x309u,
      "dlg_listbox_select");
  v8 = *(_QWORD *)(v7 + 48);
  if ( v8 )
  {
    v18 = gtk_combo_box_get_type(v4, v5);
    v19 = g_type_check_instance_cast(v8, v18);
    result = gtk_combo_box_set_active(v19, v6);
  }
  else
  {
    v9 = *(_QWORD *)(v7 + 56);
    if ( !v9 )
      __assert_fail("false && \"bad control type in listbox_select\"", "unix/gtkdlg.c", 0x345u, "dlg_listbox_select");
    v10 = gtk_tree_view_get_type(v4, v5);
    v11 = v10;
    v12 = v10;
    v13 = g_type_check_instance_cast(v9, v10);
    v14 = gtk_tree_view_get_selection(v13, v11);
    v15 = gtk_tree_path_new_from_indices(v6, 0xFFFFFFFFLL);
    gtk_tree_selection_select_path(v14, v15);
    v16 = g_type_check_instance_cast(*(_QWORD *)(v7 + 56), v12);
    gtk_tree_view_scroll_to_cell(v16, v15, 0LL, 0LL);
    result = gtk_tree_path_free(v15, v15);
  }
  return result;
}

void __fastcall sub_9FD80(__int64 a1, __int64 **a2, __int64 a3)
{
  __int64 *v3; // rax
  __int64 v4; // rbp
  __int64 v5; // rsi
  __int64 v6; // rbx
  __int64 *v7; // rdi
  __int64 v8; // r12
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax

  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = a3;
  v5 = a1;
  v6 = a1;
  v7 = v3;
  v8 = sub_9B3D0(v3, v5, (__int64 (__fastcall *)(__int64))sub_9DB00);
  switch ( **(_DWORD **)v8 )
  {
    case 1:
    case 2:
    case 5:
    case 7:
    case 8:
      v9 = gtk_label_get_type(v7);
      v10 = g_type_check_instance_cast(*(_QWORD *)(v8 + 80), v9);
      gtk_label_set_text(v10, v4);
      sub_9DBC0(*(_QWORD *)(v8 + 80), *(char *)(v6 + 56));
      break;
    case 3:
    case 4:
      v11 = gtk_label_get_type(v7);
      v12 = g_type_check_instance_cast(*(_QWORD *)(v8 + 8), v11);
      gtk_label_set_text(v12, v4);
      sub_9DBC0(*(_QWORD *)(v8 + 8), *(char *)(v6 + 56));
      break;
    default:
      __assert_fail("false && \"bad control type in label_change\"", "unix/gtkdlg.c", 0x374u, "dlg_label_change");
      return;
  }
}

void __fastcall sub_9FE60(__int64 a1, __int64 **a2, char **a3)
{
  __int64 v3; // rax
  char **v4; // rbx
  __int64 *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax
  char *v8; // rdi
  __int64 v9; // rbp
  char *v10; // rbx
  __int64 v11; // rbp
  __int64 v12; // rax
  __int64 v13; // rax

  v3 = a1;
  v4 = a3;
  v5 = *a2;
  if ( !*a2 )
  {
    sub_BC120(*a3);
    BUG();
  }
  v6 = v3;
  v7 = sub_9B3D0(v5, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  v8 = *v4;
  v9 = v7;
  v10 = sub_BC120(*v4);
  if ( **(_DWORD **)v9 != 7 )
    __assert_fail("uc->ctrl->generic.type == CTRL_FILESELECT", "unix/gtkdlg.c", 0x37Eu, "dlg_filesel_set");
  v11 = *(_QWORD *)(v9 + 32);
  if ( !v11 )
    __assert_fail(aUc, "unix/gtkdlg.c", 0x37Fu, "dlg_filesel_set");
  v12 = gtk_entry_get_type(v8, v6);
  v13 = g_type_check_instance_cast(v11, v12);
  gtk_entry_set_text(v13, v10);
  sub_2F4D0(v10);
}

_QWORD *__fastcall sub_9FF20(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  char *v10; // rax

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v5 != 7 )
    __assert_fail("uc->ctrl->generic.type == CTRL_FILESELECT", "unix/gtkdlg.c", 0x387u, "dlg_filesel_get");
  v6 = *(_QWORD *)(v5 + 32);
  if ( !v6 )
    __assert_fail(aUc, "unix/gtkdlg.c", 0x388u, "dlg_filesel_get");
  v7 = gtk_entry_get_type(v3, v4);
  v8 = v7;
  v9 = g_type_check_instance_cast(v6, v7);
  v10 = (char *)gtk_entry_get_text(v9, v8);
  return sub_B4DD0(v10);
}

void __fastcall sub_9FFC0(__int64 a1, __int64 **a2, char **a3)
{
  __int64 v3; // rax
  char **v4; // rbx
  __int64 *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax
  char *v8; // rdi
  __int64 v9; // rbp
  char *v10; // rbx
  __int64 v11; // rbp
  __int64 v12; // rax
  __int64 v13; // rax

  v3 = a1;
  v4 = a3;
  v5 = *a2;
  if ( !*a2 )
  {
    sub_BC120(*a3);
    BUG();
  }
  v6 = v3;
  v7 = sub_9B3D0(v5, v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  v8 = *v4;
  v9 = v7;
  v10 = sub_BC120(*v4);
  if ( **(_DWORD **)v9 != 8 )
    __assert_fail("uc->ctrl->generic.type == CTRL_FONTSELECT", "unix/gtkdlg.c", 0x392u, "dlg_fontsel_set");
  v11 = *(_QWORD *)(v9 + 32);
  if ( !v11 )
    __assert_fail(aUc, "unix/gtkdlg.c", 0x393u, "dlg_fontsel_set");
  v12 = gtk_entry_get_type(v8, v6);
  v13 = g_type_check_instance_cast(v11, v12);
  gtk_entry_set_text(v13, v10);
  sub_2F4D0(v10);
}

_QWORD *__fastcall sub_A0080(__int64 a1, __int64 **a2)
{
  __int64 v2; // rax
  __int64 *v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  char *v10; // rax

  v2 = a1;
  v3 = *a2;
  if ( !*a2 )
    BUG();
  v4 = v2;
  v5 = sub_9B3D0(v3, v2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  if ( **(_DWORD **)v5 != 8 )
    __assert_fail("uc->ctrl->generic.type == CTRL_FONTSELECT", "unix/gtkdlg.c", 0x39Bu, "dlg_fontsel_get");
  v6 = *(_QWORD *)(v5 + 32);
  if ( !v6 )
    __assert_fail(aUc, "unix/gtkdlg.c", 0x39Cu, "dlg_fontsel_get");
  v7 = gtk_entry_get_type(v3, v4);
  v8 = v7;
  v9 = g_type_check_instance_cast(v6, v7);
  v10 = (char *)gtk_entry_get_text(v9, v8);
  return sub_B51E0(v10);
}

void nullsub_37()
{
  ;
}

void nullsub_38()
{
  ;
}

__int64 __fastcall sub_A0140(__int64 **a1, __int64 **a2)
{
  _QWORD *v2; // r12
  __int64 **v3; // rbx
  __int64 *v4; // rdi
  __int64 result; // rax
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // r14
  int v9; // er13
  __int64 v10; // rax

  v2 = 0LL;
  v3 = a1;
  v4 = *a2;
  if ( *a2 )
  {
    a2 = v3;
    v2 = (_QWORD *)sub_9B3D0(v4, (__int64)v3, (__int64 (__fastcall *)(__int64))sub_9DB00);
  }
  result = *(unsigned int *)v3;
  switch ( (_DWORD)result )
  {
    case 1:
    case 7:
    case 8:
      v6 = v2[4];
      if ( v6 )
        goto LABEL_8;
      v6 = v2[6];
      if ( v6 )
        goto LABEL_8;
      break;
    case 2:
      result = *((unsigned int *)v3 + 16);
      if ( (signed int)result > 0 )
      {
        v7 = 0LL;
        v8 = gtk_toggle_button_get_type(v4, a2);
        v9 = 0;
        do
        {
          v10 = g_type_check_instance_cast(*(_QWORD *)(v2[2] + v7), v8);
          result = gtk_toggle_button_get_active(v10, v8);
          if ( (_DWORD)result )
            result = gtk_widget_grab_focus(*(_QWORD *)(v2[2] + v7));
          ++v9;
          v7 += 8LL;
        }
        while ( *((_DWORD *)v3 + 16) > v9 );
      }
      break;
    case 3:
    case 4:
      v6 = v2[1];
      goto LABEL_8;
    case 5:
      v6 = v2[6];
      if ( !v6 )
      {
        v6 = v2[7];
        if ( !v6 )
          __assert_fail("false && \"bad control type in set_focus\"", "unix/gtkdlg.c", 0x3F4u, "dlg_set_focus");
      }
LABEL_8:
      result = gtk_widget_grab_focus(v6);
      break;
    default:
      return result;
  }
  return result;
}

__int64 __fastcall sub_A0250(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = gdk_display_get_default(a1, a2);
  return gdk_display_beep(v2);
}

__int64 __fastcall sub_A0270(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 104) = a2;
  return gtk_widget_destroy(*(_QWORD *)(a1 + 40));
}

_QWORD *__fastcall sub_A0280(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  signed int i; // ebp
  __int64 v4; // rdi
  void (__fastcall *v5)(__int64, __int64, _QWORD, _QWORD); // rax

  if ( a1 )
  {
    result = *(_QWORD **)(a1 + 24);
    if ( result )
      result = (_QWORD *)((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD))result)(
                           a1,
                           a2,
                           *(_QWORD *)(a2 + 16),
                           0LL);
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      result = (_QWORD *)sub_9B010(*(__int64 **)a2, i);
      if ( !result )
        break;
      v4 = *result;
      if ( !*result )
        __assert_fail("uc->ctrl != NULL", "unix/gtkdlg.c", 0x443u, "dlg_refresh");
      v5 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v4 + 24);
      if ( v5 )
        v5(v4, a2, *(_QWORD *)(a2 + 16), 0LL);
    }
  }
  return result;
}

unsigned __int64 __fastcall sub_A0310(__int64 a1, __int64 a2)
{
  __int64 *v3; // rbx
  unsigned int v4; // eax
  __int64 v5; // rsi
  int v6; // [rsp+4h] [rbp-54h]
  __int64 v7; // [rsp+8h] [rbp-50h]
  char v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( (unsigned int)gtk_tree_selection_get_selected(a1, &v7, &v8) )
  {
    gtk_tree_model_get(v7, &v8, 1LL, &v6, 0xFFFFFFFFLL);
    v3 = *(__int64 **)(a2 + 8LL * v6);
    v4 = gtk_notebook_page_num(v3[1], v3[2]);
    gtk_notebook_set_current_page(v3[1], v4);
    v5 = *v3;
    *(_QWORD *)(v5 + 88) = v3;
    sub_A0280(0LL, v5);
    *(_QWORD *)(*v3 + 32) = v3 + 5;
  }
  return __readfsqword(0x28u) ^ v9;
}

unsigned __int64 __fastcall sub_A03D0(__int64 *a1, __int64 **a2, signed int a3, signed int a4, signed int a5)
{
  __int64 **v5; // r14
  signed int v6; // er13
  __int64 v7; // rdx
  signed int v8; // er12
  signed int v9; // ebp
  __int64 *v10; // rax
  __int64 v11; // ST08_8
  __int64 v12; // ST00_8
  __int64 v13; // rsi
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // r15
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  double v23; // [rsp+10h] [rbp-68h]
  double v24; // [rsp+18h] [rbp-60h]
  double v25; // [rsp+20h] [rbp-58h]
  __int64 v26; // [rsp+28h] [rbp-50h]
  unsigned __int64 v27; // [rsp+38h] [rbp-40h]

  v5 = a2;
  v6 = a3;
  v7 = 0LL;
  v8 = a4;
  v9 = a5;
  v27 = __readfsqword(0x28u);
  v10 = *a2;
  if ( *a2 )
  {
    a2 = (__int64 **)a1;
    a1 = v10;
    v7 = sub_9B3D0(v10, (__int64)a2, (__int64 (__fastcall *)(__int64))sub_9DB00);
  }
  v11 = v7;
  v12 = gtk_window_get_type(a1, a2);
  v13 = g_type_check_instance_cast(v5[5], v12);
  v14 = gtk_color_chooser_dialog_new("Select a colour", v13);
  v15 = gtk_color_chooser_get_type("Select a colour", v13);
  v16 = v15;
  v17 = g_type_check_instance_cast(v14, v15);
  gtk_color_chooser_set_use_alpha(v17, 0LL);
  *((_BYTE *)v5 + 27) = 0;
  v18 = g_type_check_instance_cast(v14, v12);
  gtk_window_set_modal(v18, 1LL);
  v26 = 4607182418800017408LL;
  v23 = (double)v6 / 255.0;
  v24 = (double)v8 / 255.0;
  v25 = (double)v9 / 255.0;
  v19 = g_type_check_instance_cast(v14, v16);
  gtk_color_chooser_set_rgba(v19, &v23);
  v20 = g_type_check_instance_cast(v14, 80LL);
  g_object_set_data(v20, "user-data", v11);
  v21 = g_type_check_instance_cast(v14, 80LL);
  g_signal_connect_data(v21, "response", sub_9DC80, v5, 0LL, 0LL);
  gtk_widget_show(v14);
  return __readfsqword(0x28u) ^ v27;
}

__int64 __fastcall sub_A0560(__int64 a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  __int64 result; // rax

  result = a2[27];
  if ( (_BYTE)result )
  {
    *a3 = a2[24];
    *a4 = a2[25];
    *a5 = a2[26];
  }
  return result;
}

__int64 __fastcall sub_A0580(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rsi
  unsigned __int64 v9; // r15
  __int64 v10; // rax
  int *v11; // r12
  void *__ptr32 *v12; // rdx
  __int64 result; // rax
  _QWORD *v14; // rax
  int v15; // edx
  __int64 v16; // rbx
  const char *v17; // r13
  _QWORD *v18; // rbp
  __int64 v19; // rax
  _QWORD *v20; // rax
  signed __int64 v21; // rsi
  __int64 v22; // rdi
  __int64 v23; // r13
  __int64 v24; // rax
  const char **v25; // rdi
  __int64 v26; // rax
  _QWORD *v27; // rax
  __int64 v28; // r13
  __int64 v29; // rax
  __int64 v30; // rdi
  __int64 v31; // rax
  const char **v32; // rax
  __int64 v33; // rax
  __int64 v34; // r13
  __int64 v35; // rax
  const char **v36; // rax
  __int64 v37; // ST20_8
  __int64 v38; // ST18_8
  __int64 v39; // rax
  _QWORD *v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax
  int v43; // eax
  __int64 v44; // rdi
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rsi
  __int64 v49; // rax
  __int64 v50; // r12
  int v51; // er13
  char *v52; // rax
  unsigned int v53; // ecx
  char *v54; // rbp
  __int64 v55; // rax
  __int64 v56; // rdi
  __int64 v57; // rsi
  __int64 v58; // rdi
  __int64 v59; // ST18_8
  __int64 v60; // rax
  __int64 v61; // r13
  __int64 v62; // rax
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rax
  const char *v66; // rsi
  __int64 v67; // rdi
  __int64 v68; // r13
  __int64 v69; // rax
  __int64 v70; // rax
  int v71; // eax
  __int64 v72; // rax
  const char **v73; // rdi
  __int64 v74; // rax
  _QWORD *v75; // rdi
  __int64 v76; // rax
  const char **v77; // rax
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 v80; // rdi
  __int64 v81; // rax
  int v82; // er13
  __int64 v83; // rsi
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  __int64 v88; // rdi
  __int64 v89; // rax
  int v90; // er13
  __int64 v91; // rsi
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // rdi
  __int64 v96; // r13
  __int64 v97; // rax
  const char **v98; // rdi
  __int64 v99; // rax
  _QWORD *v100; // rax
  __int64 v101; // rdi
  __int64 v102; // rax
  int v103; // er13
  __int64 v104; // r8
  signed int v105; // ecx
  int v106; // esi
  int v107; // eax
  __int64 v108; // rax
  _QWORD *v109; // rax
  unsigned __int64 v110; // rdi
  void *v111; // rax
  int v112; // ecx
  __int64 v113; // rax
  int *v114; // rbx
  __int64 v115; // r14
  __int64 v116; // r12
  int v117; // er15
  __int64 v118; // r13
  __int64 v119; // rax
  __int64 v120; // rdi
  __int64 v121; // rax
  int v122; // ecx
  int v123; // edx
  int v124; // ecx
  __int64 v125; // rax
  const char **v126; // rdi
  __int64 v127; // rax
  _QWORD *v128; // rax
  __int64 v129; // rax
  __int64 v130; // rdi
  __int64 v131; // rax
  int v132; // er15
  __int64 v133; // rax
  __int64 v134; // rsi
  __int64 v135; // rax
  __int64 v136; // rax
  __int64 v137; // rax
  __int64 v138; // rax
  __int64 v139; // r13
  __int64 v140; // rax
  __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // rax
  __int64 v144; // rax
  const char *v145; // rsi
  __int64 v146; // rax
  __int64 v147; // rdi
  __int64 v148; // rax
  _QWORD *v149; // rdi
  __int64 v150; // rax
  const char **v151; // rdi
  __int64 v152; // rax
  _QWORD *v153; // rdi
  __int64 v154; // rax
  const char **v155; // rdi
  __int64 v156; // rax
  _QWORD *v157; // rax
  __int64 v158; // rdi
  __int64 v159; // r13
  __int64 v160; // rax
  __int64 v161; // rbp
  __int64 v162; // rax
  __int64 v163; // rsi
  __int64 v164; // rax
  __int64 v165; // rdi
  char *v166; // rax
  char *v167; // rax
  __int64 v168; // rdi
  __int64 v169; // rax
  __int64 v170; // r13
  __int64 v171; // rdi
  __int64 v172; // rax
  __int64 v173; // rax
  __int64 v174; // rbp
  __int64 v175; // rax
  __int64 v176; // rax
  const char *v177; // rsi
  __int64 v178; // rdi
  signed int v179; // eax
  signed int v180; // ebp
  __int64 v181; // rbx
  signed int v182; // er14
  __int64 v183; // r15
  __int64 v184; // rax
  __int64 v185; // r15
  __int64 v186; // rax
  __int64 v187; // rdi
  __int64 v188; // rax
  __int64 v189; // rbp
  __int64 v190; // rax
  __int64 v191; // rbx
  __int64 v192; // rax
  __int64 v193; // rax
  __int64 v194; // ST18_8
  __int64 v195; // rax
  __int64 v196; // rax
  __int64 v197; // rax
  __int64 v198; // rdi
  int v199; // ST20_4
  __int64 v200; // ST18_8
  int v201; // er13
  __int64 v202; // rax
  __int64 v203; // rax
  __int64 v204; // rax
  __int64 v205; // rax
  __int64 v206; // rax
  __int64 v207; // [rsp+8h] [rbp-B0h]
  const char **v208; // [rsp+10h] [rbp-A8h]
  __int64 v209; // [rsp+18h] [rbp-A0h]
  __int64 v210; // [rsp+18h] [rbp-A0h]
  __int64 v211; // [rsp+18h] [rbp-A0h]
  __int64 v212; // [rsp+18h] [rbp-A0h]
  __int64 v213; // [rsp+18h] [rbp-A0h]
  __int64 v214; // [rsp+18h] [rbp-A0h]
  int v215; // [rsp+20h] [rbp-98h]
  __int64 v216; // [rsp+20h] [rbp-98h]
  __int64 v217; // [rsp+28h] [rbp-90h]
  __int64 v218; // [rsp+30h] [rbp-88h]
  __int64 v219; // [rsp+38h] [rbp-80h]
  unsigned __int64 v220; // [rsp+38h] [rbp-80h]
  __int64 v221; // [rsp+40h] [rbp-78h]
  __int64 v222; // [rsp+48h] [rbp-70h]
  unsigned __int64 v223; // [rsp+50h] [rbp-68h]
  __int64 v224; // [rsp+58h] [rbp-60h]
  char v225; // [rsp+68h] [rbp-50h]
  int v226; // [rsp+6Ch] [rbp-4Ch]
  __int64 v227; // [rsp+70h] [rbp-48h]
  unsigned __int64 v228; // [rsp+78h] [rbp-40h]

  v5 = a4;
  v228 = __readfsqword(0x28u);
  v207 = a1;
  v218 = a2;
  v217 = a3;
  v222 = a5;
  if ( *(_QWORD *)(a4 + 8) )
  {
    v6 = sub_9C450(a1);
    v7 = sub_9D170(4LL);
    v208 = (const char **)g_type_check_instance_cast(v7, v6);
    v8 = gtk_widget_get_type(v7, v6);
    v221 = g_type_check_instance_cast(v208, v8);
    gtk_widget_show(v221);
    if ( **(_BYTE **)(v5 + 8) )
    {
      v187 = *(_QWORD *)(v5 + 16);
      v221 = gtk_frame_new(v187, v8);
      v188 = gtk_container_get_type(v187);
      v189 = v188;
      v190 = g_type_check_instance_cast(v208, v188);
      gtk_container_set_border_width(v190, 4LL);
      v191 = g_type_check_instance_cast(v208, v8);
      v192 = g_type_check_instance_cast(v221, v189);
      gtk_container_add(v192, v191);
      gtk_widget_show(v221);
    }
    if ( *(_QWORD *)(v5 + 32) )
    {
      v9 = 0LL;
      do
      {
        while ( 1 )
        {
          v11 = *(int **)(*(_QWORD *)(v5 + 48) + 8 * v9);
          if ( *v11 == 6 )
            break;
          if ( *v11 == 9 )
          {
            if ( *(_QWORD *)v207 )
            {
              v10 = sub_9B3D0(*(__int64 **)v207, *((_QWORD *)v11 + 7), (__int64 (__fastcall *)(__int64))sub_9DB00);
              if ( v10 )
                sub_9D740(v208, *(_QWORD *)(v10 + 8));
            }
          }
          else
          {
            v14 = sub_2F450(1uLL, 0x78uLL, 0LL);
            v15 = *v11;
            v16 = (__int64)v14;
            *v14 = v11;
            v14[2] = 0LL;
            v14[4] = 0LL;
            v14[6] = 0LL;
            v14[12] = v218;
            v14[7] = 0LL;
            v14[8] = 0LL;
            v14[9] = 0LL;
            v14[5] = 0LL;
            v14[10] = 0LL;
            *((_DWORD *)v14 + 28) = 0;
            switch ( v15 )
            {
              case 0:
                v158 = *((_QWORD *)v11 + 1);
                v18 = (_QWORD *)gtk_label_new(v158, 120LL);
                *(_QWORD *)(v16 + 72) = v18;
                v159 = gtk_label_get_type(v158);
                g_type_check_instance_cast(v18, v159);
                sub_AB600();
                v160 = g_type_check_instance_cast(v18, v159);
                gtk_label_set_line_wrap(v160, 1LL);
                goto LABEL_23;
              case 1:
                if ( *((_BYTE *)v11 + 65) )
                {
                  v161 = gtk_list_store_new(2LL, 24LL, 64LL);
                  *(_QWORD *)(v16 + 64) = v161;
                  v162 = gtk_tree_model_get_type(2LL);
                  v163 = v162;
                  v164 = g_type_check_instance_cast(v161, v162);
                  v18 = (_QWORD *)gtk_combo_box_new_with_model_and_entry(v164, v163);
                  v165 = g_type_check_instance_cast(v18, 80LL);
                  g_object_set(v165, "entry-text-column", 1LL, 0LL);
                  if ( *((_BYTE *)v11 + 64) )
                    __assert_fail("!ctrl->editbox.password", "unix/gtkdlg.c", 0x7ECu, "layout_ctrls");
                  *(_QWORD *)(v16 + 48) = v18;
                  v139 = gtk_entry_get_type(v165, "entry-text-column");
                }
                else
                {
                  v18 = (_QWORD *)gtk_entry_new(1LL, 120LL);
                  v138 = gtk_entry_get_type(1LL, 120LL);
                  v139 = v138;
                  if ( *((_BYTE *)v11 + 64) )
                  {
                    v205 = g_type_check_instance_cast(v18, v138);
                    gtk_entry_set_visibility(v205, 0LL);
                  }
                  *(_QWORD *)(v16 + 32) = v18;
                }
                v140 = g_type_check_instance_cast(v18, 80LL);
                *(_DWORD *)(v16 + 104) = g_signal_connect_data(v140, "changed", sub_9E770, v207, 0LL, 0LL);
                v141 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v141, "key_press_event", sub_9DE10, v207, 0LL, 0LL);
                v142 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v142, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v143 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v143, "focus_out_event", sub_9E2C0, v207, 0LL, 0LL);
                v144 = g_type_check_instance_cast(v18, 80LL);
                v145 = "focus_out_event";
                g_signal_connect_data(v144, "focus_out_event", sub_9E2C0, v207, 0LL, 0LL);
                if ( v18 )
                {
                  if ( *v18 && *(_QWORD *)*v18 == v139
                    || (v145 = (const char *)v139, (unsigned int)g_type_check_instance_is_a(v18, v139)) )
                  {
                    v146 = g_type_check_instance_cast(v18, v139);
                    v145 = (_BYTE *)(&n + 1);
                    gtk_entry_set_width_chars(v146, 1LL);
                  }
                  v147 = *((_QWORD *)v11 + 1);
                  if ( !v147 )
                    goto LABEL_24;
                }
                else
                {
                  v147 = *((_QWORD *)v11 + 1);
                  if ( !v147 )
                    goto LABEL_42;
                }
                v68 = gtk_label_new(v147, v145);
                sub_9E0B0(v217, v68, *((char *)v11 + 56), 2, *(_QWORD *)(v16 + 32));
                v210 = sub_9D170(4LL);
                v71 = v11[15];
                if ( v71 == 100 )
                {
LABEL_36:
                  v72 = sub_9C450(4LL);
                  v73 = (const char **)g_type_check_instance_cast(v210, v72);
                  sub_9D2C0(v73, v68, 0, 1);
                  v74 = sub_9C450((__int64)v73);
                  v75 = (_QWORD *)g_type_check_instance_cast(v210, v74);
                  sub_9D510(v75, v68);
                  v76 = sub_9C450((__int64)v75);
                  v77 = (const char **)g_type_check_instance_cast(v210, v76);
                  sub_9D2C0(v77, (__int64)v18, 0, 1);
                }
                else
                {
LABEL_69:
                  HIDWORD(v227) = v71;
                  LODWORD(v227) = 100 - v71;
                  v148 = sub_9C450(4LL);
                  v149 = (_QWORD *)g_type_check_instance_cast(v210, v148);
                  sub_9D1B0(v149, 2, (__int64)&v227);
                  v150 = sub_9C450((__int64)v149);
                  v151 = (const char **)g_type_check_instance_cast(v210, v150);
                  sub_9D2C0(v151, v68, 0, 1);
                  v152 = sub_9C450((__int64)v151);
                  v153 = (_QWORD *)g_type_check_instance_cast(v210, v152);
                  sub_9D510(v153, v68);
                  v154 = sub_9C450((__int64)v153);
                  v155 = (const char **)g_type_check_instance_cast(v210, v154);
                  sub_9D2C0(v155, (__int64)v18, 1, 1);
                  v156 = sub_9C450((__int64)v155);
                  v157 = (_QWORD *)g_type_check_instance_cast(v210, v156);
                  sub_9D600(v157, v68, (__int64)v18);
                }
                gtk_widget_show(v68);
                gtk_widget_show(v18);
                *(_QWORD *)(v16 + 80) = v68;
                v18 = (_QWORD *)v210;
LABEL_23:
                if ( !v18 )
LABEL_42:
                  __assert_fail("w != NULL", "unix/gtkdlg.c", 0x9B7u, "layout_ctrls");
                goto LABEL_24;
              case 2:
                v94 = sub_9D170(0LL);
                v95 = *((_QWORD *)v11 + 1);
                v18 = (_QWORD *)v94;
                if ( v95 )
                {
                  v96 = gtk_label_new(v95, 120LL);
                  v97 = sub_9C450(v95);
                  v98 = (const char **)g_type_check_instance_cast(v18, v97);
                  sub_9D2C0(v98, v96, 0, 1);
                  v99 = sub_9C450((__int64)v98);
                  v100 = (_QWORD *)g_type_check_instance_cast(v18, v99);
                  sub_9D510(v100, v96);
                  gtk_widget_show(v96);
                  sub_9E0B0(v217, v96, *((char *)v11 + 56), 3, v16);
                  *(_QWORD *)(v16 + 80) = v96;
                }
                v101 = v11[15];
                v102 = g_malloc_n(v101, 4LL);
                v103 = v11[15];
                v211 = v102;
                if ( v103 > 0 )
                {
                  v104 = v102;
                  v105 = 100;
                  LODWORD(v101) = 0;
                  do
                  {
                    v101 = (unsigned int)(v101 + 1);
                    v104 += 4LL;
                    v106 = v105 / v103;
                    v107 = v105 - 100;
                    v105 += 100;
                    *(_DWORD *)(v104 - 4) = v106 - v107 / v103;
                    v103 = v11[15];
                  }
                  while ( (signed int)v101 < v103 );
                }
                v108 = sub_9C450(v101);
                v109 = (_QWORD *)g_type_check_instance_cast(v18, v108);
                sub_9D1B0(v109, v103, v211);
                g_free(v211);
                v110 = v11[16];
                *(_DWORD *)(v16 + 24) = v110;
                v111 = sub_2F450(v110, 8uLL, 0LL);
                v112 = v11[16];
                *(_QWORD *)(v16 + 16) = v111;
                if ( v112 > 0 )
                {
                  v219 = gtk_radio_button_get_type(v110, 8LL);
                  v113 = v16;
                  v224 = v5;
                  v114 = v11;
                  v212 = 0LL;
                  v223 = v9;
                  v115 = 0LL;
                  v116 = v113;
                  do
                  {
                    v117 = 1;
                    v118 = gtk_radio_button_new_with_label(v212, *(_QWORD *)(*((_QWORD *)v114 + 9) + 8 * v115));
                    *(_QWORD *)(*(_QWORD *)(v116 + 16) + 8 * v115) = v118;
                    v119 = g_type_check_instance_cast(v118, v219);
                    v120 = v119;
                    v121 = gtk_radio_button_get_group(v119, v219);
                    v122 = v114[15];
                    v212 = v121;
                    v123 = (signed int)v115 % v122;
                    v124 = v122 - (signed int)v115 % v122;
                    v215 = v123;
                    if ( v114[16] - 1 == (_DWORD)v115 )
                      v117 = v124;
                    v125 = sub_9C450(v120);
                    v126 = (const char **)g_type_check_instance_cast(v18, v125);
                    sub_9D2C0(v126, v118, v215, v117);
                    v127 = sub_9C450((__int64)v126);
                    v128 = (_QWORD *)g_type_check_instance_cast(v18, v127);
                    sub_9D510(v128, v118);
                    gtk_widget_show(v118);
                    v129 = g_type_check_instance_cast(v118, 80LL);
                    g_signal_connect_data(v129, "toggled", sub_9E320, v207, 0LL, 0LL);
                    v130 = g_type_check_instance_cast(v118, 80LL);
                    g_signal_connect_data(v130, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                    v131 = *((_QWORD *)v114 + 10);
                    if ( v131 )
                    {
                      v132 = *(char *)(v131 + v115);
                      v133 = gtk_bin_get_type(v130, "focus_in_event");
                      v134 = v133;
                      v135 = g_type_check_instance_cast(v118, v133);
                      v136 = gtk_bin_get_child(v135, v134);
                      sub_9E0B0(v217, v136, v132, 3, v116);
                    }
                    ++v115;
                  }
                  while ( v114[16] > (signed int)v115 );
                  v137 = v116;
                  v9 = v223;
                  v11 = v114;
                  v5 = v224;
                  v16 = v137;
                }
                goto LABEL_23;
              case 3:
                v86 = gtk_check_button_new_with_label(*((_QWORD *)v11 + 1), 120LL);
                v18 = (_QWORD *)v86;
                v87 = g_type_check_instance_cast(v86, 80LL);
                g_signal_connect_data(v87, "toggled", sub_9E320, v207, 0LL, 0LL);
                v88 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v88, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v89 = gtk_bin_get_type(v88, "focus_in_event");
                v90 = *((char *)v11 + 56);
                v91 = v89;
                v92 = g_type_check_instance_cast(v18, v89);
                v93 = gtk_bin_get_child(v92, v91);
                sub_9E0B0(v217, v93, v90, 3, v16);
                if ( !v18 )
                  goto LABEL_42;
                sub_9D2C0(v208, (__int64)v18, (unsigned __int16)v11[5], ((unsigned int)v11[5] >> 16) + 1);
                sub_9D510(v208, (__int64)v18);
                goto LABEL_25;
              case 4:
                v78 = gtk_button_new_with_label(*((_QWORD *)v11 + 1));
                v18 = (_QWORD *)v78;
                if ( !v222 )
                  goto LABEL_41;
                gtk_widget_set_can_default(v78, 1LL);
                if ( !*((_BYTE *)v11 + 57) )
                {
                  if ( !*((_BYTE *)v11 + 58) )
                    goto LABEL_41;
LABEL_40:
                  *(_QWORD *)(v207 + 48) = v18;
                  goto LABEL_41;
                }
                gtk_window_set_default(v222, v18);
                if ( *((_BYTE *)v11 + 58) )
                  goto LABEL_40;
LABEL_41:
                v79 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v79, "clicked", sub_9E3C0, v207, 0LL, 0LL);
                v80 = g_type_check_instance_cast(v18, 80LL);
                g_signal_connect_data(v80, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v81 = gtk_bin_get_type(v80, "focus_in_event");
                v82 = *((char *)v11 + 56);
                v83 = v81;
                v84 = g_type_check_instance_cast(v18, v81);
                v85 = gtk_bin_get_child(v84, v83);
                sub_9E0B0(v217, v85, v82, 3, v16);
                if ( !v18 )
                  goto LABEL_42;
LABEL_24:
                sub_9D2C0(v208, (__int64)v18, (unsigned __int16)v11[5], ((unsigned int)v11[5] >> 16) + 1);
LABEL_25:
                v48 = *((_QWORD *)v11 + 6);
                if ( v48 )
                {
                  if ( !*(_QWORD *)v207
                    || (v49 = sub_9B3D0(*(__int64 **)v207, v48, (__int64 (__fastcall *)(__int64))sub_9DB00),
                        (v50 = v49) == 0) )
                  {
                    __assert_fail(off_F629E, "unix/gtkdlg.c", 0x9CAu, "layout_ctrls");
                  }
                  sub_9D600(v208, (__int64)v18, *(_QWORD *)(v49 + 8));
                  gtk_widget_set_valign(v18, 4LL);
                  gtk_widget_set_valign(*(_QWORD *)(v50 + 8), 4LL);
                }
                gtk_widget_show(v18);
                *(_QWORD *)(v16 + 8) = v18;
                sub_9AFD0(*(__int64 **)v207, v16);
                sub_9AFD0(*(__int64 **)(v207 + 8), v16);
                break;
              case 5:
                v51 = v11[19];
                if ( v51 )
                {
                  v166 = (char *)sub_2F450(v51 + 1, 8uLL, 0LL);
                  v54 = v166;
                  *(_QWORD *)v166 = 24LL;
                  v53 = v51 + 1;
                  if ( v51 > 0 )
                  {
                    v167 = v166 + 8;
                    do
                    {
                      *(_QWORD *)v167 = 64LL;
                      v167 += 8;
                    }
                    while ( &v54[8 * (v51 - 1) + 16] != v167 );
                  }
                }
                else
                {
                  v52 = (char *)sub_2F450(2uLL, 8uLL, 0LL);
                  v53 = 2;
                  v54 = v52;
                  *(_QWORD *)v52 = 24LL;
                  *((_QWORD *)v52 + 1) = 64LL;
                }
                *(_QWORD *)(v16 + 64) = gtk_list_store_newv(v53, v54);
                sub_2F4D0(v54);
                v55 = gtk_tree_model_get_type(v54);
                v56 = *(_QWORD *)(v16 + 64);
                v57 = v55;
                if ( !v11[15] )
                {
                  v58 = g_type_check_instance_cast(v56, v55);
                  v18 = (_QWORD *)gtk_combo_box_new_with_model(v58);
                  *(_QWORD *)(v16 + 48) = v18;
                  v59 = gtk_cell_renderer_text_new(v58, v57);
                  v60 = gtk_cell_layout_get_type();
                  v61 = v60;
                  v62 = g_type_check_instance_cast(v18, v60);
                  gtk_cell_layout_pack_start(v62, v59, 1LL);
                  v63 = g_type_check_instance_cast(v18, v61);
                  gtk_cell_layout_set_attributes(v63, v59, "text", 1LL, 0LL);
                  v64 = g_type_check_instance_cast(v18, 80LL);
                  g_signal_connect_data(v64, "changed", sub_9E260, v207, 0LL, 0LL);
                  v65 = g_type_check_instance_cast(v18, 80LL);
                  v66 = "focus_in_event";
                  g_signal_connect_data(v65, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                  goto LABEL_34;
                }
                v169 = g_type_check_instance_cast(v56, v55);
                v170 = gtk_tree_view_new_with_model(v169);
                v171 = g_type_check_instance_cast(*(_QWORD *)(v16 + 64), 80LL);
                g_object_set_data(v171, "user-data", v170);
                v213 = gtk_tree_view_get_type(v171, "user-data");
                v172 = g_type_check_instance_cast(v170, v213);
                gtk_tree_view_set_headers_visible(v172, 0LL);
                v173 = g_type_check_instance_cast(v170, v213);
                v174 = gtk_tree_view_get_selection(v173, v213);
                gtk_tree_selection_set_mode(v174, (unsigned int)v11[17] < 1 ? 1 : 3);
                *(_QWORD *)(v16 + 56) = v170;
                v175 = g_type_check_instance_cast(v170, 80LL);
                g_signal_connect_data(v175, "row-activated", sub_9E200, v207, 0LL, 0LL);
                v176 = g_type_check_instance_cast(v170, 80LL);
                g_signal_connect_data(v176, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v177 = "changed";
                v178 = g_type_check_instance_cast(v174, 80LL);
                g_signal_connect_data(v178, "changed", sub_9E420, v207, 0LL, 0LL);
                if ( *((_BYTE *)v11 + 64) )
                {
                  v206 = g_type_check_instance_cast(v170, v213);
                  gtk_tree_view_set_reorderable(v206, 1LL);
                  v177 = "row-inserted";
                  v178 = g_type_check_instance_cast(*(_QWORD *)(v16 + 64), 80LL);
                  g_signal_connect_data(v178, "row-inserted", sub_9E6D0, v207, 0LL, 0LL);
                }
                v179 = v11[19];
                if ( v179 )
                {
                  if ( v179 <= 0 )
                    goto LABEL_93;
                }
                else
                {
                  v179 = 1;
                }
                v216 = v16;
                v180 = 0;
                v181 = v213;
                v220 = v9;
                v214 = v5;
                v182 = v179;
                do
                {
                  v184 = gtk_cell_renderer_text_new(v178, v177);
                  v185 = v184;
                  if ( !*((_BYTE *)v11 + 88) )
                  {
                    v186 = g_type_check_instance_cast(v184, 80LL);
                    g_object_set(v186, "ellipsize", 3LL, "ellipsize-set");
                  }
                  v183 = gtk_tree_view_column_new_with_attributes("heading", v185, "text", (unsigned int)++v180, 0LL);
                  gtk_tree_view_column_set_sizing(v183, 0LL);
                  v177 = (const char *)v183;
                  v178 = g_type_check_instance_cast(v170, v181);
                  gtk_tree_view_append_column(v178, v183);
                }
                while ( v180 < v182 );
                v16 = v216;
                v9 = v220;
                v5 = v214;
LABEL_93:
                v18 = (_QWORD *)gtk_scrolled_window_new(0LL, 0LL);
                v193 = gtk_scrolled_window_get_type(0LL, 0LL);
                v194 = v193;
                v195 = g_type_check_instance_cast(v18, v193);
                gtk_scrolled_window_set_shadow_type(v195, 1LL);
                gtk_widget_show(v170);
                v196 = gtk_container_get_type(v170);
                v197 = g_type_check_instance_cast(v18, v196);
                gtk_container_add(v197, v170);
                v198 = g_type_check_instance_cast(v18, v194);
                gtk_scrolled_window_set_policy(v198, 1LL, 0LL);
                v199 = v11[15];
                v200 = gtk_cell_renderer_text_new(v198, 1LL);
                gtk_cell_renderer_get_preferred_size(v200, v170, &v225, 0LL);
                v201 = v226;
                v202 = g_type_check_instance_cast(v200, 80LL);
                g_object_ref(v202, 80LL);
                v203 = g_type_check_instance_cast(v200, 80LL);
                g_object_ref_sink(v203, 80LL);
                v204 = g_type_check_instance_cast(v200, 80LL);
                g_object_unref(v204, 80LL);
                v66 = (const char *)0xFFFFFFFFLL;
                gtk_widget_set_size_request(v18, 0xFFFFFFFFLL, (unsigned int)(v201 * v199));
LABEL_34:
                v67 = *((_QWORD *)v11 + 1);
                if ( !v67 )
                  goto LABEL_23;
                v68 = gtk_label_new(v67, v66);
                v69 = gtk_label_get_type(v67);
                v70 = g_type_check_instance_cast(v68, v69);
                gtk_label_set_width_chars(v70, 3LL);
                sub_9E0B0(v217, v68, *((char *)v11 + 56), 3, v16);
                v210 = sub_9D170(4LL);
                v71 = v11[18];
                if ( v71 == 100 )
                  goto LABEL_36;
                goto LABEL_69;
              case 7:
              case 8:
                v17 = "Browse...";
                if ( v15 != 7 )
                  v17 = "Change...";
                v209 = (__int64)v17;
                v227 = 107374182475LL;
                v18 = (_QWORD *)sub_9D170(4LL);
                v19 = sub_9C450(4LL);
                v20 = (_QWORD *)g_type_check_instance_cast(v18, v19);
                v21 = 2LL;
                sub_9D1B0(v20, 2, (__int64)&v227);
                v22 = *((_QWORD *)v11 + 1);
                if ( v22 )
                {
                  v23 = gtk_label_new(v22, 2LL);
                  v24 = sub_9C450(v22);
                  v25 = (const char **)g_type_check_instance_cast(v18, v24);
                  sub_9D2C0(v25, v23, 0, 2);
                  v26 = sub_9C450((__int64)v25);
                  v27 = (_QWORD *)g_type_check_instance_cast(v18, v26);
                  sub_9D510(v27, v23);
                  gtk_widget_show(v23);
                  v22 = v217;
                  v21 = v23;
                  sub_9E0B0(v217, v23, *((char *)v11 + 56), 3, v16);
                  *(_QWORD *)(v16 + 80) = v23;
                }
                v28 = gtk_entry_new(v22, v21);
                *(_QWORD *)(v16 + 32) = v28;
                v29 = gtk_entry_get_type(v22, v21);
                v30 = g_type_check_instance_cast(v28, v29);
                gtk_entry_set_width_chars(v30, 1LL);
                v31 = sub_9C450(v30);
                v32 = (const char **)g_type_check_instance_cast(v18, v31);
                sub_9D2C0(v32, v28, 0, 1);
                gtk_widget_show(v28);
                v33 = gtk_button_new_with_label(v209);
                *(_QWORD *)(v16 + 40) = v33;
                v34 = v33;
                v35 = sub_9C450(v209);
                v36 = (const char **)g_type_check_instance_cast(v18, v35);
                sub_9D2C0(v36, v34, 1, 1);
                gtk_widget_show(v34);
                v37 = *(_QWORD *)(v16 + 40);
                v38 = *(_QWORD *)(v16 + 32);
                v39 = sub_9C450(v34);
                v40 = (_QWORD *)g_type_check_instance_cast(v18, v39);
                sub_9D600(v40, v38, v37);
                v41 = g_type_check_instance_cast(*(_QWORD *)(v16 + 32), 80LL);
                g_signal_connect_data(v41, "key_press_event", sub_9DE10, v207, 0LL, 0LL);
                v42 = g_type_check_instance_cast(*(_QWORD *)(v16 + 32), 80LL);
                v43 = g_signal_connect_data(v42, "changed", sub_9E770, v207, 0LL, 0LL);
                v44 = *(_QWORD *)(v16 + 32);
                *(_DWORD *)(v16 + 104) = v43;
                v45 = g_type_check_instance_cast(v44, 80LL);
                g_signal_connect_data(v45, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v46 = g_type_check_instance_cast(*(_QWORD *)(v16 + 40), 80LL);
                g_signal_connect_data(v46, "focus_in_event", sub_9E380, v207, 0LL, 0LL);
                v47 = g_type_check_instance_cast(v34, 80LL);
                g_signal_connect_data(v47, "clicked", sub_9E480, v207, 0LL, 0LL);
                goto LABEL_23;
              default:
                goto LABEL_42;
            }
          }
          if ( *(_QWORD *)(v5 + 32) <= ++v9 )
            goto LABEL_15;
        }
        v12 = (void *__ptr32 *)*((_QWORD *)v11 + 8);
        if ( !v12 )
          v12 = &off_F7784;
        ++v9;
        sub_9D1B0(v208, v11[14], (__int64)v12);
      }
      while ( *(_QWORD *)(v5 + 32) > v9 );
    }
  }
  else
  {
    v168 = *(_QWORD *)(a4 + 16);
    if ( !v168 )
LABEL_96:
      __assert_fail("s->boxtitle", "unix/gtkdlg.c", 0x73Du, "layout_ctrls");
    v221 = gtk_label_new(v168, a2);
  }
LABEL_15:
  result = v221;
  if ( __readfsqword(0x28u) != v228 )
    goto LABEL_96;
  return result;
}

__int64 __fastcall sub_A1980(__int64 a1, __int64 a2, char *a3, int a4, char a5, __int64 a6, __int64 a7, __int64 a8, __int64 (__fastcall *a9)(__int64, __int64), __int64 a10)
{
  __int64 v10; // r12
  _QWORD *v11; // rax
  _QWORD *v12; // r13
  char *v13; // rax
  unsigned __int64 *v14; // rax
  size_t v15; // r14
  __int64 v16; // rdx
  signed int v17; // ebx
  __int64 v18; // rcx
  signed int v19; // esi
  int v20; // ecx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r15
  void *v24; // rdi
  char *v25; // r9
  __int64 v26; // r8
  signed int v27; // esi
  int v28; // edi
  int v29; // eax
  __int64 v30; // r14
  int v31; // er15
  __int64 v32; // r13
  __int64 v33; // rbp
  __int64 v34; // r12
  __int64 v35; // rax
  __int64 v36; // rax
  int v37; // edx
  __int64 v38; // r12
  __int64 v39; // rax
  __int64 v40; // r15
  __int64 v41; // rbx
  __int64 v42; // rax
  __int64 v43; // rbp
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // r14
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // r12
  __int64 v50; // rax
  __int64 v51; // r14
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 *v54; // rdi
  __int64 v55; // r12
  __int64 v56; // rax
  __int64 v57; // r15
  __int64 v58; // rax
  __int64 v59; // rax
  __int64 v60; // r12
  __int64 v61; // rax
  __int64 v62; // rax
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rax
  __int64 v67; // rax
  char v68; // [rsp+0h] [rbp-C98h]
  __int64 v69; // [rsp+8h] [rbp-C90h]
  __int64 v70; // [rsp+18h] [rbp-C80h]
  __int64 v71; // [rsp+20h] [rbp-C78h]
  char *v72; // [rsp+28h] [rbp-C70h]
  int v73; // [rsp+30h] [rbp-C68h]
  char v74; // [rsp+34h] [rbp-C64h]
  __int64 v75; // [rsp+40h] [rbp-C58h]
  char v76; // [rsp+50h] [rbp-C48h]
  char v77; // [rsp+60h] [rbp-C38h]
  unsigned __int64 v78; // [rsp+C58h] [rbp-40h]
  char v79; // [rsp+C60h] [rbp-38h]

  v10 = a6;
  v70 = a1;
  v71 = a2;
  v72 = a3;
  v73 = a4;
  v74 = a5;
  v78 = __readfsqword(0x28u);
  v11 = sub_2F450(1uLL, 0x80uLL, 0LL);
  v11[14] = a7;
  v11[15] = a8;
  v12 = v11;
  sub_9DEB0((__int64)v11);
  v13 = &v77;
  do
  {
    *(_DWORD *)v13 = 0;
    v13 += 24;
  }
  while ( v13 != &v79 );
  v14 = sub_28870();
  v15 = 0LL;
  v12[12] = v14;
  v16 = 0LL;
  v17 = 1;
  while ( *(_DWORD *)(v10 + 8) > (signed int)v15 )
  {
    v18 = v16 + *(_QWORD *)v10;
    v19 = *(_DWORD *)(v18 + 12);
    v20 = *(_DWORD *)(v18 + 16);
    if ( v17 > v19 )
      v17 = v19;
    ++v15;
    v16 += 24LL;
    if ( v20 < 0 )
      __assert_fail("button->value >= 0", "unix/gtkdlg.c", 0xD0Fu, "create_message_box_general");
  }
  v69 = sub_28A10(v14, &locale, &locale, &locale);
  v23 = sub_28C10(v69, 2, 50LL, 50LL, v21, v22, v68);
  v24 = *(void **)(v23 + 64);
  *(_DWORD *)(v69 + 24) = v15;
  *(_DWORD *)(v23 + 56) = v15;
  v25 = (char *)sub_2F490(v24, v15, 4uLL);
  *(_QWORD *)(v23 + 64) = v25;
  if ( (signed int)v15 > 0 )
  {
    v26 = 0LL;
    v27 = 100;
    while ( 1 )
    {
      v28 = v27 / (signed int)v15;
      v29 = v27 - 100;
      v27 += 100;
      *(_DWORD *)&v25[v26] = v28 - v29 / (signed int)v15;
      v26 += 4LL;
      if ( v27 == 100 * ((_DWORD)v15 + 1) )
        break;
      v25 = *(char **)(v23 + 64);
    }
  }
  v75 = (__int64)v12;
  v30 = 0LL;
  v31 = 0;
  v32 = v10;
  while ( *(_DWORD *)(v32 + 8) > v31 )
  {
    v33 = v30 + *(_QWORD *)v32;
    v34 = sub_28760(*(_DWORD *)(v33 + 16));
    v35 = sub_28770(0LL);
    v36 = sub_290C0(v69, *(char **)v33, *(_BYTE *)(v33 + 8), v35, (__int64)sub_9ECC0, v34);
    v37 = *(_DWORD *)(v33 + 12);
    *(_DWORD *)(v36 + 20) = v31;
    if ( v37 > 0 )
      *(_BYTE *)(v36 + 57) = 1;
    if ( v37 == v17 )
      *(_BYTE *)(v36 + 58) = 1;
    v30 += 24LL;
    ++v31;
  }
  v38 = sub_28A10(*(unsigned __int64 **)(v75 + 96), "x", &locale, &locale);
  v39 = sub_28770(0LL);
  v40 = sub_29350(v38, v72, v39);
  v41 = sub_AB610();
  v42 = gtk_window_get_type(v38, v72);
  v43 = v42;
  v44 = g_type_check_instance_cast(v41, v42);
  gtk_window_set_title(v44, v71);
  v45 = g_type_check_instance_cast(v41, v43);
  v46 = sub_A0580(v75, 0LL, (__int64)&v76, v69, v45);
  if ( a9 )
    v46 = a9(v46, a10);
  v47 = g_type_check_instance_cast(v41, v43);
  sub_AB660(v47, v46);
  gtk_widget_show(v46);
  v48 = g_type_check_instance_cast(v41, v43);
  v49 = sub_A0580(v75, 0LL, (__int64)&v76, v38, v48);
  v50 = gtk_container_get_type(v75);
  v51 = v50;
  v52 = g_type_check_instance_cast(v49, v50);
  gtk_container_set_border_width(v52, 10LL);
  gtk_widget_set_size_request(v49, (unsigned int)(v73 + 20), 0xFFFFFFFFLL);
  v53 = g_type_check_instance_cast(v41, v43);
  sub_AB790(v53, v49, 1u, 1u, 0);
  gtk_widget_show(v49);
  *(_QWORD *)(v75 + 64) = 0LL;
  *(_DWORD *)(v75 + 104) = 0;
  *(_QWORD *)(v75 + 40) = v41;
  *(_QWORD *)(v75 + 32) = &v76;
  if ( v74 )
  {
    v54 = *(__int64 **)v75;
    if ( !*(_QWORD *)v75 )
      BUG();
    v55 = sub_9B3D0(v54, v40, (__int64 (__fastcall *)(__int64))sub_9DB00);
    v56 = gtk_label_get_type(v54);
    v57 = v56;
    v58 = g_type_check_instance_cast(*(_QWORD *)(v55 + 72), v56);
    gtk_label_set_selectable(v58, 1LL);
    gtk_widget_grab_focus(*(_QWORD *)(v55 + 72));
    v59 = g_type_check_instance_cast(*(_QWORD *)(v55 + 72), v57);
    gtk_label_select_region(v59, 0LL, 0LL);
  }
  if ( v70 )
  {
    v60 = g_type_check_instance_cast(v70, v43);
    v61 = g_type_check_instance_cast(v41, v43);
    gtk_window_set_transient_for(v61, v60);
  }
  else
  {
    v67 = g_type_check_instance_cast(v41, v43);
    gtk_window_set_position(v67, 1LL);
  }
  v62 = g_type_check_instance_cast(v41, v51);
  gtk_container_set_focus_child(v62, 0LL);
  gtk_widget_show(v41);
  v63 = g_type_check_instance_cast(v41, v43);
  gtk_window_set_focus(v63, 0LL);
  *(_QWORD *)(v75 + 80) = 0LL;
  v64 = g_type_check_instance_cast(v41, 80LL);
  g_signal_connect_data(v64, "destroy", sub_9EB60, v75, 0LL, 0LL);
  v65 = g_type_check_instance_cast(v41, 80LL);
  g_signal_connect_data(v65, "key_press_event", sub_9E860, v75, 0LL, 0LL);
  return v41;
}

__int64 __fastcall sub_A1E90(__int64 a1, char *a2)
{
  int v2; // eax

  v2 = sub_AB5C0((__int64)"Some sort of text about a config-box error message");
  return sub_A1980(
           *(_QWORD *)(a1 + 40),
           (__int64)"Error",
           a2,
           v2,
           0,
           (__int64)&off_322580,
           (__int64)nullsub_36,
           0LL,
           0LL,
           0LL);
}

void __fastcall sub_A1EE0(__int64 a1, __int64 a2)
{
  int v2; // eax

  if ( !*(_QWORD *)(a2 + 72) )
  {
    v2 = sub_AB5C0((__int64)"SHA256 fingerprint: ecdsa-sha2-nistp521 521 abcdefghkmnopqrsuvwxyzABCDEFGHJKLMNOPQRSTUW");
    *(_QWORD *)(a2 + 72) = sub_A1980(
                             *(_QWORD *)(a2 + 64),
                             (__int64)"Host key information",
                             *(char **)(a2 + 32),
                             v2,
                             1,
                             (__int64)&off_322580,
                             (__int64)sub_9DB70,
                             a2,
                             0LL,
                             0LL);
  }
}

void __fastcall sub_A1F40(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  char *v8; // rax
  char *v9; // rbx
  int v10; // eax

  v8 = sub_BC160("PuTTY", a1, a2, a3, a4, a5, a6, a7, a8, " Licence", 0LL);
  if ( !qword_3264B8 )
    __assert_fail("aboutbox != NULL", "unix/gtkdlg.c", 0xEDDu, "licence_clicked");
  v9 = v8;
  v10 = sub_AB5C0((__int64)"LONGISH LINE OF TEXT SO THE LICENCE BOX ISN'T EXCESSIVELY TALL AND THIN");
  sub_A1980(
    qword_3264B8,
    (__int64)v9,
    "PuTTY is copyright 1997-2021 Simon Tatham.\n"
    "\n"
    "Portions copyright Robert de Bath, Joris van Rantwijk, Delian Delchev, Andreas Schultz, Jeroen Massar, Wez Furlong, "
    "Nicolas Barry, Justin Bradford, Ben Harris, Malcolm Smith, Ahmad Khalifa, Markus Kuhn, Colin Watson, Christopher Sta"
    "ite, Lorenz Diener, Christian Brabandt, Jeff Smith, Pavel Kryukov, Maxim Kuznetsov, Svyatoslav Kuzmich, Nico William"
    "s, Viktor Dukhovni, Josh Dersch, Lars Brinkhoff, and CORE SDI S.A.\n"
    "\n"
    "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documen"
    "tation files (the \"Software\"), to deal in the Software without restriction, including without limitation the right"
    "s to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit pe"
    "rsons to whom the Software is furnished to do so, subject to the following conditions:\n"
    "\n"
    "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the"
    " Software.\n"
    "\n"
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO T"
    "HE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE COPYR"
    "IGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWIS"
    "E, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
    v10,
    1,
    (__int64)&off_322580,
    (__int64)nullsub_36,
    0LL,
    0LL,
    0LL);
  sub_2F4D0(v9);
}

bool __fastcall sub_A1FD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  bool result; // al

  if ( !*(_QWORD *)a2 )
    BUG();
  v2 = *(_QWORD *)(sub_9B3D0(*(__int64 **)a2, a1, (__int64 (__fastcall *)(__int64))sub_9DB00) + 96);
  result = 1;
  if ( v2 )
    result = *(_QWORD *)(a2 + 88) == v2;
  return result;
}

void __fastcall sub_A2020(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 v3; // rbp
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r13
  __int64 v7; // rax

  if ( *(_QWORD *)(a1 + 72) )
  {
    v2 = a2;
    v3 = a1;
    v4 = 0LL;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)(v3 + 80) + 8 * v4);
      if ( *(_DWORD *)(v5 + 24) > 1 )
      {
        v6 = *(_QWORD *)(v5 + 32);
        v7 = gtk_tree_view_get_type(a1, a2);
        a2 = v6;
        a1 = g_type_check_instance_cast(v2, v7);
        gtk_tree_view_collapse_row(a1, v6);
      }
      ++v4;
    }
    while ( *(_QWORD *)(v3 + 72) > v4 );
  }
}

unsigned __int64 __fastcall sub_A2090(__int64 a1, __int64 a2)
{
  __int64 v3; // [rsp+0h] [rbp-38h]
  unsigned int v4; // [rsp+8h] [rbp-30h]
  unsigned __int64 v5; // [rsp+18h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  gtk_widget_get_allocation(a1, &v3);
  gtk_widget_set_size_request(a1, v4, 0xFFFFFFFFLL);
  sub_A2020(a2, a1);
  return __readfsqword(0x28u) ^ v5;
}

__int64 __fastcall sub_A20F0(__int64 a1, __int64 *a2, unsigned __int8 a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r15
  __int64 v7; // r13
  __int64 v8; // rbp
  unsigned __int8 v9; // bl
  int v10; // er12
  _QWORD *v11; // rax
  _QWORD *v12; // r14
  char *v13; // rax
  __int64 v14; // rax
  __int64 v15; // r15
  unsigned int v16; // eax
  unsigned __int64 *v17; // rdi
  __int64 v18; // rax
  __int64 v19; // r13
  __int64 v20; // rax
  __int64 v21; // rbx
  __int64 v22; // rdi
  __int64 v23; // rax
  __int64 v24; // r15
  __int64 v25; // rax
  __int64 v26; // r13
  __int64 v27; // rax
  __int64 v28; // rbp
  __int64 v29; // rax
  __int64 v30; // r12
  __int64 v31; // rax
  __int64 v32; // rbp
  __int64 v33; // rax
  const char **v34; // rdi
  __int64 v35; // rax
  _QWORD *v36; // rax
  __int64 v37; // rax
  __int64 v38; // r12
  __int64 v39; // rax
  __int64 v40; // rsi
  __int64 v41; // rdi
  __int64 v42; // rdi
  __int64 v43; // rax
  __int64 v44; // r12
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // rdi
  __int64 v50; // rax
  __int64 v51; // r15
  __int64 v52; // rax
  __int64 v53; // r13
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  unsigned __int64 *v57; // rax
  unsigned __int64 v58; // rbp
  __int64 v59; // r15
  unsigned __int64 v60; // r13
  int v61; // er14
  char *v62; // rdi
  int v63; // eax
  int v64; // er12
  const char *v65; // r14
  char *v66; // rax
  signed __int64 v67; // rdx
  __int64 v68; // r14
  __int64 v69; // rax
  _QWORD *v70; // r14
  __int64 *v71; // rax
  signed __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // r12
  __int64 v75; // rax
  __int64 v76; // rbx
  __int64 v77; // rax
  const char **v78; // rbx
  __int64 v79; // rax
  __int64 v80; // rbx
  __int64 v81; // rax
  signed __int64 v82; // rax
  __int64 v83; // rax
  unsigned int v84; // er15
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  __int64 v88; // rax
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // rax
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 *v94; // rax
  __int64 v95; // r10
  __int64 v96; // r11
  __int64 v97; // rcx
  signed __int64 v98; // r9
  __int64 v99; // rbp
  __int64 v100; // rsi
  __int64 ***v101; // r8
  __int64 **v102; // rdi
  unsigned __int64 v103; // rax
  signed __int64 v104; // rax
  signed __int64 v105; // rbx
  unsigned __int64 v106; // rdx
  __int64 v107; // rax
  __int64 v108; // rax
  __int64 result; // rax
  __int64 v110; // [rsp+0h] [rbp-E28h]
  __int64 *ptr; // [rsp+8h] [rbp-E20h]
  __int64 v112; // [rsp+10h] [rbp-E18h]
  __int64 v113; // [rsp+18h] [rbp-E10h]
  __int64 v114; // [rsp+20h] [rbp-E08h]
  __int64 v115; // [rsp+28h] [rbp-E00h]
  char *v116; // [rsp+38h] [rbp-DF0h]
  signed __int64 v117; // [rsp+40h] [rbp-DE8h]
  int v118; // [rsp+48h] [rbp-DE0h]
  int v119; // [rsp+4Ch] [rbp-DDCh]
  __int64 v120; // [rsp+58h] [rbp-DD0h]
  __int64 v121; // [rsp+60h] [rbp-DC8h]
  __int64 v122; // [rsp+70h] [rbp-DB8h]
  __int64 v123; // [rsp+78h] [rbp-DB0h]
  __int64 v124; // [rsp+80h] [rbp-DA8h]
  __int64 v125; // [rsp+88h] [rbp-DA0h]
  __int64 *v126; // [rsp+98h] [rbp-D90h]
  __int64 v127; // [rsp+A0h] [rbp-D88h]
  __int64 v128; // [rsp+A8h] [rbp-D80h]
  __int64 v129; // [rsp+B8h] [rbp-D70h]
  __int128 v130; // [rsp+C0h] [rbp-D68h]
  __int128 v131; // [rsp+D0h] [rbp-D58h]
  __int128 v132; // [rsp+E0h] [rbp-D48h]
  __int128 v133[15]; // [rsp+F0h] [rbp-D38h]
  char v134; // [rsp+1E0h] [rbp-C48h]
  char v135; // [rsp+1F0h] [rbp-C38h]
  unsigned __int64 v136; // [rsp+DE8h] [rbp-40h]
  char v137; // [rsp+DF0h] [rbp-38h]

  v6 = a5;
  v7 = a6;
  v8 = a1;
  v9 = a3;
  v10 = a4;
  v126 = a2;
  v129 = 0LL;
  v136 = __readfsqword(0x28u);
  v11 = sub_2F450(1uLL, 0x80uLL, 0LL);
  v11[14] = v6;
  v11[15] = v7;
  v12 = v11;
  sub_9DEB0((__int64)v11);
  v13 = &v135;
  do
  {
    *(_DWORD *)v13 = 0;
    v13 += 24;
  }
  while ( &v137 != v13 );
  v14 = sub_AB610();
  v15 = v14;
  v123 = v14;
  v12[12] = sub_28870();
  v16 = sub_1EFD0(a2, 2);
  sub_231A0(v12[12], v9, v16, v10);
  sub_B4060((unsigned __int64 *)v12[12], v9);
  v17 = (unsigned __int64 *)v12[12];
  sub_9B4C0(v17, v9, v15);
  v18 = gtk_window_get_type(v17, v9);
  v19 = v18;
  v124 = v18;
  v20 = g_type_check_instance_cast(v15, v18);
  gtk_window_set_title(v20, v8);
  v21 = gtk_box_new(0LL, 4LL);
  v22 = g_type_check_instance_cast(v15, v19);
  sub_AB790(v22, v21, 1u, 1u, 0);
  v23 = gtk_container_get_type(v22);
  v24 = v23;
  v25 = g_type_check_instance_cast(v21, v23);
  gtk_container_set_border_width(v25, 10LL);
  gtk_widget_show(v21);
  v26 = gtk_box_new(1LL, 4LL);
  v27 = gtk_box_get_type(1LL, 4LL);
  v28 = v27;
  v29 = g_type_check_instance_cast(v21, v27);
  gtk_box_pack_start(v29, v26, 0LL, 0LL, 0LL);
  gtk_widget_show(v26);
  v30 = sub_9D170(4LL);
  v120 = v28;
  v31 = g_type_check_instance_cast(v26, v28);
  gtk_box_pack_start(v31, v30, 0LL, 0LL, 0LL);
  gtk_widget_show(v30);
  v32 = gtk_label_new("Category:", v30);
  v33 = sub_9C450((__int64)"Category:");
  v34 = (const char **)g_type_check_instance_cast(v30, v33);
  sub_9D2C0(v34, v32, 0, 1);
  v35 = sub_9C450((__int64)v34);
  v36 = (_QWORD *)g_type_check_instance_cast(v30, v35);
  sub_9D510(v36, v32);
  gtk_widget_show(v32);
  v127 = gtk_scrolled_window_new(0LL, 0LL);
  v37 = gtk_tree_store_new(2LL, 64LL, 24LL);
  v38 = v37;
  v113 = v37;
  v39 = gtk_tree_model_get_type(2LL);
  v40 = v39;
  v125 = v39;
  v41 = g_type_check_instance_cast(v38, v39);
  v121 = gtk_tree_view_new_with_model(v41);
  v122 = gtk_tree_view_get_type(v41, v40);
  v42 = g_type_check_instance_cast(v121, v122);
  gtk_tree_view_set_headers_visible(v42, 0LL);
  v43 = gtk_cell_renderer_text_new(v42, 0LL);
  v44 = gtk_tree_view_column_new_with_attributes("Label", v43, "text", 0LL, 0LL);
  v45 = g_type_check_instance_cast(v121, v122);
  gtk_tree_view_append_column(v45, v44);
  v46 = g_type_check_instance_cast(v121, v122);
  v128 = gtk_tree_view_get_selection(v46, v122);
  gtk_tree_selection_set_mode(v128, 2LL);
  v47 = g_type_check_instance_cast(v127, v24);
  gtk_container_add(v47, v121);
  v48 = g_type_check_instance_cast(v121, 80LL);
  g_signal_connect_data(v48, "focus_in_event", sub_9E380, v12, 0LL, 0LL);
  sub_9E0B0((__int64)&v134, v32, 103, 1, v121);
  gtk_widget_show(v127);
  v49 = g_type_check_instance_cast(v26, v120);
  gtk_box_pack_start(v49, v127, 1LL, 1LL, 0LL);
  v50 = gtk_notebook_new(v49, v127);
  v51 = v50;
  v115 = v50;
  v52 = gtk_notebook_get_type();
  v53 = v52;
  v114 = v52;
  v54 = g_type_check_instance_cast(v51, v52);
  gtk_notebook_set_show_tabs(v54, 0LL);
  v55 = g_type_check_instance_cast(v51, v53);
  gtk_notebook_set_show_border(v55, 0LL);
  v56 = g_type_check_instance_cast(v21, v120);
  gtk_box_pack_start(v56, v51, 1LL, 1LL, 0LL);
  gtk_widget_show(v51);
  v57 = (unsigned __int64 *)v12[12];
  if ( !*v57 )
  {
    v12[9] = 0LL;
    v12[10] = 0LL;
    v86 = g_type_check_instance_cast(v121, 80LL);
    g_signal_connect_data(v86, "map", sub_A2090, v12, 0LL, 0LL);
    v87 = g_type_check_instance_cast(v128, 80LL);
    g_signal_connect_data(v87, "changed", sub_A0310, 0LL, 0LL, 0LL);
    v12[2] = v126;
    sub_A0280(0LL, (__int64)v12);
    BUG();
  }
  v58 = 0LL;
  ptr = 0LL;
  v116 = 0LL;
  v119 = 0;
  v59 = 0LL;
  v60 = 0LL;
  v110 = (__int64)v12;
  do
  {
    v78 = *(const char ***)(v57[2] + 8 * v60);
    v62 = (char *)*v78;
    if ( **v78 )
    {
      if ( v116 )
      {
        v61 = sub_287C0(v62, v116);
        if ( v61 == 0x7FFFFFFF )
        {
LABEL_17:
          v76 = sub_A0580(v110, ptr[v58 - 1], ptr[v58 - 1] + 40, (__int64)v78, 0LL);
          v77 = g_type_check_instance_cast(v59, v120);
          gtk_box_pack_start(v77, v76, 0LL, 0LL, 0LL);
          gtk_widget_show(v76);
          goto LABEL_18;
        }
        v62 = (char *)*v78;
      }
      else
      {
        v61 = 0;
      }
      v63 = sub_28780(v62);
      v64 = v63 - 1;
      v118 = v63;
      if ( v63 - 1 != v61 )
        __assert_fail("j == ctrl_path_elements(s->pathname) - 1", "unix/gtkdlg.c", 0xBE6u, "create_config_box");
      v65 = *v78;
      v116 = (char *)*v78;
      v66 = strrchr(*v78, 47);
      v67 = (signed __int64)(v66 + 1);
      if ( !v66 )
        v67 = (signed __int64)v65;
      v117 = v67;
      v68 = gtk_box_new(1LL, 4LL);
      v112 = v68;
      gtk_widget_show(v68);
      v69 = g_type_check_instance_cast(v115, v114);
      gtk_notebook_append_page(v69, v68, 0LL);
      v70 = sub_2F450(1uLL, 0xC28uLL, 0LL);
      if ( !v59 )
      {
        v83 = g_type_check_instance_cast(v115, v114);
        v84 = gtk_notebook_page_num(v83, v112);
        v85 = g_type_check_instance_cast(v115, v114);
        gtk_notebook_set_current_page(v85, v84);
        *(_QWORD *)(v110 + 88) = v70;
      }
      v71 = (__int64 *)sub_2F4F0(ptr, (unsigned __int64 *)&v129, 8uLL, v58, 1uLL, 0);
      v71[v58] = (__int64)v70;
      ptr = v71;
      *v70 = v110;
      v70[1] = g_type_check_instance_cast(v115, v114);
      v70[2] = v112;
      qmemcpy(v70 + 5, &v134, 0xC00uLL);
      if ( v64 > v119 )
        goto LABEL_42;
      if ( v64 <= 0 )
      {
        gtk_tree_store_append(v113, &v130, 0LL);
        gtk_tree_store_set(v113, &v130, 0LL, v117, 1LL, v58, -1LL);
        v82 = 2LL * v64;
        *(__int128 *)((char *)&v132 + v82 * 16) = (__int128)_mm_load_si128((const __m128i *)&v130);
        v133[v82] = (__int128)_mm_load_si128((const __m128i *)&v131);
        *((_DWORD *)v70 + 6) = v64;
        v70[4] = 0LL;
      }
      else
      {
        gtk_tree_store_append(v113, &v130, &v132 + 2 * (v118 - 2));
        gtk_tree_store_set(v113, &v130, 0LL, v117, 1LL, v58, -1LL);
        v72 = 2LL * v64;
        *(__int128 *)((char *)&v132 + v72 * 16) = (__int128)_mm_load_si128((const __m128i *)&v130);
        v133[v72] = (__int128)_mm_load_si128((const __m128i *)&v131);
        *((_DWORD *)v70 + 6) = v64;
        v73 = g_type_check_instance_cast(v113, v125);
        v74 = gtk_tree_model_get_path(v73, &v132 + 2 * (v118 - 2));
        v70[4] = v74;
        v75 = g_type_check_instance_cast(v121, v122);
        gtk_tree_view_expand_row(v75, v74, 0LL);
      }
      v59 = v112;
      ++v58;
      v119 = v118;
      goto LABEL_17;
    }
    v79 = g_type_check_instance_cast(v123, v124);
    v80 = sub_A0580(v110, 0LL, (__int64)&v134, (__int64)v78, v79);
    v81 = g_type_check_instance_cast(v123, v124);
    sub_AB660(v81, v80);
LABEL_18:
    ++v60;
    v57 = *(unsigned __int64 **)(v110 + 96);
  }
  while ( *v57 > v60 );
  *(_QWORD *)(v110 + 80) = ptr;
  *(_QWORD *)(v110 + 72) = v58;
  v88 = g_type_check_instance_cast(v121, 80LL);
  g_signal_connect_data(v88, "map", sub_A2090, v110, 0LL, 0LL);
  v89 = g_type_check_instance_cast(v128, 80LL);
  g_signal_connect_data(v89, "changed", sub_A0310, ptr, 0LL, 0LL);
  *(_QWORD *)(v110 + 16) = v126;
  sub_A0280(0LL, v110);
  v90 = *ptr;
  *(_QWORD *)(v110 + 64) = 0LL;
  *(_DWORD *)(v110 + 104) = -1;
  *(_QWORD *)(v110 + 40) = v123;
  *(_QWORD *)(v110 + 32) = v90 + 40;
  sub_B2540(v123, (__int64 *)&off_322A20, 3);
  v91 = gtk_scrolled_window_get_type(v123, &off_322A20);
  v92 = g_type_check_instance_cast(v127, v91);
  gtk_scrolled_window_set_policy(v92, 2LL, 1LL);
  gtk_widget_show(v121);
  v93 = g_type_check_instance_cast(v123, v124);
  gtk_window_set_position(v93, 1LL);
  gtk_widget_show(v123);
  v94 = *(__int64 **)(v110 + 96);
  v95 = *v94;
  if ( !*v94 )
    goto LABEL_36;
  v96 = v94[2];
  v97 = 0LL;
  v98 = 577LL;
  while ( 2 )
  {
    v99 = *(_QWORD *)(v96 + 8 * v97);
    if ( !**(_BYTE **)v99 || (v100 = *(_QWORD *)(v99 + 32)) == 0 )
    {
LABEL_27:
      if ( v95 == ++v97 )
        goto LABEL_36;
      continue;
    }
    break;
  }
  v101 = *(__int64 ****)(v99 + 48);
  v102 = *v101;
  v103 = *(unsigned int *)*v101;
  if ( (unsigned int)v103 <= 9 && _bittest64(&v98, v103) )
  {
    v104 = 1LL;
    while ( v100 != v104 )
    {
      v102 = v101[v104];
      v105 = 8 * v104;
      v106 = *(unsigned int *)v102;
      if ( (unsigned int)v106 <= 9 )
      {
        ++v104;
        if ( _bittest64(&v98, v106) )
          continue;
      }
      goto LABEL_35;
    }
    goto LABEL_27;
  }
  v105 = 0LL;
LABEL_35:
  sub_A0140(v102, (__int64 **)v110);
  *(_QWORD *)(v110 + 64) = *(_QWORD *)(*(_QWORD *)(v99 + 48) + v105);
LABEL_36:
  v107 = g_type_check_instance_cast(v123, 80LL);
  g_signal_connect_data(v107, "destroy", sub_9EB60, v110, 0LL, 0LL);
  v108 = g_type_check_instance_cast(v123, 80LL);
  g_signal_connect_data(v108, "key_press_event", sub_9E860, v110, 0LL, 0LL);
  result = v123;
  if ( __readfsqword(0x28u) != v136 )
LABEL_42:
    __assert_fail("j-1 < level", "unix/gtkdlg.c", 0xC0Bu, "create_config_box");
  return result;
}

__int64 __fastcall sub_A2C30(__int64 a1, __int64 a2, char *a3, int a4, char a5, __int64 a6, __int64 a7, __int64 a8)
{
  return sub_A1980(a1, a2, a3, a4, a5, a6, a7, a8, 0LL, 0LL);
}

signed __int64 __fastcall sub_A2C50(__int64 a1, char *a2, unsigned int a3, char *a4, char *a5, const char *a6, _QWORD *a7, __int64 a8, __int64 a9)
{
  __int64 (__fastcall ***v9)(); // r15
  unsigned int v10; // ebp
  char *v11; // rbx
  const char *v12; // r13
  int v13; // eax
  int v15; // ST40_4
  _BOOL4 v16; // eax
  const char *v17; // rdi
  _QWORD *v18; // rax
  char *v19; // rax
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rbx
  int v23; // eax
  __int64 v24; // rax
  __int64 v25; // rax
  size_t v26; // rax
  const char *v27; // rbp
  __int64 (**v28)(void); // r12
  signed __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rdi
  __int64 v32; // rax
  char *v33; // [rsp+8h] [rbp-70h]
  __int64 *v34; // [rsp+8h] [rbp-70h]
  __int64 *v35; // [rsp+8h] [rbp-70h]
  __int64 v36; // [rsp+10h] [rbp-68h]
  __int64 v37; // [rsp+18h] [rbp-60h]
  char *v38; // [rsp+20h] [rbp-58h]
  char *src; // [rsp+28h] [rbp-50h]
  __int64 v40; // [rsp+30h] [rbp-48h]
  unsigned __int64 v41; // [rsp+38h] [rbp-40h]

  v9 = (__int64 (__fastcall ***)())a1;
  v10 = a3;
  v11 = a4;
  v33 = a5;
  v12 = a6;
  v41 = __readfsqword(0x28u);
  v13 = sub_BADA0(a2, a3, a4, a5);
  if ( !v13 )
    return 1LL;
  src = v33;
  v15 = v13;
  v16 = sub_BD840((__int64)a7);
  v17 = "The server's host key is not cached. You have no guarantee that the server is the computer you think it is.\n"
        "The server's %s key fingerprint is:\n"
        "%s\n"
        "If you trust this host, press \"Accept\" to add the key to PuTTY's cache and carry on connecting.\n"
        "If you want to carry on connecting just once, without adding the key to the cache, press \"Connect Once\".\n"
        "If you do not trust this host, press \"Cancel\" to abandon the connection.";
  v34 = &a7[v16];
  if ( v15 == 2 )
    v17 = "WARNING - POTENTIAL SECURITY BREACH!\n"
          "The server's host key does not match the one PuTTY has cached. This means that either the server administrator"
          " has changed the host key, or you have actually connected to another computer pretending to be the server.\n"
          "The new %s key fingerprint is:\n"
          "%s\n"
          "If you were expecting this change and trust the new key, press \"Accept\" to update PuTTY's cache and continue"
          " connecting.\n"
          "If you want to carry on connecting but without updating the cache, press \"Connect Once\".\n"
          "If you want to abandon the connection completely, press \"Cancel\" to cancel. Pressing \"Cancel\" is the ONLY "
          "guaranteed safe choice.";
  v38 = sub_BC360((__int64)v17, v11, a7[v16]);
  v18 = sub_2F450(1uLL, 0x50uLL, 0LL);
  v36 = (__int64)v18;
  v18[5] = a8;
  v18[6] = a9;
  *v18 = sub_BC120(a2);
  *(_DWORD *)(v36 + 8) = v10;
  *(_QWORD *)(v36 + 16) = sub_BC120(v11);
  v19 = sub_BC120(src);
  *(_QWORD *)(v36 + 56) = v9;
  *(_QWORD *)(v36 + 24) = v19;
  v20 = gtk_widget_get_type(src, a9);
  v21 = sub_AF870((__int64)v9);
  v40 = 0LL;
  v22 = g_type_check_instance_cast(v21, v20);
  v23 = sub_AB5C0(*v34);
  v24 = sub_A1980(
          v22,
          (__int64)"PuTTY Security Alert",
          v38,
          v23,
          1,
          (__int64)&off_322570,
          (__int64)sub_9DFA0,
          v36,
          (__int64 (__fastcall *)(__int64, __int64))sub_9DF00,
          (__int64)&v40);
  *(_QWORD *)(v36 + 72) = 0LL;
  v37 = v24;
  *(_QWORD *)(v36 + 64) = v24;
  v25 = sub_BC640();
  v35 = (__int64 *)v25;
  if ( a7[1] )
    sub_BC720(v25, (__int64)"SHA256 fingerprint: %s\n");
  if ( *a7 )
    sub_BC720((__int64)v35, (__int64)"MD5 fingerprint: %s\n");
  sub_BC720((__int64)v35, (__int64)"Full text of host's public key:");
  v26 = strlen(v12);
  v27 = &v12[v26];
  if ( v12 < &v12[v26] )
  {
    v28 = (__int64 (**)(void))(v35 + 3);
    do
    {
      v29 = v27 - v12;
      if ( (unsigned __int64)(v27 - v12) > 0x48 )
        v29 = 72LL;
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))v28, 10);
      v12 += v29;
      sub_2EC20(v28);
    }
    while ( v27 > v12 );
  }
  v30 = sub_BC6B0(v35);
  v31 = v40;
  *(_QWORD *)(v36 + 32) = v30;
  v32 = g_type_check_instance_cast(v31, 80LL);
  g_signal_connect_data(v32, "clicked", sub_A1EE0, v36, 0LL, 0LL);
  sub_AF880(v9, 1u, v37);
  sub_2F4D0(v38);
  return 0xFFFFFFFFLL;
}

signed __int64 __fastcall sub_A2F30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // r13
  char *v7; // r12
  _QWORD *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r13
  __int64 v11; // rax
  __int64 v12; // r13
  int v13; // eax
  __int64 v14; // rax

  v5 = a4;
  v6 = a5;
  v7 = sub_BC360(
         (__int64)"The first %s supported by the server is %s, which is below the configured warning threshold.\n"
                  "Continue with connection?",
         a2,
         a3);
  v8 = sub_2F450(1uLL, 0x20uLL, 0LL);
  *v8 = v5;
  v8[1] = v6;
  v9 = (__int64)v8;
  v8[2] = a1;
  *((_DWORD *)v8 + 6) = 1;
  v10 = gtk_widget_get_type(1LL, 32LL);
  v11 = sub_AF870(a1);
  v12 = g_type_check_instance_cast(v11, v10);
  v13 = sub_AB5C0((__int64)"Reasonably long line of text as a width template");
  v14 = sub_A1980(
          v12,
          (__int64)"PuTTY Security Alert",
          v7,
          v13,
          0,
          (__int64)&off_3225B0,
          (__int64)sub_9E030,
          v9,
          0LL,
          0LL);
  sub_AF880((__int64 (__fastcall ***)())a1, *(_DWORD *)(v9 + 24), v14);
  sub_2F4D0(v7);
  return 0xFFFFFFFFLL;
}

signed __int64 __fastcall sub_A3000(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // r13
  char *v7; // r12
  _QWORD *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r13
  __int64 v11; // rax
  __int64 v12; // r13
  int v13; // eax
  __int64 v14; // rax

  v5 = a4;
  v6 = a5;
  v7 = sub_BC360(
         (__int64)"The first host key type we have stored for this server\n"
                  "is %s, which is below the configured warning threshold.\n"
                  "The server also provides the following types of host key\n"
                  "above the threshold, which we do not have stored:\n"
                  "%s\n"
                  "Continue with connection?",
         a2,
         a3);
  v8 = sub_2F450(1uLL, 0x20uLL, 0LL);
  *v8 = v5;
  v8[1] = v6;
  v9 = (__int64)v8;
  v8[2] = a1;
  *((_DWORD *)v8 + 6) = 1;
  v10 = gtk_widget_get_type(1LL, 32LL);
  v11 = sub_AF870(a1);
  v12 = g_type_check_instance_cast(v11, v10);
  v13 = sub_AB5C0((__int64)"is ecdsa-nistp521, which is below the configured warning threshold.");
  v14 = sub_A1980(
          v12,
          (__int64)"PuTTY Security Alert",
          v7,
          v13,
          0,
          (__int64)&off_3225B0,
          (__int64)sub_9E030,
          v9,
          0LL,
          0LL);
  sub_AF880((__int64 (__fastcall ***)())a1, *(_DWORD *)(v9 + 24), v14);
  sub_2F4D0(v7);
  return 0xFFFFFFFFLL;
}

void nullsub_39()
{
  ;
}

void __fastcall sub_A30E0(__int64 a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  char *v10; // rbx
  int v11; // eax

  v10 = sub_BC160("PuTTY", a3, a4, a5, a6, a7, a8, a9, a10, &unk_F87FB, 0LL);
  v11 = sub_AB5C0((__int64)"REASONABLY LONG LINE OF TEXT FOR BASIC SANITY");
  sub_A1980(a1, (__int64)v10, a2, v11, 0, (__int64)&off_322580, (__int64)nullsub_36, 0LL, 0LL, 0LL);
  sub_2F4D0(v10);
}

unsigned __int64 sub_A3150(__int64 a1, ...)
{
  double v1; // xmm0_8
  double v2; // xmm1_8
  double v3; // xmm2_8
  double v4; // xmm3_8
  double v5; // xmm6_8
  double v6; // xmm7_8
  char *v7; // rbx
  double v8; // xmm4_8
  double v9; // xmm5_8
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v12; // [rsp+18h] [rbp-C0h]
  __int128 v13; // [rsp+50h] [rbp-88h]
  __int128 v14; // [rsp+60h] [rbp-78h]
  __int128 v15; // [rsp+70h] [rbp-68h]
  __int128 v16; // [rsp+80h] [rbp-58h]
  __int128 v17; // [rsp+90h] [rbp-48h]
  __int128 v18; // [rsp+A0h] [rbp-38h]
  __int128 v19; // [rsp+B0h] [rbp-28h]
  __int128 v20; // [rsp+C0h] [rbp-18h]

  va_start(va, a1);
  *(_QWORD *)&v13 = va_arg(va, double);
  v1 = *(double *)&v13;
  *(_QWORD *)&v14 = va_arg(va, double);
  v2 = *(double *)&v14;
  *(_QWORD *)&v15 = va_arg(va, double);
  v3 = *(double *)&v15;
  *(_QWORD *)&v16 = va_arg(va, double);
  v4 = *(double *)&v16;
  *(_QWORD *)&v17 = va_arg(va, double);
  *(_QWORD *)&v18 = va_arg(va, double);
  *(_QWORD *)&v19 = va_arg(va, double);
  v5 = *(double *)&v19;
  *(_QWORD *)&v20 = va_arg(va, double);
  v6 = *(double *)&v20;
  va_end(va);
  va_start(va, a1);
  v12 = __readfsqword(0x28u);
  v7 = sub_BC310(a1, (const __m128i *)va);
  sub_A30E0(0LL, v7, v1, v2, v3, v4, v8, v9, v5, v6);
  sub_2F4D0(v7);
  return __readfsqword(0x28u) ^ v12;
}

__int64 __fastcall sub_A3238(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbx
  __int64 v10; // rbp
  __int64 v11; // rax
  __int64 v12; // r13
  __int64 v13; // rax
  double v14; // xmm4_8
  double v15; // xmm5_8
  char *v16; // r12
  __int64 v17; // rax
  __int64 v18; // rbp
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // r12
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r15
  __int64 v25; // rax
  __int64 v26; // r12
  __int64 v27; // rax
  __int64 v28; // rax
  char *v29; // r15
  __int64 v30; // r12
  __int64 v31; // rax
  __int64 v32; // r14
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rdi
  __int64 v38; // rax
  __int64 v39; // rbx
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax

  v9 = a1;
  v10 = sub_AB610();
  qword_3264B8 = v10;
  v11 = gtk_container_get_type(a1);
  v12 = v11;
  v13 = g_type_check_instance_cast(v10, v11);
  gtk_container_set_border_width(v13, 10LL);
  v16 = sub_BC160("About ", a2, a3, a4, a5, v14, v15, a8, a9, "PuTTY", 0LL);
  v17 = gtk_window_get_type("About ", "PuTTY");
  v18 = v17;
  v19 = g_type_check_instance_cast(qword_3264B8, v17);
  gtk_window_set_title(v19, v16);
  sub_2F4D0(v16);
  v20 = g_type_check_instance_cast(qword_3264B8, 80LL);
  g_signal_connect_data(v20, "destroy", sub_9DB80, 0LL, 0LL, 0LL);
  v21 = gtk_button_new_with_label("Close");
  gtk_widget_set_can_default(v21, 1LL);
  v22 = g_type_check_instance_cast(qword_3264B8, v18);
  gtk_window_set_default(v22, v21);
  v23 = g_type_check_instance_cast(qword_3264B8, v18);
  v24 = sub_AB700(v23);
  gtk_box_pack_end(v24, v21, 0LL, 0LL, 0LL);
  v25 = g_type_check_instance_cast(v21, 80LL);
  g_signal_connect_data(v25, "clicked", sub_9DC60, 0LL, 0LL, 0LL);
  gtk_widget_show(v21);
  v26 = gtk_button_new_with_label("View Licence");
  gtk_widget_set_can_default(v26, 1LL);
  gtk_box_pack_end(v24, v26, 0LL, 0LL, 0LL);
  v27 = g_type_check_instance_cast(v26, 80LL);
  g_signal_connect_data(v27, "clicked", sub_A1F40, 0LL, 0LL, 0LL);
  gtk_widget_show(v26);
  v28 = sub_31FE0((__int64)"\n", (__int64)"clicked");
  v29 = sub_BC360(
          (__int64)"%s\n\n%s\n\n%s\n\n%s",
          "PuTTY",
          "Release 0.76",
          v28,
          "Copyright 1997-2021 Simon Tatham. All rights reserved");
  v30 = gtk_label_new(v29, "PuTTY");
  v31 = gtk_label_get_type(v29);
  v32 = v31;
  v33 = g_type_check_instance_cast(v30, v31);
  gtk_label_set_justify(v33, 2LL);
  v34 = g_type_check_instance_cast(v30, v32);
  gtk_label_set_selectable(v34, 1LL);
  sub_2F4D0(v29);
  v35 = g_type_check_instance_cast(qword_3264B8, v18);
  sub_AB790(v35, v30, 0, 0, 0);
  gtk_widget_grab_focus(v30);
  v36 = g_type_check_instance_cast(v30, v32);
  gtk_label_select_region(v36, 0LL, 0LL);
  gtk_widget_show(v30);
  v37 = g_type_check_instance_cast(qword_3264B8, 80LL);
  g_signal_connect_data(v37, "key_press_event", sub_9E160, 0LL, 0LL, 0LL);
  v38 = gtk_widget_get_type(v37, "key_press_event");
  g_type_check_instance_cast(v9, v38);
  if ( v9 )
  {
    v39 = g_type_check_instance_cast(v9, v18);
    v40 = g_type_check_instance_cast(qword_3264B8, v18);
    gtk_window_set_transient_for(v40, v39);
  }
  v41 = g_type_check_instance_cast(qword_3264B8, v12);
  gtk_container_set_focus_child(v41, 0LL);
  gtk_widget_show(qword_3264B8);
  v42 = g_type_check_instance_cast(qword_3264B8, v18);
  return gtk_window_set_focus(v42, 0LL);
}

__int64 __fastcall sub_A3560(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdi
  _DWORD *v15; // rax
  unsigned __int64 *v16; // rax
  __int64 v17; // r15
  __int64 v18; // r9
  __int64 v19; // rbp
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 *v22; // rdi
  __int64 v23; // r14
  __int64 v24; // rbp
  __int64 v25; // rax
  __int64 v26; // rbp
  _DWORD *v27; // rax
  __int64 v28; // rbp
  double v29; // xmm4_8
  double v30; // xmm5_8
  char *v31; // r14
  __int64 v32; // rax
  __int64 v33; // r12
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // r15
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // ST00_8
  __int64 v40; // r15
  __int64 v41; // rax
  __int64 v42; // rax
  int v43; // eax
  __int64 v44; // rax
  __int64 v45; // r14
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // [rsp+0h] [rbp-48h]
  __int64 v53; // [rsp+8h] [rbp-40h]

  v10 = a1;
  v11 = gtk_widget_get_type(a1, a2);
  v12 = g_type_check_instance_cast(a2, v11);
  v13 = *(_QWORD *)(a1 + 8);
  if ( v13 )
    return gtk_widget_grab_focus(v13);
  v52 = v12;
  sub_9DEB0(v10 + 3096);
  v15 = (_DWORD *)(v10 + 40);
  do
  {
    *v15 = 0;
    v15 += 6;
  }
  while ( v15 != (_DWORD *)(v10 + 3112) );
  v53 = v52;
  v16 = sub_28870();
  *(_QWORD *)(v10 + 16) = v16;
  v17 = sub_28A10(v16, &locale, &locale, &locale);
  sub_28C10(v17, 3, 33LL, 34LL, 33LL, v18, v52);
  v19 = sub_28770(0LL);
  v20 = sub_28770(0LL);
  v21 = sub_290C0(v17, "Close", 99, v20, (__int64)sub_9ECE0, v19);
  v22 = *(unsigned __int64 **)(v10 + 16);
  *(_DWORD *)(v21 + 20) = 1;
  *(_BYTE *)(v21 + 57) = 1;
  v23 = sub_28A10(v22, "x", &locale, &locale);
  v24 = sub_28770(v10);
  v25 = sub_28770(0LL);
  v26 = sub_29110(v23, 0LL, 0, v25, (__int64)sub_9F930, v24);
  *(_QWORD *)(v10 + 3224) = v26;
  *(_DWORD *)(v26 + 60) = 10;
  *(_DWORD *)(v26 + 68) = 2;
  *(_DWORD *)(v26 + 76) = 3;
  v27 = sub_2F450(3uLL, 4uLL, 0LL);
  *(_QWORD *)(v26 + 80) = v27;
  *v27 = 25;
  *(_DWORD *)(*(_QWORD *)(v26 + 80) + 4LL) = 10;
  *(_DWORD *)(*(_QWORD *)(v26 + 80) + 8LL) = 65;
  v28 = sub_AB610();
  *(_QWORD *)(v10 + 8) = v28;
  v31 = sub_BC160("PuTTY", a3, a4, a5, a6, v29, v30, a9, a10, " Event Log", 0LL, v23);
  v32 = gtk_window_get_type("PuTTY", " Event Log");
  v33 = v32;
  v34 = g_type_check_instance_cast(v28, v32);
  gtk_window_set_title(v34, v31);
  sub_2F4D0(v31);
  v35 = g_type_check_instance_cast(v28, v33);
  v36 = sub_A0580(v10 + 3096, 0LL, v10 + 24, v17, v35);
  v37 = g_type_check_instance_cast(v28, v33);
  sub_AB660(v37, v36);
  gtk_widget_show(v36);
  v38 = g_type_check_instance_cast(v28, v33);
  v40 = sub_A0580(v10 + 3096, 0LL, v10 + 24, v39, v38);
  v41 = gtk_container_get_type(v10 + 3096);
  v42 = g_type_check_instance_cast(v40, v41);
  gtk_container_set_border_width(v42, 10LL);
  v43 = sub_AB5C0((__int64)"LINE OF TEXT GIVING WIDTH OF EVENT LOG IS QUITE LONG 'COS SSH LOG ENTRIES ARE WIDE");
  gtk_widget_set_size_request(v40, (unsigned int)(v43 + 20), 0xFFFFFFFFLL);
  v44 = g_type_check_instance_cast(v28, v33);
  sub_AB790(v44, v40, 1u, 1u, 0);
  gtk_widget_show(v40);
  *(_QWORD *)(v10 + 3112) = v10;
  *(_QWORD *)(v10 + 3128) = v10 + 24;
  *(_QWORD *)(v10 + 3160) = 0LL;
  *(_DWORD *)(v10 + 3200) = 0;
  *(_QWORD *)(v10 + 3136) = v28;
  sub_A0280(0LL, v10 + 3096);
  if ( v53 )
  {
    v45 = g_type_check_instance_cast(v53, v33);
    v46 = g_type_check_instance_cast(v28, v33);
    gtk_window_set_transient_for(v46, v45);
  }
  else
  {
    v51 = g_type_check_instance_cast(v28, v33);
    gtk_window_set_position(v51, 1LL);
  }
  gtk_widget_show(v28);
  v47 = g_type_check_instance_cast(v28, 80LL);
  g_signal_connect_data(v47, "destroy", sub_9EBF0, v10, 0LL, 0LL);
  v48 = g_type_check_instance_cast(v28, 80LL);
  g_signal_connect_data(v48, "key_press_event", sub_9E860, v10 + 3096, 0LL, 0LL);
  v49 = g_type_check_instance_cast(v28, 80LL);
  g_signal_connect_data(v49, "selection_get", sub_9E070, v10, 0LL, 0LL);
  v50 = g_type_check_instance_cast(v28, 80LL);
  return g_signal_connect_data(v50, "selection_clear_event", sub_9EC20, v10, 0LL, 0LL);
}

_QWORD *sub_A3950()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx

  v0 = sub_2F450(1uLL, 0xCD0uLL, 0LL);
  v1 = v0;
  *v0 = 0LL;
  v0[409] = 0LL;
  memset(
    (void *)((unsigned __int64)(v0 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v0 - (((_DWORD)v0 + 8) & 0xFFFFFFF8) + 3280) >> 3));
  v0[408] = sub_BC640();
  return v1;
}

void __fastcall sub_A39B0(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rbx
  void *v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rbx
  void *v7; // rdi

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 3232);
  if ( v2 )
  {
    v3 = 0LL;
    while ( 1 )
    {
      v4 = *(void **)(v2 + v3);
      v3 += 8LL;
      sub_2F4D0(v4);
      if ( v3 == 1024 )
        break;
      v2 = *(_QWORD *)(v1 + 3232);
    }
    sub_2F4D0(*(void **)(v1 + 3232));
  }
  v5 = *(_QWORD *)(v1 + 3240);
  if ( v5 )
  {
    v6 = 0LL;
    while ( 1 )
    {
      v7 = *(void **)(v5 + v6);
      v6 += 8LL;
      sub_2F4D0(v7);
      if ( v6 == 1024 )
        break;
      v5 = *(_QWORD *)(v1 + 3240);
    }
    sub_2F4D0(*(void **)(v1 + 3240));
  }
  sub_BC660(*(void ***)(v1 + 3264));
  sub_2F4D0((void *)v1);
}

signed __int64 __fastcall sub_A3DA0(__int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // er8
  unsigned int v6; // er9
  __int64 v7; // rax
  int v8; // edx

  v3 = *(_DWORD *)(a1 + 20);
  a3 = (unsigned __int8)a3;
  if ( (unsigned __int8)a3 < v3 )
    return 0LL;
  v4 = *(_DWORD *)(a1 + 24);
  if ( a3 > v4 )
    return 0LL;
  v5 = *(_DWORD *)(a1 + 28);
  if ( v5 )
  {
    a2 = (unsigned __int8)a2;
    if ( v5 > (unsigned __int8)a2 )
      return 0LL;
    v6 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 32);
    if ( !v6 )
    {
      v7 = *(_QWORD *)(a1 + 80);
      v8 = a3 - v3;
      if ( v7 )
        return v7 + 12LL * v8;
      return a1 + 68;
    }
    a2 = (unsigned __int8)a2;
  }
  if ( v6 >= a2 )
  {
    v8 = (a2 - v5) * (v4 + 1 - v3) + a3 - v3;
    v7 = *(_QWORD *)(a1 + 80);
    if ( v7 )
      return v7 + 12LL * v8;
    return a1 + 68;
  }
  return 0LL;
}

bool __fastcall sub_A3E20(__int64 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  _WORD *v3; // rdx
  bool result; // al

  v3 = (_WORD *)sub_A3DA0(a1, a2, a3);
  result = 0;
  if ( v3 )
  {
    result = 1;
    if ( (signed __int16)v3[4] + (signed __int16)v3[3] <= 0 )
      result = v3[2] > 0;
  }
  return result;
}

__int64 __fastcall sub_A3E60(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned int a6, __int64 a7, unsigned int a8, int a9, char a10, int a11)
{
  __int64 v11; // r14
  __int64 v12; // rdx
  unsigned int v13; // er12
  signed __int64 v14; // rbp
  __int64 (__fastcall *v15)(__int64, __int64, __int64); // rcx
  __int64 result; // rax
  int v17; // er13
  __int64 v18; // rbx
  unsigned int v19; // eax
  __int64 v20; // [rsp+8h] [rbp-50h]
  unsigned int v21; // [rsp+14h] [rbp-44h]
  unsigned int v22; // [rsp+18h] [rbp-40h]

  v11 = a3;
  v12 = a4;
  v13 = a5;
  v20 = a4;
  v21 = a6;
  v14 = a8;
  v15 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(a1 + 8);
  if ( a10 )
  {
    result = v15(a2, v11, v12);
    if ( (signed int)a8 <= 0 )
      return result;
    v17 = a8 - 1;
    v14 = 1LL;
  }
  else
  {
    v17 = 0;
    v15(a2, v11, v20);
  }
  v18 = 0LL;
  do
  {
    if ( a10 )
      v19 = v13
          + (signed int)(a11
                       - (unsigned __int64)(*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD))a1)(
                                             a2,
                                             v11,
                                             a7,
                                             (unsigned int)v18,
                                             (unsigned int)v14))
          / 2;
    else
      v19 = v13;
    v22 = v19;
    (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD, __int64, __int64))(a1 + 16))(
      a2,
      v11,
      v20,
      v19,
      v21,
      a7,
      v18);
    if ( a9 )
      (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, _QWORD, __int64, __int64, signed __int64))(a1 + 16))(
        a2,
        v11,
        v20,
        a9 + v22,
        v21,
        a7,
        v18,
        v14);
    --v17;
    v13 += a11;
    v18 = (unsigned int)(v14 + v18);
    result = (unsigned int)(v17 + 1);
  }
  while ( (signed int)result > 0 );
  return result;
}

__int64 sub_A3FA0()
{
  return 0LL;
}

signed __int64 sub_A3FB0()
{
  return 1LL;
}

__int64 __fastcall sub_A3FC0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a2 + 32LL))(a1);
}

__int64 __fastcall sub_A3FE0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__cdecl **)(__int64))(*(_QWORD *)a2 + 40LL))(a1);
}

__int64 __fastcall sub_A4000(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, int a6, unsigned __int8 a7, unsigned __int8 a8, __int64 a9, unsigned int a10, __int64 (__fastcall *a11)(__int64, __int64, _QWORD, _QWORD, unsigned int *, _QWORD, _QWORD, _QWORD, _QWORD))
{
  __int64 result; // rax
  __int64 v12; // r15
  unsigned int *v13; // r13
  int v14; // ebp
  unsigned int *v15; // rbx
  signed int v16; // er14
  char v17; // r12
  __int64 v18; // rsi
  unsigned int v19; // [rsp+8h] [rbp-50h]
  int v20; // [rsp+Ch] [rbp-4Ch]
  unsigned int v21; // [rsp+18h] [rbp-40h]

  v19 = a3;
  v21 = a4;
  result = a8;
  if ( a6 > 0 )
  {
    v12 = a2;
    v13 = a5;
    v14 = a6;
    do
    {
      v15 = v13 + 1;
      v16 = 1;
      v17 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v12 - 16) + 24LL))(*(_QWORD *)(v12 - 16), *v13);
      if ( v14 == 1 )
      {
        result = a10;
        v16 = 1;
        v20 = a10;
      }
      else
      {
        do
        {
          if ( ((*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(v12 - 16) + 24LL))(
                  *(_QWORD *)(v12 - 16),
                  *v15) ^ 1) == v17 )
          {
            result = v16 * a10;
            v20 = v16 * a10;
            goto LABEL_8;
          }
          ++v16;
          ++v15;
        }
        while ( v16 != v14 );
        v15 = &v13[v16];
        result = v16 * a10;
        v20 = v16 * a10;
      }
LABEL_8:
      v18 = *(_QWORD *)(v12 - 8);
      if ( v17 )
        v18 = *(_QWORD *)(v12 - 16);
      if ( v18 )
        result = a11(a1, v18, v19, v21, v13, (unsigned int)v16, a7, a8, (unsigned int)a9);
      v14 -= v16;
      v19 += v20;
      v13 = v15;
    }
    while ( v14 > 0 );
  }
  return result;
}

__int64 __fastcall sub_A4140(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, int a6, unsigned __int8 a7, unsigned __int8 a8, unsigned int a9)
{
  return sub_A4000(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a9,
           (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, unsigned int *, _QWORD, _QWORD, _QWORD, _QWORD))sub_A3FC0);
}

__int64 __fastcall sub_A4170(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, unsigned int *a5, int a6, unsigned __int8 a7, unsigned __int8 a8, unsigned int a9)
{
  return sub_A4000(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           0,
           (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, unsigned int *, _QWORD, _QWORD, _QWORD, _QWORD))sub_A3FE0);
}

__int64 __fastcall sub_A41A0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 16) + 72LL))();
}

void __fastcall sub_A41B0(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rdi

  v1 = (void *)(a1 - 16);
  (*(void (**)(void))(**(_QWORD **)(a1 - 16) + 16LL))();
  v2 = *(_QWORD *)(a1 - 8);
  if ( v2 )
    (*(void (**)(void))(*(_QWORD *)v2 + 16LL))();
  sub_2F4D0(v1);
}

char *__fastcall sub_A41F0(char *src)
{
  size_t v1; // rax
  __int64 *v2; // rbx
  char *v3; // rbp
  char *v4; // rdx
  char *v5; // rdi
  char *v7; // rdi
  int v8; // eax
  char *v9; // rdi
  int v10; // eax
  char *v11; // rdi
  int v12; // eax
  char *v13; // rdi
  char *v14; // rdi
  __int64 v15; // [rsp+0h] [rbp-A8h]
  __int64 v16; // [rsp+8h] [rbp-A0h]
  __int64 v17; // [rsp+10h] [rbp-98h]
  __int64 v18; // [rsp+18h] [rbp-90h]
  __int64 v19; // [rsp+20h] [rbp-88h]
  __int64 v20; // [rsp+28h] [rbp-80h]
  char *nptr; // [rsp+30h] [rbp-78h]
  char *v22; // [rsp+38h] [rbp-70h]
  char *v23; // [rsp+40h] [rbp-68h]
  char *v24; // [rsp+48h] [rbp-60h]
  __int64 v25; // [rsp+50h] [rbp-58h]
  char *v26; // [rsp+58h] [rbp-50h]
  __int64 v27; // [rsp+60h] [rbp-48h]
  __int64 v28; // [rsp+68h] [rbp-40h]
  __int64 v29; // [rsp+70h] [rbp-38h]
  unsigned __int64 v30; // [rsp+78h] [rbp-30h]

  v30 = __readfsqword(0x28u);
  if ( !src )
    return 0LL;
  v1 = strlen(src);
  v2 = &v15;
  v3 = (char *)sub_2F450(1uLL, 0x60uLL, v1 + 1);
  v4 = strcpy(v3 + 96, src);
  do
  {
    if ( *v4 != 45 )
      goto LABEL_5;
    *v4 = 0;
    ++v2;
    *(v2 - 1) = (__int64)(v4 + 1);
    v4 += strcspn(v4 + 1, "-") + 1;
  }
  while ( &v29 != v2 );
  if ( *v4 )
  {
LABEL_5:
    v5 = v3;
    v3 = 0LL;
    sub_2F4D0(v5);
    return v3;
  }
  v7 = nptr;
  *(_QWORD *)v3 = v15;
  *((_QWORD *)v3 + 1) = v16;
  *((_QWORD *)v3 + 2) = v17;
  *((_QWORD *)v3 + 3) = v18;
  *((_QWORD *)v3 + 4) = v19;
  *((_QWORD *)v3 + 5) = v20;
  v8 = strtol(v7, 0LL, 10);
  v9 = v22;
  *((_DWORD *)v3 + 12) = v8;
  v10 = strtol(v9, 0LL, 10);
  v11 = v23;
  *((_DWORD *)v3 + 13) = v10;
  v12 = strtol(v11, 0LL, 10);
  v13 = v24;
  *((_DWORD *)v3 + 14) = v12;
  *((_DWORD *)v3 + 15) = strtol(v13, 0LL, 10);
  v14 = v26;
  *((_QWORD *)v3 + 8) = v25;
  *((_DWORD *)v3 + 18) = strtol(v14, 0LL, 10);
  *((_QWORD *)v3 + 10) = v27;
  *((_QWORD *)v3 + 11) = v28;
  return v3;
}

char *__fastcall sub_A4380(__int64 *a1)
{
  char *v1; // r11
  signed __int64 v2; // rbx
  __int64 v3; // r8
  __int64 v4; // rsi
  __int64 v5; // rcx
  __int64 v6; // rdx
  signed __int64 v7; // r10
  char *v8; // r9
  __int64 v9; // rax
  char *v10; // rbp
  signed __int64 v11; // r12
  char *v13; // [rsp+8h] [rbp-50h]
  char *v14; // [rsp+10h] [rbp-48h]
  unsigned int v15; // [rsp+18h] [rbp-40h]
  unsigned int v16; // [rsp+1Ch] [rbp-3Ch]

  v1 = "-";
  v2 = 1LL;
  v3 = *((unsigned int *)a1 + 18);
  if ( (_DWORD)v3 == 0x80000000 )
  {
    v1 = "-*";
    v3 = 0LL;
    v2 = 0LL;
  }
  v4 = *((unsigned int *)a1 + 15);
  if ( (_DWORD)v4 == 0x80000000 )
  {
    v4 = 0LL;
    v15 = 0;
    v13 = "-*";
  }
  else
  {
    v15 = 1;
    v13 = "-";
  }
  v5 = *((unsigned int *)a1 + 14);
  if ( (_DWORD)v5 == 0x80000000 )
  {
    v5 = 0LL;
    v16 = 0;
    v14 = "-*";
  }
  else
  {
    v16 = 1;
    v14 = "-";
  }
  v6 = *((unsigned int *)a1 + 13);
  v7 = 1LL;
  v8 = "-";
  if ( (_DWORD)v6 == 0x80000000 )
  {
    v8 = "-*";
    v6 = 0LL;
    v7 = 0LL;
  }
  v9 = *((unsigned int *)a1 + 12);
  if ( (_DWORD)v9 == 0x80000000 )
  {
    v9 = 0LL;
    v11 = 0LL;
    v10 = "-*";
  }
  else
  {
    v10 = "-";
    v11 = 1LL;
  }
  return sub_BC360(
           (__int64)"-%s-%s-%s-%s-%s-%s%s%.*d%s%.*d%s%.*d%s%.*d-%s%s%.*d-%s-%s",
           *a1,
           a1[1],
           a1[2],
           a1[3],
           a1[4],
           a1[5],
           v10,
           v11,
           v9,
           v8,
           v7,
           v6,
           v14,
           v16,
           v5,
           v13,
           v15,
           v4,
           a1[8],
           v1,
           v2,
           v3,
           a1[10],
           a1[11]);
}

char *__fastcall sub_A4510(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  Display *v10; // r13
  Atom v11; // rax
  char *v12; // rax
  const __m128i *v13; // rax
  __m128i *v14; // r12
  int v15; // ebx
  __m128i v16; // xmm0
  char *v17; // r14
  char **v18; // rax
  char **v19; // rbp
  signed __int64 v20; // r14
  char *v21; // r13
  int v22; // ebx
  char *v23; // rax
  int v24; // edx
  int v25; // edx
  int v26; // eax
  char *v27; // rbx
  char *v28; // r14
  double v29; // xmm4_8
  double v30; // xmm5_8
  char *v32; // [rsp+0h] [rbp-C8h]
  Atom v33; // [rsp+18h] [rbp-B0h]
  int v34[4]; // [rsp+20h] [rbp-A8h]
  __m128i v35; // [rsp+30h] [rbp-98h]
  __m128i v36; // [rsp+40h] [rbp-88h]
  __m128i v37; // [rsp+50h] [rbp-78h]
  __m128i v38; // [rsp+60h] [rbp-68h]
  __m128i v39; // [rsp+70h] [rbp-58h]
  unsigned __int64 v40; // [rsp+88h] [rbp-40h]

  v10 = *(Display **)(a1 - 344);
  LODWORD(v32) = a2;
  v40 = __readfsqword(0x28u);
  v11 = XInternAtom(v10, "FONT", 0);
  if ( !XGetFontProperty(*(XFontStruct **)(a1 - 336), v11, &v33) )
    return 0LL;
  v12 = XGetAtomName(v10, v33);
  v13 = (const __m128i *)sub_A41F0(v12);
  v14 = (__m128i *)v13;
  if ( !v13 )
    return 0LL;
  v15 = 0x8000;
  *(__m128i *)v34 = _mm_loadu_si128(v13);
  v35 = _mm_loadu_si128(v13 + 1);
  v36 = _mm_loadu_si128(v13 + 2);
  v37 = _mm_loadu_si128(v13 + 3);
  v38 = _mm_loadu_si128(v13 + 4);
  v16 = _mm_loadu_si128(v13 + 5);
  v37.m128i_i64[0] = -9223372034707292160LL;
  v38.m128i_i32[2] = 2147483648;
  v39 = v16;
  v17 = sub_A4380((__int64 *)v34);
  while ( 1 )
  {
    v18 = XListFonts(v10, v17, v15, v34);
    v19 = v18;
    if ( v34[0] < v15 )
      break;
    v15 *= 2;
    XFreeFontNames(v18);
  }
  sub_2F4D0(v17);
  if ( v34[0] <= 0 )
  {
    v21 = 0LL;
    v27 = 0LL;
  }
  else
  {
    v20 = 1LL;
    v21 = 0LL;
    v22 = (a2 >> 31) | 1;
    do
    {
      v23 = sub_A41F0(v19[v20 - 1]);
      if ( v23 )
      {
        v24 = *((_DWORD *)v23 + 12);
        if ( v24 )
        {
          v25 = v22 * (*((_DWORD *)v23 + 13) + v24);
          if ( v25 > v22 * (v14[3].m128i_i32[0] + v14[3].m128i_i32[1])
            && (!v21 || v25 < v22 * (*((_DWORD *)v21 + 12) + *((_DWORD *)v21 + 13))) )
          {
            v32 = v23;
            sub_2F4D0(v21);
            v21 = v32;
            v23 = 0LL;
          }
        }
        sub_2F4D0(v23);
      }
      v26 = v20++;
    }
    while ( v34[0] > v26 );
    v27 = 0LL;
    if ( v21 )
    {
      v28 = sub_A4380((__int64 *)v21);
      v27 = sub_BC160(
              *(char **)(*(_QWORD *)a1 + 80LL),
              *(double *)v16.m128i_i64,
              a4,
              a5,
              a6,
              v29,
              v30,
              a9,
              a10,
              ":",
              v28,
              0LL,
              v32);
      sub_2F4D0(v28);
    }
  }
  XFreeFontNames(v19);
  sub_2F4D0(v14);
  sub_2F4D0(v21);
  return v27;
}

unsigned __int64 __fastcall sub_A4770(__int64 a1, int a2)
{
  Display *v2; // r14
  XFontStruct *v3; // r12
  Atom v4; // rax
  char *v5; // rax
  char *v6; // r12
  char *v7; // r13
  signed __int64 v8; // rbx
  Atom v10; // [rsp+0h] [rbp-48h]
  unsigned __int64 v11; // [rsp+8h] [rbp-40h]

  v2 = *(Display **)a1;
  v3 = *(XFontStruct **)(a1 + 8);
  v11 = __readfsqword(0x28u);
  v4 = XInternAtom(v2, "FONT", 0);
  if ( XGetFontProperty(v3, v4, &v10) && (v5 = XGetAtomName(v2, v10), (v6 = sub_A41F0(v5)) != 0LL) )
  {
    if ( a2 & 1 )
      *((_QWORD *)v6 + 2) = "bold";
    if ( a2 & 2 )
    {
      *((_DWORD *)v6 + 18) *= 2;
      *((_QWORD *)v6 + 5) = "*";
      *((_QWORD *)v6 + 4) = "*";
    }
    v7 = sub_A4380((__int64 *)v6);
    sub_2F4D0(v6);
  }
  else
  {
    v7 = 0LL;
  }
  v8 = 80LL * a2 + a1;
  *(_QWORD *)(v8 + 8) = XLoadQueryFont(v2, v7);
  *(_BYTE *)(v8 + 16) = 1;
  sub_2F4D0(v7);
  return __readfsqword(0x28u) ^ v11;
}

char *__fastcall sub_A4890(__int64 a1, const char *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  char v5; // r14
  _DWORD *v6; // r13
  Display *v7; // rax
  Display *v8; // rbx
  XFontStruct *v9; // rbp
  Atom v10; // rax
  char *v11; // r15
  Atom v12; // rax
  _DWORD *v14; // [rsp+8h] [rbp-60h]
  Atom v15; // [rsp+18h] [rbp-50h]
  unsigned __int64 v16; // [rsp+20h] [rbp-48h]
  unsigned __int64 v17; // [rsp+28h] [rbp-40h]

  v5 = a5;
  v6 = a4;
  v17 = __readfsqword(0x28u);
  v14 = a3;
  v7 = (Display *)sub_AB820();
  if ( v7 )
  {
    v8 = v7;
    v9 = XLoadQueryFont(v7, a2);
    if ( v9 )
    {
      v10 = XInternAtom(v8, "FONT", 0);
      if ( XGetFontProperty(v9, v10, &v15) )
      {
        v11 = XGetAtomName(v8, v15);
        if ( v11 )
        {
          v16 = 12LL;
          v12 = XInternAtom(v8, "PIXEL_SIZE", 0);
          if ( XGetFontProperty(v9, v12, &v16) )
          {
            if ( v16 )
            {
              *v14 = v16;
              XFreeFont(v8, v9);
              if ( v6 )
              {
                if ( *a2 != 45 && !v5 )
                {
                  *v6 = 4;
                  if ( *a2 != 45 )
                  {
LABEL_12:
                    if ( !v5 )
                      v11 = (char *)a2;
                  }
                  return sub_BC120(v11);
                }
                *v6 = 2;
              }
              if ( *a2 != 45 )
                goto LABEL_12;
              return sub_BC120(v11);
            }
          }
        }
      }
      XFreeFont(v8, v9);
    }
  }
  return 0LL;
}

unsigned __int64 __fastcall sub_A49F0(__int64 a1, void (__fastcall *a2)(__int64, char *, char *, char *, char *, signed __int64, __int64, signed __int64, void **), __int64 a3)
{
  __int64 v3; // rax
  Display *v4; // rbp
  int v5; // ebx
  char **v6; // rax
  void *v7; // rbx
  char **v8; // r15
  signed __int64 v9; // r14
  char *v10; // r12
  int v11; // eax
  char *v12; // rbx
  int v13; // ebp
  __int64 v14; // r9
  int v15; // eax
  __int64 v16; // r9
  char *v17; // rbp
  int v18; // eax
  const char *v19; // rdx
  char *v20; // rbp
  _BYTE *v21; // rdi
  _BYTE *v22; // r8
  signed __int64 v23; // rbp
  char *v24; // rax
  __int64 v25; // rdx
  signed __int64 v26; // rax
  int v27; // eax
  char v29; // r9
  __m128i v30; // xmm0
  __int64 v31; // [rsp+8h] [rbp-C0h]
  char *v32; // [rsp+10h] [rbp-B8h]
  unsigned int v33; // [rsp+1Ch] [rbp-ACh]
  signed __int64 v34; // [rsp+38h] [rbp-90h]
  char *v35; // [rsp+70h] [rbp-58h]
  int v36; // [rsp+7Ch] [rbp-4Ch]
  int v37; // [rsp+84h] [rbp-44h]
  unsigned __int64 v38; // [rsp+88h] [rbp-40h]

  v38 = __readfsqword(0x28u);
  v31 = a3;
  v3 = sub_AB820();
  if ( v3 )
  {
    v4 = (Display *)v3;
    v5 = 0x8000;
    while ( 1 )
    {
      v6 = XListFonts(v4, "*", v5, &v37);
      if ( v37 < v5 )
        break;
      v5 *= 2;
      XFreeFontNames(v6);
    }
    v7 = 0LL;
    v8 = v6;
    v9 = 1LL;
    v36 = 0;
    v10 = 0LL;
    if ( v37 <= 0 )
    {
LABEL_31:
      XFreeFontNames(v8);
      sub_2F4D0(v7);
      return __readfsqword(0x28u) ^ v38;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = sub_A41F0(v8[v9 - 1]);
        if ( v12 )
          break;
        a2(v31, v8[v9 - 1], v8[v9 - 1], 0LL, 0LL, 0LL, 0LL, 4LL, &off_322720);
        sub_2F4D0(0LL);
        v11 = v9++;
        if ( v37 <= v11 )
          goto LABEL_30;
      }
      v13 = 4 * strlen(v8[v9 - 1]) + 256;
      v34 = v13;
      if ( v13 > v36 )
      {
        v36 = v13;
        v10 = (char *)sub_2F490(v10, v13, 1uLL);
      }
      v14 = *(_QWORD *)v12;
      v15 = __sprintf_chk(v10, 1LL, -1LL, "%s (%s)", *((_QWORD *)v12 + 1));
      v16 = *((_QWORD *)v12 + 11);
      v17 = &v10[v15 + 1];
      v35 = &v10[v15 + 1];
      v18 = __sprintf_chk(v17, 1LL, -1LL, "%s-%s", *((_QWORD *)v12 + 10));
      v19 = (const char *)*((_QWORD *)v12 + 2);
      v32 = &v17[v18 + 1];
      if ( !*v19 )
        v19 = "regular";
      v20 = &v32[sprintf(&v17[v18 + 1], "%s", v19)];
      if ( !(unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), "i") )
        break;
      if ( (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), &off_FD4B4) )
      {
        if ( (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), "ri") )
        {
          if ( (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), "ro") )
          {
            if ( !(unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), "ot") )
            {
              *((_DWORD *)v20 + 2) = 1953390956;
              v20[12] = 0;
              *(_QWORD *)v20 = 8299415468183416608LL;
              v20 += 12;
            }
          }
          else
          {
            v30 = _mm_load_si128((const __m128i *)&xmmword_F7FC0);
            v20 += 16;
            *v20 = 0;
            *((__m128i *)v20 - 1) = v30;
          }
        }
        else
        {
          v20 += 15;
          *(__m128i *)(v20 - 15) = _mm_load_si128((const __m128i *)&xmmword_F7FB0);
        }
LABEL_15:
        v21 = (_BYTE *)*((_QWORD *)v12 + 4);
        if ( *v21 )
          goto LABEL_35;
        goto LABEL_16;
      }
      v20[8] = 0;
      v20 += 8;
      *((_QWORD *)v20 - 1) = 7310874267709763360LL;
      v21 = (_BYTE *)*((_QWORD *)v12 + 4);
      if ( *v21 )
      {
LABEL_35:
        if ( (unsigned int)g_ascii_strcasecmp(v21, "normal") )
          v20 += (signed int)__sprintf_chk(v20, 1LL, -1LL, " %s", *((_QWORD *)v12 + 4));
      }
LABEL_16:
      if ( !(unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 8), "m") )
      {
        *(_DWORD *)v20 = 1565350688;
        v20[4] = 0;
        v20 += 4;
      }
      if ( !(unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 8), "c") )
      {
        *(_DWORD *)v20 = 1564695328;
        v20[4] = 0;
        v20 += 4;
      }
      v22 = (_BYTE *)*((_QWORD *)v12 + 5);
      if ( *v22 )
        v20 += (signed int)__sprintf_chk(v20, 1LL, -1LL, " %s", v22);
      v23 = (signed __int64)(v20 + 1);
      if ( (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 2), "medium")
        && (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 2), "regular")
        && (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 2), "normal")
        && (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 2), "book") )
      {
        if ( !(unsigned int)g_ascii_strncasecmp(*((_QWORD *)v12 + 2), "demi", 4LL)
          || (v33 = 2, !(unsigned int)g_ascii_strncasecmp(*((_QWORD *)v12 + 2), "semi", 4LL)) )
        {
          v33 = 1;
        }
      }
      else
      {
        v33 = 0;
      }
      if ( (unsigned int)g_ascii_strcasecmp(*((_QWORD *)v12 + 3), "r") )
        v29 = ((unsigned int)g_ascii_strncasecmp(*((_QWORD *)v12 + 3), "r", 1LL) == 0) + 1;
      g_ascii_strcasecmp(*((_QWORD *)v12 + 4), "normal");
      strlen(*((const char **)v12 + 5));
      strlen(*((const char **)v12 + 8));
      strlen(*((const char **)v12 + 4));
      strlen(*((const char **)v12 + 3));
      strlen(*((const char **)v12 + 2));
      if ( v23
         + (signed int)__sprintf_chk(v23, 1LL, -1LL, "%04d%04d%s%04d%04d%s%04d%04d%s%04d%s%04d%s", v33)
         - (signed __int64)v10 >= v34 )
        __assert_fail("p - tmp < thistmpsize", "unix/gtkfont.c", 0x450u, "x11font_enum_fonts");
      v24 = strchr("CcMm", **((char **)v12 + 8));
      v25 = *((unsigned int *)v12 + 12);
      v26 = (unsigned __int64)v24 < 1 ? 10 : 2;
      if ( (_DWORD)v25 )
        a2(v31, v8[v9 - 1], v10, v35, v32, v23, v25, v26, &off_322720);
      sub_2F4D0(v12);
      v27 = v9++;
      if ( v37 <= v27 )
      {
LABEL_30:
        v7 = v10;
        goto LABEL_31;
      }
    }
    v20 += 7;
    *(_QWORD *)(v20 - 7) = 27981936906758432LL;
    goto LABEL_15;
  }
  return __readfsqword(0x28u) ^ v38;
}

void __fastcall sub_A50B0(int *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, signed int a6, char a7, char a8, int a9)
{
  signed int v9; // er13
  __int64 v10; // rbx
  __int64 v11; // r12
  __int64 v12; // rax
  int v13; // er10
  char v14; // cl
  int v15; // edx
  int v16; // er14
  signed int v17; // er8
  char v18; // di
  int v19; // er11
  signed __int64 v20; // rbp
  __int64 v21; // rsi
  int v22; // er15
  __int64 v23; // rbp
  char v24; // ST58_1
  signed int v25; // ST54_4
  int v26; // ST50_4
  __int64 v27; // ST48_8
  int v28; // er10
  __int64 v29; // rbp
  __int64 v30; // r15
  _BYTE *v31; // r14
  __int64 v32; // rax
  int v33; // edx
  int v34; // ST54_4
  int v35; // ST50_4
  _BYTE *v36; // rax
  unsigned int v37; // eax
  int v38; // ST5C_4
  signed int v39; // ST58_4
  int v40; // ST54_4
  int v41; // ST50_4
  __int64 v42; // ST48_8
  int *v43; // [rsp+18h] [rbp-60h]
  unsigned int v44; // [rsp+20h] [rbp-58h]
  unsigned int v45; // [rsp+24h] [rbp-54h]
  int v46; // [rsp+28h] [rbp-50h]
  int v47; // [rsp+30h] [rbp-48h]

  v9 = a6;
  v10 = a2;
  v11 = a5;
  v12 = a2 - 344;
  v44 = a3;
  v45 = a4;
  v43 = a1;
  v13 = a9;
  v14 = a8;
  v15 = *a1;
  if ( a7 )
  {
    v17 = 2;
    v16 = 2 * (unsigned __int8)(*(_BYTE *)(a2 - 4) ^ 1);
  }
  else
  {
    v16 = 0;
    v17 = 1;
  }
  v18 = *(_BYTE *)(a2 - 2);
  if ( !a8 || *(_BYTE *)(a2 - 3) )
  {
    if ( v18 )
    {
      v19 = 0;
LABEL_7:
      v20 = v10 + 80LL * v16;
      if ( *(_BYTE *)(v20 - 328) )
      {
        v21 = *(_QWORD *)(v20 - 336);
        v22 = v16;
      }
      else
      {
        v38 = v13;
        v39 = v17;
        v40 = v15;
        v22 = v16;
        v41 = v19;
        v42 = v12;
        sub_A4770(v12, v16);
        v21 = *(_QWORD *)(v20 - 336);
        v12 = v42;
        v19 = v41;
        v15 = v40;
        v17 = v39;
        v13 = v38;
      }
LABEL_9:
      if ( !v21 )
        return;
      goto LABEL_16;
    }
    v23 = a2 + 80LL * v16;
    v14 = *(_BYTE *)(v23 - 328);
    if ( v14 )
    {
      v21 = *(_QWORD *)(v23 - 336);
      v22 = v16;
      v19 = 0;
      goto LABEL_9;
    }
    v22 = v16;
  }
  else
  {
    if ( v18 )
    {
LABEL_6:
      v19 = *(_DWORD *)(v10 - 8);
      goto LABEL_7;
    }
    v22 = v16 + 1;
    v23 = a2 + 80LL * (v16 + 1);
    if ( *(_BYTE *)(v23 - 328) )
    {
      v21 = *(_QWORD *)(v23 - 336);
      goto LABEL_15;
    }
  }
  v24 = v14;
  v25 = v17;
  v26 = v15;
  v27 = a2 - 344;
  sub_A4770(v12, v22);
  v21 = *(_QWORD *)(v23 - 336);
  v12 = v27;
  v15 = v26;
  v17 = v25;
  v13 = a9;
  if ( !v24 )
  {
    v19 = 0;
    goto LABEL_9;
  }
LABEL_15:
  v19 = 0;
  if ( !v21 )
    goto LABEL_6;
LABEL_16:
  v28 = v17 * v13;
  v29 = 2 * v15;
  v30 = v12 + 80LL * v22 + 8;
  if ( *(_BYTE *)(v10 - 16) )
  {
    v47 = v28;
    v46 = v19;
    v31 = sub_2F450(v9, 2uLL, 0LL);
    if ( v9 > 0 )
    {
      v32 = 0LL;
      do
      {
        v33 = *(_DWORD *)(v11 + 2 * v32);
        v31[v32 + 1] = v33;
        v31[v32] = BYTE1(v33);
        v32 += 2LL;
      }
      while ( v32 != 2LL * (unsigned int)(v9 - 1) + 2 );
    }
    sub_A3E60(
      (__int64)(&off_3226E0 + 3 * v29 + 3),
      (__int64)v43,
      v30,
      *(_QWORD *)(v10 - 344),
      v44,
      v45,
      (__int64)v31,
      v9,
      v46,
      *(_BYTE *)(v10 - 15),
      v47);
  }
  else
  {
    v34 = v28;
    v35 = v19;
    v36 = sub_2F450(v9 + 1, 1uLL, 0LL);
    v31 = v36;
    v37 = sub_BB550(*(_DWORD *)(v10 - 12), 0LL, v11, v9, (__int64)v36, v9 + 1, ".");
    sub_A3E60(
      (__int64)(&off_3226E0 + 3 * v29),
      (__int64)v43,
      v30,
      *(_QWORD *)(v10 - 344),
      v44,
      v45,
      (__int64)v31,
      v37,
      v35,
      *(_BYTE *)(v10 - 15),
      v34);
  }
  sub_2F4D0(v31);
}

void __fastcall sub_A5400(int *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, int a6, char a7, char a8, int a9)
{
  unsigned int v9; // er14
  unsigned int v10; // er15
  __int64 v11; // r12
  __int64 v12; // r8
  signed __int64 v13; // [rsp+0h] [rbp-48h]

  if ( a6 > 0 )
  {
    v9 = a3;
    v10 = a4;
    v11 = a5;
    v13 = a5 + 4LL * (unsigned int)(a6 - 1) + 4;
    do
    {
      v12 = v11;
      v11 += 4LL;
      sub_A50B0(a1, a2, v9, v10, v12, 1, a7, a8, a9);
    }
    while ( v11 != v13 );
  }
}

__int64 __fastcall sub_A5490(__int64 a1, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  unsigned int v5; // eax
  int v6; // [rsp+Ch] [rbp-2Ch]
  unsigned __int8 v7; // [rsp+16h] [rbp-22h]
  unsigned __int64 v8; // [rsp+18h] [rbp-20h]

  v2 = *(unsigned __int8 *)(a1 - 16);
  v8 = __readfsqword(0x28u);
  v6 = a2;
  if ( (_BYTE)v2 )
  {
    LOBYTE(v3) = sub_A3E20(*(_QWORD *)(a1 - 336), BYTE1(a2), a2);
    v2 = v3;
  }
  else if ( (unsigned int)sub_BB550(*(_DWORD *)(a1 - 12), 0LL, (__int64)&v6, 1, (__int64)&v7, 2, &locale) && v7 )
  {
    LOBYTE(v5) = sub_A3E20(*(_QWORD *)(a1 - 336), 0, v7);
    v2 = v5;
  }
  return v2;
}

int __fastcall sub_A5540(__int64 a1, XFontStruct **a2, __int64 a3, int a4, int a5)
{
  return XTextWidth16(*a2, (const XChar2b *)(a3 + 2LL * a4), a5);
}

__int64 __fastcall sub_A5560(Display *a1, __int64 a2, int a3)
{
  __int64 v3; // r15
  signed __int16 *v4; // r12
  void *v5; // r13
  XImage *v6; // rax
  int v7; // ecx
  XImage *v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // ST00_8
  __int64 v11; // rdx
  int v12; // ebp
  int v13; // eax
  int v14; // er14
  int v15; // eax
  int v16; // ebx
  char *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r8
  char *v20; // rbx
  __int64 v21; // rdx
  __int64 result; // rax
  void *v23; // rdi
  int v24; // eax
  int v25; // ecx
  char *v26; // rdx
  unsigned __int64 v27; // rcx
  int v28; // [rsp+Ch] [rbp-3Ch]

  v3 = a2;
  v28 = a3;
  v4 = (signed __int16 *)sub_A3DA0(*(_QWORD *)a2, a3 >> 8, (unsigned __int8)a3);
  v5 = sub_2F450(*(signed int *)(a2 + 68), 1uLL, 0LL);
  memset(v5, 0, *(signed int *)(a2 + 68));
  v6 = XGetImage(a1, *(_QWORD *)(v3 + 32), 0, 0, *(_DWORD *)(v3 + 48), *(_DWORD *)(v3 + 52), 0xFFFFFFFFFFFFFFFFLL, 1);
  v7 = *(_DWORD *)(a2 + 60);
  v8 = v6;
  v9 = (unsigned int)v4[4];
  v11 = v10;
  v12 = *(_DWORD *)(v3 + 60) - v4[3];
  if ( v12 < (signed int)v9 + v7 )
  {
    v11 = (unsigned int)v4[1];
    v13 = *(_DWORD *)(v3 + 56);
    do
    {
      v14 = *v4 + v13;
      if ( v14 < (signed int)v11 + v13 )
      {
        do
        {
          if ( ((__int64 (__fastcall *)(XImage *, _QWORD, _QWORD))v8->f.get_pixel)(
                 v8,
                 (unsigned int)v14,
                 (unsigned int)v12) )
          {
            v15 = v14 + 7;
            if ( v14 >= 0 )
              v15 = v14;
            *((_BYTE *)v5 + v12 * *(_DWORD *)(v3 + 64) + (v15 >> 3)) |= 1 << (*(_BYTE *)(v3 + 72) ^ v14 & 7);
          }
          v11 = (unsigned int)v4[1];
          v13 = *(_DWORD *)(v3 + 56);
          ++v14;
        }
        while ( (signed int)v11 + v13 > v14 );
        v9 = (unsigned int)v4[4];
        v7 = *(_DWORD *)(v3 + 60);
      }
      ++v12;
    }
    while ( (signed int)v9 + v7 > v12 );
  }
  ((void (__fastcall *)(XImage *, __int64, __int64))v8->f.destroy_image)(v8, v9, v11);
  v16 = *(_DWORD *)(v3 + 24);
  if ( v16 <= v28 )
  {
    v23 = *(void **)(v3 + 16);
    v24 = v28 + 256;
    LOBYTE(v24) = 0;
    *(_DWORD *)(v3 + 24) = v24;
    v17 = (char *)sub_2F490(v23, v24, 0x10uLL);
    v25 = *(_DWORD *)(v3 + 24);
    *(_QWORD *)(v3 + 16) = v17;
    if ( v16 < v25 )
    {
      v26 = &v17[16 * v16];
      v27 = (unsigned __int64)&v17[16 * (v16 + (unsigned __int64)(unsigned int)(v25 - 1 - v16)) + 16];
      do
      {
        *(_QWORD *)v26 = 0LL;
        *((_QWORD *)v26 + 1) = 0LL;
        v26 += 16;
      }
      while ( v26 != (char *)v27 );
    }
  }
  else
  {
    v17 = *(char **)(v3 + 16);
  }
  v18 = *(unsigned int *)(v3 + 52);
  v19 = *(unsigned int *)(v3 + 64);
  v20 = &v17[16 * v28];
  v21 = *(unsigned int *)(v3 + 48);
  *((_QWORD *)v20 + 1) = v5;
  result = cairo_image_surface_create_for_data(v5, 3LL, v21, v18, v19);
  *(_QWORD *)v20 = result;
  return result;
}

int __fastcall sub_A5750(__int64 a1, XFontStruct **a2, __int64 a3, int a4, int a5)
{
  return XTextWidth(*a2, (const char *)(a3 + a4), a5);
}

void __fastcall sub_A5770(__int64 a1)
{
  void *v1; // r15
  signed __int64 v2; // r13
  signed __int64 v3; // rbx
  Display *v4; // r14
  struct _XGC *v5; // rsi
  Pixmap v6; // rsi
  char *v7; // rdi
  __int64 v8; // rbp
  int v9; // er12
  void *v10; // rdi

  v1 = (void *)(a1 - 344);
  v2 = a1 - 16;
  v3 = a1 - 336;
  v4 = *(Display **)(a1 - 344);
  do
  {
    if ( *(_QWORD *)v3 )
      XFreeFont(v4, *(XFontStruct **)v3);
    v5 = *(struct _XGC **)(v3 + 40);
    if ( v5 )
      XFreeGC(v4, v5);
    v6 = *(_QWORD *)(v3 + 32);
    if ( v6 )
      XFreePixmap(v4, v6);
    v7 = *(char **)(v3 + 16);
    if ( v7 )
    {
      if ( *(_DWORD *)(v3 + 24) > 0 )
      {
        v8 = 0LL;
        v9 = 0;
        do
        {
          ++v9;
          cairo_surface_destroy(*(_QWORD *)&v7[v8]);
          v10 = *(void **)(*(_QWORD *)(v3 + 16) + v8 + 8);
          v8 += 16LL;
          sub_2F4D0(v10);
          v7 = *(char **)(v3 + 16);
        }
        while ( *(_DWORD *)(v3 + 24) > v9 );
      }
      sub_2F4D0(v7);
    }
    v3 += 80LL;
  }
  while ( v3 != v2 );
  sub_2F4D0(v1);
}

_QWORD *__fastcall sub_A5840(__int64 a1, const char *a2, char a3, char a4, int a5, char a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  char v14; // r15
  int v15; // er14
  Display *v16; // rax
  Display *v17; // rbp
  XFontStruct *v18; // rbx
  Atom v19; // r12
  Atom v20; // r13
  Atom v21; // rax
  signed int v22; // er12
  Display **v23; // rcx
  Display **v24; // ST18_8
  bool v25; // r13
  int v26; // eax
  Display **v27; // rcx
  int v28; // eax
  int v29; // edx
  int v30; // edx
  int v31; // eax
  signed __int64 v32; // rdx
  _QWORD *result; // rax
  char *v34; // rax
  Display **v35; // ST18_8
  char *v36; // r12
  char *v37; // rax
  double v38; // xmm4_8
  double v39; // xmm5_8
  int v40; // er10
  int v41; // er10
  Atom v42; // rax
  bool v43; // [rsp+Bh] [rbp-7Dh]
  char v44; // [rsp+Ch] [rbp-7Ch]
  char v45; // [rsp+10h] [rbp-78h]
  signed int v46; // [rsp+14h] [rbp-74h]
  unsigned __int8 *v47; // [rsp+18h] [rbp-70h]
  XChar2b v48; // [rsp+2Eh] [rbp-5Ah]
  Atom v49; // [rsp+30h] [rbp-58h]
  Atom v50; // [rsp+38h] [rbp-50h]
  Atom v51; // [rsp+40h] [rbp-48h]
  unsigned __int64 v52; // [rsp+48h] [rbp-40h]

  v14 = a6;
  v15 = a5;
  v52 = __readfsqword(0x28u);
  v44 = a3;
  v45 = a4;
  v16 = (Display *)sub_AB820();
  if ( !v16 )
    return 0LL;
  v17 = v16;
  v18 = XLoadQueryFont(v16, a2);
  if ( !v18 )
    return 0LL;
  v19 = XInternAtom(v17, "CHARSET_REGISTRY", 0);
  v20 = XInternAtom(v17, "CHARSET_ENCODING", 0);
  if ( !XGetFontProperty(v18, v19, &v49)
    || !XGetFontProperty(v18, v20, &v50)
    || (v36 = XGetAtomName(v17, v49), v37 = XGetAtomName(v17, v50), (v43 = v37 != 0LL && v36 != 0LL) == 0) )
  {
    v21 = XInternAtom(v17, "SPACING", 0);
    v22 = XGetFontProperty(v18, v21, &v51);
    if ( !v22 )
    {
      v23 = (Display **)sub_2F450(1uLL, 0x180uLL, 0LL);
      v46 = 0;
      v43 = 1;
      v23[43] = (Display *)&off_322720;
      goto LABEL_6;
    }
    v25 = 0;
    v46 = 0;
    v22 = 0;
    goto LABEL_14;
  }
  v47 = (unsigned __int8 *)sub_BC160(v36, a7, a8, a9, a10, v38, v39, a13, a14, "-", v37, 0LL);
  v22 = sub_1CA70(v47);
  if ( !strcasecmp((const char *)v47, "iso10646-1") )
  {
    v25 = v43;
    v22 = 55;
    v46 = 55;
  }
  else if ( v22 == 1 )
  {
    LOBYTE(v40) = 1;
    do
    {
      v25 = sub_A3E20((__int64)v18, 0, v40);
      if ( !v25 )
      {
        v46 = 1;
        goto LABEL_26;
      }
      v40 = v41 + 1;
    }
    while ( v40 != 32 );
    v25 = 0;
    v46 = 2;
  }
  else
  {
    v46 = v22;
    v25 = 0;
  }
LABEL_26:
  sub_2F4D0(v47);
  v42 = XInternAtom(v17, "SPACING", 0);
  if ( XGetFontProperty(v18, v42, &v51) )
  {
LABEL_14:
    v34 = XGetAtomName(v17, v51);
    v43 = 1;
    if ( v34 )
      v43 = strchr("CcMm", *v34) == 0LL;
  }
  v23 = (Display **)sub_2F450(1uLL, 0x180uLL, 0LL);
  v23[43] = (Display *)&off_322720;
  if ( v25 )
  {
    v35 = v23;
    v48 = (XChar2b)12288;
    v26 = XTextWidth16(v18, &v48, 1);
    v27 = v35;
    goto LABEL_7;
  }
LABEL_6:
  v24 = v23;
  v25 = 0;
  v26 = XTextWidth(v18, "0", 1);
  v27 = v24;
LABEL_7:
  *((_DWORD *)v27 + 89) = v26;
  v28 = v18->ascent;
  v29 = v18->descent;
  *((_DWORD *)v27 + 88) = v22;
  *((_BYTE *)v27 + 376) = 1;
  *((_DWORD *)v27 + 95) = 0;
  *((_DWORD *)v27 + 91) = v28;
  *v27 = v17;
  *((_DWORD *)v27 + 92) = v29;
  *((_BYTE *)v27 + 328) = v25;
  *((_DWORD *)v27 + 90) = v28 + v29;
  v30 = 3 * v28 + 7;
  *((_DWORD *)v27 + 84) = v15;
  *((_BYTE *)v27 + 342) = v14;
  if ( 3 * v28 >= 0 )
    v30 = 3 * v28;
  v31 = v28 - (v30 >> 3);
  v32 = (signed __int64)(v27 + 1);
  *((_DWORD *)v27 + 93) = v31;
  *((_DWORD *)v27 + 83) = v46;
  *((_BYTE *)v27 + 329) = v43;
  *((_BYTE *)v27 + 340) = v44;
  *((_BYTE *)v27 + 341) = v45;
  do
  {
    *(_QWORD *)v32 = 0LL;
    *(_BYTE *)(v32 + 8) = 0;
    v32 += 80LL;
    *(_QWORD *)(v32 - 64) = 0LL;
    *(_DWORD *)(v32 - 56) = 0;
    *(_QWORD *)(v32 - 48) = 0LL;
    *(_QWORD *)(v32 - 40) = 0LL;
  }
  while ( v27 + 41 != (Display **)v32 );
  result = v27 + 43;
  v27[1] = (Display *)v18;
  *((_BYTE *)v27 + 16) = 1;
  return result;
}

char *__fastcall sub_A5C30(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbp
  __int64 v11; // rbx
  double v12; // xmm4_8
  double v13; // xmm5_8
  char *v14; // r12
  char *result; // rax

  v10 = pango_font_description_copy_static(*(_QWORD *)(a1 - 48));
  if ( (signed int)((a2 << 10) + (unsigned __int64)pango_font_description_get_size(v10)) <= 0 )
  {
    pango_font_description_free(v10);
    result = 0LL;
  }
  else
  {
    pango_font_description_set_size(v10);
    v11 = pango_font_description_to_string(v10);
    v14 = sub_BC160(*(char **)(*(_QWORD *)a1 + 80LL), a3, a4, a5, a6, v12, v13, a9, a10, ":", v11, 0LL);
    g_free(v11);
    pango_font_description_free(v10);
    result = v14;
  }
  return result;
}

char *__fastcall sub_A5CC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  char *v4; // rbp
  char *v5; // r12

  v2 = pango_font_description_from_string(a2);
  if ( !v2 )
    return 0LL;
  v3 = v2;
  pango_font_description_set_size(v2);
  v4 = (char *)pango_font_description_to_string(v3);
  v5 = sub_BC120(v4);
  g_free(v4);
  pango_font_description_free(v3);
  return v5;
}

void __fastcall sub_A5D20(__int64 a1, __int64 a2)
{
  pango_font_description_free(*(_QWORD *)(a1 - 48));
  sub_2F4D0(*(void **)(a1 - 16));
  g_object_unref(*(_QWORD *)(a1 - 40), a2);
  sub_2F4D0((void *)(a1 - 48));
}

__int64 __fastcall sub_A5D50(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rax
  __int64 v4; // rbx
  int v5; // ebp
  __int64 v6; // r12
  __int64 v7; // rax
  int v9; // [rsp+Ch] [rbp-3Ch]
  __int64 v10; // [rsp+10h] [rbp-38h]
  unsigned __int64 v11; // [rsp+18h] [rbp-30h]

  v2 = 0;
  v11 = __readfsqword(0x28u);
  v3 = pango_context_get_font_map(a1, a2);
  if ( v3 )
  {
    pango_font_map_list_families(v3, &v10, &v9);
    if ( v9 <= 0 )
    {
LABEL_9:
      v2 = 0;
    }
    else
    {
      v4 = 0LL;
      v5 = 0;
      while ( 1 )
      {
        v6 = pango_font_description_get_family(a2);
        v7 = pango_font_family_get_name(*(_QWORD *)(v10 + v4));
        if ( !(unsigned int)g_ascii_strcasecmp(v7, v6) )
          break;
        ++v5;
        v4 += 8LL;
        if ( v9 <= v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
    g_free(v10);
  }
  return v2;
}

char *__fastcall sub_A5E20(__int64 a1, __int64 a2, signed int *a3, _DWORD *a4)
{
  signed int *v4; // r13
  _DWORD *v5; // r12
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rbp
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 v12; // rsi
  __int64 v13; // rax
  __int64 v14; // rbp
  __int64 v15; // rax
  __int64 v16; // r14
  char *v17; // r13
  char *v18; // r12
  char *result; // rax

  v4 = a3;
  v5 = a4;
  v6 = pango_font_description_from_string(a2);
  if ( !v6 )
    return 0LL;
  v7 = v6;
  v8 = gtk_widget_get_pango_context(a1);
  v9 = v8;
  if ( v8
    && (unsigned __int8)sub_A5D50(v8, v7)
    && (v10 = pango_context_get_font_map(v9, v7)) != 0
    && (v11 = pango_context_get_language(v9),
        v12 = v9,
        v13 = pango_font_map_load_fontset(v10, v9, v7, v11),
        (v14 = v13) != 0) )
  {
    v15 = pango_fontset_get_metrics(v13);
    v16 = v15;
    if ( v15 && (unsigned int)pango_font_metrics_get_approximate_digit_width(v15) )
    {
      *v4 = (signed int)((unsigned __int64)pango_font_description_get_size(v7) + 512) >> 10;
      *v5 = 1;
      pango_font_description_set_size(v7);
      v17 = (char *)pango_font_description_to_string(v7);
      v18 = sub_BC120(v17);
      g_free(v17);
      pango_font_metrics_unref(v16, 12288LL);
      pango_font_description_free(v7);
      g_object_unref(v14, 12288LL);
      return v18;
    }
    pango_font_description_free(v7);
    g_object_unref(v14, v12);
    result = 0LL;
  }
  else
  {
    pango_font_description_free(v7);
    result = 0LL;
  }
  return result;
}

unsigned __int64 __fastcall sub_A5F80(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64, _QWORD, __int64, __int64, __int64, _QWORD, __int64 (__fastcall **)()), __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 *v5; // rsi
  __int64 v6; // rbx
  __int64 v7; // rbp
  __int64 v8; // rbx
  int *v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // r12
  int v12; // er13
  __int64 v13; // rsi
  __int64 v14; // r14
  __int64 *v15; // rbp
  int v16; // eax
  unsigned int v17; // eax
  signed int v18; // eax
  unsigned int v19; // eax
  __int64 v20; // rax
  __int64 v21; // rdx
  void *v22; // rbp
  int *v24; // [rsp+0h] [rbp-C8h]
  __int64 v25; // [rsp+8h] [rbp-C0h]
  __int64 v26; // [rsp+10h] [rbp-B8h]
  void (__fastcall *v27)(__int64, __int64, __int64, _QWORD, __int64, __int64, __int64, _QWORD, __int64 (__fastcall **)()); // [rsp+18h] [rbp-B0h]
  __int64 v28; // [rsp+20h] [rbp-A8h]
  unsigned int v29; // [rsp+28h] [rbp-A0h]
  int v30; // [rsp+2Ch] [rbp-9Ch]
  __int64 v31; // [rsp+30h] [rbp-98h]
  __int64 v32; // [rsp+48h] [rbp-80h]
  int v33; // [rsp+60h] [rbp-68h]
  int v34; // [rsp+64h] [rbp-64h]
  int v35; // [rsp+68h] [rbp-60h]
  int v36; // [rsp+6Ch] [rbp-5Ch]
  __int64 v37; // [rsp+70h] [rbp-58h]
  __int64 v38; // [rsp+78h] [rbp-50h]
  int *v39; // [rsp+80h] [rbp-48h]
  unsigned __int64 v40; // [rsp+88h] [rbp-40h]

  v40 = __readfsqword(0x28u);
  v27 = a2;
  v28 = a3;
  v3 = gtk_widget_get_pango_context(a1);
  if ( v3 )
  {
    v4 = pango_context_get_font_map(v3, a2);
    if ( v4 )
    {
      v5 = &v37;
      pango_font_map_list_families(v4, &v37, &v33);
      if ( v33 > 0 )
      {
        v32 = 0LL;
        while ( 1 )
        {
          v6 = *(_QWORD *)(v37 + 8 * v32);
          v29 = (unsigned int)pango_font_family_is_monospace(*(_QWORD *)(v37 + 8 * v32), v5) < 1 ? 9 : 1;
          v5 = &v38;
          v26 = pango_font_family_get_name(v6);
          pango_font_family_list_faces(v6, &v38, &v34);
          if ( v34 > 0 )
            break;
LABEL_21:
          g_free(v38);
          if ( v33 <= (signed int)++v32 )
            goto LABEL_22;
        }
        v31 = 0LL;
        v30 = 0;
        v24 = &v36;
        while ( 1 )
        {
          v7 = *(_QWORD *)(v38 + v31);
          v25 = pango_font_face_get_face_name(*(_QWORD *)(v38 + v31));
          v5 = (__int64 *)&v39;
          v8 = pango_font_face_describe(v7);
          pango_font_face_list_sizes(v7, &v39, &v35);
          v9 = v39;
          if ( !v39 )
            break;
          if ( v35 > 0 )
          {
            v10 = (unsigned int)*v39;
            goto LABEL_10;
          }
LABEL_18:
          if ( v9 != v24 )
            g_free(v9);
          pango_font_description_free(v8);
          ++v30;
          v31 += 8LL;
          if ( v34 <= v30 )
            goto LABEL_21;
        }
        v36 = 12288;
        v35 = 1;
        v39 = v24;
LABEL_10:
        v11 = 0LL;
        v12 = 0;
        while ( 1 )
        {
          pango_font_description_set_size(v8);
          v14 = pango_font_description_to_string(v8);
          v15 = (__int64 *)sub_BC640();
          v16 = pango_font_description_get_weight(v8);
          if ( v16 < 401 )
            v16 = 400 - v16;
          sub_BC720((__int64)v15, (__int64)"%4d", (unsigned int)v16, v24);
          v17 = pango_font_description_get_style(v8, "%4d");
          sub_BC720((__int64)v15, (__int64)" %2d", v17);
          v18 = pango_font_description_get_stretch(v8, " %2d");
          sub_BC720((__int64)v15, (__int64)" %2d", (unsigned int)(v18 <= 3) + 2 * abs(4 - v18));
          v19 = pango_font_description_get_variant(v8, " %2d");
          sub_BC720((__int64)v15, (__int64)" %2d", v19);
          v20 = sub_BC6B0(v15);
          v21 = 0LL;
          v22 = (void *)v20;
          if ( v39 != v24 )
            v21 = (unsigned int)((v39[v11] + 512) >> 10);
          v5 = (__int64 *)v14;
          ++v12;
          ++v11;
          v27(v28, v14, v26, 0LL, v25, v20, v21, v29, off_322680);
          sub_2F4D0(v22);
          g_free(v14);
          if ( v35 <= v12 )
            break;
          v13 = (unsigned int)v39[v11];
        }
        v9 = v39;
        goto LABEL_18;
      }
LABEL_22:
      g_free(v37);
    }
  }
  return __readfsqword(0x28u) ^ v40;
}

signed __int64 __fastcall sub_A62F0(const char *a1, signed int *a2, signed int *a3)
{
  signed int *v3; // r12
  signed int *v4; // rbp
  const char *v5; // rbx
  unsigned __int64 v6; // rax
  bool v7; // cf
  bool v8; // zf
  signed __int64 result; // rax
  const char *v10; // rsi
  signed __int64 v11; // rcx
  signed int v12; // edx
  bool v13; // cf
  bool v14; // zf
  const char *v15; // rsi
  signed __int64 v16; // rcx
  const char *v17; // rdi
  signed int v18; // eax

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v6 = (signed int)strcspn(a1, ":");
  if ( a1[(signed int)v6] )
  {
    v7 = v6 < 6;
    v8 = v6 == 6;
    if ( v6 != 6 )
    {
LABEL_3:
      *v4 = 0;
      result = (signed __int64)&v5[v6 + 1];
      *v3 = 0;
      return result;
    }
    v10 = "client";
    v11 = 6LL;
    do
    {
      if ( !v11 )
        break;
      v7 = (const unsigned __int8)*v10 < *a1;
      v8 = *v10++ == *a1++;
      --v11;
    }
    while ( v8 );
    v12 = (char)((!v7 && !v8) - v7);
    v13 = 0;
    v14 = v12 == 0;
    if ( v12 )
    {
      v15 = "server";
      v16 = 6LL;
      v17 = v5;
      do
      {
        if ( !v16 )
          break;
        v13 = (const unsigned __int8)*v15 < *v17;
        v14 = *v15++ == *v17++;
        --v16;
      }
      while ( v14 );
      if ( (!v13 && !v14) != v13 )
        goto LABEL_3;
      v18 = 2;
      v12 = 1;
    }
    else
    {
      v18 = 1;
    }
    *v3 = v12;
    *v4 = v18;
    result = (signed __int64)(v5 + 7);
  }
  else
  {
    *a2 = 0;
    result = (signed __int64)a1;
    *v4 = 2;
  }
  return result;
}

void __fastcall sub_A63B0(__int64 a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, int a7, int a8, __int64 a9)
{
  __int64 v9; // r14
  const char *v10; // r13
  const char *v11; // r12
  const char *v12; // rbp
  const char *v13; // rbx
  int v14; // eax
  int v15; // edx
  int v16; // er15
  int v17; // er15
  int v18; // ecx
  int v19; // ST10_4
  int v20; // eax
  int v21; // er15
  int v22; // edx
  int v23; // ST10_4
  int v24; // eax
  int v25; // er15
  int v26; // eax
  int v27; // ST10_4
  char *v28; // r15
  char *v29; // rdi
  __int64 *v30; // rdi
  int v31; // eax
  __int64 *v32; // rdi
  signed __int64 v33; // [rsp+10h] [rbp-48h]

  v9 = a1;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  v13 = a6;
  v14 = strlen(a2);
  v15 = 0;
  v16 = v14;
  if ( v10 )
    v15 = strlen(v10);
  v17 = v16 + 82;
  v18 = 0;
  if ( v11 )
  {
    v19 = v15;
    v20 = strlen(v11);
    v15 = v19;
    v18 = v20;
  }
  v21 = v15 + v17;
  v22 = 0;
  if ( v12 )
  {
    v23 = v18;
    v24 = strlen(v12);
    v18 = v23;
    v22 = v24;
  }
  v25 = v18 + v21;
  v26 = 0;
  if ( v13 )
  {
    v27 = v22;
    v26 = strlen(v13);
    v22 = v27;
  }
  v33 = v25 + v22 + v26;
  v28 = (char *)sub_2F450(v33, 1uLL, 0LL);
  *((_QWORD *)v28 + 8) = a9;
  *(_QWORD *)v28 = v28 + 72;
  v29 = stpcpy(v28 + 72, a2) + 1;
  if ( v10 )
  {
    *((_QWORD *)v28 + 1) = v29;
    v29 = stpcpy(v29, v10) + 1;
    if ( v11 )
      goto LABEL_11;
  }
  else
  {
    *((_QWORD *)v28 + 1) = 0LL;
    if ( v11 )
    {
LABEL_11:
      *((_QWORD *)v28 + 2) = v29;
      v29 = stpcpy(v29, v11) + 1;
      if ( v12 )
        goto LABEL_12;
LABEL_19:
      *((_QWORD *)v28 + 3) = 0LL;
      if ( v13 )
        goto LABEL_13;
      goto LABEL_20;
    }
  }
  *((_QWORD *)v28 + 2) = 0LL;
  if ( !v12 )
    goto LABEL_19;
LABEL_12:
  *((_QWORD *)v28 + 3) = v29;
  v29 = stpcpy(v29, v12) + 1;
  if ( v13 )
  {
LABEL_13:
    *((_QWORD *)v28 + 4) = v29;
    v29 = stpcpy(v29, v13) + 1;
    goto LABEL_14;
  }
LABEL_20:
  *((_QWORD *)v28 + 4) = 0LL;
LABEL_14:
  if ( v29 - v28 > v33 )
    __assert_fail("p - (char *)info <= totalsize", "unix/gtkfont.c", 0xBD5u, "unifontsel_add_entry");
  v30 = *(__int64 **)(v9 + 152);
  *((_DWORD *)v28 + 10) = a7;
  *((_DWORD *)v28 + 11) = a8;
  v31 = sub_9AFB0(v30);
  v32 = *(__int64 **)(v9 + 144);
  *((_DWORD *)v28 + 12) = v31;
  if ( (char *)sub_9AFD0(v32, (__int64)v28) == v28 )
    sub_9AFD0(*(__int64 **)(v9 + 152), (__int64)v28);
  else
    sub_2F4D0(v28);
}

signed __int64 __fastcall sub_A65E0(__int64 a1)
{
  __int64 v1; // rax

  v1 = gtk_widget_get_window(a1);
  gdk_window_invalidate_rect(v1, 0LL, 0LL);
  return 1LL;
}

void __fastcall sub_A6600(__int64 a1, __int64 a2)
{
  void **v2; // rbp
  void *v3; // r15
  __int64 (__fastcall *v4)(__int64, void *, _QWORD); // r14
  unsigned int v5; // ST28_4
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  void *v9; // r14
  void *v10; // r15
  __int64 (__fastcall *v11)(__int64, void *, _QWORD, _QWORD, _QWORD, _QWORD); // ST28_8
  __int64 v12; // rax
  unsigned int *v13; // rbx
  double v14; // xmm2_8
  double v15; // xmm0_8
  double v16; // xmm1_8
  double v17; // xmm2_8
  double v18; // xmm0_8
  double v19; // xmm1_8

  v2 = *(void ***)(a2 + 160);
  if ( !v2 )
  {
    v9 = 0LL;
    v13 = 0LL;
    if ( *(_DWORD *)a1 )
      goto LABEL_5;
    goto LABEL_9;
  }
  v3 = *v2;
  v4 = (__int64 (__fastcall *)(__int64, void *, _QWORD))*((_QWORD *)v2[8] + 8);
  v5 = *(_DWORD *)(a2 + 168);
  v6 = gtk_widget_get_type(a1, a2);
  v7 = v6;
  v8 = g_type_check_instance_cast(*(_QWORD *)(a2 + 192), v6);
  v9 = (void *)v4(v8, v3, v5);
  v10 = v9;
  if ( !v9 )
    v10 = *v2;
  v11 = *(__int64 (__fastcall **)(__int64, void *, _QWORD, _QWORD, _QWORD, _QWORD))v2[8];
  v12 = g_type_check_instance_cast(*(_QWORD *)(a2 + 192), v7);
  v13 = (unsigned int *)v11(v12, v10, 0LL, 0LL, 0LL, 0LL);
  if ( !*(_DWORD *)a1 )
  {
LABEL_9:
    v14 = (double)*(unsigned __int16 *)(a2 + 132) / 65535.0;
    v15 = (double)*(unsigned __int16 *)(a2 + 128) / 65535.0;
    v16 = (double)*(unsigned __int16 *)(a2 + 130) / 65535.0;
    cairo_set_source_rgb(*(_QWORD *)(a1 + 16));
    cairo_paint(*(_QWORD *)(a1 + 16));
    v17 = (double)*(unsigned __int16 *)(a2 + 120) / 65535.0;
    v18 = (double)*(unsigned __int16 *)(a2 + 116) / 65535.0;
    v19 = (double)*(unsigned __int16 *)(a2 + 118) / 65535.0;
    cairo_set_source_rgb(*(_QWORD *)(a1 + 16));
  }
LABEL_5:
  if ( v13 )
  {
    (*((void (__fastcall **)(__int64, unsigned int *, _QWORD, _QWORD, void **, signed __int64, _QWORD, _QWORD, _QWORD))v2[8]
     + 4))(
      a1,
      v13,
      0LL,
      v13[5],
      &off_F7CB8,
      41LL,
      0LL,
      0LL,
      v13[3]);
    (*((void (__fastcall **)(__int64, unsigned int *, _QWORD, _QWORD, void **, signed __int64, _QWORD, _QWORD, _QWORD))v2[8]
     + 4))(
      a1,
      v13,
      0LL,
      v13[5] + v13[4],
      &off_F7D60,
      41LL,
      0LL,
      0LL,
      v13[3]);
    (*((void (__fastcall **)(__int64, unsigned int *, _QWORD, _QWORD, void **, signed __int64, _QWORD, _QWORD, _QWORD))v2[8]
     + 4))(
      a1,
      v13,
      0LL,
      v13[5] + 2 * v13[4],
      &off_F7E08,
      42LL,
      0LL,
      0LL,
      v13[3]);
    (*((void (__fastcall **)(unsigned int *))v2[8] + 2))(v13);
  }
  sub_2F4D0(v9);
}

void __fastcall sub_A6840(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // [rsp+0h] [rbp-68h]
  __int64 v4; // [rsp+8h] [rbp-60h]
  __int64 v5; // [rsp+10h] [rbp-58h]
  unsigned __int64 v6; // [rsp+58h] [rbp-10h]

  v4 = a1;
  v5 = a2;
  v3 = 0;
  v6 = __readfsqword(0x28u);
  sub_A6600((__int64)&v3, a3);
  __readfsqword(0x28u);
}

unsigned __int64 __fastcall sub_A6890(__int64 a1, __int64 a2, signed int a3)
{
  signed int v3; // er12
  __int64 v4; // rbx
  __int64 v5; // rdi
  signed int v6; // ebp
  unsigned int v7; // er13
  unsigned int *v8; // r14
  __int64 v9; // r8
  __int64 v10; // rdi
  __int64 v11; // ST08_8
  const char *v13; // r15
  unsigned int i; // er14
  char v15; // [rsp+10h] [rbp-88h]
  char v16; // [rsp+30h] [rbp-68h]
  unsigned __int64 v17; // [rsp+58h] [rbp-40h]

  v3 = a3;
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 16);
  v17 = __readfsqword(0x28u);
  gtk_list_store_clear(v5, a2);
  if ( (signed int)a2 < v3 )
  {
    v6 = a2;
    v7 = 0;
    do
    {
      v8 = (unsigned int *)sub_9B010(*(__int64 **)(v4 + 152), v6);
      if ( !v8 )
        break;
      if ( ~*(_DWORD *)(v4 + 136) & v8[11] )
      {
        v8[15] = -1;
      }
      else
      {
        v9 = v8[10];
        if ( !(_DWORD)v9 )
        {
          if ( (_DWORD)a2 != v6 )
            __assert_fail("i == start", "unix/gtkfont.c", 0xA58u, "unifontsel_setup_sizelist");
          if ( v6 + 1 != v3 )
            __assert_fail("i+1 == end", "unix/gtkfont.c", 0xA59u, "unifontsel_setup_sizelist");
          v13 = "\n";
          for ( i = 10; ; i = *(_DWORD *)v13 )
          {
            __sprintf_chk(&v16, 1LL, 40LL, "%d", i);
            v13 += 4;
            gtk_list_store_append(*(_QWORD *)(v4 + 16), &v15);
            gtk_list_store_set(*(_QWORD *)(v4 + 16), &v15, 0LL, &v16, 1LL);
            if ( v13 == (const char *)&unk_F7FAC )
              break;
          }
          return __readfsqword(0x28u) ^ v17;
        }
        __sprintf_chk(&v16, 1LL, 40LL, "%d", v9);
        v10 = *(_QWORD *)(v4 + 16);
        v8[15] = v7++;
        gtk_list_store_append(v10, &v15);
        v11 = v8[10];
        gtk_list_store_set(*(_QWORD *)(v4 + 16), &v15, 0LL, &v16, 1LL);
      }
      ++v6;
    }
    while ( v3 != v6 );
  }
  return __readfsqword(0x28u) ^ v17;
}

__int64 __fastcall sub_A6AB0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  signed __int64 v3; // rbx
  __int64 v4; // r13
  __int64 v5; // rax
  _BOOL4 v6; // er14
  __int64 v7; // rax

  result = *(unsigned int *)(a1 + 88);
  if ( (signed int)result > 0 )
  {
    v3 = 1LL;
    v4 = gtk_toggle_button_get_type(a1, a2);
    do
    {
      v5 = g_type_check_instance_cast(*(_QWORD *)(a1 + 8 * v3 + 48), 80LL);
      v6 = ((unsigned int)g_object_get_data(v5, "user-data") & *(_DWORD *)(a1 + 136)) != 0;
      v7 = g_type_check_instance_cast(*(_QWORD *)(a1 + 8 * v3 + 48), v4);
      gtk_toggle_button_set_active(v7, (unsigned int)v6);
      result = (unsigned int)v3++;
    }
    while ( *(_DWORD *)(a1 + 88) > (signed int)result );
  }
  return result;
}

__int64 __fastcall sub_A6B40(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( a1 )
    result = g_ascii_strcasecmp(a1, a2);
  else
    result = 0LL;
  return result;
}

__int64 __fastcall sub_A6B60(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // rbp
  __int64 v6; // rbx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  bool v10; // sf
  unsigned __int8 v11; // of
  __int64 v12; // rsi
  __int64 v13; // rdi
  __int64 v14; // rsi
  __int64 v15; // rdi
  __int64 v16; // rsi
  __int64 v17; // rdi
  int v18; // edx
  int v19; // edx

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 8);
  result = (v2 == 0) - (unsigned int)(v3 == 0);
  if ( (v2 == 0) == (v3 == 0) )
  {
    v5 = a2;
    v6 = a1;
    result = sub_A6B40(v3, v2);
    if ( !(_DWORD)result )
    {
      v7 = *(_DWORD *)(a2 + 44);
      if ( ((unsigned __int8)v7 ^ (unsigned __int8)*(_DWORD *)(a1 + 44)) & 7 )
      {
        v8 = *(_DWORD *)(a1 + 44) & 7;
        v9 = *(_DWORD *)(a2 + 44) & 7;
        v11 = __OFSUB__(v8, v9);
        v10 = v8 - v9 < 0;
LABEL_5:
        if ( v10 ^ v11 )
          result = 0xFFFFFFFFLL;
        else
          result = 1LL;
        return result;
      }
      v12 = *(_QWORD *)(a2 + 16);
      v13 = *(_QWORD *)(a1 + 16);
      result = (v12 == 0) - (unsigned int)(v13 == 0);
      if ( (v12 == 0) == (v13 == 0) )
      {
        result = sub_A6B40(v13, v12);
        if ( !(_DWORD)result )
        {
          v14 = *(_QWORD *)(v5 + 32);
          v15 = *(_QWORD *)(v6 + 32);
          result = (v14 == 0) - (unsigned int)(v15 == 0);
          if ( (v14 == 0) == (v15 == 0) )
          {
            result = sub_A6B40(v15, v14);
            if ( !(_DWORD)result )
            {
              v16 = *(_QWORD *)(v5 + 24);
              v17 = *(_QWORD *)(v6 + 24);
              result = (v16 == 0) - (unsigned int)(v17 == 0);
              if ( (v16 == 0) == (v17 == 0) )
              {
                result = sub_A6B40(v17, v16);
                if ( !(_DWORD)result )
                {
                  v18 = *(_DWORD *)(v5 + 40);
                  v11 = __OFSUB__(*(_DWORD *)(v6 + 40), v18);
                  v10 = *(_DWORD *)(v6 + 40) - v18 < 0;
                  if ( *(_DWORD *)(v6 + 40) != v18 )
                    goto LABEL_5;
                  v19 = *(_DWORD *)(v5 + 48);
                  v11 = __OFSUB__(*(_DWORD *)(v6 + 48), v19);
                  v10 = *(_DWORD *)(v6 + 48) - v19 < 0;
                  if ( *(_DWORD *)(v6 + 48) != v19 )
                    goto LABEL_5;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

__int64 __fastcall sub_A6C60(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // edx

  result = (*(_QWORD *)a2 == 0LL) - (unsigned int)(*(_QWORD *)a1 == 0LL);
  if ( (*(_QWORD *)a2 == 0LL) == (*(_QWORD *)a1 == 0LL) )
  {
    result = sub_A6B40(*(_QWORD *)a1, *(_QWORD *)a2);
    if ( !(_DWORD)result )
    {
      v3 = *(_DWORD *)(a2 + 44);
      result = ((unsigned __int8)v3 ^ (unsigned __int8)*(_DWORD *)(a1 + 44)) & 7;
      if ( ((unsigned __int8)v3 ^ (unsigned __int8)*(_DWORD *)(a1 + 44)) & 7 )
        result = 2 * (unsigned int)((*(_DWORD *)(a1 + 44) & 7) >= (*(_DWORD *)(a2 + 44) & 7)) - 1;
    }
  }
  return result;
}

__int64 __fastcall sub_A6CD0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // edx

  result = (*(_QWORD *)a2 == 0LL) - (unsigned int)(*(_QWORD *)a1 == 0LL);
  if ( (*(_QWORD *)a2 == 0LL) == (*(_QWORD *)a1 == 0LL) )
  {
    result = sub_A6B40(*(_QWORD *)a1, *(_QWORD *)a2);
    if ( !(_DWORD)result )
    {
      v3 = *(_DWORD *)(a2 + 44);
      result = ((unsigned __int8)v3 ^ (unsigned __int8)*(_DWORD *)(a1 + 8)) & 7;
      if ( ((unsigned __int8)v3 ^ (unsigned __int8)*(_DWORD *)(a1 + 8)) & 7 )
        result = 2 * (unsigned int)((*(_DWORD *)(a1 + 8) & 7) >= (*(_DWORD *)(a2 + 44) & 7)) - 1;
    }
  }
  return result;
}

void __fastcall sub_A6D40(__int64 a1, __int64 a2, Display *a3, int a4, int a5, __int64 a6, int a7, int a8)
{
  signed __int64 v8; // rax
  int v9; // er12
  const XChar2b *v10; // rbx
  signed __int64 v11; // r13
  double v12; // xmm0_8
  double v13; // xmm1_8
  int v14; // ebp
  int v15; // er11
  int v16; // ebp
  Display *v17; // [rsp+8h] [rbp-50h]
  int v18; // [rsp+1Ch] [rbp-3Ch]

  v17 = a3;
  v18 = a5;
  if ( a8 > 0 )
  {
    v8 = 2LL * a7;
    v9 = a4;
    v10 = (const XChar2b *)(a6 + v8);
    v11 = v8 + a6 + 2LL * (unsigned int)(a8 - 1) + 2;
    do
    {
      v14 = v10->byte1;
      if ( sub_A3E20(*(_QWORD *)a2, v10->byte1, v10->byte2) )
      {
        v16 = v15 + (v14 << 8);
        if ( *(_DWORD *)(a2 + 24) > v16 && *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16LL * v16)
          || (XDrawImageString16(
                v17,
                *(_QWORD *)(a2 + 32),
                *(GC *)(a2 + 40),
                *(_DWORD *)(a2 + 56),
                *(_DWORD *)(a2 + 60),
                v10,
                1),
              sub_A5560(v17, a2, v16),
              *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16LL * v16)) )
        {
          v12 = (double)(v9 - *(_DWORD *)(a2 + 56));
          v13 = (double)(v18 - *(_DWORD *)(a2 + 60));
          cairo_mask_surface(*(_QWORD *)(a1 + 16));
        }
        v9 += XTextWidth16(*(XFontStruct **)a2, v10, 1);
      }
      ++v10;
    }
    while ( (const XChar2b *)v11 != v10 );
  }
}

unsigned __int64 __fastcall sub_A6E80(__int64 a1, _QWORD *a2, Display *a3)
{
  _QWORD *v3; // rbx
  Display *v4; // r12
  __int64 v5; // rax
  __int64 v6; // rax
  signed __int64 v7; // rbp
  int v8; // ecx
  int v9; // eax
  int v10; // esi
  int v11; // edx
  int v12; // eax
  unsigned int v13; // er14
  __int64 v14; // rdi
  unsigned int v15; // er15
  __int64 v16; // rax
  Drawable v17; // rax
  Drawable v18; // rax
  Screen *v19; // rdx
  signed __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v24; // [rsp+0h] [rbp-C8h]
  __int64 v25; // [rsp+10h] [rbp-B8h]
  __int64 v26; // [rsp+18h] [rbp-B0h]
  __int64 v27; // [rsp+58h] [rbp-70h]
  unsigned __int64 v28; // [rsp+88h] [rbp-40h]

  v28 = __readfsqword(0x28u);
  if ( !a2[4] )
  {
    v3 = a2;
    v4 = a3;
    v5 = gtk_widget_get_window(*(_QWORD *)(a1 + 8));
    v6 = gdk_window_get_screen(v5);
    v7 = (signed __int64)(signed int)gdk_x11_screen_get_screen_number(v6) << 7;
    v8 = *(signed __int16 *)(*a2 + 74LL);
    v9 = *(signed __int16 *)(*a2 + 56LL);
    v10 = *(signed __int16 *)(*a2 + 70LL);
    v11 = *(signed __int16 *)(*v3 + 76LL);
    *((_DWORD *)v3 + 15) = v8;
    *((_DWORD *)v3 + 12) = v10 - v9;
    *((_DWORD *)v3 + 13) = v8 + v11;
    *((_DWORD *)v3 + 14) = -v9;
    v12 = cairo_format_stride_for_width(3LL);
    v13 = *((_DWORD *)v3 + 13);
    *((_DWORD *)v3 + 16) = v12;
    v14 = *(_QWORD *)(a1 + 8);
    v15 = *((_DWORD *)v3 + 12);
    *((_DWORD *)v3 + 18) = 0;
    *((_DWORD *)v3 + 17) = v13 * v12;
    v16 = gtk_widget_get_window(v14);
    v17 = gdk_x11_window_get_xid(v16);
    v18 = XCreatePixmap(v4, v17, v15, v13, 1u);
    v19 = v4->screens;
    v3[4] = v18;
    v20 = (signed __int64)v19 + v7;
    v21 = *(_QWORD *)(v20 + 88);
    v26 = *(_QWORD *)(v20 + 96);
    v22 = *v3;
    v25 = v21;
    v27 = *(_QWORD *)(v22 + 8);
    v3[5] = XCreateGC(v4, v18, 0x400CuLL, (XGCValues *)&v24);
  }
  return __readfsqword(0x28u) ^ v28;
}

__int64 __fastcall sub_A6FC0(__int64 a1, void **a2, unsigned int *a3, unsigned int a4, __int64 a5, unsigned int i)
{
  unsigned int *v6; // rax
  __int64 result; // rax
  signed __int64 v8; // rbx
  unsigned int *v9; // rbx
  unsigned int v10; // ST0C_4
  __int64 v11; // ST00_8
  unsigned int v12; // er13
  unsigned int v13; // ST08_4
  __int64 v14; // rdx
  char v15; // [rsp+10h] [rbp-48h]
  unsigned int v16; // [rsp+18h] [rbp-40h]
  unsigned __int64 v17; // [rsp+28h] [rbp-30h]

  v17 = __readfsqword(0x28u);
  v6 = (unsigned int *)*a2;
  if ( *a3 <= a4 )
  {
    v12 = a4 + 256;
    v9 = a3;
    v10 = i;
    v11 = a5;
    LOBYTE(v12) = 0;
    v13 = a4;
    v6 = (unsigned int *)sub_2F490(*a2, v12, 4uLL);
    v14 = *v9;
    *a2 = v6;
    a4 = v13;
    a5 = v11;
    for ( i = v10; v12 > (unsigned int)v14; v14 = *v9 )
    {
      *v9 = v14 + 1;
      v6[v14] = -1;
    }
  }
  result = v6[a4];
  v8 = 4LL * (signed int)a4;
  if ( (signed int)result < 0 )
  {
    pango_layout_set_text(a1, a5, i);
    pango_layout_get_extents(a1, 0LL, &v15);
    result = v16;
    *(_DWORD *)((char *)*a2 + v8) = v16;
  }
  return result;
}

unsigned __int64 __fastcall sub_A70C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbp
  __int64 v6; // rax
  int v8; // [rsp+0h] [rbp-78h]
  __int64 v9; // [rsp+8h] [rbp-70h]
  __int64 v10; // [rsp+10h] [rbp-68h]
  __int64 v11; // [rsp+48h] [rbp-30h]
  __int64 v12; // [rsp+50h] [rbp-28h]
  unsigned __int64 v13; // [rsp+58h] [rbp-20h]

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 96);
  v13 = __readfsqword(0x28u);
  if ( gtk_widget_get_window(v3) )
  {
    v8 = 0;
    v4 = gtk_widget_get_type(v3, a2);
    v9 = g_type_check_instance_cast(*(_QWORD *)(v2 + 96), v4);
    v11 = gtk_widget_get_window(v9);
    v5 = gdk_window_get_clip_region(v11, v4);
    v12 = gdk_window_begin_draw_frame(v11, v5);
    v10 = gdk_drawing_context_get_cairo_context(v12);
    cairo_region_destroy(v5);
    sub_A6600((__int64)&v8, v2);
    if ( !v8 )
      gdk_window_end_draw_frame(v11, v12);
    v6 = gtk_widget_get_window(*(_QWORD *)(v2 + 96));
    gdk_window_invalidate_rect(v6, 0LL, 0LL);
  }
  return __readfsqword(0x28u) ^ v13;
}

unsigned __int64 __fastcall sub_A71A0(__int64 *a1, __int64 a2)
{
  unsigned int v2; // er15
  _QWORD *v3; // r13
  __int64 v4; // rbp
  int v5; // er14
  __int64 v6; // rdi
  __int64 v7; // rsi
  char *v8; // rsi
  __int64 v9; // rbx
  __int64 v10; // rax
  unsigned __int64 result; // rax
  __int64 v12; // rdi
  int v13; // [rsp+4h] [rbp-74h]
  char v14; // [rsp+10h] [rbp-68h]
  unsigned __int64 v15; // [rsp+38h] [rbp-40h]

  v2 = 0;
  v3 = a1;
  v4 = 0LL;
  v5 = 0;
  *((_BYTE *)a1 + 176) = 1;
  v6 = *a1;
  v15 = __readfsqword(0x28u);
  gtk_list_store_clear(v6, a2);
  v13 = -1;
  while ( 1 )
  {
    v8 = (char *)v2;
    v9 = sub_9B010((__int64 *)v3[19], v2);
    if ( !v9 )
      break;
    if ( ~*((_DWORD *)v3 + 34) & *(_DWORD *)(v9 + 44) )
    {
      *(_DWORD *)(v9 + 52) = -1;
    }
    else
    {
      v7 = *(_QWORD *)(v9 + 8);
      if ( (v7 == 0) != (v4 == 0) || (unsigned int)sub_A6B40(v4, v7) || (*(_DWORD *)(v9 + 44) & 7) != v13 )
      {
        if ( v4 )
        {
          ++v5;
          gtk_list_store_append(*v3, &v14);
          gtk_list_store_set(*v3, &v14, 0LL, v4, 1LL);
        }
        v4 = *(_QWORD *)(v9 + 8);
        v13 = *(_DWORD *)(v9 + 44) & 7;
      }
      *(_DWORD *)(v9 + 52) = v5;
    }
    ++v2;
  }
  if ( v4 )
  {
    gtk_list_store_append(*v3, &v14);
    v8 = &v14;
    gtk_list_store_set(*v3, &v14, 0LL, v4, 1LL);
  }
  v10 = v3[20];
  if ( v10 && *(_DWORD *)(v10 + 52) < 0 )
  {
    v12 = v3[1];
    v3[20] = 0LL;
    gtk_list_store_clear(v12, v8);
    gtk_list_store_clear(v3[2], v8);
    gtk_widget_set_sensitive(v3[25], 0LL);
    gtk_widget_set_sensitive(v3[5], 0LL);
    sub_A70C0((__int64)v3, 0LL);
  }
  result = __readfsqword(0x28u) ^ v15;
  *((_BYTE *)v3 + 176) = 0;
  return result;
}

unsigned __int64 __fastcall sub_A73B0(__int64 a1, __int64 a2)
{
  int v2; // er12
  __int64 v3; // rax
  unsigned int v4; // eax
  int v5; // edx
  unsigned __int64 result; // rax

  v2 = gtk_toggle_button_get_active(a1, a2);
  v3 = g_type_check_instance_cast(a1, 80LL);
  v4 = g_object_get_data(v3, "user-data");
  v5 = *(_DWORD *)(a2 + 136);
  if ( v2 )
  {
    result = v5 | v4;
    if ( (_DWORD)result == v5 )
      return result;
    goto LABEL_3;
  }
  result = v5 & ~v4;
  if ( (_DWORD)result != v5 )
  {
LABEL_3:
    *(_DWORD *)(a2 + 136) = result;
    result = sub_A71A0((__int64 *)a2, (__int64)"user-data");
  }
  return result;
}

__int64 __fastcall sub_A7420(__int64 a1, __int64 a2, unsigned int a3, signed int a4, char a5)
{
  unsigned int v5; // er13
  __int64 v6; // rbp
  _QWORD *v7; // rbx
  __int64 *v8; // rdi
  __int64 v9; // rdi
  __int64 v10; // r14
  __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // r15
  __int64 v17; // rax
  __int64 *v18; // rdi
  __int64 v19; // rsi
  __int64 v20; // rdi
  __int64 v21; // r14
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rdi
  __int64 v28; // r13
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  char *v33; // rsi
  __int64 v34; // rdi
  _BOOL4 v35; // ebp
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rsi
  bool v39; // zf
  __int64 result; // rax
  unsigned __int64 v41; // rt1
  __int64 v42; // rbp
  signed int i; // eax
  __int64 v44; // r15
  __int64 v45; // rax
  __int64 v46; // rax
  int v47; // eax
  int v48; // edx
  __int64 v49; // rax
  signed int v50; // er14
  int v51; // ST50_4
  int v52; // eax
  __int64 v53; // r12
  _QWORD *v54; // r15
  signed int v55; // ebp
  int v56; // er13
  __int64 v57; // rbx
  __int64 v58; // rsi
  signed int v59; // [rsp+Ch] [rbp-10Ch]
  __int64 v60; // [rsp+10h] [rbp-108h]
  char v61; // [rsp+27h] [rbp-F1h]
  __int64 v62; // [rsp+38h] [rbp-E0h]
  __int64 v63; // [rsp+40h] [rbp-D8h]
  __int64 v64; // [rsp+48h] [rbp-D0h]
  unsigned int v65; // [rsp+54h] [rbp-C4h]
  int v66; // [rsp+64h] [rbp-B4h]
  unsigned int v67; // [rsp+68h] [rbp-B0h]
  int v68; // [rsp+6Ch] [rbp-ACh]
  char v69; // [rsp+70h] [rbp-A8h]
  char v70; // [rsp+90h] [rbp-88h]
  char v71; // [rsp+B0h] [rbp-68h]
  unsigned __int64 v72; // [rsp+D8h] [rbp-40h]

  v5 = a3;
  v6 = a2;
  v7 = (_QWORD *)a1;
  *(_BYTE *)(a1 + 176) = 1;
  *(_QWORD *)(a1 + 160) = a2;
  v72 = __readfsqword(0x28u);
  v59 = a4;
  *(_DWORD *)(a1 + 168) = a3;
  if ( a5 )
    *(_DWORD *)(a1 + 172) = a3;
  gtk_widget_set_sensitive(*(_QWORD *)(a1 + 200), 1LL);
  v8 = *(__int64 **)(a1 + 152);
  v66 = -1;
  sub_9B3F0(v8, a2, 0LL, &v66);
  if ( v66 < 0 )
    __assert_fail("index >= 0", "unix/gtkfont.c", 0xB25u, "unifontsel_select_font");
  if ( !v59 )
  {
    v47 = *((_DWORD *)v7 + 34);
    v48 = v47 | *(_DWORD *)(a2 + 44);
    if ( v47 != v48 )
    {
      *((_DWORD *)v7 + 34) = v48;
      sub_A6AB0((__int64)v7, a2);
      sub_A71A0(v7, a2);
    }
  }
  v9 = *(unsigned int *)(a2 + 52);
  if ( (signed int)v9 < 0 )
    __assert_fail("info->familyindex >= 0", "unix/gtkfont.c", 0xB35u, "unifontsel_select_font");
  v10 = gtk_tree_path_new_from_indices(v9, 0xFFFFFFFFLL);
  v11 = gtk_tree_view_get_type(v9, 0xFFFFFFFFLL);
  v12 = g_type_check_instance_cast(v7[3], v11);
  v13 = gtk_tree_view_get_selection(v12, v11);
  gtk_tree_selection_select_path(v13, v10);
  v14 = g_type_check_instance_cast(v7[3], v11);
  gtk_tree_view_scroll_to_cell(v14, v10, 0LL, 0LL);
  v15 = gtk_tree_model_get_type(v14);
  v16 = v15;
  v17 = g_type_check_instance_cast(*v7, v15);
  if ( !(unsigned int)gtk_tree_model_get_iter(v17, &v69, v10) )
    __assert_fail("success", "unix/gtkfont.c", 0xB3Eu, "unifontsel_select_font");
  gtk_tree_path_free(v10, &v69);
  v18 = (__int64 *)g_type_check_instance_cast(*v7, v16);
  v19 = (__int64)&v69;
  gtk_tree_model_get(v18, &v69, 1LL, &v67, 2LL);
  if ( v59 <= 1 )
  {
    v18 = (__int64 *)v7[1];
    v50 = v67;
    v51 = v68;
    gtk_list_store_clear(v18, &v69);
    v52 = v51;
    if ( v51 >= v50 )
    {
      v19 = 0LL;
      v62 = v11;
      v63 = v16;
      v53 = 0LL;
      v64 = v6;
      v65 = v5;
      v54 = v7;
      v60 = 0LL;
      v61 = 0;
      v55 = v52;
      v56 = 0;
      while ( v55 != v50 )
      {
        v18 = (__int64 *)v54[19];
        v19 = (unsigned int)v50;
        v57 = sub_9B010(v18, v50);
        if ( !v57 )
          break;
        if ( ~*((_DWORD *)v54 + 34) & *(_DWORD *)(v57 + 44) )
        {
          *(_DWORD *)(v57 + 56) = -1;
        }
        else
        {
          if ( !v61
            || (v58 = *(_QWORD *)(v57 + 16), (v58 == 0) != (v53 == 0))
            || (v18 = (__int64 *)v53, (unsigned int)sub_A6B40(v53, v58))
            || (v19 = *(_QWORD *)(v57 + 24), (v19 == 0) != (v60 == 0))
            || (v18 = (__int64 *)v60, (unsigned int)sub_A6B40(v60, v19)) )
          {
            if ( v60 )
            {
              ++v56;
              gtk_list_store_append(v54[1], &v70);
              v18 = (__int64 *)v54[1];
              gtk_list_store_set(v18, &v70, 0LL, v60, 1LL);
            }
            v19 = *(_QWORD *)(v57 + 16);
            if ( v19 )
            {
              if ( !v53 || (v18 = (__int64 *)v53, (unsigned int)sub_A6B40(v53, v19)) )
              {
                ++v56;
                gtk_list_store_append(v54[1], &v70);
                v18 = (__int64 *)v54[1];
                v19 = (__int64)&v70;
                gtk_list_store_set(v18, &v70, 0LL, *(_QWORD *)(v57 + 16), 1LL);
                v53 = *(_QWORD *)(v57 + 16);
              }
              else
              {
                v53 = *(_QWORD *)(v57 + 16);
              }
            }
            else
            {
              v53 = 0LL;
            }
            v60 = *(_QWORD *)(v57 + 24);
          }
          *(_DWORD *)(v57 + 56) = v56;
          v61 = 1;
        }
        if ( v55 < ++v50 )
        {
          v7 = v54;
          v11 = v62;
          v16 = v63;
          v6 = v64;
          v5 = v65;
          goto LABEL_8;
        }
      }
      v7 = v54;
      v11 = v62;
      v16 = v63;
      v6 = v64;
      v5 = v65;
      if ( v60 )
      {
        gtk_list_store_append(v7[1], &v70);
        v18 = (__int64 *)v7[1];
        v19 = (__int64)&v70;
        gtk_list_store_set(v18, &v70, 0LL, v60, 1LL);
      }
    }
  }
LABEL_8:
  if ( *(_QWORD *)(v6 + 24) )
  {
    v20 = *(unsigned int *)(v6 + 56);
    if ( (signed int)v20 < 0 )
      goto LABEL_55;
    v21 = gtk_tree_path_new_from_indices(v20, 0xFFFFFFFFLL);
    v22 = g_type_check_instance_cast(v7[4], v11);
    v23 = gtk_tree_view_get_selection(v22, v11);
    gtk_tree_selection_select_path(v23, v21);
    v24 = g_type_check_instance_cast(v7[4], v11);
    gtk_tree_view_scroll_to_cell(v24, v21, 0LL, 0LL);
    v25 = g_type_check_instance_cast(v7[1], v16);
    gtk_tree_model_get_iter(v25, &v69, v21);
    gtk_tree_path_free(v21, &v69);
    v26 = g_type_check_instance_cast(v7[1], v16);
    gtk_tree_model_get(v26, &v69, 1LL, &v67, 2LL);
    if ( v59 == 3 )
    {
      if ( *(_DWORD *)(v6 + 40) )
      {
LABEL_12:
        v27 = *(unsigned int *)(v6 + 60);
        if ( (signed int)v27 < 0 )
          __assert_fail("info->sizeindex >= 0", "unix/gtkfont.c", 0xB64u, "unifontsel_select_font");
        v28 = gtk_tree_path_new_from_indices(v27, 0xFFFFFFFFLL);
        v29 = g_type_check_instance_cast(v7[6], v11);
        v30 = gtk_tree_view_get_selection(v29, v11);
        gtk_tree_selection_select_path(v30, v28);
        v31 = g_type_check_instance_cast(v7[6], v11);
        gtk_tree_view_scroll_to_cell(v31, v28, 0LL, 0LL);
        gtk_tree_path_free(v28, v28);
        v5 = *(_DWORD *)(v6 + 40);
LABEL_14:
        __sprintf_chk(&v71, 1LL, 40LL, "%d", v5);
        v32 = gtk_entry_get_type(&v71, 1LL);
        v33 = &v71;
        v34 = g_type_check_instance_cast(v7[5], v32);
        gtk_entry_set_text(v34, &v71);
        goto LABEL_15;
      }
    }
    else
    {
      sub_A6890((__int64)v7, v67, v68);
      if ( *(_DWORD *)(v6 + 40) )
        goto LABEL_12;
    }
    v42 = 0LL;
    for ( i = 10; ; i = *(_DWORD *)&asc_F7F90[4 * v42] )
    {
      if ( i == v5 )
      {
        v44 = gtk_tree_path_new_from_indices((unsigned int)v42, 0xFFFFFFFFLL);
        v45 = g_type_check_instance_cast(v7[6], v11);
        gtk_tree_view_set_cursor(v45, v44, 0LL, 0LL);
        v46 = g_type_check_instance_cast(v7[6], v11);
        gtk_tree_view_scroll_to_cell(v46, v44, 0LL, 0LL);
        gtk_tree_path_free(v44, v44);
      }
      if ( ++v42 == 7 )
        break;
    }
    goto LABEL_14;
  }
  if ( v59 != 3 )
  {
    v19 = 0LL;
    v18 = v7;
    sub_A6890((__int64)v7, 0LL, 0);
  }
  v49 = gtk_entry_get_type(v18, v19);
  v33 = &locale;
  v34 = g_type_check_instance_cast(v7[5], v49);
  gtk_entry_set_text(v34, &locale);
LABEL_15:
  v35 = *(_DWORD *)(v7[20] + 40LL) == 0;
  v36 = gtk_editable_get_type(v34, v33);
  v37 = g_type_check_instance_cast(v7[5], v36);
  gtk_editable_set_editable(v37, (unsigned int)v35);
  v38 = *(_DWORD *)(v7[20] + 40LL) == 0;
  gtk_widget_set_sensitive(v7[5], v38);
  sub_A70C0((__int64)v7, v38);
  v41 = __readfsqword(0x28u);
  result = v41 ^ v72;
  v39 = v41 == v72;
  *((_BYTE *)v7 + 176) = 0;
  if ( !v39 )
LABEL_55:
    __assert_fail("info->styleindex >= 0", "unix/gtkfont.c", 0xB4Du, "unifontsel_select_font");
  return result;
}

unsigned __int64 __fastcall sub_A7C50(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  unsigned int v4; // edx
  int v5; // [rsp+0h] [rbp-58h]
  unsigned int v6; // [rsp+4h] [rbp-54h]
  __int64 v7; // [rsp+8h] [rbp-50h]
  char v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( !*(_BYTE *)(a2 + 176) )
  {
    if ( (unsigned int)gtk_tree_selection_get_selected(a1, &v7, &v8) )
    {
      gtk_tree_model_get(v7, &v8, 1LL, &v5, 2LL);
      v3 = sub_9B010(*(__int64 **)(a2 + 152), v5);
      if ( v3 )
      {
        v4 = *(_DWORD *)(v3 + 40);
        if ( !v4 )
          v4 = v6;
        sub_A7420(a2, v3, v4, 3, 1);
      }
    }
  }
  return __readfsqword(0x28u) ^ v9;
}

unsigned __int64 __fastcall sub_A7D20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v5; // rbx
  __int64 v6; // rax
  __int64 v7; // r13
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 *v10; // rdi
  __int64 v11; // rsi
  _QWORD *v12; // rax
  _QWORD *v13; // rbp
  __int64 v14; // r13
  __int64 (__fastcall *v15)(__int64, __int64, unsigned int *, int *, signed __int64); // r12
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 *v19; // rdi
  void *v20; // r13
  __int64 v21; // r12
  unsigned int v22; // edx
  unsigned int v23; // [rsp+4h] [rbp-74h]
  unsigned int v24; // [rsp+8h] [rbp-70h]
  int v25; // [rsp+Ch] [rbp-6Ch]
  __int64 v26; // [rsp+10h] [rbp-68h]
  int v27; // [rsp+18h] [rbp-60h]
  char v28; // [rsp+20h] [rbp-58h]
  unsigned __int64 v29; // [rsp+48h] [rbp-30h]

  v29 = __readfsqword(0x28u);
  if ( !*(_BYTE *)(a4 + 176) )
  {
    v5 = (_QWORD *)a4;
    v6 = gtk_tree_model_get_type(a1);
    v7 = v6;
    v8 = g_type_check_instance_cast(*v5, v6);
    gtk_tree_model_get_iter(v8, &v28, a2);
    v9 = g_type_check_instance_cast(*v5, v7);
    gtk_tree_model_get(v9, &v28, 1LL, &v23, 0xFFFFFFFFLL);
    v10 = (__int64 *)v5[19];
    v11 = v23;
    v12 = (_QWORD *)sub_9B010(v10, v23);
    v13 = v12;
    if ( v12 )
    {
      v14 = *v12;
      v15 = *(__int64 (__fastcall **)(__int64, __int64, unsigned int *, int *, signed __int64))(v12[8] + 56LL);
      v16 = gtk_widget_get_type(v10, v11);
      v17 = g_type_check_instance_cast(v5[24], v16);
      v18 = v15(v17, v14, &v24, &v25, 1LL);
      v19 = (__int64 *)v5[18];
      v20 = (void *)v18;
      v26 = v18;
      v27 = v25;
      v21 = sub_9B3D0(v19, (__int64)&v26, (__int64 (__fastcall *)(__int64))sub_A6CD0);
      sub_2F4D0(v20);
      if ( v13 != (_QWORD *)v21 )
      {
        if ( v21 )
        {
          v22 = *(_DWORD *)(v21 + 40);
          if ( !v22 )
            v22 = v24;
          sub_A7420((__int64)v5, v21, v22, 1, 1);
        }
      }
    }
  }
  return __readfsqword(0x28u) ^ v29;
}

__int64 __fastcall sub_A7E90(__int64 **a1, __int32 *a2, const __m128i *a3)
{
  __int64 **v3; // rbp
  __int64 *v4; // rdi
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __int32 v7; // eax
  __int64 v8; // rbx
  __int64 v9; // rbp
  __int64 *v11; // rdi
  int v12; // [rsp+Ch] [rbp-7Ch]
  __m128i v13; // [rsp+10h] [rbp-78h]
  __m128i v14; // [rsp+20h] [rbp-68h]
  __m128i v15; // [rsp+30h] [rbp-58h]
  __m128i v16; // [rsp+40h] [rbp-48h]
  __int64 v17; // [rsp+50h] [rbp-38h]
  unsigned __int64 v18; // [rsp+58h] [rbp-30h]

  v3 = a1;
  v4 = *a1;
  v5 = _mm_loadu_si128(a3);
  v18 = __readfsqword(0x28u);
  v13 = v5;
  v6 = _mm_loadu_si128(a3 + 1);
  v17 = a3[4].m128i_i64[0];
  v7 = *a2;
  v14 = v6;
  v15 = _mm_loadu_si128(a3 + 2);
  v15.m128i_i32[2] = v7;
  v16 = _mm_loadu_si128(a3 + 3);
  v8 = sub_9B220(v4, (__int64)&v13, 0LL, 2, &v12);
  if ( v8 )
  {
    v9 = sub_9B010(*v3, v12 + 1);
    if ( !(unsigned int)sub_A6B60((__int64)&v13, v8) )
      return v8;
    v15.m128i_i32[2] = *(_DWORD *)(v8 + 40);
    v16.m128i_i32[0] = *(_DWORD *)(v8 + 48);
    if ( (unsigned int)sub_A6B60((__int64)&v13, v8) )
      v8 = 0LL;
  }
  else
  {
    v11 = *v3;
    v12 = -1;
    v9 = sub_9B010(v11, 0);
  }
  if ( v9 )
  {
    v15.m128i_i32[2] = *(_DWORD *)(v9 + 40);
    v16.m128i_i32[0] = *(_DWORD *)(v9 + 48);
    if ( !(unsigned int)sub_A6B60((__int64)&v13, v9) )
    {
      if ( v8 )
      {
        if ( *(_DWORD *)(v9 + 40) - *a2 <= *a2 - *(_DWORD *)(v8 + 40) )
          v8 = v9;
      }
      else
      {
        v8 = v9;
      }
    }
  }
  return v8;
}

unsigned __int64 __fastcall sub_A7FE0(__int64 a1, __int64 a2)
{
  const __m128i *v3; // rax
  __int64 v4; // rax
  unsigned int v5; // edx
  int v6; // [rsp+4h] [rbp-54h]
  __int64 v7; // [rsp+8h] [rbp-50h]
  char v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( !*(_BYTE *)(a2 + 176) )
  {
    if ( (unsigned int)gtk_tree_selection_get_selected(a1, &v7, &v8) )
    {
      gtk_tree_model_get(v7, &v8, 1LL, &v6, 0xFFFFFFFFLL);
      if ( v6 >= 0 )
      {
        v3 = (const __m128i *)sub_9B010(*(__int64 **)(a2 + 152), v6);
        if ( v3 )
        {
          v4 = sub_A7E90((__int64 **)(a2 + 152), (__int32 *)(a2 + 172), v3);
          if ( v4 )
          {
            v5 = *(_DWORD *)(v4 + 40);
            if ( !v5 )
            {
              v5 = *(_DWORD *)(a2 + 172);
              *(_DWORD *)(a2 + 168) = v5;
            }
            sub_A7420(a2, v4, v5, 2, 0);
          }
        }
      }
    }
  }
  return __readfsqword(0x28u) ^ v9;
}

unsigned __int64 __fastcall sub_A80C0(__int64 a1, __int64 a2)
{
  const __m128i *v3; // rax
  __int64 v4; // rax
  unsigned int v5; // edx
  int v6; // [rsp+4h] [rbp-54h]
  __int64 v7; // [rsp+8h] [rbp-50h]
  char v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( !*(_BYTE *)(a2 + 176) )
  {
    if ( (unsigned int)gtk_tree_selection_get_selected(a1, &v7, &v8) )
    {
      gtk_tree_model_get(v7, &v8, 1LL, &v6, 0xFFFFFFFFLL);
      v3 = (const __m128i *)sub_9B010(*(__int64 **)(a2 + 152), v6);
      if ( v3 )
      {
        v4 = sub_A7E90((__int64 **)(a2 + 152), (__int32 *)(a2 + 172), v3);
        if ( v4 )
        {
          v5 = *(_DWORD *)(v4 + 40);
          if ( !v5 )
          {
            v5 = *(_DWORD *)(a2 + 172);
            *(_DWORD *)(a2 + 168) = v5;
          }
          sub_A7420(a2, v4, v5, 1, 0);
        }
      }
    }
  }
  return __readfsqword(0x28u) ^ v9;
}

void __fastcall sub_A81A0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // rax
  const char *v6; // rax
  signed int v7; // eax
  __int64 v8; // rsi

  if ( !*(_BYTE *)(a2 + 176) )
  {
    v2 = a2;
    v3 = gtk_entry_get_type(a1, a2);
    v4 = v3;
    v5 = g_type_check_instance_cast(a1, v3);
    v6 = (const char *)gtk_entry_get_text(v5, v4);
    v7 = strtol(v6, 0LL, 10);
    if ( v7 > 0 )
    {
      v8 = *(_QWORD *)(v2 + 160);
      if ( *(_DWORD *)(v8 + 40) )
        __assert_fail("fs->selected->size == 0", "unix/gtkfont.c", 0xC90u, "size_entry_changed");
      sub_A7420(v2, v8, v7, 3, 1);
    }
  }
}

_QWORD *__fastcall sub_A8240(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, char a6)
{
  __int64 v6; // r12
  char v7; // r14
  __int64 v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rbp
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 *v15; // rax
  __int64 *v16; // r13
  int v17; // eax
  int v18; // ST0C_4
  signed int v19; // eax
  int v20; // ST0C_4
  int v21; // eax
  _QWORD *result; // rax
  int v23; // [rsp+4h] [rbp-44h]
  char v24; // [rsp+8h] [rbp-40h]

  v6 = a3;
  v7 = a4;
  v23 = a5;
  v24 = a6;
  v8 = pango_context_get_font_map(a2, a2);
  if ( v8
    && (v9 = v8,
        v10 = pango_context_get_language(a2),
        v11 = pango_font_map_load_fontset(v9, a2, v6, v10),
        (v12 = v11) != 0) )
  {
    v13 = pango_fontset_get_metrics(v11);
    v14 = v13;
    if ( v13 && (unsigned int)pango_font_metrics_get_approximate_digit_width(v13) )
    {
      v15 = (__int64 *)sub_2F450(1uLL, 0x58uLL, 0LL);
      v16 = v15;
      v15[6] = (__int64)off_322680;
      *((_DWORD *)v15 + 15) = (signed int)((unsigned __int64)pango_font_metrics_get_approximate_digit_width(v14) + 512) >> 10;
      v17 = pango_font_metrics_get_ascent(v14, 88LL);
      *((_DWORD *)v16 + 17) = (v17 + 1023) >> 10;
      v18 = (v17 + 1023) >> 10;
      v19 = (signed int)((unsigned __int64)pango_font_metrics_get_descent(v14) + 1023) >> 10;
      *((_DWORD *)v16 + 18) = v19;
      *((_DWORD *)v16 + 16) = v19 + v18;
      v20 = pango_font_metrics_get_ascent(v14, 88LL);
      v21 = pango_font_metrics_get_strikethrough_position(v14);
      *((_BYTE *)v16 + 80) = 0;
      *((_DWORD *)v16 + 21) = 0;
      *((_DWORD *)v16 + 14) = 55;
      *v16 = v6;
      v16[1] = v12;
      v16[2] = a1;
      *((_BYTE *)v16 + 28) = v7;
      v16[4] = 0LL;
      *((_DWORD *)v16 + 10) = 0;
      *((_DWORD *)v16 + 19) = (v20 - v21 + 512) >> 10;
      *((_DWORD *)v16 + 6) = v23;
      *((_BYTE *)v16 + 29) = v24;
      pango_font_metrics_unref(v14, 88LL);
      result = v16 + 6;
    }
    else
    {
      pango_font_description_free(v6);
      g_object_unref(v12, a2);
      result = 0LL;
    }
  }
  else
  {
    pango_font_description_free(v6);
    result = 0LL;
  }
  return result;
}

_QWORD *__fastcall sub_A83F0(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, char a6)
{
  char v6; // r15
  char v7; // r12
  int v8; // er14
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rbp

  v6 = a6;
  v7 = a4;
  v8 = a5;
  v9 = pango_font_description_from_string(a2);
  if ( v9 )
  {
    v10 = v9;
    v11 = gtk_widget_get_pango_context(a1);
    v12 = v11;
    if ( v11 && (unsigned __int8)sub_A5D50(v11, v10) )
      return sub_A8240(a1, v12, v10, v7, v8, v6);
    pango_font_description_free(v10);
  }
  return 0LL;
}

_QWORD *__fastcall sub_A8480(__int64 a1, __int64 a2, __int64 a3, char a4, int a5, char a6)
{
  char v6; // r14
  char v7; // bp
  int v8; // er13
  __int64 v9; // rax
  __int64 v10; // r15
  __int64 v11; // rax
  __int64 v12; // ST08_8

  v6 = a6;
  v7 = a4;
  v8 = a5;
  v9 = pango_font_description_from_string("Monospace");
  if ( v9 )
  {
    v10 = v9;
    v11 = gtk_widget_get_pango_context(a1);
    if ( v11 )
    {
      v12 = v11;
      pango_font_description_set_absolute_size(v10);
      return sub_A8240(a1, v12, v10, v7, v8, v6);
    }
    pango_font_description_free(v10);
  }
  return 0LL;
}

unsigned __int64 __fastcall sub_A8520(int *a1, __int64 a2, int a3, int a4, int *a5, int a6, char a7, char a8, int a9, char a10)
{
  int v10; // er8
  __int64 v11; // r13
  int v12; // ebx
  int v13; // eax
  __int64 v14; // rax
  int v15; // ebp
  signed __int64 v16; // rsi
  int v17; // er12
  char *v18; // r10
  __int64 v19; // r14
  int v20; // er13
  signed int v21; // ebx
  signed __int64 v22; // rbp
  double v23; // xmm1_8
  unsigned __int8 v24; // dl
  unsigned __int8 *v25; // rax
  unsigned __int8 v26; // dl
  bool v27; // al
  double v28; // xmm1_8
  double v29; // xmm0_8
  unsigned __int64 result; // rax
  unsigned __int64 v31; // rt1
  int v32; // er13
  signed __int64 v33; // r12
  char *v34; // r14
  int v35; // er13
  unsigned __int8 v36; // al
  __int64 v37; // rax
  __int64 v38; // rcx
  unsigned __int8 v39; // dl
  __int64 v40; // rbp
  int v41; // er11
  signed __int64 v42; // [rsp+8h] [rbp-C0h]
  __int64 v43; // [rsp+8h] [rbp-C0h]
  int v44; // [rsp+8h] [rbp-C0h]
  __int64 v45; // [rsp+10h] [rbp-B8h]
  int *v46; // [rsp+18h] [rbp-B0h]
  int v47; // [rsp+20h] [rbp-A8h]
  int v48; // [rsp+24h] [rbp-A4h]
  void **v49; // [rsp+30h] [rbp-98h]
  unsigned int *v50; // [rsp+38h] [rbp-90h]
  char *v51; // [rsp+40h] [rbp-88h]
  char v52; // [rsp+4Ah] [rbp-7Eh]
  int v53; // [rsp+4Ch] [rbp-7Ch]
  int v54; // [rsp+50h] [rbp-78h]
  int v55; // [rsp+58h] [rbp-70h]
  int v56; // [rsp+5Ch] [rbp-6Ch]
  __int64 v57; // [rsp+68h] [rbp-60h]
  char v58; // [rsp+70h] [rbp-58h]
  int v59; // [rsp+78h] [rbp-50h]
  int v60; // [rsp+7Ch] [rbp-4Ch]
  unsigned __int64 v61; // [rsp+88h] [rbp-40h]
  int v62; // [rsp+E0h] [rbp+18h]

  v46 = a5;
  v10 = *a1;
  v47 = a3;
  v52 = a8;
  v61 = __readfsqword(0x28u);
  if ( v10 )
    goto LABEL_46;
  v11 = a2;
  v12 = a6;
  v13 = 2 * a9;
  if ( !a7 )
    v13 = a9;
  v62 = v13;
  v48 = a4 - *(_DWORD *)(a2 + 20);
  v14 = gtk_widget_get_pango_context(*(_QWORD *)(a2 - 32));
  v45 = pango_layout_new(v14);
  pango_layout_set_font_description(v45, *(_QWORD *)(a2 - 48));
  if ( a8 )
  {
    v52 = 0;
    if ( !*(_BYTE *)(a2 - 20) )
    {
      v52 = *(_BYTE *)(a2 - 19);
      if ( !*(_BYTE *)(a2 - 19) )
      {
        v40 = pango_font_description_copy_static(*(_QWORD *)(a2 - 48));
        pango_font_description_set_weight(v40, 700LL);
        pango_layout_set_font_description(v45, v40);
      }
    }
  }
  v15 = 6 * v12 + 1;
  v51 = (char *)sub_2F450(v15, 1uLL, 0LL);
  v16 = 0LL;
  v17 = sub_BB550(0x37u, 0LL, (__int64)v46, v12, (__int64)v51, v15, ".");
  if ( v17 > 0 )
  {
    v18 = v51;
    v19 = v11;
    v49 = (void **)(v11 - 16);
    v50 = (unsigned int *)(v11 - 8);
    do
    {
      if ( a10 )
      {
        v20 = v62;
        v21 = v17;
        v22 = (signed __int64)&v18[v17];
        v17 = 0;
        v42 = 4LL;
      }
      else
      {
        if ( v17 == 1 || (v24 = v18[1], (v24 & 0x80u) == 0) )
        {
          v22 = (signed __int64)(v18 + 1);
          v21 = 1;
        }
        else
        {
          v25 = (unsigned __int8 *)(v18 + 2);
          v21 = 1;
          v22 = (signed __int64)(v18 + 1);
          if ( v24 <= 0xBFu )
          {
            do
            {
              ++v21;
              v22 = (signed __int64)v25;
              if ( v21 == v17 )
                break;
              v26 = *v25;
              if ( (*v25 & 0x80u) == 0 )
                break;
              ++v25;
            }
            while ( v26 <= 0xBFu );
          }
        }
        v43 = (__int64)v18;
        v27 = sub_2F670(*v46);
        v18 = (char *)v43;
        if ( v27
          || (v32 = sub_A6FC0(v45, v49, v50, *v46, v43, v21), v18 = (char *)v43, v32 != v62 << 10)
          || (v44 = 1, v56 = v17 - 2, v17 <= v21) )
        {
          v17 -= v21;
          v20 = v62;
          v42 = 4LL;
        }
        else
        {
          v53 = v17;
          v57 = v19;
          v33 = 2LL;
          v55 = v32;
          v34 = v18;
          while ( 1 )
          {
            v35 = v21 + 1;
            if ( v21 + 1 < v53 )
            {
              v36 = v34[v35];
              if ( (v36 & 0x80u) != 0 && v36 <= 0xBFu )
              {
                v37 = v21 + 2;
                v38 = v37 + (unsigned int)(v56 - v21);
                do
                {
                  v35 = v37;
                  if ( v37 == v38 )
                    break;
                  v39 = v34[v37];
                  if ( (v39 & 0x80u) == 0 )
                    break;
                  ++v37;
                }
                while ( v39 <= 0xBFu );
              }
            }
            v22 = (signed __int64)&v34[v21];
            v54 = v44 + 1;
            if ( sub_2F670(v46[v33 - 1])
              || v55 != (unsigned int)sub_A6FC0(v45, v49, v50, v46[v33 - 1], (__int64)&v34[v21], v35 - v21) )
            {
              v18 = v34;
              v19 = v57;
              v20 = v44 * v62;
              v17 = v53 - v21;
              v42 = 4LL * v44;
              goto LABEL_9;
            }
            if ( v53 <= v35 )
              break;
            ++v33;
            v21 = v35;
            ++v44;
          }
          v42 = v33 * 4;
          v41 = v35;
          v18 = v34;
          v19 = v57;
          v22 = (signed __int64)&v18[v35];
          v20 = v62 * v54;
          v17 = v53 - v41;
          v21 = v41;
        }
      }
LABEL_9:
      pango_layout_set_text(v45, v18, (unsigned int)v21);
      pango_layout_get_pixel_extents(v45, 0LL, &v58);
      v23 = (double)(v48 + (*(_DWORD *)(v19 + 16) - v60) / 2);
      cairo_move_to(*((_QWORD *)a1 + 2));
      pango_cairo_show_layout(*((_QWORD *)a1 + 2), v45);
      if ( v52 )
      {
        v28 = (double)(v48 + (*(_DWORD *)(v19 + 16) - v60) / 2);
        v29 = (double)(*(_DWORD *)(v19 - 24) + v47 + (v20 - v59) / 2);
        cairo_move_to(*((_QWORD *)a1 + 2));
        pango_cairo_show_layout(*((_QWORD *)a1 + 2), v45);
      }
      v16 = v42;
      v47 += v20;
      v18 = (char *)v22;
      v46 = (int *)((char *)v46 + v42);
    }
    while ( v17 > 0 );
  }
  sub_2F4D0(v51);
  g_object_unref(v45, v16);
  v31 = __readfsqword(0x28u);
  result = v31 ^ v61;
  if ( v31 != v61 )
LABEL_46:
    __assert_fail("draw_layout", "unix/gtkfont.c", 0x656u, "pangofont_draw_internal");
  return result;
}

void __fastcall sub_A8A60(int *a1, __int64 a2, __int64 a3, __int64 a4, int *a5, int a6, char a7, char a8, int a9)
{
  int v9; // er14
  int *v10; // r12
  int v11; // eax
  int *v12; // r8
  int v13; // er9
  int v14; // ecx
  int *v15; // [rsp+8h] [rbp-50h]
  int v16; // [rsp+10h] [rbp-48h]
  int v17; // [rsp+14h] [rbp-44h]

  v9 = a3;
  v10 = 0LL;
  v17 = a4;
  v16 = a6;
  v15 = a5;
  v11 = sub_BD8A0(*a5);
  v12 = v15;
  v13 = v16;
  v14 = v17;
  if ( !v11 )
  {
    v10 = (int *)sub_2F450(v16 + 1, 4uLL, 0LL);
    memcpy(v10 + 1, v15, 4LL * v16);
    v14 = v17;
    v12 = v10;
    *v10 = 32;
    v13 = v16 + 1;
  }
  sub_A8520(a1, a2, v9, v14, v12, v13, a7, a8, a9, 1);
  sub_2F4D0(v10);
}

unsigned __int64 __fastcall sub_A8B40(int *a1, __int64 a2, int a3, int a4, int *a5, int a6, char a7, char a8, int a9)
{
  return sub_A8520(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0);
}

char __fastcall sub_A8B70(__int64 a1, __int64 a2, Display *a3, int a4, int a5, __int64 a6, int a7, int a8)
{
  int v8; // eax
  int v9; // er12
  unsigned __int8 *v10; // rbx
  signed __int64 v11; // r13
  double v12; // xmm0_8
  double v13; // xmm1_8
  int v14; // ebp
  __int64 v15; // r11
  signed __int64 v16; // r11
  signed __int64 v17; // ST20_8
  Display *v19; // [rsp+8h] [rbp-50h]
  int v20; // [rsp+1Ch] [rbp-3Ch]

  LOBYTE(v8) = a8;
  v19 = a3;
  v20 = a5;
  if ( a8 > 0 )
  {
    v9 = a4;
    v10 = (unsigned __int8 *)(a6 + a7);
    v11 = a7 + a6 + (unsigned int)(a8 - 1) + 1;
    do
    {
      v14 = *v10;
      LOBYTE(v8) = sub_A3E20(*(_QWORD *)a2, 0, *v10);
      if ( (_BYTE)v8 )
      {
        v16 = 16 * v15;
        if ( v14 < *(_DWORD *)(a2 + 24) && *(_QWORD *)(*(_QWORD *)(a2 + 16) + v16)
          || (v17 = v16,
              XDrawImageString(
                v19,
                *(_QWORD *)(a2 + 32),
                *(GC *)(a2 + 40),
                *(_DWORD *)(a2 + 56),
                *(_DWORD *)(a2 + 60),
                (const char *)v10,
                1),
              sub_A5560(v19, a2, v14),
              *(_QWORD *)(*(_QWORD *)(a2 + 16) + v17)) )
        {
          v12 = (double)(v9 - *(_DWORD *)(a2 + 56));
          v13 = (double)(v20 - *(_DWORD *)(a2 + 60));
          cairo_mask_surface(*(_QWORD *)(a1 + 16));
        }
        v8 = XTextWidth(*(XFontStruct **)a2, (const char *)v10, 1);
        v9 += v8;
      }
      ++v10;
    }
    while ( (unsigned __int8 *)v11 != v10 );
  }
  return v8;
}

__int64 __fastcall sub_A8C90(__int64 a1, const char *a2, unsigned __int8 a3, unsigned __int8 a4, unsigned int a5, char a6)
{
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bp
  unsigned int v8; // er15
  unsigned int v9; // er12
  signed __int64 v10; // rax
  signed __int64 v11; // r13
  __int64 v12; // rbp
  __int64 result; // rax
  unsigned int v14; // [rsp+8h] [rbp-50h]
  int v15; // [rsp+10h] [rbp-48h]
  int v16; // [rsp+14h] [rbp-44h]
  unsigned __int64 v17; // [rsp+18h] [rbp-40h]

  v6 = a3;
  v7 = a4;
  v8 = a5;
  LOBYTE(v9) = a6;
  v17 = __readfsqword(0x28u);
  v10 = sub_A62F0(a2, &v15, &v16);
  if ( v15 >= v16 )
    return 0LL;
  v11 = v10;
  v9 = (unsigned __int8)v9;
  v14 = v7;
  v12 = v15;
  while ( 1 )
  {
    result = ((__int64 (__fastcall *)(__int64, signed __int64, _QWORD, _QWORD, _QWORD, _QWORD))(*off_322660[v12])[0])(
               a1,
               v11,
               v6,
               v14,
               v8,
               v9);
    if ( result )
      break;
    if ( v16 <= (signed int)++v12 )
      return 0LL;
  }
  return result;
}

__int64 __fastcall sub_A8D60(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 16LL))();
}

__int64 __fastcall sub_A8D70(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 72LL))();
}

_DWORD *__fastcall sub_A8D80(__int64 a1, const char *a2, unsigned __int8 a3, unsigned __int8 a4, unsigned int a5, char a6)
{
  char v6; // r15
  unsigned __int8 v7; // r12
  unsigned int v8; // ebp
  int v9; // er14
  __int64 v10; // rax
  _DWORD *v11; // rbx
  _QWORD *v12; // rcx
  _QWORD *v13; // ST08_8
  char *v14; // rax
  int v15; // edx
  int v16; // edx
  int v17; // edx

  v6 = a6;
  v7 = a4;
  v8 = a3;
  v9 = a5;
  v10 = sub_A8C90(a1, a2, a3, a4, a5, a6);
  v11 = (_DWORD *)v10;
  if ( v10 )
  {
    v12 = 0LL;
    if ( *(_BYTE *)(v10 + 32) )
      v12 = sub_A8480(a1, *(unsigned int *)(v10 + 16), v8, v7, v9, v6);
    v13 = v12;
    v14 = (char *)sub_2F450(1uLL, 0x38uLL, 0LL);
    v15 = v11[3];
    *((_QWORD *)v14 + 2) = &unk_322600;
    *((_DWORD *)v14 + 7) = v15;
    *((_DWORD *)v14 + 9) = v11[5];
    *((_DWORD *)v14 + 10) = v11[6];
    *((_DWORD *)v14 + 8) = v11[4];
    *((_DWORD *)v14 + 11) = v11[7];
    v16 = v11[2];
    v14[48] = 0;
    *((_DWORD *)v14 + 6) = v16;
    v17 = v11[9];
    *(_QWORD *)v14 = v11;
    v11 = v14 + 16;
    *((_QWORD *)v14 + 1) = v13;
    *((_DWORD *)v14 + 13) = v17;
  }
  return v11;
}

signed __int64 __fastcall sub_A8E50(__int64 a1)
{
  _BYTE *v1; // rax
  __int64 v2; // rbx
  unsigned int v3; // ST40_4
  int v4; // ST5C_4
  unsigned int v5; // ST48_4
  unsigned int v6; // ST4C_4
  int v7; // edx
  unsigned int v8; // ST58_4
  __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // r13
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rbp
  __int64 v21; // rax
  __int64 v22; // r12
  __int64 v23; // rax
  __int64 v24; // rdi
  __int64 v25; // r14
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // r15
  __int64 v30; // ST20_8
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // r14
  __int64 v34; // rsi
  __int64 v35; // ST50_8
  __int64 v36; // rdi
  __int64 v37; // r14
  __int64 v38; // rax
  __int64 v39; // r13
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // r15
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // r15
  __int64 v50; // ST28_8
  __int64 v51; // rdi
  __int64 v52; // rax
  __int64 v53; // ST30_8
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // r15
  __int64 v59; // rax
  __int64 v60; // rax
  __int64 v61; // rax
  __int64 v62; // ST40_8
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // r14
  __int64 v66; // rax
  __int64 v67; // rax
  __int64 v68; // rax
  __int64 v69; // r15
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // rax
  __int64 v75; // r15
  __int64 v76; // rax
  __int64 v77; // rax
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 v80; // rax
  __int64 v81; // r15
  __int64 v82; // rax
  __int64 v83; // rdi
  __int64 v84; // r14
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  __int64 v88; // rax
  __int64 v89; // rax
  __int64 v90; // r15
  __int64 v91; // rax
  __int64 v92; // rax
  __int64 v93; // r14
  __int64 v94; // rax
  __int64 v95; // rax
  __int64 v96; // ST20_8
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rax
  __int64 v101; // rax
  __int64 v102; // r13
  __int64 v103; // rax
  __int64 v104; // rax
  __int64 v105; // rax
  __int64 v106; // rax
  __int64 v107; // rdi
  __int64 v108; // rax
  __int64 v109; // rax
  __int64 v110; // rax
  __int64 v111; // r13
  __int64 v112; // rax
  __int64 v113; // r14
  __int64 v114; // rax
  __int64 v115; // rax
  __int64 v116; // rax
  __int64 v117; // r13
  __int64 v118; // rax
  __int64 v119; // rax
  __int64 v120; // rax
  __int64 v121; // rax
  __int64 v122; // r13
  __int64 v123; // rax
  __int64 v124; // rax
  __int64 v125; // rax
  __int64 v126; // rax
  __int64 v127; // rax
  __int64 v128; // rax
  __int64 v129; // r13
  __int64 v130; // rax
  __int64 v131; // rax
  __int64 v132; // rax
  __int64 v133; // rax
  __int64 v134; // rax
  __int64 v135; // rax
  __int64 v136; // r13
  __int64 v137; // rax
  __int64 v138; // rax
  __int64 v139; // rax
  __int64 v140; // rax
  __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // r13
  __int64 v144; // rax
  __int64 v145; // rax
  __int64 v146; // rax
  __int64 v147; // rax
  __int64 v148; // rax
  __int64 v149; // rax
  __int64 v150; // rbp
  __int64 v151; // rax
  __int64 v152; // rax
  __int64 v153; // rdi
  unsigned int v155; // [rsp+40h] [rbp-48h]
  int v156; // [rsp+44h] [rbp-44h]
  unsigned __int64 v157; // [rsp+48h] [rbp-40h]

  v157 = __readfsqword(0x28u);
  v1 = sub_2F450(1uLL, 0xD8uLL, 0LL);
  v1[176] = 0;
  *((_QWORD *)v1 + 20) = 0LL;
  v2 = (__int64)v1;
  sub_AB500((__int64)"Quite Long Font Name (Foundry)", (int *)&v155, &v156);
  v3 = v155;
  v4 = v156;
  v5 = 14 * v156;
  sub_AB500((__int64)"Italic Extra Condensed", (int *)&v155, &v156);
  v6 = v155;
  sub_AB500((__int64)"48000", (int *)&v155, &v156);
  v7 = v155;
  *(_QWORD *)(v2 + 184) = 0LL;
  v8 = v7;
  v9 = gtk_window_get_type("48000", &v155);
  v10 = gtk_dialog_new();
  v11 = a1;
  v12 = g_type_check_instance_cast(v10, v9);
  *(_QWORD *)(v2 + 192) = v12;
  gtk_window_set_title(v12, v11);
  v13 = gtk_dialog_get_type(v12, v11);
  v14 = v13;
  v15 = g_type_check_instance_cast(*(_QWORD *)(v2 + 192), v13);
  v16 = gtk_dialog_add_button(v15, "_Cancel", 4294967290LL);
  v17 = *(_QWORD *)(v2 + 192);
  *(_QWORD *)(v2 + 208) = v16;
  v18 = g_type_check_instance_cast(v17, v14);
  v19 = gtk_dialog_add_button(v18, "_OK", 4294967291LL);
  *(_QWORD *)(v2 + 200) = v19;
  gtk_widget_grab_default(v19);
  v20 = gtk_grid_new(v19, "_OK");
  v21 = gtk_grid_get_type();
  v22 = v21;
  v23 = g_type_check_instance_cast(v20, v21);
  gtk_grid_set_column_spacing(v23, 8LL);
  gtk_widget_show(v20);
  v24 = g_type_check_instance_cast(v20, 80LL);
  g_object_set(v24, "margin", 8LL, 0LL);
  v25 = gtk_box_get_type(v24, "margin");
  v26 = g_type_check_instance_cast(*(_QWORD *)(v2 + 192), v14);
  v27 = gtk_dialog_get_content_area(v26, v14);
  v28 = g_type_check_instance_cast(v27, v25);
  gtk_box_pack_start(v28, v20, 1LL, 1LL, 0LL);
  v29 = gtk_label_new_with_mnemonic("_Font:", v20);
  gtk_widget_show(v29);
  v30 = gtk_label_get_type(v29);
  g_type_check_instance_cast(v29, v30);
  sub_AB600();
  v31 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v31, v29, 0LL, 0LL, 1LL, 1LL);
  v32 = g_type_check_instance_cast(v29, 80LL);
  g_object_set(v32, "hexpand", 1LL, 0LL);
  v33 = gtk_list_store_new(3LL, 64LL, 24LL);
  v34 = gtk_tree_model_get_type(3LL);
  v35 = v33;
  v36 = g_type_check_instance_cast(v33, v34);
  v37 = gtk_tree_view_new_with_model(v36);
  v38 = gtk_tree_view_get_type(v36, v34);
  v39 = v38;
  v40 = g_type_check_instance_cast(v37, v38);
  gtk_tree_view_set_headers_visible(v40, 0LL);
  v41 = g_type_check_instance_cast(v29, v30);
  gtk_label_set_mnemonic_widget(v41, v37);
  gtk_widget_show(v37);
  v42 = gtk_cell_renderer_text_new(v37, v37);
  v43 = gtk_tree_view_column_new_with_attributes("Font", v42, "text", 0LL, 0LL);
  gtk_tree_view_column_set_sizing(v43, 1LL);
  v44 = g_type_check_instance_cast(v37, v39);
  gtk_tree_view_append_column(v44, v43);
  v45 = g_type_check_instance_cast(v37, v39);
  v46 = gtk_tree_view_get_selection(v45, v39);
  v47 = g_type_check_instance_cast(v46, 80LL);
  g_signal_connect_data(v47, "changed", sub_A80C0, v2, 0LL, 0LL);
  v48 = g_type_check_instance_cast(v37, 80LL);
  g_signal_connect_data(v48, "row-activated", sub_A7D20, v2, 0LL, 0LL);
  v49 = gtk_scrolled_window_new(0LL, 0LL);
  v50 = gtk_scrolled_window_get_type(0LL, 0LL);
  v51 = g_type_check_instance_cast(v49, v50);
  gtk_scrolled_window_set_shadow_type(v51, 1LL);
  v52 = gtk_container_get_type(v51);
  v53 = v52;
  v54 = g_type_check_instance_cast(v49, v52);
  gtk_container_add(v54, v37);
  gtk_widget_show(v49);
  v55 = g_type_check_instance_cast(v49, v50);
  gtk_scrolled_window_set_policy(v55, 1LL, 0LL);
  gtk_widget_set_size_request(v49, v3, v5);
  v56 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v56, v49, 0LL, 1LL, 1LL, 2LL);
  v57 = g_type_check_instance_cast(v49, 80LL);
  g_object_set(v57, "expand", 1LL, 0LL);
  *(_QWORD *)(v2 + 24) = v37;
  *(_QWORD *)v2 = v35;
  v58 = gtk_label_new_with_mnemonic("_Style:", "expand");
  gtk_widget_show(v58);
  g_type_check_instance_cast(v58, v30);
  sub_AB600();
  v59 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v59, v58, 1LL, 0LL, 1LL, 1LL);
  v60 = g_type_check_instance_cast(v58, 80LL);
  g_object_set(v60, "hexpand", 1LL, 0LL);
  v61 = gtk_list_store_new(5LL, 64LL, 24LL);
  v62 = v61;
  v63 = g_type_check_instance_cast(v61, v34);
  v64 = gtk_tree_view_new_with_model(v63);
  v65 = v64;
  v66 = g_type_check_instance_cast(v64, v39);
  gtk_tree_view_set_headers_visible(v66, 0LL);
  v67 = g_type_check_instance_cast(v58, v30);
  gtk_label_set_mnemonic_widget(v67, v65);
  gtk_widget_show(v65);
  v68 = gtk_cell_renderer_text_new(v65, v65);
  v69 = gtk_tree_view_column_new_with_attributes("Style", v68, "text", 0LL, "sensitive");
  gtk_tree_view_column_set_sizing(v69, 1LL);
  v70 = g_type_check_instance_cast(v65, v39);
  gtk_tree_view_append_column(v70, v69);
  v71 = g_type_check_instance_cast(v65, v39);
  v72 = gtk_tree_view_get_selection(v71, v39);
  v73 = g_type_check_instance_cast(v72, 80LL);
  g_signal_connect_data(v73, "changed", sub_A7FE0, v2, 0LL, 0LL);
  v74 = gtk_scrolled_window_new(0LL, 0LL);
  v75 = v74;
  v76 = g_type_check_instance_cast(v74, v50);
  gtk_scrolled_window_set_shadow_type(v76, 1LL);
  v77 = g_type_check_instance_cast(v75, v53);
  gtk_container_add(v77, v65);
  gtk_widget_show(v75);
  v78 = g_type_check_instance_cast(v75, v50);
  gtk_scrolled_window_set_policy(v78, 1LL, 0LL);
  gtk_widget_set_size_request(v75, v6, v5);
  v79 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v79, v75, 1LL, 1LL, 1LL, 2LL);
  v80 = g_type_check_instance_cast(v75, 80LL);
  g_object_set(v80, "expand", 1LL, 0LL);
  *(_QWORD *)(v2 + 32) = v65;
  *(_QWORD *)(v2 + 8) = v62;
  v81 = gtk_label_new_with_mnemonic("Si_ze:", "expand");
  gtk_widget_show(v81);
  g_type_check_instance_cast(v81, v30);
  sub_AB600();
  v82 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v82, v81, 2LL, 0LL, 1LL, 1LL);
  v83 = g_type_check_instance_cast(v81, 80LL);
  g_object_set(v83, "hexpand", 1LL, 0LL);
  v84 = gtk_entry_new(v83, "hexpand");
  *(_QWORD *)(v2 + 40) = v84;
  v85 = g_type_check_instance_cast(v81, v30);
  gtk_label_set_mnemonic_widget(v85, v84);
  gtk_widget_set_size_request(v84, v8, 0xFFFFFFFFLL);
  gtk_widget_show(v84);
  v86 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v86, v84, 2LL, 1LL, 1LL, 1LL);
  v87 = g_type_check_instance_cast(v84, 80LL);
  g_object_set(v87, "hexpand", 1LL, 0LL);
  v88 = g_type_check_instance_cast(v84, 80LL);
  g_signal_connect_data(v88, "changed", sub_A81A0, v2, 0LL, 0LL);
  v89 = gtk_list_store_new(3LL, 64LL, 24LL);
  v90 = v89;
  v91 = g_type_check_instance_cast(v89, v34);
  v92 = gtk_tree_view_new_with_model(v91);
  v93 = v92;
  v94 = g_type_check_instance_cast(v92, v39);
  gtk_tree_view_set_headers_visible(v94, 0LL);
  gtk_widget_show(v93);
  v95 = gtk_cell_renderer_text_new(v93, 0LL);
  v96 = gtk_tree_view_column_new_with_attributes("Size", v95, "text", 0LL, 0LL);
  gtk_tree_view_column_set_sizing(v96, 1LL);
  v97 = g_type_check_instance_cast(v93, v39);
  gtk_tree_view_append_column(v97, v96);
  v98 = g_type_check_instance_cast(v93, v39);
  v99 = gtk_tree_view_get_selection(v98, v39);
  v100 = g_type_check_instance_cast(v99, 80LL);
  g_signal_connect_data(v100, "changed", sub_A7C50, v2, 0LL, 0LL);
  v101 = gtk_scrolled_window_new(0LL, 0LL);
  v102 = v101;
  v103 = g_type_check_instance_cast(v101, v50);
  gtk_scrolled_window_set_shadow_type(v103, 1LL);
  v104 = g_type_check_instance_cast(v102, v53);
  gtk_container_add(v104, v93);
  gtk_widget_show(v102);
  v105 = g_type_check_instance_cast(v102, v50);
  gtk_scrolled_window_set_policy(v105, 1LL, 0LL);
  v106 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v106, v102, 2LL, 2LL, 1LL, 1LL);
  v107 = g_type_check_instance_cast(v102, 80LL);
  g_object_set(v107, "expand", 1LL, 0LL);
  *(_QWORD *)(v2 + 16) = v90;
  *(_QWORD *)(v2 + 48) = v93;
  v108 = gtk_drawing_area_new(v107, "expand");
  *(_WORD *)(v2 + 120) = 0;
  *(_WORD *)(v2 + 132) = -1;
  *(_QWORD *)(v2 + 124) = -4294967296LL;
  *(_QWORD *)(v2 + 96) = v108;
  *(_QWORD *)(v2 + 104) = 0LL;
  *(_QWORD *)(v2 + 112) = 0LL;
  v109 = g_type_check_instance_cast(v108, 80LL);
  g_signal_connect_data(v109, "draw", sub_A6840, v2, 0LL, 0LL);
  v110 = g_type_check_instance_cast(*(_QWORD *)(v2 + 96), 80LL);
  g_signal_connect_data(v110, "configure_event", sub_A65E0, v2, 0LL, 0LL);
  gtk_widget_set_size_request(*(_QWORD *)(v2 + 96), 1LL, (unsigned int)(5 * v4));
  gtk_widget_show(*(_QWORD *)(v2 + 96));
  v111 = *(_QWORD *)(v2 + 96);
  v112 = gtk_frame_new(0LL, 1LL);
  v113 = v112;
  v114 = g_type_check_instance_cast(v112, v53);
  gtk_container_add(v114, v111);
  gtk_widget_show(v113);
  v115 = g_type_check_instance_cast(v113, 80LL);
  g_object_set(v115, "margin", 8LL, 0LL);
  v116 = gtk_frame_new("Preview of font", "margin");
  v117 = v116;
  v118 = g_type_check_instance_cast(v116, v53);
  gtk_container_add(v118, v113);
  gtk_widget_show(v117);
  v119 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v119, v117, 0LL, 3LL, 3LL, 1LL);
  v120 = g_type_check_instance_cast(v117, 80LL);
  g_object_set(v120, "expand", 1LL, 0LL);
  *(_DWORD *)(v2 + 88) = 0;
  v121 = gtk_check_button_new_with_label("Show client-side fonts", "expand");
  v122 = v121;
  v123 = g_type_check_instance_cast(v121, 80LL);
  g_object_set_data(v123, "user-data", 1LL);
  v124 = g_type_check_instance_cast(v122, 80LL);
  g_signal_connect_data(v124, "toggled", sub_A73B0, v2, 0LL, 0LL);
  gtk_widget_show(v122);
  v125 = *(signed int *)(v2 + 88);
  *(_DWORD *)(v2 + 88) = v125 + 1;
  *(_QWORD *)(v2 + 8 * v125 + 56) = v122;
  v126 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v126, v122, 0LL, 4LL, 3LL, 1LL);
  v127 = g_type_check_instance_cast(v122, 80LL);
  g_object_set(v127, "hexpand", 1LL, 0LL);
  v128 = gtk_check_button_new_with_label("Show server-side fonts", "hexpand");
  v129 = v128;
  v130 = g_type_check_instance_cast(v128, 80LL);
  g_object_set_data(v130, "user-data", 2LL);
  v131 = g_type_check_instance_cast(v129, 80LL);
  g_signal_connect_data(v131, "toggled", sub_A73B0, v2, 0LL, 0LL);
  gtk_widget_show(v129);
  v132 = *(signed int *)(v2 + 88);
  *(_DWORD *)(v2 + 88) = v132 + 1;
  *(_QWORD *)(v2 + 8 * v132 + 56) = v129;
  v133 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v133, v129, 0LL, 5LL, 3LL, 1LL);
  v134 = g_type_check_instance_cast(v129, 80LL);
  g_object_set(v134, "hexpand", 1LL, 0LL);
  v135 = gtk_check_button_new_with_label("Show server-side font aliases", "hexpand");
  v136 = v135;
  v137 = g_type_check_instance_cast(v135, 80LL);
  g_object_set_data(v137, "user-data", 4LL);
  v138 = g_type_check_instance_cast(v136, 80LL);
  g_signal_connect_data(v138, "toggled", sub_A73B0, v2, 0LL, 0LL);
  gtk_widget_show(v136);
  v139 = *(signed int *)(v2 + 88);
  *(_DWORD *)(v2 + 88) = v139 + 1;
  *(_QWORD *)(v2 + 8 * v139 + 56) = v136;
  v140 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v140, v136, 0LL, 6LL, 3LL, 1LL);
  v141 = g_type_check_instance_cast(v136, 80LL);
  g_object_set(v141, "hexpand", 1LL, 0LL);
  v142 = gtk_check_button_new_with_label("Show non-monospaced fonts", "hexpand");
  v143 = v142;
  v144 = g_type_check_instance_cast(v142, 80LL);
  g_object_set_data(v144, "user-data", 8LL);
  v145 = g_type_check_instance_cast(v143, 80LL);
  g_signal_connect_data(v145, "toggled", sub_A73B0, v2, 0LL, 0LL);
  gtk_widget_show(v143);
  v146 = *(signed int *)(v2 + 88);
  *(_DWORD *)(v2 + 88) = v146 + 1;
  *(_QWORD *)(v2 + 8 * v146 + 56) = v143;
  v147 = g_type_check_instance_cast(v20, v22);
  gtk_grid_attach(v147, v143, 0LL, 7LL, 3LL, 1LL);
  v148 = g_type_check_instance_cast(v143, 80LL);
  g_object_set(v148, "hexpand", 1LL, 0LL);
  if ( *(_DWORD *)(v2 + 88) > 4u )
    __assert_fail("fs->n_filter_buttons <= lenof(fs->filter_buttons)", "unix/gtkfont.c", 0xE61u, "unifontsel_new");
  *(_DWORD *)(v2 + 136) = 7;
  sub_A6AB0(v2, (__int64)"hexpand");
  *(_QWORD *)(v2 + 144) = sub_9AF60((__int64)sub_A6C60);
  *(_QWORD *)(v2 + 152) = sub_9AF60((__int64)sub_A6B60);
  v149 = gtk_widget_get_type(sub_A6B60, "hexpand");
  v150 = v149;
  v151 = g_type_check_instance_cast(*(_QWORD *)(v2 + 192), v149);
  sub_A5F80(
    v151,
    (void (__fastcall *)(__int64, __int64, __int64, _QWORD, __int64, __int64, __int64, _QWORD, __int64 (__fastcall **)()))sub_A63B0,
    v2);
  v152 = g_type_check_instance_cast(*(_QWORD *)(v2 + 192), v150);
  sub_A49F0(
    v152,
    (void (__fastcall *)(__int64, char *, char *, char *, char *, signed __int64, __int64, signed __int64, void **))sub_A63B0,
    v2);
  sub_A71A0((__int64 *)v2, (__int64)sub_A63B0);
  v153 = *(_QWORD *)(v2 + 200);
  *(_QWORD *)(v2 + 168) = 55834574861LL;
  gtk_widget_set_sensitive(v153, 0LL);
  return v2 + 184;
}

void __fastcall sub_A9D80(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  void *v3; // rax
  _QWORD **v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rax

  v1 = (void *)(a1 - 184);
  v2 = a1;
  sub_9AF90(*(_QWORD ***)(a1 - 32));
  while ( 1 )
  {
    v3 = (void *)sub_9B400(*(__int64 **)(a1 - 40), 0);
    if ( !v3 )
      break;
    sub_2F4D0(v3);
  }
  v4 = *(_QWORD ***)(a1 - 40);
  sub_9AF90(v4);
  v5 = gtk_widget_get_type(v4, 0LL);
  v6 = g_type_check_instance_cast(*(_QWORD *)(v2 + 8), v5);
  gtk_widget_destroy(v6);
  sub_2F4D0(v1);
}

unsigned __int64 __fastcall sub_A9DF0(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  const char *v3; // rdi
  signed __int64 v4; // rax
  int v5; // er13
  int v6; // edx
  __int64 v7; // r12
  __int64 v8; // rbx
  __int64 (__fastcall *v9)(); // r15
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 *v13; // rdi
  __int64 v14; // rax
  int v15; // ecx
  unsigned int v16; // edx
  __int64 *v17; // rdi
  __int64 v18; // [rsp+8h] [rbp-80h]
  int v19; // [rsp+20h] [rbp-68h]
  int v20; // [rsp+24h] [rbp-64h]
  unsigned int v21; // [rsp+28h] [rbp-60h]
  int v22; // [rsp+2Ch] [rbp-5Ch]
  __int64 v23; // [rsp+30h] [rbp-58h]
  int v24; // [rsp+38h] [rbp-50h]
  unsigned __int64 v25; // [rsp+48h] [rbp-40h]

  v2 = a1;
  v3 = "server:fixed";
  v25 = __readfsqword(0x28u);
  if ( a2 )
  {
    v3 = a2;
    if ( !*a2 )
      v3 = "server:fixed";
  }
  v4 = sub_A62F0(v3, &v19, &v20);
  v5 = v19;
  v6 = v20;
  v7 = v4;
  if ( v19 >= v20 )
  {
    v11 = 0LL;
  }
  else
  {
    v18 = gtk_widget_get_type(v3, &v19);
    v8 = v5;
    while ( 1 )
    {
      v5 = v8;
      v9 = (*off_322660[v8])[7];
      v10 = g_type_check_instance_cast(*(_QWORD *)(v2 + 8), v18);
      v11 = ((__int64 (__fastcall *)(__int64, __int64, unsigned int *, int *, _QWORD))v9)(v10, v7, &v21, &v22, 0LL);
      if ( v11 )
        break;
      v6 = v20;
      v5 = ++v8;
      if ( v20 <= (signed int)v8 )
        goto LABEL_9;
    }
    v6 = v20;
  }
LABEL_9:
  if ( v5 != v6 )
  {
    v23 = v11;
    v13 = *(__int64 **)(v2 - 40);
    v24 = v22;
    v14 = sub_9B3D0(v13, (__int64)&v23, (__int64 (__fastcall *)(__int64))sub_A6CD0);
    if ( v14 )
    {
      v15 = *(_DWORD *)(v14 + 40);
      v16 = v21;
      if ( !v15 || v15 == v21 )
        goto LABEL_20;
    }
    v17 = *(__int64 **)(v2 - 40);
    v23 = v7;
    v24 = v22;
    v14 = sub_9B3D0(v17, (__int64)&v23, (__int64 (__fastcall *)(__int64))sub_A6CD0);
    if ( v14 )
    {
      v16 = *(_DWORD *)(v14 + 40);
      if ( v16 == v21 )
LABEL_20:
        sub_A7420(v2 - 184, v14, v16, 0, 1);
    }
  }
  return __readfsqword(0x28u) ^ v25;
}

char *__fastcall sub_A9FA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double xmm0_8_0, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 *v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rbp
  __int64 (__fastcall *v17)(__int64, __int64, _QWORD); // r12
  unsigned int v18; // er13
  __int64 v19; // rax
  __int64 v20; // rax
  void *v21; // rbp
  __int64 *v22; // rax
  char *v24; // rbx

  v14 = *(__int64 **)(a1 - 24);
  if ( !v14 )
    return 0LL;
  v15 = v14[8];
  v16 = *v14;
  if ( *((_DWORD *)v14 + 10) )
    return sub_BC160(*(char **)(v15 + 80), xmm0_8_0, a8, a9, a10, a11, a12, a13, a14, ":", v16, 0LL, a5, a6);
  v17 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v15 + 64);
  v18 = *(_DWORD *)(a1 - 16);
  v19 = gtk_widget_get_type(a1, a2);
  v20 = g_type_check_instance_cast(*(_QWORD *)(a1 + 8), v19);
  v21 = (void *)v17(v20, v16, v18);
  v22 = *(__int64 **)(a1 - 24);
  if ( !v21 )
  {
    v16 = *v22;
    v15 = v22[8];
    return sub_BC160(*(char **)(v15 + 80), xmm0_8_0, a8, a9, a10, a11, a12, a13, a14, ":", v16, 0LL, a5, a6);
  }
  v24 = sub_BC160(*(char **)(v22[8] + 80), xmm0_8_0, a8, a9, a10, a11, a12, a13, a14, ":", v21, 0LL);
  sub_2F4D0(v21);
  return v24;
}

unsigned __int64 __fastcall sub_AA070(_QWORD *a1, int a2)
{
  __int64 *v2; // rbp
  const char *v3; // r12

  v2 = (__int64 *)*a1;
  v3 = (const char *)a1[1];
  sub_2F4D0(a1);
  if ( a2 > 0 )
    return sub_B2560(v2, v3);
  sub_1ED50(v2);
  return gtk_main_quit(v2);
}

char *__fastcall sub_AA0B0(char *a1)
{
  Display *v1; // rax
  char *result; // rax

  v1 = (Display *)sub_AB820();
  if ( v1 )
    result = XGetDefault(v1, off_3260C0, a1);
  else
    result = 0LL;
  return result;
}

__int64 sub_AA0E0(int fd, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, ...)
{
  int v9; // ebp
  _QWORD *v10; // rsi
  char v11; // cl
  int v12; // ebx
  unsigned int v13; // eax
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  char *v16; // rax
  int v17; // ecx
  char *v18; // r12
  bool v19; // zf
  bool v20; // sf
  __int64 v21; // rdi
  __int64 v22; // rax
  int v23; // ecx
  __int64 *v24; // r8
  unsigned int v25; // esi
  char v26; // r10
  __int64 v27; // rax
  char *v28; // rdi
  int v29; // ecx
  __int64 v30; // rdx
  __int64 *v31; // rdx
  __int64 v32; // rdx
  __pid_t v33; // eax
  __pid_t v34; // ebx
  __pid_t v35; // eax
  __int64 result; // rax
  unsigned __int64 v37; // rt1
  int stat_loc; // [rsp+Ch] [rbp-7Ch]
  gcc_va_list va; // [rsp+10h] [rbp-78h]
  unsigned __int64 v40; // [rsp+28h] [rbp-60h]

  va_start(va, a9);
  v9 = fd;
  v40 = __readfsqword(0x28u);
  v10 = va[0].overflow_arg_area;
  v11 = 0;
  v12 = dword_3264C8 + 2;
  v13 = 8;
  while ( 1 )
  {
    if ( v13 > 0x2F )
    {
      v15 = v10;
      ++v10;
    }
    else
    {
      v14 = v13;
      v11 = 1;
      v13 += 8;
      v15 = (char *)va[0].reg_save_area + v14;
    }
    if ( !*v15 )
      break;
    ++v12;
  }
  if ( v11 )
    va[0].gp_offset = v13;
  v16 = (char *)sub_2F450(v12, 8uLL, 0LL);
  v17 = dword_3264C8;
  v18 = v16;
  v19 = dword_3264C8 == 0;
  v20 = dword_3264C8 < 0;
  *(_QWORD *)v16 = qword_3264D8;
  *(_QWORD *)&v16[8 * v12 - 8] = 0LL;
  if ( v20 || v19 )
  {
    v23 = 1;
  }
  else
  {
    v21 = qword_3264D0;
    v22 = 0LL;
    do
    {
      *(_QWORD *)&v18[v22 + 8] = *(_QWORD *)(v21 + v22);
      v22 += 8LL;
    }
    while ( 8LL * (unsigned int)(v17 - 1) + 8 != v22 );
    v23 = v17 + 1;
  }
  v24 = (__int64 *)va[0].overflow_arg_area;
  v25 = 8;
  v26 = 0;
  va_end(va);
  va_start(va, a9);
  v27 = v23 + 1;
  v28 = &v18[8 * (v23 - v27)];
  do
  {
    v29 = v27;
    if ( v25 > 0x2F )
    {
      v31 = v24;
      ++v24;
    }
    else
    {
      v30 = v25;
      v26 = 1;
      v25 += 8;
      v31 = (__int64 *)((char *)va[0].reg_save_area + v30);
    }
    v32 = *v31;
    *(_QWORD *)&v28[8 * v27++] = v32;
  }
  while ( v32 );
  if ( v26 )
    va[0].gp_offset = v25;
  if ( v12 != v29 )
    __assert_fail("i == n", "unix/gtkmain.c", 0x65u, "fork_and_exec_self");
  v33 = fork();
  v34 = v33;
  if ( v33 < 0 )
  {
    perror("fork");
    sub_2F4D0(v18);
  }
  else
  {
    if ( !v33 )
    {
      v35 = fork();
      if ( v35 >= 0 )
      {
        if ( v35 )
          _exit(0);
        if ( v9 >= 0 )
          close(v9);
        execv("/proc/self/exe", (char *const *)v18);
        execvp(qword_3264D8, (char *const *)v18);
        perror("exec");
        _exit(127);
      }
LABEL_31:
      perror("fork");
      _exit(1);
    }
    sub_2F4D0(v18);
    waitpid(v34, &stat_loc, 0);
  }
  v37 = __readfsqword(0x28u);
  result = v37 ^ v40;
  if ( v37 != v40 )
    goto LABEL_31;
  return result;
}

__int64 __fastcall sub_AA510(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return sub_AA0E0(-1, a1, a2, a3, a4, a5, a6, a7, a8, 0LL);
}

__int64 __fastcall sub_AA540(_QWORD *a1, const char *a2)
{
  int v2; // er12
  char *v3; // rax
  __int64 v4; // rdx
  char *v5; // rbx
  int v6; // eax
  __int64 v7; // rdi
  __int64 result; // rax
  const char *v16; // rdx
  int fd; // [rsp+8h] [rbp-60h]
  int v18; // [rsp+Ch] [rbp-5Ch]
  char *v19; // [rsp+10h] [rbp-58h]
  __int64 v20; // [rsp+18h] [rbp-50h]
  __int64 v21; // [rsp+20h] [rbp-48h]
  int v22; // [rsp+28h] [rbp-40h]
  __int64 *v23; // [rsp+30h] [rbp-38h]
  unsigned __int64 v24; // [rsp+38h] [rbp-30h]

  v24 = __readfsqword(0x28u);
  if ( sscanf(a2, "---[%d,%d]", &fd, &v18) != 2 )
  {
    __fprintf_chk(stderr, 1LL, "%s: malformed magic argument `%s'\n", "PuTTY");
    exit(1);
  }
  v2 = 0;
  v3 = (char *)sub_2F450(v18, 1uLL, 0LL);
  v4 = v18;
  v5 = v3;
  if ( v18 > 0 )
  {
    while ( 1 )
    {
      v6 = read(fd, &v5[v2], (signed int)v4 - v2);
      if ( v6 <= 0 )
        break;
      v4 = v18;
      v2 += v6;
      if ( v18 <= v2 )
        goto LABEL_8;
    }
    if ( v6 )
    {
      perror(aReadFrom);
      exit(1);
    }
    v4 = v18;
    if ( v18 > v2 )
    {
      v16 = "%s: unexpected EOF in Duplicate Session data\n";
LABEL_20:
      __fprintf_chk(stderr, 1LL, v16, "PuTTY");
      exit(1);
    }
  }
LABEL_8:
  v19 = v5;
  v21 = v4;
  v20 = 0LL;
  v22 = 0;
  v23 = (__int64 *)&v19;
  if ( !(unsigned __int8)sub_1FD50(a1, (__int64)&v19) )
  {
    __fprintf_chk(stderr, 1LL, "%s: malformed Duplicate Session data\n", "PuTTY");
    exit(1);
  }
  v7 = (__int64)v23;
  if ( *(_DWORD *)(v7 + 24)
    || *(_QWORD *)(v7 + 16) != *(_QWORD *)(v7 + 8)
    || (sub_2F4D0(v5), result = 0LL, __readfsqword(0x28u) != v24) )
  {
    v16 = "%s: malformed Duplicate Session data\n";
    goto LABEL_20;
  }
  return result;
}

void __noreturn sub_AA7D0(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v2; // [rsp+18h] [rbp-C0h]

  va_start(va, a1);
  v2 = __readfsqword(0x28u);
  __fprintf_chk(stderr, 1LL, "%s: ", "PuTTY");
  __vfprintf_chk(stderr, 1LL, a1, va);
  fputc(10, stderr);
  exit(1);
}

void __noreturn sub_AA8C0()
{
  __fprintf_chk(stderr, 1LL, "%s: %s\n", "PuTTY");
  exit(1);
}

__int64 __fastcall sub_AA900(int a1, signed __int64 a2, unsigned __int8 a3, _QWORD *a4)
{
  int v4; // er15
  signed __int64 v5; // r13
  _QWORD *v6; // rbx
  int v7; // er14
  bool v8; // cf
  bool v9; // zf
  char *v10; // r12
  const char *v11; // rdi
  _BYTE *v12; // rsi
  signed __int64 v13; // rcx
  __int64 v14; // rsi
  unsigned int v15; // eax
  bool v16; // cf
  bool v17; // zf
  const char *v18; // rdi
  signed __int64 v19; // rcx
  char *v20; // rsi
  char v21; // al
  bool v22; // cf
  bool v23; // zf
  const char *v24; // rdi
  signed __int64 v25; // rcx
  char *v26; // rsi
  char v27; // al
  bool v28; // cf
  bool v29; // zf
  const char *v30; // rdi
  signed __int64 v31; // rcx
  char *v32; // rsi
  char v33; // al
  bool v34; // cf
  bool v35; // zf
  signed __int64 v36; // rbp
  int v37; // esi
  void **v38; // r12
  __int64 v39; // rdx
  __int64 result; // rax
  const char *v41; // rdi
  signed __int64 v42; // rcx
  char *v43; // rsi
  char v44; // al
  bool v45; // cf
  bool v46; // zf
  const char *v47; // rdi
  signed __int64 v48; // rcx
  char *v49; // rsi
  char v50; // al
  bool v51; // cf
  bool v52; // zf
  const char *v53; // rdi
  signed __int64 v54; // rcx
  char *v55; // rsi
  char v56; // al
  bool v57; // cf
  bool v58; // zf
  char *v59; // rdx
  const char *v60; // rdi
  signed __int64 v61; // rcx
  char *v62; // rsi
  char v63; // al
  bool v64; // cf
  bool v65; // zf
  __int64 v66; // rdx
  const char *v67; // rdi
  signed __int64 v68; // rcx
  char *v69; // rsi
  char v70; // al
  bool v71; // cf
  bool v72; // zf
  const char *v73; // rdi
  int v74; // eax
  signed __int64 v75; // rcx
  char *v76; // rsi
  const char *v77; // rdi
  char v78; // al
  bool v79; // cf
  bool v80; // zf
  const char *v81; // rdi
  signed __int64 v82; // rcx
  char *v83; // rsi
  char v84; // al
  bool v85; // cf
  bool v86; // zf
  const char *v87; // rdi
  signed __int64 v88; // rcx
  char *v89; // rsi
  char v90; // al
  bool v91; // cf
  bool v92; // zf
  const char *v93; // rdi
  signed __int64 v94; // rcx
  char *v95; // rsi
  char v96; // al
  bool v97; // cf
  bool v98; // zf
  const char *v99; // rdi
  signed __int64 v100; // rcx
  char *v101; // rsi
  char v102; // al
  bool v103; // cf
  bool v104; // zf
  const char *v105; // rdi
  signed __int64 v106; // rcx
  char *v107; // rsi
  int v108; // eax
  bool v109; // cf
  bool v110; // zf
  const char *v111; // rdi
  signed __int64 v112; // rcx
  char *v113; // rsi
  int v114; // edx
  bool v115; // cf
  bool v116; // zf
  int v117; // er14
  const char *v118; // rdi
  signed __int64 v119; // rcx
  char *v120; // rsi
  char v121; // al
  bool v122; // cf
  bool v123; // zf
  const char *v124; // rdi
  signed __int64 v125; // rcx
  char *v126; // rsi
  char v127; // al
  bool v128; // cf
  bool v129; // zf
  const char *v130; // rdi
  signed __int64 v131; // rcx
  char *v132; // rsi
  char v133; // al
  bool v134; // cf
  bool v135; // zf
  const char *v136; // rdi
  signed __int64 v137; // rcx
  char *v138; // rsi
  int v139; // er12
  int v140; // er13
  char *v147; // rdx
  char *v148; // rdi
  void **v149; // rbp
  char v150; // dl
  char v151; // dl
  char v152; // dl
  char *v153; // rax
  __int64 v154; // rcx
  const char *v155; // rsi
  FILE *v156; // rbp
  void *v157; // rbx
  FILE *v158; // rbx
  int v159; // [rsp+Ch] [rbp-7Ch]
  int v160; // [rsp+10h] [rbp-78h]
  unsigned __int8 v161; // [rsp+1Ah] [rbp-6Eh]
  unsigned __int8 v162; // [rsp+1Bh] [rbp-6Dh]
  int v163; // [rsp+1Ch] [rbp-6Ch]
  double v164; // [rsp+20h] [rbp-68h]
  double v165; // [rsp+28h] [rbp-60h]
  double v166; // [rsp+30h] [rbp-58h]
  unsigned __int64 v167; // [rsp+48h] [rbp-40h]

  v4 = a1;
  v5 = a2;
  v6 = a4;
  v167 = __readfsqword(0x28u);
  v161 = a3;
  v162 = 0;
  v159 = -(a3 < 1u) | 1;
LABEL_2:
  while ( 1 )
  {
    v7 = v4 - 1;
    if ( v4 - 1 <= 0 )
      break;
    while ( 1 )
    {
      v8 = 0;
      v9 = (dword_F9C60 & 2) == 0;
      v10 = *(char **)(v5 + 8);
      if ( dword_F9C60 & 2 )
      {
        v11 = "-T";
        v12 = *(_BYTE **)(v5 + 8);
        v13 = 3LL;
        do
        {
          if ( !v13 )
            break;
          v8 = *v12 < (const unsigned __int8)*v11;
          v9 = *v12++ == *v11++;
          --v13;
        }
        while ( v9 );
        if ( (!v8 && !v9) == v8 )
          v10 = "-title";
      }
      v14 = 0LL;
      if ( v7 != 1 )
        v14 = *(_QWORD *)(v5 + 16);
      v15 = sub_1CD30(v159, (__int64)v6, v10, v14, (__int64)v10);
      if ( v15 == -2 )
        sub_AA7D0((__int64)"option \"%s\" requires an argument", v10);
      if ( v15 == 2 )
      {
        v4 -= 2;
        v5 += 16LL;
        goto LABEL_2;
      }
      v16 = v15 < 1;
      v17 = v15 == 1;
      if ( v15 == 1 )
        goto LABEL_37;
      v18 = "-fn";
      v19 = 4LL;
      v20 = v10;
      do
      {
        if ( !v19 )
          break;
        v16 = (unsigned __int8)*v20 < *v18;
        v17 = *v20++ == *v18++;
        --v19;
      }
      while ( v17 );
      v21 = (!v16 && !v17) - v16;
      v22 = 0;
      v23 = v21 == 0;
      if ( v21 )
      {
        v24 = "-font";
        v25 = 6LL;
        v26 = v10;
        do
        {
          if ( !v25 )
            break;
          v22 = (unsigned __int8)*v26 < *v24;
          v23 = *v26++ == *v24++;
          --v25;
        }
        while ( v23 );
        v27 = (!v22 && !v23) - v22;
        v28 = 0;
        v29 = v27 == 0;
        if ( v27 )
          break;
      }
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_45;
      v36 = v5 + 16;
      if ( v161 )
      {
        v37 = 125;
        v38 = (void **)sub_B51E0(*(char **)(v5 + 16));
        v39 = (__int64)v38;
LABEL_29:
        sub_1FB70(v6, v37, v39);
        sub_B5230(v38);
      }
LABEL_30:
      v7 = v4 - 1;
      v5 = v36;
      if ( v4 - 1 <= 0 )
        goto LABEL_31;
    }
    v30 = "-fb";
    v31 = 4LL;
    v32 = v10;
    do
    {
      if ( !v31 )
        break;
      v28 = (unsigned __int8)*v32 < *v30;
      v29 = *v32++ == *v30++;
      --v31;
    }
    while ( v29 );
    v33 = (!v28 && !v29) - v28;
    v34 = 0;
    v35 = v33 == 0;
    if ( !v33 )
    {
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      if ( !v161 )
        goto LABEL_30;
      v37 = 197;
      v38 = (void **)sub_B51E0(*(char **)(v5 + 16));
      v39 = (__int64)v38;
      goto LABEL_29;
    }
    v41 = "-fw";
    v42 = 4LL;
    v43 = v10;
    do
    {
      if ( !v42 )
        break;
      v34 = (unsigned __int8)*v43 < *v41;
      v35 = *v43++ == *v41++;
      --v42;
    }
    while ( v35 );
    v44 = (!v34 && !v35) - v34;
    v45 = 0;
    v46 = v44 == 0;
    if ( !v44 )
    {
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      if ( v161 )
      {
        v37 = 198;
        v38 = (void **)sub_B51E0(*(char **)(v5 + 16));
        v39 = (__int64)v38;
        goto LABEL_29;
      }
      goto LABEL_30;
    }
    v47 = "-fwb";
    v48 = 5LL;
    v49 = v10;
    do
    {
      if ( !v48 )
        break;
      v45 = (unsigned __int8)*v49 < *v47;
      v46 = *v49++ == *v47++;
      --v48;
    }
    while ( v46 );
    v50 = (!v45 && !v46) - v45;
    v51 = 0;
    v52 = v50 == 0;
    if ( !v50 )
    {
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      if ( v161 )
      {
        v37 = 199;
        v38 = (void **)sub_B51E0(*(char **)(v5 + 16));
        v39 = (__int64)v38;
        goto LABEL_29;
      }
      goto LABEL_30;
    }
    v53 = "-cs";
    v54 = 4LL;
    v55 = v10;
    do
    {
      if ( !v54 )
        break;
      v51 = (unsigned __int8)*v55 < *v53;
      v52 = *v55++ == *v53++;
      --v54;
    }
    while ( v52 );
    v56 = (!v51 && !v52) - v51;
    v57 = 0;
    v58 = v56 == 0;
    if ( !v56 )
    {
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      if ( v161 )
      {
        v59 = *(char **)(v5 + 16);
        v5 += 16LL;
        sub_1F890(v6, 164, v59);
        continue;
      }
      goto LABEL_30;
    }
    v60 = "-geometry";
    v61 = 10LL;
    v62 = v10;
    do
    {
      if ( !v61 )
        break;
      v57 = (unsigned __int8)*v62 < *v60;
      v58 = *v62++ == *v60++;
      --v61;
    }
    while ( v58 );
    v63 = (!v57 && !v58) - v57;
    v64 = 0;
    v65 = v63 == 0;
    if ( !v63 )
    {
      v4 -= 2;
      if ( v4 > 0 )
      {
        if ( v161 )
        {
          v66 = *(_QWORD *)(v5 + 16);
          v5 += 16LL;
          qword_3264C0 = v66;
        }
        else
        {
          v5 += 16LL;
        }
        continue;
      }
LABEL_60:
      v5 += 8LL;
      __fprintf_chk(stderr, 1LL, "%s: %s expects an argument\n", "PuTTY");
      v162 = 1;
      continue;
    }
    v67 = "-sl";
    v68 = 4LL;
    v69 = v10;
    do
    {
      if ( !v68 )
        break;
      v64 = (unsigned __int8)*v69 < *v67;
      v65 = *v69++ == *v67++;
      --v68;
    }
    while ( v65 );
    v70 = (!v64 && !v65) - v64;
    v71 = 0;
    v72 = v70 == 0;
    if ( !v70 )
    {
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      if ( v161 )
      {
        v73 = *(const char **)(v5 + 16);
        v5 += 16LL;
        v74 = strtol(v73, 0LL, 10);
        sub_1F760(v6, 104, v74);
        continue;
      }
      goto LABEL_30;
    }
    v75 = 4LL;
    v76 = v10;
    v77 = "-fg";
    do
    {
      if ( !v75 )
        break;
      v71 = (unsigned __int8)*v76 < *v77;
      v72 = *v76++ == *v77++;
      --v75;
    }
    while ( v72 );
    v78 = (!v71 && !v72) - v71;
    v79 = 0;
    v80 = v78 == 0;
    if ( !v78 )
      goto LABEL_197;
    v81 = "-bg";
    v82 = 4LL;
    v83 = v10;
    do
    {
      if ( !v82 )
        break;
      v79 = (unsigned __int8)*v83 < *v81;
      v80 = *v83++ == *v81++;
      --v82;
    }
    while ( v80 );
    v84 = (!v79 && !v80) - v79;
    v85 = 0;
    v86 = v84 == 0;
    if ( !v84 )
      goto LABEL_197;
    v87 = "-bfg";
    v88 = 5LL;
    v89 = v10;
    do
    {
      if ( !v88 )
        break;
      v85 = (unsigned __int8)*v89 < *v87;
      v86 = *v89++ == *v87++;
      --v88;
    }
    while ( v86 );
    v90 = (!v85 && !v86) - v85;
    v91 = 0;
    v92 = v90 == 0;
    if ( !v90 )
      goto LABEL_197;
    v93 = "-bbg";
    v94 = 5LL;
    v95 = v10;
    do
    {
      if ( !v94 )
        break;
      v91 = (unsigned __int8)*v95 < *v93;
      v92 = *v95++ == *v93++;
      --v94;
    }
    while ( v92 );
    v96 = (!v91 && !v92) - v91;
    v97 = 0;
    v98 = v96 == 0;
    if ( !v96 )
      goto LABEL_197;
    v99 = "-cfg";
    v100 = 5LL;
    v101 = v10;
    do
    {
      if ( !v100 )
        break;
      v97 = (unsigned __int8)*v101 < *v99;
      v98 = *v101++ == *v99++;
      --v100;
    }
    while ( v98 );
    v102 = (!v97 && !v98) - v97;
    v103 = 0;
    v104 = v102 == 0;
    if ( !v102 )
      goto LABEL_197;
    v105 = "-cbg";
    v106 = 5LL;
    v107 = v10;
    do
    {
      if ( !v106 )
        break;
      v103 = (unsigned __int8)*v107 < *v105;
      v104 = *v107++ == *v105++;
      --v106;
    }
    while ( v104 );
    if ( (!v103 && !v104) == v103 )
    {
LABEL_197:
      v4 -= 2;
      if ( v4 <= 0 )
      {
LABEL_45:
        v5 += 8LL;
        __fprintf_chk(stderr, 1LL, "%s: %s expects an argument\n", "PuTTY");
        v162 = 1;
        continue;
      }
      v36 = v5 + 16;
      if ( v161 )
      {
        v108 = gdk_rgba_parse(&v164, *(_QWORD *)(v5 + 16));
        v109 = 0;
        v110 = v108 == 0;
        if ( v108 )
        {
          v111 = "-fg";
          v112 = 4LL;
          v113 = v10;
          do
          {
            if ( !v112 )
              break;
            v109 = (unsigned __int8)*v113 < *v111;
            v110 = *v113++ == *v111++;
            --v112;
          }
          while ( v110 );
          v114 = (char)((!v109 && !v110) - v109);
          v115 = 0;
          v116 = v114 == 0;
          v117 = (signed int)(v165 * 255.0);
          v160 = (signed int)(v164 * 255.0);
          v163 = (signed int)(255.0 * v166);
          if ( v114 )
          {
            v118 = "-bg";
            v119 = 4LL;
            v120 = v10;
            do
            {
              if ( !v119 )
                break;
              v115 = (unsigned __int8)*v120 < *v118;
              v116 = *v120++ == *v118++;
              --v119;
            }
            while ( v116 );
            v121 = (!v115 && !v116) - v115;
            v122 = 0;
            v123 = v121 == 0;
            if ( v121 )
            {
              v124 = "-bfg";
              v125 = 5LL;
              v126 = v10;
              do
              {
                if ( !v125 )
                  break;
                v122 = (unsigned __int8)*v126 < *v124;
                v123 = *v126++ == *v124++;
                --v125;
              }
              while ( v123 );
              v127 = (!v122 && !v123) - v122;
              v128 = 0;
              v129 = v127 == 0;
              if ( v127 )
              {
                v130 = "-bbg";
                v131 = 5LL;
                v132 = v10;
                do
                {
                  if ( !v131 )
                    break;
                  v128 = (unsigned __int8)*v132 < *v130;
                  v129 = *v132++ == *v130++;
                  --v131;
                }
                while ( v129 );
                v133 = (!v128 && !v129) - v128;
                v134 = 0;
                v135 = v133 == 0;
                if ( v133 )
                {
                  v136 = "-cfg";
                  v137 = 5LL;
                  v138 = v10;
                  do
                  {
                    if ( !v137 )
                      break;
                    v134 = (unsigned __int8)*v138 < *v136;
                    v135 = *v138++ == *v136++;
                    --v137;
                  }
                  while ( v135 );
                  if ( (!v134 && !v135) == v134 )
                  {
                    v139 = 14;
                    v140 = 13;
                    v114 = 12;
                  }
                  else
                  {
                    if ( strcmp(v10, "-cbg") )
                      goto LABEL_134;
                    v139 = 17;
                    v140 = 16;
                    v114 = 15;
                  }
                }
                else
                {
                  v139 = 11;
                  v140 = 10;
                  v114 = 9;
                }
              }
              else
              {
                v139 = 5;
                v140 = 4;
                v114 = 3;
              }
            }
            else
            {
              v139 = 8;
              v140 = 7;
              v114 = 6;
            }
          }
          else
          {
            v139 = 2;
            v140 = 1;
          }
          sub_1F7F0(v6, 147, v114, v160);
          sub_1F7F0(v6, 147, v140, v117);
          sub_1F7F0(v6, 147, v139, v163);
        }
        else
        {
          __fprintf_chk(stderr, 1LL, "%s: unable to parse colour \"%s\"\n", "PuTTY");
          v162 = v161;
        }
      }
      goto LABEL_30;
    }
    if ( strcmp(v10, "-title") )
    {
      if ( !strcmp(v10, "-log") )
      {
        v4 -= 2;
        if ( v4 <= 0 )
          goto LABEL_60;
        v148 = *(char **)(v5 + 16);
        v5 += 16LL;
        if ( v161 )
        {
          v149 = (void **)sub_B4DD0(v148);
          sub_1FAC0(v6, 127, (__int64)v149);
          sub_1F760(v6, 128, 2);
          sub_B4E60(v149);
        }
        continue;
      }
      if ( !strcmp(v10, "-ut-") || !strcmp(v10, "+ut") )
      {
        v150 = 0;
        if ( !v161 )
          goto LABEL_37;
LABEL_148:
        v5 += 8LL;
        sub_1F6D0(v6, 193, v150);
        v4 = v7;
        continue;
      }
      if ( !strcmp(v10, "-ut") )
      {
        if ( !v161 )
          goto LABEL_37;
        v150 = 1;
        goto LABEL_148;
      }
      if ( !strcmp(v10, "-ls-") || !strcmp(v10, "+ls") )
      {
        v151 = 0;
        if ( !v161 )
          goto LABEL_37;
LABEL_155:
        v5 += 8LL;
        sub_1F6D0(v6, 194, v151);
        v4 = v7;
        continue;
      }
      if ( !strcmp(v10, "-ls") )
      {
        if ( !v161 )
          goto LABEL_37;
        v151 = 1;
        goto LABEL_155;
      }
      if ( !strcmp(v10, "-nethack") )
      {
        if ( v161 )
        {
          sub_1F6D0(v6, 86, 1);
          v5 += 8LL;
          v4 = v7;
          continue;
        }
        goto LABEL_37;
      }
      if ( !strcmp(v10, "-sb-") || !strcmp(v10, "+sb") )
      {
        v152 = 0;
        if ( !v161 )
          goto LABEL_37;
LABEL_165:
        v5 += 8LL;
        sub_1F6D0(v6, 117, v152);
        v4 = v7;
        continue;
      }
      if ( !strcmp(v10, "-sb") )
      {
        if ( !v161 )
          goto LABEL_37;
        v152 = 1;
        goto LABEL_165;
      }
      if ( !strcmp(v10, "-name") )
      {
        v4 -= 2;
        if ( v4 > 0 )
        {
          v153 = *(char **)(v5 + 16);
          v5 += 16LL;
          off_3260C0 = v153;
          continue;
        }
        goto LABEL_60;
      }
      if ( strcmp(v10, "-xrm") )
      {
        if ( !strcmp(v10, "-help") || !strcmp(v10, asc_F8116) )
        {
          v158 = stdout;
          if ( (signed int)__fprintf_chk(
                             stdout,
                             1LL,
                             "pterm option summary:\n"
                             "\n"
                             "  --display DISPLAY         Specify X display to use (note '--')\n"
                             "  -name PREFIX              Prefix when looking up resources (default: pterm)\n"
                             "  -fn FONT                  Normal text font\n"
                             "  -fb FONT                  Bold text font\n"
                             "  -geometry GEOMETRY        Position and size of window (size in characters)\n"
                             "  -sl LINES                 Number of lines of scrollback\n"
                             "  -fg COLOUR, -bg COLOUR    Foreground/background colour\n"
                             "  -bfg COLOUR, -bbg COLOUR  Foreground/background bold colour\n"
                             "  -cfg COLOUR, -bfg COLOUR  Foreground/background cursor colour\n"
                             "  -T TITLE                  Window title\n"
                             "  -ut, +ut                  Do(default) or do not update utmp\n"
                             "  -ls, +ls                  Do(default) or do not make shell a login shell\n"
                             "  -sb, +sb                  Do(default) or do not display a scrollbar\n"
                             "  -log PATH, -sessionlog PATH  Log all output to a file\n"
                             "  -nethack                  Map numeric keypad to hjklyubn direction keys\n"
                             "  -xrm RESOURCE-STRING      Set an X resource\n"
                             "  -e COMMAND [ARGS...]      Execute command (consumes all remaining args)\n",
                             v154) >= 0
            && fflush(v158) >= 0 )
          {
LABEL_190:
            exit(0);
          }
        }
        else
        {
          v155 = "-version";
          if ( strcmp(v10, "-version") )
          {
            v155 = asc_F812A;
            if ( strcmp(v10, asc_F812A) )
            {
              if ( !strcmp(v10, "-pgpfp") )
              {
                sub_B4F30();
                exit(1);
              }
              if ( *v10 == 45 )
              {
                v5 += 8LL;
                v4 = v7;
                __fprintf_chk(stderr, 1LL, "%s: unrecognized option '%s'\n", "PuTTY");
                v162 = 1;
                continue;
              }
              if ( v161 )
              {
                v5 += 8LL;
                v4 = v7;
                __fprintf_chk(stderr, 1LL, "%s: unexpected non-option argument '%s'\n", "PuTTY");
                v162 = v161;
                continue;
              }
LABEL_37:
              v5 += 8LL;
              v4 = v7;
              continue;
            }
          }
          v156 = stdout;
          v157 = (void *)sub_31FE0((__int64)"\n", (__int64)v155);
          if ( (signed int)__fprintf_chk(v156, 1LL, &unk_F8134, "PuTTY") >= 0 && fflush(v156) >= 0 )
          {
            sub_2F4D0(v157);
            goto LABEL_190;
          }
        }
        perror("output error");
        exit(1);
      }
      v4 -= 2;
      if ( v4 <= 0 )
        goto LABEL_60;
      v36 = v5 + 16;
      sub_BA580(*(const char **)(v5 + 16), (__int64)"PuTTY");
      goto LABEL_30;
    }
    v4 -= 2;
    if ( v4 <= 0 )
      goto LABEL_60;
    v147 = *(char **)(v5 + 16);
    v5 += 16LL;
    if ( v161 )
      sub_1F890(v6, 103, v147);
  }
LABEL_31:
  result = v162;
  if ( __readfsqword(0x28u) != v167 )
LABEL_134:
    __assert_fail("index != -1", "unix/gtkmain.c", 0x1C0u, "do_cmdline");
  return result;
}

__int64 sub_AB4E0()
{
  return gtk_window_new(0LL);
}

__int64 __fastcall j__gtk_main_quit(__int64 a1)
{
  return gtk_main_quit(a1);
}

unsigned __int64 __fastcall sub_AB500(__int64 a1, int *a2, int *a3)
{
  int *v3; // r12
  int *v4; // rbp
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax
  __int64 v12; // rax
  __int64 v14; // [rsp+0h] [rbp-38h]
  int v15; // [rsp+8h] [rbp-30h]
  int v16; // [rsp+Ch] [rbp-2Ch]
  unsigned __int64 v17; // [rsp+18h] [rbp-20h]

  v3 = a2;
  v4 = a3;
  v17 = __readfsqword(0x28u);
  v5 = gtk_label_new(a1, a2);
  v6 = gtk_label_get_type(a1);
  v7 = v6;
  v8 = g_type_check_instance_cast(v5, v6);
  v9 = gtk_label_get_layout(v8, v7);
  pango_layout_get_extents(v9, 0LL, &v14);
  if ( v3 )
  {
    v10 = v15 + 1023;
    if ( v15 >= 0 )
      v10 = v15;
    *v3 = v10 >> 10;
  }
  if ( v4 )
  {
    v11 = v16 + 1023;
    if ( v16 >= 0 )
      v11 = v16;
    *v4 = v11 >> 10;
  }
  v12 = g_type_check_instance_cast(v5, 80LL);
  g_object_ref_sink(v12, 80LL);
  g_object_unref(v5, 80LL);
  return __readfsqword(0x28u) ^ v17;
}

__int64 __fastcall sub_AB5C0(__int64 a1)
{
  unsigned int v2; // [rsp+4h] [rbp-14h]
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  sub_AB500(a1, (int *)&v2, 0LL);
  return v2;
}

__int64 sub_AB600()
{
  return gtk_label_set_xalign();
}

__int64 sub_AB610()
{
  __int64 v0; // rbx
  __int64 v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rax

  v0 = gtk_window_new(0LL);
  v1 = gtk_box_new(1LL, 8LL);
  v2 = gtk_container_get_type(1LL);
  v3 = g_type_check_instance_cast(v0, v2);
  gtk_container_add(v3, v1);
  gtk_widget_show(v1);
  return v0;
}

__int64 __fastcall sub_AB660(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rbx

  v2 = a2;
  v3 = gtk_box_get_type(a1, a2);
  v4 = gtk_bin_get_type(a1, a2);
  v5 = v4;
  v6 = g_type_check_instance_cast(a1, v4);
  v7 = gtk_bin_get_child(v6, v5);
  v8 = g_type_check_instance_cast(v7, v3);
  v9 = g_type_check_instance_cast(v2, 80LL);
  g_object_set(v9, "margin", 8LL, 0LL);
  gtk_box_pack_end(v8, v2, 0LL, 1LL, 0LL);
  v10 = gtk_separator_new(0LL, v2);
  gtk_box_pack_end(v8, v10, 0LL, 1LL, 0LL);
  return gtk_widget_show(v10);
}

__int64 __fastcall sub_AB700(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax

  v1 = gtk_box_new(0LL, 0LL);
  sub_AB660(a1, v1);
  v2 = g_type_check_instance_cast(v1, 80LL);
  g_object_set(v2, "margin", 0LL, 0LL);
  v3 = g_type_check_instance_cast(v1, 80LL);
  g_object_set(v3, "spacing", 8LL, 0LL);
  gtk_widget_show(v1);
  v4 = gtk_box_get_type(v1, "spacing");
  return g_type_check_instance_cast(v1, v4);
}

__int64 __fastcall sub_AB790(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned int a5)
{
  __int64 v5; // r12
  unsigned __int8 v6; // bp
  unsigned __int8 v7; // bl
  unsigned int v8; // ST0C_4
  __int64 v9; // r13
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax

  v5 = a2;
  v6 = a4;
  v7 = a3;
  v8 = a5;
  v9 = gtk_box_get_type(a1, a2);
  v10 = gtk_bin_get_type(a1, a2);
  v11 = v10;
  v12 = g_type_check_instance_cast(a1, v10);
  v13 = gtk_bin_get_child(v12, v11);
  v14 = g_type_check_instance_cast(v13, v9);
  return gtk_box_pack_start(v14, v5, v7, v6, v8);
}

char *sub_AB800()
{
  return sub_BC360((__int64)"%d.%d.%d", 3LL, 22LL, 30LL);
}

__int64 __fastcall sub_AB820(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rax

  v2 = (_QWORD *)gdk_display_get_default(a1, a2);
  v3 = gdk_x11_display_get_type();
  if ( !v2 )
    return 0LL;
  if ( !*v2 || *(_QWORD *)*v2 != v3 )
  {
    a2 = v3;
    a1 = v2;
    if ( !(unsigned int)g_type_check_instance_is_a(v2, v3) )
      return 0LL;
  }
  v4 = gdk_display_get_default(a1, a2);
  return gdk_x11_display_get_xdisplay(v4);
}

signed __int64 sub_AB870()
{
  return 1LL;
}

bool __fastcall sub_AB880(__int64 a1)
{
  return *(_DWORD *)(a1 - 5584) == 55;
}

void __fastcall sub_AB890(__int64 a1, char a2)
{
  *(_BYTE *)(a1 - 116) = a2;
}

void nullsub_40()
{
  ;
}

void nullsub_41()
{
  ;
}

signed __int64 sub_AB8C0()
{
  return 1LL;
}

_QWORD *__fastcall sub_AB8D0(__int64 a1)
{
  return sub_1BD80((__int64)sub_ABDA0, a1 - 9536);
}

__int64 __fastcall sub_AB8F0(_QWORD *a1)
{
  return gtk_widget_destroy(*a1);
}

void __fastcall sub_AB900(void *a1)
{
  sub_2F4D0(a1);
}

char *__fastcall sub_AB910(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // rdx
  char *result; // rax

  v2 = *(_QWORD *)(a1 - 5624);
  v3 = sub_2F450(1uLL, 0xA8uLL, 0LL);
  *v3 = 0LL;
  v3[17] = 0LL;
  v4 = v3;
  memset(
    (void *)((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 144) >> 3));
  v3[18] = a2;
  *((_BYTE *)v3 + 16) = 0;
  *((_DWORD *)v3 + 5) = 0;
  v3[12] = v2;
  v3[19] = sub_87340;
  v3[15] = sub_90B70;
  result = (char *)(v3 + 19);
  v4[20] = result;
  return result;
}

char *__fastcall sub_AB910(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // rdx
  char *result; // rax

  v2 = *(_QWORD *)(a1 - 5624);
  v3 = sub_2F450(1uLL, 0xA8uLL, 0LL);
  *v3 = 0LL;
  v3[17] = 0LL;
  v4 = v3;
  memset(
    (void *)((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 144) >> 3));
  v3[18] = a2;
  *((_BYTE *)v3 + 16) = 0;
  *((_DWORD *)v3 + 5) = 0;
  v3[12] = v2;
  v3[19] = sub_87340;
  v3[15] = sub_90B70;
  result = (char *)(v3 + 19);
  v4[20] = result;
  return result;
}

signed __int64 __fastcall sub_AB930(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  __int64 v3; // rdi

  v3 = *(_QWORD *)(a1 - 5624);
  if ( !v3 )
    return 0LL;
  sub_90B10(v3, a2, a3);
  return 1LL;
}

signed __int64 __fastcall sub_AB960(__int64 a1, char a2)
{
  sub_90B00(*(_QWORD *)(a1 - 5624), a2);
  return 1LL;
}

__int64 __fastcall sub_AB980(__int64 a1, __int64 *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rax
  unsigned int v4; // edx
  int v5; // eax
  __int64 v6; // rax

  v2 = (_QWORD *)gtk_widget_get_window(*(_QWORD *)(a1 - 9528));
  v3 = gdk_x11_window_get_type();
  v4 = 0;
  if ( v2 )
  {
    if ( *v2 && *(_QWORD *)*v2 == v3 || (v5 = g_type_check_instance_is_a(v2, v3), v4 = 0, v5) )
    {
      v6 = gdk_x11_window_get_xid(v2);
      v4 = 1;
      *a2 = v6;
    }
  }
  return v4;
}

__int64 __fastcall sub_AB9E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = gdk_display_get_default(a1, a2);
  return gdk_display_get_name(v2);
}

char *__usercall sub_ABA00@<rax>(bool a1@<cf>, bool a2@<zf>, __int64 a3@<rdi>, _BYTE *a4@<rsi>)
{
  __int64 v4; // r8
  const char *v5; // rdi
  signed __int64 v6; // rcx
  _BYTE *v7; // rdx
  char v8; // al
  bool v9; // cf
  bool v10; // zf
  char *v11; // rdi
  const char *v13; // rdi
  signed __int64 v14; // rcx
  _BYTE *v15; // rsi
  char *v16; // rdi

  v4 = *(_QWORD *)(a3 - 5624);
  v5 = "ERASE";
  v6 = 6LL;
  v7 = a4;
  do
  {
    if ( !v6 )
      break;
    a1 = *a4 < (const unsigned __int8)*v5;
    a2 = *a4++ == *v5++;
    --v6;
  }
  while ( a2 );
  v8 = (!a1 && !a2) - a1;
  v9 = 0;
  v10 = v8 == 0;
  if ( !v8 )
  {
    v11 = (char *)&unk_F4B6A;
    if ( !*(_BYTE *)(v4 + 4525) )
      v11 = "^H";
    return sub_BC120(v11);
  }
  v13 = "IUTF8";
  v14 = 6LL;
  v15 = v7;
  do
  {
    if ( !v14 )
      break;
    v9 = *v15 < (const unsigned __int8)*v13;
    v10 = *v15++ == *v13++;
    --v14;
  }
  while ( v10 );
  v11 = 0LL;
  if ( (!v9 && !v10) != v9 )
    return sub_BC120(v11);
  v16 = "yes";
  if ( *(_DWORD *)(*(_QWORD *)(v4 + 4352) + 16LL) != 55 )
    v16 = "no";
  return sub_BC120(v16);
}

char *__usercall sub_ABA00@<rax>(bool a1@<cf>, bool a2@<zf>, __int64 a3@<rdi>, _BYTE *a4@<rsi>)
{
  __int64 v4; // r8
  const char *v5; // rdi
  signed __int64 v6; // rcx
  _BYTE *v7; // rdx
  char v8; // al
  bool v9; // cf
  bool v10; // zf
  char *v11; // rdi
  const char *v13; // rdi
  signed __int64 v14; // rcx
  _BYTE *v15; // rsi
  char *v16; // rdi

  v4 = *(_QWORD *)(a3 - 5624);
  v5 = "ERASE";
  v6 = 6LL;
  v7 = a4;
  do
  {
    if ( !v6 )
      break;
    a1 = *a4 < (const unsigned __int8)*v5;
    a2 = *a4++ == *v5++;
    --v6;
  }
  while ( a2 );
  v8 = (!a1 && !a2) - a1;
  v9 = 0;
  v10 = v8 == 0;
  if ( !v8 )
  {
    v11 = (char *)&unk_F4B6A;
    if ( !*(_BYTE *)(v4 + 4525) )
      v11 = "^H";
    return sub_BC120(v11);
  }
  v13 = "IUTF8";
  v14 = 6LL;
  v15 = v7;
  do
  {
    if ( !v14 )
      break;
    v9 = *v15 < (const unsigned __int8)*v13;
    v10 = *v15++ == *v13++;
    --v14;
  }
  while ( v10 );
  v11 = 0LL;
  if ( (!v9 && !v10) != v9 )
    return sub_BC120(v11);
  v16 = "yes";
  if ( *(_DWORD *)(*(_QWORD *)(v4 + 4352) + 16LL) != 55 )
    v16 = "no";
  return sub_BC120(v16);
}

char *__usercall sub_ABA00@<rax>(bool a1@<cf>, bool a2@<zf>, __int64 a3@<rdi>, _BYTE *a4@<rsi>)
{
  __int64 v4; // r8
  const char *v5; // rdi
  signed __int64 v6; // rcx
  _BYTE *v7; // rdx
  char v8; // al
  bool v9; // cf
  bool v10; // zf
  char *v11; // rdi
  const char *v13; // rdi
  signed __int64 v14; // rcx
  _BYTE *v15; // rsi
  char *v16; // rdi

  v4 = *(_QWORD *)(a3 - 5624);
  v5 = "ERASE";
  v6 = 6LL;
  v7 = a4;
  do
  {
    if ( !v6 )
      break;
    a1 = *a4 < (const unsigned __int8)*v5;
    a2 = *a4++ == *v5++;
    --v6;
  }
  while ( a2 );
  v8 = (!a1 && !a2) - a1;
  v9 = 0;
  v10 = v8 == 0;
  if ( !v8 )
  {
    v11 = (char *)&unk_F4B6A;
    if ( !*(_BYTE *)(v4 + 4525) )
      v11 = "^H";
    return sub_BC120(v11);
  }
  v13 = "IUTF8";
  v14 = 6LL;
  v15 = v7;
  do
  {
    if ( !v14 )
      break;
    v9 = *v15 < (const unsigned __int8)*v13;
    v10 = *v15++ == *v13++;
    --v14;
  }
  while ( v10 );
  v11 = 0LL;
  if ( (!v9 && !v10) != v9 )
    return sub_BC120(v11);
  v16 = "yes";
  if ( *(_DWORD *)(*(_QWORD *)(v4 + 4352) + 16LL) != 55 )
    v16 = "no";
  return sub_BC120(v16);
}

__int64 __fastcall sub_ABA10(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // r13
  const __m128i *v5; // rbx
  const char *v6; // rsi
  __int64 v7; // rdi
  __int64 v9; // r14
  signed int v10; // er15
  __int64 v11; // r12
  __m128i *v12; // ST10_8
  __int64 v13; // rax
  __int64 v14; // rax
  int v15; // eax
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // r12
  __int64 v19; // r15
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // [rsp+8h] [rbp-50h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 - 5632);
  v3 = gtk_container_get_type(a1);
  v4 = v3;
  if ( !v2 )
  {
    v23 = g_type_check_instance_cast(*(_QWORD *)(a1 - 9472), v3);
    gtk_container_foreach(v23, &gtk_widget_destroy, 0LL);
    goto LABEL_3;
  }
  v5 = (const __m128i *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 56LL))(v2);
  v6 = (const char *)&gtk_widget_destroy;
  v7 = g_type_check_instance_cast(*(_QWORD *)(a1 - 9472), v4);
  gtk_container_foreach(v7, &gtk_widget_destroy, 0LL);
  if ( !v5 )
  {
LABEL_3:
    gtk_widget_hide(*(_QWORD *)(v1 - 9464));
    return gtk_widget_hide(*(_QWORD *)(v1 - 9456));
  }
  v9 = *(_QWORD *)(v1 - 9472);
  v10 = 1;
  v24 = 0LL;
  while ( 1 )
  {
    v15 = v5->m128i_i64[1];
    if ( v15 == 31 )
    {
      if ( v10 != 1 )
        __assert_fail("nesting < 2", "unix/gtkwin.c", 0x133Eu, "gtk_seat_update_specials_menu");
      v16 = gtk_menu_new(v7);
      v17 = v5->m128i_i64[0];
      v18 = v16;
      v19 = gtk_menu_item_new_with_label(v5->m128i_i64[0]);
      v20 = gtk_menu_item_get_type(v17, v6);
      v21 = g_type_check_instance_cast(v19, v20);
      gtk_menu_item_set_submenu(v21, v18);
      v22 = g_type_check_instance_cast(v9, v4);
      v6 = (const char *)v19;
      gtk_container_add(v22, v19);
      v7 = v19;
      v10 = 2;
      gtk_widget_show(v7);
      v24 = v9;
      v9 = v18;
      goto LABEL_10;
    }
    if ( v15 == 32 )
      break;
    if ( v15 == 30 )
    {
      v11 = gtk_menu_item_new(v7, v6);
    }
    else
    {
      v11 = gtk_menu_item_new_with_label(v5->m128i_i64[0]);
      v12 = (__m128i *)sub_2F450(1uLL, 0x10uLL, 0LL);
      *v12 = _mm_loadu_si128(v5);
      v13 = g_type_check_instance_cast(v11, 80LL);
      g_object_set_data_full(v13, "user-data", v12, sub_AB900);
      v6 = "activate";
      v7 = g_type_check_instance_cast(v11, 80LL);
      g_signal_connect_data(v7, "activate", sub_AC430, v1 - 9536, 0LL, 0LL);
    }
    if ( v11 )
    {
      v14 = g_type_check_instance_cast(v9, v4);
      v6 = (const char *)v11;
      gtk_container_add(v14, v11);
      v7 = v11;
      gtk_widget_show(v11);
    }
LABEL_10:
    ++v5;
  }
  if ( v10 != 1 )
  {
    v9 = v24;
    v10 = 1;
    v24 = 0LL;
    goto LABEL_10;
  }
  gtk_widget_show(*(_QWORD *)(v1 - 9464));
  return gtk_widget_show(*(_QWORD *)(v1 - 9456));
}

__int64 __fastcall sub_ABCA0(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  __int64 *v3; // rdi
  int v4; // eax
  __int64 *v5; // rdi
  __int64 result; // rax

  v1 = a1;
  v2 = sub_1EFD0(*(__int64 **)(a1 + 9336), 146);
  v3 = *(__int64 **)(a1 + 9336);
  *(_DWORD *)(v1 + 9408) = v2;
  v4 = sub_1EFD0(v3, 136);
  v5 = *(__int64 **)(v1 + 9336);
  *(_DWORD *)(v1 + 9412) = v4;
  result = sub_1EFD0(v5, 108);
  *(_DWORD *)(v1 + 9424) = 8;
  *(_DWORD *)(v1 + 9416) = result;
  return result;
}

void __fastcall sub_ABD00(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rdi
  __int64 v3; // rdi
  __int64 v4; // rdi

  v1 = (_QWORD *)a1;
  *(_BYTE *)(a1 + 3928) = 1;
  v2 = *(_QWORD **)(a1 + 3896);
  if ( v2 )
  {
    sub_2C040(v2);
    v1[487] = 0LL;
  }
  v3 = v1[488];
  if ( v3 )
  {
    (*(void (**)(void))(*(_QWORD *)v3 + 8LL))();
    v1[488] = 0LL;
  }
  v4 = v1[489];
  if ( v4 )
    sub_90B30(v4, 0LL);
  if ( v1[7] )
  {
    (*(void (__fastcall **)(_QWORD *))(v1[1192] + 40LL))(v1 + 1192);
    gtk_widget_set_sensitive(v1[11], 1LL);
  }
}

void __fastcall sub_ABD90(__int64 a1)
{
  sub_ABD00(a1);
}

void __fastcall sub_ABDA0(__int64 a1)
{
  int v1; // ebp
  int v2; // eax

  if ( !*(_BYTE *)(a1 + 3928) )
  {
    v1 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 3904) + 72LL))();
    if ( v1 >= 0 )
    {
      sub_ABD00(a1);
      v2 = sub_1EFD0(*(__int64 **)(a1 + 9336), 4);
      if ( !v2 || v2 == 2 && !v1 )
        gtk_widget_destroy(*(_QWORD *)a1);
    }
  }
}

__int64 __fastcall sub_ABE20(__int64 a1, unsigned __int8 a2, unsigned __int64 a3, __int64 a4)
{
  return sub_99540(*(_QWORD *)(a1 - 5624), a2, a3, a4);
}

signed __int64 __fastcall sub_ABE30(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rax

  a2 = (unsigned int)a2;
  result = 0LL;
  v3 = *(_QWORD *)(a1 + 8LL * (unsigned int)a2 + 9360);
  if ( v3 )
  {
    v4 = gtk_window_get_type(a1, a2);
    v5 = v4;
    v6 = g_type_check_instance_cast(v3, v4);
    gtk_window_deiconify(v6, v5);
    v7 = gtk_widget_get_window(v3);
    gdk_window_raise(v7);
    result = 1LL;
  }
  return result;
}

_QWORD *__fastcall sub_ABE80(__int64 a1, __int64 a2)
{
  return sub_97DA0(*(_QWORD *)(a2 + 3912), 3);
}

__int64 __fastcall sub_ABEA0(__int64 a1, __int64 a2)
{
  return sub_97D00(*(_QWORD *)(a2 + 3912), (unsigned int *)&unk_F9050, 1);
}

__int64 __fastcall sub_ABEC0(__int64 a1, const char *a2)
{
  size_t v2; // rax

  v2 = strlen(a2);
  (**(void (__fastcall ***)(signed __int64, signed __int64, const char *, size_t))(a1 - 16))(a1 - 16, 1LL, a2, v2);
  return (**(__int64 (__fastcall ***)(signed __int64, signed __int64, char *, signed __int64))(a1 - 16))(
           a1 - 16,
           1LL,
           "\r\n",
           2LL);
}

signed __int64 __fastcall sub_ABF10(__int64 a1)
{
  return sub_90EF0(*(_QWORD *)(a1 - 5632));
}

__int64 __fastcall sub_ABF20(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rdi
  _QWORD *v5; // rdi
  FILE **v6; // rdi
  __int64 v7; // rdi
  __int64 v8; // rax

  v2 = a2 + 1170;
  *a2 = 0LL;
  do
  {
    if ( *v2 )
    {
      gtk_widget_destroy(*v2);
      *v2 = 0LL;
    }
    ++v2;
  }
  while ( v2 != a2 + 1175 );
  if ( *a2 )
  {
    gtk_widget_destroy(*a2);
    *a2 = 0LL;
  }
  v3 = a2[7];
  if ( v3 )
  {
    gtk_widget_destroy(v3);
    a2[7] = 0LL;
  }
  sub_ABD00((__int64)a2);
  v4 = a2[489];
  if ( v4 )
  {
    sub_908E0(v4);
    a2[489] = 0LL;
  }
  v5 = (_QWORD *)a2[1167];
  if ( v5 )
  {
    sub_1ED50(v5);
    a2[1167] = 0LL;
  }
  v6 = (FILE **)a2[490];
  if ( v6 )
  {
    sub_2DA60(v6);
    a2[490] = 0LL;
  }
  v7 = a2[1190];
  if ( v7 )
  {
    v8 = g_type_check_instance_cast(v7, 80LL);
    g_object_unref(v8, 80LL);
    a2[1190] = 0LL;
  }
  sub_1BCD0((__int64)a2);
  sub_A39B0(a2[1168]);
  sub_2F4D0(a2);
  return j__gtk_main_quit((__int64)a2);
}

signed __int64 __fastcall sub_AC030(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  _QWORD *v4; // rax
  int v5; // ecx
  __int64 v6; // rbx
  signed __int64 v7; // r12
  signed __int64 v8; // r12
  __int64 v9; // rbp
  void *v10; // rdi
  void *v11; // rdi
  void *v12; // rdi
  __int64 v13; // rdx

  v3 = *(_QWORD *)(a2 + 24);
  v4 = (_QWORD *)(a3 + 3376);
  v5 = 0;
  while ( a3 != *v4 || v3 != v4[2] )
  {
    ++v5;
    v4 += 8;
    if ( v5 == 7 )
      return 1LL;
  }
  v6 = v5;
  v7 = (signed __int64)v5 << 6;
  if ( a3 + v7 != -3376 )
  {
    v8 = a3 + v7;
    v9 = a3;
    sub_994E0(*(const __m128i **)(a3 + 3912), *(unsigned int *)(v8 + 3384));
    v10 = *(void **)(v8 + 3400);
    if ( v10 )
      sub_2F4D0(v10);
    v11 = *(void **)(v9 + (v6 << 6) + 3408);
    if ( v11 )
      sub_2F4D0(v11);
    v12 = *(void **)(v9 + (v6 << 6) + 3416);
    if ( v12 )
      sub_2F4D0(v12);
    *(_QWORD *)(v8 + 3400) = 0LL;
    v13 = v9 + (v6 << 6);
    *(_DWORD *)(v13 + 3424) = 0;
    *(_QWORD *)(v13 + 3408) = 0LL;
    *(_DWORD *)(v13 + 3428) = 0;
    *(_QWORD *)(v13 + 3416) = 0LL;
    *(_DWORD *)(v13 + 3432) = 0;
  }
  return 1LL;
}

signed __int64 __fastcall sub_AC140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rbp
  __int64 v6; // r12
  signed __int64 result; // rax
  _QWORD *v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // rcx
  signed __int64 v12; // rbp
  signed __int64 v13; // rbp

  v5 = a5;
  v6 = gtk_selection_data_get_target(a2);
  result = gtk_selection_data_get_selection(a2);
  v8 = (_QWORD *)(v5 + 3376);
  LODWORD(v9) = 0;
  while ( v5 != *v8 || result != v8[2] )
  {
    LODWORD(v9) = v9 + 1;
    v8 += 8;
    if ( (_DWORD)v9 == 7 )
      return result;
  }
  v9 = (signed int)v9;
  result = (signed __int64)(signed int)v9 << 6;
  if ( v5 + result != -3376 )
  {
    if ( qword_326548 == v6 )
    {
      v13 = result + v5;
      v10 = *(unsigned int *)(v13 + 3432);
      v11 = *(_QWORD *)(v13 + 3416);
    }
    else if ( qword_326540 == v6 )
    {
      v12 = result + v5;
      v10 = *(unsigned int *)(v12 + 3428);
      v11 = *(_QWORD *)(v12 + 3408);
    }
    else
    {
      v10 = *(unsigned int *)(v5 + result + 3424);
      v11 = *(_QWORD *)(v5 + ((v9 + 53) << 6) + 8);
    }
    result = gtk_selection_data_set(a2, v6, 8LL, v11, v10);
  }
  return result;
}

unsigned __int64 __fastcall sub_AC220(__int64 a1, __int64 a2)
{
  int *v2; // rbx
  _QWORD *v3; // rbp
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // esi
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  int v12; // eax
  int v13; // ecx
  int v15; // esi
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // [rsp+8h] [rbp-40h]
  int v21; // [rsp+Ch] [rbp-3Ch]
  __int64 v22; // [rsp+10h] [rbp-38h]
  __int64 v23; // [rsp+18h] [rbp-30h]
  unsigned __int64 v24; // [rsp+28h] [rbp-20h]

  v2 = (int *)a2;
  v3 = (_QWORD *)a1;
  *(_QWORD *)(a2 + 8) = -1LL;
  v4 = *(_DWORD *)(a1 + 3832);
  v24 = __readfsqword(0x28u);
  v5 = *(_DWORD *)(a1 + 9412);
  *(_QWORD *)(a2 + 40) = 0LL;
  *(_QWORD *)(a2 + 32) = 0LL;
  v5 *= 2;
  *(_DWORD *)a2 = v4 + v5;
  v6 = *(_DWORD *)(a1 + 3836);
  *(_DWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 20) = v5;
  *(_DWORD *)(a2 + 24) = v4;
  v7 = v5 + v6;
  v8 = *(_DWORD *)(a1 + 24);
  v2[7] = v6;
  v2[1] = v7;
  if ( v8 )
  {
    a1 = *(_QWORD *)(a1 + 16);
    gtk_widget_get_preferred_size(a1, &v20, 0LL);
    v15 = v2[7];
    v16 = v21 + v15 - 1;
    v17 = (v21 + v15 - 1 - v2[5] % v15) % v15;
    v18 = v20;
    *v2 += v20;
    v2[4] += v18;
    v19 = v16 - v17;
    if ( v2[1] < v19 )
      v2[1] = v19;
  }
  v9 = v3[1];
  v23 = 0LL;
  v22 = v9;
  v10 = gtk_container_get_type(a1);
  v11 = g_type_check_instance_cast(*v3, v10);
  gtk_container_foreach(v11, sub_AC370, &v22);
  if ( v23 )
  {
    gtk_widget_get_preferred_size(v23, 0LL, &v20);
    v12 = v21;
    v2[1] += v21;
    v2[5] += v12;
    v13 = v20 + v2[6] - 1 - (v20 + v2[6] - 1 - v2[4] % v2[6]) % v2[6];
    if ( *v2 < v13 )
      *v2 = v13;
  }
  return __readfsqword(0x28u) ^ v24;
}

void __fastcall sub_AC370(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  if ( (_QWORD *)*a2 != a1 )
  {
    v2 = gtk_menu_bar_get_type();
    if ( a1 )
    {
      if ( *a1 && *(_QWORD *)*a1 == v2 || (unsigned int)g_type_check_instance_is_a(a1, v2) )
        a2[1] = a1;
    }
  }
}

void __fastcall sub_AC3C0(__int64 a1, __int64 a2)
{
  sub_906E0(*(const __m128i **)(a2 + 3912));
}

__int64 __fastcall sub_AC3D0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdi

  result = sub_923A0(*(_QWORD *)(a2 + 3912), 1);
  v3 = *(_QWORD *)(a2 + 3896);
  if ( v3 )
    result = sub_2C080(v3);
  return result;
}

__int64 __fastcall sub_AC410(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  __int64 v4; // rbp
  unsigned int v5; // eax
  __int64 v6; // ST00_8
  __int64 v8; // rdi

  v8 = *(_QWORD *)(a2 + 3912);
  v2 = *(_QWORD *)(v8 + 16);
  v3 = *(_QWORD *)(a2 + 3912);
  v4 = (unsigned int)-sub_8A550(v8);
  v5 = sub_8B960(v8, v2);
  sub_8DA80(v3, v4, ((unsigned __int64)*(unsigned int *)(v3 + 416) << 32) | v5, 0, 1u, (unsigned int *)&unk_F9048, 2);
  return v6;
}

__int64 __fastcall sub_AC410(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  __int64 v4; // rbp
  unsigned int v5; // eax
  __int64 v6; // ST00_8
  __int64 v8; // rdi

  v8 = *(_QWORD *)(a2 + 3912);
  v2 = *(_QWORD *)(v8 + 16);
  v3 = *(_QWORD *)(a2 + 3912);
  v4 = (unsigned int)-sub_8A550(v8);
  v5 = sub_8B960(v8, v2);
  sub_8DA80(v3, v4, ((unsigned __int64)*(unsigned int *)(v3 + 416) << 32) | v5, 0, 1u, (unsigned int *)&unk_F9048, 2);
  return v6;
}

__int64 __fastcall sub_AC430(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // rdi

  v2 = g_type_check_instance_cast(a1, 80LL);
  result = g_object_get_data(v2, "user-data");
  v4 = *(_QWORD *)(a2 + 3904);
  if ( v4 )
    result = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v4 + 48LL))(
               v4,
               *(unsigned int *)(result + 8),
               *(unsigned int *)(result + 12));
  return result;
}

void __fastcall sub_AC480(__int64 a1)
{
  __int64 v1; // rax
  void *v2; // rax

  v1 = g_type_check_instance_cast(a1, 80LL);
  v2 = (void *)g_object_get_data(v1, "user-data");
  sub_2F4D0(v2);
}

__int64 __fastcall sub_AC4B0(__int64 a1, __int64 *a2)
{
  __int64 v3; // rdi

  v3 = *a2;
  JUMPOUT(qword_3264B8, 0LL, sub_A3238);
  return gtk_widget_grab_focus(qword_3264B8);
}

__int64 __fastcall sub_9B4A0(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdi
  __int64 result; // rax

  if ( a4 == 1 )
  {
    v4 = *(_QWORD *)(a1 + 32);
    JUMPOUT(qword_3264B8, 0LL, sub_A3238);
    result = gtk_widget_grab_focus(qword_3264B8);
  }
  return result;
}

__int64 __fastcall sub_AC4C0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 *a10)
{
  return sub_A3560(a10[1168], *a10, a1, a2, a3, a4, a5, a6, a7, a8);
}

unsigned __int64 __usercall sub_AC4D0@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rsi>, __int64 a4@<r12>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  signed __int64 v10; // rbx
  __int64 v14; // r9
  int v15; // ebp
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v22; // rdi
  int pipedes[2]; // [rsp+0h] [rbp-80h]
  char v24; // [rsp+8h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  __int64 v28; // [rsp+78h] [rbp-8h]

  v22 = *(_QWORD **)(a3 + 9336);
  v28 = a4;
  v27 = a2;
  v26 = a1;
  v25 = __readfsqword(0x28u);
  if ( pipe(pipedes) < 0 )
  {
    perror("pipe");
  }
  else
  {
    v10 = sub_BC640();
    sub_1FC20(v10 + 24, v22);
    v14 = *(_QWORD *)(v10 + 16);
    __sprintf_chk(&v24, 1LL, 80LL, "---[%d,%zu]", (unsigned int)pipedes[0]);
    sub_B4FD0(pipedes[0]);
    v15 = 0;
    sub_AA0E0(pipedes[1], a5, a6, a7, a8, v16, v17, a9, a10, &v24, 0LL);
    close(pipedes[0]);
    v18 = *(_QWORD *)(v10 + 16);
    v19 = 0LL;
    if ( v18 )
    {
      while ( 1 )
      {
        v20 = write(pipedes[1], (const void *)(*(_QWORD *)v10 + v19), v18 - v19);
        if ( v20 <= 0 )
          break;
        v18 = *(_QWORD *)(v10 + 16);
        v15 += v20;
        v19 = v15;
        if ( v15 >= v18 )
          goto LABEL_10;
      }
      if ( v20 )
        perror("write to pipe");
    }
LABEL_10:
    close(pipedes[1]);
    sub_BC660((void **)v10);
  }
  return __readfsqword(0x28u) ^ v25;
}

unsigned __int64 __usercall sub_AC4D0@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rsi>, __int64 a4@<r12>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  signed __int64 v10; // rbx
  __int64 v14; // r9
  int v15; // ebp
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v22; // rdi
  int pipedes[2]; // [rsp+0h] [rbp-80h]
  char v24; // [rsp+8h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  __int64 v28; // [rsp+78h] [rbp-8h]

  v22 = *(_QWORD **)(a3 + 9336);
  v28 = a4;
  v27 = a2;
  v26 = a1;
  v25 = __readfsqword(0x28u);
  if ( pipe(pipedes) < 0 )
  {
    perror("pipe");
  }
  else
  {
    v10 = sub_BC640();
    sub_1FC20(v10 + 24, v22);
    v14 = *(_QWORD *)(v10 + 16);
    __sprintf_chk(&v24, 1LL, 80LL, "---[%d,%zu]", (unsigned int)pipedes[0]);
    sub_B4FD0(pipedes[0]);
    v15 = 0;
    sub_AA0E0(pipedes[1], a5, a6, a7, a8, v16, v17, a9, a10, &v24, 0LL);
    close(pipedes[0]);
    v18 = *(_QWORD *)(v10 + 16);
    v19 = 0LL;
    if ( v18 )
    {
      while ( 1 )
      {
        v20 = write(pipedes[1], (const void *)(*(_QWORD *)v10 + v19), v18 - v19);
        if ( v20 <= 0 )
          break;
        v18 = *(_QWORD *)(v10 + 16);
        v15 += v20;
        v19 = v15;
        if ( v15 >= v18 )
          goto LABEL_10;
      }
      if ( v20 )
        perror("write to pipe");
    }
LABEL_10:
    close(pipedes[1]);
    sub_BC660((void **)v10);
  }
  return __readfsqword(0x28u) ^ v25;
}

unsigned __int64 __usercall sub_AC4D0@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rsi>, __int64 a4@<r12>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  signed __int64 v10; // rbx
  __int64 v14; // r9
  int v15; // ebp
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v22; // rdi
  int pipedes[2]; // [rsp+0h] [rbp-80h]
  char v24; // [rsp+8h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  __int64 v28; // [rsp+78h] [rbp-8h]

  v22 = *(_QWORD **)(a3 + 9336);
  v28 = a4;
  v27 = a2;
  v26 = a1;
  v25 = __readfsqword(0x28u);
  if ( pipe(pipedes) < 0 )
  {
    perror("pipe");
  }
  else
  {
    v10 = sub_BC640();
    sub_1FC20(v10 + 24, v22);
    v14 = *(_QWORD *)(v10 + 16);
    __sprintf_chk(&v24, 1LL, 80LL, "---[%d,%zu]", (unsigned int)pipedes[0]);
    sub_B4FD0(pipedes[0]);
    v15 = 0;
    sub_AA0E0(pipedes[1], a5, a6, a7, a8, v16, v17, a9, a10, &v24, 0LL);
    close(pipedes[0]);
    v18 = *(_QWORD *)(v10 + 16);
    v19 = 0LL;
    if ( v18 )
    {
      while ( 1 )
      {
        v20 = write(pipedes[1], (const void *)(*(_QWORD *)v10 + v19), v18 - v19);
        if ( v20 <= 0 )
          break;
        v18 = *(_QWORD *)(v10 + 16);
        v15 += v20;
        v19 = v15;
        if ( v15 >= v18 )
          goto LABEL_10;
      }
      if ( v20 )
        perror("write to pipe");
    }
LABEL_10:
    close(pipedes[1]);
    sub_BC660((void **)v10);
  }
  return __readfsqword(0x28u) ^ v25;
}

unsigned __int64 __usercall sub_AC4D0@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rsi>, __int64 a4@<r12>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  signed __int64 v10; // rbx
  __int64 v14; // r9
  int v15; // ebp
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v22; // rdi
  int pipedes[2]; // [rsp+0h] [rbp-80h]
  char v24; // [rsp+8h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  __int64 v28; // [rsp+78h] [rbp-8h]

  v22 = *(_QWORD **)(a3 + 9336);
  v28 = a4;
  v27 = a2;
  v26 = a1;
  v25 = __readfsqword(0x28u);
  if ( pipe(pipedes) < 0 )
  {
    perror("pipe");
  }
  else
  {
    v10 = sub_BC640();
    sub_1FC20(v10 + 24, v22);
    v14 = *(_QWORD *)(v10 + 16);
    __sprintf_chk(&v24, 1LL, 80LL, "---[%d,%zu]", (unsigned int)pipedes[0]);
    sub_B4FD0(pipedes[0]);
    v15 = 0;
    sub_AA0E0(pipedes[1], a5, a6, a7, a8, v16, v17, a9, a10, &v24, 0LL);
    close(pipedes[0]);
    v18 = *(_QWORD *)(v10 + 16);
    v19 = 0LL;
    if ( v18 )
    {
      while ( 1 )
      {
        v20 = write(pipedes[1], (const void *)(*(_QWORD *)v10 + v19), v18 - v19);
        if ( v20 <= 0 )
          break;
        v18 = *(_QWORD *)(v10 + 16);
        v15 += v20;
        v19 = v15;
        if ( v15 >= v18 )
          goto LABEL_10;
      }
      if ( v20 )
        perror("write to pipe");
    }
LABEL_10:
    close(pipedes[1]);
    sub_BC660((void **)v10);
  }
  return __readfsqword(0x28u) ^ v25;
}

unsigned __int64 __usercall sub_AC4D0@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rsi>, __int64 a4@<r12>, double a5@<xmm0>, double a6@<xmm1>, double a7@<xmm2>, double a8@<xmm3>, double a9@<xmm6>, double a10@<xmm7>)
{
  signed __int64 v10; // rbx
  __int64 v14; // r9
  int v15; // ebp
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  int v20; // eax
  _QWORD *v22; // rdi
  int pipedes[2]; // [rsp+0h] [rbp-80h]
  char v24; // [rsp+8h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  __int64 v28; // [rsp+78h] [rbp-8h]

  v22 = *(_QWORD **)(a3 + 9336);
  v28 = a4;
  v27 = a2;
  v26 = a1;
  v25 = __readfsqword(0x28u);
  if ( pipe(pipedes) < 0 )
  {
    perror("pipe");
  }
  else
  {
    v10 = sub_BC640();
    sub_1FC20(v10 + 24, v22);
    v14 = *(_QWORD *)(v10 + 16);
    __sprintf_chk(&v24, 1LL, 80LL, "---[%d,%zu]", (unsigned int)pipedes[0]);
    sub_B4FD0(pipedes[0]);
    v15 = 0;
    sub_AA0E0(pipedes[1], a5, a6, a7, a8, v16, v17, a9, a10, &v24, 0LL);
    close(pipedes[0]);
    v18 = *(_QWORD *)(v10 + 16);
    v19 = 0LL;
    if ( v18 )
    {
      while ( 1 )
      {
        v20 = write(pipedes[1], (const void *)(*(_QWORD *)v10 + v19), v18 - v19);
        if ( v20 <= 0 )
          break;
        v18 = *(_QWORD *)(v10 + 16);
        v15 += v20;
        v19 = v15;
        if ( v15 >= v18 )
          goto LABEL_10;
      }
      if ( v20 )
        perror("write to pipe");
    }
LABEL_10:
    close(pipedes[1]);
    sub_BC660((void **)v10);
  }
  return __readfsqword(0x28u) ^ v25;
}

__int64 __fastcall sub_AC4E0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  return sub_AA510(a1, a2, a3, a4, a5, a6, a7, a8);
}

unsigned __int64 __fastcall sub_AC4F0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbx
  __int64 v10; // r13
  __int64 *v11; // rdi
  void **v12; // r14
  __int64 v13; // r12
  __int64 v14; // rbp
  __int64 v15; // r15
  __int64 v16; // rax
  __int64 v17; // rax
  double v18; // xmm4_8
  double v19; // xmm5_8
  void *v20; // rbp
  __int64 v21; // rax
  __int64 v23; // rax
  __int64 v24; // rdi
  char *v25; // [rsp+0h] [rbp-48h]
  unsigned __int64 v26; // [rsp+8h] [rbp-40h]

  v9 = a1;
  v10 = a1 + 9536;
  v11 = *(__int64 **)(a1 + 9336);
  v26 = __readfsqword(0x28u);
  v12 = sub_B8570(v11);
  (*(void (__fastcall **)(__int64, signed __int64))(*(_QWORD *)(v9 + 9536) + 136LL))(v10, 1LL);
  v13 = (unsigned __int8)sub_1EF00(*(__int64 **)(v9 + 9336), 8);
  v14 = (unsigned __int8)sub_1EF00(*(__int64 **)(v9 + 9336), 7);
  v15 = (unsigned int)sub_1EFD0(*(__int64 **)(v9 + 9336), 1);
  v16 = sub_1F170(*(__int64 **)(v9 + 9336), 0);
  v17 = ((__int64 (__fastcall *)(void **, __int64, __int64, _QWORD, _QWORD, __int64, __int64, char **, __int64, __int64))*v12)(
          v12,
          v10,
          v9 + 3904,
          *(_QWORD *)(v9 + 3920),
          *(_QWORD *)(v9 + 9336),
          v16,
          v15,
          &v25,
          v14,
          v13);
  if ( v17 )
  {
    v20 = (void *)v17;
    v21 = sub_31D00(*(__int64 **)(v9 + 9336));
    sub_31A30(v10, (__int64)"Unable to open connection to %s:\n%s", v21, v20);
    sub_2F4D0(v20);
    *(_BYTE *)(v9 + 3928) = 1;
  }
  else
  {
    sub_907E0(*(_QWORD *)(v9 + 3912), v25, a2, a3, a4, a5, v18, v19, a8, a9);
    sub_2F4D0(v25);
    sub_90B30(*(_QWORD *)(v9 + 3912), *(_QWORD *)(v9 + 3904));
    v23 = sub_2BFB0(*(__int64 **)(v9 + 9336), *(_QWORD *)(v9 + 3912), *(_QWORD *)(v9 + 3904), v10);
    v24 = *(_QWORD *)(v9 + 88);
    *(_QWORD *)(v9 + 3896) = v23;
    gtk_widget_set_sensitive(v24, 0LL);
  }
  return __readfsqword(0x28u) ^ v26;
}

__int64 __fastcall sub_AC680(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9; // xmm4_8
  double v10; // xmm5_8
  __int64 v12; // rax
  __int64 v13; // rax

  v12 = g_type_check_instance_cast(a1, 80LL);
  v13 = g_object_get_data(v12, "user-data");
  return sub_AA0E0(-1, a2, a3, a4, a5, v9, v10, a8, a9, "-load", v13, 0LL);
}

__int64 __fastcall sub_AC680(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9; // xmm4_8
  double v10; // xmm5_8
  __int64 v12; // rax
  __int64 v13; // rax

  v12 = g_type_check_instance_cast(a1, 80LL);
  v13 = g_object_get_data(v12, "user-data");
  return sub_AA0E0(-1, a2, a3, a4, a5, v9, v10, a8, a9, "-load", v13, 0LL);
}

__int64 __fastcall sub_AC6B0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er13
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rax

  v3 = a3;
  v4 = gtk_window_get_type(a1, a2);
  v5 = v4;
  v6 = g_type_check_instance_cast(*(_QWORD *)(a1 - 9544), v4);
  gtk_window_set_gravity(v6, 3LL);
  v7 = g_type_check_instance_cast(*(_QWORD *)(a1 - 9544), v5);
  return gtk_window_move(v7, (unsigned int)a2, v3);
}

void __fastcall sub_AC710(__int64 a1, __int64 a2, __int64 a3)
{
  *(_BYTE *)(*(_QWORD *)(a3 + 3912) + 4672LL) = (*(_DWORD *)(a2 + 24) >> 1) & 1;
}

void __fastcall sub_AC710(__int64 a1, __int64 a2, __int64 a3)
{
  *(_BYTE *)(*(_QWORD *)(a3 + 3912) + 4672LL) = (*(_DWORD *)(a2 + 24) >> 1) & 1;
}

unsigned __int64 __fastcall sub_AC730(__int64 a1, __int64 a2)
{
  signed int v2; // er15
  signed __int64 v3; // rbp
  __int64 v4; // rax
  __int64 v5; // r13
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  char *v9; // rdi
  char *v10; // r14
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  int v17; // [rsp+10h] [rbp-58h]
  __int64 v18; // [rsp+18h] [rbp-50h]
  unsigned __int64 v19; // [rsp+28h] [rbp-40h]

  v2 = 1;
  v3 = 8LL;
  v19 = __readfsqword(0x28u);
  v4 = gtk_container_get_type(a1);
  v5 = v4;
  v6 = g_type_check_instance_cast(*(_QWORD *)(a2 + 96), v4);
  gtk_container_foreach(v6, &gtk_widget_destroy, 0LL);
  sub_40A70((__int64)&v17, 1LL);
  if ( v17 <= 1 )
    goto LABEL_8;
  do
  {
    ++v2;
    v7 = gtk_menu_item_new_with_label(*(_QWORD *)(v18 + v3));
    v8 = g_type_check_instance_cast(*(_QWORD *)(a2 + 96), v5);
    gtk_container_add(v8, v7);
    gtk_widget_show(v7);
    v9 = *(char **)(v18 + v3);
    v3 += 8LL;
    v10 = sub_BC120(v9);
    v11 = g_type_check_instance_cast(v7, 80LL);
    g_object_set_data(v11, "user-data", v10);
    v12 = g_type_check_instance_cast(v7, 80LL);
    g_signal_connect_data(v12, "activate", sub_AC680, a2, 0LL, 0LL);
    v13 = g_type_check_instance_cast(v7, 80LL);
    g_signal_connect_data(v13, "destroy", sub_AC480, a2, 0LL, 0LL);
  }
  while ( v17 > v2 );
  if ( v17 <= 1 )
  {
LABEL_8:
    v15 = gtk_menu_item_new_with_label("(No sessions)");
    gtk_widget_set_sensitive(v15, 0LL);
    v16 = g_type_check_instance_cast(*(_QWORD *)(a2 + 96), v5);
    gtk_container_add(v16, v15);
    gtk_widget_show(v15);
  }
  sub_40A70((__int64)&v17, 0LL);
  return __readfsqword(0x28u) ^ v19;
}

__int64 __fastcall sub_AC8F0(__int64 a1, int *a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbp

  v3 = *(_QWORD *)(a3 + 3912);
  if ( v3 )
  {
    v4 = a3;
    sub_99B90(v3, a2[5], a2[6]);
    sub_99BA0(*(_QWORD *)(v4 + 3912), a2[7], a2[8]);
  }
  return 0LL;
}

signed __int64 __fastcall sub_AC940(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // r14
  char *v6; // r13
  char *v7; // r12
  _QWORD *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 v12; // r14
  int v13; // eax
  __int64 v14; // rax

  v4 = a3;
  v5 = a4;
  v6 = sub_BC360(
         (__int64)"The session log file \"%.*s\" already exists. You can overwrite it with a new session log, append your"
                  " session log to the end of it, or disable session logging for this session.",
         4096LL,
         *a2);
  v7 = sub_BC360((__int64)"%s Log to File", "PuTTY");
  v8 = sub_2F450(1uLL, 0x20uLL, 0LL);
  *v8 = v4;
  v8[1] = v5;
  v9 = (__int64)v8;
  v8[2] = a1 - 16;
  *((_DWORD *)v8 + 6) = 2;
  v10 = gtk_widget_get_type(1LL, 32LL);
  v11 = sub_AF870(a1 - 16);
  v12 = g_type_check_instance_cast(v11, v10);
  v13 = sub_AB5C0((__int64)"LINE OF TEXT SUITABLE FOR THE ASKAPPEND WIDTH");
  v14 = sub_A1980(v12, (__int64)v7, v6, v13, 0, (__int64)&off_322510, (__int64)sub_9E030, v9, 0LL, 0LL);
  sub_AF880((__int64 (__fastcall ***)())(a1 - 16), *(_DWORD *)(v9 + 24), v14);
  sub_2F4D0(v6);
  sub_2F4D0(v7);
  return 0xFFFFFFFFLL;
}

signed __int64 __fastcall sub_AC940(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // r14
  char *v6; // r13
  char *v7; // r12
  _QWORD *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 v12; // r14
  int v13; // eax
  __int64 v14; // rax

  v4 = a3;
  v5 = a4;
  v6 = sub_BC360(
         (__int64)"The session log file \"%.*s\" already exists. You can overwrite it with a new session log, append your"
                  " session log to the end of it, or disable session logging for this session.",
         4096LL,
         *a2);
  v7 = sub_BC360((__int64)"%s Log to File", "PuTTY");
  v8 = sub_2F450(1uLL, 0x20uLL, 0LL);
  *v8 = v4;
  v8[1] = v5;
  v9 = (__int64)v8;
  v8[2] = a1 - 16;
  *((_DWORD *)v8 + 6) = 2;
  v10 = gtk_widget_get_type(1LL, 32LL);
  v11 = sub_AF870(a1 - 16);
  v12 = g_type_check_instance_cast(v11, v10);
  v13 = sub_AB5C0((__int64)"LINE OF TEXT SUITABLE FOR THE ASKAPPEND WIDTH");
  v14 = sub_A1980(v12, (__int64)v7, v6, v13, 0, (__int64)&off_322510, (__int64)sub_9E030, v9, 0LL, 0LL);
  sub_AF880((__int64 (__fastcall ***)())(a1 - 16), *(_DWORD *)(v9 + 24), v14);
  sub_2F4D0(v6);
  sub_2F4D0(v7);
  return 0xFFFFFFFFLL;
}

unsigned __int64 __usercall sub_AC950@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<rsi>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  __int64 v11; // rax
  void **v12; // r12
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  double v15; // xmm4_8
  double v16; // xmm5_8
  char *v17; // rax
  bool v18; // zf
  signed int v19; // eax
  signed int v20; // eax
  unsigned int v22; // edx
  _QWORD *v23; // rax
  signed __int64 v24; // rdx
  _QWORD *v25; // rax
  signed __int64 v26; // rdx
  int v27; // eax
  __int64 v28; // rdx
  char **v29; // rbx
  __int64 v30; // rdi
  __int128 v31; // [rsp+0h] [rbp-D8h]
  __int128 v32; // [rsp+10h] [rbp-C8h]
  __int128 v33; // [rsp+20h] [rbp-B8h]
  const char *v34; // [rsp+30h] [rbp-A8h]
  struct tm tp; // [rsp+40h] [rbp-98h]
  char s; // [rsp+80h] [rbp-58h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-30h]
  __int64 v38; // [rsp+B8h] [rbp-20h]
  __int64 v39; // [rsp+C0h] [rbp-18h]
  __int64 v40; // [rsp+C8h] [rbp-10h]
  __int64 v41; // [rsp+D0h] [rbp-8h]

  v30 = *(_QWORD *)(a3 - 208);
  v41 = a5;
  v40 = a4;
  v39 = a2;
  v38 = a1;
  v37 = __readfsqword(0x28u);
  v11 = *(signed int *)(v30 + 3248);
  if ( !(_DWORD)v11 )
  {
    v23 = sub_2F490(*(void **)(v30 + 3232), 0x80uLL, 8uLL);
    v24 = (signed __int64)(v23 + 128);
    *(_QWORD *)(v30 + 3232) = v23;
    do
    {
      *v23 = 0LL;
      ++v23;
    }
    while ( v23 != (_QWORD *)v24 );
    v25 = sub_2F490(*(void **)(v30 + 3240), 0x80uLL, 8uLL);
    v26 = (signed __int64)(v25 + 128);
    *(_QWORD *)(v30 + 3240) = v25;
    do
    {
      *v25 = 0LL;
      ++v25;
    }
    while ( (_QWORD *)v26 != v25 );
    v11 = *(signed int *)(v30 + 3248);
  }
  if ( (signed int)v11 > 127 )
  {
    v22 = (*(_DWORD *)(v30 + 3256) + *(_DWORD *)(v30 + 3252)) >> 31;
    v12 = (void **)(*(_QWORD *)(v30 + 3240)
                  + 8LL
                  * (signed int)((((v22 >> 25) + *(_BYTE *)(v30 + 3256) + *(_BYTE *)(v30 + 3252)) & 0x7F) - (v22 >> 25)));
  }
  else
  {
    v12 = (void **)(*(_QWORD *)(v30 + 3232) + 8 * v11);
  }
  sub_99BB0((__m128i *)&v31);
  *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v31);
  v13 = _mm_loadu_si128((const __m128i *)&v32);
  tp.tm_zone = v34;
  *(__m128i *)&tp.tm_mon = v13;
  v14 = _mm_loadu_si128((const __m128i *)&v33);
  *(__m128i *)&tp.tm_isdst = v14;
  strftime(&s, 0x28uLL, "%Y-%m-%d %H:%M:%S\t", &tp);
  sub_2F4D0(*v12);
  v17 = sub_BC160(&s, *(double *)v14.m128i_i64, a7, a8, a9, v15, v16, a10, a11, a6, 0LL);
  v18 = *(_QWORD *)(v30 + 8) == 0LL;
  *v12 = v17;
  if ( !v18 )
    sub_9F340(*(_QWORD *)(v30 + 3224), v30 + 3096, v17, 0);
  v19 = *(_DWORD *)(v30 + 3248);
  if ( v19 <= 127 )
  {
    *(_DWORD *)(v30 + 3248) = v19 + 1;
  }
  else
  {
    v20 = *(_DWORD *)(v30 + 3252);
    if ( v20 <= 127 )
    {
      *(_DWORD *)(v30 + 3252) = v20 + 1;
    }
    else if ( v20 == 128 )
    {
      v27 = (*(_DWORD *)(v30 + 3256) + 1) % 128;
      v28 = *(_QWORD *)(v30 + 3240);
      *(_DWORD *)(v30 + 3256) = v27;
      sub_2F4D0(*(void **)(v28 + 8LL * v27));
      v29 = (char **)(*(_QWORD *)(v30 + 3240) + 8LL * *(signed int *)(v30 + 3256));
      *v29 = sub_BC120("..");
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

unsigned __int64 __usercall sub_AC950@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<rsi>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  __int64 v11; // rax
  void **v12; // r12
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  double v15; // xmm4_8
  double v16; // xmm5_8
  char *v17; // rax
  bool v18; // zf
  signed int v19; // eax
  signed int v20; // eax
  unsigned int v22; // edx
  _QWORD *v23; // rax
  signed __int64 v24; // rdx
  _QWORD *v25; // rax
  signed __int64 v26; // rdx
  int v27; // eax
  __int64 v28; // rdx
  char **v29; // rbx
  __int64 v30; // rdi
  __int128 v31; // [rsp+0h] [rbp-D8h]
  __int128 v32; // [rsp+10h] [rbp-C8h]
  __int128 v33; // [rsp+20h] [rbp-B8h]
  const char *v34; // [rsp+30h] [rbp-A8h]
  struct tm tp; // [rsp+40h] [rbp-98h]
  char s; // [rsp+80h] [rbp-58h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-30h]
  __int64 v38; // [rsp+B8h] [rbp-20h]
  __int64 v39; // [rsp+C0h] [rbp-18h]
  __int64 v40; // [rsp+C8h] [rbp-10h]
  __int64 v41; // [rsp+D0h] [rbp-8h]

  v30 = *(_QWORD *)(a3 - 208);
  v41 = a5;
  v40 = a4;
  v39 = a2;
  v38 = a1;
  v37 = __readfsqword(0x28u);
  v11 = *(signed int *)(v30 + 3248);
  if ( !(_DWORD)v11 )
  {
    v23 = sub_2F490(*(void **)(v30 + 3232), 0x80uLL, 8uLL);
    v24 = (signed __int64)(v23 + 128);
    *(_QWORD *)(v30 + 3232) = v23;
    do
    {
      *v23 = 0LL;
      ++v23;
    }
    while ( v23 != (_QWORD *)v24 );
    v25 = sub_2F490(*(void **)(v30 + 3240), 0x80uLL, 8uLL);
    v26 = (signed __int64)(v25 + 128);
    *(_QWORD *)(v30 + 3240) = v25;
    do
    {
      *v25 = 0LL;
      ++v25;
    }
    while ( (_QWORD *)v26 != v25 );
    v11 = *(signed int *)(v30 + 3248);
  }
  if ( (signed int)v11 > 127 )
  {
    v22 = (*(_DWORD *)(v30 + 3256) + *(_DWORD *)(v30 + 3252)) >> 31;
    v12 = (void **)(*(_QWORD *)(v30 + 3240)
                  + 8LL
                  * (signed int)((((v22 >> 25) + *(_BYTE *)(v30 + 3256) + *(_BYTE *)(v30 + 3252)) & 0x7F) - (v22 >> 25)));
  }
  else
  {
    v12 = (void **)(*(_QWORD *)(v30 + 3232) + 8 * v11);
  }
  sub_99BB0((__m128i *)&v31);
  *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v31);
  v13 = _mm_loadu_si128((const __m128i *)&v32);
  tp.tm_zone = v34;
  *(__m128i *)&tp.tm_mon = v13;
  v14 = _mm_loadu_si128((const __m128i *)&v33);
  *(__m128i *)&tp.tm_isdst = v14;
  strftime(&s, 0x28uLL, "%Y-%m-%d %H:%M:%S\t", &tp);
  sub_2F4D0(*v12);
  v17 = sub_BC160(&s, *(double *)v14.m128i_i64, a7, a8, a9, v15, v16, a10, a11, a6, 0LL);
  v18 = *(_QWORD *)(v30 + 8) == 0LL;
  *v12 = v17;
  if ( !v18 )
    sub_9F340(*(_QWORD *)(v30 + 3224), v30 + 3096, v17, 0);
  v19 = *(_DWORD *)(v30 + 3248);
  if ( v19 <= 127 )
  {
    *(_DWORD *)(v30 + 3248) = v19 + 1;
  }
  else
  {
    v20 = *(_DWORD *)(v30 + 3252);
    if ( v20 <= 127 )
    {
      *(_DWORD *)(v30 + 3252) = v20 + 1;
    }
    else if ( v20 == 128 )
    {
      v27 = (*(_DWORD *)(v30 + 3256) + 1) % 128;
      v28 = *(_QWORD *)(v30 + 3240);
      *(_DWORD *)(v30 + 3256) = v27;
      sub_2F4D0(*(void **)(v28 + 8LL * v27));
      v29 = (char **)(*(_QWORD *)(v30 + 3240) + 8LL * *(signed int *)(v30 + 3256));
      *v29 = sub_BC120("..");
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

unsigned __int64 __usercall sub_AC950@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<rsi>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  __int64 v11; // rax
  void **v12; // r12
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  double v15; // xmm4_8
  double v16; // xmm5_8
  char *v17; // rax
  bool v18; // zf
  signed int v19; // eax
  signed int v20; // eax
  unsigned int v22; // edx
  _QWORD *v23; // rax
  signed __int64 v24; // rdx
  _QWORD *v25; // rax
  signed __int64 v26; // rdx
  int v27; // eax
  __int64 v28; // rdx
  char **v29; // rbx
  __int64 v30; // rdi
  __int128 v31; // [rsp+0h] [rbp-D8h]
  __int128 v32; // [rsp+10h] [rbp-C8h]
  __int128 v33; // [rsp+20h] [rbp-B8h]
  const char *v34; // [rsp+30h] [rbp-A8h]
  struct tm tp; // [rsp+40h] [rbp-98h]
  char s; // [rsp+80h] [rbp-58h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-30h]
  __int64 v38; // [rsp+B8h] [rbp-20h]
  __int64 v39; // [rsp+C0h] [rbp-18h]
  __int64 v40; // [rsp+C8h] [rbp-10h]
  __int64 v41; // [rsp+D0h] [rbp-8h]

  v30 = *(_QWORD *)(a3 - 208);
  v41 = a5;
  v40 = a4;
  v39 = a2;
  v38 = a1;
  v37 = __readfsqword(0x28u);
  v11 = *(signed int *)(v30 + 3248);
  if ( !(_DWORD)v11 )
  {
    v23 = sub_2F490(*(void **)(v30 + 3232), 0x80uLL, 8uLL);
    v24 = (signed __int64)(v23 + 128);
    *(_QWORD *)(v30 + 3232) = v23;
    do
    {
      *v23 = 0LL;
      ++v23;
    }
    while ( v23 != (_QWORD *)v24 );
    v25 = sub_2F490(*(void **)(v30 + 3240), 0x80uLL, 8uLL);
    v26 = (signed __int64)(v25 + 128);
    *(_QWORD *)(v30 + 3240) = v25;
    do
    {
      *v25 = 0LL;
      ++v25;
    }
    while ( (_QWORD *)v26 != v25 );
    v11 = *(signed int *)(v30 + 3248);
  }
  if ( (signed int)v11 > 127 )
  {
    v22 = (*(_DWORD *)(v30 + 3256) + *(_DWORD *)(v30 + 3252)) >> 31;
    v12 = (void **)(*(_QWORD *)(v30 + 3240)
                  + 8LL
                  * (signed int)((((v22 >> 25) + *(_BYTE *)(v30 + 3256) + *(_BYTE *)(v30 + 3252)) & 0x7F) - (v22 >> 25)));
  }
  else
  {
    v12 = (void **)(*(_QWORD *)(v30 + 3232) + 8 * v11);
  }
  sub_99BB0((__m128i *)&v31);
  *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v31);
  v13 = _mm_loadu_si128((const __m128i *)&v32);
  tp.tm_zone = v34;
  *(__m128i *)&tp.tm_mon = v13;
  v14 = _mm_loadu_si128((const __m128i *)&v33);
  *(__m128i *)&tp.tm_isdst = v14;
  strftime(&s, 0x28uLL, "%Y-%m-%d %H:%M:%S\t", &tp);
  sub_2F4D0(*v12);
  v17 = sub_BC160(&s, *(double *)v14.m128i_i64, a7, a8, a9, v15, v16, a10, a11, a6, 0LL);
  v18 = *(_QWORD *)(v30 + 8) == 0LL;
  *v12 = v17;
  if ( !v18 )
    sub_9F340(*(_QWORD *)(v30 + 3224), v30 + 3096, v17, 0);
  v19 = *(_DWORD *)(v30 + 3248);
  if ( v19 <= 127 )
  {
    *(_DWORD *)(v30 + 3248) = v19 + 1;
  }
  else
  {
    v20 = *(_DWORD *)(v30 + 3252);
    if ( v20 <= 127 )
    {
      *(_DWORD *)(v30 + 3252) = v20 + 1;
    }
    else if ( v20 == 128 )
    {
      v27 = (*(_DWORD *)(v30 + 3256) + 1) % 128;
      v28 = *(_QWORD *)(v30 + 3240);
      *(_DWORD *)(v30 + 3256) = v27;
      sub_2F4D0(*(void **)(v28 + 8LL * v27));
      v29 = (char **)(*(_QWORD *)(v30 + 3240) + 8LL * *(signed int *)(v30 + 3256));
      *v29 = sub_BC120("..");
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

unsigned __int64 __usercall sub_AC950@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<rsi>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  __int64 v11; // rax
  void **v12; // r12
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  double v15; // xmm4_8
  double v16; // xmm5_8
  char *v17; // rax
  bool v18; // zf
  signed int v19; // eax
  signed int v20; // eax
  unsigned int v22; // edx
  _QWORD *v23; // rax
  signed __int64 v24; // rdx
  _QWORD *v25; // rax
  signed __int64 v26; // rdx
  int v27; // eax
  __int64 v28; // rdx
  char **v29; // rbx
  __int64 v30; // rdi
  __int128 v31; // [rsp+0h] [rbp-D8h]
  __int128 v32; // [rsp+10h] [rbp-C8h]
  __int128 v33; // [rsp+20h] [rbp-B8h]
  const char *v34; // [rsp+30h] [rbp-A8h]
  struct tm tp; // [rsp+40h] [rbp-98h]
  char s; // [rsp+80h] [rbp-58h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-30h]
  __int64 v38; // [rsp+B8h] [rbp-20h]
  __int64 v39; // [rsp+C0h] [rbp-18h]
  __int64 v40; // [rsp+C8h] [rbp-10h]
  __int64 v41; // [rsp+D0h] [rbp-8h]

  v30 = *(_QWORD *)(a3 - 208);
  v41 = a5;
  v40 = a4;
  v39 = a2;
  v38 = a1;
  v37 = __readfsqword(0x28u);
  v11 = *(signed int *)(v30 + 3248);
  if ( !(_DWORD)v11 )
  {
    v23 = sub_2F490(*(void **)(v30 + 3232), 0x80uLL, 8uLL);
    v24 = (signed __int64)(v23 + 128);
    *(_QWORD *)(v30 + 3232) = v23;
    do
    {
      *v23 = 0LL;
      ++v23;
    }
    while ( v23 != (_QWORD *)v24 );
    v25 = sub_2F490(*(void **)(v30 + 3240), 0x80uLL, 8uLL);
    v26 = (signed __int64)(v25 + 128);
    *(_QWORD *)(v30 + 3240) = v25;
    do
    {
      *v25 = 0LL;
      ++v25;
    }
    while ( (_QWORD *)v26 != v25 );
    v11 = *(signed int *)(v30 + 3248);
  }
  if ( (signed int)v11 > 127 )
  {
    v22 = (*(_DWORD *)(v30 + 3256) + *(_DWORD *)(v30 + 3252)) >> 31;
    v12 = (void **)(*(_QWORD *)(v30 + 3240)
                  + 8LL
                  * (signed int)((((v22 >> 25) + *(_BYTE *)(v30 + 3256) + *(_BYTE *)(v30 + 3252)) & 0x7F) - (v22 >> 25)));
  }
  else
  {
    v12 = (void **)(*(_QWORD *)(v30 + 3232) + 8 * v11);
  }
  sub_99BB0((__m128i *)&v31);
  *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v31);
  v13 = _mm_loadu_si128((const __m128i *)&v32);
  tp.tm_zone = v34;
  *(__m128i *)&tp.tm_mon = v13;
  v14 = _mm_loadu_si128((const __m128i *)&v33);
  *(__m128i *)&tp.tm_isdst = v14;
  strftime(&s, 0x28uLL, "%Y-%m-%d %H:%M:%S\t", &tp);
  sub_2F4D0(*v12);
  v17 = sub_BC160(&s, *(double *)v14.m128i_i64, a7, a8, a9, v15, v16, a10, a11, a6, 0LL);
  v18 = *(_QWORD *)(v30 + 8) == 0LL;
  *v12 = v17;
  if ( !v18 )
    sub_9F340(*(_QWORD *)(v30 + 3224), v30 + 3096, v17, 0);
  v19 = *(_DWORD *)(v30 + 3248);
  if ( v19 <= 127 )
  {
    *(_DWORD *)(v30 + 3248) = v19 + 1;
  }
  else
  {
    v20 = *(_DWORD *)(v30 + 3252);
    if ( v20 <= 127 )
    {
      *(_DWORD *)(v30 + 3252) = v20 + 1;
    }
    else if ( v20 == 128 )
    {
      v27 = (*(_DWORD *)(v30 + 3256) + 1) % 128;
      v28 = *(_QWORD *)(v30 + 3240);
      *(_DWORD *)(v30 + 3256) = v27;
      sub_2F4D0(*(void **)(v28 + 8LL * v27));
      v29 = (char **)(*(_QWORD *)(v30 + 3240) + 8LL * *(signed int *)(v30 + 3256));
      *v29 = sub_BC120("..");
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

unsigned __int64 __usercall sub_AC950@<rax>(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<r12>, __int64 a5@<r13>, __int64 a6@<rsi>, double a7@<xmm1>, double a8@<xmm2>, double a9@<xmm3>, double a10@<xmm6>, double a11@<xmm7>)
{
  __int64 v11; // rax
  void **v12; // r12
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  double v15; // xmm4_8
  double v16; // xmm5_8
  char *v17; // rax
  bool v18; // zf
  signed int v19; // eax
  signed int v20; // eax
  unsigned int v22; // edx
  _QWORD *v23; // rax
  signed __int64 v24; // rdx
  _QWORD *v25; // rax
  signed __int64 v26; // rdx
  int v27; // eax
  __int64 v28; // rdx
  char **v29; // rbx
  __int64 v30; // rdi
  __int128 v31; // [rsp+0h] [rbp-D8h]
  __int128 v32; // [rsp+10h] [rbp-C8h]
  __int128 v33; // [rsp+20h] [rbp-B8h]
  const char *v34; // [rsp+30h] [rbp-A8h]
  struct tm tp; // [rsp+40h] [rbp-98h]
  char s; // [rsp+80h] [rbp-58h]
  unsigned __int64 v37; // [rsp+A8h] [rbp-30h]
  __int64 v38; // [rsp+B8h] [rbp-20h]
  __int64 v39; // [rsp+C0h] [rbp-18h]
  __int64 v40; // [rsp+C8h] [rbp-10h]
  __int64 v41; // [rsp+D0h] [rbp-8h]

  v30 = *(_QWORD *)(a3 - 208);
  v41 = a5;
  v40 = a4;
  v39 = a2;
  v38 = a1;
  v37 = __readfsqword(0x28u);
  v11 = *(signed int *)(v30 + 3248);
  if ( !(_DWORD)v11 )
  {
    v23 = sub_2F490(*(void **)(v30 + 3232), 0x80uLL, 8uLL);
    v24 = (signed __int64)(v23 + 128);
    *(_QWORD *)(v30 + 3232) = v23;
    do
    {
      *v23 = 0LL;
      ++v23;
    }
    while ( v23 != (_QWORD *)v24 );
    v25 = sub_2F490(*(void **)(v30 + 3240), 0x80uLL, 8uLL);
    v26 = (signed __int64)(v25 + 128);
    *(_QWORD *)(v30 + 3240) = v25;
    do
    {
      *v25 = 0LL;
      ++v25;
    }
    while ( (_QWORD *)v26 != v25 );
    v11 = *(signed int *)(v30 + 3248);
  }
  if ( (signed int)v11 > 127 )
  {
    v22 = (*(_DWORD *)(v30 + 3256) + *(_DWORD *)(v30 + 3252)) >> 31;
    v12 = (void **)(*(_QWORD *)(v30 + 3240)
                  + 8LL
                  * (signed int)((((v22 >> 25) + *(_BYTE *)(v30 + 3256) + *(_BYTE *)(v30 + 3252)) & 0x7F) - (v22 >> 25)));
  }
  else
  {
    v12 = (void **)(*(_QWORD *)(v30 + 3232) + 8 * v11);
  }
  sub_99BB0((__m128i *)&v31);
  *(__m128i *)&tp.tm_sec = _mm_loadu_si128((const __m128i *)&v31);
  v13 = _mm_loadu_si128((const __m128i *)&v32);
  tp.tm_zone = v34;
  *(__m128i *)&tp.tm_mon = v13;
  v14 = _mm_loadu_si128((const __m128i *)&v33);
  *(__m128i *)&tp.tm_isdst = v14;
  strftime(&s, 0x28uLL, "%Y-%m-%d %H:%M:%S\t", &tp);
  sub_2F4D0(*v12);
  v17 = sub_BC160(&s, *(double *)v14.m128i_i64, a7, a8, a9, v15, v16, a10, a11, a6, 0LL);
  v18 = *(_QWORD *)(v30 + 8) == 0LL;
  *v12 = v17;
  if ( !v18 )
    sub_9F340(*(_QWORD *)(v30 + 3224), v30 + 3096, v17, 0);
  v19 = *(_DWORD *)(v30 + 3248);
  if ( v19 <= 127 )
  {
    *(_DWORD *)(v30 + 3248) = v19 + 1;
  }
  else
  {
    v20 = *(_DWORD *)(v30 + 3252);
    if ( v20 <= 127 )
    {
      *(_DWORD *)(v30 + 3252) = v20 + 1;
    }
    else if ( v20 == 128 )
    {
      v27 = (*(_DWORD *)(v30 + 3256) + 1) % 128;
      v28 = *(_QWORD *)(v30 + 3240);
      *(_DWORD *)(v30 + 3256) = v27;
      sub_2F4D0(*(void **)(v28 + 8LL * v27));
      v29 = (char **)(*(_QWORD *)(v30 + 3240) + 8LL * *(signed int *)(v30 + 3256));
      *v29 = sub_BC120("..");
    }
  }
  return __readfsqword(0x28u) ^ v37;
}

unsigned __int64 __fastcall sub_AC960(__int64 a1, int a2, int a3)
{
  __int64 v3; // r12
  __int64 v4; // rdi
  int v5; // ebp
  int v6; // ebx
  int v7; // ebp
  __int64 v8; // rax
  unsigned int v9; // ebx
  unsigned int v10; // ebp
  __int64 v11; // rax
  __int64 v13; // [rsp+0h] [rbp-58h]
  int v14; // [rsp+10h] [rbp-48h]
  int v15; // [rsp+14h] [rbp-44h]
  int v16; // [rsp+18h] [rbp-40h]
  int v17; // [rsp+1Ch] [rbp-3Ch]
  unsigned __int64 v18; // [rsp+38h] [rbp-20h]

  v3 = a1;
  v4 = a1 - 9544;
  v5 = a3;
  v18 = __readfsqword(0x28u);
  sub_AC220(v4, (__int64)&v13);
  v6 = v16 * a2;
  v7 = v17 * v5;
  v8 = gtk_window_get_type(v4, &v13);
  v9 = v14 + v6;
  v10 = v15 + v7;
  v11 = g_type_check_instance_cast(*(_QWORD *)(v3 - 9544), v8);
  gtk_window_resize(v11, v9, v10);
  return __readfsqword(0x28u) ^ v18;
}

__int64 __fastcall sub_AC9E0(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 - 112);
  if ( !(_DWORD)result )
    result = cairo_destroy(*(_QWORD *)(a1 - 96));
  return result;
}

unsigned __int64 __fastcall sub_ACA00(__int64 a1, int a2, int a3)
{
  __int64 v3; // rbx
  int v4; // ebp
  unsigned int v5; // er13
  int v6; // eax
  __int64 v7; // rdi
  int v8; // esi
  unsigned int v9; // ebp
  signed __int64 v10; // rsi
  __int64 v11; // rax
  int v12; // esi
  __int64 v13; // rbp
  unsigned int v14; // edx
  __int64 v15; // r12
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 v18; // ST08_8
  __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rax
  __int64 v22; // rdi
  unsigned int v24; // [rsp+8h] [rbp-70h]
  int v25; // [rsp+14h] [rbp-64h]
  unsigned int v26; // [rsp+1Ch] [rbp-5Ch]
  unsigned int v27; // [rsp+20h] [rbp-58h]
  unsigned int v28; // [rsp+24h] [rbp-54h]
  int v29; // [rsp+30h] [rbp-48h]
  int v30; // [rsp+34h] [rbp-44h]
  unsigned __int64 v31; // [rsp+38h] [rbp-40h]

  v3 = a1;
  v4 = *(_DWORD *)(a1 - 5712);
  v5 = *(_DWORD *)(a1 - 5708);
  v31 = __readfsqword(0x28u);
  v6 = *(_DWORD *)(a1 - 132);
  v7 = *(_QWORD *)(a1 - 24);
  v8 = v4 * a2;
  v9 = 2 * v4;
  v10 = (unsigned int)(v6 + v8);
  v26 = v10;
  v27 = v5 * a3 + v6;
  if ( *(_DWORD *)(v3 - 16) != v9 || v5 != *(_DWORD *)(v3 - 12) )
  {
    if ( v7 )
    {
      v11 = g_type_check_instance_cast(v7, 80LL);
      g_object_unref(v11, 80LL);
    }
  }
  else if ( v7 )
  {
    goto LABEL_12;
  }
  v12 = v5 + v9;
  v28 = v9;
  v13 = 0LL;
  v24 = -1;
  v25 = 0;
  do
  {
    while ( 1 )
    {
      if ( sscanf((*off_322E60[v13])[0], "%d %d", &v29, &v30) == 2 )
      {
        v14 = abs(v29 + v30 - v12);
        if ( v29 + v30 - v12 <= 0 )
          v14 |= 0x80000000;
        if ( v24 > v14 )
          break;
      }
      if ( ++v13 == 3 )
        goto LABEL_11;
    }
    v25 = v13++;
    v24 = v14;
  }
  while ( v13 != 3 );
LABEL_11:
  v9 = v28;
  v15 = gdk_pixbuf_new_from_xpm_data(off_322E60[v25]);
  v10 = 80LL;
  *(_QWORD *)(v3 - 24) = gdk_pixbuf_scale_simple(v15, v28, v5, 2LL);
  v16 = g_type_check_instance_cast(v15, 80LL);
  g_object_unref(v16, 80LL);
  *(_DWORD *)(v3 - 16) = v28;
  *(_DWORD *)(v3 - 12) = v5;
LABEL_12:
  v17 = *(_QWORD *)(v3 - 9536);
  if ( !*(_DWORD *)(v3 - 112) )
  {
    v18 = *(_QWORD *)(v3 - 9536);
    v19 = gtk_widget_get_type(v17, v10);
    v20 = v19;
    v21 = g_type_check_instance_cast(v18, v19);
    v22 = *(_QWORD *)(v3 - 96);
    *(_QWORD *)(v3 - 104) = v21;
    cairo_save(v22, v20);
    cairo_translate(*(_QWORD *)(v3 - 96));
    gdk_cairo_set_source_pixbuf(*(_QWORD *)(v3 - 96), *(_QWORD *)(v3 - 24));
    cairo_rectangle(*(_QWORD *)(v3 - 96));
    cairo_fill(*(_QWORD *)(v3 - 96));
    cairo_restore(*(_QWORD *)(v3 - 96));
    v17 = *(_QWORD *)(v3 - 9536);
  }
  gtk_widget_queue_draw_area(v17, v26, v27, v9, v5);
  return __readfsqword(0x28u) ^ v31;
}

signed __int64 __fastcall sub_ACCA0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // ebp
  __int64 v4; // rdi
  int v5; // eax
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rax
  double v12; // xmm0_8

  v2 = a1;
  v3 = 0;
  v4 = *(_QWORD *)(a1 - 9536);
  if ( !gtk_widget_get_window(v4) )
    return v3;
  v5 = *(_DWORD *)(v2 - 124);
  v3 = 1;
  *(_DWORD *)(v2 - 112) = v5;
  if ( v5 )
    return v3;
  v7 = gtk_widget_get_type(v4, a2);
  v8 = v7;
  v9 = g_type_check_instance_cast(*(_QWORD *)(v2 - 9536), v7);
  v10 = *(_QWORD *)(v2 - 9432);
  *(_QWORD *)(v2 - 104) = v9;
  v11 = cairo_create(v10, v8);
  *(_QWORD *)(v2 - 96) = v11;
  v12 = (double)*(signed int *)(v2 - 5696);
  cairo_scale(v11);
  cairo_get_matrix(*(_QWORD *)(v2 - 96), v2 - 88);
  cairo_set_line_width(*(_QWORD *)(v2 - 96));
  cairo_set_line_cap(*(_QWORD *)(v2 - 96), 2LL);
  cairo_set_line_join(*(_QWORD *)(v2 - 96), 0LL);
  cairo_set_antialias(*(_QWORD *)(v2 - 96), 1LL);
  return 1LL;
}

signed __int64 __fastcall sub_ACD70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rax
  __int64 v5; // rax

  v3 = a3;
  v4 = gtk_window_get_type(a1, a2);
  v5 = g_type_check_instance_cast(*(_QWORD *)(a1 - 9536), v4);
  gtk_window_get_size(v5, a2, v3);
  return 1LL;
}

__int64 __fastcall sub_ACDB0(__int64 a1)
{
  unsigned int v1; // eax
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rax

  v1 = *(_DWORD *)(a1 + 3856);
  if ( v1 )
  {
    if ( v1 > 2 )
      __assert_fail("false && \"Bad busy_status\"", "unix/gtkwin.c", 0x2A7u, "update_mouseptr");
    v2 = *(_QWORD *)(a1 + 208);
    v3 = *(_QWORD *)(a1 + 8);
  }
  else if ( *(_BYTE *)(a1 + 3853) )
  {
    if ( *(_BYTE *)(a1 + 9429) )
      v2 = *(_QWORD *)(a1 + 184);
    else
      v2 = *(_QWORD *)(a1 + 192);
    v3 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 200);
    v3 = *(_QWORD *)(a1 + 8);
  }
  v4 = gtk_widget_get_window(v3);
  return gdk_window_set_cursor(v4, v2);
}

__int64 __fastcall sub_ACE50(__int64 a1, int a2)
{
  *(_DWORD *)(a1 - 5680) = a2;
  return sub_ACDB0(a1 - 9536);
}

__int64 __fastcall sub_ACE70(__int64 a1, char a2)
{
  *(_BYTE *)(a1 - 115) = a2;
  return sub_ACDB0(a1 - 9544);
}

__int64 __fastcall sub_ACE80(__int64 a1, char a2)
{
  char v2; // bl

  v2 = a2;
  if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(a1 + 9336), 134) )
    v2 = 1;
  *(_BYTE *)(a1 + 3853) = v2;
  return sub_ACDB0(a1);
}

__int64 __fastcall sub_ACEC0(__int64 a1, const char *a2, __int64 a3)
{
  __int64 v3; // rbx
  signed int v4; // eax
  __int64 result; // rax

  v3 = a3;
  v4 = strlen(a2);
  sub_99290(*(_QWORD *)(v3 + 3912), 55LL, a2, v4);
  result = sub_ACE80(v3, 0);
  if ( *(_BYTE *)(v3 + 3928) )
    result = gtk_widget_destroy(*(_QWORD *)v3);
  return result;
}

signed __int64 __usercall sub_ACF20@<rax>(__int64 a1@<rdx>, __int64 a2@<rsi>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  __int64 v6; // rbp
  int v7; // eax
  __int64 v8; // rbx
  signed int v9; // esi
  unsigned int v10; // edx
  int v11; // er11
  int v12; // ecx
  bool v13; // di
  __int32 v14; // esi
  signed int v15; // er12
  int v16; // edx
  signed __int64 result; // rax

  v6 = a2;
  v7 = *(_DWORD *)(a2 + 20);
  v8 = a1;
  v9 = (signed int)*(double *)(a2 + 24) << 16;
  *(_DWORD *)(a1 + 9352) = v7;
  sub_B7C30(5u, (signed int)*(double *)(v6 + 32) | (unsigned int)v9, a3, a4, a5, a6);
  sub_ACE80(v8, 1);
  v10 = *(_DWORD *)(v6 + 48);
  v11 = *(_DWORD *)(v6 + 48) & 1;
  v12 = (v10 >> 2) & 1;
  v13 = (v10 & *(_DWORD *)(v8 + 9424)) != 0;
  if ( v10 & 0x100 )
  {
    v14 = 1;
    v15 = 1;
  }
  else if ( v10 & 0x200 )
  {
    v14 = 2;
    v15 = 2;
  }
  else
  {
    result = 0LL;
    if ( !(v10 & 0x400) )
      return result;
    v14 = 3;
    v15 = 3;
  }
  v16 = 4;
  if ( v15 != 1 )
    v16 = (v14 == 2) + 5;
  sub_980C0(
    *(const __m128i **)(v8 + 3912),
    v14,
    v16,
    4,
    (signed int)((*(double *)(v6 + 24) - (double)*(signed int *)(v8 + 9412)) / (double)*(signed int *)(v8 + 3832)),
    (signed int)((*(double *)(v6 + 32) - (double)*(signed int *)(v8 + 9412)) / (double)*(signed int *)(v8 + 3836)),
    v11,
    v12,
    v13);
  return 1LL;
}

signed __int64 __usercall sub_AD050@<rax>(__int64 a1@<rdi>, double *a2@<rsi>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  double *v6; // rbp
  __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rsi
  signed __int64 v10; // rsi
  int v11; // er12
  char v12; // r13
  __int64 v13; // rdx
  int v14; // er14
  int v15; // er15
  int v16; // eax
  int v17; // eax
  __int32 v18; // esi
  bool v19; // zf
  bool v20; // sf
  unsigned __int8 v21; // of
  int v22; // ecx
  bool v23; // r10
  int v24; // edx
  signed __int64 result; // rax
  unsigned int v26; // ST2C_4
  char v27; // al
  __int64 v28; // rax
  __int64 v29; // rax

  v6 = a2;
  v7 = a1;
  v8 = *((_DWORD *)a2 + 5);
  v9 = *((unsigned int *)a2 + 13);
  *(_DWORD *)(a1 + 9352) = v8;
  sub_B7C30(4u, v9, a3, a4, a5, a6);
  v10 = 1LL;
  sub_ACE80(a1, 1);
  v11 = *((_DWORD *)v6 + 12);
  v12 = *(_BYTE *)(a1 + 9428);
  v13 = *(unsigned int *)(a1 + 9424);
  v14 = (_DWORD)v6[6] & 1;
  v15 = (_DWORD)v6[6] & 4;
  if ( !v12
    || v14
    && (a1 = *(_QWORD *)(a1 + 9336),
        v10 = 154LL,
        v26 = *(_DWORD *)(v7 + 9424),
        v27 = sub_1EF00((__int64 *)a1, 154),
        v13 = v26,
        v27) )
  {
    v16 = *((_DWORD *)v6 + 13);
    if ( v16 == 4 )
    {
      v17 = *(_DWORD *)v6;
      v12 = 0;
      v18 = 7;
      if ( *(_DWORD *)v6 == 4 )
      {
        sub_97BB0(*(_QWORD *)(v7 + 3912), 0, -5);
        return 1LL;
      }
      goto LABEL_7;
    }
    v12 = 0;
    if ( v16 == 5 )
    {
      v17 = *(_DWORD *)v6;
      v18 = 8;
      if ( *(_DWORD *)v6 == 4 )
      {
        sub_97BB0(*(_QWORD *)(v7 + 3912), 0, 5);
        return 1LL;
      }
      goto LABEL_7;
    }
  }
  else
  {
    v16 = *((_DWORD *)v6 + 13);
  }
  if ( v16 != 3 )
  {
    switch ( v16 )
    {
      case 1:
        v17 = *(_DWORD *)v6;
        v18 = 1;
        break;
      case 2:
        v17 = *(_DWORD *)v6;
        v18 = 2;
        break;
      case 4:
        v17 = *(_DWORD *)v6;
        v18 = 7;
        break;
      case 5:
        v17 = *(_DWORD *)v6;
        v18 = 8;
        break;
      default:
        return 0LL;
    }
LABEL_7:
    v21 = __OFSUB__(v17, 5);
    v19 = v17 == 5;
    v20 = v17 - 5 < 0;
    if ( v17 != 5 )
      goto LABEL_8;
LABEL_23:
    result = 1LL;
    if ( v12 )
      return result;
    v22 = 2;
    goto LABEL_11;
  }
  if ( v15 )
  {
    v28 = gtk_menu_get_type(a1, v10, v13);
    v29 = g_type_check_instance_cast(*(_QWORD *)(v7 + 56), v28);
    gtk_menu_popup_at_pointer(v29, v6);
    return 1LL;
  }
  v17 = *(_DWORD *)v6;
  v18 = 3;
  v21 = __OFSUB__(*(_DWORD *)v6, 5);
  v19 = *(_DWORD *)v6 == 5;
  v20 = *(_DWORD *)v6 - 5 < 0;
  if ( *(_DWORD *)v6 == 5 )
    goto LABEL_23;
LABEL_8:
  if ( (unsigned __int8)(v20 ^ v21) | v19 )
  {
    if ( v17 == 4 )
    {
      v22 = 1;
      goto LABEL_11;
    }
    return 0LL;
  }
  if ( v17 == 6 )
  {
    result = 1LL;
    v22 = 3;
    if ( v12 )
      return result;
    goto LABEL_11;
  }
  v22 = 5;
  if ( v17 != 7 )
    return 0LL;
LABEL_11:
  v23 = (v11 & (unsigned int)v13) != 0;
  v24 = 4;
  if ( v18 != 1 )
  {
    v24 = 6;
    if ( v18 != 2 )
      v24 = 5 * (v18 == 3);
  }
  sub_980C0(
    *(const __m128i **)(v7 + 3912),
    v18,
    v24,
    v22,
    (signed int)((v6[3] - (double)*(signed int *)(v7 + 9412)) / (double)*(signed int *)(v7 + 3832)),
    (signed int)((v6[4] - (double)*(signed int *)(v7 + 9412)) / (double)*(signed int *)(v7 + 3836)),
    v14,
    v15 != 0,
    v23);
  return 1LL;
}

signed __int64 __usercall sub_AD340@<rax>(__int64 a1@<rdx>, double *a2@<rsi>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  return sub_AD050(a1, a2, a3, a4, a5, a6);
}

__int64 __fastcall sub_AD350(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a3;
  sub_99580(*(_QWORD *)(a3 + 3912), *(_WORD *)(a2 + 18) != 0);
  sub_8FD90(*(const __m128i **)(v3 + 3912));
  sub_ACE80(v3, 1);
  return 0LL;
}

signed __int64 __fastcall sub_AD390(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  signed __int64 result; // rax

  v3 = a3;
  result = sub_1CC70(a2);
  if ( (_DWORD)result == -1 )
    result = sub_99630(*(_QWORD *)(a1 - 5624), a2, v3);
  return result;
}

__int64 __fastcall sub_AD3D0(__int64 a1, int a2)
{
  __int64 v2; // rcx
  bool v3; // zf
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 result; // rax

  v2 = *(unsigned int *)(a1 - 192);
  v3 = *(_BYTE *)(a1 - 6176) == 0;
  v4 = *(_QWORD *)(a1 + ((a2 + 53LL) << 6) - 9544);
  v5 = *(_QWORD *)(a1 - 9536);
  if ( v3 )
    result = gtk_selection_convert(v5, v4, qword_326548, v2);
  else
    result = gtk_selection_convert(v5, v4, 31LL, v2);
  return result;
}

unsigned __int64 __fastcall sub_AD420(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  Atom v6; // r14
  unsigned __int8 *v7; // r13
  int v8; // er15
  __int64 v9; // rax
  _QWORD *v10; // rdx
  int v11; // ecx
  int v12; // er12
  wchar_t *v13; // rax
  wchar_t *v14; // rbx
  int v15; // eax
  bool v17; // al
  Display *v18; // rdi
  char *v19; // rax
  unsigned __int64 v20; // rdi
  char *v21; // r12
  int v22; // eax
  wchar_t *v23; // rax
  wchar_t *v24; // rbx
  int v25; // eax
  int v26; // eax
  Display *v27; // rdi
  __int64 v28; // r9
  int v29; // eax
  char *v30; // r12
  int v31; // eax
  wchar_t *v32; // rax
  wchar_t *v33; // rbx
  int v34; // eax
  __int64 v35; // [rsp+8h] [rbp-80h]
  int v36; // [rsp+10h] [rbp-78h]
  int count_return; // [rsp+14h] [rbp-74h]
  char **list_return; // [rsp+18h] [rbp-70h]
  XTextProperty text_prop; // [rsp+20h] [rbp-68h]
  unsigned __int64 v40; // [rsp+48h] [rbp-40h]

  v4 = a4;
  v40 = __readfsqword(0x28u);
  v5 = gtk_selection_data_get_target(a2);
  v6 = gtk_selection_data_get_data_type(a2);
  v7 = (unsigned __int8 *)gtk_selection_data_get_data(a2);
  v8 = gtk_selection_data_get_length(a2);
  v9 = gtk_selection_data_get_selection(a2);
  v10 = (_QWORD *)(v4 + 3376);
  v11 = 0;
  while ( v4 != *v10 || v9 != v10[2] )
  {
    ++v11;
    v10 += 8;
    if ( v11 == 7 )
      return __readfsqword(0x28u) ^ v40;
  }
  if ( v4 + ((signed __int64)v11 << 6) == -3376 )
    return __readfsqword(0x28u) ^ v40;
  if ( qword_326548 == v5 )
  {
    if ( v8 <= 0 )
    {
      gtk_selection_convert(*(_QWORD *)(v4 + 8), v9, qword_326540, *(unsigned int *)(v4 + 9352));
      return __readfsqword(0x28u) ^ v40;
    }
    v17 = v6 != 31;
    if ( v5 != qword_326540 )
    {
      if ( v6 != 31 )
        goto LABEL_10;
      goto LABEL_12;
    }
    goto LABEL_27;
  }
  if ( v5 == qword_326540 )
  {
    if ( v8 <= 0 )
    {
      gtk_selection_convert(*(_QWORD *)(v4 + 8), v9, 31LL, *(unsigned int *)(v4 + 9352));
      return __readfsqword(0x28u) ^ v40;
    }
    v17 = v6 != 31;
LABEL_27:
    if ( v8 > 0 && v17 )
    {
LABEL_10:
      if ( qword_326548 != v6 && v6 != qword_326540 )
        return __readfsqword(0x28u) ^ v40;
    }
LABEL_12:
    if ( v6 == qword_326540 )
    {
      v35 = v11;
      text_prop.value = v7;
      text_prop.encoding = v6;
      v26 = gtk_selection_data_get_format(a2, a2, qword_326540);
      v27 = *(Display **)(v4 + 104);
      text_prop.format = v26;
      v28 = v35;
      text_prop.nitems = v8;
      if ( !v27
        || (v29 = Xutf8TextPropertyToTextList(v27, &text_prop, &list_return, &count_return), v28 = v35, v29)
        || count_return != 1 )
      {
        gtk_selection_convert(
          *(_QWORD *)(v4 + 8),
          *(_QWORD *)(v4 + ((v28 + 53) << 6)),
          31LL,
          *(unsigned int *)(v4 + 9352));
      }
      else
      {
        v30 = *list_return;
        v31 = strlen(*list_return);
        v36 = v31;
        v32 = (wchar_t *)sub_2F450(v31, 4uLL, 0LL);
        v33 = v32;
        v34 = sub_BB410(55, 0LL, (__int64)v30, v36, (__int64)v32, v36);
        sub_97DE0(*(_QWORD *)(v4 + 3912), v33, v34);
        sub_2F4D0(v33);
        XFreeStringList(list_return);
      }
    }
    else
    {
      v36 = v8;
      v12 = 55;
      if ( qword_326548 != v6 )
        v12 = *(_DWORD *)(v4 + 3952);
      v13 = (wchar_t *)sub_2F450(v8, 4uLL, 0LL);
      v14 = v13;
      v15 = sub_BB410(v12, 0LL, (__int64)v7, v36, (__int64)v13, v36);
      sub_97DE0(*(_QWORD *)(v4 + 3912), v14, v15);
      sub_2F4D0(v14);
    }
    return __readfsqword(0x28u) ^ v40;
  }
  if ( v8 > 0 && v6 != 31 )
    goto LABEL_10;
  if ( v8 > 0 )
    goto LABEL_12;
  v18 = *(Display **)(v4 + 104);
  if ( !v18 )
    return __readfsqword(0x28u) ^ v40;
  v19 = XFetchBytes(v18, &v36);
  v20 = v36;
  v21 = v19;
  v22 = v36;
  if ( v36 > 0 )
  {
LABEL_24:
    v23 = (wchar_t *)sub_2F450(v20, 4uLL, 0LL);
    v24 = v23;
    v25 = sub_BB410(1, 0LL, (__int64)v21, v36, (__int64)v23, v36);
    sub_97DE0(*(_QWORD *)(v4 + 3912), v24, v25);
    sub_2F4D0(v24);
    XFree(v21);
    return __readfsqword(0x28u) ^ v40;
  }
  if ( v21 )
  {
    XFree(v21);
    v22 = v36;
  }
  if ( v22 )
  {
    v20 = v22;
    v21 = 0LL;
    goto LABEL_24;
  }
  return __readfsqword(0x28u) ^ v40;
}

__int64 __fastcall sub_AD7C0(__int64 a1, __int64 a2, double a3)
{
  __int64 result; // rax

  result = sub_1EF00(*(__int64 **)(a2 + 9336), 117);
  if ( (_BYTE)result )
  {
    if ( !*(_BYTE *)(a2 + 3852) )
    {
      gtk_adjustment_get_value(a1, 117LL);
      result = sub_97BB0(*(_QWORD *)(a2 + 3912), 1, (signed int)a3);
    }
  }
  return result;
}

unsigned __int64 __usercall sub_AD820@<rax>(__int64 a1@<rdi>, __int64 a2@<r13>, __int64 a3@<r15>, double a4@<xmm0>, double a5@<xmm1>, double a6@<xmm2>, double a7@<xmm3>, double a8@<xmm6>, double a9@<xmm7>)
{
  double v9; // xmm4_8
  double v10; // xmm5_8
  unsigned __int64 result; // rax

  sub_2D2C0(*(_QWORD *)(a1 + 3920), "----- Session restarted -----", a2, a3);
  sub_923A0(*(_QWORD *)(a1 + 3912), 0);
  result = sub_AC4F0(a1, a4, a5, a6, a7, v9, v10, a8, a9);
  *(_BYTE *)(a1 + 3928) = 0;
  return result;
}

unsigned __int64 __usercall sub_AD860@<rax>(__int64 a1@<rsi>, __int64 a2@<r13>, __int64 a3@<r15>, double a4@<xmm0>, double a5@<xmm1>, double a6@<xmm2>, double a7@<xmm3>, double a8@<xmm6>, double a9@<xmm7>)
{
  unsigned __int64 result; // rax

  if ( !*(_QWORD *)(a1 + 3904) )
    result = sub_AD820(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return result;
}

__int64 __fastcall sub_AD880(__int64 a1, char a2)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 + 9432);
  if ( !(_DWORD)result )
  {
    cairo_new_path(*(_QWORD *)(a1 + 9448));
    if ( a2 )
    {
      cairo_rectangle(*(_QWORD *)(a1 + 9448));
      result = cairo_fill(*(_QWORD *)(a1 + 9448));
    }
    else
    {
      cairo_rectangle(*(_QWORD *)(a1 + 9448));
      cairo_close_path(*(_QWORD *)(a1 + 9448));
      result = cairo_stroke(*(_QWORD *)(a1 + 9448));
    }
  }
  return result;
}

__int64 __fastcall sub_AD980(__int64 a1, char a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  __int64 v5; // rax

  v2 = *(_QWORD *)(a1 - 9544);
  if ( a2 )
  {
    v5 = gtk_widget_get_window(v2);
    result = gdk_window_raise(v5);
  }
  else
  {
    v3 = gtk_widget_get_window(v2);
    result = gdk_window_lower(v3);
  }
  return result;
}

__int64 __fastcall sub_AD9C0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rax

  v2 = gtk_window_get_type(a1, a2);
  v3 = *(_QWORD *)(a1 - 9544);
  if ( (_BYTE)a2 )
  {
    v6 = g_type_check_instance_cast(v3, v2);
    result = gtk_window_maximize(v6);
  }
  else
  {
    v4 = g_type_check_instance_cast(v3, v2);
    result = gtk_window_unmaximize(v4);
  }
  return result;
}

__int64 __fastcall sub_ADA10(__int64 a1, __int64 a2)
{
  char v2; // bl
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rax

  v2 = a2;
  v3 = gtk_window_get_type(a1, a2);
  v4 = *(_QWORD *)(a1 - 9544);
  v5 = v3;
  if ( v2 )
  {
    v8 = g_type_check_instance_cast(v4, v3);
    result = gtk_window_iconify(v8);
  }
  else
  {
    v6 = g_type_check_instance_cast(v4, v3);
    result = gtk_window_deiconify(v6, v5);
  }
  return result;
}

__int64 __fastcall sub_ADA60(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rbp
  __int64 v7; // rax

  v2 = a1[484];
  v3 = gtk_window_get_type(a1, a2);
  v4 = g_type_check_instance_cast(*a1, v3);
  gtk_window_set_title(v4, v2);
  result = sub_1EF00((__int64 *)a1[1167], 122);
  if ( !(_BYTE)result )
  {
    v6 = a1[485];
    v7 = gtk_widget_get_window(*a1);
    result = gdk_window_set_icon_name(v7, v6);
  }
  return result;
}

__int64 __fastcall sub_ADAD0(__int64 a1, char *a2)
{
  sub_2F4D0(*(void **)(a1 - 5664));
  *(_QWORD *)(a1 - 5664) = sub_BC120(a2);
  return sub_ADA60((_QWORD *)(a1 - 9544), (__int64)a2);
}

__int64 __fastcall sub_ADB10(__int64 a1, char *a2)
{
  sub_2F4D0(*(void **)(a1 - 5672));
  *(_QWORD *)(a1 - 5672) = sub_BC120(a2);
  return sub_ADA60((_QWORD *)(a1 - 9544), (__int64)a2);
}

unsigned __int64 __fastcall sub_ADB50(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, int a6, char a7)
{
  __int64 v7; // r14
  __int64 v8; // r15
  __int64 v9; // rbp
  int v10; // er13
  __int64 v11; // rbx
  void *v12; // rdi
  void *v13; // rdi
  void *v14; // rdi
  int v15; // er12
  unsigned __int64 v16; // r10
  signed __int64 v17; // rax
  int v18; // eax
  __int64 v19; // rsi
  void *v21; // rax
  Display *v22; // rdi
  const char *v23; // r12
  int v24; // er13
  void *v25; // rax
  signed __int64 v26; // r11
  int v27; // eax
  signed __int64 v28; // r11
  signed __int64 v29; // ST18_8
  _BYTE *v30; // rax
  __int64 v31; // rdx
  char *v32; // rax
  Display *v33; // rdi
  int v34; // eax
  signed __int64 v35; // rax
  void *v36; // rax
  unsigned __int64 v37; // rdx
  unsigned __int8 *v38; // rsi
  unsigned __int8 *v39; // rdi
  unsigned __int64 v40; // [rsp+8h] [rbp-90h]
  unsigned int v41; // [rsp+14h] [rbp-84h]
  int v42; // [rsp+24h] [rbp-74h]
  __int64 v43; // [rsp+28h] [rbp-70h]
  XTextProperty text_prop_return; // [rsp+30h] [rbp-68h]
  char *list; // [rsp+50h] [rbp-48h]
  unsigned __int64 v46; // [rsp+58h] [rbp-40h]

  v7 = a1;
  v8 = a3;
  v9 = (signed int)a2;
  v10 = a6;
  v11 = a1 + ((signed __int64)(signed int)a2 << 6);
  v41 = a2;
  v12 = *(void **)(v11 - 6144);
  v46 = __readfsqword(0x28u);
  if ( v12 )
    sub_2F4D0(v12);
  v13 = *(void **)(v7 + ((signed __int64)(signed int)a2 << 6) - 6136);
  if ( v13 )
    sub_2F4D0(v13);
  v14 = *(void **)(v7 + ((signed __int64)(signed int)a2 << 6) - 6128);
  if ( v14 )
    sub_2F4D0(v14);
  v15 = 6 * v10;
  v16 = 6 * v10;
  if ( *(_BYTE *)(v7 - 6176) )
  {
    v17 = v7 + ((signed __int64)(signed int)a2 << 6);
    *(_QWORD *)(v17 - 6128) = 0LL;
    *(_DWORD *)(v17 - 6112) = 0;
    *(_QWORD *)(v17 - 6136) = 0LL;
    *(_DWORD *)(v17 - 6116) = 0;
  }
  else
  {
    v43 = v8;
    v42 = v10;
    v25 = sub_2F450(v15, 1uLL, 0LL);
    v26 = v7 + ((signed __int64)(signed int)a2 << 6);
    *(_QWORD *)(v26 - 6128) = v25;
    *(_DWORD *)(v26 - 6112) = v15;
    v27 = sub_1BF60(&v43, &v42, *(_QWORD *)(v26 - 6128), v15, 0x37u, 0LL, 0LL, 0);
    v28 = v7 + ((signed __int64)(signed int)a2 << 6);
    *(_DWORD *)(v28 - 6112) = v27;
    if ( v27 )
    {
      v29 = v7 + ((signed __int64)(signed int)a2 << 6);
      v30 = sub_2F490(*(void **)(v28 - 6128), v27 + 1, 1uLL);
      v16 = v15;
      v31 = *(signed int *)(v29 - 6112);
      *(_QWORD *)(v29 - 6128) = v30;
      v30[v31] = 0;
      v32 = *(char **)(v29 - 6128);
    }
    else
    {
      sub_2F4D0(*(void **)(v28 - 6128));
      v32 = 0LL;
      v16 = v15;
      *(_QWORD *)(v7 + ((signed __int64)(signed int)a2 << 6) - 6128) = 0LL;
    }
    v33 = *(Display **)(v7 - 9440);
    list = v32;
    if ( v33
      && (v40 = v16,
          v34 = Xutf8TextListToTextProperty(v33, &list, 1, XCompoundTextStyle, &text_prop_return),
          v16 = v40,
          !v34) )
    {
      v36 = sub_2F450(text_prop_return.nitems + 1, 1uLL, 0LL);
      v37 = text_prop_return.nitems;
      v38 = text_prop_return.value;
      *(_QWORD *)(v7 + (v9 << 6) - 6136) = v36;
      memcpy(v36, v38, v37);
      v39 = text_prop_return.value;
      *(_DWORD *)(v7 + (v9 << 6) - 6116) = text_prop_return.nitems;
      XFree(v39);
      v16 = v40;
    }
    else
    {
      v35 = v7 + ((signed __int64)(signed int)a2 << 6);
      *(_QWORD *)(v35 - 6136) = 0LL;
      *(_DWORD *)(v35 - 6116) = 0;
    }
  }
  *(_QWORD *)(v11 - 6144) = sub_2F450(v16, 1uLL, 0LL);
  *(_DWORD *)(v7 + (v9 << 6) - 6120) = v15;
  v18 = sub_BB550(*(_DWORD *)(v7 - 5592), 0LL, v8, v10, *(_QWORD *)(v11 - 6144), v15, 0LL);
  *(_DWORD *)(v7 + (v9 << 6) - 6120) = v18;
  if ( v18 )
  {
    v21 = sub_2F490(*(void **)(v11 - 6144), v18, 1uLL);
    v19 = *(_QWORD *)(v11 - 6152);
    *(_QWORD *)(v11 - 6144) = v21;
    if ( v19 != 1 )
      goto LABEL_11;
  }
  else
  {
    sub_2F4D0(*(void **)(v11 - 6144));
    v19 = *(_QWORD *)(v11 - 6152);
    *(_QWORD *)(v11 - 6144) = 0LL;
    if ( v19 != 1 )
      goto LABEL_11;
  }
  v22 = *(Display **)(v7 - 9440);
  if ( v22 )
  {
    v23 = *(const char **)(v11 - 6144);
    v24 = *(_DWORD *)(v7 + (v9 << 6) - 6120);
    XRotateBuffers(v22, v19);
    XStoreBytes(*(Display **)(v7 - 9440), v23, v24);
    v19 = *(_QWORD *)(v11 - 6152);
  }
LABEL_11:
  if ( (unsigned int)gtk_selection_owner_set(*(_QWORD *)(v7 - 9536), v19, *(unsigned int *)(v7 - 192)) )
  {
    gtk_selection_clear_targets(*(_QWORD *)(v7 - 9536), *(_QWORD *)(v11 - 6152));
    gtk_selection_add_target(*(_QWORD *)(v7 - 9536), *(_QWORD *)(v11 - 6152), 31LL, 1LL);
    if ( *(_QWORD *)(v7 + (v9 << 6) - 6136) )
      gtk_selection_add_target(*(_QWORD *)(v7 - 9536), *(_QWORD *)(v11 - 6152), qword_326540, 1LL);
    if ( *(_QWORD *)(v7 + (v9 << 6) - 6128) )
      gtk_selection_add_target(*(_QWORD *)(v7 - 9536), *(_QWORD *)(v11 - 6152), qword_326548, 1LL);
  }
  if ( a7 )
    sub_994E0(*(const __m128i **)(v7 - 5632), v41);
  return __readfsqword(0x28u) ^ v46;
}

void __fastcall sub_ADFD0(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  if ( (_DWORD)a2 == 1 )
  {
    v2 = gdk_display_get_default(a1, a2);
    gdk_display_beep(v2);
  }
}

__int64 __fastcall sub_AE000(__int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax
  __int64 v3; // rdi

  v1 = a1;
  result = sub_1EF00(*(__int64 **)(a1 - 208), 117);
  if ( (_BYTE)result )
  {
    v3 = *(_QWORD *)(a1 - 9496);
    *(_BYTE *)(v1 - 5692) = 1;
    gtk_adjustment_set_lower(v3, 117LL);
    gtk_adjustment_set_upper(*(_QWORD *)(v1 - 9496));
    gtk_adjustment_set_value(*(_QWORD *)(v1 - 9496));
    gtk_adjustment_set_page_size(*(_QWORD *)(v1 - 9496));
    gtk_adjustment_set_step_increment(*(_QWORD *)(v1 - 9496));
    result = gtk_adjustment_set_page_increment(*(_QWORD *)(v1 - 9496));
    *(_BYTE *)(v1 - 5692) = 0;
  }
  return result;
}

__int64 __fastcall sub_AE0D0(_QWORD *a1)
{
  cairo_new_path(*a1);
  cairo_move_to(*a1);
  cairo_line_to(*a1);
  return cairo_stroke(*a1);
}

__int64 __fastcall sub_AE160(__int64 a1, __int64 *a2, int a3)
{
  __int64 v3; // r12
  __int64 *v4; // rbx
  int v5; // ebp
  __int64 v6; // rdi
  __int64 v7; // r14
  __int64 v8; // rax
  __int64 v9; // r13
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rbp
  signed __int64 v13; // r14
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // rax

  v3 = a1;
  v4 = a2;
  v5 = a3;
  gtk_widget_realize(a1);
  v6 = *a2;
  v7 = gdk_pixbuf_new_from_xpm_data(*a2);
  v8 = gtk_window_get_type(v6, a2);
  v9 = v8;
  v10 = g_type_check_instance_cast(v3, v8);
  gtk_window_set_icon(v10, v7);
  if ( v5 <= 0 )
  {
    v12 = 0LL;
  }
  else
  {
    v11 = (unsigned int)(v5 - 1);
    v12 = 0LL;
    v13 = (signed __int64)&a2[v11 + 1];
    do
    {
      v14 = *v4;
      ++v4;
      v15 = gdk_pixbuf_new_from_xpm_data(v14);
      v12 = g_list_append(v12, v15);
    }
    while ( v4 != (__int64 *)v13 );
  }
  v16 = g_type_check_instance_cast(v3, v9);
  return gtk_window_set_icon_list(v16, v12);
}

__int64 __fastcall sub_AE200(__int64 a1, int a2, char a3)
{
  unsigned __int16 *v3; // rcx
  __int64 v4; // rdi
  double v5; // xmm2_8
  double v6; // xmm1_8
  double v7; // xmm0_8

  v3 = (unsigned __int16 *)(a1 + 12LL * a2);
  v4 = *(_QWORD *)(a1 + 9448);
  v5 = (double)v3[116] / 65535.0;
  v6 = (double)v3[115] / 65535.0;
  if ( a3 )
    v7 = (double)v3[114] / 65535.0;
  return cairo_set_source_rgb(v4);
}

__int64 __fastcall sub_AE290(__int64 a1)
{
  __int64 result; // rax
  int v2; // eax
  unsigned int v3; // ebp
  unsigned int v4; // er12

  result = (**(__int64 (__fastcall ***)(signed __int64))(a1 + 9544))(a1 + 9544);
  if ( (_BYTE)result )
  {
    v2 = 2 * *(_DWORD *)(a1 + 9412);
    v3 = v2 + *(_DWORD *)(a1 + 3832) * *(_DWORD *)(a1 + 3840);
    v4 = v2 + *(_DWORD *)(a1 + 3836) * *(_DWORD *)(a1 + 3844);
    if ( !*(_DWORD *)(a1 + 9432) )
      sub_AE200(a1, 258, 0);
    sub_AD880(a1, 1);
    gtk_widget_queue_draw_area(*(_QWORD *)(a1 + 8), 0LL, 0LL, v3, v4);
    result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 9544) + 40LL))(a1 + 9544, 0LL);
  }
  return result;
}

__int64 __fastcall sub_AE360(__int64 a1, signed __int64 a2, int a3)
{
  __int64 v3; // rbx
  int v4; // ecx
  int v5; // ebp
  int v6; // kr00_4
  signed int v7; // eax
  __int64 v8; // rdx
  signed int v9; // er12
  char v10; // r13
  _QWORD *v11; // rdi
  __int64 result; // rax
  int v13; // ecx
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rdi
  __int64 v18; // rax
  signed int v19; // eax

  v3 = a1;
  v4 = 2 * *(_DWORD *)(a1 + 9412);
  v5 = ((signed int)a2 - v4) / *(_DWORD *)(a1 + 3832);
  v6 = a3 - v4;
  v8 = (unsigned int)((a3 - v4) >> 31);
  v7 = __PAIR__(v8, v6) / *(signed int *)(a1 + 3836);
  LODWORD(v8) = __PAIR__(v8, v6) % *(signed int *)(a1 + 3836);
  v9 = v7;
  if ( *(_DWORD *)(a1 + 3840) != v5 || (v10 = 0, *(_DWORD *)(a1 + 3844) != v7) )
  {
    v11 = *(_QWORD **)(a1 + 9336);
    *(_DWORD *)(v3 + 3840) = v5;
    *(_DWORD *)(v3 + 3844) = v7;
    v10 = 1;
    sub_1F760(v11, 123, v5);
    a2 = 124LL;
    sub_1F760(*(_QWORD **)(v3 + 9336), 124, *(_DWORD *)(v3 + 3844));
    *(_DWORD *)(v3 + 36) = 1;
  }
  result = gtk_widget_get_scale_factor(*(_QWORD *)(v3 + 8), a2, v8);
  if ( *(_DWORD *)(v3 + 3848) != (_DWORD)result )
    *(_DWORD *)(v3 + 36) = 1;
  v13 = 2 * *(_DWORD *)(v3 + 9412);
  v14 = (unsigned int)(result * (v13 + v5 * *(_DWORD *)(v3 + 3832)));
  v15 = (unsigned int)(result * (v13 + v9 * *(_DWORD *)(v3 + 3836)));
  if ( *(_DWORD *)(v3 + 120) != (_DWORD)v14 || *(_DWORD *)(v3 + 124) != (_DWORD)v15 || *(_DWORD *)(v3 + 36) )
  {
    v16 = *(_QWORD *)(v3 + 112);
    *(_DWORD *)(v3 + 36) = 0;
    *(_DWORD *)(v3 + 3848) = result;
    *(_DWORD *)(v3 + 120) = v14;
    *(_DWORD *)(v3 + 124) = v15;
    if ( v16 )
    {
      cairo_surface_destroy(v16);
      v15 = *(unsigned int *)(v3 + 124);
      v14 = *(unsigned int *)(v3 + 120);
      *(_QWORD *)(v3 + 112) = 0LL;
    }
    *(_QWORD *)(v3 + 112) = cairo_image_surface_create(0LL, v14, v15);
    sub_AE290(v3);
    if ( v10 )
    {
      if ( !*(_QWORD *)(v3 + 3912) )
      {
LABEL_12:
        v18 = gtk_widget_get_window(*(_QWORD *)(v3 + 8));
        return gtk_im_context_set_client_window(*(_QWORD *)(v3 + 128), v18);
      }
      v19 = sub_1EFD0(*(__int64 **)(v3 + 9336), 104);
      sub_91860(*(const __m128i **)(v3 + 3912), v9, v5, v19);
    }
    v17 = *(_QWORD *)(v3 + 3912);
    if ( v17 )
      sub_90EF0(v17);
    goto LABEL_12;
  }
  return result;
}

unsigned __int64 __fastcall sub_AE500(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v4; // [rsp+0h] [rbp-28h]
  unsigned int v5; // [rsp+8h] [rbp-20h]
  int v6; // [rsp+Ch] [rbp-1Ch]
  unsigned __int64 v7; // [rsp+18h] [rbp-10h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 8);
  v7 = __readfsqword(0x28u);
  gtk_widget_get_allocation(v2, &v4);
  sub_AE360(v1, v5, v6);
  return __readfsqword(0x28u) ^ v7;
}

__int64 __fastcall sub_AE550(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rbx
  int v5; // ebp
  __int64 v6; // rdi

  result = *(unsigned int *)(a1 + 36);
  if ( !(_DWORD)result )
  {
    v4 = a1;
    v5 = *(_DWORD *)(a1 + 3848);
    result = gtk_widget_get_scale_factor(*(_QWORD *)(a1 + 8), a2, a3);
    if ( v5 != (_DWORD)result )
    {
      result = sub_AE500(a1);
      v6 = *(_QWORD *)(a1 + 3912);
      if ( v6 )
      {
        sub_90EF0(v6);
        result = sub_8FD90(*(const __m128i **)(v4 + 3912));
      }
    }
  }
  return result;
}

signed __int64 __fastcall sub_AE5C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // r12
  __int64 v6; // [rsp+10h] [rbp-78h]
  __int64 v7; // [rsp+18h] [rbp-70h]
  int v8; // [rsp+20h] [rbp-68h]
  char v9; // [rsp+30h] [rbp-58h]
  unsigned __int64 v10; // [rsp+68h] [rbp-20h]

  v3 = a3;
  v10 = __readfsqword(0x28u);
  sub_AE550(a3, a2, a3);
  if ( *(_QWORD *)(v3 + 112) )
  {
    v4 = cairo_get_target(a2);
    cairo_get_matrix(a2, &v9);
    cairo_surface_get_device_scale(v4, &v6, &v7);
    cairo_surface_set_device_scale(v4);
    cairo_translate(a2);
    gdk_cairo_get_clip_rectangle(a2, &v8);
    cairo_set_source_surface(a2, *(_QWORD *)(v3 + 112));
    cairo_rectangle(a2);
    cairo_fill(a2);
    cairo_surface_set_device_scale(v4);
  }
  return 1LL;
}

__int64 __fastcall sub_AE700(__int64 a1, __int64 a2, __int64 a3)
{
  sub_AE550(a3, a2, a3);
  return 0LL;
}

unsigned __int64 __fastcall sub_AE720(__int64 a1, _DWORD *a2)
{
  int v2; // edx
  unsigned __int64 result; // rax

  v2 = a2[7];
  a2[8] = 1;
  if ( v2 )
  {
    result = (unsigned int)a2[9];
    if ( (_DWORD)result )
      result = sub_AE500((__int64)a2);
  }
  return result;
}

__int64 __fastcall sub_AE750(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  result = *(unsigned int *)(a3 + 32);
  *(_DWORD *)(a3 + 28) = 1;
  if ( (_DWORD)result )
    result = sub_AE360(a3, *(unsigned int *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return result;
}

__int64 __fastcall sub_AE780(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 + 9432);
  if ( !(_DWORD)result )
    result = cairo_set_source_rgb(*(_QWORD *)(a1 + 9448));
  return result;
}

__int64 __fastcall sub_AE810(__int64 a1, int a2, int a3, __int64 a4, int a5, unsigned __int64 a6, char a7, __int64 a8)
{
  signed int v8; // er15
  unsigned __int64 v9; // r14
  __int64 v10; // rbx
  int v11; // er12
  __int64 v12; // rdi
  __int64 v13; // rax
  int v14; // eax
  char v15; // cl
  int v16; // er11
  char v17; // di
  char v18; // si
  int v19; // esi
  int v20; // esi
  unsigned __int64 v21; // rax
  int v22; // er13
  int v23; // er10
  int v24; // eax
  char v25; // ST8F_1
  int v26; // ST88_4
  int v27; // ST84_4
  int v28; // ST80_4
  __int64 v29; // r15
  int v30; // ST7C_4
  signed __int64 v31; // r15
  int v32; // ST50_4
  __int64 v33; // rax
  __int64 v34; // r9
  int v35; // edx
  int v36; // er10
  __int64 v37; // rbp
  __int64 v38; // rcx
  __int64 v39; // ST10_8
  __int64 v40; // rcx
  __int64 result; // rax
  unsigned __int64 v42; // rt1
  int v43; // er10
  __int64 i; // rax
  __int64 v45; // rsi
  __int64 v46; // r13
  __int64 v47; // rdx
  int v48; // ST7C_4
  __int64 v49; // rcx
  __int64 v50; // ST10_8
  int v51; // edi
  int v52; // eax
  int v53; // esi
  int v54; // edx
  int v55; // esi
  char v56; // ST84_1
  int v57; // ST80_4
  int v58; // ST7C_4
  int v59; // [rsp+Ch] [rbp-DCh]
  char v60; // [rsp+10h] [rbp-D8h]
  int v61; // [rsp+14h] [rbp-D4h]
  int v62; // [rsp+18h] [rbp-D0h]
  signed int v63; // [rsp+1Ch] [rbp-CCh]
  int v64; // [rsp+40h] [rbp-A8h]
  int v65; // [rsp+44h] [rbp-A4h]
  __int64 v66; // [rsp+70h] [rbp-78h]
  __int64 v67; // [rsp+78h] [rbp-70h]
  __int64 v68; // [rsp+80h] [rbp-68h]
  __int64 v69; // [rsp+88h] [rbp-60h]
  double v70; // [rsp+90h] [rbp-58h]
  double v71; // [rsp+98h] [rbp-50h]
  unsigned __int64 v72; // [rsp+A8h] [rbp-40h]

  v8 = a5;
  v9 = a6;
  v10 = a1;
  v11 = a2;
  v12 = *(_QWORD *)(a1 + 8);
  v72 = __readfsqword(0x28u);
  v62 = a3;
  v59 = a5;
  v60 = BYTE4(a8);
  v13 = gtk_widget_get_visual(v12);
  v14 = gdk_visual_get_depth(v13);
  v63 = 1;
  v15 = a8;
  if ( (v9 & 0x80000000) != 0LL )
  {
    v63 = v8;
    v59 = 1;
  }
  if ( v14 == 1 )
  {
    v61 = 258;
    v15 = dword_F5931;
    v17 = (v9 >> 30) & 1;
    v16 = 256;
    v60 = dword_F5931;
  }
  else
  {
    v16 = v9 & 0x1FF;
    v61 = (v9 >> 9) & 0x1FF;
    v17 = 0;
  }
  if ( v17 == ((v9 >> 20) & 1) )
  {
    v18 = v60;
    v60 = v15;
    v15 = v18;
    v19 = v61;
    v61 = v16;
    v16 = v19;
  }
  v20 = *(_DWORD *)(v10 + 9408);
  if ( v20 & 2 )
  {
    if ( !(v9 & 0x40000) )
      goto LABEL_11;
    if ( v61 <= 15 )
    {
      v61 |= 8u;
LABEL_11:
      if ( !(v9 & 0x200000) )
        goto LABEL_12;
      goto LABEL_40;
    }
    v51 = v61 | 1;
    if ( v61 <= 255 )
      v51 = v61;
    v61 = v51;
    if ( v9 & 0x200000 )
    {
LABEL_40:
      if ( v16 > 15 )
      {
        if ( v16 > 255 )
          v16 |= 1u;
      }
      else
      {
        v16 |= 8u;
      }
      goto LABEL_12;
    }
  }
LABEL_12:
  if ( v14 != 1 && (v9 >> 30) & 1 )
  {
    v15 = dword_F5931;
    v9 = (unsigned int)v9 & 0xFEFFFFFF;
    v16 = 261;
    v61 = 260;
    v60 = dword_F5931;
  }
  v21 = v9 & 0x400000;
  v22 = 2 - (v21 < 1);
  v23 = v21 >= 1 ? 2 : 0;
  if ( v9 & 0x40000 && v20 & 1 )
  {
    v23 |= 1u;
    if ( *(_QWORD *)(v10 + 8LL * v23 + 136) )
      goto LABEL_18;
  }
  else if ( *(_QWORD *)(v10 + 8LL * (v21 >= 1 ? 2 : 0) + 136) )
  {
    goto LABEL_18;
  }
  LODWORD(i) = v23 - 1;
  v43 = ~v23;
  for ( i = (signed int)i; ; --i )
  {
    if ( i == -1 )
      __assert_fail("inst->fonts[fontid]", "unix/gtkwin.c", 0xEA1u, "do_text_internal");
    if ( !((unsigned int)i & v43) && *(_QWORD *)(v10 + 8 * i + 136) )
      break;
  }
  v23 = i;
LABEL_18:
  v65 = a7 & 3;
  if ( a7 & 3 )
  {
    v11 *= 2;
    v24 = *(_DWORD *)(*(_QWORD *)(v10 + 3912) + 416LL);
    if ( v24 <= v11 )
      goto LABEL_38;
    if ( v24 < v22 * 2 * v59 + v11 )
    {
      v59 = ((v24 - v11) >> 1) / v22;
      if ( !v59 )
        goto LABEL_38;
    }
  }
  if ( !*(_DWORD *)(v10 + 9432) )
  {
    v25 = v15;
    v26 = v23;
    v27 = v16;
    v28 = *(_DWORD *)(v10 + 3836);
    v29 = *(unsigned int *)(v10 + 3832);
    v30 = *(_DWORD *)(v10 + 9412);
    cairo_reset_clip(*(_QWORD *)(v10 + 9448));
    cairo_new_path(*(_QWORD *)(v10 + 9448));
    cairo_rectangle(*(_QWORD *)(v10 + 9448));
    cairo_clip(*(_QWORD *)(v10 + 9448));
    v15 = v25;
    v23 = v26;
    v16 = v27;
  }
  if ( a7 & 3 )
  {
    if ( *(_DWORD *)(v10 + 9432) )
    {
      v31 = (v9 >> 24) & 1;
      if ( !v15 )
        goto LABEL_27;
      goto LABEL_57;
    }
    v52 = *(_DWORD *)(v10 + 3832);
    v53 = *(_DWORD *)(v10 + 9412);
    v54 = *(_DWORD *)(v10 + 3836);
    v68 = 0LL;
    v67 = 0LL;
    v66 = 0x4000000000000000LL;
    v70 = (double)-(v53 + v11 * v52);
    if ( v65 == 1 )
    {
      v71 = 0.0;
      v69 = 4607182418800017408LL;
    }
    else
    {
      v69 = 0x4000000000000000LL;
      v55 = v54 * v62 + v53;
      if ( v65 == 3 )
        v71 = (double)-(v55 + v54);
      else
        v71 = (double)-v55;
    }
    v56 = v15;
    v57 = v23;
    v58 = v16;
    cairo_transform(*(_QWORD *)(v10 + 9448), &v66);
    v15 = v56;
    v23 = v57;
    v16 = v58;
  }
  v31 = (v9 >> 24) & 1;
  if ( v15 )
  {
LABEL_57:
    v48 = v23;
    sub_AE780(v10);
    v23 = v48;
    goto LABEL_27;
  }
  if ( !*(_DWORD *)(v10 + 9432) )
  {
    v32 = v23;
    sub_AE200(v10, v16, BYTE3(v9) & 1);
    v23 = v32;
  }
LABEL_27:
  v33 = *(unsigned int *)(v10 + 3832);
  v34 = *(unsigned int *)(v10 + 3836);
  v35 = *(_DWORD *)(v10 + 9412);
  v64 = v23;
  sub_AD880(v10, 1);
  v36 = v64;
  if ( !v60 )
  {
    if ( !*(_DWORD *)(v10 + 9432) )
    {
      sub_AE200(v10, v61, v31);
      v36 = v64;
    }
    if ( v63 > 1 )
      goto LABEL_31;
LABEL_59:
    v37 = v36;
    v49 = (unsigned int)(*(_DWORD *)(*(_QWORD *)(v10 + 136) + 20LL)
                       + *(_DWORD *)(v10 + 9412)
                       + *(_DWORD *)(v10 + 3836) * v62);
    v50 = *(unsigned int *)(v10 + 3832);
    sub_A3FC0(v10 + 9432, *(_QWORD *)(v10 + 8LL * v36 + 136));
    goto LABEL_33;
  }
  sub_AE780(v10);
  v36 = v64;
  if ( v63 <= 1 )
    goto LABEL_59;
LABEL_31:
  if ( v59 != 1 )
    goto LABEL_76;
  v37 = v36;
  v38 = (unsigned int)(*(_DWORD *)(*(_QWORD *)(v10 + 136) + 20LL)
                     + *(_DWORD *)(v10 + 9412)
                     + *(_DWORD *)(v10 + 3836) * v62);
  v39 = *(unsigned int *)(v10 + 3832);
  sub_A3FE0(v10 + 9432, *(_QWORD *)(v10 + 8LL * v36 + 136));
LABEL_33:
  if ( !(v9 & 0x80000) )
  {
LABEL_50:
    if ( v9 & 0x2000000 && !*(_DWORD *)(v10 + 9432) )
    {
      v46 = (unsigned int)(*(_DWORD *)(v10 + 3832) * (v11 + v59) * v22);
      v47 = (unsigned int)(*(_DWORD *)(v10 + 9412)
                         + *(_DWORD *)(*(_QWORD *)(v10 + 8 * v37 + 136) + 28LL)
                         + *(_DWORD *)(v10 + 3836) * v62);
      sub_AE0D0((_QWORD *)(v10 + 9448));
    }
    goto LABEL_35;
  }
  v40 = (unsigned int)(*(_DWORD *)(v10 + 3836) - 1);
  *(_DWORD *)(*(_QWORD *)(v10 + 136) + 20LL);
  if ( !*(_DWORD *)(v10 + 9432) )
  {
    v45 = (unsigned int)(*(_DWORD *)(v10 + 9412) + v11 * *(_DWORD *)(v10 + 3832));
    sub_AE0D0((_QWORD *)(v10 + 9448));
    goto LABEL_50;
  }
LABEL_35:
  if ( a7 & 3 )
  {
    if ( !*(_DWORD *)(v10 + 9432) )
      cairo_set_matrix(*(_QWORD *)(v10 + 9448), v10 + 9456);
  }
LABEL_38:
  v42 = __readfsqword(0x28u);
  result = v42 ^ v72;
  if ( v42 != v72 )
LABEL_76:
    __assert_fail("len == 1", "unix/gtkwin.c", 0xECFu, "do_text_internal");
  return result;
}

__int64 __fastcall sub_AF250(__int64 a1, int a2, int a3, __int64 a4, int a5, unsigned __int64 a6, char a7, __int64 a8)
{
  int v8; // er15
  int v9; // ebp
  int v10; // er13
  int v11; // ebx
  int v12; // ecx
  __int64 result; // rax
  int v14; // ebx

  v8 = a6;
  v9 = a3;
  v10 = a2;
  v11 = a5;
  sub_AE810(a1 - 9544, a2, a3, a4, a5, a6, a7, a8);
  v12 = ((v8 & 0x400000) != 0) + 1;
  if ( !(a7 & 3) )
    goto LABEL_5;
  v10 = 2 * a2;
  result = *(unsigned int *)(*(_QWORD *)(a1 - 5632) + 416LL);
  if ( (signed int)result <= 2 * a2 )
    return result;
  v14 = v12 * 2 * v11;
  if ( (signed int)result < v14 + v10 )
  {
    v11 = 2 * ((((signed int)result - v10) >> 1) / v12);
LABEL_5:
    v14 = v12 * v11;
  }
  return gtk_widget_queue_draw_area(
           *(_QWORD *)(a1 - 9536),
           (unsigned int)(*(_DWORD *)(a1 - 5712) * v10 + *(_DWORD *)(a1 - 132)),
           (unsigned int)(*(_DWORD *)(a1 - 5708) * v9 + *(_DWORD *)(a1 - 132)),
           (unsigned int)(*(_DWORD *)(a1 - 5712) * v14),
           *(unsigned int *)(a1 - 5708));
}

unsigned __int64 __fastcall sub_AF330(__int64 a1, int a2, int a3, __int64 a4, int a5, unsigned __int64 a6, char a7, __int64 a8)
{
  char v8; // r15
  int v9; // er13
  int v10; // ebp
  __int64 v11; // rbx
  int v12; // er12
  unsigned __int64 v13; // r10
  __int64 v14; // r14
  int v15; // ecx
  int v16; // edx
  int v17; // er12
  int v18; // ecx
  __int64 v19; // rax
  int v20; // esi
  __int64 v21; // r8
  int v22; // eax
  int v23; // ecx
  __int64 v24; // rdi
  int v26; // eax
  int v27; // edx
  int v28; // er8
  int v29; // edx
  int v30; // ecx
  signed int v31; // er10
  int v32; // er9
  int v33; // eax
  int v34; // er14
  int v35; // ST28_4
  signed int v36; // ST24_4
  int v37; // ST20_4
  int v38; // ST2C_4
  int v39; // ST10_4
  int v40; // esi
  int v41; // er9
  int v42; // ST2C_4
  int v43; // ST28_4
  int v44; // ST24_4
  signed int v45; // ST20_4
  int v46; // ST10_4
  int v47; // [rsp+0h] [rbp-78h]
  char v48; // [rsp+Ch] [rbp-6Ch]
  int v49; // [rsp+20h] [rbp-58h]
  int v50; // [rsp+24h] [rbp-54h]
  int v51; // [rsp+28h] [rbp-50h]
  int v52; // [rsp+2Ch] [rbp-4Ch]
  unsigned __int64 v53; // [rsp+38h] [rbp-40h]

  v8 = 0;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = a5;
  v13 = a6;
  v14 = a1 - 9544;
  v53 = __readfsqword(0x28u);
  if ( a6 & 0x20000000 )
  {
    v13 = a6 & 0xFFFFFFFFDFFFFFFFLL;
    v8 = 1;
  }
  v48 = 0;
  if ( v13 & 0x40000000 && *(_DWORD *)(a1 - 128) )
  {
    v13 &= 0xFFFFFFFFBFFFFFFFLL;
    v48 = 1;
  }
  v47 = v13;
  sub_AE810(a1 - 9544, a2, a3, a4, a5, v13, a7, a8);
  if ( v47 < 0 )
    v12 = 1;
  v15 = ((v47 & 0x400000) != 0) + 1;
  if ( !(a7 & 3) )
    goto LABEL_12;
  v10 = 2 * a2;
  v16 = *(_DWORD *)(*(_QWORD *)(a1 - 5632) + 416LL);
  if ( v16 > 2 * a2 )
  {
    v17 = v15 * 2 * v12;
    if ( v16 >= v17 + v10 )
      goto LABEL_13;
    v12 = 2 * (((v16 - v10) >> 1) / v15);
LABEL_12:
    v17 = v15 * v12;
LABEL_13:
    v18 = *(_DWORD *)(a1 - 128);
    if ( !v18 )
    {
      if ( v8 )
      {
        if ( !*(_DWORD *)(a1 - 112) )
          sub_AE200(v14, 261, 0);
        v19 = *(unsigned int *)(a1 - 5708);
        v20 = *(_DWORD *)(a1 - 132);
        v21 = (unsigned int)(v17 * *(_DWORD *)(a1 - 5712) - 1);
        sub_AD880(v14, 0);
      }
LABEL_18:
      gtk_widget_queue_draw_area(
        *(_QWORD *)(a1 - 9536),
        (unsigned int)(*(_DWORD *)(a1 - 132) + v10 * *(_DWORD *)(a1 - 5712)),
        (unsigned int)(*(_DWORD *)(a1 - 132) + v9 * *(_DWORD *)(a1 - 5708)),
        (unsigned int)(v17 * *(_DWORD *)(a1 - 5712)),
        *(unsigned int *)(a1 - 5708));
      v22 = *(_DWORD *)(a1 - 5712);
      v23 = *(_DWORD *)(a1 - 132);
      v24 = *(_QWORD *)(a1 - 9416);
      v52 = *(_DWORD *)(v11 - 5708);
      v49 = v23 + v22 * v10;
      v50 = v23 + v52 * v9;
      v51 = v22 * v17;
      gtk_im_context_set_cursor_location(v24, &v49);
      return __readfsqword(0x28u) ^ v53;
    }
    v26 = *(_DWORD *)(a1 - 5712);
    if ( v47 & 0x400000 || (v27 = *(_DWORD *)(a1 - 5712), a7 & 3) )
      v27 = 2 * v26;
    v28 = *(_DWORD *)(a1 - 5708);
    if ( v18 == 1 )
    {
      v40 = *(_DWORD *)(*(_QWORD *)(a1 - 9408) + 20LL) + 1;
      v41 = *(_DWORD *)(a1 - 132);
      if ( v40 >= v28 )
        v40 = v28 - 1;
      v31 = 0;
      v33 = v41 + v10 * v26;
      v32 = v40 + v9 * v28 + v41;
      v28 = v17 * v27;
      if ( *(_DWORD *)(a1 - 112) )
        goto LABEL_26;
    }
    else
    {
      v29 = v27 - 1;
      if ( !(v47 & 0x10000000) )
        v29 = 0;
      v30 = *(_DWORD *)(a1 - 132);
      v31 = 1;
      v32 = v30 + v28 * v9;
      v33 = v29 + v30 + v10 * v26;
      v18 = 0;
      if ( *(_DWORD *)(a1 - 112) )
        goto LABEL_26;
    }
    v42 = v32;
    v43 = v33;
    v44 = v28;
    v45 = v31;
    v46 = v18;
    sub_AE200(v14, 261, 0);
    v32 = v42;
    v33 = v43;
    v28 = v44;
    v31 = v45;
    v18 = v46;
LABEL_26:
    if ( v8 )
    {
      if ( v28 > 0 )
      {
        v34 = 0;
        do
        {
          if ( !(v34 & 1) && !*(_DWORD *)(a1 - 112) )
          {
            v35 = v28;
            v36 = v31;
            v37 = v18;
            v38 = v32;
            v39 = v33;
            cairo_new_path(*(_QWORD *)(a1 - 96));
            cairo_rectangle(*(_QWORD *)(a1 - 96));
            cairo_fill(*(_QWORD *)(a1 - 96));
            v28 = v35;
            v31 = v36;
            v18 = v37;
            v33 = v39;
            v32 = v38;
          }
          ++v34;
          v33 += v18;
          v32 += v31;
        }
        while ( v28 != v34 );
      }
    }
    else if ( v48 && !*(_DWORD *)(a1 - 112) )
    {
      sub_AE0D0((_QWORD *)(a1 - 96));
    }
    goto LABEL_18;
  }
  return __readfsqword(0x28u) ^ v53;
}

_QWORD *__usercall sub_AF750@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>)
{
  _BYTE *v3; // rsi
  const char *v4; // rdi
  signed __int64 v5; // rcx
  _QWORD *result; // rax

  v3 = a3;
  v4 = "Font";
  v5 = 5LL;
  do
  {
    if ( !v5 )
      break;
    a1 = *v3 < (const unsigned __int8)*v4;
    a2 = *v3++ == *v4++;
    --v5;
  }
  while ( a2 );
  if ( (!a1 && !a2) == a1 )
    result = sub_B51E0("server:fixed");
  else
    result = sub_B51E0(&locale);
  return result;
}

_QWORD *__usercall sub_AF790@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>)
{
  _BYTE *v3; // rsi
  const char *v4; // rdi
  signed __int64 v5; // rcx
  _QWORD *result; // rax

  v3 = a3;
  v4 = "LogFileName";
  v5 = 12LL;
  do
  {
    if ( !v5 )
      break;
    a1 = *v3 < (const unsigned __int8)*v4;
    a2 = *v3++ == *v4++;
    --v5;
  }
  while ( a2 );
  if ( (!a1 && !a2) == a1 )
    result = sub_B4DD0("putty.log");
  else
    result = sub_B4DD0(&locale);
  return result;
}

char *__usercall sub_AF7D0@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>)
{
  _BYTE *v3; // rsi
  const char *v4; // rdi
  signed __int64 v5; // rcx
  char *result; // rax

  v3 = a3;
  v4 = "SerialLine";
  v5 = 11LL;
  do
  {
    if ( !v5 )
      break;
    a1 = *v3 < (const unsigned __int8)*v4;
    a2 = *v3++ == *v4++;
    --v5;
  }
  while ( a2 );
  if ( (!a1 && !a2) == a1 )
    result = sub_BC120("/dev/ttyS0");
  else
    result = 0LL;
  return result;
}

__int64 __usercall sub_AF810@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>, unsigned int a4@<esi>)
{
  _BYTE *v4; // rdx
  const char *v5; // rdi
  __int64 result; // rax
  signed __int64 v7; // rcx
  _BYTE *v8; // rsi

  v4 = a3;
  v5 = "WinNameAlways";
  result = a4;
  v7 = 14LL;
  v8 = v4;
  do
  {
    if ( !v7 )
      break;
    a1 = *v8 < (const unsigned __int8)*v5;
    a2 = *v8++ == *v5++;
    --v7;
  }
  while ( a2 );
  if ( (!a1 && !a2) == a1 )
    result = 0LL;
  return result;
}

signed __int64 __usercall sub_AF840@<rax>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>, unsigned int a4@<esi>)
{
  _BYTE *v4; // rdx
  const char *v5; // rdi
  signed __int64 result; // rax
  signed __int64 v7; // rcx
  _BYTE *v8; // rsi

  v4 = a3;
  v5 = "CloseOnExit";
  result = a4;
  v7 = 12LL;
  v8 = v4;
  do
  {
    if ( !v7 )
      break;
    a1 = *v8 < (const unsigned __int8)*v5;
    a2 = *v8++ == *v5++;
    --v7;
  }
  while ( a2 );
  if ( (!a1 && !a2) == a1 )
    result = 2LL;
  return result;
}

__int64 __fastcall sub_AF870(__int64 a1)
{
  return *(_QWORD *)(a1 - 9536);
}

signed __int64 __fastcall sub_AF880(__int64 (__fastcall ***a1)(), unsigned int a2, __int64 a3)
{
  signed __int64 result; // rax

  if ( *a1 != off_324AA0 )
    __assert_fail("seat->vt == &gtk_seat_vt", "unix/gtkwin.c", 0x1E5u, "register_dialog");
  if ( a2 > 4 )
    __assert_fail("slot < DIALOG_SLOT_LIMIT", "unix/gtkwin.c", 0x1E7u, "register_dialog");
  result = (signed __int64)&a1[a2];
  if ( *(_QWORD *)(result - 176) )
    __assert_fail("!inst->dialogs[slot]", "unix/gtkwin.c", 0x1E8u, "register_dialog");
  *(_QWORD *)(result - 176) = a3;
  return result;
}

void __fastcall sub_AF910(__int64 a1, char *a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r13
  char *v12; // rbp
  int v13; // eax
  __int64 v14; // rax

  v11 = a3;
  v12 = sub_BC160("PuTTY", a4, a5, a6, a7, a8, a9, a10, a11, &unk_F87F5, 0LL);
  v13 = sub_AB5C0((__int64)"REASONABLY LONG LINE OF TEXT FOR BASIC SANITY");
  v14 = sub_A2C30(*(_QWORD *)a1, (__int64)v12, a2, v13, 0, (__int64)&off_322580, v11, a1);
  sub_AF880((__int64 (__fastcall ***)())(a1 + 9536), 4u, v14);
  sub_2F4D0(v12);
}

_QWORD *__fastcall sub_AF9A0(__int64 a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbp
  double v11; // xmm4_8
  double v12; // xmm5_8

  v10 = a1 - 9536;
  if ( (unsigned int)sub_1EFD0(*(__int64 **)(a1 - 200), 4) )
    sub_AF910(v10, a2, (__int64)sub_AFD00, a3, a4, a5, a6, v11, v12, a9, a10);
  else
    sub_AF910(v10, a2, (__int64)sub_AFCD0, a3, a4, a5, a6, v11, v12, a9, a10);
  *(_BYTE *)(a1 - 5608) = 1;
  return sub_1BD80((__int64)sub_ABD90, v10);
}

signed __int64 __fastcall sub_AFA10(double a1, double a2, double a3, double a4, __int64 a5, __int64 a6, __int64 a7, double a8, double a9, double a10, double a11)
{
  signed __int64 result; // rax
  __int64 v12; // rbx
  char v13; // dl
  double v14; // xmm4_8
  double v15; // xmm5_8
  char *v16; // rax
  __int64 v17; // rdi
  char *v18; // r13
  __int64 (*v19)(void); // rax
  __int64 v20; // rax
  void *v21; // rbp
  char *v22; // rsi
  char *v23; // rdx
  char *v24; // r12
  int v25; // eax
  __int64 v26; // rax

  if ( *(_BYTE *)(a7 + 3928) )
    return 0LL;
  v12 = a7;
  if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(a7 + 9336), 5) )
    return 0LL;
  v13 = sub_ABE30(v12, 3LL);
  result = 1LL;
  if ( !v13 )
  {
    v16 = sub_BC160("PuTTY", a1, a2, a3, a4, v14, v15, a10, a11, " Exit Confirmation", 0LL);
    v17 = *(_QWORD *)(v12 + 3904);
    v18 = v16;
    if ( v17 && (v19 = *(__int64 (**)(void))(*(_QWORD *)v17 + 128LL)) != 0LL )
    {
      v20 = v19();
      v21 = (void *)v20;
      if ( v20 )
      {
        v22 = "\n";
        v23 = (char *)v20;
      }
      else
      {
        v23 = &locale;
        v22 = &locale;
      }
    }
    else
    {
      v23 = &locale;
      v21 = 0LL;
      v22 = &locale;
    }
    v24 = sub_BC360((__int64)"Are you sure you want to close this session?%s%s", v22, v23);
    v25 = sub_AB5C0((__int64)"Most of the width of the above text");
    v26 = sub_A2C30(*(_QWORD *)v12, (__int64)v18, v24, v25, 0, (__int64)&off_3225B0, (__int64)sub_AFD20, v12);
    sub_AF880((__int64 (__fastcall ***)())(v12 + 9536), 3u, v26);
    sub_2F4D0(v18);
    sub_2F4D0(v24);
    sub_2F4D0(v21);
    result = 1LL;
  }
  return result;
}

void __fastcall sub_AFB60(double a1, double a2, double a3, double a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbx
  double v11; // xmm4_8
  double v12; // xmm5_8
  char *v13; // r12
  _QWORD *v14; // rax
  _QWORD *v15; // rdi
  __int64 v16; // rbp
  _QWORD *v17; // rax
  __int64 v18; // rdi
  _QWORD *v19; // rsi
  __int64 v20; // rdi
  int v21; // ecx
  __int64 v22; // rax

  v10 = a6;
  if ( !(unsigned __int8)sub_ABE30(a6, 0LL) )
  {
    v13 = sub_BC160("PuTTY", a1, a2, a3, a4, v11, v12, a9, a10, " Reconfiguration", 0LL);
    v14 = sub_2F450(1uLL, 0x10uLL, 0LL);
    v15 = *(_QWORD **)(a6 + 9336);
    *v14 = a6;
    v16 = (__int64)v14;
    v17 = sub_1EED0(v15);
    v18 = *(_QWORD *)(a6 + 3912);
    *(_QWORD *)(v16 + 8) = v17;
    v19 = v17;
    sub_906C0(v18, v17);
    v20 = *(_QWORD *)(v10 + 3904);
    if ( v20 )
      v21 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v20 + 112LL))(v20, v19);
    else
      v21 = 0;
    v22 = sub_A20F0((__int64)v13, *(__int64 **)(v16 + 8), 1u, v21, (__int64)sub_B1FA0, v16);
    sub_AF880((__int64 (__fastcall ***)())(v10 + 9536), 0, v22);
    sub_2F4D0(v13);
  }
}

signed __int64 __fastcall sub_AFC30(__int64 (__fastcall ***a1)(), unsigned int a2)
{
  signed __int64 result; // rax

  if ( *a1 != off_324AA0 )
    __assert_fail("seat->vt == &gtk_seat_vt", "unix/gtkwin.c", 0x1EEu, "unregister_dialog");
  if ( a2 > 4 )
    __assert_fail("slot < DIALOG_SLOT_LIMIT", "unix/gtkwin.c", 0x1F0u, "unregister_dialog");
  result = (signed __int64)&a1[a2];
  if ( !*(_QWORD *)(result - 176) )
    __assert_fail("inst->dialogs[slot]", "unix/gtkwin.c", 0x1F1u, "unregister_dialog");
  *(_QWORD *)(result - 176) = 0LL;
  return result;
}

_QWORD *__fastcall sub_AFCD0(__int64 a1)
{
  sub_AFC30((__int64 (__fastcall ***)())(a1 + 9536), 4u);
  return sub_1BD80((__int64)sub_AB8F0, a1);
}

signed __int64 __fastcall sub_AFD00(__int64 a1)
{
  return sub_AFC30((__int64 (__fastcall ***)())(a1 + 9536), 4u);
}

signed __int64 __fastcall sub_AFD20(__int64 a1, int a2)
{
  signed __int64 result; // rax

  result = sub_AFC30((__int64 (__fastcall ***)())(a1 + 9536), 3u);
  if ( a2 )
    result = gtk_widget_destroy(*(_QWORD *)a1);
  return result;
}

signed __int64 __fastcall sub_AFD60(__int64 a1, unsigned int a2, double a3, double a4, double a5)
{
  int v5; // edx
  signed int v6; // ebp
  signed int v7; // er12
  signed int v8; // er15
  double v9; // xmm0_8
  signed int v10; // eax
  int v11; // er14
  double v12; // xmm1_8
  int v13; // er12
  bool v14; // r15
  int v15; // ebp
  double v17; // xmm0_8
  int v18; // ebx
  __int32 v19; // [rsp+10h] [rbp-58h]
  double v20; // [rsp+18h] [rbp-50h]
  int v21; // [rsp+2Ch] [rbp-3Ch]

  v20 = a4;
  sub_ACE80(a1, 1);
  if ( *(_BYTE *)(a1 + 9428) )
  {
    v5 = *(_DWORD *)(a1 + 9424);
    v6 = *(_DWORD *)(a1 + 9412);
    v7 = *(_DWORD *)(a1 + 3832);
    v8 = *(_DWORD *)(a1 + 3836);
    if ( !(a2 & 1) )
      goto LABEL_3;
    v21 = *(_DWORD *)(a1 + 9424);
    if ( !(unsigned __int8)sub_1EF00(*(__int64 **)(a1 + 9336), 154) )
    {
      v5 = v21;
LABEL_3:
      v9 = a3 * 5.0 + *(double *)(a1 + 9400);
      v10 = (signed int)(v9 / 5.0);
      if ( v10 )
      {
        *(double *)(a1 + 9400) = v9 - (double)(5 * v10);
        if ( v10 <= 0 )
        {
          v19 = 7;
          v11 = ~v10;
        }
        else
        {
          v11 = v10 - 1;
          v19 = 8;
        }
        v12 = (double)v8;
        v13 = (signed int)((v20 - (double)v6) / (double)v7);
        v14 = (a2 & v5) != 0;
        v15 = (signed int)((a5 - (double)v6) / v12);
        do
        {
          --v11;
          sub_980C0(*(const __m128i **)(a1 + 3912), v19, 0, 1, v13, v15, a2 & 1, (a2 >> 2) & 1, v14);
        }
        while ( v11 + 1 > 0 );
      }
      else
      {
        *(double *)(a1 + 9400) = v9;
      }
      return 1LL;
    }
  }
  v17 = a3 * 5.0 + *(double *)(a1 + 9400);
  v18 = (signed int)v17;
  *(double *)(a1 + 9400) = v17;
  if ( (signed int)v17 )
  {
    sub_97BB0(*(_QWORD *)(a1 + 3912), 0, v18);
    *(double *)(a1 + 9400) = *(double *)(a1 + 9400) - (double)v18;
  }
  return 1LL;
}

signed __int64 __usercall sub_AFF80@<rax>(__int64 a1@<rdx>, __int64 a2@<rsi>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  __int64 v4; // r12
  signed __int64 result; // rax
  __int64 v6; // r13
  __int64 v7; // rbp
  __int64 v8; // xmm0_8
  __int64 v9; // rdi
  int v10; // eax
  __int64 v11; // xmm0_8
  __int64 v12; // rax
  __int64 v13; // xmm0_8
  unsigned int v14; // ST0C_4
  int v15; // [rsp+14h] [rbp-44h]
  char v16; // [rsp+18h] [rbp-40h]
  double v17; // [rsp+20h] [rbp-38h]
  unsigned __int64 v18; // [rsp+28h] [rbp-30h]

  v4 = a1;
  v18 = __readfsqword(0x28u);
  if ( (unsigned int)gdk_event_get_scroll_deltas(a2, &v16, &v17) )
    return sub_AFD60(v4, *(_DWORD *)(a2 + 40), v17, *(double *)(a2 + 24), *(double *)(a2 + 32));
  result = gdk_event_get_scroll_direction(a2, &v15);
  if ( !(_DWORD)result )
    return result;
  if ( v15 )
  {
    result = 0LL;
    v6 = 5LL;
    if ( v15 != 1 )
      return result;
  }
  else
  {
    v6 = 4LL;
  }
  v7 = gdk_event_new(4LL);
  *(_QWORD *)(v7 + 8) = g_object_ref(*(_QWORD *)(a2 + 8), &v15);
  *(_BYTE *)(v7 + 16) = *(_BYTE *)(a2 + 16);
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 48);
  *(_DWORD *)(v7 + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(v7 + 24) = v8;
  v10 = *(_DWORD *)(a2 + 40);
  v11 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(v7 + 40) = 0LL;
  *(_DWORD *)(v7 + 52) = v6;
  *(_QWORD *)(v7 + 32) = v11;
  *(_DWORD *)(v7 + 48) = v10;
  v12 = g_object_ref(v9, &v15);
  v13 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(v7 + 56) = v12;
  *(_QWORD *)(v7 + 64) = v13;
  *(_QWORD *)(v7 + 72) = *(_QWORD *)(a2 + 64);
  v14 = sub_AD050(v4, (double *)v7, v4, v6, a3, a4);
  gdk_event_free(v7, v7);
  return v14;
}

__int64 __fastcall sub_B00D0(unsigned __int16 *a1)
{
  signed int v1; // eax
  double v2; // xmm0_8
  signed int v3; // eax
  double v5; // [rsp+0h] [rbp-38h]
  double v6; // [rsp+8h] [rbp-30h]
  double v7; // [rsp+10h] [rbp-28h]
  __int64 v8; // [rsp+18h] [rbp-20h]
  unsigned __int64 v9; // [rsp+28h] [rbp-10h]

  v9 = __readfsqword(0x28u);
  v1 = a1[3];
  v5 = (double)a1[2] / 65535.0;
  v2 = (double)v1;
  v3 = a1[4];
  v6 = v2 / 65535.0;
  v8 = 4607182418800017408LL;
  v7 = (double)v3 / 65535.0;
  return gdk_rgba_to_string(&v5);
}

void __fastcall sub_B0160(__int64 a1, unsigned __int16 *a2)
{
  __int64 v2; // r12
  void *v3; // rbx
  char *v4; // rbp
  __int64 v5; // r13
  __int64 v6; // rax
  __int64 v7; // rax

  v2 = gtk_css_provider_new();
  v3 = (void *)sub_B00D0(a2);
  v4 = sub_BC360((__int64)"#drawing-area, #top-level { background-color: %s; }\n", v3);
  gtk_css_provider_load_from_data(v2, v4, -1LL, 0LL);
  v5 = gtk_widget_get_style_context(a1);
  v6 = gtk_style_provider_get_type(a1, v4);
  v7 = g_type_check_instance_cast(v2, v6);
  gtk_style_context_add_provider(v5, v7, 600LL);
  free(v4);
  free(v3);
}

void __fastcall sub_B01F0(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 v7; // rax

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 )
  {
    v4 = gtk_widget_get_type(a1, a2);
    a2 = a1 + 3320;
    a1 = g_type_check_instance_cast(v3, v4);
    sub_B0160(a1, (unsigned __int16 *)(v2 + 3320));
  }
  v5 = *(_QWORD *)v2;
  if ( *(_QWORD *)v2 )
  {
    v6 = gtk_widget_get_type(a1, a2);
    v7 = g_type_check_instance_cast(v5, v6);
    sub_B0160(v7, (unsigned __int16 *)(v2 + 3320));
  }
}

void __fastcall sub_B0260(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4)
{
  __int64 v4; // rbx
  unsigned int v5; // er8
  signed __int64 v6; // r10
  __int16 v7; // r9
  signed __int64 v8; // rax
  signed __int64 v9; // rax
  signed __int64 v10; // rsi
  __int64 v11; // rdi

  if ( a2 > 0x106 )
    __assert_fail("start <= OSC4_NCOLOURS", "unix/gtkwin.c", 0xA0Au, "gtkwin_palette_set");
  if ( 262 - a2 < a3 )
    __assert_fail("ncolours <= OSC4_NCOLOURS - start", "unix/gtkwin.c", 0xA0Bu, "gtkwin_palette_set");
  if ( a3 )
  {
    v4 = a1;
    v5 = a2;
    v6 = (signed __int64)&a4[3 * (a3 - 1) + 3];
    do
    {
      v7 = *a4;
      a4 += 3;
      v8 = 3LL * v5++;
      v9 = a1 + 4 * v8;
      *(_WORD *)(v9 - 9316) = 257 * v7;
      *(_WORD *)(v9 - 9314) = 257 * *(a4 - 2);
      *(_WORD *)(v9 - 9312) = 257 * *(a4 - 1);
    }
    while ( (unsigned __int8 *)v6 != a4 );
    if ( a2 <= 0x102 )
    {
      v10 = a3 + a2;
      if ( (unsigned int)v10 > 0x102 )
      {
        sub_B01F0(a1 - 9544, v10);
        v11 = *(_QWORD *)(a1 - 9536);
        if ( v11 )
        {
          if ( gtk_widget_get_window(v11) )
          {
            sub_AE290(v4 - 9544);
            gtk_widget_queue_draw(*(_QWORD *)(v4 - 9536));
          }
        }
      }
    }
  }
}

unsigned __int64 __fastcall sub_B03C0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  Window v3; // rax
  __int64 v4; // rdi
  Window v5; // rax
  __int64 v6; // rdi
  Window v7; // rax
  __int64 v8; // rdi
  Window v9; // rax
  __int64 v10; // rdi
  Window v11; // rax
  __int64 v12; // rdi
  Window v13; // rax
  __int64 v14; // rdi
  Window v15; // rax
  __int64 v16; // rdi
  Window v17; // rax
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned __int8 v24; // [rsp+7h] [rbp-21h]
  unsigned __int64 v25; // [rsp+8h] [rbp-20h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 104);
  v25 = __readfsqword(0x28u);
  if ( v2 )
  {
    v24 = 0;
    sub_BBAD0(v2, 8);
    v3 = gdk_x11_get_default_root_xwindow(v2, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v3, 9uLL, 0x1FuLL, 8, 2, &v24, 0);
    v4 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v4, 8);
    v5 = gdk_x11_get_default_root_xwindow(v4, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v5, 0xAuLL, 0x1FuLL, 8, 2, &v24, 0);
    v6 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v6, 8);
    v7 = gdk_x11_get_default_root_xwindow(v6, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v7, 0xBuLL, 0x1FuLL, 8, 2, &v24, 0);
    v8 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v8, 8);
    v9 = gdk_x11_get_default_root_xwindow(v8, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v9, 0xCuLL, 0x1FuLL, 8, 2, &v24, 0);
    v10 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v10, 8);
    v11 = gdk_x11_get_default_root_xwindow(v10, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v11, 0xDuLL, 0x1FuLL, 8, 2, &v24, 0);
    v12 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v12, 8);
    v13 = gdk_x11_get_default_root_xwindow(v12, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v13, 0xEuLL, 0x1FuLL, 8, 2, &v24, 0);
    v14 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v14, 8);
    v15 = gdk_x11_get_default_root_xwindow(v14, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v15, 0xFuLL, 0x1FuLL, 8, 2, &v24, 0);
    v16 = *(_QWORD *)(v1 + 104);
    sub_BBAD0(v16, 8);
    v17 = gdk_x11_get_default_root_xwindow(v16, 8LL);
    XChangeProperty(*(Display **)(v1 + 104), v17, 0x10uLL, 0x1FuLL, 8, 2, &v24, 0);
  }
  v18 = qword_3260C8;
  v19 = *(_QWORD *)(v1 + 8);
  *(_QWORD *)(v1 + 3520) = 1LL;
  *(_QWORD *)(v1 + 3504) = v1;
  *(_DWORD *)(v1 + 3512) = 2;
  *(_QWORD *)(v1 + 3568) = v1;
  *(_QWORD *)(v1 + 3584) = v18;
  *(_DWORD *)(v1 + 3576) = 3;
  v20 = g_type_check_instance_cast(v19, 80LL);
  g_signal_connect_data(v20, "selection_received", sub_AD420, v1, 0LL, 0LL);
  v21 = g_type_check_instance_cast(*(_QWORD *)(v1 + 8), 80LL);
  g_signal_connect_data(v21, "selection_get", sub_AC140, v1, 0LL, 0LL);
  v22 = g_type_check_instance_cast(*(_QWORD *)(v1 + 8), 80LL);
  g_signal_connect_data(v22, "selection_clear_event", sub_AC030, v1, 0LL, 0LL);
  return __readfsqword(0x28u) ^ v25;
}

__int64 __fastcall sub_B06A0(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rax

  v2 = a2;
  if ( (_DWORD)a2 == -1 )
    v2 = -2;
  v3 = gdk_display_get_default(a1, a2);
  return gdk_cursor_new_for_display(v3, v2);
}

void __noreturn sub_B06C0(__int64 a1, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v2; // [rsp+18h] [rbp-C0h]

  va_start(va, a1);
  v2 = __readfsqword(0x28u);
  fwrite("FATAL ERROR: ", 1uLL, 0xDuLL, stderr);
  __vfprintf_chk(stderr, 1LL, a1, va);
  fputc(10, stderr);
  exit(1);
}

__int64 __fastcall sub_B07B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rdi
  __int64 v3; // r15
  unsigned int v4; // er13
  const char **v5; // rax
  const char **v6; // r14
  _DWORD *v7; // rax
  __int64 v8; // r12
  const char **v9; // rax
  const char **v10; // r14
  const char **v11; // rax
  const char **v12; // r12
  const char **v13; // rax
  const char **v14; // r12
  __int64 v15; // rbx
  __int64 v16; // rdi
  __int64 result; // rax
  unsigned __int64 v18; // rt1
  const char *v19; // rsi
  const char *v20; // rdi
  unsigned __int64 v21; // rt1
  unsigned __int64 v22; // rt1
  unsigned __int64 v23; // rt1
  __int64 v24; // rbp
  __int64 v25; // rdi
  __int64 v26; // rax
  int v27; // edx
  int v28; // eax
  int v29; // er13
  int v30; // er12
  char v31; // bp
  unsigned __int8 *v32; // rax
  _DWORD *v33; // [rsp+0h] [rbp-68h]
  _DWORD *v34; // [rsp+8h] [rbp-60h]
  _DWORD *v35; // [rsp+10h] [rbp-58h]
  _DWORD *v36; // [rsp+18h] [rbp-50h]
  unsigned __int64 v37; // [rsp+28h] [rbp-40h]

  v1 = a1;
  v2 = *(__int64 **)(a1 + 9336);
  v37 = __readfsqword(0x28u);
  v3 = (unsigned __int8)sub_1EF00(v2, 196);
  v4 = sub_1EFD0(*(__int64 **)(v1 + 9336), 200);
  v5 = (const char **)sub_1F600(*(__int64 **)(v1 + 9336), 125);
  v6 = v5;
  v7 = sub_A8D80(*(_QWORD *)(v1 + 8), *v5, 0, 0, v4, v3);
  v33 = v7;
  if ( !v7 )
  {
    v23 = __readfsqword(0x28u);
    result = v23 ^ v37;
    if ( v23 == v37 )
    {
      v19 = *v6;
      v20 = "unable to load font \"%s\"";
      goto LABEL_15;
    }
    return result;
  }
  v8 = (__int64)v7;
  v9 = (const char **)sub_1F600(*(__int64 **)(v1 + 9336), 197);
  v10 = v9;
  if ( (_BYTE)v3 || !**v9 )
  {
    v34 = 0LL;
  }
  else
  {
    v34 = sub_A8D80(*(_QWORD *)(v1 + 8), *v9, 0, 1u, v4, 0);
    if ( !v34 )
    {
      sub_A8D60(v8);
      v21 = __readfsqword(0x28u);
      result = v21 ^ v37;
      if ( v21 == v37 )
      {
        v19 = *v10;
        v20 = "unable to load bold font \"%s\"";
        goto LABEL_15;
      }
      return result;
    }
  }
  v11 = (const char **)sub_1F600(*(__int64 **)(v1 + 9336), 198);
  v12 = v11;
  if ( **v11 )
  {
    v35 = sub_A8D80(*(_QWORD *)(v1 + 8), *v11, 1u, 0, v4, v3);
    if ( !v35 )
    {
      if ( v33 )
        sub_A8D60((__int64)v33);
      if ( v34 )
        sub_A8D60((__int64)v34);
      v22 = __readfsqword(0x28u);
      result = v22 ^ v37;
      if ( v22 == v37 )
      {
        v19 = *v12;
        v20 = "unable to load wide font \"%s\"";
        goto LABEL_15;
      }
      return result;
    }
  }
  else
  {
    v35 = 0LL;
  }
  v13 = (const char **)sub_1F600(*(__int64 **)(v1 + 9336), 199);
  v14 = v13;
  if ( (_BYTE)v3 || !**v13 )
  {
    v36 = 0LL;
LABEL_30:
    v24 = 0LL;
    do
    {
      v25 = *(_QWORD *)(v1 + v24 * 8 + 136);
      if ( v25 )
        sub_A8D60(v25);
      *(_QWORD *)(v1 + v24 * 8 + 136) = (&v33)[v24];
      ++v24;
    }
    while ( v24 != 4 );
    v26 = *(_QWORD *)(v1 + 136);
    v27 = *(_DWORD *)(v26 + 12);
    v28 = *(_DWORD *)(v26 + 16);
    if ( *(_DWORD *)(v1 + 3832) != v27 || *(_DWORD *)(v1 + 3836) != v28 )
    {
      *(_DWORD *)(v1 + 3832) = v27;
      *(_DWORD *)(v1 + 3836) = v28;
      *(_DWORD *)(v1 + 36) = 1;
    }
    v29 = sub_1EFD0(*(__int64 **)(v1 + 9336), 163);
    v30 = *(_DWORD *)(*(_QWORD *)(v1 + 136) + 8LL);
    v31 = sub_1EF00(*(__int64 **)(v1 + 9336), 166);
    v32 = (unsigned __int8 *)sub_1F170(*(__int64 **)(v1 + 9336), 164);
    *(_BYTE *)(v1 + 3368) = sub_BB6E0(v1 + 3936, v32, v31, v30, v29);
    *(_DWORD *)(v1 + 9420) = *(_DWORD *)(*(_QWORD *)(v1 + 136) + 36LL);
    return 0LL;
  }
  v36 = sub_A8D80(*(_QWORD *)(v1 + 8), *v13, 1u, 1u, v4, 0);
  if ( v36 )
    goto LABEL_30;
  v15 = 0LL;
  do
  {
    v16 = (__int64)(&v33)[v15];
    if ( v16 )
      sub_A8D60(v16);
    ++v15;
  }
  while ( v15 != 3 );
  v18 = __readfsqword(0x28u);
  result = v18 ^ v37;
  if ( v18 == v37 )
  {
    v19 = *v14;
    v20 = "unable to load wide bold font \"%s\"";
LABEL_15:
    result = (__int64)sub_BC360((__int64)v20, v19);
  }
  return result;
}

unsigned __int64 __fastcall sub_B0B40(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // ebp
  unsigned int v3; // eax
  __int64 v4; // rdi
  unsigned int v5; // ebp
  void **v6; // rax
  int v7; // ecx
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rax
  int v12; // [rsp+0h] [rbp-58h]
  int v13; // [rsp+4h] [rbp-54h]
  int v14; // [rsp+8h] [rbp-50h]
  int v15; // [rsp+Ch] [rbp-4Ch]
  unsigned __int64 v16; // [rsp+38h] [rbp-20h]

  v1 = a1;
  v16 = __readfsqword(0x28u);
  sub_AC220(a1, (__int64)&v12);
  v2 = *(_BYTE *)(a1 + 180) < 1u ? 0xFFFFFF80 : 0;
  v3 = sub_1EFD0(*(__int64 **)(a1 + 9336), 2);
  v4 = v3;
  v5 = v2 + 170;
  v6 = sub_3CFD0(v3);
  if ( v6 && (_BYTE)v6[20] & 1 )
  {
    v5 |= 4u;
    v7 = 2 * *(_DWORD *)(v1 + 9412);
    v8 = *(_DWORD *)(v1 + 3836) * *(_DWORD *)(v1 + 3844);
    v12 = v7 + *(_DWORD *)(v1 + 3832) * *(_DWORD *)(v1 + 3840);
    v14 = v12;
    v13 = v7 + v8;
    v15 = v7 + v8;
  }
  v9 = gtk_window_get_type(v4, 2LL);
  v10 = g_type_check_instance_cast(*(_QWORD *)v1, v9);
  gtk_window_set_geometry_hints(v10, 0LL, &v12, v5);
  return __readfsqword(0x28u) ^ v16;
}

void __fastcall sub_B0C20(__int64 a1)
{
  __int64 v1; // r12
  __int64 v2; // rbx
  __int64 v3; // rdi
  char *v4; // rax
  void *v5; // r14
  __int64 v6; // rbx
  __int64 v7; // r15
  int v8; // ebp
  char **v9; // rax
  void **v10; // rax
  _QWORD *v11; // rdi
  void **v12; // rbp
  __int64 v13; // rbx
  void **v14; // rdi
  __int64 v15; // rbx
  unsigned int v16; // ebx
  unsigned int v17; // eax
  void **v18; // [rsp+0h] [rbp-88h]
  __int64 v19; // [rsp+8h] [rbp-80h]
  __int64 v20; // [rsp+10h] [rbp-78h]
  __int64 v21; // [rsp+18h] [rbp-70h]
  __int64 v22; // [rsp+20h] [rbp-68h]
  __int64 v23; // [rsp+28h] [rbp-60h]
  __int64 v24; // [rsp+30h] [rbp-58h]
  __int64 v25; // [rsp+38h] [rbp-50h]
  unsigned __int64 v26; // [rsp+48h] [rbp-40h]

  v1 = a1;
  v2 = 0LL;
  v26 = __readfsqword(0x28u);
  v22 = 0LL;
  v18 = 0LL;
  v23 = 0LL;
  v19 = 0LL;
  v24 = 0LL;
  v20 = 0LL;
  v25 = 0LL;
  v21 = 0LL;
  do
  {
    v3 = *(_QWORD *)(v1 + v2 + 136);
    if ( v3 )
    {
      v4 = (char *)sub_A8D70(v3);
      v5 = v4;
      if ( !v4 )
      {
        v12 = 0LL;
        goto LABEL_11;
      }
      *(__int64 *)((char *)&v22 + v2) = (__int64)sub_B51E0(v4);
      sub_2F4D0(v5);
    }
    v2 += 8LL;
  }
  while ( v2 != 32 );
  v6 = 0LL;
  do
  {
    v7 = *(&v22 + v6);
    if ( v7 )
    {
      v8 = *((_DWORD *)&off_F9060 + v6);
      v9 = (char **)sub_1F600(*(__int64 **)(v1 + 9336), *((_DWORD *)&off_F9060 + v6));
      v10 = (void **)sub_B5220(v9);
      v11 = *(_QWORD **)(v1 + 9336);
      (&v18)[v6] = v10;
      sub_1FB70(v11, v8, v7);
    }
    ++v6;
  }
  while ( v6 != 4 );
  v5 = (void *)sub_B07B0(v1);
  v12 = v18;
  if ( !v5 )
  {
    v15 = 0LL;
    if ( !v18 )
      goto LABEL_22;
    while ( 1 )
    {
      sub_B5230(v12);
      (&v18)[v15] = 0LL;
LABEL_22:
      ++v15;
      if ( v15 == 4 )
        break;
      while ( 1 )
      {
        v12 = (&v18)[v15];
        if ( v12 )
          break;
        ++v15;
        if ( v15 == 4 )
          goto LABEL_25;
      }
    }
LABEL_25:
    sub_B0B40(v1);
    v16 = sub_1EFD0(*(__int64 **)(v1 + 9336), 124);
    v17 = sub_1EFD0(*(__int64 **)(v1 + 9336), 123);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v1 + 9544) + 112LL))(v1 + 9544, v17, v16);
    sub_90EF0(*(_QWORD *)(v1 + 3912));
    gtk_widget_queue_draw(*(_QWORD *)(v1 + 8));
    v12 = v18;
  }
LABEL_11:
  v13 = 0LL;
  if ( !v12 )
    goto LABEL_13;
LABEL_12:
  sub_1FB70(*(_QWORD **)(v1 + 9336), *((_DWORD *)&off_F9060 + v13), (__int64)v12);
  sub_B5230(v12);
  while ( 1 )
  {
LABEL_13:
    v14 = (void **)*(&v22 + v13);
    if ( v14 )
      sub_B5230(v14);
    if ( ++v13 == 4 )
      break;
    v12 = (&v18)[v13];
    if ( v12 )
      goto LABEL_12;
  }
  if ( __readfsqword(0x28u) == v26 )
    sub_2F4D0(v5);
}

unsigned __int64 __usercall sub_B0E70@<rax>(__int64 a1@<rdx>, unsigned __int64 a2@<rsi>, __int64 a3@<r13>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  __int64 v5; // rdi
  unsigned __int64 v6; // rbx
  __int64 v7; // rbp
  __int64 v8; // r12
  __int64 v9; // rsi
  __int64 v10; // r8
  int v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // eax
  bool v15; // zf
  const char *v16; // rdx
  __int64 v17; // rdi
  signed int v18; // ecx
  __int64 v19; // rcx
  unsigned __int64 v20; // rt1
  unsigned __int64 result; // rax
  __int64 v22; // rax
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rax
  unsigned int v26; // eax
  int v27; // eax
  unsigned int v28; // edx
  __int64 v29; // rax
  int v30; // eax
  signed __int64 v31; // r9
  char v32; // si
  char *v33; // rcx
  int v34; // edx
  unsigned int v35; // eax
  signed __int64 v36; // rcx
  int v37; // edx
  int v38; // eax
  unsigned int v39; // er9
  int v40; // eax
  signed int v41; // eax
  __int64 v42; // rax
  signed int v43; // edx
  int v44; // eax
  unsigned int v45; // edx
  int v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // eax
  int v50; // eax
  __int64 v51; // rdx
  int v52; // eax
  int v53; // eax
  unsigned int v54; // ST1C_4
  unsigned __int8 v55; // al
  unsigned int v56; // ST1C_4
  unsigned __int8 v57; // al
  unsigned int v58; // eax
  unsigned int v59; // [rsp+4h] [rbp-1E4h]
  char v60; // [rsp+Ah] [rbp-1DEh]
  char v61; // [rsp+Bh] [rbp-1DDh]
  int v62; // [rsp+14h] [rbp-1D4h]
  int *v63; // [rsp+18h] [rbp-1D0h]
  int v64; // [rsp+20h] [rbp-1C8h]
  int v65; // [rsp+24h] [rbp-1C4h]
  char v66; // [rsp+A0h] [rbp-148h]
  int v67; // [rsp+A1h] [rbp-147h]
  char v68; // [rsp+19Fh] [rbp-49h]
  unsigned __int64 v69; // [rsp+1A8h] [rbp-40h]

  v5 = 3LL;
  v6 = a2;
  v7 = a1;
  v8 = *(_QWORD *)(a2 + 40);
  v9 = *(unsigned int *)(a2 + 28);
  v69 = __readfsqword(0x28u);
  if ( !v8 )
    v8 = (__int64)&locale;
  sub_B7C30(3u, v9, v8, a3, a4, a5);
  *(_DWORD *)(v7 + 9352) = *(_DWORD *)(v6 + 20);
  v11 = *(_DWORD *)v6;
  if ( *(_DWORD *)v6 != 9 )
  {
LABEL_4:
    if ( v11 != 8 )
      goto LABEL_17;
    v12 = *(_DWORD *)(v6 + 28);
    if ( (unsigned int)(v12 - 65511) <= 3 )
    {
      *(_QWORD *)(v7 + 3860) = 0xFFFFFFFFLL;
      goto LABEL_17;
    }
    if ( *(_DWORD *)(v6 + 24) & *(_DWORD *)(v7 + 9424) )
    {
      v13 = *(_DWORD *)(v7 + 3860);
      if ( v13 != -2 )
      {
        switch ( v12 )
        {
          case 65429:
          case 65463:
            v41 = 7;
            break;
          case 65430:
          case 65460:
            v41 = 4;
            break;
          case 65431:
          case 65464:
            v41 = 8;
            break;
          case 65432:
          case 65462:
            v41 = 6;
            break;
          case 65433:
          case 65458:
            v41 = 2;
            break;
          case 65434:
          case 65465:
            v41 = 9;
            break;
          case 65435:
          case 65459:
            v41 = 3;
            break;
          case 65436:
          case 65457:
            v41 = 1;
            break;
          case 65437:
          case 65461:
            v41 = 5;
            break;
          case 65438:
          case 65456:
            v41 = 0;
            break;
          default:
            *(_DWORD *)(v7 + 3860) = -2;
            goto LABEL_23;
        }
        if ( v13 != -1 )
          v41 += 10 * v13;
        *(_DWORD *)(v7 + 3860) = v41;
        ++*(_DWORD *)(v7 + 3864);
        goto LABEL_17;
      }
    }
LABEL_23:
    v22 = *(_QWORD *)(v6 + 24);
    v23 = v22 & 0xFFFFFFFF00000004LL;
    if ( (v22 & 0xFFFFFFFF00000004LL) == 266287972356LL )
    {
      LODWORD(v9) = 1;
      v5 = v7;
      sub_B0C20(v7);
      goto LABEL_17;
    }
    if ( v23 == 257698037764LL )
    {
      LODWORD(v9) = -1;
      v5 = v7;
      sub_B0C20(v7);
      goto LABEL_17;
    }
    v24 = v22 & 0xFFFFFFFF00000005LL;
    if ( (v22 & 0xFFFFFFFF00000005LL) == 280740537303045LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = 1;
      sub_97BB0(v5, 1, 0);
      goto LABEL_17;
    }
    v25 = v22 & 0xFFFFFFFF00000001LL;
    if ( v25 == 280740537303041LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = 0;
      sub_97BB0(v5, 0, *(_DWORD *)(v7 + 3844) / -2);
      goto LABEL_17;
    }
    if ( v23 == 280740537303044LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = 0;
      sub_97BB0(v5, 0, -1);
      goto LABEL_17;
    }
    if ( v24 == 280744832270341LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = -1;
      sub_97BB0(v5, -1, 0);
      goto LABEL_17;
    }
    if ( v25 == 280744832270337LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = 0;
      sub_97BB0(v5, 0, *(_DWORD *)(v7 + 3844) / 2);
      goto LABEL_17;
    }
    if ( v23 == 280744832270340LL )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      LODWORD(v9) = 0;
      sub_97BB0(v5, 0, 1);
      goto LABEL_17;
    }
    v5 = *(_QWORD *)(v7 + 9336);
    if ( v25 == 280800666845185LL )
    {
      v49 = sub_1EFD0((__int64 *)v5, 158);
      switch ( v49 )
      {
        case 2:
          v5 = *(_QWORD *)(v7 + 3912);
          LODWORD(v9) = 3;
          sub_97DA0(v5, 3);
          goto LABEL_17;
        case 3:
          LODWORD(v9) = *(_DWORD *)(v7 + 3824);
          v5 = *(_QWORD *)(v7 + 3912);
          sub_97DA0(v5, v9);
          goto LABEL_17;
        case 1:
          goto LABEL_173;
      }
      v5 = *(_QWORD *)(v7 + 9336);
      v23 = *(_QWORD *)(v6 + 24) & 0xFFFFFFFF00000004LL;
    }
    if ( v23 == 280800666845188LL )
    {
      LODWORD(v9) = 158;
      v50 = sub_1EFD0((__int64 *)v5, 158);
      switch ( v50 )
      {
        case 2:
          v5 = *(_QWORD *)(v7 + 3912);
          v9 = (__int64)&unk_F9074;
          sub_97D00(v5, (unsigned int *)&unk_F9074, 1);
          goto LABEL_17;
        case 3:
          v5 = *(_QWORD *)(v7 + 3912);
          LODWORD(v9) = v7 + 3824;
          sub_97D00(v5, (unsigned int *)(v7 + 3824), 1);
          goto LABEL_17;
        case 1:
          goto LABEL_17;
      }
      v5 = *(_QWORD *)(v7 + 9336);
    }
    if ( (*(_DWORD *)(v6 + 24) & 5) != 5 || (v26 = *(_DWORD *)(v6 + 28) & 0xFFFFFFDF, v26 != 67) && v26 != 86 )
    {
LABEL_40:
      v66 = 27;
      a5 = (unsigned int)sub_1EF00((__int64 *)v5, 86);
      if ( *(_BYTE *)(*(_QWORD *)(v7 + 3912) + 441LL) )
      {
        a4 = (unsigned int)sub_1EF00(*(__int64 **)(v7 + 9336), 75) ^ 1;
        v51 = (unsigned int)(*(_DWORD *)(v6 + 28) - 65407);
        if ( (unsigned int)v51 > 0x3A )
          goto LABEL_42;
        LOBYTE(a3) = byte_F8F60[v51];
        v60 = off_F8FA0[v51];
        LOBYTE(a4) = (v60 != 0) & a4;
        LOBYTE(v59) = a4;
        if ( (_BYTE)a4 )
        {
          if ( (_BYTE)a3 )
          {
            LOBYTE(v59) = byte_F8F60[v51];
            goto LABEL_44;
          }
          LOBYTE(a3) = a4;
          if ( *(_DWORD *)(*(_QWORD *)(v7 + 3912) + 4544LL) != 2 )
            goto LABEL_44;
        }
        else
        {
          LOBYTE(v59) = v60 != 0;
        }
      }
      else
      {
        v29 = (unsigned int)(*(_DWORD *)(v6 + 28) - 65407);
        if ( (unsigned int)v29 > 0x3A )
        {
LABEL_42:
          v60 = 0;
          LOBYTE(v59) = 0;
LABEL_43:
          v5 = *(_QWORD *)(v7 + 128);
          LODWORD(v9) = v6;
          LOBYTE(a3) = 0;
          if ( (unsigned int)gtk_im_context_filter_keypress(v5, v6) )
            goto LABEL_17;
LABEL_44:
          a4 = (__int64)&v64;
          a5 = (__int64)&v66;
          v30 = strlen((const char *)v8);
          v62 = sub_BB410(0xFFFF, 0LL, v8, v30, (__int64)&v64, 31);
          v63 = &v64;
          *(&v66 + (signed int)((unsigned __int64)sub_1BF60(&v63, &v62, (__int64)&v67, 254, 0x37u, 0LL, 0LL, 0) + 1)) = 0;
          v32 = v67;
          if ( (_BYTE)v67 || (v52 = sub_BBBD0(*(_DWORD *)(v6 + 28)), v32 = v67, v52 < 0) )
          {
            v68 = 0;
            v33 = &v66;
            do
            {
              v34 = *(_DWORD *)v33;
              v33 += 4;
              v35 = ~v34 & (v34 - 16843009) & 0x80808080;
            }
            while ( !v35 );
            v10 = *(unsigned int *)(v6 + 24);
            if ( !(~v34 & (v34 - 16843009) & 0x8080) )
              LOBYTE(v35) = (~v34 & (v34 - 16843009) & 0x80808080) >> 16;
            if ( !(~v34 & (v34 - 16843009) & 0x8080) )
              v33 += 2;
            v5 = *(_QWORD *)(v6 + 24);
            v36 = &v33[-__CFADD__((_BYTE)v35, (_BYTE)v35) - 3] - &v66;
            result = v5 & 0xFFFFFFFF00000004LL;
            v37 = v36;
            if ( (unsigned int)v10 & *(_DWORD *)(v7 + 9424) )
            {
              if ( (_DWORD)v36 == 1 )
              {
                if ( v32 )
                {
                  v8 = 0LL;
                  v37 = 0;
                  v19 = 0LL;
                  goto LABEL_58;
                }
                v19 = 0LL;
                v37 = 0;
                v31 = v10 & 4;
                v8 = 0LL;
LABEL_55:
                if ( result == 412316860420LL )
                {
                  LOBYTE(v67) = 28;
                  if ( !(_DWORD)v31 )
                  {
                    if ( *(_DWORD *)(v6 + 28) != 65293 )
                    {
                      v61 = 0;
                      LOBYTE(v19) = 0;
                      v39 = 55;
                      v37 = 2;
                      goto LABEL_69;
                    }
                    goto LABEL_166;
                  }
                  goto LABEL_175;
                }
LABEL_56:
                if ( v37 != 2 || !(_DWORD)v31 )
                  goto LABEL_58;
                if ( (_BYTE)v19 )
                {
                  LODWORD(v9) = v65;
LABEL_176:
                  v31 = (unsigned int)(v9 - 24);
                  result = v5 & 0xFFFFFFFF00000004LL;
                  if ( (unsigned int)(v9 - 51) <= 4 )
                    goto LABEL_184;
                  switch ( (_DWORD)v9 )
                  {
                    case 0x32:
                    case 0x20:
                      goto LABEL_202;
                    case 0x38:
                      v31 = 127LL;
                      goto LABEL_184;
                    case 0x2F:
                      v31 = 31LL;
                      goto LABEL_184;
                  }
                  v31 = (unsigned int)(v9 - 64);
                  v37 = 2;
                  if ( (unsigned int)v31 <= 0x3E )
                  {
                    v31 = v9 & 0x1F;
                    goto LABEL_183;
                  }
                  goto LABEL_58;
                }
LABEL_175:
                LODWORD(v9) = (char)v67;
                v19 = 0LL;
                goto LABEL_176;
              }
              v19 = 0LL;
              v8 = 0LL;
            }
            else
            {
              v19 = 0LL;
              v8 = 1LL;
            }
          }
          else
          {
            v10 = *(unsigned int *)(v6 + 24);
            v15 = ((unsigned int)v10 & *(_DWORD *)(v7 + 9424)) == 0;
            v5 = *(_QWORD *)(v6 + 24);
            v65 = v52;
            v64 = 27;
            v32 = v67;
            v19 = 1LL;
            v37 = 2;
            v8 = v15;
            result = v5 & 0xFFFFFFFF00000004LL;
          }
          v31 = v10 & 4;
          if ( v32 )
            goto LABEL_56;
          goto LABEL_55;
        }
        v60 = off_F8FA0[v29];
        LOBYTE(v59) = v60 != 0;
      }
      LOBYTE(a3) = a5 & ((unsigned __int8)(v60 - 49) <= 8u);
      if ( (unsigned __int8)a5 & ((unsigned __int8)(v60 - 49) <= 8u) )
        goto LABEL_44;
      goto LABEL_43;
    }
    LODWORD(v9) = 159;
    v27 = sub_1EFD0((__int64 *)v5, 159);
    v28 = *(_DWORD *)(v6 + 28) & 0xFFFFFFDF;
    if ( v27 == 2 )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      if ( v28 == 86 )
      {
        LODWORD(v9) = 3;
        sub_97DA0(v5, 3);
      }
      else
      {
        v9 = (__int64)&unk_F9070;
        sub_97D00(v5, (unsigned int *)&unk_F9070, 1);
      }
      goto LABEL_17;
    }
    if ( v27 == 3 )
    {
      v5 = *(_QWORD *)(v7 + 3912);
      if ( v28 == 86 )
      {
        LODWORD(v9) = *(_DWORD *)(v7 + 3828);
        sub_97DA0(v5, v9);
      }
      else
      {
        LODWORD(v9) = v7 + 3828;
        sub_97D00(v5, (unsigned int *)(v7 + 3828), 1);
      }
      goto LABEL_17;
    }
    if ( v27 != 1 )
    {
      v5 = *(_QWORD *)(v7 + 9336);
      goto LABEL_40;
    }
    if ( v28 != 86 )
      goto LABEL_17;
LABEL_173:
    v5 = *(_QWORD *)(v7 + 3912);
    LODWORD(v9) = 2;
    sub_97DA0(v5, 2);
    goto LABEL_17;
  }
  if ( (unsigned int)(*(_DWORD *)(v6 + 28) - 65511) <= 3 )
  {
    v14 = *(_DWORD *)(v7 + 3860);
    if ( v14 >= 0 && *(_DWORD *)(v7 + 3864) > 1 )
    {
      v15 = *(_BYTE *)(v7 + 3368) == 0;
      v66 = *(_DWORD *)(v7 + 3860);
      v16 = &v66;
      if ( v15 )
      {
        v17 = *(_QWORD *)(v7 + 3912);
        v39 = 1;
        v18 = 1;
        goto LABEL_81;
      }
      v17 = *(_QWORD *)(v7 + 3912);
      v18 = 1;
      goto LABEL_14;
    }
  }
  v5 = *(_QWORD *)(v7 + 128);
  LODWORD(v9) = v6;
  if ( !(unsigned int)gtk_im_context_filter_keypress(v5, v6) )
  {
    v11 = *(_DWORD *)v6;
    goto LABEL_4;
  }
LABEL_17:
  while ( 1 )
  {
    v20 = __readfsqword(0x28u);
    v19 = v20 ^ v69;
    result = 1LL;
    if ( v20 == v69 )
      return result;
LABEL_202:
    v31 = 0LL;
LABEL_183:
    v37 = 2;
    if ( (_DWORD)v31 != (_DWORD)v9 )
    {
LABEL_184:
      LOBYTE(v67) = v31;
      v37 = 2;
      v19 = 0LL;
    }
LABEL_58:
    LODWORD(v9) = 4;
    if ( result == 280835026583556LL )
    {
      v5 = *(_QWORD *)(v7 + 3904);
      if ( v5 )
      {
        LODWORD(v9) = 0;
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD, __int64, __int64, signed __int64))(*(_QWORD *)v5 + 48LL))(
          v5,
          0LL,
          0LL,
          v19,
          v10,
          v31);
      }
    }
    else
    {
      v38 = *(_DWORD *)(v6 + 28);
      if ( v38 == 65293 )
      {
LABEL_166:
        if ( *(_BYTE *)(*(_QWORD *)(v7 + 3912) + 445LL) )
        {
          v61 = 0;
          v37 = 3;
          LOWORD(v67) = 2573;
        }
        else
        {
          LOBYTE(v67) = 13;
          v61 = 1;
          v37 = 2;
        }
        LOBYTE(v19) = 0;
        v39 = 55;
      }
      else
      {
        if ( (_BYTE)v67 )
          goto LABEL_217;
        if ( !((v38 - 32) & 0xFFFFFFDF) || v38 == 50 )
        {
          v10 &= 5u;
          if ( (_DWORD)v10 == 4 )
            LOBYTE(v19) = 0;
          if ( (_DWORD)v10 == 4 )
            v37 = 2;
        }
        if ( (v5 & 0xFFFFFFFF00000005LL) != 137438953477LL )
        {
LABEL_217:
          v61 = 0;
          v39 = 55;
        }
        else
        {
          LOBYTE(v67) = -96;
          v61 = 0;
          LOBYTE(v19) = 0;
          v39 = 1;
          v37 = 2;
        }
      }
LABEL_69:
      v5 &= 0xFFFFFFFF00000001LL;
      if ( v5 == 280409824821248LL )
      {
        v5 = *(_QWORD *)(v7 + 9336);
        v54 = v39;
        v55 = sub_1EF00((__int64 *)v5, 71);
        v61 = 1;
        v37 = 2;
        v39 = v54;
        LOBYTE(v19) = 0;
        LOBYTE(v67) = v55 < 1u ? 8 : 127;
      }
      if ( (*(_QWORD *)(v6 + 24) & 0xFFFFFFFF00000001LL) == 280409824821249LL )
      {
        v5 = *(_QWORD *)(v7 + 9336);
        v56 = v39;
        v57 = sub_1EF00((__int64 *)v5, 71);
        v61 = 1;
        v37 = 2;
        v39 = v56;
        LOBYTE(v19) = 0;
        LOBYTE(v67) = v57 < 1u ? 127 : 8;
      }
      v40 = *(_DWORD *)(v6 + 28);
      if ( v40 == 65056 || (v5 = 280414119788545LL, (*(_QWORD *)(v6 + 24) & 0xFFFFFFFF00000001LL) == 280414119788545LL) )
      {
        v67 = 5921563;
        LOBYTE(v19) = 0;
        v37 = 4;
      }
      else if ( v37 <= 1 && v40 == 65289 )
      {
        LOBYTE(v67) = 9;
        v37 = 2;
      }
      LOBYTE(a3) = v59 & a3;
      if ( !(_BYTE)a3 )
      {
        v9 = (__int64)off_F8C74;
        switch ( v40 )
        {
          case 0xFF50:
          case 0xFF95:
            v47 = 0;
            goto LABEL_106;
          case 0xFF51:
          case 0xFF96:
            v45 = 68;
            goto LABEL_104;
          case 0xFF52:
          case 0xFF97:
            v45 = 65;
            goto LABEL_104;
          case 0xFF53:
          case 0xFF98:
            v45 = 67;
            goto LABEL_104;
          case 0xFF54:
          case 0xFF99:
            v45 = 66;
            goto LABEL_104;
          case 0xFF55:
          case 0xFF9A:
            v47 = 4;
            goto LABEL_106;
          case 0xFF56:
          case 0xFF9B:
            v47 = 5;
            goto LABEL_106;
          case 0xFF57:
          case 0xFF9C:
            v47 = 1;
            goto LABEL_106;
          case 0xFF58:
          case 0xFF9D:
            v45 = 71;
LABEL_104:
            v9 = *(_QWORD *)(v7 + 3912);
            v5 = a5 + 1;
            v59 = v39;
            v46 = sub_98A60(a5 + 1, (_BYTE *)v9, v45, (*(_DWORD *)(v6 + 24) >> 2) & 1);
            v39 = v59;
            v37 = v46 + 1;
            goto LABEL_98;
          case 0xFF63:
          case 0xFF9E:
            v47 = 2;
            goto LABEL_106;
          case 0xFF9F:
          case 0xFFFF:
            v47 = 3;
LABEL_106:
            if ( *(_BYTE *)(v6 + 24) & 4 )
              goto LABEL_96;
            v9 = *(_QWORD *)(v7 + 3912);
            v5 = a5 + 1;
            v59 = v39;
            v48 = sub_98CD0((_BYTE *)(a5 + 1), v9, v47);
            v39 = v59;
            v37 = v48 + 1;
            goto LABEL_98;
          case 0xFFBE:
            v43 = 1;
            goto LABEL_102;
          case 0xFFBF:
            v43 = 2;
            goto LABEL_102;
          case 0xFFC0:
            v43 = 3;
            goto LABEL_102;
          case 0xFFC1:
            v43 = 4;
            goto LABEL_102;
          case 0xFFC2:
            v43 = 5;
            goto LABEL_102;
          case 0xFFC3:
            v43 = 6;
            goto LABEL_102;
          case 0xFFC4:
            v43 = 7;
            goto LABEL_102;
          case 0xFFC5:
            v43 = 8;
            goto LABEL_102;
          case 0xFFC6:
            v43 = 9;
            goto LABEL_102;
          case 0xFFC7:
            v43 = 10;
            goto LABEL_102;
          case 0xFFC8:
            v43 = 11;
            goto LABEL_102;
          case 0xFFC9:
            v43 = 12;
            goto LABEL_102;
          case 0xFFCA:
            v43 = 13;
            goto LABEL_102;
          case 0xFFCB:
            v43 = 14;
            goto LABEL_102;
          case 0xFFCC:
            v43 = 15;
            goto LABEL_102;
          case 0xFFCD:
            v43 = 16;
            goto LABEL_102;
          case 0xFFCE:
            v43 = 17;
            goto LABEL_102;
          case 0xFFCF:
            v43 = 18;
            goto LABEL_102;
          case 0xFFD0:
            v43 = 19;
            goto LABEL_102;
          case 0xFFD1:
            v43 = 20;
LABEL_102:
            v9 = *(_QWORD *)(v7 + 3912);
            v5 = a5 + 1;
            v59 = v39;
            v44 = sub_98AF0(a5 + 1, v9, v43, *(_DWORD *)(v6 + 24) & 1, (*(_DWORD *)(v6 + 24) >> 2) & 1);
            v39 = v59;
            v37 = v44 + 1;
            goto LABEL_98;
          default:
LABEL_96:
            if ( !v60 )
            {
              LOBYTE(a3) = v19;
              goto LABEL_98;
            }
            v58 = *(_DWORD *)(v6 + 24);
            v5 = a5 + 1;
            v9 = *(_QWORD *)(v7 + 3912);
            v59 = v39;
            v6 = (unsigned int)v60;
            v37 = (unsigned __int64)sub_98EC0((char *)(a5 + 1), v9, v60, v58 & 1, (v58 >> 2) & 1) + 1;
            v39 = v59;
            if ( v60 != 13 || v37 != 1 )
            {
              LOBYTE(a3) = 0;
              goto LABEL_98;
            }
            v42 = *(_QWORD *)(v7 + 3912);
            if ( *(_BYTE *)(v42 + 445) )
            {
              LOWORD(v67) = 2573;
              v37 = 3;
              goto LABEL_98;
            }
            LOBYTE(v67) = 13;
            v37 = 2;
            break;
        }
LABEL_100:
        *(&v66 + v37) = 0;
        sub_99290(v42, 0xFFFFFFFFLL, (const char *)(a5 + v8), -2);
        goto LABEL_15;
      }
      v5 = a5 + 1;
      v9 = *(_QWORD *)(v7 + 3912);
      v59 = v39;
      LOBYTE(a3) = 0;
      v53 = sub_98EC0((char *)(a5 + 1), v9, v60, *(_DWORD *)(v6 + 24) & 1, (*(_DWORD *)(v6 + 24) >> 2) & 1);
      v39 = v59;
      v37 = v53 + 1;
LABEL_98:
      v18 = v37 - v8;
      if ( v37 - (signed int)v8 > 0 )
      {
        v17 = *(_QWORD *)(v7 + 3912);
        v42 = *(_QWORD *)(v7 + 3912);
        if ( v61 )
          goto LABEL_100;
        v16 = (const char *)(a5 + v8);
        if ( *(_BYTE *)(v7 + 3368) )
        {
LABEL_14:
          sub_99290(v17, 0xFFFFFFFFLL, v16, v18);
        }
        else if ( (_BYTE)a3 )
        {
          sub_991B0(v17, (signed int *)(a4 + 4 * v8), v18);
        }
        else
        {
          v16 = (const char *)(a5 + v8);
LABEL_81:
          sub_99290(v17, v39, v16, v18);
        }
LABEL_15:
        LODWORD(v9) = 0;
        v5 = v7;
        sub_ACE80(v7, 0);
        if ( *(_BYTE *)(v7 + 3928) )
        {
          v5 = *(_QWORD *)v7;
          gtk_widget_destroy(*(_QWORD *)v7);
        }
      }
    }
  }
}

__int64 __fastcall sub_B1D00(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 *v3; // r12
  int v4; // eax
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rcx
  int v11; // edx
  __int64 v12; // rax
  __int64 v13; // rax
  _QWORD *v14; // rcx
  int v15; // edx

  if ( a2[1154] != 1 )
    __assert_fail("term->mouse_select_clipboards[0] == CLIP_LOCAL", "unix/gtkwin.c", 0x1178u, "setup_clipboards");
  a2[1161] = 2;
  a2[1155] = 2;
  v3 = a3;
  if ( (unsigned __int8)sub_1EF00(a3, 156) )
  {
    v6 = (signed int)a2[1161];
    a2[1161] = v6 + 1;
    a2[v6 + 1154] = 3;
  }
  *(_QWORD *)(a1 + 3632) = a1;
  *(_DWORD *)(a1 + 3640) = 4;
  *(_QWORD *)(a1 + 3648) = 0LL;
  *(_QWORD *)(a1 + 3696) = a1;
  *(_DWORD *)(a1 + 3704) = 5;
  *(_QWORD *)(a1 + 3712) = 0LL;
  *(_QWORD *)(a1 + 3760) = a1;
  *(_DWORD *)(a1 + 3768) = 6;
  *(_QWORD *)(a1 + 3776) = 0LL;
  v4 = sub_1EFD0(v3, 157);
  if ( v4 == 2 )
  {
    a2[1162] = 3;
  }
  else if ( v4 == 3 )
  {
    a2[1162] = 4;
    v7 = sub_1F170(v3, 160);
    v8 = gdk_atom_intern(v7, 0LL);
    *(_QWORD *)(a1 + 3632) = a1;
    *(_DWORD *)(a1 + 3640) = 4;
    *(_QWORD *)(a1 + 3648) = v8;
  }
  else
  {
    a2[1162] = 2 * (v4 == 1);
  }
  if ( (unsigned int)sub_1EFD0(v3, 158) == 3 )
  {
    v12 = sub_1F170(v3, 161);
    v13 = gdk_atom_intern(v12, 0LL);
    v14 = (_QWORD *)(a1 + 3376);
    v15 = 0;
    do
    {
      if ( a1 == *v14 && v13 == v14[2] )
      {
        *(_DWORD *)(a1 + 3824) = *(_DWORD *)(a1 + ((signed __int64)v15 << 6) + 3384);
        goto LABEL_8;
      }
      ++v15;
      v14 += 8;
    }
    while ( v15 != 7 );
    *(_DWORD *)(a1 + 3824) = 5;
    *(_QWORD *)(a1 + 3696) = a1;
    *(_DWORD *)(a1 + 3704) = 5;
    *(_QWORD *)(a1 + 3712) = v13;
  }
LABEL_8:
  result = sub_1EFD0(v3, 159);
  if ( (_DWORD)result == 3 )
  {
    v9 = sub_1F170(v3, 162);
    result = gdk_atom_intern(v9, 0LL);
    v10 = (_QWORD *)(a1 + 3376);
    v11 = 0;
    do
    {
      if ( a1 == *v10 && result == v10[2] )
      {
        result = *(unsigned int *)(a1 + ((signed __int64)v11 << 6) + 3384);
        *(_DWORD *)(a1 + 3824) = result;
        return result;
      }
      ++v11;
      v10 += 8;
    }
    while ( v11 != 7 );
    *(_DWORD *)(a1 + 3828) = 6;
    *(_QWORD *)(a1 + 3760) = a1;
    *(_DWORD *)(a1 + 3768) = 6;
    *(_QWORD *)(a1 + 3776) = result;
  }
  return result;
}

__int64 __fastcall sub_B2540(__int64 a1, __int64 *a2, int a3)
{
  __int64 result; // rax

  if ( a3 )
    result = sub_AE160(a1, a2, a3);
  return result;
}

unsigned __int64 __fastcall sub_B2560(__int64 *a1, const char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 *v10; // r12
  const char *v11; // rbp
  int *v12; // rsi
  char *v13; // rdi
  _QWORD *v14; // rbx
  int v15; // ebp
  __int64 v16; // rbp
  __int64 v17; // rax
  __int64 v18; // r12
  __int64 v19; // rax
  int v21; // eax
  bool v22; // zf
  __int64 v23; // rax
  __int64 v24; // rax
  char *v25; // rbp
  int v26; // eax
  __int64 *v27; // rdi
  __int64 v28; // rbp
  __int64 v29; // rax
  __int64 v30; // rsi
  __int64 v31; // rbp
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 *v34; // rdi
  __int64 v35; // rdi
  __int64 v36; // r13
  __int64 v37; // rax
  __int64 v38; // rbp
  __int64 v39; // rax
  unsigned __int8 v40; // al
  __int64 v41; // rdi
  __int64 v42; // rax
  int v43; // er13
  int v44; // er15
  unsigned int v45; // er15
  unsigned int v46; // ST04_4
  __int64 v47; // rax
  __int64 v48; // r13
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 v58; // rax
  __int64 v59; // rax
  __int64 v60; // rax
  __int64 v61; // rax
  __int64 v62; // rax
  __int64 v63; // rax
  __int64 v64; // rax
  __int64 v65; // rax
  __int64 v66; // rax
  __int64 v67; // r12
  __int64 v68; // rax
  __int64 v69; // rax
  __int64 v70; // r12
  __int64 v71; // rax
  __int64 v72; // rdi
  __int64 v73; // r14
  __int64 v74; // r12
  __int64 v75; // rax
  __int64 v76; // r12
  __int64 v77; // rax
  __int64 v78; // rdi
  __int64 v79; // r12
  __int64 v80; // rax
  __int64 v81; // r12
  __int64 v82; // rax
  __int64 v83; // r13
  __int64 v84; // rdi
  __int64 v85; // r12
  __int64 v86; // rax
  __int64 v87; // rdi
  __int64 v88; // r12
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // r12
  __int64 v92; // rax
  __int64 v93; // rdi
  __int64 v94; // r12
  __int64 v95; // rax
  __int64 v96; // r12
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // r12
  __int64 v100; // rax
  __int64 v101; // rax
  __int64 v102; // r12
  __int64 v103; // rax
  __int64 v104; // rdi
  __int64 v105; // r12
  __int64 v106; // rax
  double v107; // xmm4_8
  double v108; // xmm5_8
  char *v109; // r13
  __int64 v110; // r12
  __int64 v111; // rax
  __int64 v112; // rax
  __int64 v113; // rdi
  __int64 v114; // rdi
  __int64 v115; // rdi
  __int64 v116; // rax
  _QWORD *v117; // rax
  _QWORD *v118; // rdi
  _DWORD *v119; // rax
  __int64 *v120; // rdx
  __int64 v121; // rax
  __int64 v122; // rdi
  signed int v123; // eax
  __int64 v124; // rax
  double v125; // xmm4_8
  double v126; // xmm5_8
  __int64 v127; // rdi
  __int64 v128; // r12
  __int64 v129; // rax
  __int64 v130; // rax
  __int64 v131; // r12
  __int64 v132; // rax
  __int64 v133; // rax
  __int64 v134; // r13
  __int64 v135; // rdi
  __int64 v136; // rax
  __int64 v137; // rax
  __int64 v138; // rax
  __int64 v139; // r13
  XClassHint *v140; // rax
  XClassHint *v141; // r14
  Window v142; // rax
  __int64 v143; // r12
  __int64 v144; // rax
  __int64 v145; // rax
  __int64 v146; // rax
  unsigned int v147; // er15
  __int64 v148; // ST10_8
  __int64 v149; // rax
  __int64 v150; // rax
  int v151; // eax
  unsigned int v152; // er14
  __int64 v153; // rax
  __int64 v154; // rax
  unsigned int v155; // [rsp+4h] [rbp-B4h]
  __int64 v156; // [rsp+8h] [rbp-B0h]
  int v157; // [rsp+18h] [rbp-A0h]
  int v158; // [rsp+1Ch] [rbp-9Ch]
  int v159; // [rsp+20h] [rbp-98h]
  int v160; // [rsp+24h] [rbp-94h]
  int v161; // [rsp+28h] [rbp-90h]
  int v162; // [rsp+2Ch] [rbp-8Ch]
  int v163; // [rsp+34h] [rbp-84h]
  int v164; // [rsp+38h] [rbp-80h]
  unsigned int v165; // [rsp+3Ch] [rbp-7Ch]
  unsigned int v166; // [rsp+40h] [rbp-78h]
  int v167; // [rsp+48h] [rbp-70h]
  int v168; // [rsp+4Ch] [rbp-6Ch]
  int v169; // [rsp+50h] [rbp-68h]
  int v170; // [rsp+54h] [rbp-64h]
  int v171; // [rsp+58h] [rbp-60h]
  int v172; // [rsp+5Ch] [rbp-5Ch]
  unsigned __int64 v173; // [rsp+78h] [rbp-40h]

  v10 = a1;
  v11 = a2;
  v173 = __readfsqword(0x28u);
  sub_3C190(a1);
  v12 = 0LL;
  v13 = (char *)sub_2F450(1uLL, 0x2558uLL, 0LL);
  v14 = v13;
  memset(v13, 0, 0x2558uLL);
  *((_DWORD *)v13 + 965) = -1;
  *((_QWORD *)v13 + 1167) = v10;
  *((_DWORD *)v13 + 9) = 1;
  *((_QWORD *)v13 + 1193) = &off_322780;
  *((_QWORD *)v13 + 1192) = off_324AA0;
  *((_QWORD *)v13 + 1194) = off_324A80;
  *((_QWORD *)v13 + 13) = sub_AB820(v13, 0LL);
  if ( !v11 )
    goto LABEL_5;
  v12 = &v163;
  v13 = (char *)v11;
  v15 = XParseGeometry(v11, &v163, &v164, &v165, &v166);
  if ( !(v15 & 4) )
  {
    if ( !(v15 & 8) )
      goto LABEL_4;
    goto LABEL_27;
  }
  v12 = &dword_78 + 3;
  v13 = (char *)v10;
  sub_1F760(v10, 123, v165);
  if ( v15 & 8 )
  {
LABEL_27:
    v12 = &dword_7C;
    v13 = (char *)v10;
    sub_1F760(v10, 124, v166);
    if ( v15 & 3 )
      goto LABEL_11;
LABEL_5:
    if ( qword_326540 )
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_4:
  if ( !(v15 & 3) )
    goto LABEL_5;
LABEL_11:
  v21 = v163;
  *((_BYTE *)v14 + 180) = 1;
  v22 = qword_326540 == 0;
  *((_DWORD *)v14 + 44) = (v15 >> 4) & 3;
  *((_DWORD *)v14 + 42) = v21;
  *((_DWORD *)v14 + 43) = v164;
  if ( !v22 )
  {
LABEL_6:
    if ( qword_326548 )
      goto LABEL_7;
LABEL_13:
    v13 = "UTF8_STRING";
    v12 = 0LL;
    qword_326548 = gdk_atom_intern("UTF8_STRING", 0LL);
    if ( qword_3260C8 )
      goto LABEL_8;
    goto LABEL_14;
  }
LABEL_12:
  v13 = "COMPOUND_TEXT";
  v12 = 0LL;
  qword_326540 = gdk_atom_intern("COMPOUND_TEXT", 0LL);
  if ( !qword_326548 )
    goto LABEL_13;
LABEL_7:
  if ( qword_3260C8 )
    goto LABEL_8;
LABEL_14:
  v13 = "CLIPBOARD";
  v12 = 0LL;
  qword_3260C8 = gdk_atom_intern("CLIPBOARD", 0LL);
LABEL_8:
  v16 = gtk_drawing_area_new(v13, v12);
  v14[1] = v16;
  v17 = gtk_widget_get_type(v13, v12);
  v18 = v17;
  v19 = g_type_check_instance_cast(v16, v17);
  gtk_widget_set_name(v19, "drawing-area");
  if ( sub_B07B0((__int64)v14) )
    sub_AA8C0();
  v14[16] = gtk_im_multicontext_new(v14);
  v23 = sub_AB4E0();
  *v14 = v23;
  v24 = g_type_check_instance_cast(v23, v18);
  gtk_widget_set_name(v24, "top-level");
  v25 = (char *)sub_1F170((__int64 *)v14[1167], 202);
  if ( *v25 )
  {
    v136 = g_type_check_instance_cast(*v14, v18);
    gtk_widget_realize(v136);
    v137 = g_type_check_instance_cast(*v14, v18);
    v138 = gtk_widget_get_window(v137);
    v139 = v138;
    if ( v14[13] )
    {
      if ( (unsigned int)gdk_window_ensure_native(v138, v18) )
      {
        v140 = XAllocClassHint();
        v140->res_name = v25;
        v140->res_class = v25;
        v141 = v140;
        v142 = gdk_x11_window_get_xid(v139);
        XSetClassHint((Display *)v14[13], v142, v141);
        XFree(v141);
      }
    }
  }
  v26 = sub_1EFD0((__int64 *)v14[1167], 123);
  v27 = (__int64 *)v14[1167];
  *((_DWORD *)v14 + 960) = v26;
  *((_DWORD *)v14 + 961) = sub_1EFD0(v27, 124);
  sub_ABCA0((__int64)v14);
  sub_B03C0((__int64)v14);
  v28 = gtk_adjustment_get_type(v14, 124LL);
  v29 = gtk_adjustment_new();
  v30 = g_type_check_instance_cast(v29, v28);
  v14[6] = v30;
  v14[2] = gtk_scrollbar_new(1LL, v30);
  v31 = gtk_box_get_type(1LL, v30);
  v32 = gtk_box_new(0LL, 0LL);
  v33 = g_type_check_instance_cast(v32, v31);
  v34 = (__int64 *)v14[1167];
  v14[5] = v33;
  if ( (unsigned __int8)sub_1EF00(v34, 195) )
    gtk_box_pack_start(v14[5], v14[2], 0LL, 0LL, 0LL);
  gtk_box_pack_start(v14[5], v14[1], 1LL, 1LL, 0LL);
  if ( !(unsigned __int8)sub_1EF00((__int64 *)v14[1167], 195) )
    gtk_box_pack_start(v14[5], v14[2], 0LL, 0LL, 0LL);
  v35 = v14[5];
  v36 = g_type_check_instance_cast(v35, v18);
  v37 = gtk_container_get_type(v35);
  v38 = v37;
  v39 = g_type_check_instance_cast(*v14, v37);
  gtk_container_add(v39, v36);
  gtk_widget_show(v14[1]);
  v40 = sub_1EF00((__int64 *)v14[1167], 117);
  v41 = v14[2];
  *((_DWORD *)v14 + 6) = v40;
  if ( v40 )
    gtk_widget_show(v41);
  else
    gtk_widget_hide(v41);
  v42 = g_type_check_instance_cast(v14[5], v18);
  gtk_widget_show(v42);
  gtk_widget_realize(*v14);
  sub_B0B40((__int64)v14);
  v43 = *((_DWORD *)v14 + 961);
  v44 = *((_DWORD *)v14 + 960);
  sub_AC220((__int64)v14, (__int64)&v166);
  v45 = v169 + v171 * v44;
  v46 = v172 * v43 + v170;
  v47 = gtk_window_get_type(v14, &v166);
  v48 = v47;
  v49 = g_type_check_instance_cast(*v14, v47);
  gtk_window_set_default_size(v49, v45, v46);
  if ( *((_BYTE *)v14 + 180) )
  {
    v147 = *((_DWORD *)v14 + 43);
    v155 = *((_DWORD *)v14 + 42);
    v157 = *((_DWORD *)v14 + 961);
    v158 = *((_DWORD *)v14 + 960);
    sub_AC220((__int64)v14, (__int64)&v166);
    v159 = v169;
    v160 = v171;
    v161 = v170;
    v162 = v172;
    v148 = g_type_check_instance_cast(*v14, v18);
    v156 = gtk_widget_get_display(v148, v18);
    v149 = gtk_widget_get_window(v148);
    if ( v149 )
      v150 = gdk_display_get_monitor_at_window(v156, v149);
    else
      v150 = gdk_display_get_monitor(v156, 0LL);
    gdk_monitor_get_geometry(v150, &v166);
    v151 = *((_DWORD *)v14 + 44);
    if ( v151 & 1 )
      v155 = v167 + v155 - (v159 + v160 * v158);
    if ( v151 & 2 )
      v147 = v168 + v147 - (v161 + v162 * v157);
    v152 = dword_F9020[v151 & 3];
    v153 = g_type_check_instance_cast(*v14, v48);
    gtk_window_set_gravity(v153, v152);
    v154 = g_type_check_instance_cast(*v14, v48);
    gtk_window_move(v154, v155, v147);
  }
  v50 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v50, "destroy", sub_ABF20, v14, 0LL, 0LL);
  v51 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v51, "delete_event", sub_AFA10, v14, 0LL, 0LL);
  v52 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v52, "key_press_event", sub_B0E70, v14, 0LL, 0LL);
  v53 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v53, "key_release_event", sub_B0E70, v14, 0LL, 0LL);
  v54 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v54, "focus_in_event", sub_AD350, v14, 0LL, 0LL);
  v55 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v55, "focus_out_event", sub_AD350, v14, 0LL, 0LL);
  v56 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v56, "realize", sub_AE720, v14, 0LL, 0LL);
  v57 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v57, "size_allocate", sub_AE750, v14, 0LL, 0LL);
  v58 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v58, "configure_event", sub_AC8F0, v14, 0LL, 0LL);
  v59 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v59, "configure_event", sub_AE700, v14, 0LL, 0LL);
  v60 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v60, "draw", sub_AE5C0, v14, 0LL, 0LL);
  v61 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v61, "button_press_event", sub_AD340, v14, 0LL, 0LL);
  v62 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v62, "button_release_event", sub_AD340, v14, 0LL, 0LL);
  v63 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v63, "scroll_event", sub_AFF80, v14, 0LL, 0LL);
  v64 = g_type_check_instance_cast(v14[1], 80LL);
  g_signal_connect_data(v64, "motion_notify_event", sub_ACF20, v14, 0LL, 0LL);
  v65 = g_type_check_instance_cast(v14[16], 80LL);
  g_signal_connect_data(v65, "commit", sub_ACEC0, v14, 0LL, 0LL);
  if ( (unsigned __int8)sub_1EF00((__int64 *)v14[1167], 117) )
  {
    v146 = g_type_check_instance_cast(v14[6], 80LL);
    g_signal_connect_data(v146, "value_changed", sub_AD7C0, v14, 0LL, 0LL);
  }
  v66 = g_type_check_instance_cast(v14[1], v18);
  gtk_widget_add_events(v66, 8392468LL);
  sub_AE160(*v14, (__int64 *)off_322E60, 3);
  gtk_widget_show(*v14);
  sub_B01F0((__int64)v14, (signed __int64)off_322E60);
  v14[7] = gtk_menu_new(v14);
  v143 = gtk_menu_item_new_with_label("New Session...");
  v144 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v144, v143);
  gtk_widget_show(v143);
  v145 = g_type_check_instance_cast(v143, 80LL);
  g_signal_connect_data(v145, "activate", sub_AC4E0, v14, 0LL, 0LL);
  v67 = gtk_menu_item_new_with_label("Restart Session");
  v68 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v68, v67);
  gtk_widget_show(v67);
  v69 = g_type_check_instance_cast(v67, 80LL);
  g_signal_connect_data(v69, "activate", sub_AD860, v14, 0LL, 0LL);
  v14[11] = v67;
  gtk_widget_set_sensitive(v67, 0LL);
  v70 = gtk_menu_item_new_with_label("Duplicate Session");
  v71 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v71, v70);
  gtk_widget_show(v70);
  v72 = g_type_check_instance_cast(v70, 80LL);
  g_signal_connect_data(v72, "activate", sub_AC4D0, v14, 0LL, 0LL);
  v73 = gtk_menu_item_get_type(v72, "activate");
  v14[12] = gtk_menu_new(v72);
  v131 = gtk_menu_item_new_with_label("Saved Sessions");
  v132 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v132, v131);
  gtk_widget_show(v131);
  v133 = g_type_check_instance_cast(v131, 80LL);
  g_signal_connect_data(v133, "activate", sub_AC730, v14, 0LL, 0LL);
  v134 = v14[12];
  v135 = g_type_check_instance_cast(v131, v73);
  gtk_menu_item_set_submenu(v135, v134);
  v74 = gtk_menu_item_new(v135, v134);
  v75 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v75, v74);
  gtk_widget_show(v74);
  v76 = gtk_menu_item_new_with_label("Change Settings...");
  v77 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v77, v76);
  gtk_widget_show(v76);
  v78 = g_type_check_instance_cast(v76, 80LL);
  g_signal_connect_data(v78, "activate", sub_AFB60, v14, 0LL, 0LL);
  v79 = gtk_menu_item_new(v78, "activate");
  v80 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v80, v79);
  gtk_widget_show(v79);
  v128 = gtk_menu_item_new_with_label("Event Log");
  v129 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v129, v128);
  gtk_widget_show(v128);
  v130 = g_type_check_instance_cast(v128, 80LL);
  g_signal_connect_data(v130, "activate", sub_AC4C0, v14, 0LL, 0LL);
  v81 = gtk_menu_item_new_with_label("Special Commands");
  v82 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v82, v81);
  gtk_widget_show(v81);
  v83 = gtk_menu_new(v81);
  v14[8] = v83;
  v84 = g_type_check_instance_cast(v81, v73);
  gtk_menu_item_set_submenu(v84, v83);
  v14[9] = v81;
  v85 = gtk_menu_item_new(v84, v83);
  v86 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v86, v85);
  gtk_widget_show(v85);
  v87 = v14[9];
  v14[10] = v85;
  gtk_widget_hide(v87);
  gtk_widget_hide(v14[10]);
  v88 = gtk_menu_item_new_with_label("Clear Scrollback");
  v89 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v89, v88);
  gtk_widget_show(v88);
  v90 = g_type_check_instance_cast(v88, 80LL);
  g_signal_connect_data(v90, "activate", sub_AC3C0, v14, 0LL, 0LL);
  v91 = gtk_menu_item_new_with_label("Reset Terminal");
  v92 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v92, v91);
  gtk_widget_show(v91);
  v93 = g_type_check_instance_cast(v91, 80LL);
  g_signal_connect_data(v93, "activate", sub_AC3D0, v14, 0LL, 0LL);
  v94 = gtk_menu_item_new(v93, "activate");
  v95 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v95, v94);
  gtk_widget_show(v94);
  v96 = gtk_menu_item_new_with_label("Copy to CLIPBOARD");
  v97 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v97, v96);
  gtk_widget_show(v96);
  v98 = g_type_check_instance_cast(v96, 80LL);
  g_signal_connect_data(v98, "activate", sub_ABEA0, v14, 0LL, 0LL);
  v99 = gtk_menu_item_new_with_label(&unk_F8A0F);
  v100 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v100, v99);
  gtk_widget_show(v99);
  v101 = g_type_check_instance_cast(v99, 80LL);
  g_signal_connect_data(v101, "activate", sub_ABE80, v14, 0LL, 0LL);
  v102 = gtk_menu_item_new_with_label("Copy All");
  v103 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v103, v102);
  gtk_widget_show(v102);
  v104 = g_type_check_instance_cast(v102, 80LL);
  g_signal_connect_data(v104, "activate", sub_AC410, v14, 0LL, 0LL);
  v105 = gtk_menu_item_new(v104, "activate");
  v106 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v106, v105);
  gtk_widget_show(v105);
  v109 = sub_BC160("About ", 0.0, 0.0, 0.0, 0.0, v107, v108, a9, a10, "PuTTY", 0LL);
  v110 = gtk_menu_item_new_with_label(v109);
  v111 = g_type_check_instance_cast(v14[7], v38);
  gtk_container_add(v111, v110);
  gtk_widget_show(v110);
  v112 = g_type_check_instance_cast(v110, 80LL);
  g_signal_connect_data(v112, "activate", sub_AC4B0, v14, 0LL, 0LL);
  sub_2F4D0(v109);
  v113 = gdk_display_get_default(v109, "activate");
  v14[24] = gdk_cursor_new_for_display(v113, 152LL);
  v114 = gdk_display_get_default(v113, 152LL);
  v14[23] = gdk_cursor_new_for_display(v114, 68LL);
  v115 = gdk_display_get_default(v114, 68LL);
  v14[26] = gdk_cursor_new_for_display(v115, 150LL);
  v116 = gdk_display_get_default(v115, 150LL);
  v14[25] = gdk_cursor_new_for_display(v116, 4294967294LL);
  v14[27] = v14[24];
  sub_ACE80((__int64)v14, 1);
  v117 = sub_A3950();
  v118 = (_QWORD *)v14[1167];
  v14[1168] = v117;
  v119 = (_DWORD *)sub_92D80(v118, (__int64)(v14 + 492), (__int64)(v14 + 1193));
  v120 = (__int64 *)v14[1167];
  v14[489] = v119;
  sub_B1D00((__int64)v14, v119, v120);
  v121 = sub_2D9F0((__int64)(v14 + 1194), (_QWORD *)v14[1167]);
  v122 = v14[489];
  v14[490] = v121;
  sub_99570(v122, v121);
  v123 = sub_1EFD0((__int64 *)v14[1167], 104);
  sub_91860((const __m128i *)v14[489], *((_DWORD *)v14 + 961), *((_DWORD *)v14 + 960), v123);
  v124 = g_type_check_instance_cast(*v14, 80LL);
  g_signal_connect_data(v124, "window_state_event", sub_AC710, v14, 0LL, 0LL);
  *((_BYTE *)v14 + 3928) = 0;
  sub_AC4F0((__int64)v14, 0.0, 0.0, 0.0, 0.0, v125, v126, a9, a10);
  v127 = v14[487];
  if ( v127 )
    sub_2C080(v127);
  return __readfsqword(0x28u) ^ v173;
}

void __fastcall sub_B36E0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  char *v9; // rax
  char *v10; // rax
  double v11; // xmm4_8
  double v12; // xmm5_8
  char *v13; // rax
  char *v14; // rbp

  v9 = getenv("XAUTHORITY");
  if ( v9 )
  {
    sub_BEA90(a1, v9);
  }
  else
  {
    v10 = getenv("HOME");
    if ( v10 )
    {
      v13 = sub_BC160(v10, a2, a3, a4, a5, v11, v12, a8, a9, "/.Xauthority", 0LL);
      v14 = v13;
      if ( v13 )
      {
        sub_BEA90(a1, v13);
        sub_2F4D0(v14);
      }
    }
  }
}

__int64 __fastcall sub_B3760(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, double xmm0_8_0, double xmm1_8_0, double xmm2_8_0, double xmm3_8_0, double a11, double a12, double a13, double a14, __int64 a7, __int64 a8, __int64 **a9, _QWORD *a10)
{
  unsigned int v18; // ebx
  char *v19; // rax
  unsigned int v20; // er15
  __int64 *v21; // rax
  __int64 v22; // rdx
  const char *v23; // r14
  char *v24; // rax
  char *v25; // r14
  __int64 v26; // r9
  char *v27; // rax
  char *v28; // r14
  __int64 v29; // rax
  __int64 v30; // r15
  __int64 *v31; // rax
  __int64 v32; // rdx
  __int64 v33; // r9
  char *v34; // rdi
  char *v35; // rax
  double v36; // xmm4_8
  double v37; // xmm5_8
  char *v38; // r12
  __mode_t v39; // ST20_4
  FILE *v40; // rbp
  char *v41; // rbx
  __pid_t v43; // eax
  signed __int64 v44; // rax
  signed __int64 v45; // r13
  signed __int64 v46; // rbx
  __int64 v47; // rsi
  signed __int64 v48; // [rsp+0h] [rbp-1088h]
  __int64 fd; // [rsp+8h] [rbp-1080h]
  int fda; // [rsp+8h] [rbp-1080h]
  __int64 mask; // [rsp+10h] [rbp-1078h]
  __int64 v52; // [rsp+18h] [rbp-1070h]
  struct addrinfo **v53; // [rsp+20h] [rbp-1068h]
  __int64 v54; // [rsp+28h] [rbp-1060h]
  void *v55; // [rsp+30h] [rbp-1058h]
  int pipedes[2]; // [rsp+38h] [rbp-1050h]
  char buf; // [rsp+40h] [rbp-1048h]
  unsigned __int64 v58; // [rsp+1048h] [rbp-40h]

  v18 = a3;
  fd = a2;
  v54 = a4;
  mask = a5;
  v52 = a6;
  v58 = __readfsqword(0x28u);
  v48 = sub_BC650();
  while ( 1 )
  {
    v21 = (__int64 *)sub_3ADB0(0LL, v18 + 6000, a1, 0, (__int64)a10, 1u);
    v22 = *v21;
    *a9 = v21;
    v23 = (const char *)(*(__int64 (__fastcall **)(__int64 *))(v22 + 48))(v21);
    if ( !v23 )
      break;
    (*(void (**)(void))(**a9 + 8))();
    v19 = strerror(98);
    v20 = strcmp(v23, v19);
    if ( !v20 )
    {
      v28 = 0LL;
      v38 = 0LL;
      goto LABEL_18;
    }
    ++v18;
  }
  v24 = (char *)sub_B7300();
  v25 = v24;
  if ( v24 )
  {
    v55 = 0LL;
    v53 = (struct addrinfo **)sub_B7550(v24, &v55, 1);
    sub_2F4D0(v55);
    sub_2F4D0(v25);
    if ( v53 )
      sub_BEEE0(v48 + 24, (__int64)v53, v18, mask, v52, v26, a7, a8);
  }
  else
  {
    sub_2F4D0(0LL);
    v53 = 0LL;
  }
  v27 = sub_BC360((__int64)"/tmp/.X11-unix/X%d", v18, v48);
  v28 = v27;
  v29 = sub_B74A0((__int64)v27);
  v30 = v29;
  v31 = (__int64 *)sub_B7700(v29, a1);
  v32 = *v31;
  a9[1] = v31;
  if ( (*(__int64 (__fastcall **)(__int64 *, __int64))(v32 + 48))(v31, a1) )
  {
    v20 = 1;
    (*(void (**)(void))(*a9[1] + 8))();
    v34 = v28;
    v28 = 0LL;
    sub_2F4D0(v34);
  }
  else
  {
    v47 = v30;
    v20 = 2;
    sub_BEEE0(v48 + 24, v47, v18, mask, v52, v33, a7, a8);
  }
  v35 = getenv("TMPDIR");
  if ( v35 )
  {
    if ( !*v35 )
      v35 = "/tmp";
  }
  else
  {
    v35 = "/tmp";
  }
  v38 = sub_BC160(v35, xmm0_8_0, xmm1_8_0, xmm2_8_0, xmm3_8_0, v36, v37, a13, a14, "/", fd, "-Xauthority-XXXXXX", 0LL);
  v39 = umask(0x3Fu);
  fda = mkstemp(v38);
  umask(v39);
  if ( fda < 0 )
  {
    v44 = (signed int)(v20 - 1);
    v45 = v44 - 1;
    v46 = v44 - 1 - (v20 - 1);
    while ( 1 )
    {
      (*(void (**)(void))(*a9[v44] + 8))();
      v44 = v45;
      if ( v46 == v45 )
        break;
      --v45;
    }
    v20 = -1;
  }
  else
  {
    if ( !pipe(pipedes) )
    {
      v43 = fork();
      if ( !v43 )
      {
        close(0);
        close(1);
        close(2);
        setpgid(0, 0);
        close(pipedes[1]);
        close(fda);
        while ( read(pipedes[0], &buf, 0x1000uLL) > 0 )
          ;
        unlink(v38);
        if ( v28 )
          unlink(v28);
        _exit(0);
      }
      if ( v43 < 0 )
      {
        close(pipedes[0]);
        close(pipedes[1]);
      }
      else
      {
        close(pipedes[0]);
        sub_B4F50(pipedes[1]);
      }
    }
    v40 = fdopen(fda, "wb");
    fwrite(*(const void **)(v48 + 8), 1uLL, *(_QWORD *)(v48 + 16), v40);
    fclose(v40);
    v41 = sub_BC360((__int64)":%d%s", v18, v54);
    sub_1F940(a10, 55, "DISPLAY", v41);
    sub_2F4D0(v41);
    sub_1F940(a10, 55, "XAUTHORITY", v38);
  }
  if ( v53 )
    sub_B62D0(v53);
LABEL_18:
  sub_2F4D0(v38);
  sub_BC660((void **)v48);
  sub_2F4D0(v28);
  return v20;
}

signed __int64 __fastcall sub_B3BC0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_B3BE0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a2 > *a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *a2 < *a1;
  return result;
}

char __fastcall sub_B3C00(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  int v3; // eax
  int v4; // edx
  void *v6; // rdi
  unsigned int *v7; // rbp
  signed __int32 v8; // edi
  _DWORD *v9; // rax

  v1 = a1;
  v2 = read(
         *(_DWORD *)a1,
         (void *)(*(_QWORD *)(a1 + 8) + *(signed int *)(a1 + 24)),
         *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 24));
  if ( v2 <= 0 )
  {
    v6 = *(void **)(a1 + 8);
    if ( v6 != (void *)(v1 + 16) )
      sub_2F4D0(v6);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 24) + v2;
    v4 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 24) = v3;
    if ( v3 != 4 || v4 != 4 )
      return v4 <= v3;
    v7 = *(unsigned int **)(a1 + 8);
    v8 = _byteswap_ulong(*v7) + 4;
    *(_DWORD *)(v1 + 20) = v8;
    if ( v8 > 0 )
    {
      if ( v7 != (unsigned int *)(v1 + 16) )
        __assert_fail("conn->retbuf == conn->sizebuf", "unix/uxagentc.c", 0x52u, "agent_try_read");
      v9 = sub_2F450(v8, 1uLL, 0LL);
      *(_QWORD *)(v1 + 8) = v9;
      *v9 = *v7;
      v3 = *(_DWORD *)(v1 + 24);
      v4 = *(_DWORD *)(v1 + 20);
      return v4 <= v3;
    }
  }
  *(_QWORD *)(v1 + 8) = 0LL;
  *(_DWORD *)(v1 + 24) = 0;
  return 1;
}

__int64 sub_B3CE0()
{
  char *v0; // rax
  unsigned int v1; // edx

  v0 = getenv("SSH_AUTH_SOCK");
  v1 = 0;
  if ( v0 )
    LOBYTE(v1) = *v0 != 0;
  return v1;
}

void __fastcall sub_B3D10(int *a1)
{
  int *v1; // rbx
  int *v2; // rdi

  v1 = a1;
  sub_B86F0(*a1);
  close(*a1);
  sub_9B440((__int64 *)qword_3264E0, (__int64)a1);
  v2 = (int *)*((_QWORD *)a1 + 1);
  if ( v2 && v2 != v1 + 4 )
    sub_2F4D0(v2);
  sub_2F4D0(v1);
}

void __fastcall sub_B3D60(unsigned int a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  int v4; // [rsp+Ch] [rbp-Ch]

  v4 = a1;
  if ( a2 != 1 )
    __assert_fail("event == SELECT_R", "unix/uxagentc.c", 0x6Bu, "agent_select_result");
  v2 = sub_9B3D0((__int64 *)qword_3264E0, (__int64)&v4, (__int64 (__fastcall *)(__int64))sub_B3BE0);
  v3 = v2;
  if ( v2 )
  {
    if ( sub_B3C00(v2) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(v3 + 32))(
        *(_QWORD *)(v3 + 40),
        *(_QWORD *)(v3 + 8),
        *(unsigned int *)(v3 + 24));
      *(_QWORD *)(v3 + 8) = 0LL;
      sub_B3D10((int *)v3);
    }
  }
  else
  {
    sub_B86F0(v4);
  }
}

_QWORD *__fastcall sub_B3DF0(__int64 a1, __int64 a2)
{
  char *v2; // rax
  __int64 v3; // rax

  v2 = getenv("SSH_AUTH_SOCK");
  if ( !v2 )
    return sub_2BCD0(a1, (__int64)"SSH_AUTH_SOCK not set");
  v3 = sub_B74A0((__int64)v2);
  return (_QWORD *)sub_B6300(v3, 0, 0, 0, 0, 0, a1);
}

__int64 __fastcall sub_B3E40(_QWORD *a1, _QWORD *a2, _DWORD *a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // r15
  _DWORD *v6; // r14
  __int64 v7; // r13
  char *v8; // rax
  char *v9; // r12
  int v10; // eax
  int v11; // ebp
  unsigned __int64 v12; // rdx
  int v13; // er12
  __int64 v14; // rsi
  int v15; // eax
  __int64 v16; // rbx
  _QWORD *v18; // rax
  __int64 *v19; // rdi
  void *v20; // rdi
  int v21; // eax
  __int64 v22; // [rsp+8h] [rbp-C0h]
  __int16 v23; // [rsp+10h] [rbp-B8h]
  char v24; // [rsp+12h] [rbp-B6h]
  unsigned __int64 v25; // [rsp+88h] [rbp-40h]

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v25 = __readfsqword(0x28u);
  v22 = a5;
  v8 = getenv("SSH_AUTH_SOCK");
  if ( !v8 )
    goto LABEL_10;
  v9 = v8;
  if ( strlen(v8) > 0x6B )
    goto LABEL_10;
  v10 = socket(1, 1, 0);
  v11 = v10;
  if ( v10 < 0 )
  {
    perror("socket(PF_UNIX)");
    exit(1);
  }
  sub_B4F50(v10);
  v23 = 1;
  __strcpy_chk(&v24, v9, 108LL);
  if ( connect(v11, (const struct sockaddr *)&v23, 0x6Eu) < 0 )
  {
LABEL_9:
    close(v11);
LABEL_10:
    *v5 = 0LL;
    v16 = 0LL;
    *v6 = 0;
    return v16;
  }
  sub_BC800((__int64)a1);
  v12 = a1[2];
  if ( v12 )
  {
    v13 = 0;
    v14 = 0LL;
    do
    {
      v15 = write(v11, (const void *)(*a1 + v14), v12 - v14);
      if ( v15 <= 0 )
        goto LABEL_9;
      v12 = a1[2];
      v13 += v15;
      v14 = v13;
    }
    while ( v13 < v12 );
  }
  v18 = sub_2F450(1uLL, 0x30uLL, 0LL);
  *(_DWORD *)v18 = v11;
  v16 = (__int64)v18;
  *(_QWORD *)((char *)v18 + 20) = 4LL;
  v18[4] = v7;
  v18[1] = v18 + 2;
  v18[5] = v22;
  if ( v7 )
  {
    v19 = (__int64 *)qword_3264E0;
    if ( !qword_3264E0 )
    {
      v19 = sub_9AF60((__int64)sub_B3BC0);
      qword_3264E0 = (__int64)v19;
    }
    sub_9AFD0(v19, v16);
    sub_B8750(v11, 1, (__int64)sub_B3D60);
  }
  else
  {
    sub_B50E0(v11);
    while ( !sub_B3C00(v16) )
      ;
    v20 = (void *)v16;
    *v5 = *(_QWORD *)(v16 + 8);
    v21 = *(_DWORD *)(v16 + 24);
    v16 = 0LL;
    *v6 = v21;
    sub_2F4D0(v20);
  }
  return v16;
}

__int64 __fastcall sub_B4060(unsigned __int64 *a1, char a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // rdx
  __int64 v5; // rbp
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rbx
  int v9; // eax
  void *v10; // rdi
  _QWORD *v11; // rax
  __int64 v12; // rdx
  _QWORD *v13; // rax
  _QWORD *v14; // r12
  __int64 v15; // rbx

  v2 = sub_28A10(a1, "Terminal", "printing", "Remote-controlled printing");
  if ( *(_QWORD *)(v2 + 32) != 1LL || (result = **(_QWORD **)(v2 + 48), *(_DWORD *)result != 1) )
    __assert_fail(
      "s->ncontrols == 1 && s->ctrls[0]->generic.type == CTRL_EDITBOX",
      "unix/uxcfg.c",
      0x1Fu,
      "unix_setup_config_box");
  *(_BYTE *)(result + 65) = 0;
  if ( !a2 )
  {
    result = sub_28A10(a1, "Connection/Proxy", "basics", 0LL);
    v4 = *(_QWORD *)(result + 32);
    v5 = result;
    if ( v4 )
    {
      v6 = *(_QWORD *)(result + 48);
      v7 = 0LL;
      while ( 1 )
      {
        v8 = *(_QWORD *)(v6 + 8 * v7);
        if ( *(_DWORD *)v8 == 2 && *(_DWORD *)(v8 + 32) == 13 )
          break;
        if ( ++v7 == v4 )
          goto LABEL_13;
      }
      if ( *(void (__fastcall **)(__int64, __int64 **, __int64 *, int))(v8 + 24) != sub_22230 )
        __assert_fail("c->generic.handler == conf_radiobutton_handler", "unix/uxcfg.c", 0x2Du, "unix_setup_config_box");
      v9 = *(_DWORD *)(v8 + 64);
      v10 = *(void **)(v8 + 72);
      *(_DWORD *)(v8 + 64) = v9 + 1;
      v11 = sub_2F490(v10, v9 + 1, 8uLL);
      v12 = *(signed int *)(v8 + 64);
      *(_QWORD *)(v8 + 72) = v11;
      v11[v12 - 1] = sub_BC120("Local");
      v13 = sub_2F490(*(void **)(v8 + 88), *(signed int *)(v8 + 64), 8uLL);
      *(_QWORD *)(v8 + 88) = v13;
      v14 = v13;
      result = sub_28760(5u);
      v14[*(signed int *)(v8 + 64) - 1] = result;
      v4 = *(_QWORD *)(v5 + 32);
      if ( !v4 )
        return result;
      v6 = *(_QWORD *)(v5 + 48);
LABEL_13:
      result = 0LL;
      while ( 1 )
      {
        v15 = *(_QWORD *)(v6 + 8 * result);
        if ( *(_DWORD *)v15 == 1 && *(_DWORD *)(v15 + 32) == 18 )
          break;
        if ( ++result == v4 )
          return result;
      }
      if ( *(unsigned __int64 (__fastcall **)(__int64, __int64 **, __int64 *, int))(v15 + 24) != sub_1FF90 )
        __assert_fail("c->generic.handler == conf_editbox_handler", "unix/uxcfg.c", 0x3Eu, "unix_setup_config_box");
      sub_2F4D0(*(void **)(v15 + 8));
      result = (__int64)sub_BC120("Telnet command, or local proxy command");
      *(_QWORD *)(v15 + 8) = result;
    }
  }
  return result;
}

signed __int64 __fastcall sub_B4230(__int64 a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 4) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 4) > v2;
  return result;
}

signed __int64 __fastcall sub_B4250(_DWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( *(_DWORD *)(a2 + 4) > *a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a2 + 4) < *a1;
  return result;
}

signed __int64 __fastcall sub_B4270(__int64 a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(a1 + 8) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 8) > v2;
  return result;
}

signed __int64 __fastcall sub_B4290(_DWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( *(_DWORD *)(a2 + 8) > *a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a2 + 8) < *a1;
  return result;
}

signed __int64 __fastcall sub_B42B0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_B42D0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a2 > *a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *a2 < *a1;
  return result;
}

__int64 __fastcall sub_B42F0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 - 8);
  if ( a2 )
    *(_QWORD *)(a1 - 8) = a2;
  return result;
}

__int64 sub_B4300()
{
  return 0LL;
}

void __fastcall sub_B4310(__int64 a1, char a2)
{
  int v2; // edi

  v2 = *(_DWORD *)(a1 - 8308);
  if ( v2 >= 0 )
  {
    if ( a2 )
      sub_B86F0(v2);
    else
      sub_B8750(v2, 1, (__int64)sub_B4400);
  }
}

unsigned __int64 __fastcall sub_B4340(int a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  int v3; // eax
  int fd; // [rsp+Ch] [rbp-502Ch]
  char buf; // [rsp+10h] [rbp-5028h]
  unsigned __int64 v7; // [rsp+5018h] [rbp-20h]

  fd = a1;
  v7 = __readfsqword(0x28u);
  v1 = sub_9B3D0((__int64 *)qword_3264E8, (__int64)&fd, (__int64 (__fastcall *)(__int64))sub_B4290);
  if ( v1 )
  {
    v2 = v1;
    v3 = read(fd, &buf, 0x5000uLL);
    if ( v3 <= 0 )
    {
      sub_9B440((__int64 *)qword_3264E8, v2);
      sub_B86F0(*(_DWORD *)(v2 + 8));
      close(*(_DWORD *)(v2 + 8));
      *(_DWORD *)(v2 + 8) = -1;
    }
    else
    {
      sub_1B9D0(
        *(void (__fastcall ****)(_QWORD, signed __int64, _QWORD, _QWORD, __int64, _QWORD))(v2 + 8304),
        (_QWORD *)(v2 + 96),
        &buf,
        v3);
    }
  }
  return __readfsqword(0x28u) ^ v7;
}

unsigned __int64 __fastcall sub_B4400(int a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  int v3; // eax
  int *v5; // rax
  unsigned int v6; // ebp
  char *v7; // rax
  int v8; // [rsp+Ch] [rbp-502Ch]
  char buf; // [rsp+10h] [rbp-5028h]
  unsigned __int64 v10; // [rsp+5018h] [rbp-20h]

  v8 = a1;
  v10 = __readfsqword(0x28u);
  v1 = sub_9B3D0((__int64 *)qword_3264F0, (__int64)&v8, (__int64 (__fastcall *)(__int64))sub_B4250);
  if ( v1 )
  {
    v2 = v1;
    v3 = read(*(_DWORD *)(v1 + 4), &buf, 0x5000uLL);
    if ( v3 <= 0 )
    {
      if ( v3 )
      {
        v5 = __errno_location();
        v6 = *v5;
        v7 = strerror(*v5);
        (*(void (__fastcall **)(_QWORD, char *, _QWORD, _QWORD))(**(_QWORD **)(v2 + 8304) + 8LL))(
          *(_QWORD *)(v2 + 8304),
          v7,
          v6,
          0LL);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 8304) + 8LL))(
          *(_QWORD *)(v2 + 8304),
          0LL,
          0LL,
          0LL);
      }
      sub_9B440((__int64 *)qword_3264F0, v2);
      sub_B86F0(*(_DWORD *)(v2 + 4));
      close(*(_DWORD *)(v2 + 4));
      *(_DWORD *)(v2 + 4) = -1;
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, char *, _QWORD))(**(_QWORD **)(v2 + 8304) + 16LL))(
        *(_QWORD *)(v2 + 8304),
        0LL,
        &buf,
        v3);
    }
  }
  return __readfsqword(0x28u) ^ v10;
}

void __fastcall sub_B4500(__int64 a1)
{
  unsigned int v1; // ebp
  char *v2; // rax

  v1 = *(_DWORD *)(a1 + 8300);
  if ( v1 )
  {
    v2 = strerror(v1);
    (*(void (__fastcall **)(_QWORD, char *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 8304) + 8LL))(
      *(_QWORD *)(a1 + 8304),
      v2,
      v1,
      0LL);
  }
}

__int64 __usercall sub_B4550@<rax>(int *a1@<rdi>, __int64 a2@<r14>, __int64 a3@<r15>)
{
  int *v3; // rbp
  __int64 v4; // r12
  const void *v5; // rax
  size_t v6; // rdx
  ssize_t v7; // rbx
  int v8; // eax

  v3 = a1 + 4;
  v4 = 0LL;
  while ( 1 )
  {
    if ( !sub_BCD00((__int64)v3) )
      goto LABEL_7;
    v5 = (const void *)sub_BCF00((__int64)v3);
    v7 = write(*a1, v5, v6);
    sub_B7C30(1u, v7, v4, (__int64)a1, a2, a3);
    if ( v7 < 0 )
      break;
    if ( !v7 )
      goto LABEL_7;
    v4 = (unsigned int)(v7 + v4);
    sub_BCE20((__int64)v3, v7);
  }
  v8 = *__errno_location();
  if ( v8 == 11 )
  {
LABEL_7:
    if ( a1[2074] == 1 )
    {
      sub_9B440((__int64 *)qword_3264F8, (__int64)a1);
      close(*a1);
      sub_B86F0(*a1);
      *a1 = -1;
      a1[2074] = 2;
    }
    if ( sub_BCD00((__int64)v3) )
      sub_B8750(*a1, 2, (__int64)sub_B46A0);
    else
      sub_B86F0(*a1);
    return (unsigned int)v4;
  }
  if ( !a1[2075] )
  {
    a1[2075] = v8;
    sub_1BD80((__int64)sub_B4500, (__int64)a1);
  }
  return 0LL;
}

int *__usercall sub_B46A0@<rax>(int a1@<edi>, __int64 a2@<r14>, __int64 a3@<r15>)
{
  int *result; // rax
  int *v4; // rbx
  __int64 v5; // rax
  int v6; // [rsp+Ch] [rbp-Ch]

  v6 = a1;
  result = (int *)sub_9B3D0((__int64 *)qword_3264F8, (__int64)&v6, (__int64 (__fastcall *)(__int64))sub_B42D0);
  if ( result )
  {
    v4 = result;
    result = (int *)sub_B4550(result, a2, a3);
    if ( (_DWORD)result )
    {
      v5 = sub_BCD00((__int64)(v4 + 4));
      result = (int *)(*(__int64 (__fastcall **)(_QWORD, __int64))(**((_QWORD **)v4 + 1038) + 24LL))(
                        *((_QWORD *)v4 + 1038),
                        v5);
    }
  }
  return result;
}

void __fastcall sub_B4700(__int64 a1)
{
  void *v1; // rbp

  v1 = (void *)(a1 - 8312);
  if ( *(_DWORD *)(a1 - 8312) >= 0 )
  {
    sub_9B440((__int64 *)qword_3264F8, (__int64)v1);
    sub_B86F0(*(_DWORD *)(a1 - 8312));
    close(*(_DWORD *)(a1 - 8312));
  }
  if ( *(_DWORD *)(a1 - 8308) >= 0 )
  {
    sub_9B440((__int64 *)qword_3264F0, (__int64)v1);
    sub_B86F0(*(_DWORD *)(a1 - 8308));
    close(*(_DWORD *)(a1 - 8308));
  }
  if ( *(_DWORD *)(a1 - 8304) >= 0 )
  {
    sub_9B440((__int64 *)qword_3264E8, (__int64)v1);
    sub_B86F0(*(_DWORD *)(a1 - 8304));
    close(*(_DWORD *)(a1 - 8304));
  }
  sub_BCCA0((__int64)v1 + 56);
  sub_BCCA0((__int64)v1 + 16);
  sub_1BCD0((__int64)v1);
  sub_2F4D0(v1);
}

__int64 __usercall sub_B47D0@<rax>(__int64 a1@<rdi>, __int64 a2@<r14>, __int64 a3@<r15>)
{
  if ( *(_DWORD *)(a1 - 16) )
    __assert_fail("fds->outgoingeof == EOF_NO", "unix/uxfdsock.c", 0xE2u, "fdsocket_write_eof");
  *(_DWORD *)(a1 - 16) = 1;
  return sub_B4550((int *)(a1 - 8312), a2, a3);
}

__int64 __usercall sub_B4810@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<rdx>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  if ( *(_DWORD *)(a1 - 16) )
    __assert_fail("fds->outgoingeof == EOF_NO", "unix/uxfdsock.c", 0xCCu, "fdsocket_write");
  sub_BCD20(a1 - 8312 + 16, (char *)a2, a3);
  sub_B4550((int *)(a1 - 8312), a4, a5);
  return sub_BCD00(a1 - 8312 + 16);
}

__int64 __usercall sub_B4870@<rax>(__int64 a1@<rdi>, __int64 a2@<rsi>, __int64 a3@<rdx>, __int64 a4@<r14>, __int64 a5@<r15>)
{
  return sub_B4810(a1, a2, a3, a4, a5);
}

char *__fastcall sub_B4880(int a1, int a2, int a3, __int64 a4)
{
  int v4; // ebp
  __int64 v5; // r14
  char *v6; // rbx
  __int64 *v7; // rdi
  __int64 *v8; // rdi
  int v9; // eax
  __int64 *v10; // rdi

  v4 = a3;
  v5 = a4;
  v6 = (char *)sub_2F450(1uLL, 0x2080uLL, 0LL);
  *((_QWORD *)v6 + 1038) = v5;
  *((_DWORD *)v6 + 2074) = 0;
  *((_QWORD *)v6 + 1039) = off_322840;
  *((_DWORD *)v6 + 2075) = 0;
  *((_DWORD *)v6 + 1) = a1;
  *(_DWORD *)v6 = a2;
  *((_DWORD *)v6 + 2) = v4;
  sub_BCC70((_QWORD *)v6 + 7);
  sub_BCC70((_QWORD *)v6 + 2);
  sub_1B9C0((__int64)(v6 + 96));
  if ( *(_DWORD *)v6 >= 0 )
  {
    v7 = (__int64 *)qword_3264F8;
    if ( !qword_3264F8 )
    {
      v7 = sub_9AF60((__int64)sub_B42B0);
      qword_3264F8 = (__int64)v7;
    }
    sub_9AFD0(v7, (__int64)v6);
  }
  if ( *((_DWORD *)v6 + 1) >= 0 )
  {
    v8 = (__int64 *)qword_3264F0;
    if ( !qword_3264F0 )
    {
      v8 = sub_9AF60((__int64)sub_B4230);
      qword_3264F0 = (__int64)v8;
    }
    sub_9AFD0(v8, (__int64)v6);
    sub_B8750(*((_DWORD *)v6 + 1), 1, (__int64)sub_B4400);
  }
  v9 = *((_DWORD *)v6 + 2);
  if ( v9 >= 0 )
  {
    if ( v9 == *((_DWORD *)v6 + 1) )
      __assert_fail("fds->inerrfd != fds->infd", "unix/uxfdsock.c", 0x15Du, "make_fd_socket");
    v10 = (__int64 *)qword_3264E8;
    if ( !qword_3264E8 )
    {
      v10 = sub_9AF60((__int64)sub_B4270);
      qword_3264E8 = (__int64)v10;
    }
    sub_9AFD0(v10, (__int64)v6);
    sub_B8750(*((_DWORD *)v6 + 2), 1, (__int64)sub_B4340);
  }
  return v6 + 8312;
}

__int64 (__fastcall *__fastcall sub_B4A10(_QWORD *a1, void *a2, int a3, __int64 a4))()
{
  *(_DWORD *)a1 = a3;
  a1[1] = a4;
  a1[24] = a2;
  a1[13] = dlsym(a2, "gss_delete_sec_context");
  a1[14] = dlsym(a2, "gss_display_status");
  a1[15] = dlsym(a2, "gss_get_mic");
  a1[16] = dlsym(a2, "gss_verify_mic");
  a1[17] = dlsym(a2, "gss_import_name");
  a1[18] = dlsym(a2, "gss_init_sec_context");
  a1[19] = dlsym(a2, "gss_release_buffer");
  a1[20] = dlsym(a2, "gss_release_cred");
  a1[21] = dlsym(a2, "gss_release_name");
  a1[22] = dlsym(a2, "gss_acquire_cred");
  a1[23] = dlsym(a2, "gss_inquire_cred_by_mech");
  return sub_767D0(a1);
}

signed int *__fastcall sub_B4B20(__int64 *a1)
{
  signed int *v1; // rbx
  void *v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  void *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  void *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  const char **v11; // rax
  const char *v12; // rbp
  void *v14; // r12
  char *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx

  v1 = (signed int *)sub_2F450(1uLL, 0x10uLL, 0LL);
  *(_QWORD *)v1 = sub_2F450(4uLL, 0xC8uLL, 0LL);
  v1[2] = 0;
  v2 = dlopen("libgssapi.so.2", 1);
  if ( v2 )
  {
    v3 = v1[2];
    v4 = *(_QWORD *)v1;
    v1[2] = v3 + 1;
    sub_B4A10((_QWORD *)(v4 + 200 * v3), v2, 0, (__int64)"Using GSSAPI from libgssapi.so.2");
  }
  v5 = dlopen("libgssapi_krb5.so.2", 1);
  if ( v5 )
  {
    v6 = v1[2];
    v7 = *(_QWORD *)v1;
    v1[2] = v6 + 1;
    sub_B4A10((_QWORD *)(v7 + 200 * v6), v5, 1, (__int64)"Using GSSAPI from libgssapi_krb5.so.2");
  }
  v8 = dlopen("libgss.so.1", 1);
  if ( v8 )
  {
    v9 = v1[2];
    v10 = *(_QWORD *)v1;
    v1[2] = v9 + 1;
    sub_B4A10((_QWORD *)(v10 + 200 * v9), v8, 2, (__int64)&unk_F9453);
  }
  v11 = (const char **)sub_1F530(a1, 46);
  v12 = *v11;
  if ( !**v11 )
    return v1;
  v14 = dlopen(*v11, 1);
  if ( !v14 )
    return v1;
  v15 = sub_BC360((__int64)"Using GSSAPI from user-specified library '%s'", v12);
  v16 = v1[2];
  v17 = *(_QWORD *)v1;
  v1[2] = v16 + 1;
  sub_B4A10((_QWORD *)(v17 + 200 * v16), v14, 3, (__int64)v15);
  return v1;
}

void __fastcall sub_B4CA0(_DWORD *a1)
{
  _DWORD *v1; // r12
  int v2; // eax
  char *v3; // rdi
  __int64 v4; // rbx
  int v5; // ebp
  __int64 v6; // rax

  v1 = a1;
  v2 = a1[2];
  v3 = *(char **)a1;
  if ( v2 > 0 )
  {
    v4 = 0LL;
    v5 = 0;
    do
    {
      dlclose(*(void **)&v3[v4 + 192]);
      v3 = *(char **)v1;
      v6 = *(_QWORD *)v1 + v4;
      if ( *(_DWORD *)v6 == 3 )
      {
        sub_2F4D0(*(void **)(v6 + 8));
        v3 = *(char **)v1;
      }
      ++v5;
      v4 += 200LL;
    }
    while ( v1[2] > v5 );
  }
  sub_2F4D0(v3);
  sub_2F4D0(v1);
}

__int64 sub_B4D20()
{
  __int64 v1; // [rsp+0h] [rbp-28h]
  __int64 v2; // [rsp+8h] [rbp-20h]
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  if ( !clock_gettime(1, (struct timespec *)&v1) )
    return 1000 * v1
         + ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v2) >> 64) >> 18)
         - (v2 >> 63);
  gettimeofday((struct timeval *)&v1, 0LL);
  return 1000 * v1
       + ((signed __int64)((unsigned __int128)(2361183241434822607LL * (signed __int128)v2) >> 64) >> 7)
       - (v2 >> 63);
}

_QWORD *__fastcall sub_B4DD0(char *src)
{
  _QWORD *v1; // rbx

  v1 = sub_2F450(1uLL, 8uLL, 0LL);
  *v1 = sub_BC120(src);
  return v1;
}

_QWORD *__fastcall sub_B4E10(char **a1)
{
  return sub_B4DD0(*a1);
}

__int64 __fastcall sub_B4E20(__int64 a1)
{
  return *(_QWORD *)a1;
}

bool __fastcall sub_B4E30(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2) == 0;
}

bool __fastcall sub_B4E50(_BYTE **a1)
{
  return **a1 == 0;
}

void __fastcall sub_B4E60(void **a1)
{
  sub_2F4D0(*a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_B4E80(__int64 a1, const char **a2)
{
  return sub_2EF90(*(__int64 (__fastcall ***)(_QWORD, const char *, size_t))(a1 + 8), *a2);
}

_QWORD *__fastcall sub_B4E90(__int64 a1)
{
  char *v1; // rax

  v1 = sub_2F240(*(_QWORD *)(a1 + 32));
  return sub_B4DD0(v1);
}

signed __int64 __fastcall sub_B4EB0(unsigned int a1)
{
  signed __int64 result; // rax

  result = 46LL;
  if ( (_BYTE)a1 != 47 )
    result = a1;
  return result;
}

char *sub_B4EC0()
{
  __uid_t v0; // ebp
  char *v1; // rbx
  struct passwd *v2; // rax
  struct passwd *v3; // rax

  v0 = getuid();
  v1 = getlogin();
  setpwent();
  if ( v1 )
  {
    v2 = getpwnam(v1);
    if ( v2 )
    {
      if ( v2->pw_uid == v0 )
        goto LABEL_6;
    }
  }
  v3 = getpwuid(v0);
  if ( v3 )
  {
    v1 = v3->pw_name;
LABEL_6:
    endpwent();
    return sub_BC120(v1);
  }
  return 0LL;
}

size_t sub_B4F30()
{
  return fwrite(
           "These are the fingerprints of the PuTTY PGP Master Keys. They can\n"
           "be used to establish a trust path from this executable to another\n"
           "one. See the manual for more information.\n"
           "(Note: these fingerprints have nothing to do with SSH!)\n"
           "\n"
           "PuTTY Master Key as of 2018 (RSA, 4096-bit):\n"
           "  24E1 B1C5 75EA 3C9F F752  A922 76BC 7FE4 EBFD 2D9E\n"
           "\n"
           "Previous Master Key (2015, RSA, 4096-bit):\n"
           "  440D E3B5 B7A1 CA85 B3CC  1718 AB58 5DC6 0467 6F7C\n",
           1uLL,
           0x1AAuLL,
           stdout);
}

int __fastcall sub_B4F50(int fd)
{
  int v1; // eax
  int result; // eax
  int *v3; // rax
  const char *v4; // rdx
  __int64 v5; // rcx
  int *v6; // rax

  v1 = fcntl(fd, 1);
  if ( v1 < 0 )
  {
    v3 = __errno_location();
    strerror(*v3);
    v4 = "%d: fcntl(F_GETFD): %s\n";
    v5 = (unsigned int)fd;
LABEL_5:
    __fprintf_chk(stderr, 1LL, v4, v5);
    exit(1);
  }
  result = fcntl(fd, 2, v1 | 1u);
  if ( result < 0 )
  {
    v6 = __errno_location();
    strerror(*v6);
    v5 = (unsigned int)fd;
    v4 = "%d: fcntl(F_SETFD): %s\n";
    goto LABEL_5;
  }
  return result;
}

int __fastcall sub_B4FD0(int fd)
{
  int v1; // eax
  int result; // eax
  int *v3; // rax
  const char *v4; // rdx
  __int64 v5; // rcx
  int *v6; // rax

  v1 = fcntl(fd, 1);
  if ( v1 < 0 )
  {
    v3 = __errno_location();
    strerror(*v3);
    v4 = "%d: fcntl(F_GETFD): %s\n";
    v5 = (unsigned int)fd;
LABEL_5:
    __fprintf_chk(stderr, 1LL, v4, v5);
    exit(1);
  }
  result = fcntl(fd, 2, v1 & 0xFFFFFFFE);
  if ( result < 0 )
  {
    v6 = __errno_location();
    strerror(*v6);
    v5 = (unsigned int)fd;
    v4 = "%d: fcntl(F_SETFD): %s\n";
    goto LABEL_5;
  }
  return result;
}

__int64 __fastcall sub_B5050(int fd)
{
  int v1; // eax
  unsigned int v2; // ebx
  int *v4; // rax
  const char *v5; // rdx
  __int64 v6; // rcx
  int *v7; // rax

  v1 = fcntl(fd, 3);
  if ( v1 < 0 )
  {
    v4 = __errno_location();
    strerror(*v4);
    v5 = "%d: fcntl(F_GETFL): %s\n";
    v6 = (unsigned int)fd;
LABEL_5:
    __fprintf_chk(stderr, 1LL, v5, v6);
    exit(1);
  }
  v2 = v1;
  if ( fcntl(fd, 4) < 0 )
  {
    v7 = __errno_location();
    strerror(*v7);
    v6 = (unsigned int)fd;
    v5 = "%d: fcntl(F_SETFL): %s\n";
    goto LABEL_5;
  }
  return (v2 >> 11) & 1;
}

__int64 __fastcall sub_B50E0(int fd)
{
  int v1; // eax
  unsigned int v2; // ebx
  int *v4; // rax
  const char *v5; // rdx
  __int64 v6; // rcx
  int *v7; // rax

  v1 = fcntl(fd, 3);
  if ( v1 < 0 )
  {
    v4 = __errno_location();
    strerror(*v4);
    v5 = "%d: fcntl(F_GETFL): %s\n";
    v6 = (unsigned int)fd;
LABEL_5:
    __fprintf_chk(stderr, 1LL, v5, v6);
    exit(1);
  }
  v2 = v1;
  if ( fcntl(fd, 4) < 0 )
  {
    v7 = __errno_location();
    strerror(*v7);
    v6 = (unsigned int)fd;
    v5 = "%d: fcntl(F_SETFL): %s\n";
    goto LABEL_5;
  }
  return (v2 >> 11) & 1;
}

FILE *__usercall sub_B5170@<rax>(char a1@<dl>, __int64 a2@<rbx>, const char **a3@<rdi>, const char *a4@<rsi>)
{
  int v4; // eax
  FILE *result; // rax

  if ( !a1 )
    return fopen(*a3, a4);
  if ( *a4 != 119 )
    __assert_fail("mode[0] == 'w'", "unix/uxmisc.c", 0xF6u, "f_open");
  v4 = open(*a3, 577, 384LL, a2);
  if ( v4 < 0 )
    result = 0LL;
  else
    result = fdopen(v4, a4);
  return result;
}

_QWORD *__fastcall sub_B51E0(char *src)
{
  _QWORD *v1; // rbx

  v1 = sub_2F450(1uLL, 8uLL, 0LL);
  *v1 = sub_BC120(src);
  return v1;
}

_QWORD *__fastcall sub_B5220(char **a1)
{
  return sub_B51E0(*a1);
}

void __fastcall sub_B5230(void **a1)
{
  sub_2F4D0(*a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_B5250(__int64 a1, const char **a2)
{
  return sub_2EF90(*(__int64 (__fastcall ***)(_QWORD, const char *, size_t))(a1 + 8), *a2);
}

_QWORD *__fastcall sub_B5260(__int64 a1)
{
  char *v1; // rax

  v1 = sub_2F240(*(_QWORD *)(a1 + 32));
  return sub_B51E0(v1);
}

char *__fastcall sub_B5280(char *filename)
{
  char *v1; // rbx
  int v2; // edi
  unsigned int v3; // ebp
  char *result; // rax
  char *v5; // rax
  int *v6; // rax
  char *v7; // rax
  __int64 v8; // [rsp+0h] [rbp-B8h]
  int v9; // [rsp+18h] [rbp-A0h]
  unsigned int v10; // [rsp+1Ch] [rbp-9Ch]
  unsigned __int64 v11; // [rsp+98h] [rbp-20h]

  v1 = filename;
  v11 = __readfsqword(0x28u);
  if ( mkdir(filename, 0x1C0u) < 0 && (v2 = *__errno_location(), v2 != 17) )
  {
    v5 = strerror(v2);
    result = sub_BC360((__int64)"%s: mkdir: %s", v1, v5);
  }
  else if ( __xstat(1, v1, (struct stat *)&v8) < 0 )
  {
    v6 = __errno_location();
    v7 = strerror(*v6);
    result = sub_BC360((__int64)"%s: stat: %s", v1, v7);
  }
  else
  {
    v3 = v10;
    if ( v3 == getuid() )
    {
      if ( v9 & 0x3F )
        result = sub_BC360((__int64)"%s: directory has overgenerous permissions %03o (expected 700)", v1, v9 & 0x1FF);
      else
        result = 0LL;
    }
    else
    {
      result = sub_BC360((__int64)"%s: directory owned by uid %d, not by us", v1, v10);
    }
  }
  return result;
}

char *__fastcall sub_B53A0(__int64 a1, __mode_t a2)
{
  __int64 v2; // rbp
  int i; // ebx
  const char *v4; // rdi
  unsigned int v5; // ebx
  char *v6; // r14
  int v7; // edi
  char *v9; // rax
  char *v10; // ST08_8

  v2 = a1;
  for ( i = 0; ; i = strspn(v4, "/") + v5 )
  {
    v5 = strcspn((const char *)(v2 + i), "/") + i;
    if ( (signed int)v5 <= 0 )
    {
      v4 = (const char *)(v2 + (signed int)v5);
      if ( !*v4 )
        return 0LL;
      continue;
    }
    v6 = sub_BC360((__int64)"%.*s", v5, v2);
    if ( mkdir(v6, a2) < 0 )
    {
      v7 = *__errno_location();
      if ( v7 != 17 )
        break;
    }
    sub_2F4D0(v6);
    v4 = (const char *)(v2 + (signed int)v5);
    if ( !*v4 )
      return 0LL;
  }
  v9 = strerror(v7);
  v10 = sub_BC360((__int64)"%s: mkdir: %s", v6, v9);
  sub_2F4D0(v6);
  return v10;
}

__int64 __fastcall sub_B5480(const char **a1)
{
  const char *v1; // rsi
  int v2; // eax
  unsigned int v3; // ecx
  __int64 v5; // [rsp+0h] [rbp-A8h]
  int v6; // [rsp+18h] [rbp-90h]
  __int64 v7; // [rsp+30h] [rbp-78h]
  unsigned __int64 v8; // [rsp+98h] [rbp-10h]

  v1 = *a1;
  v8 = __readfsqword(0x28u);
  v2 = __xstat(1, v1, (struct stat *)&v5);
  v3 = 0;
  if ( v2 >= 0 && (v6 & 0xF000) == 0x8000 )
    LOBYTE(v3) = v7 > 0;
  return v3;
}

signed __int64 __fastcall sub_B54F0(unsigned __int64 a1, unsigned __int64 a2)
{
  int v2; // eax
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 8);
  v5 = __OFSUB__(*(_DWORD *)(a1 + 8), v2);
  v3 = *(_DWORD *)(a1 + 8) == v2;
  v4 = *(_DWORD *)(a1 + 8) - v2 < 0;
  if ( *(_DWORD *)(a1 + 8) < v2 )
    goto LABEL_8;
  result = 1LL;
  if ( !((unsigned __int8)(v4 ^ v5) | v3) )
    return result;
  if ( a1 < a2 )
LABEL_8:
    result = 0xFFFFFFFFLL;
  else
    result = a1 > a2;
  return result;
}

signed __int64 __fastcall sub_B5520(_DWORD *a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 8);
  if ( *a1 < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > v2;
  return result;
}

__int64 __fastcall sub_B5540(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 - 128);
  if ( a2 )
    *(_QWORD *)(a1 - 128) = a2;
  return result;
}

__int64 __fastcall sub_B5550(__int64 a1)
{
  return *(_QWORD *)(a1 - 144);
}

__m128i *__fastcall sub_B5560(__int64 a1)
{
  __int64 v1; // rbp
  int v2; // edi
  __m128i *v3; // rbx
  int v4; // edi
  __m128i *v6; // rdi
  struct in_addr v7; // edi
  __int32 v8; // eax
  char *v9; // rax
  char *v10; // rax
  __int64 v11; // rdx
  struct passwd *v12; // r13
  struct group *v13; // rax
  char *v14; // rcx
  char *v15; // rdx
  __int16 v16; // ax
  char *v17; // rax
  char *v18; // rax
  __int64 v19; // rdx
  int v20; // [rsp+0h] [rbp-148h]
  unsigned int v21; // [rsp+4h] [rbp-144h]
  __uid_t uid; // [rsp+8h] [rbp-140h]
  __gid_t gid; // [rsp+Ch] [rbp-13Ch]
  struct sockaddr addr; // [rsp+10h] [rbp-138h]
  char v25; // [rsp+90h] [rbp-B8h]
  char buf; // [rsp+D0h] [rbp-78h]
  unsigned __int64 v27; // [rsp+118h] [rbp-30h]

  v1 = a1;
  v2 = *(_DWORD *)(a1 - 136);
  v20 = 128;
  v27 = __readfsqword(0x28u);
  if ( getpeername(v2, &addr, (socklen_t *)&v20) < 0 )
    return 0LL;
  v3 = (__m128i *)sub_2F450(1uLL, 0x30uLL, 0LL);
  LODWORD(v3->m128i_i64[0]) = 0;
  v3->m128i_i64[1] = 0LL;
  v3[2].m128i_i32[0] = -1;
  v3[2].m128i_i64[1] = 0LL;
  switch ( addr.sa_family )
  {
    case 2u:
      LODWORD(v3->m128i_i64[0]) = 1;
      v7.s_addr = *(_DWORD *)&addr.sa_data[2];
      v8 = (unsigned __int16)__ROR2__(*(_WORD *)addr.sa_data, 8);
      v3[1].m128i_i32[0] = *(_DWORD *)&addr.sa_data[2];
      v3[2].m128i_i32[0] = v8;
      v9 = inet_ntoa(v7);
      v10 = sub_BC120(v9);
      v11 = v3[2].m128i_u32[0];
      v3->m128i_i64[1] = (__int64)v10;
      v3[2].m128i_i64[1] = (__int64)sub_BC360((__int64)"%s:%d", v10, v11);
      break;
    case 0xAu:
      LODWORD(v3->m128i_i64[0]) = 2;
      v16 = *(_WORD *)addr.sa_data;
      v3[1] = _mm_loadu_si128((const __m128i *)&addr.sa_data[6]);
      v3[2].m128i_i32[0] = (unsigned __int16)__ROR2__(v16, 8);
      v17 = (char *)inet_ntop(10, &addr.sa_data[6], &buf, 0x2Eu);
      v18 = sub_BC120(v17);
      v19 = v3[2].m128i_u32[0];
      v3->m128i_i64[1] = (__int64)v18;
      v3[2].m128i_i64[1] = (__int64)sub_BC360((__int64)"[%s]:%d", v18, v19);
      break;
    case 1u:
      v4 = *(_DWORD *)(v1 - 136);
      LODWORD(v3->m128i_i64[0]) = 3;
      if ( (unsigned __int8)sub_B7D10(v4, &v21, &uid, &gid) )
      {
        __sprintf_chk(&v25, 1LL, 64LL, "%d", uid);
        __sprintf_chk(&buf, 1LL, 64LL, "%d", gid);
        v12 = getpwuid(uid);
        v13 = getgrgid(gid);
        v14 = &buf;
        if ( v13 )
          v14 = v13->gr_name;
        v15 = &v25;
        if ( v12 )
          v15 = v12->pw_name;
        v3[2].m128i_i64[1] = (__int64)sub_BC360((__int64)"pid %d (%s:%s)", v21, v15, v14);
      }
      break;
    default:
      v6 = v3;
      v3 = 0LL;
      sub_2F4D0(v6);
      break;
  }
  return v3;
}

void __fastcall sub_B57C0(__int64 a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 92);
  if ( v1 )
  {
    v1 = 0;
  }
  else if ( *(_BYTE *)(a1 + 96) )
  {
    v1 = 1;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 64) )
    {
      if ( !*(_BYTE *)(a1 + 66) && !*(_BYTE *)(a1 + 88) )
        v1 = 5;
    }
    else
    {
      v1 = 2;
    }
    if ( sub_BCD00(a1 + 24) )
      v1 |= 2u;
  }
  sub_B8750(*(_DWORD *)(a1 + 8), v1, (__int64)sub_B6B60);
}

void __fastcall sub_B5840(__int64 a1, char a2)
{
  if ( *(_BYTE *)(a1 - 78) != a2 )
  {
    *(_BYTE *)(a1 - 78) = a2;
    sub_B57C0(a1 - 144);
  }
}

__int64 __fastcall sub_B5870(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // ebp
  char *v3; // rax

  result = sub_9B3D0((__int64 *)qword_326500, a1, 0LL);
  if ( result )
  {
    v2 = *(_DWORD *)(a1 + 92);
    if ( v2 )
    {
      v3 = strerror(v2);
      result = (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 8LL))(
                 *(_QWORD *)(a1 + 16),
                 v3,
                 v2,
                 0LL);
    }
  }
  return result;
}

signed __int64 __fastcall sub_B58D0(int a1, __int64 a2)
{
  _QWORD *v2; // rbx
  int *v4; // rax

  v2 = sub_2F450(1uLL, 0x98uLL, 0LL);
  *v2 = 0LL;
  v2[2] = a2;
  v2[18] = off_322900;
  sub_BCC70(v2 + 3);
  *((_BYTE *)v2 + 65) = 1;
  v2[9] = 0LL;
  *((_BYTE *)v2 + 66) = 1;
  *((_BYTE *)v2 + 67) = 0;
  *((_DWORD *)v2 + 23) = 0;
  *((_BYTE *)v2 + 80) = 0;
  *((_DWORD *)v2 + 21) = 0;
  *((_BYTE *)v2 + 88) = 0;
  *((_BYTE *)v2 + 96) = 0;
  v2[17] = 0LL;
  v2[16] = 0LL;
  v2[13] = 0LL;
  *((_BYTE *)v2 + 64) = 1;
  *((_DWORD *)v2 + 2) = a1;
  if ( a1 < 0 )
  {
    v4 = __errno_location();
    *v2 = strerror(*v4);
  }
  else
  {
    *((_BYTE *)v2 + 81) = 0;
    sub_B57C0((__int64)v2);
    sub_9AFD0((__int64 *)qword_326500, (__int64)v2);
  }
  return (signed __int64)(v2 + 18);
}

int *__fastcall sub_B59B0(int *a1, __int64 a2, __int64 *a3)
{
  int *result; // rax
  bool v4; // zf
  __int64 v5; // rcx
  int v6; // [rsp+0h] [rbp-238h]
  __int64 v7; // [rsp+18h] [rbp-220h]
  unsigned __int64 v8; // [rsp+228h] [rbp-10h]

  result = a1;
  v8 = __readfsqword(0x28u);
  v4 = *(_DWORD *)(a2 + 16) == 2;
  qmemcpy(&v6, (const void *)a2, 0x220uLL);
  v5 = *(_QWORD *)(a2 + 24);
  if ( v4 )
    v5 = *a3;
  v7 = v5;
  v6 = 1;
  qmemcpy(a1, &v6, 0x220uLL);
  return result;
}

bool __fastcall sub_B5A30(__int16 *a1)
{
  __int16 v1; // ax
  bool result; // al

  v1 = *a1;
  if ( *a1 == 2 )
    return *((_BYTE *)a1 + 4) == 127;
  if ( v1 != 10 )
    return v1 == 1;
  result = 0;
  if ( !*((_DWORD *)a1 + 2) && !*((_DWORD *)a1 + 3) && !*((_DWORD *)a1 + 4) )
    result = *((_DWORD *)a1 + 5) == 0x1000000;
  return result;
}

__int64 __fastcall sub_B5A90(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // edi
  int v3; // eax
  __int64 v4; // rax
  int v5; // er12
  int v6; // eax
  int v7; // er13
  unsigned int v8; // er14
  __int64 result; // rax
  char *v10; // rax
  __int16 v11; // bp
  int v12; // eax
  __int64 v13; // rdx
  __int16 *v14; // r14
  socklen_t v15; // ebp
  __int64 v16; // rsi
  const char *v17; // rbp
  size_t v18; // rax
  const char *v19; // rsi
  __int64 *v20; // [rsp+8h] [rbp-300h]
  int optval; // [rsp+1Ch] [rbp-2ECh]
  __int16 v22; // [rsp+20h] [rbp-2E8h]
  char v23[6]; // [rsp+22h] [rbp-2E6h]
  __m128i v24; // [rsp+28h] [rbp-2E0h]
  int v25[138]; // [rsp+A0h] [rbp-268h]
  unsigned __int64 v26; // [rsp+2C8h] [rbp-40h]

  v1 = a1;
  v26 = __readfsqword(0x28u);
  sub_9B440((__int64 *)qword_326500, a1);
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 >= 0 )
    close(v2);
  v20 = (__int64 *)(v1 + 112);
  sub_B59B0(v25, *(_QWORD *)(v1 + 104), (__int64 *)(v1 + 112));
  (***(void (__fastcall ****)(_QWORD, _QWORD, int *, _QWORD, _QWORD, _QWORD))(v1 + 16))(
    *(_QWORD *)(v1 + 16),
    0LL,
    v25,
    *(unsigned int *)(v1 + 100),
    0LL,
    0LL);
  v3 = *(_DWORD *)(*(_QWORD *)(v1 + 104) + 16LL);
  if ( !v3 )
    goto LABEL_47;
  if ( v3 == 1 )
  {
    v5 = 1;
  }
  else
  {
    v4 = *(_QWORD *)(v1 + 112);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 4);
      if ( v5 )
        goto LABEL_7;
LABEL_47:
      __assert_fail("family != AF_UNSPEC", "unix/uxnet.c", 0x24Fu, "try_connect");
    }
    v5 = 2;
  }
LABEL_7:
  v6 = socket(v5, 1, 0);
  v7 = v6;
  *(_DWORD *)(v1 + 8) = v6;
  if ( v6 < 0 )
  {
    v8 = *__errno_location();
    goto LABEL_9;
  }
  sub_B4F50(v6);
  if ( *(_BYTE *)(v1 + 81) && (optval = 1, setsockopt(v7, 1, 10, &optval, 4u) < 0)
    || *(_BYTE *)(v1 + 97) && v5 != 1 && (optval = 1, setsockopt(v7, 6, 1, &optval, 4u) < 0)
    || *(_BYTE *)(v1 + 98) && (optval = 1, setsockopt(v7, 1, 9, &optval, 4u) < 0) )
  {
    v8 = *__errno_location();
    close(v7);
    goto LABEL_9;
  }
  v11 = *(_BYTE *)(v1 + 99) >= 1u ? 0x3FF : 0;
  memset(&v22, 0, 0x80uLL);
  if ( v5 != 1 )
  {
    while ( 1 )
    {
      if ( v5 == 10 )
      {
        v22 = 10;
        v24 = _mm_loadu_si128((const __m128i *)&in6addr_any);
        *(_WORD *)v23 = __ROR2__(v11, 8);
        v12 = bind(v7, (const struct sockaddr *)&v22, 0x1Cu);
      }
      else
      {
        if ( v5 != 2 )
          __assert_fail("family == AF_INET", "unix/uxnet.c", 0x294u, "try_connect");
        v22 = 2;
        *(_DWORD *)&v23[2] = 0;
        *(_DWORD *)v23 = (unsigned __int16)__ROR2__(v11, 8);
        v12 = bind(v7, (const struct sockaddr *)&v22, 0x10u);
      }
      if ( v12 >= 0 )
        goto LABEL_37;
      v8 = *__errno_location();
      if ( v8 != 98 )
        break;
      if ( v11 )
      {
        if ( --v11 )
          continue;
      }
      goto LABEL_13;
    }
    if ( v8 )
    {
LABEL_13:
      sub_9AFD0((__int64 *)qword_326500, v1);
LABEL_14:
      sub_B59B0(v25, *(_QWORD *)(v1 + 104), v20);
      v10 = strerror(v8);
      (***(void (__fastcall ****)(_QWORD, signed __int64, int *, _QWORD, char *, _QWORD))(v1 + 16))(
        *(_QWORD *)(v1 + 16),
        1LL,
        v25,
        *(unsigned int *)(v1 + 100),
        v10,
        v8);
      goto LABEL_10;
    }
LABEL_37:
    if ( v5 == 2 || v5 == 10 )
    {
      v13 = *(_QWORD *)(v1 + 112);
      v14 = *(__int16 **)(v13 + 24);
      v15 = *(_DWORD *)(v13 + 16);
      v14[1] = __ROR2__(*(_WORD *)(v1 + 100), 8);
      goto LABEL_40;
    }
    if ( v5 != 1 )
      __assert_fail("false && \"unknown address family\"", "unix/uxnet.c", 0x2D2u, "try_connect");
  }
  v17 = (const char *)(*(_QWORD *)(v1 + 104) + 32LL);
  v18 = strlen(v17);
  if ( v18 > 0x6B )
LABEL_48:
    __assert_fail("strlen(sock->addr->hostname) < sizeof u.su.sun_path", "unix/uxnet.c", 0x2CAu, "try_connect");
  v14 = &v22;
  v19 = v17;
  v22 = 1;
  v15 = 110;
  __memcpy_chk(v23, v19, v18 + 1, 108LL);
LABEL_40:
  sub_B5050(v7);
  if ( connect(v7, (const struct sockaddr *)v14, v15) >= 0 )
  {
    v16 = *(_QWORD *)(v1 + 104);
    *(_BYTE *)(v1 + 64) = 1;
    *(_BYTE *)(v1 + 65) = 1;
    sub_B59B0(v25, v16, v20);
    (***(void (__fastcall ****)(_QWORD, signed __int64, int *, _QWORD, _QWORD, _QWORD))(v1 + 16))(
      *(_QWORD *)(v1 + 16),
      2LL,
      v25,
      *(unsigned int *)(v1 + 100),
      0LL,
      0LL);
  }
  else
  {
    v8 = *__errno_location();
    if ( v8 != 115 )
    {
LABEL_9:
      sub_9AFD0((__int64 *)qword_326500, v1);
      if ( !v8 )
        goto LABEL_10;
      goto LABEL_14;
    }
  }
  v8 = 0;
  sub_B57C0(v1);
  sub_9AFD0((__int64 *)qword_326500, v1);
LABEL_10:
  result = v8;
  if ( __readfsqword(0x28u) != v26 )
    goto LABEL_48;
  return result;
}

void __fastcall sub_B5F60(struct addrinfo **a1)
{
  struct addrinfo **v1; // rbx
  struct addrinfo *v2; // rdi

  v1 = a1;
  v2 = a1[3];
  if ( v2 )
    freeaddrinfo(v2);
  sub_2F4D0(v1);
}

void __fastcall sub_B5F80(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rdi
  int v4; // edi
  struct addrinfo **v5; // rdi
  int v6; // eax
  bool v7; // zf

  v1 = (void *)(a1 - 144);
  v2 = a1;
  v3 = *(_QWORD *)(a1 - 8);
  if ( v3 )
    sub_B5F80(v3 + 144);
  sub_BCCA0((__int64)v1 + 24);
  sub_9B440((__int64 *)qword_326500, (__int64)v1);
  v4 = *(_DWORD *)(v2 - 136);
  if ( v4 >= 0 )
  {
    sub_B86F0(v4);
    close(*(_DWORD *)(v2 - 136));
  }
  v5 = *(struct addrinfo ***)(v2 - 40);
  if ( v5 )
  {
    v6 = *(_DWORD *)v5 - 1;
    v7 = *(_DWORD *)v5 == 1;
    *(_DWORD *)v5 = v6;
    if ( v6 < 0 || v7 )
      sub_B5F60(v5);
  }
  sub_1BCD0((__int64)v1);
  sub_2F4D0(v1);
}

_QWORD *sub_B6020()
{
  _QWORD *result; // rax

  result = sub_9AF60((__int64)sub_B54F0);
  qword_326500 = (__int64)result;
  return result;
}

void sub_B6040()
{
  __int64 *v0; // rdi
  signed int v1; // ebx
  __int64 v2; // rax

  v0 = (__int64 *)qword_326500;
  if ( qword_326500 )
  {
    v1 = 0;
    while ( 1 )
    {
      v2 = sub_9B010(v0, v1);
      if ( !v2 )
        break;
      ++v1;
      close(*(_DWORD *)(v2 + 8));
      v0 = (__int64 *)qword_326500;
    }
  }
}

__int64 __fastcall sub_B6090(char *src)
{
  void *v1; // rax
  __int64 v2; // rbx
  __int64 result; // rax

  v1 = sub_2F450(1uLL, 0x220uLL, 0LL);
  v2 = (__int64)v1;
  *((_QWORD *)v1 + 1) = 0LL;
  *((_DWORD *)v1 + 4) = 0;
  strncpy((char *)v1 + 32, src, 0x200uLL);
  *(_BYTE *)(v2 + 543) = 0;
  *(_QWORD *)(v2 + 24) = 0LL;
  result = v2;
  *(_DWORD *)v2 = 1;
  return result;
}

int __fastcall sub_B60F0(__int64 a1, char *a2, signed int a3)
{
  __int64 v3; // rbx
  int result; // eax

  v3 = a3;
  if ( *(_DWORD *)(a1 + 16) <= 1u )
  {
    result = (unsigned __int64)strncpy(a2, (const char *)(a1 + 32), a3);
    a2[v3 - 1] = 0;
  }
  else
  {
    result = getnameinfo(
               *(const struct sockaddr **)(*(_QWORD *)(a1 + 24) + 24LL),
               *(_DWORD *)(*(_QWORD *)(a1 + 24) + 16LL),
               a2,
               a3,
               0LL,
               0,
               1);
    if ( result )
    {
      *a2 = 0;
      result = (unsigned __int64)strncat(a2, "<unknown>", (signed int)v3 - 1);
    }
  }
  return result;
}

bool __fastcall sub_B6170(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) > 1u;
}

bool __usercall sub_B6180@<al>(bool a1@<cf>, bool a2@<zf>, _BYTE *a3@<rdi>)
{
  _BYTE *v3; // r8
  const char *v4; // rdi
  signed __int64 v5; // rcx
  _BYTE *v6; // rsi
  bool result; // al
  char v8; // dl
  bool v9; // cf
  bool v10; // zf
  const char *v11; // rdi
  signed __int64 v12; // rcx
  _BYTE *v13; // rsi
  char v14; // dl
  bool v15; // cf
  bool v16; // zf
  const char *v17; // rdi
  signed __int64 v18; // rcx
  _BYTE *v19; // rsi

  v3 = a3;
  v4 = "localhost";
  v5 = 10LL;
  v6 = v3;
  result = 1;
  do
  {
    if ( !v5 )
      break;
    a1 = *v6 < (const unsigned __int8)*v4;
    a2 = *v6++ == *v4++;
    --v5;
  }
  while ( a2 );
  v8 = (!a1 && !a2) - a1;
  v9 = 0;
  v10 = v8 == 0;
  if ( v8 )
  {
    v11 = "::1";
    v12 = 4LL;
    v13 = v3;
    do
    {
      if ( !v12 )
        break;
      v9 = *v13 < (const unsigned __int8)*v11;
      v10 = *v13++ == *v11++;
      --v12;
    }
    while ( v10 );
    v14 = (!v9 && !v10) - v9;
    v15 = 0;
    v16 = v14 == 0;
    if ( v14 )
    {
      v17 = "127.";
      v18 = 4LL;
      v19 = v3;
      do
      {
        if ( !v18 )
          break;
        v15 = *v19 < (const unsigned __int8)*v17;
        v16 = *v19++ == *v17++;
        --v18;
      }
      while ( v16 );
      result = (!v15 && !v16) == v15;
    }
  }
  return result;
}

bool __fastcall sub_B61E0(__int64 a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( !v1 )
    return 0;
  if ( v1 == 1 )
    return 1;
  return sub_B5A30(*(__int16 **)(*(_QWORD *)(a1 + 24) + 24LL));
}

bool __fastcall sub_B6210(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) == 1;
}

signed __int64 __fastcall sub_B6220(__int64 a1)
{
  signed __int64 result; // rax
  __int64 v2; // rdx
  int v3; // edx

  result = 4LL;
  if ( *(_DWORD *)(a1 + 16) > 1u )
  {
    v2 = *(_QWORD *)(a1 + 24);
    result = 1LL;
    if ( v2 )
    {
      v3 = *(_DWORD *)(v2 + 4);
      if ( v3 != 2 )
        result = 2 * (unsigned int)(v3 != 10) + 2;
    }
  }
  return result;
}

__int64 __fastcall sub_B6260(__int64 a1, __m128i *a2)
{
  __int64 v2; // rax
  int v3; // edx
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 16) <= 1u )
LABEL_2:
    __assert_fail("false && \"bad address family in sk_addrcopy\"", "unix/uxnet.c", 0x1CEu, "sk_addrcopy");
  v2 = *(_QWORD *)(a1 + 24);
  if ( v2 && (v3 = *(_DWORD *)(v2 + 4), v3 != 2) )
  {
    if ( v3 != 10 )
      goto LABEL_2;
    result = *(_QWORD *)(v2 + 24);
    *a2 = _mm_loadu_si128((const __m128i *)(result + 8));
  }
  else
  {
    result = *(unsigned int *)(*(_QWORD *)(v2 + 24) + 4LL);
    LODWORD(a2->m128i_i64[0]) = result;
  }
  return result;
}

void __fastcall sub_B62D0(struct addrinfo **a1)
{
  int v1; // eax
  bool v2; // zf

  v1 = *(_DWORD *)a1 - 1;
  v2 = *(_DWORD *)a1 == 1;
  *(_DWORD *)a1 = v1;
  if ( v1 < 0 || v2 )
    sub_B5F60(a1);
}

_DWORD *__fastcall sub_B62F0(_DWORD *a1)
{
  _DWORD *result; // rax

  result = a1;
  ++*a1;
  return result;
}

char *__fastcall sub_B6300(__int64 a1, int a2, char a3, char a4, char a5, char a6, __int64 a7)
{
  char v7; // r15
  char v8; // r13
  char v9; // r14
  char v10; // ST0C_1
  _QWORD *v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rdx
  int v15; // eax

  v7 = a5;
  v8 = a3;
  v9 = a6;
  v10 = a4;
  v11 = sub_2F450(1uLL, 0x98uLL, 0LL);
  *v11 = 0LL;
  v11[18] = off_322900;
  v11[2] = a7;
  sub_BCC70(v11 + 3);
  v12 = *(_QWORD *)(a1 + 24);
  *((_BYTE *)v11 + 64) = 0;
  *((_BYTE *)v11 + 65) = 0;
  v11[9] = 0LL;
  *((_BYTE *)v11 + 66) = 0;
  *((_BYTE *)v11 + 67) = 0;
  *((_DWORD *)v11 + 23) = 0;
  v11[17] = 0LL;
  v11[16] = 0LL;
  *((_BYTE *)v11 + 80) = 0;
  *((_DWORD *)v11 + 21) = 0;
  *((_BYTE *)v11 + 88) = 0;
  *((_BYTE *)v11 + 96) = 0;
  v11[13] = a1;
  v11[14] = v12;
  *((_DWORD *)v11 + 30) = 0;
  *((_DWORD *)v11 + 2) = -1;
  *((_BYTE *)v11 + 81) = v10;
  *((_BYTE *)v11 + 97) = v7;
  *((_BYTE *)v11 + 98) = v9;
  *((_BYTE *)v11 + 99) = v8;
  *((_DWORD *)v11 + 25) = a2;
  while ( 1 )
  {
    v15 = sub_B5A90((__int64)v11);
    if ( !v15 )
      break;
    v13 = v11[14];
    if ( !v13 || (v14 = *(_QWORD *)(v13 + 40)) == 0 )
    {
      *v11 = strerror(v15);
      return (char *)(v11 + 18);
    }
    v11[14] = v14;
  }
  return (char *)(v11 + 18);
}

char *__fastcall sub_B6430(char *a1, unsigned int a2, __int64 a3, unsigned __int8 a4, int a5)
{
  __int64 v5; // r13
  unsigned __int8 v6; // bp
  int v7; // er12
  _QWORD *v8; // r14
  int v9; // ebx
  char *v10; // ST18_8
  int service; // ST10_4
  sockaddr *v12; // rsi
  socklen_t v13; // edx
  int v14; // eax
  int v15; // ST10_4
  signed __int64 v16; // rax
  signed __int64 v17; // rbp
  signed __int64 v18; // rax
  char *result; // rax
  int *v20; // rax
  int *v21; // rax
  struct sockaddr v22; // xmm0
  int v23; // [rsp+8h] [rbp-120h]
  unsigned int v24; // [rsp+Ch] [rbp-11Ch]
  int optval; // [rsp+24h] [rbp-104h]
  struct addrinfo *pai; // [rsp+28h] [rbp-100h]
  struct addrinfo req; // [rsp+30h] [rbp-F8h]
  struct sockaddr addr; // [rsp+60h] [rbp-C8h]
  char v29; // [rsp+E2h] [rbp-46h]
  unsigned __int64 v30; // [rsp+E8h] [rbp-40h]

  v5 = a3;
  v6 = a4;
  v7 = a5;
  v24 = a2;
  pai = 0LL;
  v30 = __readfsqword(0x28u);
  optval = 1;
  v8 = sub_2F450(1uLL, 0x98uLL, 0LL);
  *v8 = 0LL;
  v8[2] = v5;
  v8[18] = off_322900;
  sub_BCC70(v8 + 3);
  *((_BYTE *)v8 + 65) = 0;
  v8[9] = 0LL;
  *((_BYTE *)v8 + 66) = 0;
  *((_BYTE *)v8 + 67) = v6;
  *((_DWORD *)v8 + 23) = 0;
  v8[17] = 0LL;
  v8[16] = 0LL;
  *((_BYTE *)v8 + 80) = 0;
  *((_DWORD *)v8 + 21) = 0;
  *((_BYTE *)v8 + 88) = 0;
  *((_BYTE *)v8 + 96) = 1;
  v8[13] = 0LL;
  *((_DWORD *)v8 + 2) = -1;
  if ( v7 != 1 && (v9 = socket(10, 1, 0), v9 >= 0) )
  {
    v23 = 10;
  }
  else
  {
    v9 = socket(2, 1, 0);
    v23 = 2;
    if ( v9 < 0 )
    {
LABEL_22:
      v20 = __errno_location();
      *v8 = strerror(*v20);
      result = (char *)(v8 + 18);
      goto LABEL_23;
    }
  }
  sub_B4F50(v9);
  *((_BYTE *)v8 + 81) = 0;
  if ( setsockopt(v9, 1, 2, &optval, 4u) < 0 )
  {
    v21 = __errno_location();
    *v8 = strerror(*v21);
    close(v9);
    result = (char *)(v8 + 18);
    goto LABEL_23;
  }
  if ( !a1 )
    goto LABEL_36;
  req.ai_flags = 4;
  *(_QWORD *)&req.ai_socktype = 1LL;
  req.ai_addrlen = 0;
  req.ai_addr = 0LL;
  req.ai_family = v23;
  req.ai_canonname = 0LL;
  req.ai_next = 0LL;
  if ( a2 > 0x1869F )
    goto LABEL_33;
  __sprintf_chk(&v29, 1LL, 6LL, "%d", a2);
  v10 = sub_BC440(a1);
  service = getaddrinfo(v10, &v29, &req, &pai);
  sub_2F4D0(v10);
  if ( !service )
  {
    v12 = pai->ai_addr;
    v13 = pai->ai_addrlen;
  }
  else
  {
LABEL_36:
    v12 = &addr;
    memset(&addr, 0, 0x80uLL);
    if ( v23 == 10 )
    {
      addr.sa_family = 10;
      *(_WORD *)addr.sa_data = __ROR2__(v24, 8);
      if ( v6 )
        v22 = (struct sockaddr)_mm_loadu_si128((const __m128i *)&in6addr_loopback);
      else
        v22 = (struct sockaddr)_mm_loadu_si128((const __m128i *)&in6addr_any);
      v13 = 28;
      *(struct sockaddr *)((char *)&addr + 8) = v22;
    }
    else
    {
      v13 = 16;
      addr.sa_family = 2;
      *(_WORD *)addr.sa_data = __ROR2__(v24, 8);
      if ( v6 )
      {
        *(_DWORD *)&addr.sa_data[2] = 16777343;
        v13 = 16;
      }
    }
  }
  v14 = bind(v9, v12, v13);
  if ( pai )
  {
    v15 = v14;
    freeaddrinfo(pai);
    v14 = v15;
  }
  if ( v14 < 0 || listen(v9, 128) < 0 )
  {
    close(v9);
    goto LABEL_22;
  }
  if ( v23 != 10 )
    goto LABEL_20;
  if ( v7 )
    goto LABEL_20;
  v16 = sub_B6430(a1, v24, v5, v6, 1);
  v17 = v16;
  v18 = v16 - 144;
  if ( !v18 )
    goto LABEL_20;
  if ( !*(_QWORD *)(v17 - 144) )
  {
    *(_QWORD *)(v17 - 16) = v8;
    v8[17] = v18;
LABEL_20:
    *((_DWORD *)v8 + 2) = v9;
    sub_B57C0((__int64)v8);
    sub_9AFD0((__int64 *)qword_326500, (__int64)v8);
    result = (char *)(v8 + 18);
    goto LABEL_23;
  }
  close(v9);
  sub_2F4D0(v8);
  result = (char *)v17;
LABEL_23:
  if ( __readfsqword(0x28u) != v30 )
LABEL_33:
    __assert_fail("port >= 0 && port <= 99999", "unix/uxnet.c", 0x38Au, "sk_newlistener");
  return result;
}

_BYTE *__fastcall sub_B6870(__int64 (__fastcall ***a1)(), _DWORD *a2)
{
  int v2; // edi
  _BYTE *v3; // rbx
  unsigned __int32 v5; // eax
  __int16 v6; // ax
  int v7; // eax
  int v8; // edx
  __int16 v9; // ax
  socklen_t len; // [rsp+Ch] [rbp-9Ch]
  struct sockaddr addr; // [rsp+10h] [rbp-98h]
  int v12; // [rsp+20h] [rbp-88h]
  int v13; // [rsp+24h] [rbp-84h]
  unsigned __int64 v14; // [rsp+98h] [rbp-10h]

  v14 = __readfsqword(0x28u);
  if ( *a1 == off_322900 )
  {
    v2 = *((_DWORD *)a1 - 34);
    len = 128;
    if ( getsockname(v2, &addr, &len) >= 0 )
    {
      switch ( addr.sa_family )
      {
        case 2u:
          *a2 = 6;
          v3 = sub_2F450(6uLL, 1uLL, 0LL);
          v5 = _byteswap_ulong(*(unsigned int *)&addr.sa_data[2]);
          v3[3] = v5;
          v3[2] = BYTE1(v5);
          v3[1] = BYTE2(v5);
          *v3 = HIBYTE(v5);
          break;
        case 0xAu:
          *a2 = 6;
          v3 = sub_2F450(6uLL, 1uLL, 0LL);
          if ( *(_DWORD *)&addr.sa_data[6] || *(_DWORD *)&addr.sa_data[10] || v12 != -65536 )
          {
            *(_DWORD *)v3 = 0;
            *((_WORD *)v3 + 2) = 0;
            return v3;
          }
          *(_DWORD *)v3 = v13;
          break;
        case 1u:
          *a2 = 6;
          v3 = sub_2F450(6uLL, 1uLL, 0LL);
          v7 = dword_3260D0;
          v8 = dword_3260D0 - 1;
          v3[3] = dword_3260D0;
          v3[2] = BYTE1(v7);
          dword_3260D0 = v8;
          *v3 = HIBYTE(v7);
          v3[1] = BYTE2(v7);
          v9 = getpid();
          v3[5] = v9;
          v3[4] = HIBYTE(v9);
          return v3;
        default:
          return 0LL;
      }
      v6 = __ROR2__(*(_WORD *)addr.sa_data, 8);
      v3[5] = __ROR2__(*(_WORD *)addr.sa_data, 8);
      v3[4] = HIBYTE(v6);
      return v3;
    }
  }
  return 0LL;
}

void __fastcall sub_B6A00(__int64 a1)
{
  __int64 v1; // r14
  size_t v2; // rbx
  const void *v3; // rsi
  int v4; // ecx
  __int64 v5; // rax
  unsigned __int64 v6; // r13
  int v7; // er12
  int v8; // er15
  __int64 v9; // rax
  size_t v10; // rdx

  v1 = a1 + 24;
  v2 = *(_QWORD *)(a1 + 72);
LABEL_2:
  if ( v2 )
  {
LABEL_3:
    v3 = (const void *)(a1 + 68);
    v4 = 1;
    goto LABEL_4;
  }
  while ( 1 )
  {
    if ( !sub_BCD00(v1) )
    {
      if ( *(_DWORD *)(a1 + 84) == 1 )
      {
        shutdown(*(_DWORD *)(a1 + 8), 1);
        *(_DWORD *)(a1 + 84) = 2;
      }
      sub_B57C0(a1);
      return;
    }
    v2 = *(_QWORD *)(a1 + 72);
    if ( v2 )
      goto LABEL_3;
    v9 = sub_BCF00(v1);
    v4 = 0;
    v3 = (const void *)v9;
    v2 = v10;
LABEL_4:
    v5 = send(*(_DWORD *)(a1 + 8), v3, v2, v4);
    v6 = (signed int)v5;
    v7 = v5;
    v8 = v5;
    sub_B7C30(2u, (signed int)v5, v5, (signed int)v5, v1, (unsigned int)v5);
    if ( v7 <= 0 )
      break;
    if ( !*(_QWORD *)(a1 + 72) )
    {
      sub_BCE20(v1, v6);
      v2 = *(_QWORD *)(a1 + 72);
      goto LABEL_2;
    }
    if ( v6 < v2 )
    {
      v2 -= v6;
      memmove((void *)(a1 + 68), (const void *)(a1 + 68 + v6), v2);
      *(_QWORD *)(a1 + 72) = v2;
      goto LABEL_2;
    }
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  if ( v7 && (v8 = *__errno_location(), v8 == 11) )
  {
    *(_BYTE *)(a1 + 65) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = v8;
    sub_B57C0(a1);
    sub_1BD80((__int64)sub_B5870, a1);
  }
}

unsigned __int64 __usercall sub_B6B60@<rax>(int a1@<edi>, int a2@<esi>, __int64 a3@<rdx>, __int64 a4@<rcx>, __int64 a5@<r8>, __int64 a6@<r9>, __int64 r12_0@<r12>, __int64 r13_0@<r13>, __int64 r14_0@<r14>, __int64 r15_0@<r15>)
{
  __int64 v10; // rax
  __int64 v11; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v13; // rt1
  __int64 v14; // rsi
  struct addrinfo **v15; // rdi
  int v16; // eax
  bool v17; // zf
  char v18; // bp
  char v19; // r12
  __int64 v20; // rdi
  signed __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // r14
  int v24; // er13
  struct addrinfo **v25; // rdi
  int v26; // eax
  __int64 v27; // r12
  unsigned __int64 v28; // r12
  __int64 v29; // rbp
  char *v30; // rax
  char *v31; // r12
  unsigned int v32; // ebp
  __int64 v33; // rax
  __int64 v34; // rax
  char *v35; // rax
  int v36; // eax
  __int64 v37; // r13
  int v38; // ebp
  struct addrinfo **v39; // rdi
  int v40; // eax
  int v41; // eax
  unsigned int v42; // er12
  __int64 v43; // rax
  int *v44; // rax
  __int64 v45; // rdx
  const char *v46; // rsi
  int *v47; // rax
  unsigned int *v48; // rbp
  char *v49; // rax
  unsigned int v50; // ST0C_4
  char *v51; // rax
  char v52; // [rsp+10h] [rbp-5498h]
  int v53; // [rsp+23Ch] [rbp-526Ch]
  unsigned int optval; // [rsp+248h] [rbp-5260h]
  socklen_t optlen; // [rsp+24Ch] [rbp-525Ch]
  struct sockaddr addr; // [rsp+250h] [rbp-5258h]
  char buf; // [rsp+470h] [rbp-5038h]
  unsigned __int64 v58; // [rsp+5478h] [rbp-30h]

  v53 = a1;
  v58 = __readfsqword(0x28u);
  v10 = sub_9B3D0((__int64 *)qword_326500, (__int64)&v53, (__int64 (__fastcall *)(__int64))sub_B5520);
  if ( !v10 )
    goto LABEL_5;
  v11 = v10;
  sub_B7C30(1u, v53, r12_0, r13_0, r14_0, r15_0);
  switch ( a2 )
  {
    case 2:
      if ( *(_BYTE *)(v11 + 64) )
      {
        v27 = *(_QWORD *)(v11 + 72);
        *(_BYTE *)(v11 + 65) = 1;
        v28 = sub_BCD00(v11 + 24) + v27;
        sub_B6A00(v11);
        v29 = *(_QWORD *)(v11 + 72);
        if ( v28 > v29 + sub_BCD00(v11 + 24) )
          (*(void (**)(void))(**(_QWORD **)(v11 + 16) + 24LL))();
        break;
      }
      optlen = 4;
      if ( getsockopt(*(_DWORD *)(v11 + 8), 1, 4, &optval, &optlen) < 0 )
      {
        v47 = __errno_location();
        v48 = (unsigned int *)v47;
        v49 = strerror(*v47);
        v31 = sub_BC360((__int64)"getsockopt(SO_ERROR): %s", v49);
        optval = *v48;
      }
      else
      {
        if ( !optval )
        {
          v14 = *(_QWORD *)(v11 + 104);
          goto LABEL_11;
        }
        v30 = strerror(optval);
        v31 = sub_BC120(v30);
      }
      v14 = *(_QWORD *)(v11 + 104);
      if ( v31 )
      {
        if ( !v14 )
LABEL_73:
          __assert_fail("s->addr", "unix/uxnet.c", 0x597u, "net_select_result");
        sub_B59B0((int *)&v52, v14, (__int64 *)(v11 + 112));
        qmemcpy(&addr, &v52, 0x220uLL);
        (***(void (__fastcall ****)(_QWORD, signed __int64, struct sockaddr *, _QWORD, char *, _QWORD))(v11 + 16))(
          *(_QWORD *)(v11 + 16),
          1LL,
          &addr,
          *(unsigned int *)(v11 + 100),
          v31,
          optval);
        v32 = optval;
        if ( optval )
        {
          while ( *(_QWORD *)(v11 + 104) )
          {
            v33 = *(_QWORD *)(v11 + 112);
            if ( !v33 )
              break;
            v34 = *(_QWORD *)(v33 + 40);
            if ( !v34 )
              break;
            *(_QWORD *)(v11 + 112) = v34;
            v32 = sub_B5A90(v11);
            optval = v32;
            if ( !v32 )
              goto LABEL_63;
          }
          goto LABEL_41;
        }
LABEL_63:
        if ( !*(_BYTE *)(v11 + 64) )
          break;
        goto LABEL_12;
      }
LABEL_11:
      sub_B59B0((int *)&addr, v14, (__int64 *)(v11 + 112));
      (***(void (__fastcall ****)(_QWORD, signed __int64, struct sockaddr *, _QWORD, _QWORD, _QWORD))(v11 + 16))(
        *(_QWORD *)(v11 + 16),
        2LL,
        &addr,
        *(unsigned int *)(v11 + 100),
        0LL,
        0LL);
LABEL_12:
      v15 = *(struct addrinfo ***)(v11 + 104);
      if ( v15 )
      {
        v16 = *(_DWORD *)v15 - 1;
        v17 = *(_DWORD *)v15 == 1;
        *(_DWORD *)v15 = v16;
        if ( v16 < 0 || v17 )
          sub_B5F60(v15);
        *(_QWORD *)(v11 + 104) = 0LL;
      }
      *(_BYTE *)(v11 + 64) = 1;
      *(_BYTE *)(v11 + 65) = 1;
      sub_B57C0(v11);
      break;
    case 4:
      if ( *(_BYTE *)(v11 + 81) )
      {
        *(_BYTE *)(v11 + 80) = 1;
      }
      else
      {
        v36 = recv(*(_DWORD *)(v11 + 8), &buf, 0x5000uLL, 1);
        v37 = v36;
        v38 = v36;
        sub_B7C30(2u, v36, (__int64)&buf, v36, r14_0, r15_0);
        if ( v38 <= 0 )
        {
          v44 = __errno_location();
          v45 = (unsigned int)*v44;
          v46 = "Internal networking trouble";
          if ( v38 )
          {
            v50 = *v44;
            v51 = strerror(v45);
            v45 = v50;
            v46 = v51;
          }
          (*(void (__fastcall **)(_QWORD, const char *, __int64, _QWORD))(**(_QWORD **)(v11 + 16) + 8LL))(
            *(_QWORD *)(v11 + 16),
            v46,
            v45,
            0LL);
        }
        else
        {
          v39 = *(struct addrinfo ***)(v11 + 104);
          if ( v39 )
          {
            v40 = *(_DWORD *)v39 - 1;
            v17 = *(_DWORD *)v39 == 1;
            *(_DWORD *)v39 = v40;
            if ( v40 < 0 || v17 )
              sub_B5F60(v39);
            *(_QWORD *)(v11 + 104) = 0LL;
          }
          (*(void (__fastcall **)(_QWORD, signed __int64, char *, __int64))(**(_QWORD **)(v11 + 16) + 16LL))(
            *(_QWORD *)(v11 + 16),
            2LL,
            &buf,
            v37);
        }
      }
      break;
    case 1:
      if ( !*(_BYTE *)(v11 + 96) )
      {
        if ( *(_BYTE *)(v11 + 66) )
          break;
        v18 = *(_BYTE *)(v11 + 81);
        v19 = *(_BYTE *)(v11 + 80);
        v20 = *(unsigned int *)(v11 + 8);
        if ( v18 )
        {
          v21 = 20480LL;
          if ( !v19 )
          {
LABEL_21:
            v22 = __recv_chk(v20, &buf, v21, 20480LL, 0LL);
            v23 = (signed int)v22;
            v24 = v22;
            sub_B7C30(2u, (signed int)v22, (__int64)&buf, v22, (signed int)v22, r15_0);
            if ( v24 >= 0 )
            {
              if ( v24 )
              {
                v25 = *(struct addrinfo ***)(v11 + 104);
                if ( v25 )
                {
                  v26 = *(_DWORD *)v25 - 1;
                  v17 = *(_DWORD *)v25 == 1;
                  *(_DWORD *)v25 = v26;
                  if ( v26 < 0 || v17 )
                    sub_B5F60(v25);
                  *(_QWORD *)(v11 + 104) = 0LL;
                }
                (*(void (__fastcall **)(_QWORD, _QWORD, char *, __int64))(**(_QWORD **)(v11 + 16) + 16LL))(
                  *(_QWORD *)(v11 + 16),
                  (unsigned __int8)(v18 ^ 1),
                  &buf,
                  v23);
              }
              else
              {
                *(_BYTE *)(v11 + 88) = 1;
                sub_B57C0(v11);
                (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(v11 + 16) + 8LL))(
                  *(_QWORD *)(v11 + 16),
                  0LL,
                  0LL,
                  0LL);
              }
              break;
            }
            v32 = *__errno_location();
            if ( v32 == 11 )
              break;
LABEL_41:
            v35 = strerror(v32);
            (*(void (__fastcall **)(_QWORD, char *, _QWORD, _QWORD))(**(_QWORD **)(v11 + 16) + 8LL))(
              *(_QWORD *)(v11 + 16),
              v35,
              v32,
              0LL);
            break;
          }
          if ( ioctl(v20, 0x8905uLL, &optlen) )
          {
            v18 = v19;
            v19 = *(_BYTE *)(v11 + 80);
          }
          else
          {
            if ( optlen )
            {
              *(_BYTE *)(v11 + 80) = 0;
              v20 = *(unsigned int *)(v11 + 8);
              v18 = v19;
              goto LABEL_57;
            }
            v19 = *(_BYTE *)(v11 + 80);
            v18 = 0;
          }
          v20 = *(unsigned int *)(v11 + 8);
        }
        else
        {
          v18 = 1;
        }
        v21 = 1LL;
        if ( v19 )
          goto LABEL_21;
LABEL_57:
        v21 = 20480LL;
        goto LABEL_21;
      }
      optlen = 128;
      memset(&addr, 0, 0x80uLL);
      v41 = accept(*(_DWORD *)(v11 + 8), &addr, &optlen);
      v42 = v41;
      if ( v41 >= 0 )
      {
        if ( ((sub_B5050(v41), (v43 = *(_QWORD *)(v11 + 104)) == 0) || *(_DWORD *)(v43 + 16) != 1)
          && *(_BYTE *)(v11 + 67)
          && !sub_B5A30((__int16 *)&addr)
          || (*(unsigned int (__fastcall **)(_QWORD, signed __int64 (__fastcall *)(int, __int64), _QWORD))(**(_QWORD **)(v11 + 16) + 32LL))(
               *(_QWORD *)(v11 + 16),
               sub_B58D0,
               v42) )
        {
          close(v42);
        }
      }
      break;
    default:
      break;
  }
LABEL_5:
  v13 = __readfsqword(0x28u);
  result = v13 ^ v58;
  if ( v13 != v58 )
    goto LABEL_73;
  return result;
}

void __fastcall sub_B7130(__int64 a1)
{
  bool v1; // zf

  if ( *(_DWORD *)(a1 - 60) )
    __assert_fail("s->outgoingeof == EOF_NO", "unix/uxnet.c", 0x4E5u, "sk_net_write_eof");
  v1 = *(_BYTE *)(a1 - 79) == 0;
  *(_DWORD *)(a1 - 60) = 1;
  if ( !v1 )
    sub_B6A00(a1 - 144);
  sub_B57C0(a1 - 144);
}

__int64 __fastcall sub_B7180(__int64 a1, const void *a2, size_t a3)
{
  __int64 v3; // rbp
  size_t v4; // r12
  bool v5; // zf

  if ( *(_DWORD *)(a1 - 60) )
    __assert_fail("s->outgoingeof == EOF_NO", "unix/uxnet.c", 0x4C8u, "sk_net_write_oob");
  v3 = a1 - 144;
  v4 = a3;
  sub_BCCA0(a1 - 144 + 24);
  if ( v4 > 1 )
    __assert_fail("len <= sizeof(s->oobdata)", "unix/uxnet.c", 0x4CEu, "sk_net_write_oob");
  memcpy((void *)(v3 + 68), a2, v4);
  v5 = *(_BYTE *)(a1 - 79) == 0;
  *(_QWORD *)(a1 - 72) = v4;
  if ( !v5 )
    sub_B6A00(v3);
  sub_B57C0(v3);
  return *(_QWORD *)(a1 - 72);
}

__int64 __fastcall sub_B7230(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp

  if ( *(_DWORD *)(a1 - 60) )
    __assert_fail("s->outgoingeof == EOF_NO", "unix/uxnet.c", 0x4AEu, "sk_net_write");
  v3 = a1 - 144;
  sub_BCD20(a1 - 144 + 24, (char *)a2, a3);
  if ( *(_BYTE *)(a1 - 79) )
    sub_B6A00(v3);
  sub_B57C0(v3);
  return sub_BCD00(a1 - 144 + 24);
}

__int64 __fastcall sub_B72A0(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

__int64 __fastcall sub_B72D0(const char *a1)
{
  struct servent *v1; // rax
  unsigned int v2; // edx

  v1 = getservbyname(a1, 0LL);
  v2 = 0;
  if ( v1 )
    v2 = (unsigned __int16)__ROR2__(v1->s_port, 8);
  return v2;
}

void *sub_B7300()
{
  unsigned __int64 v0; // rcx
  void *v1; // rbx
  size_t v2; // rax
  void *v3; // rdi
  size_t len; // [rsp+0h] [rbp+0h]
  unsigned __int64 vars8; // [rsp+8h] [rbp+8h]

  v0 = 0LL;
  v1 = 0LL;
  vars8 = __readfsqword(0x28u);
  len = 0LL;
  while ( 1 )
  {
    v1 = sub_2F4F0(v1, &len, 1uLL, v0, 1uLL, 0);
    if ( gethostname((char *)v1, len) < 0 && *__errno_location() != 36 )
      break;
    v2 = strlen((const char *)v1);
    v0 = len;
    if ( v2 < len - 1 )
      return v1;
  }
  v3 = v1;
  v1 = 0LL;
  sub_2F4D0(v3);
  return v1;
}

char *__fastcall sub_B73B0(__int64 a1, unsigned int a2)
{
  __int64 v2; // r12
  char *v3; // rbx
  char *v4; // rdi
  int v5; // eax

  v2 = a1;
  v3 = (char *)sub_2F450(1uLL, 0x220uLL, 0LL);
  *(_QWORD *)v3 = 0LL;
  *((_QWORD *)v3 + 67) = 0LL;
  memset(
    (void *)((unsigned __int64)(v3 + 8) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 544) >> 3));
  *((_DWORD *)v3 + 4) = 1;
  v4 = v3 + 32;
  if ( !v2 )
  {
    if ( (signed int)__snprintf_chk(v4, 512LL, 1LL, -1LL, "%s%d", "/tmp/.X11-unix/X", a2) <= 511 )
      goto LABEL_5;
LABEL_4:
    *((_QWORD *)v3 + 1) = "X11 UNIX name too long";
    goto LABEL_5;
  }
  v5 = snprintf(v4, 0x200uLL, "%s", v2);
  if ( v5 < 0 )
  {
    *((_QWORD *)v3 + 1) = "snprintf failed";
    goto LABEL_5;
  }
  if ( v5 > 511 )
    goto LABEL_4;
LABEL_5:
  *((_QWORD *)v3 + 3) = 0LL;
  *(_DWORD *)v3 = 1;
  return v3;
}

_QWORD *__fastcall sub_B74A0(__int64 a1)
{
  void *v1; // rax
  _QWORD *v2; // rbx
  int v3; // eax

  v1 = sub_2F450(1uLL, 0x220uLL, 0LL);
  *(_QWORD *)v1 = 0LL;
  *((_QWORD *)v1 + 67) = 0LL;
  v2 = v1;
  memset(
    (void *)(((unsigned __int64)v1 + 8) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) & 0xFFFFFFF8) + 544) >> 3));
  *((_DWORD *)v1 + 4) = 1;
  v3 = snprintf((char *)v1 + 32, 0x200uLL, "%s", a1);
  if ( v3 < 0 )
  {
    v2[1] = "snprintf failed";
  }
  else if ( v3 > 107 )
  {
    v2[1] = "socket pathname too long";
  }
  v2[3] = 0LL;
  *(_DWORD *)v2 = 1;
  return v2;
}

void *__fastcall sub_B7550(char *src, _QWORD *a2, int a3)
{
  int v3; // er14
  void *v4; // rbx
  void **v5; // r12
  signed int v6; // eax
  char *v7; // r14
  int v8; // er15
  __int64 v9; // rax
  char *v10; // rdx
  int v12; // [rsp+0h] [rbp-78h]
  int v13; // [rsp+4h] [rbp-74h]
  __int64 v14; // [rsp+8h] [rbp-70h]
  int v15; // [rsp+10h] [rbp-68h]
  __int64 v16; // [rsp+18h] [rbp-60h]
  __int64 v17; // [rsp+20h] [rbp-58h]
  __int64 v18; // [rsp+28h] [rbp-50h]
  unsigned __int64 v19; // [rsp+38h] [rbp-40h]

  v19 = __readfsqword(0x28u);
  if ( *src == 47 )
  {
    *a2 = sub_BC120(src);
    v4 = sub_B74A0((__int64)src);
  }
  else
  {
    v3 = a3;
    v4 = sub_2F450(1uLL, 0x220uLL, 0LL);
    v5 = (void **)sub_BC640();
    *(_QWORD *)v4 = 0LL;
    *((_QWORD *)v4 + 67) = 0LL;
    memset(
      (void *)(((unsigned __int64)v4 + 8) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)v4 - (((_DWORD)v4 + 8) & 0xFFFFFFF8) + 544) >> 3));
    *(_DWORD *)v4 = 1;
    *((_DWORD *)v4 + 4) = 0;
    v6 = 2;
    *((_QWORD *)v4 + 1) = 0LL;
    v12 = 2;
    if ( v3 != 1 )
    {
      v6 = 10;
      if ( v3 != 2 )
        v6 = 0;
    }
    v13 = v6;
    v14 = 1LL;
    v15 = 0;
    v16 = 0LL;
    v17 = 0LL;
    v18 = 0LL;
    v7 = sub_BC440(src);
    v8 = getaddrinfo(v7, 0LL, (const struct addrinfo *)&v12, (struct addrinfo **)v4 + 3);
    sub_2F4D0(v7);
    if ( v8 )
    {
      *((_QWORD *)v4 + 1) = gai_strerror(v8);
      sub_BC660(v5);
    }
    else
    {
      v9 = *((_QWORD *)v4 + 3);
      *((_DWORD *)v4 + 4) = 2;
      v10 = *(char **)(v9 + 32);
      if ( !v10 )
        v10 = src;
      sub_BC720((__int64)v5, (__int64)"%s", v10, *(_QWORD *)&v12);
      *a2 = sub_BC6B0((__int64 *)v5);
    }
  }
  return v4;
}

char *__fastcall sub_B7700(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  bool v3; // zf
  int v4; // eax
  int v5; // er12
  char *v6; // rax
  int *v7; // rbp
  int *v8; // rax
  char *result; // rax
  __int16 v10; // [rsp+0h] [rbp-B8h]
  __int64 v11; // [rsp+2h] [rbp-B6h]
  unsigned __int64 v12; // [rsp+88h] [rbp-30h]

  v12 = __readfsqword(0x28u);
  v2 = sub_2F450(1uLL, 0x98uLL, 0LL);
  *v2 = 0LL;
  v2[2] = a2;
  v2[18] = off_322900;
  sub_BCC70(v2 + 3);
  v3 = *(_DWORD *)(a1 + 16) == 1;
  *((_BYTE *)v2 + 65) = 0;
  v2[9] = 0LL;
  *((_BYTE *)v2 + 66) = 0;
  *((_BYTE *)v2 + 67) = 1;
  *((_DWORD *)v2 + 23) = 0;
  v2[17] = 0LL;
  v2[16] = 0LL;
  *((_BYTE *)v2 + 80) = 0;
  *((_DWORD *)v2 + 21) = 0;
  *((_BYTE *)v2 + 88) = 0;
  *((_BYTE *)v2 + 96) = 1;
  v2[13] = a1;
  *((_DWORD *)v2 + 2) = -1;
  if ( !v3 )
LABEL_13:
    __assert_fail("listenaddr->superfamily == UNIX", "unix/uxnet.c", 0x6ACu, "new_unix_listener");
  v4 = socket(1, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
LABEL_9:
    v8 = __errno_location();
    *v2 = strerror(*v8);
    goto LABEL_10;
  }
  sub_B4F50(v4);
  *((_BYTE *)v2 + 81) = 0;
  v11 = 0LL;
  memset((char *)&v11 + 6, 0, 0x78uLL);
  v10 = 1;
  v6 = strncpy((char *)&v11, (const char *)(a1 + 32), 0x6BuLL);
  if ( unlink(v6) >= 0 || (v7 = __errno_location(), *v7 == 2) )
  {
    if ( bind(v5, (const struct sockaddr *)&v10, 0x6Eu) >= 0 && listen(v5, 128) >= 0 )
    {
      *((_DWORD *)v2 + 2) = v5;
      sub_B57C0((__int64)v2);
      sub_9AFD0((__int64 *)qword_326500, (__int64)v2);
      goto LABEL_10;
    }
    close(v5);
    goto LABEL_9;
  }
  close(v5);
  *v2 = strerror(*v7);
LABEL_10:
  result = (char *)(v2 + 18);
  if ( __readfsqword(0x28u) != v12 )
    goto LABEL_13;
  return result;
}

unsigned __int64 __fastcall sub_B7910(void (__fastcall *a1)(__int64 *, signed __int64))
{
  void (__fastcall *v1)(__int64 *, signed __int64); // r12
  int v2; // eax
  int v3; // er13
  signed int v4; // ebp
  int v5; // eax
  int v6; // edi
  char v7; // r13
  FILE *v8; // rbp
  unsigned int v9; // eax
  FILE *v10; // rbp
  int *v11; // rax
  char *v12; // rax
  unsigned int v13; // eax
  int v15; // edi
  FILE *v16; // rax
  __int64 v17; // [rsp+0h] [rbp-238h]
  unsigned __int64 v18; // [rsp+208h] [rbp-30h]

  v1 = a1;
  v18 = __readfsqword(0x28u);
  v2 = open("/dev/urandom", 0);
  if ( v2 < 0 )
  {
    v7 = 0;
    v8 = popen("ps -axu 2>/dev/null", "r");
    if ( v8 )
      goto LABEL_8;
LABEL_11:
    v11 = __errno_location();
    v12 = strerror(*v11);
    __fprintf_chk(stderr, 1LL, "popen: %s\nUnable to access fallback entropy source\n", v12);
    exit(1);
  }
  v3 = v2;
  v4 = 0;
  do
  {
    v5 = read(v3, (char *)&v17 + v4, 32 - v4);
    if ( v5 < 0 )
    {
      v15 = v3;
      v7 = 0;
      close(v15);
      v8 = popen("ps -axu 2>/dev/null", "r");
      if ( v8 )
        goto LABEL_8;
      goto LABEL_11;
    }
    v4 += v5;
  }
  while ( v4 <= 31 );
  v6 = v3;
  v7 = 1;
  close(v6);
  v1(&v17, 32LL);
  v8 = popen("ps -axu 2>/dev/null", "r");
  if ( !v8 )
  {
    v16 = popen(aLsAlTmp2Dev, "r");
    v10 = v16;
    if ( !v16 )
      goto LABEL_16;
    goto LABEL_14;
  }
LABEL_8:
  while ( 1 )
  {
    v9 = fread(&v17, 1uLL, 0x200uLL, v8);
    if ( (signed int)v9 <= 0 )
      break;
    v1(&v17, v9);
  }
  pclose(v8);
  v10 = popen(aLsAlTmp2Dev, "r");
  if ( !v10 )
  {
    if ( v7 )
      goto LABEL_16;
    goto LABEL_11;
  }
LABEL_14:
  while ( 1 )
  {
    v13 = fread(&v17, 1uLL, 0x200uLL, v10);
    if ( (signed int)v13 <= 0 )
      break;
    v1(&v17, v13);
  }
  pclose(v10);
LABEL_16:
  sub_BB1F0(v1);
  return __readfsqword(0x28u) ^ v18;
}

unsigned __int64 __usercall sub_B7B30@<rax>(__int64 a1@<r12>, __int64 a2@<r13>, __int64 a3@<r14>, __int64 a4@<r15>)
{
  int v4; // eax
  __int64 v5; // rbp
  int v6; // eax
  int v7; // eax
  __int64 v8; // rbp
  int v9; // eax
  __int64 v11; // [rsp+0h] [rbp-2B8h]
  char buf; // [rsp+90h] [rbp-228h]
  unsigned __int64 v13; // [rsp+298h] [rbp-20h]

  v13 = __readfsqword(0x28u);
  v4 = open("/proc/meminfo", 0);
  v5 = (unsigned int)v4;
  if ( v4 >= 0 )
  {
    while ( 1 )
    {
      v6 = read(v5, &buf, 0x200uLL);
      if ( v6 <= 0 )
        break;
      sub_7BEE0(v6, (__int64)&buf, v5, 6u, (__int64)&buf, a1, a2, a3, a4);
    }
    close(v5);
  }
  v7 = open("/proc/stat", 0);
  v8 = (unsigned int)v7;
  if ( v7 >= 0 )
  {
    while ( 1 )
    {
      v9 = read(v8, &buf, 0x200uLL);
      if ( v9 <= 0 )
        break;
      sub_7BEE0(v9, (__int64)&buf, v8, 7u, (__int64)&buf, a1, a2, a3, a4);
    }
    close(v8);
  }
  getrusage(0, (struct rusage *)&v11);
  sub_7BEE0(144, (__int64)&v11, v8, 8u, (__int64)&v11, a1, a2, a3, a4);
  return __readfsqword(0x28u) ^ v13;
}

unsigned __int64 __usercall sub_B7C30@<rax>(unsigned int a1@<edi>, __int64 a2@<rsi>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  __int64 v7; // [rsp+8h] [rbp-40h]
  struct timeval tv; // [rsp+10h] [rbp-38h]
  unsigned __int64 v9; // [rsp+28h] [rbp-20h]

  v7 = a2;
  v9 = __readfsqword(0x28u);
  gettimeofday(&tv, 0LL);
  sub_7BEE0(16, (__int64)&tv, a1, 0, (__int64)&tv, a3, a4, a5, a6);
  sub_7BEE0(8, (__int64)&tv, a1, a1, (__int64)&v7, a3, a4, a5, a6);
  return __readfsqword(0x28u) ^ v9;
}

__int64 sub_B7CA0()
{
  __int64 v1; // [rsp+0h] [rbp-28h]
  __int64 v2; // [rsp+8h] [rbp-20h]
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  gettimeofday((struct timeval *)&v1, 0LL);
  return 1000 * v1
       + ((signed __int64)((unsigned __int128)(2361183241434822607LL * (signed __int128)v2) >> 64) >> 7)
       - (v2 >> 63);
}

__int64 __fastcall sub_B7D10(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // rbx
  _DWORD *v5; // rbp
  int v6; // eax
  unsigned int v7; // edx
  socklen_t optlen; // [rsp+8h] [rbp-30h]
  int optval; // [rsp+Ch] [rbp-2Ch]
  int v11; // [rsp+10h] [rbp-28h]
  int v12; // [rsp+14h] [rbp-24h]
  unsigned __int64 v13; // [rsp+18h] [rbp-20h]

  v4 = a4;
  v5 = a3;
  optlen = 12;
  v13 = __readfsqword(0x28u);
  v6 = getsockopt(a1, 1, 17, &optval, &optlen);
  v7 = 0;
  if ( !v6 )
  {
    v7 = 1;
    *a2 = optval;
    *v5 = v11;
    *v4 = v12;
  }
  return v7;
}

signed __int64 __fastcall sub_B7DA0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

_QWORD *sub_B7DC0()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx

  v0 = sub_2F450(1uLL, 0x20uLL, 0LL);
  v0[2] = 16LL;
  v0[1] = 0LL;
  v1 = v0;
  *v0 = sub_2F450(0x10uLL, 8uLL, 0LL);
  v1[3] = sub_9AF60((__int64)sub_B7DA0);
  return v1;
}

void *__fastcall sub_B7E10(__int64 a1)
{
  void *result; // rax

  *(_QWORD *)(a1 + 8) = 0LL;
  while ( 1 )
  {
    result = (void *)sub_9B400(*(__int64 **)(a1 + 24), 0);
    if ( !result )
      break;
    sub_2F4D0(result);
  }
  return result;
}

void __fastcall sub_B7E40(__int64 a1)
{
  sub_B7E10(a1);
  sub_9AF90(*(_QWORD ***)(a1 + 24));
  sub_2F4D0(*(void **)a1);
  sub_2F4D0((void *)a1);
}

unsigned __int64 __fastcall sub_B7E70(__int64 a1, int a2, __int16 a3)
{
  __int64 v3; // rbx
  __int64 *v4; // rdi
  __int16 v5; // r12
  __int64 v6; // rax
  char *v8; // rax
  __int64 v9; // r14
  int *v10; // rax
  _QWORD *v11; // rax
  __int64 *v12; // rdi
  _QWORD *v13; // r13
  int v14; // [rsp+0h] [rbp-48h]
  unsigned __int64 v15; // [rsp+18h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  if ( a2 < 0 )
    __assert_fail("fd >= 0", "unix/uxpoll.c", 0x3Au, "pollwrap_add_fd_events");
  v3 = a1;
  v4 = *(__int64 **)(a1 + 24);
  v14 = a2;
  v5 = a3;
  v6 = sub_9B3D0(v4, (__int64)&v14, 0LL);
  if ( !v6 )
  {
    v8 = (char *)sub_2F4F0(*(void **)v3, (unsigned __int64 *)(v3 + 16), 8uLL, *(_QWORD *)(v3 + 8), 1uLL, 0);
    v9 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)v3 = v8;
    v10 = (int *)&v8[8 * v9];
    *(_QWORD *)(v3 + 8) = v9 + 1;
    *v10 = a2;
    v10[1] = 0;
    v11 = sub_2F450(1uLL, 0x10uLL, 0LL);
    v12 = *(__int64 **)(v3 + 24);
    v13 = v11;
    *(_DWORD *)v11 = a2;
    v11[1] = v9;
    v6 = sub_9AFD0(v12, (__int64)v11);
    if ( v13 != (_QWORD *)v6 )
      __assert_fail("added == f2p", "unix/uxpoll.c", 0x48u, "pollwrap_add_fd_events");
  }
  *(_WORD *)(*(_QWORD *)v3 + 8LL * *(_QWORD *)(v6 + 8) + 4) |= v5;
  return __readfsqword(0x28u) ^ v15;
}

__int64 __fastcall sub_B8030(__int64 a1, int a2)
{
  _QWORD *v2; // rbx
  __int64 *v3; // rdi
  __int64 v4; // rax
  unsigned int v5; // edx
  int v7; // [rsp+0h] [rbp-28h]
  unsigned __int64 v8; // [rsp+18h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  if ( a2 < 0 )
    sub_1B02F();
  v2 = (_QWORD *)a1;
  v3 = *(__int64 **)(a1 + 24);
  v7 = a2;
  v4 = sub_9B3D0(v3, (__int64)&v7, 0LL);
  v5 = 0;
  if ( v4 )
    v5 = *(signed __int16 *)(*v2 + 8LL * *(_QWORD *)(v4 + 8) + 6);
  return v5;
}

__int64 __fastcall sub_B80A0(__int64 a1, int a2)
{
  _QWORD *v2; // rbx
  __int64 *v3; // rdi
  __int64 v4; // rax
  unsigned int v5; // edx
  signed __int64 v6; // rcx
  __int16 v7; // ax
  __int16 v8; // cx
  int v10; // [rsp+0h] [rbp-28h]
  unsigned __int64 v11; // [rsp+18h] [rbp-10h]

  v11 = __readfsqword(0x28u);
  if ( a2 < 0 )
    sub_1B02F();
  v2 = (_QWORD *)a1;
  v3 = *(__int64 **)(a1 + 24);
  v10 = a2;
  v4 = sub_9B3D0(v3, (__int64)&v10, 0LL);
  v5 = 0;
  if ( v4 )
  {
    v6 = *v2 + 8LL * *(_QWORD *)(v4 + 8);
    v7 = *(_WORD *)(v6 + 4);
    v8 = *(_WORD *)(v6 + 6);
    if ( v7 & 1 )
      v5 = (v8 & 0xD9) != 0;
    if ( v7 & 4 && v8 & 0x30C )
      v5 |= 2u;
    if ( v7 & 2 && v8 & 2 )
      v5 |= 4u;
  }
  return v5;
}

_QWORD *__fastcall sub_B8140(char *command)
{
  _QWORD *v1; // rbx
  FILE *v2; // rax
  void *v4; // rdi

  v1 = sub_2F450(1uLL, 8uLL, 0LL);
  v2 = popen(command, "w");
  *v1 = v2;
  if ( !v2 )
  {
    v4 = v1;
    v1 = 0LL;
    sub_2F4D0(v4);
  }
  return v1;
}

size_t __fastcall sub_B8190(FILE **a1, const void *a2, size_t a3)
{
  size_t result; // rax

  result = (size_t)a2;
  if ( a1 )
    result = fwrite(a2, 1uLL, a3, *a1);
  return result;
}

void __fastcall sub_B81C0(FILE **a1)
{
  if ( a1 )
  {
    pclose(*a1);
    sub_2F4D0(a1);
  }
}

__int64 __fastcall sub_B81F0(_DWORD *a1)
{
  *a1 = 0;
  return 0LL;
}

__int64 sub_B8200()
{
  return 0LL;
}

void nullsub_42()
{
  ;
}

void *__fastcall sub_B8220(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, void (__fastcall ***a8)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD), __int64 *a9)
{
  struct addrinfo **v9; // r12
  unsigned int v10; // er13
  int v11; // eax
  void *v12; // r13
  int v13; // er14
  int v14; // ebx
  void *v15; // rdi
  int v16; // er13
  void *v17; // rbx
  void *result; // rax
  char *v19; // r13
  __pid_t v20; // er13
  int *v21; // rax
  char *v22; // rax
  int *v23; // rax
  char *v24; // rax
  int *v25; // rax
  char *v26; // rax
  int *v27; // rax
  char *v28; // rax
  int fd; // [rsp+0h] [rbp-48h]
  int v30; // [rsp+4h] [rbp-44h]
  int pipedes[2]; // [rsp+8h] [rbp-40h]
  int v32[2]; // [rsp+10h] [rbp-38h]
  unsigned __int64 v33; // [rsp+18h] [rbp-30h]

  v9 = (struct addrinfo **)a1;
  v10 = a3;
  v33 = __readfsqword(0x28u);
  v11 = sub_1EFD0(a9, 13);
  if ( (unsigned int)(v11 - 5) > 1 )
  {
    v17 = 0LL;
  }
  else if ( v11 == 5 )
  {
    v17 = (void *)sub_3ADC0(a1, v10, a9);
    v19 = sub_BC360((__int64)"Starting local proxy command: %s", v17);
    (**a8)(a8, 3LL, 0LL, 0LL, v19, 0LL);
    sub_2F4D0(v19);
    if ( pipe(&fd) < 0 || pipe(pipedes) < 0 || pipe(v32) < 0 )
    {
      sub_2F4D0(v17);
      v21 = __errno_location();
      v22 = strerror(*v21);
      v17 = sub_2BCD0((__int64)a8, (__int64)"pipe: %s", v22);
    }
    else
    {
      sub_B4F50(v30);
      sub_B4F50(pipedes[0]);
      sub_B4F50(v32[0]);
      v20 = fork();
      if ( !v20 )
        goto LABEL_20;
      sub_2F4D0(v17);
      if ( v20 >= 0 )
      {
        close(fd);
        close(pipedes[1]);
        close(v32[1]);
        v13 = v30;
        v14 = pipedes[0];
        v16 = v32[0];
        goto LABEL_6;
      }
      v27 = __errno_location();
      v28 = strerror(*v27);
      v17 = sub_2BCD0((__int64)a8, (__int64)"fork: %s", v28);
    }
  }
  else
  {
    v12 = (void *)sub_3ADC0(a1, v10, a9);
    v13 = open(&aLsAlTmp2Dev[14], 1);
    if ( v13 == -1 )
    {
      sub_2F4D0(v12);
      v23 = __errno_location();
      v24 = strerror(*v23);
      v17 = sub_2BCD0((__int64)a8, (__int64)"/dev/null: %s", v24);
    }
    else
    {
      v14 = open((const char *)v12, 0);
      if ( v14 != -1 )
      {
        v15 = v12;
        v16 = -1;
        sub_2F4D0(v15);
LABEL_6:
        sub_B62D0(v9);
        v17 = sub_B4880(v14, v13, v16, (__int64)a8);
        goto LABEL_7;
      }
      v25 = __errno_location();
      v26 = strerror(*v25);
      v17 = sub_2BCD0((__int64)a8, (__int64)"%s: %s", v12, v26);
      sub_2F4D0(v12);
      close(v13);
    }
  }
LABEL_7:
  result = v17;
  if ( __readfsqword(0x28u) != v33 )
  {
LABEL_20:
    close(0);
    close(1);
    dup2(fd, 0);
    dup2(pipedes[1], 1);
    close(fd);
    close(pipedes[1]);
    dup2(v32[1], 2);
    sub_B4FD0(0);
    sub_B4FD0(1);
    execl("/bin/sh", "sh", "-c", v17, 0LL);
    _exit(255);
  }
  return result;
}

void __fastcall __noreturn sub_B8550(int status)
{
  sub_B6040();
  sub_7C040();
  exit(status);
}

void **__fastcall sub_B8570(__int64 *a1)
{
  int v1; // eax
  void **result; // rax

  v1 = sub_1EFD0(a1, 2);
  result = sub_3CFD0(v1);
  if ( !result )
    __assert_fail("vt != NULL", "unix/uxputty.c", 0x2Du, "select_backend");
  return result;
}

void __fastcall sub_B85B0(__int64 *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r13
  char *v12; // rbx

  v11 = a3;
  v12 = sub_BC160("PuTTY", a4, a5, a6, a7, a8, a9, a10, a11, " Configuration", 0LL);
  sub_A20F0((__int64)v12, a1, 0, 0, a2, v11);
  sub_2F4D0(v12);
}

char *__fastcall sub_B8610(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  char *v3; // rax

  v2 = gdk_display_get_default(a1, a2);
  v3 = (char *)gdk_display_get_name(v2);
  if ( !v3 )
    v3 = getenv("DISPLAY");
  return sub_BC120(v3);
}

void sub_B8650()
{
  void **v0; // rbx

  sub_B6020();
  sub_3CF60(3);
  v0 = sub_3CFD0(3);
  sub_3CF70(0);
  if ( v0 )
    sub_3CF70(*((_DWORD *)v0 + 39));
}

signed __int64 __fastcall sub_B8690(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

signed __int64 __fastcall sub_B86B0(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax

  if ( *a1 < *a2 )
    result = 0xFFFFFFFFLL;
  else
    result = *a1 > *a2;
  return result;
}

_QWORD *sub_B86D0()
{
  _QWORD *result; // rax

  result = sub_9AF60((__int64)sub_B8690);
  qword_326508 = (__int64)result;
  return result;
}

void __fastcall sub_B86F0(int a1)
{
  __int64 v1; // rax
  unsigned int *v2; // rdi
  void *v3; // rbx
  int v4; // [rsp+Ch] [rbp-Ch]

  v4 = a1;
  v1 = sub_9B3D0((__int64 *)qword_326508, (__int64)&v4, (__int64 (__fastcall *)(__int64))sub_B86B0);
  if ( v1 )
  {
    v2 = *(unsigned int **)(v1 + 16);
    v3 = (void *)v1;
    if ( v2 )
      sub_9DA50(v2);
    sub_9B440((__int64 *)qword_326508, (__int64)v3);
    sub_2F4D0(v3);
  }
}

void __fastcall sub_B8750(signed int a1, int a2, __int64 a3)
{
  __int64 v3; // r13
  _DWORD *v4; // r12
  _DWORD *v5; // rax
  __int64 *v6; // rdi

  if ( a1 < 0 )
    __assert_fail("fd >= 0", "unix/uxsel.c", 0x43u, "uxsel_set");
  v3 = a3;
  sub_B86F0(a1);
  if ( a2 )
  {
    v4 = sub_2F450(1uLL, 0x18uLL, 0LL);
    *v4 = a1;
    v4[1] = a2;
    *((_QWORD *)v4 + 1) = v3;
    v5 = sub_9D9C0(a1, a2);
    v6 = (__int64 *)qword_326508;
    *((_QWORD *)v4 + 2) = v5;
    sub_9AFD0(v6, (__int64)v4);
  }
}

signed __int64 __fastcall sub_B87F0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // rbx
  signed int v3; // esi
  unsigned int *v4; // rax

  v2 = a2;
  v3 = (*a1)++;
  v4 = (unsigned int *)sub_9B010((__int64 *)qword_326508, v3);
  if ( !v4 )
    return 0xFFFFFFFFLL;
  *v2 = v4[1];
  return *v4;
}

unsigned __int64 __usercall sub_B8830@<rax>(unsigned int a1@<edi>, unsigned int a2@<esi>, __int64 a3@<r12>, __int64 a4@<r13>, __int64 a5@<r14>, __int64 a6@<r15>)
{
  __int64 v6; // rbx
  unsigned __int64 result; // rax
  unsigned int v8; // [rsp+Ch] [rbp-1Ch]

  v8 = a1;
  v6 = sub_9B3D0((__int64 *)qword_326508, (__int64)&v8, (__int64 (__fastcall *)(__int64))sub_B86B0);
  result = sub_B7C30(1u, (signed int)v8, a3, a4, a5, a6);
  if ( v6 )
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(v6 + 8))(v8, a2);
  return result;
}

signed __int64 __fastcall sub_B8880(__int64 a1, __int64 a2)
{
  int v2; // eax
  signed __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a1 + 16) < v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a1 + 16) > v2;
  return result;
}

signed __int64 __fastcall sub_B88A0(_DWORD *a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( *(_DWORD *)(a2 + 16) > *a1 )
    result = 0xFFFFFFFFLL;
  else
    result = *(_DWORD *)(a2 + 16) < *a1;
  return result;
}

void nullsub_43()
{
  ;
}

char **sub_B88D0()
{
  return &off_322940;
}

signed __int64 sub_B88E0()
{
  return 1LL;
}

__int64 sub_B88F0()
{
  return 0LL;
}

void nullsub_44()
{
  ;
}

__int64 __fastcall sub_B8910(__int64 a1)
{
  return (*(_DWORD *)(a1 - 56) & 0x80000000) - 1;
}

__int64 sub_B8920()
{
  return 0LL;
}

__int64 __fastcall sub_B8930(__int64 a1)
{
  return sub_BCD00(a1 - 40);
}

void __fastcall sub_B8940(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rdi
  int v3; // ebx

  v1 = a1;
  v2 = a1 + 32;
  v3 = *(_QWORD *)(v2 - 8) <= 0x1000uLL;
  if ( sub_BCD00(v2) )
    v3 |= 2u;
  sub_B8750(*(_DWORD *)(v1 + 16), v3, (__int64)sub_B8AB0);
}

void __fastcall sub_B8990(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 - 48) = a2;
  sub_B8940(a1 - 72);
}

void __fastcall sub_B89A0(__int64 a1)
{
  __int64 i; // rbx
  const void *v2; // rax
  size_t v3; // rdx
  signed __int64 v4; // rax

  if ( *(_DWORD *)(a1 + 16) < 0 )
    __assert_fail(aSerial, "unix/uxser.c", 0x1B6u, "serial_try_write");
  for ( i = a1 + 32; sub_BCD00(i); sub_BCE20(i, v4) )
  {
    v2 = (const void *)sub_BCF00(i);
    v4 = write(*(_DWORD *)(a1 + 16), v2, v3);
    if ( v4 < 0 )
    {
      if ( *__errno_location() != 11 )
      {
        perror("write serial port");
        exit(1);
      }
      break;
    }
  }
  sub_B8940(a1);
}

void __usercall sub_B8A40(__int64 a1@<rdi>, int a2@<esi>, __int64 a3@<r13>, __int64 a4@<r15>)
{
  int v4; // eax

  v4 = *(_DWORD *)(a1 - 56);
  if ( !a2 && v4 >= 0 )
  {
    tcsendbreak(v4, 0);
    sub_2D2C0(*(_QWORD *)(a1 - 64), "Sending serial break at user request", a3, a4);
  }
}

__int64 __fastcall sub_B8A70(__int64 a1, __int64 a2, __int64 a3)
{
  if ( *(_DWORD *)(a1 - 56) < 0 )
    return 0LL;
  sub_BCD20(a1 - 72 + 32, (char *)a2, a3);
  sub_B89A0(a1 - 72);
  return sub_BCD00(a1 - 72 + 32);
}

unsigned __int64 __fastcall sub_B8AB0(int a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  int v5; // eax
  int v6; // edi
  __int64 v7; // rdi
  int v8; // [rsp+Ch] [rbp-102Ch]
  char buf; // [rsp+10h] [rbp-1028h]
  unsigned __int64 v10; // [rsp+1018h] [rbp-20h]

  v8 = a1;
  v10 = __readfsqword(0x28u);
  v2 = sub_9B3D0((__int64 *)qword_326510, (__int64)&v8, (__int64 (__fastcall *)(__int64))sub_B88A0);
  if ( v2 )
  {
    v3 = v2;
    if ( a2 == 1 )
    {
      v5 = read(*(_DWORD *)(v2 + 16), &buf, 0x1000uLL);
      if ( v5 )
      {
        if ( v5 < 0 )
        {
          if ( *__errno_location() != 11 )
          {
            perror("read serial port");
            exit(1);
          }
        }
        else
        {
          *(_QWORD *)(v3 + 24) = (***(__int64 (__fastcall ****)(_QWORD, _QWORD, char *, _QWORD))v3)(
                                   *(_QWORD *)v3,
                                   0LL,
                                   &buf,
                                   v5);
          sub_B8940(v3);
        }
      }
      else
      {
        v6 = *(_DWORD *)(v3 + 16);
        if ( v6 >= 0 )
        {
          sub_B86F0(v6);
          close(*(_DWORD *)(v3 + 16));
          *(_DWORD *)(v3 + 16) = -1;
        }
        v7 = *(_QWORD *)v3;
        *(_BYTE *)(v3 + 20) = 1;
        (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v7 + 24LL))(v7, &buf);
      }
    }
    else if ( a2 == 2 )
    {
      sub_B89A0(v2);
    }
  }
  return __readfsqword(0x28u) ^ v10;
}

char *__usercall sub_B8BD0@<rax>(__int64 *a1@<rdx>, __int64 *a2@<rbx>, __int64 *a3@<rdi>, int *a4@<rsi>, struct termios *a5@<r12>, int *a6@<r14>)
{
  __int64 *v6; // rbp
  int v7; // edi
  signed int v8; // eax
  __int64 v9; // r15
  signed __int64 v10; // r13
  signed int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // edx
  char *result; // rax
  int *v18; // rax
  char *v19; // rax
  int v20; // [rsp+0h] [rbp-88h]
  int v21; // [rsp+4h] [rbp-84h]
  int v22; // [rsp+8h] [rbp-80h]
  int v23; // [rsp+Ch] [rbp-7Ch]
  __int16 v24; // [rsp+16h] [rbp-72h]
  unsigned __int64 v25; // [rsp+48h] [rbp-40h]

  v6 = a3;
  v7 = *a4;
  v25 = __readfsqword(0x28u);
  if ( v7 < 0 )
  {
    result = sub_BC120("Unable to reconfigure already-closed serial connection");
    goto LABEL_51;
  }
  a5 = (struct termios *)&v20;
  a2 = a1;
  a6 = a4;
  tcgetattr(v7, (struct termios *)&v20);
  v8 = sub_1EFD0(a2, 62);
  if ( v8 <= 74 )
  {
    v10 = 1LL;
    v9 = 50LL;
  }
  else if ( v8 <= 109 )
  {
    v10 = 2LL;
    v9 = 75LL;
  }
  else if ( v8 <= 133 )
  {
    v10 = 3LL;
    v9 = 110LL;
  }
  else if ( v8 <= 149 )
  {
    v10 = 4LL;
    v9 = 134LL;
  }
  else if ( v8 <= 199 )
  {
    v10 = 5LL;
    v9 = 150LL;
  }
  else if ( v8 <= 299 )
  {
    v10 = 6LL;
    v9 = 200LL;
  }
  else if ( v8 <= 599 )
  {
    v10 = 7LL;
    v9 = 300LL;
  }
  else if ( v8 <= 1199 )
  {
    v10 = 8LL;
    v9 = 600LL;
  }
  else if ( v8 <= 1799 )
  {
    v10 = 9LL;
    v9 = 1200LL;
  }
  else if ( v8 <= 2399 )
  {
    v10 = 10LL;
    v9 = 1800LL;
  }
  else if ( v8 <= 4799 )
  {
    v10 = 11LL;
    v9 = 2400LL;
  }
  else if ( v8 <= 9599 )
  {
    v10 = 12LL;
    v9 = 4800LL;
  }
  else if ( v8 <= 19199 )
  {
    v10 = 13LL;
    v9 = 9600LL;
  }
  else
  {
    if ( v8 <= 38399 )
      goto LABEL_61;
    if ( v8 <= 57599 )
    {
      v10 = 15LL;
      v9 = 38400LL;
    }
    else if ( v8 <= 115199 )
    {
      v10 = 4097LL;
      v9 = 57600LL;
    }
    else if ( v8 <= (signed int)&loc_383FF )
    {
      v10 = 4098LL;
      v9 = 115200LL;
    }
    else if ( v8 <= (signed int)&loc_707FF )
    {
      v10 = 4099LL;
      v9 = 230400LL;
    }
    else if ( v8 <= 499999 )
    {
      v10 = 4100LL;
      v9 = 460800LL;
    }
    else if ( v8 <= (signed int)&loc_8C9FF )
    {
      v10 = 4101LL;
      v9 = 500000LL;
    }
    else if ( v8 <= 921599 )
    {
      v10 = 4102LL;
      v9 = 576000LL;
    }
    else if ( v8 <= (signed int)" Record" )
    {
      v10 = 4103LL;
      v9 = 921600LL;
    }
    else if ( v8 <= (signed int)&off_1193FF )
    {
      v10 = 4104LL;
      v9 = 1000000LL;
    }
    else if ( v8 <= 1499999 )
    {
      v10 = 4105LL;
      v9 = 1152000LL;
    }
    else if ( v8 <= 1999999 )
    {
      v10 = 4106LL;
      v9 = 1500000LL;
    }
    else if ( v8 <= 2499999 )
    {
      v10 = 4107LL;
      v9 = 2000000LL;
    }
    else if ( v8 <= 2999999 )
    {
      v10 = 4108LL;
      v9 = 2500000LL;
    }
    else if ( v8 <= 3499999 )
    {
      v10 = 4109LL;
      v9 = 3000000LL;
    }
    else
    {
      v9 = 4000000LL;
      v10 = (unsigned int)(v8 > 3999999) + 4110;
      if ( v8 <= 3999999 )
        v9 = 3500000LL;
    }
  }
  while ( 1 )
  {
    cfsetispeed(a5, v10);
    cfsetospeed(a5, v10);
    sub_2D3F0(*v6, (__int64)"Configuring baud rate %d", v10, v9);
    v22 &= 0xFFFFFFCF;
    v11 = sub_1EFD0(a2, 63);
    if ( v11 == 6 )
    {
      v22 |= 0x10u;
    }
    else if ( v11 <= 6 )
    {
      if ( v11 != 5 )
      {
LABEL_54:
        result = sub_BC120("Invalid number of data bits (need 5, 6, 7 or 8)");
        goto LABEL_51;
      }
    }
    else if ( v11 == 7 )
    {
      v22 |= 0x20u;
    }
    else
    {
      if ( v11 != 8 )
        goto LABEL_54;
      v22 |= 0x30u;
    }
    sub_1EFD0(a2, 63);
    sub_2D3F0(*v6, (__int64)"Configuring %d data bits", v10, v9);
    if ( (signed int)sub_1EFD0(a2, 64) <= 3 )
      v22 &= 0xFFFFFFBF;
    else
      v22 |= 0x40u;
    sub_2D3F0(*v6, (__int64)"Configuring %s", v10, v9);
    v20 &= 0xFFFFEBFF;
    v22 &= 0x7FFFFFFFu;
    v12 = sub_1EFD0(a2, 66);
    if ( v12 == 1 )
    {
      v20 |= 0x1400u;
    }
    else if ( v12 == 2 )
    {
      v22 |= 0x80000000;
    }
    sub_2D3F0(*v6, (__int64)"Configuring %s flow control", v10, v9);
    v13 = sub_1EFD0(a2, 65);
    if ( v13 == 1 )
    {
      v22 |= 0x300u;
    }
    else
    {
      v14 = v22;
      if ( v13 == 2 )
        BYTE1(v14) = BYTE1(v14) & 0xFD | 1;
      else
        BYTE1(v14) &= 0xFEu;
      v22 = v14;
    }
    sub_2D3F0(*v6, (__int64)"Configuring %s parity", v10, v9);
    v15 = *a6;
    v22 |= 0x880u;
    v23 &= 0xFFFFFFE4;
    v24 = 256;
    v20 &= 0xFFFFFC1F;
    v21 &= 0xFFFFFFC2;
    v16 = tcsetattr(v15, 0, a5);
    result = 0LL;
    if ( v16 < 0 )
    {
      v18 = __errno_location();
      v19 = strerror(*v18);
      result = sub_BC360((__int64)"Configuring serial port: %s", v19);
    }
LABEL_51:
    if ( __readfsqword(0x28u) == v25 )
      return result;
LABEL_61:
    v10 = 14LL;
    v9 = 19200LL;
  }
}

void __usercall sub_B91D0(__int64 *a1@<rbx>, __int64 a2@<rdi>, __int64 *a3@<rsi>, struct termios *a4@<r12>, int *a5@<r14>)
{
  char *v5; // rax

  v5 = sub_B8BD0(a3, a1, (__int64 *)(a2 - 64), (int *)(a2 - 56), a4, a5);
  if ( v5 )
    sub_2F4D0(v5);
}

char *__fastcall sub_B9200(__int64 a1, __int64 a2, _QWORD *a3, int *a4, __int64 *a5, __int64 a6, __int64 a7, __int64 *a8)
{
  _QWORD *v8; // r15
  int *v9; // r14
  __int64 *v10; // r12
  _QWORD *v11; // rax
  _QWORD *v12; // rbx
  char *v13; // rbp
  int v14; // eax
  char *v15; // r12
  char *result; // rax
  int *v17; // rax
  char *v18; // rax
  char *v19; // rax
  __int64 *v20; // rdi
  bool v21; // zf

  v8 = a3;
  v9 = a4;
  v10 = a5;
  (*(void (__fastcall **)(__int64, _QWORD, _QWORD *, int *, __int64 *, __int64))(*(_QWORD *)a2 + 136LL))(
    a2,
    0LL,
    a3,
    a4,
    a5,
    a6);
  v11 = sub_2F450(1uLL, 0x50uLL, 0LL);
  v12 = v11;
  v11[9] = a1;
  *v8 = v11 + 9;
  *v11 = a2;
  v11[1] = v9;
  *((_BYTE *)v11 + 20) = 0;
  v11[3] = 0LL;
  sub_BCC70(v11 + 4);
  v13 = (char *)sub_1F170(v10, 61);
  sub_2D3F0(v12[1], (__int64)"Opening serial device %s", a1, (__int64)v8);
  v14 = open(v13, 2306);
  *((_DWORD *)v12 + 4) = v14;
  if ( v14 < 0 )
  {
    v17 = __errno_location();
    v18 = strerror(*v17);
    result = sub_BC360((__int64)"Opening serial port '%s': %s", v13, v18);
  }
  else
  {
    sub_B4F50(v14);
    v15 = sub_B8BD0(v10, v12, v12 + 1, (int *)v12 + 4, (struct termios *)v10, v9);
    if ( !v15 )
    {
      v19 = sub_BC120(v13);
      v20 = (__int64 *)qword_326510;
      v21 = qword_326510 == 0;
      *a8 = (__int64)v19;
      if ( v21 )
      {
        v20 = sub_9AF60((__int64)sub_B8880);
        qword_326510 = (__int64)v20;
      }
      sub_9AFD0(v20, (__int64)v12);
      sub_B8940((__int64)v12);
      (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)*v12 + 40LL))(*v12, v12);
    }
    result = v15;
  }
  return result;
}

signed __int64 sub_B9360()
{
  return 1LL;
}

void __fastcall sub_B9370(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // rbx
  int v3; // edi

  v1 = (void *)(a1 - 72);
  v2 = a1;
  v3 = *(_DWORD *)(a1 - 56);
  if ( v3 >= 0 )
  {
    sub_B86F0(v3);
    close(*(_DWORD *)(v2 - 56));
    *(_DWORD *)(v2 - 56) = -1;
  }
  sub_BCCA0((__int64)v1 + 32);
  sub_2F4D0(v1);
}

char *__fastcall sub_B93B0(char *a1, __int64 *a2)
{
  char *v2; // rbx
  char *v3; // r12
  char *v4; // r14
  int v5; // ebx
  signed int v6; // er15
  int v7; // eax
  __int64 v8; // rax
  void (__fastcall ***v9)(_QWORD, char *, signed __int64); // r13
  char *v10; // r15
  char *v11; // rbx
  __int64 v12; // r8
  char *v13; // rdi
  char *v14; // rbx
  char *result; // rax
  char *v16; // rdx
  char *v17; // rbx
  const char *v18; // rdi
  char *v19; // rsi
  int *v20; // rax
  int v21; // edi
  int *v22; // r13
  unsigned int v23; // ebp
  char *i; // rax
  char *v25; // rbx
  int v26; // er15
  int v27; // eax
  const char *v28; // rdi
  char *v29; // rdx
  char *v30; // rsi
  int *v31; // rax
  char *v32; // rax
  char *src; // [rsp+0h] [rbp-108h]
  char *to; // [rsp+8h] [rbp-100h]
  __int64 *v35; // [rsp+10h] [rbp-F8h]
  char *v36; // [rsp+18h] [rbp-F0h]
  char v37; // [rsp+20h] [rbp-E8h]
  char buf; // [rsp+40h] [rbp-C8h]
  char v39; // [rsp+80h] [rbp-88h]
  char v40; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v41; // [rsp+C8h] [rbp-40h]

  v36 = a1;
  v35 = a2;
  v41 = __readfsqword(0x28u);
  v2 = sub_B4EC0();
  v3 = sub_BC360((__int64)"%s.%s", "/tmp/putty-connshare", v2);
  sub_2F4D0(v2);
  if ( *v3 != 47 )
    __assert_fail("*parent == '/'", "unix/uxshare.c", 0x24u, "make_parentdir_name");
  v4 = sub_B5280(v3);
  if ( v4 )
  {
    *a2 = (__int64)v4;
    v4 = 0LL;
    sub_2F4D0(v3);
    goto LABEL_13;
  }
  to = sub_BC360((__int64)"%s/%s", v3, "salt");
  v5 = open(to, 0);
  if ( v5 >= 0 )
    goto LABEL_4;
  v20 = __errno_location();
  v21 = *v20;
  v22 = v20;
  if ( *v20 != 2 )
    goto LABEL_33;
  v23 = 0;
  LODWORD(src) = getpid();
  for ( i = sub_BC360((__int64)"%s/%s.tmp.%d.%d", v3, "salt", (unsigned int)src, 0LL, src);
        ;
        i = sub_BC360((__int64)"%s/%s.tmp.%d.%d", v3, "salt", (unsigned int)src, v23, src) )
  {
    v25 = i;
    v26 = open(i, 193, 256LL);
    if ( v26 >= 0 )
      break;
    if ( *v22 != 17 )
    {
      v28 = "%s: open: %s";
      v29 = strerror(*v22);
      v30 = v25;
      goto LABEL_36;
    }
    ++v23;
    sub_2F4D0(v25);
  }
  sub_7BF50(&buf, 0x40uLL);
  v27 = write(v26, &buf, 0x40uLL);
  if ( v27 >= 0 && v27 != 64 )
LABEL_42:
    __assert_fail("ret < 0 || ret == SALT_SIZE", "unix/uxshare.c", 0x80u, "make_dirname");
  if ( v27 < 0 )
  {
    close(v26);
    v30 = v25;
    v29 = strerror(*v22);
    v28 = "%s: write: %s";
    goto LABEL_36;
  }
  if ( close(v26) < 0 )
  {
    v30 = v25;
    v29 = strerror(*v22);
    v28 = "%s: close: %s";
LABEL_36:
    *v35 = (__int64)sub_BC360((__int64)v28, v30, v29);
    sub_2F4D0(v25);
    sub_2F4D0(to);
    sub_2F4D0(v3);
    goto LABEL_13;
  }
  if ( link(v25, to) >= 0 || *v22 == 17 )
  {
    if ( unlink(v25) >= 0 )
    {
      sub_2F4D0(v25);
      v5 = open(to, 0);
      if ( v5 >= 0 )
      {
LABEL_4:
        v6 = 0;
        while ( 1 )
        {
          v7 = read(v5, &buf, 0x40uLL);
          if ( v7 <= 0 )
            break;
          if ( 64 - v6 < v7 )
            __assert_fail("0 < ret && ret <= SALT_SIZE - i", "unix/uxshare.c", 0xCBu, "make_dirname");
          v6 += v7 + 1;
          if ( v6 > 63 )
          {
            close(v5);
            sub_2F4D0(to);
            v8 = sub_7E030();
            v9 = (void (__fastcall ***)(_QWORD, char *, signed __int64))v8;
            if ( v8 )
              (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v8 + 8LL))(v8, &buf);
            v10 = &v37;
            sub_2EE80(v9[1], &buf, 0x40uLL);
            sub_2EF40(v9[1], v36);
            ((void (__fastcall *)(void (__fastcall ***)(_QWORD, char *, signed __int64), char *))(*v9)[3])(v9, &v37);
            ((void (__fastcall *)(void (__fastcall ***)(_QWORD, char *, signed __int64)))(*v9)[4])(v9);
            v11 = &v39;
            do
            {
              v12 = (unsigned __int8)*v10;
              v13 = v11;
              v11 += 2;
              ++v10;
              __sprintf_chk(v13, 1LL, -1LL, "%02x", v12);
            }
            while ( v11 != &v40 );
            v14 = sub_BC120(&v39);
            sub_BD070(&buf, 0x40uLL);
            v4 = sub_BC360((__int64)"%s/%s", v3, v14, &v39);
            sub_2F4D0(v3);
            sub_2F4D0(v14);
            goto LABEL_13;
          }
        }
        LODWORD(src) = v7;
        close(v5);
        v16 = "unexpected EOF";
        if ( (_DWORD)src )
        {
          v31 = __errno_location();
          v16 = strerror(*v31);
        }
        v17 = to;
        v18 = "%s: read: %s";
        v19 = to;
        goto LABEL_18;
      }
      v21 = *v22;
LABEL_33:
      v17 = to;
      v16 = strerror(v21);
      v18 = "%s: open: %s";
      v19 = to;
LABEL_18:
      *v35 = (__int64)sub_BC360((__int64)v18, v19, v16, src);
      sub_2F4D0(v17);
      sub_2F4D0(v3);
      goto LABEL_13;
    }
    v30 = v25;
    v29 = strerror(*v22);
    v28 = "%s: unlink: %s";
    goto LABEL_36;
  }
  v32 = strerror(*v22);
  *a2 = (__int64)sub_BC360((__int64)"%s: link: %s", to, v32);
  sub_2F4D0(v25);
  sub_2F4D0(to);
  sub_2F4D0(v3);
LABEL_13:
  result = v4;
  if ( __readfsqword(0x28u) != v41 )
    goto LABEL_42;
  return result;
}

signed __int64 __fastcall sub_B98C0(char *a1, __int64 *a2, void (__fastcall ***a3)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD), __int64 a4, __int64 *a5, __int64 *a6, double xmm0_8_0, double xmm1_8_0, double xmm2_8_0, double xmm3_8_0, double a11, double a12, double a13, double a14, void **a7, void **a8, char a9, char a10)
{
  void (__fastcall ***v18)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD); // r13
  void **v19; // rbx
  char *v20; // rax
  char *v21; // r15
  char *v22; // rax
  double v23; // xmm4_8
  double v24; // xmm5_8
  char *v26; // rax
  int *v27; // rax
  char *v28; // rax
  _QWORD *v29; // rax
  void *v30; // rbp
  __int64 v31; // rax
  _QWORD *v32; // rax
  char *v33; // rbp
  __int64 v34; // rax
  int *v35; // rax
  char *v36; // rax
  __int64 v37; // [rsp+8h] [rbp-60h]
  __int64 *v38; // [rsp+10h] [rbp-58h]
  int fd; // [rsp+1Ch] [rbp-4Ch]
  char *v40; // [rsp+20h] [rbp-48h]
  char *v41; // [rsp+28h] [rbp-40h]

  v18 = a3;
  v19 = (void **)a6;
  v37 = a4;
  v38 = a5;
  v20 = sub_B93B0(a1, a6);
  if ( !v20 )
    return 0LL;
  v21 = v20;
  v22 = sub_B5280(v20);
  if ( v22 )
  {
    *v19 = v22;
    sub_2F4D0(v21);
    return 0LL;
  }
  v40 = sub_BC160(v21, xmm0_8_0, xmm1_8_0, xmm2_8_0, xmm3_8_0, v23, v24, a13, a14, "/lock", 0LL);
  fd = open(v40, 578, 384LL);
  if ( fd < 0 )
  {
    v27 = __errno_location();
    v28 = strerror(*v27);
    *v19 = sub_BC360((__int64)"%s: open: %s", v40, v28);
    sub_2F4D0(v21);
    sub_2F4D0(v40);
    return 0LL;
  }
  if ( flock(fd, 2) < 0 )
  {
    v35 = __errno_location();
    v36 = strerror(*v35);
    *v19 = sub_BC360((__int64)"%s: flock(LOCK_EX): %s", v40, v36);
    sub_2F4D0(v21);
    sub_2F4D0(v40);
    close(fd);
    return 0LL;
  }
  v26 = sub_BC360((__int64)"%s/socket", v21);
  v41 = v26;
  *v19 = 0LL;
  if ( a10 )
  {
    v29 = sub_B74A0((__int64)v26);
    v30 = sub_3A8A0((__int64)v29, &locale, 0, 0, 1LL, 0LL, 0LL, v18, a2);
    if ( !(*(__int64 (__fastcall **)(void *, char *))(*(_QWORD *)v30 + 48LL))(v30, &locale) )
    {
      sub_2F4D0(*v19);
      *v19 = v41;
      *v38 = (__int64)v30;
      sub_2F4D0(v21);
      sub_2F4D0(v40);
      close(fd);
      return 1LL;
    }
    sub_2F4D0(*a7);
    v31 = (*(__int64 (__fastcall **)(void *))(*(_QWORD *)v30 + 48LL))(v30);
    *a7 = sub_BC360((__int64)"%s: %s", v41, v31);
    (*(void (__fastcall **)(void *))(*(_QWORD *)v30 + 8LL))(v30);
    if ( !a9 )
      goto LABEL_17;
  }
  else if ( !a9 )
  {
    goto LABEL_10;
  }
  v32 = sub_B74A0((__int64)v41);
  v33 = sub_B7700((__int64)v32, v37);
  if ( (*(__int64 (__fastcall **)(char *, __int64))(*(_QWORD *)v33 + 48LL))(v33, v37) )
  {
    sub_2F4D0(*a8);
    v34 = (*(__int64 (__fastcall **)(char *))(*(_QWORD *)v33 + 48LL))(v33);
    *a8 = sub_BC360((__int64)"%s: %s", v41, v34);
    (*(void (__fastcall **)(char *))(*(_QWORD *)v33 + 8LL))(v33);
LABEL_17:
    if ( *v19 )
    {
LABEL_11:
      sub_2F4D0(v21);
      sub_2F4D0(v40);
      sub_2F4D0(v41);
      close(fd);
      return 0LL;
    }
LABEL_10:
    if ( !*a7 && !*a8 )
      __assert_fail("*logtext || *ds_err || *us_err", "unix/uxshare.c", 0x14Cu, "platform_ssh_share");
    goto LABEL_11;
  }
  sub_2F4D0(*v19);
  *v19 = v41;
  *v38 = (__int64)v33;
  sub_2F4D0(v21);
  sub_2F4D0(v40);
  close(fd);
  return 2LL;
}

unsigned __int64 __fastcall sub_B9C50(char *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  char *v9; // rax
  double v10; // xmm4_8
  double v11; // xmm5_8
  char *v12; // rbx
  char *v13; // rbp
  double v14; // xmm4_8
  double v15; // xmm5_8
  char *v16; // rbp
  void *v18; // [rsp+0h] [rbp-28h]
  unsigned __int64 v19; // [rsp+8h] [rbp-20h]

  v19 = __readfsqword(0x28u);
  v9 = sub_B93B0(a1, (__int64 *)&v18);
  if ( v9 )
  {
    v12 = v9;
    v13 = sub_BC160(v9, a2, a3, a4, a5, v10, v11, a8, a9, "/socket", 0LL);
    remove(v13);
    sub_2F4D0(v13);
    v16 = sub_BC160(v12, a2, a3, a4, a5, v14, v15, a8, a9, "/lock", 0LL);
    remove(v16);
    sub_2F4D0(v16);
    rmdir(v12);
    sub_2F4D0(v12);
  }
  else
  {
    sub_2F4D0(v18);
  }
  return __readfsqword(0x28u) ^ v19;
}

unsigned __int64 __fastcall sub_B9D90(int signo, char a2)
{
  __int64 _0; // [rsp+0h] [rbp+0h]
  unsigned __int64 vars88; // [rsp+88h] [rbp+88h]

  vars88 = __readfsqword(0x28u);
  sigemptyset((sigset_t *)&_0);
  sigaddset((sigset_t *)&_0, signo);
  if ( sigprocmask((unsigned __int8)(a2 ^ 1), (const sigset_t *)&_0, 0LL) < 0 )
  {
    perror("sigprocmask");
    exit(1);
  }
  return __readfsqword(0x28u) ^ vars88;
}

char *__fastcall sub_B9E20(__int64 a1, const char *a2)
{
  char *v2; // rax
  char *v3; // rdi
  char *v5; // rbp
  char *v6; // r12
  char *v7; // rbx
  __uid_t v8; // eax
  struct passwd *v9; // rax
  char *v10; // rax
  char *v11; // rax
  char *v12; // r13
  char *v13; // rbx
  char *v14; // r14
  const char *v15; // rdi
  void *v16; // rbp
  void *v17; // rsi
  const char *v18; // rbx
  __int64 v19; // r13
  void *v20; // rbp
  signed int v21; // esi
  signed __int64 v22; // r12
  char *v23; // rax
  char *v24; // rax

  if ( !(_DWORD)a1 )
  {
    v5 = getenv("PUTTYDIR");
    v3 = v5;
    if ( v5 )
      return sub_BC120(v3);
    v6 = 0LL;
    v7 = getenv("HOME");
    v8 = getuid();
    v9 = getpwuid(v8);
    if ( v9 )
      v6 = v9->pw_dir;
    v10 = getenv(aXdgConfig);
    if ( v10 )
    {
      if ( *v10 )
      {
        v12 = sub_BC360((__int64)"%s/putty", v10);
        if ( v12 )
          goto LABEL_86;
      }
    }
    if ( v7 )
    {
      v11 = sub_BC360((__int64)"%s/.config/putty", v7);
      v12 = v11;
      if ( v11 && !access(v11, 0) )
        return v12;
LABEL_17:
      v13 = sub_BC360((__int64)"%s/.putty", v7);
      if ( v6 )
      {
        v6 = sub_BC360((__int64)"%s/.putty", v6);
        v14 = sub_BC120("/.putty");
        if ( v13 )
        {
          if ( !access(v13, 0) )
            goto LABEL_26;
          v5 = v13;
          v13 = v6;
        }
        else
        {
          v5 = 0LL;
          v13 = v6;
        }
LABEL_21:
        if ( v13 && !access(v13, 0) )
        {
          v6 = v13;
        }
        else
        {
          if ( access(v14, 0) )
          {
            if ( v5 )
            {
              v6 = v13;
              v13 = v5;
              goto LABEL_26;
            }
            if ( v13 )
            {
              v6 = v13;
            }
            else
            {
              v5 = 0LL;
              v6 = 0LL;
              v13 = v14;
            }
            goto LABEL_61;
          }
          v6 = v13;
          v13 = v14;
        }
LABEL_66:
        if ( v13 == v5 )
          goto LABEL_26;
LABEL_61:
        sub_2F4D0(v5);
        goto LABEL_26;
      }
      v23 = sub_BC120("/.putty");
      v14 = v23;
      if ( v13 )
      {
        if ( !access(v13, 0) )
          goto LABEL_27;
        if ( access(v14, 0) )
        {
LABEL_26:
          if ( v13 == v6 )
          {
LABEL_28:
            if ( v13 != v14 )
              sub_2F4D0(v14);
            if ( v13 != v12 )
              sub_2F4D0(v12);
            return v13;
          }
LABEL_27:
          sub_2F4D0(v6);
          goto LABEL_28;
        }
        v5 = v13;
        v13 = v14;
        goto LABEL_66;
      }
      if ( access(v23, 0) )
      {
        v5 = 0LL;
        v13 = v14;
        goto LABEL_61;
      }
      v13 = v14;
LABEL_60:
      v6 = 0LL;
      goto LABEL_61;
    }
    if ( !v6 )
    {
      v24 = sub_BC360((__int64)"%s/.config/putty", &locale);
      v12 = v24;
      if ( v24 )
      {
        v13 = v24;
        if ( !access(v24, 0) )
          return v13;
      }
      goto LABEL_59;
    }
    v12 = sub_BC360((__int64)"%s/.config/putty", v6);
    if ( v12 )
    {
LABEL_86:
      if ( !access(v12, 0) )
        return v12;
      if ( v7 )
        goto LABEL_17;
      if ( !v6 )
      {
LABEL_59:
        v13 = sub_BC120("/.putty");
        v14 = v13;
        access(v13, 0);
        goto LABEL_60;
      }
    }
    v13 = sub_BC360((__int64)"%s/.putty", v6);
    v14 = sub_BC120("/.putty");
    goto LABEL_21;
  }
  if ( (_DWORD)a1 == 4 )
  {
    v2 = getenv("PUTTYSESSIONS");
    if ( v2 )
      goto LABEL_8;
    v15 = "%s/sessions";
    v16 = (void *)sub_B9E20(0LL, 0LL);
    v17 = v16;
LABEL_33:
    v13 = sub_BC360((__int64)v15, v17);
    sub_2F4D0(v16);
    return v13;
  }
  if ( (_DWORD)a1 != 5 )
  {
    switch ( (_DWORD)a1 )
    {
      case 1:
        v2 = getenv("PUTTYSSHHOSTKEYS");
        if ( v2 )
          goto LABEL_8;
        v15 = "%s/sshhostkeys";
        v16 = (void *)sub_B9E20(0LL, 0LL);
        v17 = v16;
        break;
      case 2:
        v15 = "%s.tmp";
        v16 = (void *)sub_B9E20(1LL, 0LL);
        v17 = v16;
        break;
      case 3:
        v2 = getenv("PUTTYRANDOMSEED");
        if ( v2 )
        {
LABEL_8:
          v3 = v2;
          return sub_BC120(v3);
        }
        v15 = "%s/randomseed";
        v16 = (void *)sub_B9E20(0LL, 0LL);
        v17 = v16;
        break;
      default:
        v15 = "%s/ERROR";
        v16 = (void *)sub_B9E20(0LL, 0LL);
        v17 = v16;
        break;
    }
    goto LABEL_33;
  }
  v18 = a2;
  v19 = sub_BC640();
  v20 = (void *)sub_B9E20(4LL, 0LL);
  sub_BC720(v19, (__int64)"%s/", v20);
  sub_2F4D0(v20);
  if ( !a2 || (v21 = *(unsigned __int8 *)a2, !(_BYTE)v21) )
  {
    v18 = "Default Settings";
    v21 = 68;
  }
  v22 = 4503599629467661LL;
  do
  {
    if ( (unsigned __int8)(v21 - 43) <= 0x34u && _bittest64(&v22, (unsigned int)(v21 - 43))
      || (unsigned __int8)(v21 - 48) <= 9u
      || (unsigned __int8)((v21 & 0xDF) - 65) <= 0x19u )
    {
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24), v21);
    }
    else
    {
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24), 37);
      sub_2ECE0(
        (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24),
        a0123456789abcd_3[((const unsigned __int8)*v18 >> 4) & 0xF]);
      sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v19 + 24), a0123456789abcd_3[*v18 & 0xF]);
    }
    v21 = *(unsigned __int8 *)++v18;
  }
  while ( (_BYTE)v21 );
  return (char *)sub_BC6B0((__int64 *)v19);
}

int __fastcall sub_BA370(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

char *__fastcall sub_BA380(char *a1)
{
  __int64 v1; // rax
  char *result; // rax
  char *v3; // [rsp+0h] [rbp-28h]
  unsigned __int64 v4; // [rsp+18h] [rbp-10h]

  v3 = a1;
  v4 = __readfsqword(0x28u);
  if ( qword_326518 && (v1 = sub_9B3D0((__int64 *)qword_326518, (__int64)&v3, 0LL)) != 0 )
    result = *(char **)(v1 + 8);
  else
    result = sub_AA0B0(a1);
  return result;
}

_QWORD *__fastcall sub_BA3F0(const char *a1, _QWORD *a2)
{
  char *v2; // rbx
  char *v3; // rbp
  char *v4; // rbx
  FILE *v5; // rbp
  _QWORD *result; // rax
  int *v7; // rax
  char *v8; // rax

  *a2 = 0LL;
  v2 = sub_B9E20(0LL, 0LL);
  v3 = sub_B53A0((__int64)v2, 0x1C0u);
  if ( v3 || (sub_2F4D0(v2), v2 = sub_B9E20(4LL, 0LL), (v3 = sub_B53A0((__int64)v2, 0x1C0u)) != 0LL) )
  {
    *a2 = sub_BC360((__int64)"Unable to save session: %s", v3);
    sub_2F4D0(v3);
    sub_2F4D0(v2);
    result = 0LL;
  }
  else
  {
    sub_2F4D0(v2);
    v4 = sub_B9E20(5LL, a1);
    v5 = fopen(v4, "w");
    if ( v5 )
    {
      sub_2F4D0(v4);
      result = sub_2F450(1uLL, 8uLL, 0LL);
      *result = v5;
    }
    else
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      *a2 = sub_BC360((__int64)"Unable to save session: open(\"%s\") returned '%s'", v4, v8);
      sub_2F4D0(v4);
      result = 0LL;
    }
  }
  return result;
}

__int64 __fastcall sub_BA520(_QWORD *a1, __int64 a2)
{
  return __fprintf_chk(*a1, 1LL, "%s=%s\n", a2);
}

__int64 __fastcall sub_BA540(_QWORD *a1, __int64 a2)
{
  return __fprintf_chk(*a1, 1LL, "%s=%d\n", a2);
}

void __fastcall sub_BA560(FILE **a1)
{
  fclose(*a1);
  sub_2F4D0(a1);
}

__int64 __fastcall sub_BA580(const char *a1, __int64 a2)
{
  char *v2; // rax
  char *v3; // r13
  char *v4; // rbp
  const char *v5; // rbx
  _QWORD *v6; // r12
  void *v7; // rax
  char *v8; // rax
  __int64 v9; // rbx
  const unsigned __int16 *v10; // rax
  char *v11; // rax
  __int64 *v12; // rdi
  __int64 result; // rax

  v2 = strchr(a1, 58);
  if ( !v2 )
    return __fprintf_chk(stderr, 1LL, "%s: expected a colon in resource string \"%s\"\n", a2);
  v3 = v2;
  v4 = v2 + 1;
  if ( a1 >= v2 )
  {
    v5 = v2;
  }
  else
  {
    v5 = v2;
    if ( (*(v2 - 1) & 0xFB) != 42 )
    {
      do
        --v5;
      while ( a1 != v5 && (*(v5 - 1) & 0xFB) != 42 );
    }
  }
  v6 = sub_2F450(1uLL, 0x10uLL, 0LL);
  v7 = sub_2F450(v4 - v5, 1uLL, 0LL);
  v8 = (char *)memcpy(v7, v5, v4 - v5);
  v8[v4 - v5 - 1] = 0;
  *v6 = v8;
  v9 = (unsigned __int8)v3[1];
  if ( (_BYTE)v9 )
  {
    v10 = *__ctype_b_loc();
    do
    {
      if ( !(v10[v9] & 0x2000) )
        break;
      v9 = (unsigned __int8)*++v4;
    }
    while ( (_BYTE)v9 );
  }
  v11 = sub_BC120(v4);
  v12 = (__int64 *)qword_326518;
  v6[1] = v11;
  if ( !v12 )
  {
    v12 = sub_9AF60((__int64)sub_BA370);
    qword_326518 = (__int64)v12;
  }
  result = sub_9AFD0(v12, (__int64)v6);
  if ( result )
  {
    sub_9B440((__int64 *)qword_326518, result);
    result = sub_9AFD0((__int64 *)qword_326518, (__int64)v6);
  }
  return result;
}

__int64 **__fastcall sub_BA700(const char *a1)
{
  char *v1; // rbx
  FILE *v2; // r12
  __int64 **v3; // r13
  char *v4; // rax
  char *v5; // r15
  _QWORD *v6; // rbp
  char *v7; // rax
  __int64 *v8; // rdi
  char *v9; // rax
  char *v10; // rbx

  v1 = sub_B9E20(5LL, a1);
  v2 = fopen(v1, "r");
  sub_2F4D0(v1);
  if ( !v2 )
    return 0LL;
  v3 = (__int64 **)sub_2F450(1uLL, 8uLL, 0LL);
  *v3 = sub_9AF60((__int64)sub_BA370);
  while ( 1 )
  {
    v9 = sub_BC850(v2);
    v10 = v9;
    if ( !v9 )
      break;
    v4 = strchr(v9, 61);
    if ( v4 )
    {
      v5 = v4 + 1;
      *v4 = 0;
      v4[strcspn(v4 + 1, "\r\n") + 1] = 0;
      v6 = sub_2F450(1uLL, 0x10uLL, 0LL);
      *v6 = sub_BC120(v10);
      v7 = sub_BC120(v5);
      v8 = *v3;
      v6[1] = v7;
      sub_9AFD0(v8, (__int64)v6);
    }
    sub_2F4D0(v10);
  }
  fclose(v2);
  return v3;
}

char *__fastcall sub_BA820(__int64 **a1, char *a2)
{
  __int64 v2; // rax
  char *v3; // rdi
  char *v5; // [rsp+0h] [rbp-28h]
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  v5 = a2;
  if ( a1 )
  {
    v2 = sub_9B3D0(*a1, (__int64)&v5, 0LL);
    if ( v2 )
    {
      v3 = *(char **)(v2 + 8);
      if ( !v3 )
        __assert_fail("val != NULL", "unix/uxstore.c", 0x199u, "read_setting_s");
      return sub_BC120(v3);
    }
  }
  v3 = sub_BA380(a2);
  if ( v3 )
    return sub_BC120(v3);
  return 0LL;
}

__int64 __fastcall sub_BA8C0(__int64 **a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  __int64 v4; // rax
  char *v5; // rdi
  __int64 result; // rax
  char *v7; // [rsp+0h] [rbp-38h]
  unsigned __int64 v8; // [rsp+18h] [rbp-20h]

  v3 = a3;
  v8 = __readfsqword(0x28u);
  v7 = a2;
  if ( a1 )
  {
    v4 = sub_9B3D0(*a1, (__int64)&v7, 0LL);
    if ( v4 )
    {
      v5 = *(char **)(v4 + 8);
      if ( !v5 )
        __assert_fail("val != NULL", "unix/uxstore.c", 0x1ACu, "read_setting_i");
      return strtol(v5, 0LL, 10);
    }
  }
  v5 = sub_BA380(a2);
  result = v3;
  if ( v5 )
    return strtol(v5, 0LL, 10);
  return result;
}

_QWORD *__fastcall sub_BA960(__int64 **a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  char *v10; // rax
  char *v11; // rbp
  char *v12; // rax
  char *v13; // rbx
  char *v14; // rdi
  _QWORD *v15; // r12
  char *v17; // rax
  double v18; // xmm4_8
  double v19; // xmm5_8

  v10 = sub_BC160(a2, a3, a4, a5, a6, a7, a8, a9, a10, "Name", 0LL);
  v11 = v10;
  v12 = sub_BA820(a1, v10);
  if ( v12 )
  {
    v13 = v12;
    v14 = v12;
  }
  else
  {
    sub_2F4D0(v11);
    v17 = sub_BA820(a1, a2);
    v13 = v17;
    if ( !v17 || !*v17 )
    {
      v15 = 0LL;
      sub_2F4D0(v17);
      return v15;
    }
    v11 = sub_BC160("server:", a3, a4, a5, a6, v18, v19, a9, a10, v17, 0LL);
    v14 = v11;
  }
  v15 = sub_B51E0(v14);
  sub_2F4D0(v11);
  sub_2F4D0(v13);
  return v15;
}

_QWORD *__fastcall sub_BAA20(__int64 **a1, char *a2)
{
  char *v2; // rax
  char *v3; // rbx
  _QWORD *v4; // rbp

  v2 = sub_BA820(a1, a2);
  if ( !v2 )
    return 0LL;
  v3 = v2;
  v4 = sub_B4DD0(v2);
  sub_2F4D0(v3);
  return v4;
}

void __fastcall sub_BAA60(_QWORD *a1, char *a2, __int64 *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 *v11; // r12
  char *v12; // rax
  __int64 v13; // r8
  char *v14; // rbx

  v11 = a3;
  v12 = sub_BC160(a2, a4, a5, a6, a7, a8, a9, a10, a11, "Name", 0LL);
  v13 = *v11;
  v14 = v12;
  __fprintf_chk(*a1, 1LL, "%s=%s\n", v12);
  sub_2F4D0(v14);
}

__int64 __fastcall sub_BAAB0(_QWORD *a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // r8

  v3 = *a3;
  return __fprintf_chk(*a1, 1LL, "%s=%s\n", a2);
}

void __fastcall sub_BAAD0(__int64 **a1)
{
  __int64 v1; // rax
  void **v2; // rbx

  if ( a1 )
  {
    while ( 1 )
    {
      v1 = sub_9B010(*a1, 0);
      v2 = (void **)v1;
      if ( !v1 )
        break;
      sub_9B440(*a1, v1);
      sub_2F4D0(*v2);
      sub_2F4D0(v2[1]);
      sub_2F4D0(v2);
    }
    sub_9AF90((_QWORD **)*a1);
    sub_2F4D0(a1);
  }
}

void __fastcall sub_BAB40(const char *a1)
{
  char *v1; // rbx

  v1 = sub_B9E20(5LL, a1);
  unlink(v1);
  sub_2F4D0(v1);
}

_QWORD *sub_BAB70()
{
  char *v0; // rbx
  DIR *v1; // rbp
  _QWORD *result; // rax

  v0 = sub_B9E20(4LL, 0LL);
  v1 = opendir(v0);
  sub_2F4D0(v0);
  result = sub_2F450(1uLL, 8uLL, 0LL);
  *result = v1;
  return result;
}

signed __int64 __fastcall sub_BABC0(DIR **a1, __int64 a2)
{
  signed __int64 result; // rax
  signed __int64 v3; // rbx
  char *v4; // r14
  unsigned __int64 v5; // r15
  struct dirent *v6; // rax
  signed __int64 v7; // r14
  __int64 (__fastcall **i)(_QWORD, char *, signed __int64); // rbp
  char v9; // si
  int v10; // eax
  int v11; // edx
  int v12; // esi
  char v13; // al
  int v14; // eax
  char v15; // dl
  struct stat stat_buf; // [rsp+10h] [rbp-D8h]
  unsigned __int64 v17; // [rsp+A8h] [rbp-40h]

  v17 = __readfsqword(0x28u);
  result = 0LL;
  if ( *a1 )
  {
    v3 = sub_BC640();
    v4 = sub_B9E20(4LL, 0LL);
    strlen(v4);
    sub_2EC30((__int64 (**)(void))(v3 + 24));
    sub_2F4D0(v4);
    sub_2ECE0((__int64 (__fastcall **)(_QWORD, char *, signed __int64))(v3 + 24), 47);
    v5 = *(_QWORD *)(v3 + 16);
    do
    {
      v6 = readdir(*a1);
      if ( !v6 )
      {
        sub_BC660((void **)v3);
        return 0LL;
      }
      v7 = (signed __int64)v6->d_name;
      sub_BC590((__int64 *)v3, v5);
      strlen((const char *)v7);
      sub_2EC30((__int64 (**)(void))(v3 + 24));
    }
    while ( __xstat(1, *(const char **)v3, &stat_buf) < 0 || (stat_buf.st_mode & 0xF000) != 0x8000 );
    for ( i = (__int64 (__fastcall **)(_QWORD, char *, signed __int64))(a2 + 24); ; sub_2ECE0(i, v9) )
    {
      v9 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      while ( v9 == 37 )
      {
        v10 = *(char *)(v7 + 1);
        if ( !*(_BYTE *)(v7 + 1) )
          break;
        v11 = *(char *)(v7 + 2);
        if ( !*(_BYTE *)(v7 + 2) )
          break;
        v12 = v10 - 48;
        v13 = v10 - 55;
        if ( v12 > 9 )
          LOBYTE(v12) = v13;
        v14 = v11 - 48;
        v15 = v11 - 55;
        if ( v14 > 9 )
          LOBYTE(v14) = v15;
        v7 += 3LL;
        sub_2ECE0(i, v14 + 16 * v12);
        v9 = *(_BYTE *)v7;
        if ( !*(_BYTE *)v7 )
          goto LABEL_16;
      }
      ++v7;
    }
LABEL_16:
    sub_BC660((void **)v3);
    result = 1LL;
  }
  return result;
}

void __fastcall sub_BAD80(DIR **a1)
{
  DIR **v1; // rbx
  DIR *v2; // rdi

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    closedir(v2);
  sub_2F4D0(v1);
}

__int64 __fastcall sub_BADA0(const char *a1, unsigned int a2, const char *a3, char *a4)
{
  const char *v4; // rbp
  char *v5; // rbx
  FILE *v6; // r12
  char *v7; // rax
  char *v8; // rbx
  size_t v9; // r15
  const char *v10; // r15
  const char *v11; // r15
  unsigned int v13; // er13
  const char *v14; // [rsp+8h] [rbp-70h]
  size_t s1; // [rsp+10h] [rbp-68h]
  size_t v16; // [rsp+18h] [rbp-60h]
  char s2; // [rsp+20h] [rbp-58h]
  unsigned __int64 v18; // [rsp+38h] [rbp-40h]

  v4 = a3;
  v14 = a4;
  v18 = __readfsqword(0x28u);
  v5 = sub_B9E20(1LL, 0LL);
  v6 = fopen(v5, "r");
  sub_2F4D0(v5);
  if ( v6 )
  {
    while ( 1 )
    {
      v7 = sub_BC850(v6);
      v8 = v7;
      if ( !v7 )
      {
        v13 = 1;
        goto LABEL_14;
      }
      v7[strcspn(v7, "\n")] = 0;
      v9 = (signed int)strlen(v4);
      if ( !strncmp(v8, v4, v9) && v8[v9] == 64 )
      {
        v10 = &v8[v9 + 1];
        __sprintf_chk(&s2, 1LL, 20LL, "%d", a2);
        s1 = (signed int)strlen(&s2);
        if ( !strncmp(v10, &s2, s1) && v10[s1] == 58 )
        {
          v11 = &v10[s1 + 1];
          v16 = (signed int)strlen(a1);
          if ( !strncmp(v11, a1, v16) && v11[v16] == 32 )
            break;
        }
      }
      sub_2F4D0(v8);
    }
    v13 = strcmp(&v11[v16 + 1], v14);
    if ( v13 )
    {
      sub_2F4D0(v8);
      v13 = 2;
    }
    else
    {
      sub_2F4D0(v8);
    }
LABEL_14:
    fclose(v6);
  }
  else
  {
    v13 = 1;
  }
  return v13;
}

bool __fastcall sub_BAFB0(const char *a1, unsigned int a2, const char *a3)
{
  return (unsigned int)sub_BADA0(a1, a2, a3, &locale) != 1;
}

void __fastcall sub_BAFD0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // r15
  char *v6; // r12
  FILE *v7; // rbp
  FILE *v8; // rbx
  char *v9; // r14
  int v10; // eax
  size_t v11; // r15
  char *v12; // rax
  char *v13; // r13
  char *v14; // rdi
  int *v15; // rax
  int v16; // edi
  int *v17; // r13
  char *v18; // rax
  int *v19; // rax
  char *v20; // rax
  char *v21; // rax
  char *v22; // rbx
  char *v23; // rax
  char *v24; // rbp
  char *newa; // [rsp+8h] [rbp-50h]
  __int64 v26; // [rsp+18h] [rbp-40h]

  v4 = a1;
  v5 = a4;
  v26 = a3;
  v6 = sub_B9E20(2LL, 0LL);
  v7 = fopen(v6, "w");
  if ( !v7 )
  {
    v15 = __errno_location();
    v16 = *v15;
    v17 = v15;
    if ( *v15 == 2 )
    {
      v21 = sub_B9E20(0LL, 0LL);
      v22 = v21;
      v23 = sub_B53A0((__int64)v21, 0x1C0u);
      v24 = v23;
      if ( v23 )
      {
        sub_A3150((__int64)"Unable to store host key: %s", v23);
        sub_2F4D0(v24);
        sub_2F4D0(v22);
        v14 = v6;
        goto LABEL_12;
      }
      sub_2F4D0(v22);
      v7 = fopen(v6, "w");
      if ( v7 )
        goto LABEL_2;
      v16 = *v17;
    }
    v18 = strerror(v16);
    sub_A3150((__int64)"Unable to store host key: open(\"%s\") returned '%s'", v6, v18);
    v14 = v6;
    goto LABEL_12;
  }
LABEL_2:
  newa = sub_B9E20(1LL, 0LL);
  v8 = fopen(newa, "r");
  v9 = sub_BC360((__int64)"%s@%d:%s %s\n", v26, a2, v4, v5);
  v10 = strcspn(v9, " ");
  if ( v8 )
  {
    v11 = v10 + 1;
    while ( 1 )
    {
      v12 = sub_BC850(v8);
      v13 = v12;
      if ( !v12 )
        break;
      if ( strncmp(v12, v9, v11) )
        fputs(v13, v7);
      sub_2F4D0(v13);
    }
    fclose(v8);
  }
  fputs(v9, v7);
  fclose(v7);
  if ( rename(v6, newa) < 0 )
  {
    v19 = __errno_location();
    v20 = strerror(*v19);
    sub_A3150((__int64)"Unable to store host key: rename(\"%s\",\"%s\") returned '%s'", v6, newa, v20);
  }
  sub_2F4D0(v6);
  sub_2F4D0(newa);
  v14 = v9;
LABEL_12:
  sub_2F4D0(v14);
}

unsigned __int64 __fastcall sub_BB1F0(void (__fastcall *a1)(__int64 *, _QWORD))
{
  void (__fastcall *v1)(__int64 *, _QWORD); // r12
  char *v2; // rdi
  int v3; // ebp
  unsigned int v4; // eax
  __int64 v6; // [rsp+0h] [rbp-228h]
  unsigned __int64 v7; // [rsp+208h] [rbp-20h]

  v1 = a1;
  v7 = __readfsqword(0x28u);
  v2 = sub_B9E20(3LL, 0LL);
  v3 = open(v2, 0);
  sub_2F4D0(v2);
  if ( v3 >= 0 )
  {
    while ( 1 )
    {
      v4 = read(v3, &v6, 0x200uLL);
      if ( (signed int)v4 <= 0 )
        break;
      v1(&v6, v4);
    }
    close(v3);
  }
  return __readfsqword(0x28u) ^ v7;
}

void __fastcall sub_BB290(void *buf, int a2)
{
  char *v2; // rbp
  int v3; // ebx
  char *v4; // r13
  int v5; // er12
  size_t v6; // rdx
  int v7; // eax
  int *v8; // rax
  char *v9; // rax
  char *v10; // rdi
  int *v11; // rax
  int v12; // edi
  int *v13; // r14
  char *v14; // rax
  char *v15; // rax
  char *v16; // r15
  char *v17; // rax
  char *v18; // r12

  v2 = (char *)buf;
  v3 = a2;
  v4 = sub_B9E20(3LL, 0LL);
  v5 = open(v4, 65, 384LL);
  if ( v5 >= 0 )
  {
LABEL_2:
    v6 = a2;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        v7 = write(v5, v2, v6);
        if ( v7 < 0 )
          break;
        v3 -= v7;
        v6 = v3;
        v2 += v3;
        if ( v3 <= 0 )
          goto LABEL_7;
      }
      v8 = __errno_location();
      v9 = strerror(*v8);
      sub_A3150((__int64)"Unable to write random seed: write returned '%s'", v9);
    }
LABEL_7:
    close(v5);
    goto LABEL_8;
  }
  v11 = __errno_location();
  v12 = *v11;
  v13 = v11;
  if ( *v11 == 2 )
  {
    v15 = sub_B9E20(0LL, 0LL);
    v16 = v15;
    v17 = sub_B53A0((__int64)v15, 0x1C0u);
    v18 = v17;
    if ( v17 )
    {
      sub_A3150((__int64)"Unable to write random seed: %s", v17);
      sub_2F4D0(v18);
      sub_2F4D0(v4);
      v10 = v16;
      goto LABEL_9;
    }
    sub_2F4D0(v16);
    v5 = open(v4, 65, 384LL);
    if ( v5 >= 0 )
      goto LABEL_2;
    v12 = *v13;
  }
  v14 = strerror(v12);
  sub_A3150((__int64)"Unable to write random seed: open(\"%s\") returned '%s'", v4, v14);
LABEL_8:
  v10 = v4;
LABEL_9:
  sub_2F4D0(v10);
}

void nullsub_45()
{
  ;
}

__int64 sub_BB400()
{
  return 0LL;
}

__int64 __fastcall sub_BB410(int a1, __int64 a2, __int64 a3, int a4, __int64 a5, int a6)
{
  __int64 v6; // rdx
  unsigned int v7; // ebp
  const char *v8; // rcx
  int v9; // eax
  int v10; // esi
  int v12; // eax
  const char *v13; // rsi
  wchar_t *v14; // rbx
  bool v15; // zf
  size_t v16; // rax
  int v17; // [rsp+4h] [rbp-34h]
  const char *v18; // [rsp+8h] [rbp-30h]
  mbstate_t p; // [rsp+10h] [rbp-28h]
  unsigned __int64 v20; // [rsp+18h] [rbp-20h]

  v20 = __readfsqword(0x28u);
  v18 = (const char *)a3;
  v17 = a4;
  v6 = a5;
  if ( a1 != 0xFFFF )
  {
    if ( a1 )
      return (unsigned int)sub_1C570(&v18, &v17, a5, a6, a1, 0LL, 0LL, 0);
    v7 = v17;
    if ( v17 > 0 )
    {
      v8 = v18;
      v9 = v17;
      do
      {
        v10 = *(unsigned __int8 *)v8;
        --v9;
        ++v8;
        v6 += 4LL;
        v18 = v8;
        v17 = v9;
        *(_DWORD *)(v6 - 4) = v10 | 0xD800;
      }
      while ( v9 );
      return v7;
    }
    return 0;
  }
  v12 = v17;
  p = 0LL;
  if ( v17 <= 0 )
    return 0;
  v13 = v18;
  v14 = (wchar_t *)a5;
  v7 = 0;
  do
  {
    v16 = mbrtowc(v14, v13, v12, &p);
    if ( v16 + 2 <= 1 )
      break;
    ++v7;
    ++v14;
    v13 = &v18[v16];
    v15 = v17 == (_DWORD)v16;
    v18 += v16;
    v12 = v17 - v16;
    v17 = v12;
  }
  while ( v12 >= 0 && !v15 );
  return v7;
}

__int64 __fastcall sub_BB550(unsigned int a1, __int64 a2, __int64 a3, int a4, __int64 a5, int a6, _BYTE *a7)
{
  int v7; // er13
  __int64 v8; // rbp
  int *v9; // rdx
  int v10; // eax
  int v11; // ebx
  int v12; // esi
  __int64 v13; // rcx
  int v14; // ecx
  wchar_t *v16; // rax
  void *v17; // rdi
  unsigned __int64 v18; // r12
  int v19; // [rsp+4h] [rbp-74h]
  int *v20; // [rsp+8h] [rbp-70h]
  mbstate_t ps; // [rsp+18h] [rbp-60h]
  char src; // [rsp+20h] [rbp-58h]
  unsigned __int64 v23; // [rsp+38h] [rbp-40h]

  v7 = a6;
  v8 = a5;
  v23 = __readfsqword(0x28u);
  v20 = (int *)a3;
  v19 = a4;
  if ( a1 == 0xFFFF )
  {
    ps = 0LL;
    if ( a4 <= 0 )
LABEL_20:
      return 0;
    v16 = (wchar_t *)a3;
    v11 = 0;
    do
    {
      v18 = wcrtomb(&src, *v16, &ps);
      if ( v18 == -1LL )
        break;
      if ( v11 - v7 < v18 )
        break;
      v17 = (void *)(v8 + v11);
      v11 += v18;
      memcpy(v17, &src, v18);
      v16 = v20 + 1;
      ++v20;
      --v19;
    }
    while ( v19 > 0 );
  }
  else
  {
    if ( !a1 )
    {
      if ( a6 > 0 && v19 > 0 )
      {
        v9 = v20;
        v10 = v19 - 1;
        v11 = 0;
        while ( 1 )
        {
          v12 = *v9;
          if ( (unsigned int)(*v9 - 55296) > 0xFF )
          {
            if ( !a7 )
              goto LABEL_11;
            LOBYTE(v12) = *a7;
          }
          v13 = v11++;
          *(_BYTE *)(a5 + v13) = v12;
LABEL_11:
          v14 = v10;
          v19 = v10;
          ++v9;
          --v10;
          if ( v14 <= 0 || v11 >= a6 )
            return (unsigned int)v11;
        }
      }
      goto LABEL_20;
    }
    v11 = sub_1BF60(&v20, &v19, a5, a6, a1, 0LL, (__int64)a7, a7 != 0LL);
  }
  return (unsigned int)v11;
}

_BOOL8 __fastcall sub_BB6E0(__int64 a1, unsigned __int8 *a2, char a3, int a4, int a5)
{
  int v5; // ecx
  __int64 v6; // r15
  int v7; // eax
  void **v8; // rsi
  signed __int64 v9; // rdx
  _BOOL8 result; // rax
  __int64 v11; // r15
  __int64 v12; // rax
  int v13; // eax
  char *v14; // rax
  int v15; // ST10_4
  char *v16; // rax
  int v17; // [rsp+0h] [rbp-68h]
  int v18; // [rsp+0h] [rbp-68h]
  bool v19; // [rsp+Bh] [rbp-5Dh]
  int v20; // [rsp+Ch] [rbp-5Ch]
  int v21; // [rsp+14h] [rbp-54h]
  char *v22; // [rsp+18h] [rbp-50h]
  int v23; // [rsp+20h] [rbp-48h]
  char v24; // [rsp+27h] [rbp-41h]
  unsigned __int64 v25; // [rsp+28h] [rbp-40h]

  v25 = __readfsqword(0x28u);
  v20 = a5;
  *(_QWORD *)(a1 + 12) = 0xFFFFFFFFLL;
  if ( a3 )
  {
    v18 = a4;
    v14 = getenv("LC_ALL");
    a4 = v18;
    if ( v14 && *v14
      || (v14 = getenv("LC_CTYPE"), a4 = v18, v14) && *v14
      || (v14 = getenv("LANG"), a4 = v18, v14) && *v14 )
    {
      v15 = a4;
      v16 = strstr(v14, "UTF-8");
      a4 = v15;
      if ( v16 )
        goto LABEL_4;
    }
    v13 = *(_DWORD *)(a1 + 16);
    if ( v13 )
    {
LABEL_42:
      v5 = v13;
      goto LABEL_5;
    }
  }
  if ( a2 && *a2 )
  {
    v17 = a4;
    v13 = sub_1C0C0(a2);
    *(_DWORD *)(a1 + 16) = v13;
    if ( !v13 )
    {
      v5 = v17;
      *(_DWORD *)(a1 + 16) = v17;
      goto LABEL_5;
    }
    goto LABEL_42;
  }
LABEL_4:
  *(_DWORD *)(a1 + 16) = 55;
  v5 = 55;
LABEL_5:
  v19 = v5 == 0;
  v6 = 0LL;
  while ( 1 )
  {
    v24 = v6;
    v22 = &v24;
    v21 = 1;
    if ( !v5 )
    {
      v7 = v6;
      BYTE1(v7) |= 0xD8u;
      *(_DWORD *)(a1 + 4 * v6 + 1044) = v7;
      goto LABEL_7;
    }
    if ( (unsigned int)sub_1C570(&v22, &v21, (__int64)&v23, 1, v5, 0LL, (__int64)&unk_F5A80, 0) != 1 )
      break;
    *(_DWORD *)(a1 + 4 * v6 + 1044) = v23;
LABEL_7:
    if ( ++v6 == 256 )
      goto LABEL_12;
LABEL_8:
    v5 = *(_DWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 4 * v6++ + 1044) = 65533;
  if ( v6 != 256 )
    goto LABEL_8;
LABEL_12:
  v8 = &off_FA2E0;
  v9 = a1 + 3092;
  if ( v20 == 3 )
    v8 = &off_FA360;
  LODWORD(result) = 0;
LABEL_15:
  if ( (unsigned int)(result - 95) > 0x1F )
  {
    *(_DWORD *)v9 = *(_DWORD *)(v9 - 2048);
    goto LABEL_17;
  }
  do
  {
    *(_DWORD *)v9 = *((_DWORD *)v8 + (result & 0x1F));
LABEL_17:
    LODWORD(result) = result + 1;
    v9 += 4LL;
    if ( (_DWORD)result != 256 )
      goto LABEL_15;
    v11 = 0LL;
    do
    {
      while ( 1 )
      {
        v21 = 1;
        v24 = v11;
        v22 = &v24;
        v8 = (void **)&v21;
        if ( (unsigned int)sub_1C570(&v22, &v21, (__int64)&v23, 1, 17, 0LL, (__int64)&unk_F5A80, 0) == 1 )
          break;
        *(_DWORD *)(a1 + 4 * v11++ + 20) = 65533;
        if ( v11 == 256 )
          goto LABEL_22;
      }
      *(_DWORD *)(a1 + 4 * v11++ + 20) = v23;
    }
    while ( v11 != 256 );
LABEL_22:
    v12 = 0LL;
    do
    {
      while ( 1 )
      {
        v9 = *(unsigned int *)(a1 + 4 * v12 + 1044);
        if ( (unsigned int)(v9 - 127) <= 0x20
          || (signed int)v9 <= 31
          || (unsigned int)(v9 - 55296) <= 0x1F
          || (_DWORD)v9 == 55423 )
        {
          break;
        }
        *(_BYTE *)(a1 + v12++ + 5140) = -1;
        if ( v12 == 256 )
          goto LABEL_29;
      }
      *(_BYTE *)(a1 + v12 + 5140) = v12;
      ++v12;
    }
    while ( v12 != 256 );
LABEL_29:
    result = v19;
  }
  while ( __readfsqword(0x28u) != v25 );
  return result;
}

const char *__fastcall sub_BB9F0(int a1)
{
  void **v1; // rdx
  int v2; // ecx
  int v3; // eax

  if ( !a1 )
    return "Use font encoding";
  v1 = &off_31CEB8;
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 == a1 )
      return (&off_31CEA0)[2 * v3];
    if ( ++v3 == 56 )
      break;
    v2 = *(_DWORD *)v1;
    v1 += 2;
  }
  return 0LL;
}

const char *__fastcall sub_BB9F0(int a1)
{
  void **v1; // rdx
  int v2; // ecx
  int v3; // eax

  if ( !a1 )
    return "Use font encoding";
  v1 = &off_31CEB8;
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 == a1 )
      return (&off_31CEA0)[2 * v3];
    if ( ++v3 == 56 )
      break;
    v2 = *(_DWORD *)v1;
    v1 += 2;
  }
  return 0LL;
}

const char *__fastcall sub_BB9F0(int a1)
{
  void **v1; // rdx
  int v2; // ecx
  int v3; // eax

  if ( !a1 )
    return "Use font encoding";
  v1 = &off_31CEB8;
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 == a1 )
      return (&off_31CEA0)[2 * v3];
    if ( ++v3 == 56 )
      break;
    v2 = *(_DWORD *)v1;
    v1 += 2;
  }
  return 0LL;
}

const char *__fastcall sub_BB9F0(int a1)
{
  void **v1; // rdx
  int v2; // ecx
  int v3; // eax

  if ( !a1 )
    return "Use font encoding";
  v1 = &off_31CEB8;
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 == a1 )
      return (&off_31CEA0)[2 * v3];
    if ( ++v3 == 56 )
      break;
    v2 = *(_DWORD *)v1;
    v1 += 2;
  }
  return 0LL;
}

const char *__fastcall sub_BBA10(int a1)
{
  bool v1; // zf
  const char *result; // rax

  if ( (unsigned int)sub_1C1B0(a1) )
    JUMPOUT(&loc_1C09E);
  v1 = (unsigned int)sub_1C1B0(a1 - 1) == 0;
  result = "Use font encoding";
  if ( v1 )
    result = 0LL;
  return result;
}

const char *__fastcall sub_BB9F0(int a1)
{
  void **v1; // rdx
  int v2; // ecx
  int v3; // eax

  if ( !a1 )
    return "Use font encoding";
  v1 = &off_31CEB8;
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 == a1 )
      return (&off_31CEA0)[2 * v3];
    if ( ++v3 == 56 )
      break;
    v2 = *(_DWORD *)v1;
    v1 += 2;
  }
  return 0LL;
}

__int64 __fastcall sub_BBA50(unsigned __int8 *a1)
{
  __int64 result; // rax

  if ( a1 && *a1 )
    result = sub_1C0C0(a1);
  else
    result = 55LL;
  return result;
}

__int64 __fastcall sub_BBA70(Display *a1, XErrorEvent *a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rdx

  if ( !qword_326528 )
    return qword_326538(a1, a2);
  v2 = ptr;
  v3 = 0LL;
  while ( (Display *)*v2 != a1 || a2->serial != v2[2] || a2->error_code != *((_BYTE *)v2 + 8) )
  {
    ++v3;
    v2 += 3;
    if ( v3 == qword_326528 )
      return qword_326538(a1, a2);
  }
  return 0LL;
}

char *__fastcall sub_BBAD0(__int64 a1, char a2)
{
  __int64 v2; // rbp
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // r9
  char *v5; // rdi
  const __m128i *v6; // rax
  const __m128i *v7; // r8
  signed __int64 v8; // rdx
  __m128i v9; // xmm0
  signed __int64 v10; // rdx
  char *v11; // rax
  __int64 v12; // rcx
  char *result; // rax
  __int64 v14; // rcx

  v2 = a1;
  if ( !qword_326538 )
    qword_326538 = (__int64 (__fastcall *)(_QWORD, _QWORD))XSetErrorHandler((XErrorHandler)sub_BBA70);
  v3 = qword_326528;
  v4 = *(_QWORD *)(a1 + 144);
  v5 = (char *)ptr;
  if ( qword_326528 )
  {
    v6 = (const __m128i *)ptr;
    v3 = 0LL;
    v7 = (const __m128i *)((char *)ptr + 24 * qword_326528);
    do
    {
      while ( v6->m128i_i64[0] != v2 || v6[1].m128i_i64[0] > v4 )
      {
        v8 = 3 * v3;
        v9 = _mm_loadu_si128(v6);
        v6 = (const __m128i *)((char *)v6 + 24);
        ++v3;
        v10 = (signed __int64)&v5[8 * v8];
        *(__m128i *)v10 = v9;
        *(_QWORD *)(v10 + 16) = v6[-1].m128i_i64[1];
        if ( v7 == v6 )
          goto LABEL_9;
      }
      v6 = (const __m128i *)((char *)v6 + 24);
    }
    while ( v7 != v6 );
  }
LABEL_9:
  qword_326528 = v3;
  v11 = (char *)sub_2F4F0(v5, (unsigned __int64 *)&unk_326520, 0x18uLL, v3, 1uLL, 0);
  ptr = v11;
  v12 = 3 * qword_326528++;
  result = &v11[8 * v12];
  result[8] = a2;
  v14 = *(_QWORD *)(v2 + 152);
  *(_QWORD *)result = v2;
  *((_QWORD *)result + 2) = v14 + 1;
  return result;
}

signed __int64 __fastcall sub_BBBD0(int a1)
{
  int v1; // ecx
  signed int v2; // edx
  int v3; // eax
  int v4; // er8

  v1 = 960;
  v2 = -1;
  while ( 1 )
  {
    if ( v1 - v2 <= 1 )
      return 0xFFFFFFFFLL;
    v3 = (v1 + v2) / 2;
    v4 = (unsigned __int16)a00112233445566[2 * v3];
    if ( v4 == a1 )
      break;
    if ( v4 >= a1 )
      v1 = (v1 + v2) / 2;
    if ( v4 < a1 )
      v2 = v3;
  }
  return (unsigned __int16)a00112233445566[2 * v3 + 1];
}

_BYTE *__fastcall sub_BBC30(_BYTE *a1, const char *a2, char a3)
{
  const char *v3; // r12
  int v4; // esi
  _BYTE *v5; // rbx
  char v6; // bp
  _BYTE *v7; // r13
  int v8; // er14

  v3 = a2;
  v4 = (char)*a1;
  if ( *a1 )
  {
    v5 = a1;
    v6 = a3;
    v7 = 0LL;
    v8 = 0;
    while ( 1 )
    {
      while ( (_BYTE)v4 == 91 )
      {
        v4 = (char)*++v5;
        ++v8;
        if ( !*v5 )
          return v7;
      }
      if ( (_BYTE)v4 == 93 )
      {
        if ( v8 )
        {
          --v8;
          goto LABEL_8;
        }
      }
      else if ( (_BYTE)v4 == 58 && v8 )
      {
        goto LABEL_8;
      }
      if ( strchr(v3, v4) )
      {
        v7 = v5;
        if ( v6 )
          return v7;
      }
LABEL_8:
      v4 = (char)*++v5;
      if ( !*v5 )
        return v7;
    }
  }
  return 0LL;
}

_BYTE *__fastcall sub_BBCC0(char a1)
{
  _BYTE *v1; // rax
  _BYTE *v2; // rbx
  _BYTE *v3; // rax

  v1 = sub_2F450(1uLL, 0x38uLL, 0LL);
  v2 = v1;
  v1[48] = a1;
  *((_QWORD *)v1 + 3) = 0LL;
  *((_QWORD *)v1 + 4) = sub_BC560;
  *(_QWORD *)v1 = 512LL;
  *((_QWORD *)v1 + 5) = v1 + 32;
  v3 = sub_2F450(0x200uLL, 1uLL, 0LL);
  *((_QWORD *)v2 + 1) = v3;
  *((_QWORD *)v2 + 2) = v3;
  *v3 = 0;
  return v2 + 8;
}

char *__fastcall sub_BBD30(void *a1, unsigned __int64 a2, unsigned __int64 *a3, __int64 a4, const __m128i *a5)
{
  __int64 v5; // r12
  const __m128i *v6; // r14
  unsigned __int64 v7; // rax
  char *i; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  __m128i v11; // xmm0
  int v12; // eax
  unsigned __int64 *v14; // [rsp+8h] [rbp-70h]
  unsigned __int64 v15; // [rsp+18h] [rbp-60h]
  __m128i v16; // [rsp+20h] [rbp-58h]
  __int64 v17; // [rsp+30h] [rbp-48h]
  unsigned __int64 v18; // [rsp+38h] [rbp-40h]

  v5 = a4;
  v6 = a5;
  v7 = *a3;
  v14 = a3;
  v18 = __readfsqword(0x28u);
  v15 = v7;
  for ( i = (char *)sub_2F4F0(a1, &v15, 1uLL, a2, 0x200uLL, 1); ; i = (char *)sub_2F4F0(i, &v15, 1uLL, v9, v10, 1) )
  {
    v11 = _mm_loadu_si128(v6);
    v17 = v6[1].m128i_i64[0];
    v16 = v11;
    v12 = __vsnprintf_chk(&i[a2], v15 - a2, 1LL, -1LL, v5, &v16);
    v9 = v15;
    if ( v12 < 0 )
      goto LABEL_7;
    v9 = v15;
    v10 = v12;
    if ( v12 < v15 )
      break;
    if ( v12 )
    {
      v9 = a2 + 1;
      continue;
    }
LABEL_7:
    v10 = 1LL;
  }
  *v14 = v15;
  return i;
}

void __noreturn sub_BBE50()
{
  __assert_fail(
    "false && \"bufchain callback used while uninitialised\"",
    "utils.c",
    0x2A0u,
    "uninitialised_queue_idempotent_callback");
}

__int64 __fastcall sub_BBE80(void *a1, size_t a2)
{
  unsigned __int8 *v2; // rax
  unsigned __int8 *v3; // rcx
  __int64 result; // rax

  v2 = (unsigned __int8 *)memset(a1, 0, a2);
  v3 = v2;
  for ( result = *v2; (_BYTE)result; result = *v3 )
    ++v3;
  return result;
}

unsigned __int64 __fastcall sub_BBEB0(const char *a1)
{
  unsigned __int64 v1; // rax
  _BYTE *v2; // rbx
  unsigned __int64 v3; // r12
  unsigned __int8 v4; // bp
  const unsigned __int16 *v5; // rcx
  _BYTE *v6; // rax
  char v7; // cl
  signed __int64 v8; // rax
  _BYTE *v10; // [rsp+0h] [rbp-28h]
  unsigned __int64 v11; // [rsp+8h] [rbp-20h]

  v11 = __readfsqword(0x28u);
  v1 = strtoul(a1, &v10, 10);
  v2 = v10;
  v3 = v1;
  v4 = *v10;
  if ( *v10 )
  {
    v5 = *__ctype_b_loc();
    v6 = v2 + 1;
    while ( v5[v4] & 0x2000 )
    {
      v10 = v6++;
      v4 = *(v6 - 1);
      if ( !v4 )
        return v3;
    }
    v7 = v4 - 71;
    if ( (unsigned __int8)(v4 - 71) <= 0x26u )
    {
      v8 = 1LL << v7;
      if ( (1LL << v7) & 0x100000001LL )
      {
        v3 <<= 30;
      }
      else if ( v8 & 0x4000000040LL )
      {
        v3 <<= 20;
      }
      else if ( v8 & 0x1000000010LL )
      {
        v3 <<= 10;
      }
    }
  }
  return v3;
}

__int64 __fastcall sub_BBFA0(const char *a1, char **a2)
{
  __int64 result; // rax
  int v3; // edx
  char *v4; // rdx

  result = *(unsigned __int8 *)a1;
  if ( (_BYTE)result != 94 )
    goto LABEL_2;
  v3 = *((unsigned __int8 *)a1 + 1);
  if ( !(_BYTE)v3 )
    goto LABEL_2;
  if ( (_BYTE)v3 == 60 )
  {
    result = strtol(a1 + 2, a2, 0);
    v4 = *a2;
    if ( *a2 != a1 + 2 && *v4 == 62 )
    {
      *a2 = v4 + 1;
      return result;
    }
LABEL_2:
    *a2 = 0LL;
    return 0LL;
  }
  if ( (unsigned __int8)(v3 - 97) <= 0x19u )
  {
    result = (unsigned int)(v3 - 96);
    *a2 = (char *)(a1 + 2);
  }
  else if ( (unsigned __int8)(v3 - 63) <= 0x20u || (v3 & 0x80u) != 0 )
  {
    result = v3 ^ 0x40u;
    *a2 = (char *)(a1 + 2);
  }
  else if ( (_BYTE)v3 == 126 )
  {
    *a2 = (char *)(a1 + 2);
  }
  else
  {
    result = 0LL;
  }
  return result;
}

size_t __fastcall sub_BC050(char *s, const char *a2)
{
  _BYTE *v2; // rax
  size_t result; // rax

  v2 = sub_BBC30(s, a2, 1);
  if ( v2 )
    result = v2 - s;
  else
    result = strlen(s);
  return result;
}

_BYTE *__fastcall sub_BC080(_BYTE *a1, char a2)
{
  char v3; // [rsp+6h] [rbp-12h]
  char v4; // [rsp+7h] [rbp-11h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v3 = a2;
  v4 = 0;
  v5 = __readfsqword(0x28u);
  return sub_BBC30(a1, &v3, 1);
}

_BYTE *__fastcall sub_BC0D0(_BYTE *a1, char a2)
{
  char v3; // [rsp+6h] [rbp-12h]
  char v4; // [rsp+7h] [rbp-11h]
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v3 = a2;
  v4 = 0;
  v5 = __readfsqword(0x28u);
  return sub_BBC30(a1, &v3, 0);
}

char *__fastcall sub_BC120(char *src)
{
  int v1; // eax
  char *v2; // rax

  if ( !src )
    return 0LL;
  v1 = strlen(src);
  v2 = (char *)sub_2F450(v1 + 1, 1uLL, 0LL);
  return strcpy(v2, src);
}

char *sub_BC160(char *src, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, ...)
{
  int i; // ebx
  const char **v10; // rdx
  char *v11; // rbx
  char *result; // rax
  const char **v13; // rcx
  unsigned __int64 v14; // rt1
  gcc_va_list va; // [rsp+0h] [rbp-68h]
  unsigned __int64 v16; // [rsp+18h] [rbp-50h]

  va_start(va, a9);
  v16 = __readfsqword(0x28u);
  for ( i = strlen(src); ; i += strlen(*v10) )
  {
    if ( va[0].gp_offset > 0x2F )
    {
      v10 = (const char **)va[0].overflow_arg_area;
      va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
    }
    else
    {
      v10 = (const char **)((char *)va[0].reg_save_area + va[0].gp_offset);
      va[0].gp_offset += 8;
    }
    if ( !*v10 )
      break;
  }
  v11 = (char *)sub_2F450(i + 1, 1uLL, 0LL);
  result = stpcpy(v11, src);
  va_end(va);
  va_start(va, a9);
LABEL_7:
  if ( va[0].gp_offset <= 0x2F )
  {
    v13 = (const char **)((char *)va[0].reg_save_area + va[0].gp_offset);
    va[0].gp_offset += 8;
    goto LABEL_9;
  }
  do
  {
    v13 = (const char **)va[0].overflow_arg_area;
    va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
LABEL_9:
    if ( *v13 )
    {
      result = stpcpy(result, *v13);
      goto LABEL_7;
    }
    result = v11;
    v14 = __readfsqword(0x28u);
    v11 = (char *)(v14 ^ v16);
  }
  while ( v14 != v16 );
  return result;
}

signed __int64 __fastcall sub_BC2F0(unsigned __int64 a1)
{
  signed __int64 result; // rax

  result = 0x7FFFFFFFLL;
  if ( a1 <= 0x7FFFFFFF )
    result = a1;
  return result;
}

char *__fastcall sub_BC310(__int64 a1, const __m128i *a2)
{
  __int64 v3; // [rsp+0h] [rbp-18h]
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  v3 = 0LL;
  return sub_BBD30(0LL, 0LL, (unsigned __int64 *)&v3, a1, a2);
}

char *sub_BC360(__int64 a1, ...)
{
  __int64 v2; // [rsp+8h] [rbp-E0h]
  gcc_va_list va; // [rsp+10h] [rbp-D8h]
  unsigned __int64 v4; // [rsp+28h] [rbp-C0h]

  va_start(va, a1);
  v4 = __readfsqword(0x28u);
  v2 = 0LL;
  return sub_BBD30(0LL, 0LL, (unsigned __int64 *)&v2, a1, (const __m128i *)va);
}

char *__fastcall sub_BC440(char *src)
{
  unsigned __int8 v1; // bl
  char *v2; // rbp
  const unsigned __int16 *v3; // rdx
  signed int v4; // er13
  char *result; // rax

  if ( *src != 91 )
    goto LABEL_20;
  v1 = src[1];
  if ( v1 != 93 && v1 )
  {
    v2 = src + 1;
    v3 = *__ctype_b_loc();
    v4 = 0;
    do
    {
      if ( !(v3[v1] & 0x1000) )
      {
        if ( v1 != 58 )
          break;
        ++v4;
      }
      v1 = *++v2;
    }
    while ( *v2 && v1 != 93 );
  }
  else
  {
    v2 = src + 1;
    v4 = 0;
  }
  if ( v1 == 37 )
    v2 += strcspn(v2, "]");
  if ( *v2 != 93 || v2[1] || v4 <= 1 )
LABEL_20:
    result = sub_BC120(src);
  else
    result = sub_BC360((__int64)"%.*s", v2 - (src + 1), src + 1);
  return result;
}

char *__fastcall sub_BC510(__int64 a1, unsigned __int64 a2)
{
  _BYTE *v2; // rax
  __int64 v3; // rdx

  v2 = sub_2F4F0(*(void **)a1, (unsigned __int64 *)(a1 - 8), 1uLL, *(_QWORD *)(a1 + 16) + 1LL, a2, *(_BYTE *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = v2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_QWORD *)(a1 + 16) = v3 + a2;
  v2[v3 + a2] = 0;
  return &v2[v3];
}

void *__fastcall sub_BC560(__int64 a1, const void *a2, unsigned __int64 a3)
{
  size_t v3; // rbx
  char *v4; // rax

  v3 = a3;
  v4 = sub_BC510(a1 - 24, a3);
  return memcpy(v4, a2, v3);
}

__int64 __fastcall sub_BC590(__int64 *a1, unsigned __int64 a2)
{
  __int64 result; // rax

  if ( a1[2] < a2 )
    __assert_fail("new_len <= buf->len", "utils.c", 0x1B3u, "strbuf_shrink_to");
  result = *a1;
  a1[2] = a2;
  *(_BYTE *)(result + a2) = 0;
  return result;
}

__int64 __fastcall sub_BC5D0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rdx
  __int64 result; // rax

  v2 = a1[2];
  if ( v2 < a2 )
    __assert_fail("amount_to_remove <= buf->len", "utils.c", 0x1BAu, "strbuf_shrink_by");
  v3 = *a1;
  result = v2 - a2;
  a1[2] = result;
  *(_BYTE *)(v3 + result) = 0;
  return result;
}

signed __int64 __fastcall sub_BC610(_QWORD *a1, char a2)
{
  __int64 v2; // rdx
  signed __int64 result; // rax
  signed __int64 v4; // rdx
  _BYTE *v5; // rcx

  v2 = a1[2];
  result = 0LL;
  if ( v2 )
  {
    v4 = v2 - 1;
    v5 = (_BYTE *)(v4 + *a1);
    if ( *v5 == a2 )
    {
      a1[2] = v4;
      result = 1LL;
      *v5 = 0;
    }
  }
  return result;
}

_BYTE *sub_BC640()
{
  return sub_BBCC0(0);
}

_BYTE *sub_BC650()
{
  return sub_BBCC0(1);
}

void __fastcall sub_BC660(void **a1)
{
  void **v1; // rbp
  void **v2; // rbx
  void *v3; // rdi
  size_t v4; // rsi

  v1 = a1 - 1;
  v2 = a1;
  v3 = *a1;
  if ( v3 )
  {
    v4 = (size_t)*(v2 - 1);
    if ( v4 )
    {
      sub_BBE80(v3, v4);
      v3 = *v2;
    }
    sub_2F4D0(v3);
  }
  sub_2F4D0(v1);
}

__int64 __fastcall sub_BC6B0(__int64 *a1)
{
  __int64 v1; // rbx

  v1 = *a1;
  sub_2F4D0(a1 - 1);
  return v1;
}

size_t __fastcall sub_BC6D0(__int64 a1, __int64 a2, const __m128i *a3)
{
  char *v3; // rax
  __int64 v4; // rbp
  size_t result; // rax

  v3 = sub_BBD30(*(void **)a1, *(_QWORD *)(a1 + 16), (unsigned __int64 *)(a1 - 8), a2, a3);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) = v3;
  result = strlen(&v3[v4]);
  *(_QWORD *)(a1 + 16) = result + v4;
  return result;
}

unsigned __int64 sub_BC720(__int64 a1, __int64 a2, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h]
  unsigned __int64 v4; // [rsp+18h] [rbp-C0h]

  va_start(va, a2);
  v4 = __readfsqword(0x28u);
  sub_BC6D0(a1, a2, (const __m128i *)va);
  return __readfsqword(0x28u) ^ v4;
}

_BYTE *sub_BC7E0()
{
  _BYTE *v0; // rbx

  v0 = sub_BBCC0(0);
  sub_BC510((__int64)v0, 4uLL);
  return v0;
}

__int64 __fastcall sub_BC800(__int64 a1)
{
  unsigned __int64 v1; // rax
  _BYTE *v2; // rdx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 <= 4 )
    __assert_fail("buf->visible.len >= 5", "utils.c", 0x204u, "strbuf_finalise_agent_query");
  v2 = *(_BYTE **)(a1 + 8);
  v3 = v1 - 4;
  v4 = v3 >> 16;
  v2[3] = v3;
  v2[2] = BYTE1(v3);
  result = v3 >> 24;
  v2[1] = v4;
  *v2 = result;
  return result;
}

char *__fastcall sub_BC850(FILE *stream)
{
  unsigned __int64 v1; // rbx
  char *v2; // rbp
  signed int v3; // esi
  char *v4; // rax
  char *v5; // r14
  char *v7; // rdi
  __int64 v8; // [rsp+0h] [rbp-38h]
  unsigned __int64 v9; // [rsp+8h] [rbp-30h]

  v1 = 0LL;
  v9 = __readfsqword(0x28u);
  v8 = 512LL;
  v2 = (char *)sub_2F450(0x200uLL, 1uLL, 0LL);
  v3 = 512;
  while ( 1 )
  {
    v5 = &v2[v1];
    if ( !fgets(&v2[v1], v3 - (signed int)v1, stream) )
      break;
    v1 += strlen(&v2[v1]);
    if ( v1 && v2[v1 - 1] == 10 )
    {
      v5 = &v2[v1];
      goto LABEL_7;
    }
    v4 = (char *)sub_2F4F0(v2, (unsigned __int64 *)&v8, 1uLL, v1, 0x200uLL, 1);
    v3 = v8;
    v2 = v4;
  }
  if ( v1 )
  {
LABEL_7:
    *v5 = 0;
    return v2;
  }
  v7 = v2;
  v2 = 0LL;
  sub_2F4D0(v7);
  return v2;
}

__int64 __fastcall sub_BCA40(unsigned __int8 *a1, signed int a2, char *a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // esi
  __int64 result; // rax
  char v8; // cl
  int v9; // esi

  v3 = *a1 << 16;
  if ( a2 <= 1 )
  {
    a3[2] = 61;
    v8 = aAbcdefghijklmn[v3 >> 18];
    result = (unsigned __int8)aAbcdefghijklmn[(v3 >> 12) & 0x30];
    a3[3] = 61;
    *a3 = v8;
    a3[1] = result;
  }
  else
  {
    v4 = (a1[1] << 8) | (*a1 << 16);
    if ( a2 == 2 )
    {
      a3[3] = 61;
      *a3 = aAbcdefghijklmn[v4 >> 18];
      v9 = (v4 >> 12) & 0x3F;
      result = (unsigned __int8)aAbcdefghijklmn[(v4 >> 6) & 0x3C];
      LOBYTE(v9) = aAbcdefghijklmn[v9];
      a3[2] = result;
      a3[1] = v9;
    }
    else
    {
      v5 = a1[2] | v4;
      *a3 = aAbcdefghijklmn[v5 >> 18];
      a3[1] = aAbcdefghijklmn[(v5 >> 12) & 0x3F];
      v6 = v5;
      result = (unsigned __int8)aAbcdefghijklmn[v5 & 0x3F];
      LOBYTE(v6) = aAbcdefghijklmn[(v6 >> 6) & 0x3F];
      a3[3] = result;
      a3[2] = v6;
    }
  }
  return result;
}

signed __int64 __fastcall sub_BCB10(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rdx
  int v3; // eax
  int v4; // eax
  signed __int64 result; // rax
  int v6; // edx
  int v7; // [rsp+0h] [rbp-28h]
  int v8; // [rsp+4h] [rbp-24h]
  int v9; // [rsp+8h] [rbp-20h]
  int v10; // [rsp+Ch] [rbp-1Ch]
  unsigned __int64 v11; // [rsp+18h] [rbp-10h]

  v2 = 0LL;
  v11 = __readfsqword(0x28u);
  do
  {
    v3 = *(char *)(a1 + v2);
    if ( (unsigned __int8)(*(_BYTE *)(a1 + v2) - 65) > 0x19u )
    {
      if ( (unsigned __int8)(v3 - 97) > 0x19u )
      {
        if ( (unsigned __int8)(v3 - 48) <= 9u )
        {
          v4 = v3 + 4;
        }
        else
        {
          switch ( (_BYTE)v3 )
          {
            case 0x2B:
              v4 = 62;
              break;
            case 0x2F:
              v4 = 63;
              break;
            case 0x3D:
              v4 = -1;
              break;
            default:
              return 0LL;
          }
        }
      }
      else
      {
        v4 = v3 - 71;
      }
    }
    else
    {
      v4 = v3 - 65;
    }
    *(&v7 + v2++) = v4;
  }
  while ( v2 != 4 );
  if ( v7 == -1 || v8 == -1 )
    return 0LL;
  if ( v9 == -1 )
  {
    if ( v10 == -1 )
    {
      result = 1LL;
      *a2 = ((v8 << 12) | (unsigned int)(v7 << 18)) >> 16;
      return result;
    }
    return 0LL;
  }
  result = (unsigned int)(v10 != -1) + 2;
  v6 = ((_WORD)v9 << 6) & 0xFC0 | v10 & 0x3F | (v8 << 12) | (v7 << 18);
  a2[1] = BYTE1(v6);
  *a2 = BYTE2(v6);
  if ( (_DWORD)result != 3 )
    return 2LL;
  a2[2] = v6;
  return result;
}

void (__noreturn *__fastcall sub_BCC70(_QWORD *a1))()
{
  void (__noreturn *result)(); // rax

  result = sub_BBE50;
  a1[1] = 0LL;
  *a1 = 0LL;
  a1[2] = 0LL;
  a1[4] = 0LL;
  a1[3] = sub_BBE50;
  return result;
}

void __fastcall sub_BCCA0(__int64 a1)
{
  _QWORD *i; // rbx

  for ( i = *(_QWORD **)a1; *(_QWORD *)a1; i = *(_QWORD **)a1 )
  {
    *(_QWORD *)a1 = *i;
    sub_BBE80(i, 0x20uLL);
    sub_2F4D0(i);
  }
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
}

__int64 __fastcall sub_BCD00(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

void __fastcall sub_BCD10(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a2;
}

void __fastcall sub_BCD20(__int64 a1, char *a2, size_t a3)
{
  __int64 v3; // r14
  size_t v4; // r13
  __int64 v5; // rax
  char *v6; // rbp
  void *v7; // rdi
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbx
  _QWORD *v10; // rax
  _QWORD *v11; // rdx
  size_t v12; // rax
  size_t v13; // rbx

  if ( a3 )
  {
    v3 = a1;
    v4 = a3;
    v5 = *(_QWORD *)(a1 + 8);
    v6 = a2;
    *(_QWORD *)(a1 + 16) += a3;
    if ( v5 )
    {
      v7 = *(void **)(v5 + 16);
      v8 = *(_QWORD *)(v5 + 24);
      if ( (unsigned __int64)v7 < v8 )
        goto LABEL_10;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = v4 + 32;
        if ( v4 + 32 < 0x200 )
          v9 = 512LL;
        v10 = sub_2F450(v9, 1uLL, 0LL);
        *v10 = 0LL;
        v10[3] = (char *)v10 + v9;
        v10[2] = v10 + 4;
        v10[1] = v10 + 4;
        v11 = *(_QWORD **)(v3 + 8);
        if ( v11 )
          *v11 = v10;
        else
          *(_QWORD *)v3 = v10;
        *(_QWORD *)(v3 + 8) = v10;
        if ( v10 )
        {
          v7 = (void *)v10[2];
          v8 = v10[3];
          if ( (unsigned __int64)v7 < v8 )
            break;
        }
      }
LABEL_10:
      v12 = v8 - (_QWORD)v7;
      if ( v12 > v4 )
        v12 = v4;
      v13 = v12;
      memcpy(v7, v6, v12);
      *(_QWORD *)(*(_QWORD *)(v3 + 8) + 16LL) += v13;
      v4 -= v13;
      if ( !v4 )
        break;
      v6 += v13;
    }
    if ( *(_QWORD *)(v3 + 32) )
      (*(void (**)(void))(v3 + 24))();
  }
}

void __fastcall sub_BCE20(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r12
  _QWORD *v3; // rbx
  __int64 v4; // rax
  bool v5; // zf
  __int64 v6; // rdx
  __int64 v7; // rbp

  if ( *(_QWORD *)(a1 + 16) < a2 )
    __assert_fail("ch->buffersize >= len", "utils.c", 0x2EEu, "bufchain_consume");
  v2 = a2;
  if ( a2 )
  {
    v3 = *(_QWORD **)a1;
    v4 = (signed int)a2;
    if ( !*(_QWORD *)a1 )
LABEL_12:
      __assert_fail("ch->head != NULL", "utils.c", 0x2F1u, "bufchain_consume");
    while ( 1 )
    {
      v6 = v3[1];
      v7 = v3[2] - v6;
      if ( v4 >= v7 )
      {
        v5 = *v3 == 0LL;
        *(_QWORD *)a1 = *v3;
        if ( v5 )
          *(_QWORD *)(a1 + 8) = 0LL;
        sub_BBE80(v3, 0x20uLL);
        sub_2F4D0(v3);
        *(_QWORD *)(a1 + 16) -= (signed int)v7;
        v2 -= (signed int)v7;
        if ( !v2 )
          return;
      }
      else
      {
        v3[1] = v4 + v6;
        *(_QWORD *)(a1 + 16) -= v4;
        v2 -= v4;
        if ( !v2 )
          return;
      }
      v3 = *(_QWORD **)a1;
      v4 = (signed int)v2;
      if ( !*(_QWORD *)a1 )
        goto LABEL_12;
    }
  }
}

__int64 __fastcall sub_BCF00(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rdx

  result = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  v2 = *(_QWORD *)(*(_QWORD *)a1 + 16LL);
  return result;
}

void __fastcall sub_BCF10(__int64 a1, char *a2, unsigned __int64 a3)
{
  _QWORD *v3; // rbp
  unsigned __int64 v4; // r12
  char *v5; // rcx
  signed __int64 v6; // rbx
  const void *v7; // rsi
  signed __int64 v8; // rax
  char *v9; // rax

  v3 = *(_QWORD **)a1;
  if ( *(_QWORD *)(a1 + 16) < a3 )
    __assert_fail("ch->buffersize >= len", "utils.c", 0x30Du, "bufchain_fetch");
  v4 = a3;
  if ( a3 )
  {
    v5 = a2;
    v6 = (signed int)a3;
    if ( !v3 )
LABEL_10:
      __assert_fail("tmp != NULL", "utils.c", 0x311u, "bufchain_fetch");
    while ( 1 )
    {
      v7 = (const void *)v3[1];
      v8 = v3[2] - (_QWORD)v7;
      if ( v6 >= v8 )
        v6 = (signed int)v8;
      v9 = (char *)memcpy(v5, v7, v6);
      v3 = (_QWORD *)*v3;
      v5 = &v9[v6];
      v4 -= v6;
      if ( !v4 )
        break;
      v6 = (signed int)v4;
      if ( !v3 )
        goto LABEL_10;
    }
  }
}

void __fastcall sub_BCFC0(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp

  v3 = a3;
  sub_BCF10(a1, a2, a3);
  sub_BCE20(a1, v3);
}

signed __int64 __fastcall sub_BCFF0(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rbp

  if ( *(_QWORD *)(a1 + 16) < a3 )
    return 0LL;
  v4 = a3;
  sub_BCF10(a1, a2, a3);
  sub_BCE20(a1, v4);
  return 1LL;
}

unsigned __int64 __fastcall sub_BD030(__int64 a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx

  v3 = a3;
  if ( *(_QWORD *)(a1 + 16) <= a3 )
    v3 = *(_QWORD *)(a1 + 16);
  if ( v3 )
  {
    sub_BCF10(a1, a2, v3);
    sub_BCE20(a1, v3);
  }
  return v3;
}

__int64 __fastcall sub_BD070(void *a1, size_t a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( a2 )
      result = sub_BBE80(a1, a2);
  }
  return result;
}

signed __int64 __fastcall sub_BD090(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  int v4; // er8
  unsigned __int8 v5; // al

  if ( !a3 )
    return 1LL;
  v3 = 0LL;
  v4 = 0;
  do
  {
    v5 = *(_BYTE *)(a2 + v3) ^ *(_BYTE *)(a1 + v3);
    ++v3;
    v4 |= v5;
  }
  while ( a3 != v3 );
  return ((unsigned int)(256 - v4) >> 8) & 1;
}

int __fastcall sub_BD0D0(const char *a1, const char *a2)
{
  int result; // eax

  if ( a1 || (result = 0, a2) )
  {
    if ( a1 )
    {
      if ( a2 )
        result = strcmp(a1, a2);
      else
        result = 1;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}

__int64 __fastcall sub_BD100(void *s1, size_t n, void *s2)
{
  void *v3; // rbx
  size_t v4; // rax
  unsigned int v5; // edx

  v3 = s2;
  v4 = strlen((const char *)s2);
  v5 = 0;
  if ( n == v4 )
    LOBYTE(v5) = memcmp(s1, v3, n) == 0;
  return v5;
}

bool __fastcall sub_BD140(const void *a1, __int64 a2, const void *a3, size_t a4)
{
  bool result; // al

  if ( a4 == a2 )
    result = memcmp(a1, a3, a4) == 0;
  else
    result = 0;
  return result;
}

signed int __fastcall sub_BD170(const void *a1, size_t a2, const void *a3, size_t a4)
{
  size_t v4; // rbp
  const void *v5; // rsi
  size_t v6; // rdx
  size_t v7; // rbx
  signed int result; // eax

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = a4;
  if ( v4 <= a4 )
    v6 = v4;
  if ( !v6 || (result = memcmp(a1, v5, v6)) == 0 )
  {
    if ( v4 < v7 )
      result = -1;
    else
      result = v4 > v7;
  }
  return result;
}

__int64 __fastcall sub_BD220(__int64 a1, unsigned __int64 a2, const void *a3, size_t a4, _QWORD *a5)
{
  unsigned int v5; // er12
  _QWORD *v6; // r13
  size_t v7; // rbx

  v5 = 0;
  if ( a2 >= a4 )
  {
    v6 = a5;
    v7 = a2 - a4;
    if ( !memcmp((const void *)(a1 + a2 - a4), a3, a4) )
    {
      v5 = 1;
      if ( v6 )
      {
        *v6 = a1;
        v6[1] = v7;
      }
    }
  }
  return v5;
}

_BYTE *__fastcall sub_BD360(void *src, size_t n)
{
  void *v2; // rax
  _BYTE *result; // rax

  v2 = sub_2F450(n + 1, 1uLL, 0LL);
  result = memcpy(v2, src, n);
  result[n] = 0;
  return result;
}

bool __fastcall sub_BD3A0(char *s1, char *s2)
{
  size_t v2; // rax

  v2 = strlen(s2);
  return strncmp(s1, s2, v2) == 0;
}

signed __int64 __fastcall sub_BD410(_BYTE *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rax
  char v3; // dl
  unsigned __int64 v4; // rcx
  char v5; // al
  signed __int64 result; // rax

  if ( a2 <= 0x7F )
  {
    *a1 = a2;
    result = 1LL;
  }
  else
  {
    v2 = a2 >> 6;
    v3 = a2 & 0x3F | 0x80;
    if ( a2 <= 0x7FF )
    {
      a1[1] = v3;
      *a1 = v2 | 0xC0;
      result = 2LL;
    }
    else
    {
      v4 = a2 >> 12;
      v5 = v2 & 0x3F | 0x80;
      if ( a2 <= 0xFFFF )
      {
        a1[1] = v5;
        *a1 = v4 | 0xE0;
        a1[2] = v3;
        result = 3LL;
      }
      else
      {
        a1[2] = v5;
        *a1 = (a2 >> 18) | 0xF0;
        a1[1] = v4 & 0x3F | 0x80;
        a1[3] = v3;
        result = 4LL;
      }
    }
  }
  return result;
}

__int64 __fastcall sub_BD620(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  return ((__int64 (*)(void))((char *)dword_FD500 + dword_FD500[a4 & 0xF]))();
}

_BOOL8 __fastcall sub_BD840(__int64 a1)
{
  _BOOL8 result; // rax

  result = *(_QWORD *)(a1 + 8) != 0LL;
  if ( !*(_QWORD *)(a1 + 8 * result) )
    sub_1B052();
  return result;
}

signed __int64 __fastcall sub_BD860(unsigned int a1, __int64 a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  unsigned int *v5; // r8

  v3 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v4 = (a3 + v3) >> 1;
      v5 = (unsigned int *)(a2 + 8LL * v4);
      if ( v5[1] >= a1 )
        break;
      v3 = v4 + 1;
      if ( v4 + 1 > a3 )
        return 0LL;
    }
    if ( a1 >= *v5 )
      break;
    a3 = v4 - 1;
    if ( v3 > v4 - 1 )
      return 0LL;
  }
  return 1LL;
}

signed __int64 __fastcall sub_BD8A0(unsigned int a1)
{
  signed __int64 result; // rax
  unsigned int v2; // er9
  char v3; // dl

  result = 0LL;
  if ( a1 )
  {
    if ( a1 - 127 <= 0x20 || a1 <= 0x1F )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      result = 1LL;
      if ( a1 > 0x2FF )
      {
        v2 = a1;
        if ( a1 > (unsigned int)&unk_E01EF || (v3 = sub_BD860(a1, (__int64)&off_FDFE0, 141), result = 0LL, !v3) )
        {
          result = 1LL;
          if ( v2 - 4352 <= (unsigned int)&loc_3EEFD )
            result = (unsigned int)((unsigned __int8)sub_BD860(v2, (__int64)&off_FDC40, 115) != 0) + 1;
        }
      }
    }
  }
  return result;
}

__int64 __fastcall sub_BD940(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // rbx
  unsigned int v3; // edi
  unsigned int v4; // er11
  int v5; // eax
  __int64 v6; // r10
  int v7; // er11

  v2 = a1;
  v3 = *a1;
  if ( v3 && a2 )
  {
    while ( 1 )
    {
      v5 = sub_BD8A0(v3);
      if ( v5 < 0 )
        break;
      v3 = v2[v6 + 1];
      v4 = v5 + v7;
      if ( !v3 || v6 + 1 == a2 )
        return v4;
    }
    v4 = -1;
  }
  else
  {
    v4 = 0;
  }
  return v4;
}

signed __int64 __fastcall sub_BD9A0(unsigned int a1)
{
  unsigned int v1; // er9
  signed __int64 result; // rax

  v1 = a1;
  if ( a1 - 161 <= (unsigned int)&unk_10FF5C && (unsigned __int8)sub_BD860(a1, (__int64)&off_FD6A0, 178) )
    result = 2LL;
  else
    result = sub_BD8A0(v1);
  return result;
}

__int64 __fastcall sub_BD9E0(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // rbx
  unsigned int v3; // edi
  unsigned int v4; // er11
  int v5; // eax
  __int64 v6; // r10
  int v7; // er11

  v2 = a1;
  v3 = *a1;
  if ( v3 && a2 )
  {
    while ( 1 )
    {
      v5 = sub_BD9A0(v3);
      if ( v5 < 0 )
        break;
      v3 = v2[v6 + 1];
      v4 = v5 + v7;
      if ( !v3 || v6 + 1 == a2 )
        return v4;
    }
    v4 = -1;
  }
  else
  {
    v4 = 0;
  }
  return v4;
}

signed __int64 __fastcall sub_BDA40(char **a1, _BYTE **a2, unsigned __int64 a3)
{
  char *v3; // r9
  _BYTE *v4; // r8
  char v5; // cl
  bool v6; // r11
  char v7; // al
  signed int v8; // eax
  bool v9; // bl
  _BYTE *v10; // rcx
  char v11; // r10
  unsigned __int8 v12; // r9
  signed int v13; // er9
  signed __int64 v14; // rbp
  signed int v15; // er13
  bool v16; // r9
  signed __int64 result; // rax

  v3 = *a1;
  v4 = *a2;
  v5 = **a1;
  v6 = (unsigned __int64)*a2 < a3 && v5 != 0 && v5 != 42;
  if ( v6 )
  {
    while ( 1 )
    {
      if ( v5 == 92 )
      {
        v7 = v3[1];
        if ( !v7 )
          return 0xFFFFFFFFLL;
        if ( v7 != *v4 )
          return 0LL;
        v3 += 2;
        goto LABEL_7;
      }
      if ( v5 != 63 )
      {
        if ( v5 == 91 )
        {
          v8 = (unsigned __int8)v3[1];
          v9 = 0;
          v10 = v3 + 1;
          if ( (_BYTE)v8 == 94 )
          {
            v8 = (unsigned __int8)v3[2];
            v10 = v3 + 2;
            v9 = v6;
          }
          v11 = 0;
          while ( (_BYTE)v8 != 93 )
          {
            while ( 1 )
            {
              if ( (_BYTE)v8 == 92 )
                v8 = (unsigned __int8)(v10++)[1];
              if ( !(_BYTE)v8 )
                return 4294967294LL;
              v12 = v10[1];
              if ( v12 == 45 )
                break;
              ++v10;
              v11 |= *v4 == (_BYTE)v8;
              v8 = v12;
              if ( v12 == 93 )
                goto LABEL_22;
            }
            v13 = (unsigned __int8)v10[2];
            if ( (_BYTE)v13 == 93 )
              return 4294967293LL;
            v14 = (signed __int64)(v10 + 2);
            if ( (_BYTE)v13 == 92 )
            {
              v13 = (unsigned __int8)v10[3];
              v14 = (signed __int64)(v10 + 3);
            }
            if ( !(_BYTE)v13 )
              return 4294967294LL;
            v10 = (_BYTE *)(v14 + 1);
            if ( v8 <= v13 )
            {
              v15 = v13;
              v13 = v8;
              v8 = v15;
            }
            v16 = v8 >= (unsigned __int8)*v4 && v13 <= (unsigned __int8)*v4;
            v8 = *(unsigned __int8 *)(v14 + 1);
            if ( v16 )
              v11 = v16;
          }
LABEL_22:
          if ( v11 == v9 )
            return 0LL;
          v3 = v10 + 1;
          goto LABEL_7;
        }
        if ( *v4 != v5 )
          return 0LL;
      }
      ++v3;
LABEL_7:
      v5 = *v3;
      ++v4;
      if ( v5 == 42 || v5 == 0 || a3 <= (unsigned __int64)v4 )
      {
        if ( !v5 || (result = 0LL, v5 == 42) )
        {
          *a1 = v3;
          result = 1LL;
          *a2 = v4;
        }
        return result;
      }
    }
  }
  if ( !v5 || (result = 0LL, v5 == 42) )
  {
    *a1 = v3;
    result = 1LL;
    *a2 = v4;
  }
  return result;
}

signed __int64 __fastcall sub_BDC10(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  unsigned __int64 v3; // rbp
  char v4; // al
  _BYTE *v5; // rdi
  _BYTE *v6; // rbx
  char v7; // al
  _BYTE *v8; // r14
  signed __int64 result; // rax
  unsigned __int64 v10; // rdx
  _BYTE *v11; // [rsp+0h] [rbp-38h]
  _BYTE *v12; // [rsp+8h] [rbp-30h]

  v3 = (unsigned __int64)&a2[a3];
  v12 = a1;
  v11 = a2;
  v4 = *a1;
  if ( *a1 != 42 )
  {
    result = sub_BDA40(&v12, &v11, v3);
    if ( (signed int)result <= 0 )
      return result;
    a1 = v12;
    v4 = *v12;
    if ( !*v12 )
      return v11 == (_BYTE *)v3;
  }
LABEL_2:
  if ( v4 != 42 )
    __assert_fail("*wildcard == '*'", "wildcard.c", 0xE4u, "wc_match_inner");
  v5 = a1 + 1;
  do
  {
    v6 = v5;
    v12 = v5++;
    v7 = *(v5 - 1);
  }
  while ( v7 == 42 );
  if ( !v7 )
    return 1LL;
  v8 = v11;
  if ( !*v11 )
    return 0LL;
  while ( 1 )
  {
    result = sub_BDA40(&v12, &v11, v3);
    if ( (signed int)result < 0 )
      return result;
    if ( (_DWORD)result )
    {
      a1 = v12;
      v4 = *v12;
      if ( *v12 )
        goto LABEL_2;
      if ( v11 != (_BYTE *)v3 )
      {
        v12 = v6;
        v11 = (_BYTE *)(v3 - (v11 - v8));
        return sub_BDA40(&v12, &v11, v10);
      }
      return v11 == (_BYTE *)v3;
    }
    v8 = v11 + 1;
    v11 = v8;
    if ( !*v8 )
      return 0LL;
    v6 = v12;
  }
}

signed __int64 __fastcall sub_BDDB0(_BYTE *a1, char *a2)
{
  __int64 v2; // rax

  v2 = strlen(a2);
  return sub_BDC10(a1, a2, v2);
}

void nullsub_46()
{
  ;
}

__int64 __fastcall sub_BDE80(__int64 a1)
{
  *(_BYTE *)(a1 - 34) = 0;
  return (***(__int64 (__fastcall ****)(_QWORD, _QWORD))(a1 - 16))(*(_QWORD *)(a1 - 16), 0LL);
}

__int64 __fastcall sub_BDEA0(__int64 a1)
{
  return (*(__int64 (**)(void))(**(_QWORD **)(a1 - 16) + 24LL))();
}

char *sub_BDEB0()
{
  return sub_BC120("Forwarded X11 connection terminated");
}

void __fastcall sub_BDEC0(__int64 a1, __int64 a2)
{
  char *v2; // rax
  char *v3; // r13
  int v4; // eax
  int v5; // er12
  int v6; // ebx
  char *v7; // rax
  _BYTE *v8; // rbp
  signed int v9; // ebx
  signed int v10; // eax
  __int16 v11; // dx
  void *v12; // rax

  v2 = sub_BC360((__int64)"%s X11 proxy: %s\n", "PuTTY", a2);
  v3 = v2;
  v4 = strlen(v2);
  v5 = v4;
  v6 = v4 + 3;
  v7 = (char *)sub_2F450(v4 + 13, 1uLL, 0LL);
  *v7 = 0;
  v7[1] = v5;
  v8 = v7;
  v9 = v6 & 0xFFFFFFFC;
  *(_DWORD *)(v7 + 2) = *(_DWORD *)(a1 + 2);
  v10 = v9 >> 2;
  v11 = (unsigned __int16)(v9 >> 2) >> 8;
  if ( *(_BYTE *)a1 == 66 )
  {
    v8[7] = v10;
    v8[6] = v11;
  }
  else
  {
    v8[6] = v10;
    v8[7] = v11;
  }
  v12 = memset(v8 + 8, 0, v9);
  memcpy(v12, v3, v5);
  (***(void (__fastcall ****)(_QWORD, _QWORD, _BYTE *, _QWORD))(a1 + 88))(*(_QWORD *)(a1 + 88), 0LL, v8, v9 + 8);
  (*(void (**)(void))(**(_QWORD **)(a1 + 88) + 8LL))();
  *(_BYTE *)(a1 + 70) = 0;
  sub_2F4D0(v8);
  sub_2F4D0(v3);
}

__int64 (__fastcall **__fastcall sub_BDFA0(__int64 (__fastcall ***a1)(), char a2))()
{
  __int64 (__fastcall **result)(); // rax
  __int64 v3; // rdi

  result = &off_324B60;
  if ( *a1 != &off_324B60 )
    __assert_fail("chan->vt == &X11Connection_channelvt", "x11fwd.c", 0x364u, "x11_set_input_wanted");
  *((_BYTE *)a1 - 43) = a2;
  v3 = (__int64)*(a1 - 2);
  if ( v3 )
    result = (__int64 (__fastcall **)())(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 40LL))(
                                          v3,
                                          (unsigned __int8)(a2 ^ 1));
  return result;
}

__int64 __fastcall sub_BE000(__int64 (__fastcall ***a1)())
{
  __int64 result; // rax
  __int64 v2; // rdi

  if ( *a1 != &off_324B60 )
    __assert_fail("chan->vt == &X11Connection_channelvt", "x11fwd.c", 0x438u, "x11_send_eof");
  result = (__int64)*(a1 - 2);
  if ( result )
    return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)result + 32LL))(*(a1 - 2));
  v2 = (__int64)*(a1 - 3);
  if ( v2 )
    result = (*(__int64 (**)(void))(*(_QWORD *)v2 + 8LL))();
  return result;
}

int __fastcall sub_BE060(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 > *a2 )
    return 1;
  if ( *a1 < *a2 )
    return -1;
  return memcmp(a1 + 1, a2 + 1, 6uLL);
}

void __fastcall sub_BE0A0(__int64 (__fastcall ***a1)())
{
  __int64 (__fastcall ***v1)(); // rbx
  __int64 (__fastcall ***v2)(); // rbp
  void *v3; // rdi
  __int64 v4; // rdi

  if ( *a1 != &off_324B60 )
    __assert_fail("chan->vt == &X11Connection_channelvt", "x11fwd.c", 0x353u, "x11_chan_free");
  v1 = a1;
  v2 = a1 - 14;
  v3 = *(a1 - 10);
  if ( v3 )
  {
    sub_2F4D0(v3);
    sub_2F4D0(*(v1 - 9));
  }
  v4 = (__int64)*(v1 - 2);
  if ( v4 )
    (*(void (**)(void))(*(_QWORD *)v4 + 8LL))();
  sub_2F4D0(*(v1 - 5));
  sub_2F4D0(v2);
}

void __usercall sub_BE120(__int64 a1@<rbx>, __int64 a2@<rbp>, __int64 a3@<rdi>, __int64 a4@<rsi>, __int64 a5@<r12>)
{
  char *v5; // r12
  __int64 v6; // rdi

  if ( a4 )
  {
    if ( *(_BYTE *)(a3 - 34) )
    {
      v5 = sub_BC360((__int64)"unable to connect to forwarded X server: %s", a1, a2, a5);
      sub_BDEC0(a3 - 104, (__int64)v5);
      sub_2F4D0(v5);
    }
    (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a3 - 16) + 16LL))(*(_QWORD *)(a3 - 16), a4);
  }
  else
  {
    v6 = *(_QWORD *)(a3 - 16);
    if ( v6 )
      (*(void (**)(void))(*(_QWORD *)v6 + 8LL))();
  }
}

__int64 __fastcall sub_BE1A0(__int64 a1, _QWORD *a2)
{
  int v2; // eax
  unsigned int v3; // edx
  int v5; // [rsp+0h] [rbp-28h]
  int v6; // [rsp+4h] [rbp-24h]
  int v7; // [rsp+8h] [rbp-20h]
  int v8; // [rsp+Ch] [rbp-1Ch]
  unsigned __int64 v9; // [rsp+18h] [rbp-10h]

  v9 = __readfsqword(0x28u);
  v2 = __isoc99_sscanf(a1, "%d.%d.%d.%d", &v5, &v6, &v7);
  v3 = 0;
  if ( v2 == 4 )
  {
    v3 = 1;
    *a2 = (v7 << 8) | v8 | (v6 << 16) | (v5 << 24);
  }
  return v3;
}

signed int *__fastcall sub_BE220(__int64 *a1, int a2)
{
  __int64 *v2; // rbp
  signed int *v3; // rax
  signed int *v4; // rbx
  _QWORD *v5; // rax
  char *v6; // rax
  signed int v7; // edx
  __int64 v8; // rbp
  signed int *result; // rax
  char *v10; // rax
  char *v11; // rdi

  v2 = a1;
  v3 = (signed int *)sub_2F450(1uLL, 0x50uLL, 0LL);
  v4 = v3;
  if ( a2 == 1 )
  {
    *v3 = 1;
    v3[4] = 16;
    v10 = (char *)sub_2F450(0x10uLL, 1uLL, 0LL);
    *((_QWORD *)v4 + 5) = 0LL;
    v11 = v10;
    for ( *((_QWORD *)v4 + 1) = v10; ; v11 = (char *)*((_QWORD *)v4 + 1) )
    {
      sub_7BF50(v11, v4[4]);
      if ( (signed int *)sub_9AFD0(v2, (__int64)v4) == v4 )
        break;
    }
    *((_QWORD *)v4 + 6) = 0LL;
  }
  else
  {
    if ( a2 != 2 )
      __assert_fail("authtype == X11_XDM", "x11fwd.c", 0x6Eu, "x11_invent_fake_auth");
    *v3 = 2;
    v3[4] = 16;
    *((_QWORD *)v3 + 1) = sub_2F450(0x10uLL, 1uLL, 0LL);
    v5 = sub_2F450(8uLL, 1uLL, 0LL);
    *((_QWORD *)v4 + 5) = v5;
    *v5 = 0LL;
    do
    {
      sub_7BF50(*((char **)v4 + 1), 0xFuLL);
      *(_BYTE *)(*((_QWORD *)v4 + 1) + 15LL) = *(_BYTE *)(*((_QWORD *)v4 + 1) + 8LL);
      *(_BYTE *)(*((_QWORD *)v4 + 1) + 8LL) = 0;
      **((_QWORD **)v4 + 5) = **((_QWORD **)v4 + 1);
      sub_5E4A0(*((_QWORD *)v4 + 1) + 9LL, *((_QWORD *)v4 + 5), 8u);
    }
    while ( (signed int *)sub_9AFD0(a1, (__int64)v4) != v4 );
    *((_QWORD *)v4 + 6) = sub_9AF60((__int64)sub_BE060);
  }
  *((_QWORD *)v4 + 3) = sub_BC120(*((char **)&off_3232D0 + *v4));
  v6 = (char *)sub_2F450(2 * v4[4] + 1, 1uLL, 0LL);
  v7 = v4[4];
  *((_QWORD *)v4 + 4) = v6;
  if ( v7 > 0 )
  {
    v8 = 0LL;
    while ( 1 )
    {
      __sprintf_chk(&v6[2 * v8], 1LL, -1LL, "%02x", *(unsigned __int8 *)(*((_QWORD *)v4 + 1) + v8));
      if ( v4[4] <= (signed int)++v8 )
        break;
      v6 = (char *)*((_QWORD *)v4 + 4);
    }
  }
  *((_QWORD *)v4 + 7) = 0LL;
  *((_QWORD *)v4 + 8) = 0LL;
  result = v4;
  *((_QWORD *)v4 + 9) = 0LL;
  return result;
}

void __fastcall sub_BE420(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdi
  __int64 *v3; // rdi
  void *v4; // rax

  v1 = a1;
  v2 = *(void **)(a1 + 8);
  if ( v2 )
  {
    sub_BD070(v2, *(signed int *)(v1 + 16));
    v2 = *(void **)(v1 + 8);
  }
  sub_2F4D0(v2);
  sub_2F4D0(*(void **)(v1 + 24));
  sub_2F4D0(*(void **)(v1 + 32));
  sub_2F4D0(*(void **)(v1 + 40));
  v3 = *(__int64 **)(v1 + 48);
  if ( v3 )
  {
    while ( 1 )
    {
      v4 = (void *)sub_9B400(v3, 0);
      if ( !v4 )
        break;
      sub_2F4D0(v4);
      v3 = *(__int64 **)(v1 + 48);
    }
    sub_9AF90(*(_QWORD ***)(v1 + 48));
  }
  sub_2F4D0((void *)v1);
}

signed int __fastcall sub_BE4A0(__int64 a1, __int64 a2)
{
  signed int result; // eax
  size_t v3; // rdx

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 < *(_DWORD *)a2 )
    return -1;
  if ( result > *(_DWORD *)a2 )
    return 1;
  if ( result != 1 )
  {
    if ( result != 2 )
      __assert_fail("a->proto == X11_XDM", "x11fwd.c", 0xB4u, "x11_authcmp");
    return memcmp(*(const void **)(a1 + 40), *(const void **)(a2 + 40), 8uLL);
  }
  v3 = *(signed int *)(a1 + 16);
  if ( (signed int)v3 < *(_DWORD *)(a2 + 16) )
    return -1;
  if ( (signed int)v3 <= *(_DWORD *)(a2 + 16) )
    result = memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v3);
  return result;
}

unsigned int *__fastcall sub_BE520(char *src, __int64 *a2, char **a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  char **v11; // r13
  __int64 *v12; // r12
  unsigned int *v13; // rbx
  char *v14; // rax
  char *v15; // rbp
  char v16; // al
  char *v17; // rdi
  char *v18; // rax
  double v19; // xmm4_8
  double v20; // xmm5_8
  _BYTE *v22; // rax
  const char *v23; // r14
  char *v24; // rax
  const char *v25; // r15
  char *v26; // rax
  bool v27; // cf
  bool v28; // zf
  char *v29; // rax
  const char *v30; // rdi
  signed __int64 v31; // rcx
  char *v32; // rsi
  bool v33; // cl
  char v34; // dl
  bool v35; // cf
  bool v36; // zf
  const char *v37; // rdi
  signed __int64 v38; // rcx
  char *v39; // rsi
  char *v40; // rdi
  __int64 v41; // rsi
  __int64 v42; // rax
  char *v43; // rbp
  char *v44; // rax
  bool v45; // cf
  bool v46; // zf
  const char *v47; // rdi
  signed __int64 v48; // rcx
  char *v49; // rsi
  char *v50; // rax
  struct addrinfo **v51; // rdi
  void *v52; // rdi
  _DWORD *v53; // rax
  char *v54; // r13
  __int64 v55; // r14
  void *v56; // rdi

  v11 = a3;
  v12 = a2;
  v13 = (unsigned int *)sub_2F450(1uLL, 0x50uLL, 0LL);
  *v11 = 0LL;
  if ( src && *src )
  {
    v15 = sub_BC120(src);
    v16 = *v15;
  }
  else
  {
    v14 = sub_B8610(1LL, 80LL);
    v15 = v14;
    if ( !v14 || (v16 = *v14) == 0 )
    {
      sub_2F4D0(v15);
      v15 = sub_BC120(":0");
      if ( *v15 == 47 )
        goto LABEL_6;
      goto LABEL_13;
    }
  }
  if ( v16 == 47 )
  {
LABEL_6:
    *((_QWORD *)v13 + 3) = v15;
    *(_BYTE *)v13 = 1;
    *((_QWORD *)v13 + 1) = 0LL;
    *((_QWORD *)v13 + 2) = 0xFFFFFFFFLL;
    v17 = v15;
    *((_QWORD *)v13 + 4) = 0LL;
    goto LABEL_7;
  }
LABEL_13:
  v22 = sub_BC0D0(v15, 58);
  if ( !v22 )
  {
    v56 = v13;
    *v11 = sub_BC360((__int64)"display name '%s' has no ':number' suffix", v15);
    v13 = 0LL;
    sub_2F4D0(v56);
    sub_2F4D0(v15);
    return v13;
  }
  v23 = v22 + 1;
  *v22 = 0;
  v24 = strchr(v22 + 1, 46);
  if ( !v24 )
  {
    v13[4] = strtol(v23, 0LL, 10);
    goto LABEL_51;
  }
  v25 = v24 + 1;
  *v24 = 0;
  v13[4] = strtol(v23, 0LL, 10);
  if ( !v25 )
  {
LABEL_51:
    v13[5] = 0;
    goto LABEL_17;
  }
  v13[5] = strtol(v25, 0LL, 10);
LABEL_17:
  if ( v15 >= v23 || (v26 = strchr(v15, 47)) == 0LL )
  {
    if ( *v15 )
    {
      v44 = sub_BC120(v15);
      *((_QWORD *)v13 + 1) = v44;
    }
    else
    {
      *((_QWORD *)v13 + 1) = 0LL;
      v44 = 0LL;
    }
    v45 = 0;
    v46 = *v15 == 0;
    if ( *v15 )
    {
      v47 = "unix";
      v48 = 5LL;
      v49 = v15;
      do
      {
        if ( !v48 )
          break;
        v45 = (unsigned __int8)*v49 < *v47;
        v46 = *v49++ == *v47++;
        --v48;
      }
      while ( v46 );
      if ( (!v45 && !v46) != v45 )
      {
        *(_BYTE *)v13 = 0;
        if ( v44 )
          goto LABEL_30;
LABEL_48:
        *((_QWORD *)v13 + 1) = sub_BC120("localhost");
        goto LABEL_30;
      }
    }
    *(_BYTE *)v13 = 1;
    if ( v44 )
      goto LABEL_30;
LABEL_47:
    if ( *(_BYTE *)v13 )
      goto LABEL_30;
    goto LABEL_48;
  }
  v28 = v26[1] == 0;
  *v26 = 0;
  if ( v28 )
  {
    *((_QWORD *)v13 + 1) = 0LL;
    v27 = 0;
    v28 = 1;
    v29 = 0LL;
  }
  else
  {
    v29 = sub_BC120(v26 + 1);
    *((_QWORD *)v13 + 1) = v29;
  }
  v30 = "local";
  v31 = 6LL;
  v32 = v15;
  do
  {
    if ( !v31 )
      break;
    v27 = (unsigned __int8)*v32 < *v30;
    v28 = *v32++ == *v30++;
    --v31;
  }
  while ( v28 );
  v33 = 1;
  v34 = (!v27 && !v28) - v27;
  v35 = 0;
  v36 = v34 == 0;
  if ( v34 )
  {
    v37 = "unix";
    v38 = 5LL;
    v39 = v15;
    do
    {
      if ( !v38 )
        break;
      v35 = (unsigned __int8)*v39 < *v37;
      v36 = *v39++ == *v37++;
      --v38;
    }
    while ( v36 );
    v33 = (!v35 && !v36) == v35;
  }
  *(_BYTE *)v13 = v33;
  if ( !v29 )
    goto LABEL_47;
LABEL_30:
  *((_QWORD *)v13 + 3) = 0LL;
  *((_QWORD *)v13 + 4) = 0LL;
  sub_2F4D0(v15);
  if ( *(_BYTE *)v13 )
  {
LABEL_35:
    v43 = (char *)*((_QWORD *)v13 + 4);
    goto LABEL_36;
  }
  v40 = (char *)*((_QWORD *)v13 + 1);
  v41 = v13[4] + 6000;
  v13[10] = v41;
  v42 = sub_3A770(v40, v41, (_QWORD *)v13 + 6, v12, 0LL, 0LL, 0LL);
  *((_QWORD *)v13 + 4) = v42;
  if ( sub_B72A0(v42) )
  {
    v50 = sub_BC360((__int64)"unable to resolve host name '%s' in display name", *((_QWORD *)v13 + 1));
    v51 = (struct addrinfo **)*((_QWORD *)v13 + 4);
    *v11 = v50;
    sub_B62D0(v51);
    sub_2F4D0(*((void **)v13 + 1));
    sub_2F4D0(*((void **)v13 + 3));
    v52 = v13;
    v13 = 0LL;
    sub_2F4D0(v52);
    return v13;
  }
  v43 = (char *)*((_QWORD *)v13 + 4);
  if ( !*(_BYTE *)v13 )
  {
    if ( !sub_B61E0(*((_QWORD *)v13 + 4)) )
      goto LABEL_34;
    v43 = sub_B73B0(0LL, v13[4]);
    if ( sub_B72A0((__int64)v43)
      || (v53 = sub_B62F0(v43),
          v54 = sub_B6300((__int64)v53, 0, 0, 0, 0, 0, (__int64)&off_326010),
          v55 = (*(__int64 (__fastcall **)(char *, _QWORD))(*(_QWORD *)v54 + 48LL))(v54, 0LL),
          (*(void (__fastcall **)(char *))(*(_QWORD *)v54 + 8LL))(v54),
          v55) )
    {
      sub_B62D0((struct addrinfo **)v43);
LABEL_34:
      if ( !*(_BYTE *)v13 )
        goto LABEL_10;
      goto LABEL_35;
    }
    sub_B62D0(*((struct addrinfo ***)v13 + 4));
    *(_BYTE *)v13 = 1;
    *((_QWORD *)v13 + 4) = v43;
  }
LABEL_36:
  v17 = (char *)*((_QWORD *)v13 + 3);
  if ( v43 )
  {
    if ( v17 )
      goto LABEL_8;
LABEL_38:
    *((_QWORD *)v13 + 6) = sub_BC360((__int64)"unix:%d", v13[4]);
    goto LABEL_9;
  }
LABEL_7:
  v18 = sub_B73B0((__int64)v17, v13[4]);
  v17 = (char *)*((_QWORD *)v13 + 3);
  *((_QWORD *)v13 + 4) = v18;
  if ( !v17 )
    goto LABEL_38;
LABEL_8:
  *((_QWORD *)v13 + 6) = sub_BC120(v17);
LABEL_9:
  v13[10] = 0;
LABEL_10:
  v13[14] = 0;
  *((_QWORD *)v13 + 8) = 0LL;
  v13[18] = 0;
  sub_B36E0((__int64)v13, a4, a5, a6, a7, v19, v20, a10, a11);
  return v13;
}

void __fastcall sub_BE9C0(__int64 a1)
{
  __int64 v1; // rbx
  void *v2; // rdi

  v1 = a1;
  sub_2F4D0(*(void **)(a1 + 8));
  sub_2F4D0(*(void **)(a1 + 24));
  v2 = *(void **)(a1 + 64);
  if ( v2 )
  {
    sub_BD070(v2, *(signed int *)(v1 + 72));
    v2 = *(void **)(v1 + 64);
  }
  sub_2F4D0(v2);
  sub_B62D0(*(struct addrinfo ***)(v1 + 32));
  sub_2F4D0((void *)v1);
}

char *__fastcall sub_BEA10(__int64 a1)
{
  unsigned int v1; // eax

  v1 = sub_2F100(*(_QWORD *)(a1 + 32));
  return sub_2F040(*(_QWORD *)(a1 + 32), v1);
}

__int64 __fastcall sub_BEA30(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  if ( a3 >> 16 )
    __assert_fail("(pl.len >> 16) == 0", "x11fwd.c", 0x1CFu, "BinarySink_put_stringpl_xauth");
  sub_2ED40(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), a3);
  return sub_2EC30(*(__int64 (***)(void))(a1 + 8));
}

unsigned __int64 __fastcall sub_BEA90(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  FILE *v3; // rbx
  char *v4; // r15
  __int64 *v5; // rdi
  int v6; // er13
  signed int v7; // er14
  size_t v8; // rdx
  char *v9; // rax
  size_t v10; // rdx
  const char *v11; // rax
  char *v12; // rbx
  char *v13; // r12
  size_t v14; // rdx
  size_t v15; // rbx
  unsigned __int64 v16; // rdx
  int v17; // eax
  size_t v18; // rsi
  signed int v19; // ebx
  void *v20; // rdi
  void *v21; // rax
  int v23; // er12
  int v24; // eax
  void *v25; // rdi
  void *v26; // rax
  size_t v27; // [rsp+8h] [rbp-D0h]
  char *s1; // [rsp+10h] [rbp-C8h]
  char *src; // [rsp+18h] [rbp-C0h]
  unsigned __int64 n; // [rsp+20h] [rbp-B8h]
  FILE *stream; // [rsp+28h] [rbp-B0h]
  void *s2; // [rsp+38h] [rbp-A0h]
  int v33; // [rsp+48h] [rbp-90h]
  bool v34; // [rsp+4Eh] [rbp-8Ah]
  char *v35; // [rsp+50h] [rbp-88h]
  unsigned __int64 v36; // [rsp+58h] [rbp-80h]
  __int64 v37; // [rsp+60h] [rbp-78h]
  int v38; // [rsp+68h] [rbp-70h]
  __int64 *v39; // [rsp+70h] [rbp-68h]
  __m128i v40; // [rsp+80h] [rbp-58h]
  unsigned __int64 v41; // [rsp+98h] [rbp-40h]

  v2 = a1;
  v41 = __readfsqword(0x28u);
  v34 = 0;
  if ( !*(_BYTE *)a1 )
    v34 = sub_B61E0(*(_QWORD *)(a1 + 32));
  v3 = fopen(a2, "rb");
  stream = v3;
  if ( v3 )
  {
    s2 = sub_B7300();
    v4 = (char *)sub_2F450(0x8000CuLL, 1uLL, 0LL);
    v33 = fread(v4, 1uLL, 0x8000CuLL, v3);
    v35 = v4;
    v37 = v33;
    v36 = 0LL;
    v38 = 0;
    v39 = (__int64 *)&v35;
    v5 = (__int64 *)&v35;
    while ( 1 )
    {
      v6 = sub_2F100((__int64)v5);
      v7 = -1;
      s1 = sub_BEA10((__int64)v39);
      v27 = v8;
      v9 = sub_BEA10((__int64)v39);
      v11 = sub_BD360(v9, v10);
      v12 = (char *)v11;
      if ( *v11 )
        v7 = strtol(v11, 0LL, 10);
      sub_2F4D0(v12);
      v13 = sub_BEA10((__int64)v39);
      v15 = v14;
      src = sub_BEA10((__int64)v39);
      n = v16;
      if ( *((_DWORD *)v39 + 6) )
      {
LABEL_23:
        fclose(stream);
        sub_BD070(v4, 0x8000CuLL);
        sub_2F4D0(v4);
        sub_2F4D0(s2);
        return __readfsqword(0x28u) ^ v41;
      }
      v17 = *(_DWORD *)(v2 + 16);
      if ( v17 >= 0 && (v7 < 0 || v17 == v7) )
      {
        if ( (unsigned __int8)sub_BD100(v13, v15, "MIT-MAGIC-COOKIE-1") )
        {
          v19 = 1;
        }
        else
        {
          v18 = v15;
          v19 = 2;
          if ( !(unsigned __int8)sub_BD100(v13, v18, "XDM-AUTHORIZATION-1") )
            goto LABEL_11;
        }
        if ( v6 == 6 )
        {
          if ( *(_BYTE *)v2 )
            goto LABEL_11;
          if ( (unsigned int)sub_B6220(*(_QWORD *)(v2 + 32)) != 2 )
            goto LABEL_11;
          sub_B6260(*(_QWORD *)(v2 + 32), &v40);
          if ( v27 != 16 || (*(_OWORD *)&v40 ^ *(_OWORD *)s1) != 0LL )
            goto LABEL_11;
          goto LABEL_22;
        }
        if ( v6 != 256 )
        {
          if ( v6 )
            goto LABEL_11;
          if ( *(_BYTE *)v2 )
            goto LABEL_11;
          if ( (unsigned int)sub_B6220(*(_QWORD *)(v2 + 32)) != 1 )
            goto LABEL_11;
          sub_B6260(*(_QWORD *)(v2 + 32), &v40);
          if ( v27 != 4 || v40.m128i_i32[0] != *(_DWORD *)s1 )
            goto LABEL_11;
LABEL_22:
          v20 = *(void **)(v2 + 64);
          *(_DWORD *)(v2 + 56) = v19;
          sub_2F4D0(v20);
          v21 = sub_2F450(n, 1uLL, 0LL);
          *(_QWORD *)(v2 + 64) = v21;
          memcpy(v21, src, n);
          *(_DWORD *)(v2 + 72) = n;
          if ( !v34 )
            goto LABEL_23;
          goto LABEL_11;
        }
        if ( *(_BYTE *)v2 | v34 && s2 && (unsigned __int8)sub_BD100(s1, v27, s2) )
        {
          v25 = *(void **)(v2 + 64);
          *(_DWORD *)(v2 + 56) = v19;
          sub_2F4D0(v25);
          v26 = sub_2F450(n, 1uLL, 0LL);
          *(_QWORD *)(v2 + 64) = v26;
          memcpy(v26, src, n);
          *(_DWORD *)(v2 + 72) = n;
          goto LABEL_23;
        }
      }
LABEL_11:
      if ( v36 > 0x40005 )
      {
        v23 = v33 - v36;
        memcpy(v4, &v4[v36], v33 - (signed int)v36);
        v24 = fread(&v4[v23], 1uLL, 524300LL - v23, stream);
        v35 = v4;
        v36 = 0LL;
        v33 = v23 + v24;
        v38 = 0;
        v37 = v23 + v24;
        v39 = (__int64 *)&v35;
        v5 = (__int64 *)&v35;
      }
      else
      {
        v5 = v39;
      }
    }
  }
  return __readfsqword(0x28u) ^ v41;
}

__int64 __fastcall sub_BEEE0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7, unsigned __int64 a8)
{
  unsigned int v8; // er15
  __int64 v9; // r14
  unsigned __int64 v10; // r13
  char *v11; // rax
  char *v12; // r12
  unsigned __int64 v13; // rax
  __int64 v14; // ST00_8
  __int64 result; // rax
  unsigned __int64 v16; // rt1
  char *v17; // r12
  unsigned __int64 v18; // rax
  char v19; // [rsp+10h] [rbp-58h]
  unsigned __int64 v20; // [rsp+28h] [rbp-40h]

  v8 = a3;
  v9 = a4;
  v10 = a5;
  v20 = __readfsqword(0x28u);
  if ( sub_B6210(a2) )
  {
    v17 = (char *)sub_B7300();
    sub_2ED40(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), 256);
    v18 = strlen(v17);
    sub_BEA30(*(_QWORD *)(a1 + 8), (__int64)v17, v18);
    sub_2F4D0(v17);
  }
  else if ( (unsigned int)sub_B6220(a2) == 1 )
  {
    sub_B6260(a2, (__m128i *)&v19);
    sub_2ED40(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), 0);
    sub_BEA30(*(_QWORD *)(a1 + 8), (__int64)&v19, 4uLL);
  }
  else
  {
    if ( (unsigned int)sub_B6220(a2) != 2 )
      goto LABEL_9;
    sub_B6260(a2, (__m128i *)&v19);
    sub_2ED40(*(void (__fastcall ***)(_QWORD, char *, signed __int64, _QWORD))(a1 + 8), 6);
    sub_BEA30(*(_QWORD *)(a1 + 8), (__int64)&v19, 0x10uLL);
  }
  v11 = sub_BC360((__int64)"%d", v8, a7);
  v12 = v11;
  v13 = strlen(v11);
  sub_BEA30(*(_QWORD *)(a1 + 8), (__int64)v12, v13);
  sub_2F4D0(v12);
  sub_BEA30(*(_QWORD *)(a1 + 8), v9, v10);
  sub_BEA30(*(_QWORD *)(a1 + 8), v14, a8);
  v16 = __readfsqword(0x28u);
  result = v16 ^ v20;
  if ( v16 != v20 )
LABEL_9:
    __assert_fail(
      "false && \"Bad address type in x11_format_auth_for_authfile\"",
      "x11fwd.c",
      0x2A2u,
      "x11_format_auth_for_authfile");
  return result;
}

__int64 __fastcall sub_BF0A0(char *s)
{
  __int64 v1; // rax
  __int64 result; // rax

  if ( s[(signed int)sub_BC050(s, ":")] && (v1 = (signed int)strcspn(s, "."), s[(signed int)v1]) )
    result = (unsigned int)strtol(&s[v1 + 1], 0LL, 10);
  else
    result = 0LL;
  return result;
}

_QWORD *__fastcall sub_BF100(__int64 a1, __int64 a2, char *a3, int a4, char a5)
{
  char *v5; // rbp
  char v6; // r15
  int v7; // er12
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  char *v10; // rax

  v5 = a3;
  v6 = a5;
  v7 = a4;
  v8 = sub_2F450(1uLL, 0x80uLL, 0LL);
  v9 = v8;
  v8[4] = 0LL;
  v8[2] = a1;
  v8[13] = off_3232A0;
  *((_BYTE *)v8 + 68) = 0;
  *((_DWORD *)v8 + 12) = 0;
  *((_BYTE *)v8 + 69) = 1;
  v8[14] = &off_324B60;
  *((_BYTE *)v8 + 70) = 1;
  v8[11] = a2;
  v8[3] = 0LL;
  v8[12] = 0LL;
  *((_DWORD *)v8 + 30) = (v6 != 0) << 7;
  v10 = 0LL;
  if ( v5 )
    v10 = sub_BC120(v5);
  v9[9] = v10;
  *((_DWORD *)v9 + 20) = v7;
  return v9 + 14;
}

__int64 __fastcall sub_BF1C0(void *s1, size_t n)
{
  __int64 result; // rax

  if ( (unsigned __int8)sub_BD100(s1, n, "MIT-MAGIC-COOKIE-1") )
    result = 1LL;
  else
    result = -((unsigned __int8)sub_BD100(s1, n, "XDM-AUTHORIZATION-1") < 1u) | 2u;
  return result;
}

void *__fastcall sub_BF210(char *a1, unsigned __int64 a2, _DWORD *a3)
{
  unsigned __int64 v3; // r14
  char *v4; // r15
  char *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  char *v8; // rbx
  char *v9; // r14
  char v10; // al
  unsigned __int64 v12; // [rsp+8h] [rbp-60h]
  void *v13; // [rsp+10h] [rbp-58h]
  _DWORD *v14; // [rsp+18h] [rbp-50h]
  int v15; // [rsp+20h] [rbp-48h]
  char v16; // [rsp+25h] [rbp-43h]
  char v17; // [rsp+26h] [rbp-42h]
  char v18; // [rsp+27h] [rbp-41h]
  unsigned __int64 v19; // [rsp+28h] [rbp-40h]

  v3 = a2 >> 1;
  v4 = a1;
  v14 = a3;
  v12 = a2 >> 1;
  v19 = __readfsqword(0x28u);
  v5 = (char *)sub_2F450((signed int)(a2 >> 1), 1uLL, 0LL);
  v13 = v5;
  if ( (signed int)(a2 >> 1) > 0 )
  {
    v8 = v5;
    v9 = &a1[2 * (unsigned int)(v3 - 1) + 2];
    do
    {
      v10 = *v4;
      v15 = 0;
      v18 = 0;
      v4 += 2;
      ++v8;
      v16 = v10;
      v17 = *(v4 - 1);
      __isoc99_sscanf(&v16, "%x", &v15, v6, v7);
      *(v8 - 1) = v15;
    }
    while ( v4 != v9 );
  }
  *v14 = v12;
  return v13;
}

_BYTE *__fastcall sub_BF300(char a1, __int16 a2, __int16 a3, int a4, __int64 *a5, int a6, __int64 a7, __int16 a8, int *a9)
{
  __int16 v9; // r12
  int v10; // er14
  __int16 v11; // r13
  __int64 *v12; // rbx
  int v13; // er15
  char v14; // di
  char v15; // si
  unsigned int v16; // edx
  unsigned int v17; // eax
  __int64 v18; // rcx
  int v19; // eax
  __int64 v20; // rdi
  char v21; // cl
  char v22; // r11
  signed int v23; // eax
  _BYTE *v24; // r14
  size_t v26; // [rsp+0h] [rbp-C8h]
  void *src; // [rsp+8h] [rbp-C0h]
  signed int v28; // [rsp+10h] [rbp-B8h]
  int v29; // [rsp+14h] [rbp-B4h]
  char v30; // [rsp+28h] [rbp-A0h]
  char v31; // [rsp+2Eh] [rbp-9Ah]
  char v32; // [rsp+2Fh] [rbp-99h]
  __int64 v33; // [rsp+38h] [rbp-90h]
  __int64 v34; // [rsp+40h] [rbp-88h]
  char v35; // [rsp+48h] [rbp-80h]
  char v36; // [rsp+49h] [rbp-7Fh]
  char v37; // [rsp+4Ah] [rbp-7Eh]
  char v38; // [rsp+4Bh] [rbp-7Dh]
  char v39; // [rsp+4Ch] [rbp-7Ch]
  char v40; // [rsp+4Dh] [rbp-7Bh]
  __int64 v41; // [rsp+4Eh] [rbp-7Ah]
  __int16 v42; // [rsp+56h] [rbp-72h]
  unsigned __int64 v43; // [rsp+88h] [rbp-40h]

  v9 = a3;
  v10 = a4;
  v11 = a2;
  v12 = a5;
  v30 = a1;
  LODWORD(v26) = a6;
  v43 = __readfsqword(0x28u);
  src = (void *)*((_QWORD *)&off_3232D0 + a4);
  v13 = strlen(*((const char **)&off_3232D0 + a4));
  v28 = (v13 + 3) & 0xFFFFFFFC;
  if ( v10 == 1 )
  {
    v22 = v26;
    v26 = (signed int)v26;
    v21 = BYTE1(v26);
    v23 = (v26 + 3) & 0xFFFFFFFC;
  }
  else if ( v10 != 2 || (_DWORD)v26 != 16 )
  {
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v26 = 0LL;
    v12 = &v34;
  }
  else
  {
    v33 = 0LL;
    if ( a7 )
    {
      sub_BE1A0(a7, &v33);
      v15 = BYTE1(v33);
      v14 = v33;
      v16 = (unsigned int)v33 >> 16;
      v17 = (unsigned int)v33 >> 24;
    }
    else
    {
      LOBYTE(v17) = 0;
      LOBYTE(v16) = 0;
      v15 = 0;
      v14 = 0;
    }
    v35 = v17;
    v41 = 0LL;
    v38 = v14;
    v42 = 0;
    v18 = *v12;
    v37 = v15;
    v36 = v16;
    v40 = a8;
    v34 = v18;
    v39 = HIBYTE(a8);
    v19 = time(0LL);
    v20 = (__int64)v12 + 9;
    BYTE3(v41) = v19;
    v12 = &v34;
    BYTE2(v41) = BYTE1(v19);
    LOBYTE(v41) = HIBYTE(v19);
    BYTE1(v41) = BYTE2(v19);
    sub_5E4A0(v20, (__int64)&v34, 0x18u);
    v21 = 0;
    v22 = 24;
    v23 = 24;
    v26 = 24LL;
  }
  v31 = v21;
  v32 = v22;
  v29 = v28 + v23 + 12;
  v24 = sub_2F450(v29, 1uLL, 0LL);
  memset(v24, 0, v29);
  *v24 = v30;
  if ( v30 == 66 )
  {
    v24[3] = v11;
    v24[2] = HIBYTE(v11);
    v24[5] = v9;
    v24[4] = HIBYTE(v9);
    v24[7] = v13;
    v24[6] = BYTE1(v13);
    v24[9] = v32;
    v24[8] = v31;
  }
  else
  {
    *((_WORD *)v24 + 1) = v11;
    *((_WORD *)v24 + 2) = v9;
    *((_WORD *)v24 + 3) = v13;
    v24[8] = v32;
    v24[9] = v31;
  }
  memcpy(v24 + 12, src, v13);
  memcpy(&v24[v28 + 12], v12, v26);
  sub_BD070(&v34, 0x40uLL);
  *a9 = v29;
  return v24;
}

unsigned int *__usercall sub_BF5E0@<rax>(__int64 a1@<rdx>, signed __int64 a2@<rcx>, unsigned __int64 a3@<rbp>, __int64 (__fastcall ***a4)()@<rdi>, signed __int64 a5@<r13>)
{
  char *v5; // rbx
  __int64 v6; // r15
  signed int v7; // esi
  signed __int64 v8; // rcx
  char *v9; // rdi
  __int64 v10; // rax
  char v11; // dl
  unsigned int *result; // rax
  __int64 v13; // rax
  int v14; // edx
  __int64 v15; // rdx
  char v16; // si
  __int64 v17; // rcx
  int v18; // esi
  int v19; // ecx
  __int16 v20; // ax
  __int16 v21; // dx
  int v22; // eax
  int v23; // edx
  unsigned int v24; // eax
  void *v25; // rax
  unsigned __int64 v26; // rdi
  __int16 v27; // cx
  __int16 v28; // si
  int v29; // edx
  int v30; // eax
  unsigned int v31; // eax
  __int64 v32; // rdi
  bool v33; // cf
  bool v34; // zf
  char v35; // al
  const char *v36; // rdi
  signed __int64 v37; // rcx
  int v38; // er14
  __int64 v39; // r12
  _BYTE *v40; // rsi
  __int64 *v41; // rax
  char v42; // cl
  bool v43; // cf
  bool v44; // zf
  __int64 v45; // rax
  const char *v46; // rsi
  const char *v47; // rdi
  _BYTE *v48; // rsi
  signed __int64 v49; // rcx
  __int64 v50; // rsi
  __int64 *v51; // rdi
  __int64 v52; // rax
  __int64 v53; // rdi
  __int64 v54; // rbp
  __int64 v55; // rax
  unsigned int v56; // er12
  _DWORD *v57; // rax
  __int64 *v58; // ST10_8
  __int64 *v59; // rax
  __int64 v60; // rdx
  __int64 v61; // rax
  __int64 (__fastcall ***v62)(); // rdi
  unsigned __int8 *v63; // rax
  unsigned __int8 *v64; // r12
  __int16 v65; // ax
  unsigned __int32 v66; // er14
  _BYTE *v67; // rax
  _DWORD *v68; // rax
  __int64 *v69; // rdi
  void *v70; // rax
  __int64 v71; // ST18_8
  __int64 v72; // ST10_8
  __int64 v73; // r9
  signed __int64 v74; // [rsp+8h] [rbp-F0h]
  const char *v75; // [rsp+10h] [rbp-E8h]
  __int64 v76; // [rsp+18h] [rbp-E0h]
  void *v77; // [rsp+18h] [rbp-E0h]
  unsigned __int16 v78; // [rsp+22h] [rbp-D6h]
  unsigned int v79; // [rsp+24h] [rbp-D4h]
  int *v80; // [rsp+28h] [rbp-D0h]
  int v81; // [rsp+34h] [rbp-C4h]
  __int64 v82; // [rsp+38h] [rbp-C0h]
  int v83; // [rsp+40h] [rbp-B8h]
  __int64 v84; // [rsp+48h] [rbp-B0h]
  int v85; // [rsp+50h] [rbp-A8h]
  __int64 v86; // [rsp+68h] [rbp-90h]
  __int64 v87; // [rsp+90h] [rbp-68h]
  unsigned __int64 v88; // [rsp+B8h] [rbp-40h]

  v88 = __readfsqword(0x28u);
  if ( *a4 != &off_324B60 )
    __assert_fail("chan->vt == &X11Connection_channelvt", "x11fwd.c", 0x39Cu, "x11_send");
  v5 = (char *)a4;
  v6 = a1;
  v7 = *((_DWORD *)a4 - 16);
  if ( a2 )
  {
    if ( v7 > 11 )
    {
      a5 = a2;
LABEL_13:
      if ( *((_QWORD *)v5 - 10) )
      {
        v13 = *((signed int *)v5 - 16);
        v14 = *((_DWORD *)v5 - 14);
LABEL_15:
        if ( (signed int)v13 > v14 + 11 )
        {
LABEL_25:
          while ( (signed int)v13 < v14 + *((_DWORD *)v5 - 12) + 12 )
          {
            v16 = *(_BYTE *)(++v6 - 1);
            v17 = *((_QWORD *)v5 - 9);
            --a5;
            *((_DWORD *)v5 - 16) = v13 + 1;
            *(_BYTE *)(v17 + (signed int)v13 - 12 - v14) = v16;
            LODWORD(v13) = *((_DWORD *)v5 - 16);
            v14 = *((_DWORD *)v5 - 14);
            if ( !a5 )
              goto LABEL_20;
          }
          goto LABEL_22;
        }
        while ( 1 )
        {
          ++v6;
          v15 = *((_QWORD *)v5 - 10);
          --a5;
          *((_DWORD *)v5 - 16) = v13 + 1;
          *(_BYTE *)(v15 + v13 - 12) = *(_BYTE *)(v6 - 1);
          if ( !a5 )
            break;
          v14 = *((_DWORD *)v5 - 14);
          v13 = *((signed int *)v5 - 16);
          if ( v14 + 11 < (signed int)v13 )
            goto LABEL_25;
        }
        LODWORD(v13) = *((_DWORD *)v5 - 16);
        v14 = *((_DWORD *)v5 - 14);
LABEL_20:
        if ( v14 + *((_DWORD *)v5 - 12) + 12 > (signed int)v13 )
          goto LABEL_9;
        a5 = 0LL;
LABEL_22:
        if ( *(v5 - 44) )
          goto LABEL_23;
        v27 = (unsigned __int8)*(v5 - 108);
        v28 = (unsigned __int8)*(v5 - 107);
        v29 = (unsigned __int8)*(v5 - 110);
        v30 = (unsigned __int8)*(v5 - 109);
        if ( *(v5 - 112) == 66 )
        {
          v31 = (unsigned __int16)(((_WORD)v29 << 8) | v30);
          v78 = v28 | (v27 << 8);
        }
        else
        {
          a3 = v29 | (unsigned int)(v30 << 8);
          v78 = v27 | (v28 << 8);
          v31 = (unsigned __int16)(v29 | ((_WORD)v30 << 8));
        }
        v79 = v31;
        if ( *((_QWORD *)v5 - 2) )
          __assert_fail("!xconn->s", "x11fwd.c", 0x3D8u, "x11_send");
        v76 = 0LL;
        LODWORD(v75) = -1;
        *(_BYTE *)(*((_QWORD *)v5 - 10) + *((signed int *)v5 - 15)) = 0;
        v32 = *((_QWORD *)v5 - 5);
        v82 = 0LL;
        v33 = 0;
        v34 = v32 == 0;
        if ( v32 )
        {
          v35 = sub_BE1A0(v32, &v82);
          v33 = 0;
          v34 = v35 == 0;
          if ( v35 )
            LODWORD(v75) = *((_DWORD *)v5 - 8);
          v76 = v82;
        }
        v36 = "MIT-MAGIC-COOKIE-1";
        v37 = 19LL;
        v38 = *((_DWORD *)v5 - 13);
        v39 = *((_QWORD *)v5 - 9);
        v40 = (_BYTE *)*((_QWORD *)v5 - 10);
        v74 = (signed __int64)(v5 - 112);
        v41 = (__int64 *)*((_QWORD *)v5 - 12);
        do
        {
          if ( !v37 )
            break;
          v33 = *v40 < (const unsigned __int8)*v36;
          v34 = *v40++ == *v36++;
          --v37;
        }
        while ( v34 );
        v42 = (!v33 && !v34) - v33;
        v43 = 0;
        v44 = v42 == 0;
        if ( v42 )
        {
          v47 = "XDM-AUTHORIZATION-1";
          v48 = (_BYTE *)*((_QWORD *)v5 - 10);
          v49 = 20LL;
          do
          {
            if ( !v49 )
              break;
            v43 = *v48 < (const unsigned __int8)*v47;
            v44 = *v48++ == *v47++;
            --v49;
          }
          while ( v44 );
          if ( (!v43 && !v44) != v43 )
          {
            v46 = "Unsupported authorisation protocol";
LABEL_50:
            sub_BDEC0(v74, (__int64)v46);
            goto LABEL_9;
          }
          v83 = 2;
          v86 = v39;
        }
        else
        {
          v83 = 1;
          v85 = v38;
          v84 = v39;
        }
        v80 = &v83;
        v45 = sub_9B3D0(v41, (__int64)&v83, 0LL);
        a3 = v45;
        if ( v45 )
        {
          if ( *(_DWORD *)v45 != 2 )
            goto LABEL_56;
          v46 = "XDM-AUTHORIZATION-1 data was wrong length";
          if ( v38 == 24 )
          {
            if ( (_DWORD)v75 == -1 )
            {
              v46 = "cannot do XDM-AUTHORIZATION-1 without remote address data";
            }
            else
            {
              sub_5E4E0(*(_QWORD *)(v45 + 8) + 9LL, v39, 0x18u);
              if ( *(_QWORD *)v39 == **(_QWORD **)(a3 + 8)
                && _byteswap_ulong(*(_DWORD *)(v39 + 8)) == v76
                && (_DWORD)v75 == _byteswap_ushort(*(_WORD *)(v39 + 12)) )
              {
                v66 = _byteswap_ulong(*(_DWORD *)(v39 + 14));
                v75 = (const char *)v66;
                v67 = (_BYTE *)(v39 + 18);
                while ( !*v67 )
                {
                  if ( (_BYTE *)(v39 + 24) == ++v67 )
                  {
                    v46 = "XDM-AUTHORIZATION-1 time stamp was too far out";
                    if ( (unsigned __int64)v66 + 1200 - time(0LL) <= 0x960 )
                    {
                      v68 = sub_2F450(1uLL, 0xCuLL, 0LL);
                      *v68 = v66;
                      v68[1] = *(_DWORD *)(v39 + 8);
                      *((_WORD *)v68 + 4) = *(_WORD *)(v39 + 12);
                      v69 = *(__int64 **)(a3 + 48);
                      if ( !v69 )
                        __assert_fail(aAuthXdm, "x11fwd.c", 0x1B0u, "x11_verify");
                      v77 = v68;
                      if ( v68 == (_DWORD *)sub_9AFD0(v69, (__int64)v68) )
                        goto LABEL_83;
                      sub_2F4D0(v77);
                      v46 = "XDM-AUTHORIZATION-1 data replayed";
                    }
                    goto LABEL_50;
                  }
                }
              }
              v46 = "XDM-AUTHORIZATION-1 data failed check";
            }
          }
        }
        else
        {
          v46 = "Authorisation not recognised";
        }
        goto LABEL_50;
      }
LABEL_30:
      v18 = (unsigned __int8)*(v5 - 104);
      v19 = (unsigned __int8)*(v5 - 103);
      v20 = (unsigned __int8)*(v5 - 106);
      v21 = (unsigned __int8)*(v5 - 105);
      if ( *(v5 - 112) == 66 )
      {
        v22 = (unsigned __int16)((v20 << 8) | v21);
        *((_DWORD *)v5 - 15) = v22;
        v23 = (v18 << 8) | (unsigned __int8)v19;
      }
      else
      {
        v22 = (unsigned __int16)(v20 | (v21 << 8));
        *((_DWORD *)v5 - 15) = v22;
        v23 = v18 | (v19 << 8);
      }
      v24 = (v22 + 3) & 0xFFFFFFFC;
      *((_DWORD *)v5 - 13) = (unsigned __int16)v23;
      *((_DWORD *)v5 - 14) = v24;
      *((_DWORD *)v5 - 12) = ((unsigned __int16)v23 + 3) & 0xFFFFFFFC;
      v25 = sub_2F450((signed int)(v24 + 1), 1uLL, 0LL);
      v26 = *((signed int *)v5 - 12);
      *((_QWORD *)v5 - 10) = v25;
      *((_QWORD *)v5 - 9) = sub_2F450(v26, 1uLL, 0LL);
      v14 = *((_DWORD *)v5 - 14);
      v13 = *((signed int *)v5 - 16);
      if ( !a5 )
        goto LABEL_20;
      goto LABEL_15;
    }
    v8 = a2 - 1;
    v9 = (char *)a4 - 1;
    v10 = v7 + 1;
    a5 = v8 - (unsigned int)(11 - v7);
    while ( 1 )
    {
      v11 = *(_BYTE *)(++v6 - 1);
      *((_DWORD *)v5 - 16) = v10;
      v7 = v10;
      v9[v10 - 112] = v11;
      if ( !v8 )
        break;
      ++v10;
      if ( v8 == a5 )
        goto LABEL_13;
      --v8;
    }
  }
  if ( v7 > 11 )
  {
    if ( *((_QWORD *)v5 - 10) )
    {
      v14 = *((_DWORD *)v5 - 14);
      LODWORD(v13) = *((_DWORD *)v5 - 16);
      goto LABEL_20;
    }
    a5 = 0LL;
    goto LABEL_30;
  }
LABEL_9:
  result = 0LL;
  while ( __readfsqword(0x28u) != v88 )
  {
    while ( (unsigned __int64)&v75[-*result] > 0x4B0 )
    {
      v70 = (void *)sub_9B400(*(__int64 **)(a3 + 48), 0);
      sub_2F4D0(v70);
LABEL_83:
      result = (unsigned int *)sub_9B010(*(__int64 **)(a3 + 48), 0);
      if ( !result )
        __assert_fail("seen != NULL", "x11fwd.c", 0x1B9u, "x11_verify");
    }
LABEL_56:
    v50 = *(_QWORD *)(a3 + 64);
    v51 = (__int64 *)*((_QWORD *)v5 - 3);
    v52 = *v51;
    if ( v50 )
    {
      (*(void (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int64, signed __int64))(v52 + 48))(
        v51,
        v50,
        *(_QWORD *)(a3 + 72),
        *((_QWORD *)v5 - 5),
        *((unsigned int *)v5 - 8),
        (unsigned __int8)*(v5 - 112),
        v79,
        v78,
        v6,
        a5);
      goto LABEL_9;
    }
    *((_DWORD *)v5 + 2) = 0;
    (*(void (**)(void))(v52 + 40))();
    v53 = *((_QWORD *)v5 - 3);
    *((_QWORD *)v5 - 11) = *(_QWORD *)(a3 + 56);
    v54 = (*(__int64 (**)(void))(*(_QWORD *)v53 + 32LL))();
    v55 = *((_QWORD *)v5 - 11);
    v56 = *(_DWORD *)(v55 + 40);
    v75 = *(const char **)(v55 + 48);
    v57 = sub_B62F0(*(_DWORD **)(v55 + 32));
    v58 = (__int64 *)v54;
    a3 = v74;
    v59 = (__int64 *)sub_3A8A0(
                       (__int64)v57,
                       v75,
                       v56,
                       0,
                       1LL,
                       0LL,
                       0LL,
                       (void (__fastcall ***)(_QWORD, signed __int64, _QWORD, _QWORD, void *, _QWORD))(v74 + 104),
                       v58);
    v60 = *v59;
    *((_QWORD *)v5 - 2) = v59;
    v61 = (*(__int64 (__fastcall **)(__int64 *, const char *))(v60 + 48))(v59, v75);
    if ( v61 )
    {
      v5 = sub_BC360((__int64)"unable to connect to forwarded X server: %s", v61);
      sub_BDEC0(v74, (__int64)v5);
      sub_2F4D0(v5);
      goto LABEL_9;
    }
    v62 = (__int64 (__fastcall ***)())*((_QWORD *)v5 - 2);
    v83 = 0;
    v63 = sub_B6870(v62, v80);
    v64 = v63;
    if ( v63 && v83 == 6 )
    {
      v71 = v63[3];
      v72 = v63[2];
      v73 = v63[1];
      __sprintf_chk(&v87, 1LL, 32LL, "%d.%d.%d.%d", *v63);
      v34 = ((v64[4] << 8) | v64[5]) == 0;
      v65 = _byteswap_ushort(*((_WORD *)v64 + 2));
    }
    else
    {
      v87 = 13561583350328880LL;
      v65 = 0;
    }
    a3 = (unsigned __int64)sub_BF300(
                             *(v5 - 112),
                             v79,
                             v78,
                             *(_DWORD *)(*((_QWORD *)v5 - 11) + 56LL),
                             *(__int64 **)(*((_QWORD *)v5 - 11) + 64LL),
                             *(_DWORD *)(*((_QWORD *)v5 - 11) + 72LL),
                             (__int64)&v87,
                             v65,
                             &v81);
    (*(void (__fastcall **)(_QWORD, unsigned __int64, _QWORD))(**((_QWORD **)v5 - 2) + 16LL))(
      *((_QWORD *)v5 - 2),
      a3,
      v81);
    sub_BD070((void *)a3, v81);
    sub_2F4D0((void *)a3);
    *(v5 - 44) = 1;
LABEL_23:
    result = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD, __int64, signed __int64))(**((_QWORD **)v5 - 2) + 16LL))(
                               *((_QWORD *)v5 - 2),
                               v6,
                               a5);
  }
  return result;
}

void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  v4 = &off_31CE78 - off_31CE70;
  init_proc();
  if ( v4 )
  {
    v5 = 0LL;
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_31CE70[v5++])(a1, a2, v3);
    while ( v4 != v5 );
  }
}

void fini(void)
{
  ;
}
