{
    "decompileResult": [
        {
            "decompiledFuncCode": "void *sub_400970()\n{\n  void *result; // rax\n\n  result = &unk_405090;\n  if ( &unk_405090 != &unk_405090 )\n    result = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x400970L", 
            "funcEndAddr": "0x400991L", 
            "funcName": "sub_400970"
        }, 
        {
            "decompiledFuncCode": "void *sub_4009E0()\n{\n  void *result; // rax\n\n  if ( !byte_4050A0 )\n  {\n    result = sub_400970();\n    byte_4050A0 = 1;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4009e0L", 
            "funcEndAddr": "0x400a01L", 
            "funcName": "sub_4009E0"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_400A10()\n{\n  return 0LL;\n}\n\n__int64 sub_400A10()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x4009a0L", 
            "funcEndAddr": "0x4009d1L", 
            "funcName": "sub_400A10"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_400A10()\n{\n  return 0LL;\n}\n\n__int64 sub_400A10()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x4009a0L", 
            "funcEndAddr": "0x4009d1L", 
            "funcName": "sub_400A10"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_400A20@<rax>(__int64 a1@<rax>)\n{\n  signed __int64 v1; // r14\n  __int64 v2; // rcx\n  __int64 v3; // rbx\n  __int64 v5; // [rsp-8h] [rbp-18h]\n\n  v5 = a1;\n  v1 = -6LL;\n  while ( 1 )\n  {\n    printf(\"active arcs                : %ld\\n\", qword_407E58, v5);\n    sub_4027B0(dest);\n    printf(\"simplex iterations         : %ld\\n\", qword_407F08);\n    sub_400DA0(dest);\n    printf(\"objective value            : %0.0f\\n\");\n    if ( !++v1 )\n      break;\n    if ( qword_407E68 )\n    {\n      v2 = sub_402090(dest, -1LL, 0LL);\n      if ( v2 )\n        printf(\"erased arcs                : %ld\\n\", v2);\n    }\n    v3 = sub_401A80(dest);\n    if ( !v3 )\n      break;\n    printf(\"new implicit arcs          : %ld\\n\", v3);\n    if ( v3 < 0 )\n    {\n      puts(\"not enough memory, exit(-1)\");\n      exit(-1);\n    }\n  }\n  printf(\"checksum                   : %ld\\n\", qword_407F18);\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x400a20L", 
            "funcEndAddr": "0x400b0bL", 
            "funcName": "sub_400A20"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall main@<rax>(char **a1@<rsi>, char **a2@<rdx>, __int64 a3@<rax>, signed int a4@<edi>)\n{\n  unsigned int v4; // ebp\n  __int64 v5; // rax\n  __int64 v6; // rbx\n  __int64 v8; // [rsp-8h] [rbp-18h]\n\n  v8 = a3;\n  v4 = -1;\n  if ( a4 >= 2 )\n  {\n    puts(\"\\nMCF SPEC CPU2006 version 1.10\");\n    puts(\"Copyright (c) 1998-2000 Zuse Institut Berlin (ZIB)\");\n    puts(\"Copyright (c) 2000-2002 Andreas Loebel & ZIB\");\n    puts(\"Copyright (c) 2003-2005 Andreas Loebel\");\n    putchar(10);\n    memset(dest, 0, 0x270uLL);\n    qword_407EC0 = 10000000LL;\n    strcpy(dest, a1[1]);\n    if ( sub_401310(dest) )\n    {\n      puts(\"read error, exit\");\n      sub_4012C0(dest);\n    }\n    else\n    {\n      printf(\"nodes                      : %ld\\n\", qword_407E48, v8);\n      v5 = sub_402190(dest);\n      sub_400A20(v5);\n      puts(\"done\");\n      v6 = sub_402340(\"mcf.out\", dest);\n      sub_4012C0(dest);\n      v4 = -(v6 != 0);\n    }\n  }\n  return v4;\n}\n", 
            "funcStartAddr": "0x400b10L", 
            "funcEndAddr": "0x400bfbL", 
            "funcName": "main"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __fastcall sub_400C00(_QWORD *a1)\n{\n  unsigned __int64 result; // rax\n  unsigned __int64 i; // rcx\n  unsigned __int64 v3; // rcx\n  unsigned __int64 v4; // r8\n  unsigned __int64 v5; // rdx\n  __int64 v6; // rsi\n  __int64 v7; // rsi\n  _QWORD *v8; // rcx\n  _QWORD *v9; // rdx\n  __int64 v10; // rdi\n  __int64 v11; // rax\n  __int64 v12; // rax\n  bool v13; // cf\n\n  result = a1[69];\n  for ( i = a1[70]; result < i; result += 104LL )\n    *(_OWORD *)(result + 56) = 0LL;\n  v3 = a1[71];\n  v4 = a1[72];\n  if ( v3 < v4 )\n  {\n    v5 = v4 + ~v3;\n    if ( !(v5 & 0x40) )\n    {\n      v6 = *(_QWORD *)(v3 + 8);\n      *(_QWORD *)(v3 + 32) = *(_QWORD *)(v6 + 56);\n      *(_QWORD *)(v6 + 56) = v3;\n      v7 = *(_QWORD *)(v3 + 16);\n      *(_QWORD *)(v3 + 40) = *(_QWORD *)(v7 + 64);\n      *(_QWORD *)(v7 + 64) = v3;\n      v3 += 64LL;\n    }\n    if ( v5 >= 0x40 )\n    {\n      v8 = (_QWORD *)(v3 + 64);\n      v9 = v8;\n      do\n      {\n        v10 = *(v8 - 7);\n        *(v8 - 4) = *(_QWORD *)(v10 + 56);\n        *(_QWORD *)(v10 + 56) = v8 - 8;\n        v11 = *(v8 - 6);\n        *(v8 - 3) = *(_QWORD *)(v11 + 64);\n        *(_QWORD *)(v11 + 64) = v8 - 8;\n        v12 = v8[1];\n        v8[4] = *(_QWORD *)(v12 + 56);\n        *(_QWORD *)(v12 + 56) = v8;\n        result = v8[2];\n        v8[5] = *(_QWORD *)(result + 64);\n        *(_QWORD *)(result + 64) = v8;\n        v9 += 16;\n        v13 = (unsigned __int64)(v8 + 8) < v4;\n        v8 = v9;\n      }\n      while ( v13 );\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x400c00L", 
            "funcEndAddr": "0x400ce5L", 
            "funcName": "sub_400C00"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_400CF0(__int64 a1)\n{\n  _QWORD *v1; // r8\n  _QWORD *v2; // rdi\n  __int64 result; // rax\n  _QWORD *v4; // rdx\n  _QWORD *v5; // rcx\n  __int64 v6; // rsi\n  _QWORD *v7; // rsi\n\n  v1 = *(_QWORD **)(a1 + 552);\n  *v1 = -100000000LL;\n  v2 = (_QWORD *)v1[2];\n  result = 0LL;\n  if ( v2 != v1 )\n  {\n    v4 = (_QWORD *)v1[2];\n    do\n    {\n      if ( v2 )\n      {\n        do\n        {\n          v4 = v2;\n          if ( *((_DWORD *)v2 + 2) == 1 )\n          {\n            v5 = (_QWORD *)v2[3];\n            v6 = *(_QWORD *)v2[6] + *v5;\n          }\n          else\n          {\n            v5 = (_QWORD *)v2[3];\n            v6 = *v5 - *(_QWORD *)v2[6];\n            ++result;\n          }\n          *v2 = v6;\n          v2 = (_QWORD *)v2[2];\n        }\n        while ( v2 );\n      }\n      else\n      {\n        v5 = (_QWORD *)v4[3];\n      }\n      v7 = v4;\n      v2 = v4;\n      if ( v5 )\n      {\n        while ( 1 )\n        {\n          v4 = (_QWORD *)v7[4];\n          v7 = v5;\n          v2 = v4;\n          if ( v4 )\n            break;\n          v5 = (_QWORD *)v5[3];\n          if ( !v5 )\n          {\n            v4 = 0LL;\n            v2 = v7;\n            break;\n          }\n        }\n      }\n    }\n    while ( v2 != v1 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x400cf0L", 
            "funcEndAddr": "0x400d97L", 
            "funcName": "sub_400CF0"
        }, 
        {
            "decompiledFuncCode": "double __fastcall sub_400DA0(_QWORD *a1)\n{\n  char *v1; // rax\n  char *v2; // r9\n  __int64 v3; // rdx\n  signed __int64 v4; // rsi\n  int v5; // ecx\n  __int64 v6; // r8\n  signed __int64 i; // rdx\n  __int64 v8; // rdx\n  signed int v9; // er8\n  int v10; // ecx\n  __int64 v11; // rsi\n\n  v1 = (char *)a1[71];\n  v2 = (char *)a1[72];\n  if ( v1 != v2 )\n  {\n    v3 = a1[71];\n    if ( ((unsigned __int8)((unsigned int)((_DWORD)v2 - 64 - (_DWORD)v1) >> 6) + 1) & 7 )\n    {\n      v4 = -(signed __int64)(((unsigned __int8)((unsigned int)((_DWORD)v2 - 64 - (_DWORD)v1) >> 6) + 1) & 7);\n      v3 = a1[71];\n      do\n      {\n        *(_QWORD *)(v3 + 48) = *(_DWORD *)(v3 + 24) == 2;\n        v3 += 64LL;\n        ++v4;\n      }\n      while ( v4 );\n    }\n    if ( (unsigned __int64)(v2 - 64 - v1) >= 0x1C0 )\n    {\n      do\n      {\n        v5 = *(_DWORD *)(v3 + 88);\n        *(_QWORD *)(v3 + 48) = *(_DWORD *)(v3 + 24) == 2;\n        *(_QWORD *)(v3 + 112) = v5 == 2;\n        *(_QWORD *)(v3 + 176) = *(_DWORD *)(v3 + 152) == 2;\n        *(_QWORD *)(v3 + 240) = *(_DWORD *)(v3 + 216) == 2;\n        *(_QWORD *)(v3 + 304) = *(_DWORD *)(v3 + 280) == 2;\n        *(_QWORD *)(v3 + 368) = *(_DWORD *)(v3 + 344) == 2;\n        *(_QWORD *)(v3 + 432) = *(_DWORD *)(v3 + 408) == 2;\n        *(_QWORD *)(v3 + 496) = *(_DWORD *)(v3 + 472) == 2;\n        v3 += 512LL;\n      }\n      while ( v2 != (char *)v3 );\n    }\n  }\n  v6 = a1[70];\n  for ( i = a1[69] + 104LL; v6 != i; i += 104LL )\n    *(_QWORD *)(*(_QWORD *)(i + 48) + 48LL) = *(_QWORD *)(i + 80);\n  if ( v1 != v2 )\n  {\n    v8 = 0LL;\n    v9 = 0;\n    while ( 1 )\n    {\n      if ( *((_QWORD *)v1 + 6) )\n      {\n        v10 = *(_DWORD *)(*((_QWORD *)v1 + 1) + 96LL);\n        if ( v10 < 0 )\n        {\n          if ( *(_DWORD *)(*((_QWORD *)v1 + 2) + 96LL) <= 0 )\n          {\n            v11 = *(_QWORD *)v1;\nLABEL_17:\n            v8 += v11;\n            goto LABEL_18;\n          }\n        }\n        else\n        {\n          v11 = *(_QWORD *)v1;\n          if ( v10 )\n            goto LABEL_17;\n          ++v9;\n          v8 = v8 + v11 - a1[66];\n        }\n      }\nLABEL_18:\n      v1 += 64;\n      if ( v2 == v1 )\n        return (double)(signed int)v8 + (double)(signed int)a1[66] * (double)v9;\n    }\n  }\n  v9 = 0;\n  LODWORD(v8) = 0;\n  return (double)(signed int)v8 + (double)(signed int)a1[66] * (double)v9;\n}\n", 
            "funcStartAddr": "0x400da0L", 
            "funcEndAddr": "0x400f5fL", 
            "funcName": "sub_400DA0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __usercall sub_401120@<rax>(__int64 a1@<rax>, _QWORD *a2@<rdi>)\n{\n  unsigned __int64 v2; // rbp\n  unsigned __int64 v3; // rbx\n  unsigned __int64 v4; // r12\n  unsigned __int64 v5; // r14\n  unsigned __int64 v6; // rax\n  __int64 v7; // r13\n  __int64 v8; // rax\n  signed __int64 v9; // rbx\n  signed __int64 result; // rax\n  __int64 v11; // [rsp-8h] [rbp-38h]\n\n  v11 = a1;\n  v2 = a2[70];\n  v3 = a2[69] + 104LL;\n  if ( v3 < v2 )\n  {\n    v4 = a2[73];\n    v5 = a2[74];\n    while ( 1 )\n    {\n      v6 = *(_QWORD *)(v3 + 48);\n      v7 = *(_QWORD *)(v3 + 80);\n      if ( v6 < v4 || v6 >= v5 )\n      {\n        if ( v7 < -a2[64] || v7 - 1 > a2[64] )\n        {\n          v9 = 0LL;\n          printf(\"PRIMAL NETWORK SIMPLEX: \", v11);\n          printf(\"basis primal infeasible (%ld)\\n\", v7);\n          result = 1LL;\n          goto LABEL_15;\n        }\n      }\n      else\n      {\n        v8 = -v7;\n        if ( -v7 < 1 )\n          v8 = *(_QWORD *)(v3 + 80);\n        if ( v8 > a2[64] )\n        {\n          printf(\"PRIMAL NETWORK SIMPLEX: \", v11);\n          printf(\"artificial arc with nonzero flow, node %d (%ld)\\n\", *(unsigned int *)(v3 + 96), v7);\n        }\n      }\n      v3 += 104LL;\n      if ( v3 >= v2 )\n      {\n        v9 = 1LL;\n        result = 0LL;\n        goto LABEL_15;\n      }\n    }\n  }\n  result = 0LL;\n  v9 = 1LL;\nLABEL_15:\n  a2[61] = v9;\n  return result;\n}\n", 
            "funcStartAddr": "0x401120L", 
            "funcEndAddr": "0x40121eL", 
            "funcName": "sub_401120"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_401220(_QWORD *a1)\n{\n  unsigned __int64 v1; // rax\n  unsigned __int64 v2; // rcx\n  signed __int64 i; // rbx\n  __int64 v4; // rdx\n\n  v1 = a1[71];\n  v2 = a1[72];\n  for ( i = 0LL; v1 < v2; v1 += 64LL )\n  {\n    v4 = **(_QWORD **)(v1 + 16) + *(_QWORD *)v1 - **(_QWORD **)(v1 + 8);\n    if ( *(_DWORD *)(v1 + 24) >= 2u )\n    {\n      if ( *(_DWORD *)(v1 + 24) == 2 && v4 > a1[64] )\n      {\nLABEL_9:\n        i = 1LL;\n        fwrite(\"DUAL NETWORK SIMPLEX: \", 0x16uLL, 1uLL, stderr);\n        fwrite(\"basis dual infeasible\\n\", 0x16uLL, 1uLL, stderr);\n        return i;\n      }\n    }\n    else if ( v4 < -a1[64] )\n    {\n      goto LABEL_9;\n    }\n  }\n  return i;\n}\n", 
            "funcStartAddr": "0x401220L", 
            "funcEndAddr": "0x4012bbL", 
            "funcName": "sub_401220"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4012C0(__int64 a1)\n{\n  __int64 v1; // rbx\n  void *v2; // rdi\n  void *v3; // rdi\n  void *v4; // rdi\n  _OWORD *v5; // rbx\n\n  v1 = a1;\n  v2 = *(void **)(a1 + 552);\n  if ( v2 )\n    free(v2);\n  v3 = *(void **)(v1 + 568);\n  if ( v3 )\n    free(v3);\n  v4 = *(void **)(v1 + 584);\n  v5 = (_OWORD *)(v1 + 552);\n  if ( v4 )\n    free(v4);\n  v5[2] = 0LL;\n  v5[1] = 0LL;\n  *v5 = 0LL;\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x4012c0L", 
            "funcEndAddr": "0x401310L", 
            "funcName": "sub_4012C0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_401310(__int64 a1)\n{\n  FILE *v1; // rax\n  FILE *v2; // rbx\n  signed __int64 v3; // r15\n  signed __int64 v4; // rdx\n  __int64 v5; // rax\n  size_t v6; // r12\n  signed __int64 v7; // r15\n  size_t v8; // rbx\n  signed __int64 v9; // rcx\n  char *v10; // r13\n  char *v11; // r14\n  _QWORD *v12; // rbx\n  __int64 v13; // r8\n  signed __int64 v14; // r14\n  signed int v15; // er12\n  signed __int64 v16; // r15\n  int v17; // edx\n  int v18; // ecx\n  __int64 v19; // rsi\n  signed __int64 v20; // rax\n  signed __int64 v21; // rcx\n  signed __int64 v22; // rsi\n  signed __int64 v23; // rcx\n  signed __int64 v24; // rsi\n  bool v25; // sf\n  unsigned __int8 v26; // of\n  __int64 v27; // r15\n  __int64 v28; // rbp\n  FILE *v29; // r12\n  __int64 v30; // rax\n  __int64 v31; // rcx\n  __int64 v32; // rdx\n  unsigned __int64 v34; // rax\n  signed __int64 v35; // rbx\n  __int64 v36; // rsi\n  __int64 v37; // rax\n  signed __int64 v38; // rcx\n  signed __int64 v39; // rcx\n  signed __int64 v40; // rbp\n  signed __int64 v41; // rsi\n  signed __int64 *v42; // rdi\n  signed __int64 v43; // rdx\n  signed __int64 v44; // rsi\n  __int64 v45; // [rsp+0h] [rbp-138h]\n  __int64 v46; // [rsp+8h] [rbp-130h]\n  FILE *stream; // [rsp+10h] [rbp-128h]\n  __int64 v48; // [rsp+18h] [rbp-120h]\n  __int64 v49; // [rsp+20h] [rbp-118h]\n  __int64 v50; // [rsp+28h] [rbp-110h]\n  char s; // [rsp+30h] [rbp-108h]\n\n  v1 = fopen((const char *)a1, \"r\");\n  v2 = v1;\n  v3 = -1LL;\n  if ( v1 )\n  {\n    fgets(&s, 200, v1);\n    if ( (unsigned int)__isoc99_sscanf(&s, \"%ld %ld\", &v46, &v45) == 2 )\n    {\n      stream = v2;\n      v4 = v46;\n      *(_QWORD *)(a1 + 408) = v46;\n      v5 = v45;\n      *(_QWORD *)(a1 + 432) = v45;\n      v6 = 2 * v4 + 1;\n      *(_QWORD *)(a1 + 400) = v6;\n      v7 = v5 + 3 * v4;\n      *(_QWORD *)(a1 + 424) = v7;\n      v8 = 27328512LL;\n      if ( v4 < 15001 )\n        v8 = v5 + 3 * v4;\n      v9 = 28900000LL;\n      if ( v4 < 15001 )\n        v9 = 3000000LL;\n      *(_QWORD *)(a1 + 416) = v8;\n      *(_QWORD *)(a1 + 456) = v9;\n      *(_QWORD *)(a1 + 448) = v8 - v7;\n      v49 = v4;\n      v10 = (char *)calloc(2 * v4 + 2, 0x68uLL);\n      *(_QWORD *)(a1 + 552) = v10;\n      v11 = (char *)calloc(v6, 0x40uLL);\n      *(_QWORD *)(a1 + 584) = v11;\n      v12 = calloc(v8, 0x40uLL);\n      *(_QWORD *)(a1 + 568) = v12;\n      if ( v12 && v10 && v11 )\n      {\n        *(_QWORD *)(a1 + 560) = &v10[104 * v6 + 104];\n        *(_QWORD *)(a1 + 576) = &v12[8 * v7];\n        *(_QWORD *)(a1 + 592) = &v11[64 * v6];\n        v13 = v49;\n        v48 = a1;\n        if ( v49 > 0 )\n        {\n          v14 = (signed __int64)(v10 + 104);\n          v15 = -1;\n          v16 = 1LL;\n          while ( 1 )\n          {\n            fgets(&s, 200, stream);\n            if ( (unsigned int)__isoc99_sscanf(&s, \"%ld %ld\", &v46, &v45) != 2 )\n              return -1LL;\n            v17 = v46;\n            v18 = v45;\n            if ( v46 > v45 )\n              return -1LL;\n            *(_DWORD *)(v14 + 96) = v15;\n            *(_QWORD *)(v14 + 80) = -1LL;\n            v19 = v48;\n            v13 = *(_QWORD *)(v48 + 408);\n            v20 = 104 * (v16 + v13);\n            *(_DWORD *)&v10[v20 + 96] = v16;\n            *(_QWORD *)&v10[v20 + 80] = 1LL;\n            *(_DWORD *)(v14 + 100) = v17;\n            *(_DWORD *)&v10[v20 + 100] = v18;\n            v21 = 104LL * *(_QWORD *)(v19 + 400);\n            v12[1] = &v10[v21];\n            v12[2] = v14;\n            v22 = *(_QWORD *)(v19 + 528);\n            *v12 = v22 + 15;\n            v12[7] = v22 + 15;\n            v12[4] = *(_QWORD *)&v10[v21 + 56];\n            *(_QWORD *)&v10[v21 + 56] = v12;\n            v12[5] = *(_QWORD *)(v14 + 64);\n            *(_QWORD *)(v14 + 64) = v12;\n            v12[9] = &v10[v20];\n            v12[10] = &v10[v21];\n            v12[8] = 15LL;\n            v12[15] = 15LL;\n            v12[12] = *(_QWORD *)&v10[v20 + 56];\n            *(_QWORD *)&v10[v20 + 56] = v12 + 8;\n            v12[13] = *(_QWORD *)&v10[v21 + 64];\n            *(_QWORD *)&v10[v21 + 64] = v12 + 8;\n            v12[17] = v14;\n            v12[18] = &v10[v20];\n            v23 = (signed __int64)(v12 + 16);\n            if ( v22 <= 9999999 )\n              v22 = 10000000LL;\n            v24 = 2 * v22;\n            v12[16] = v24;\n            v12[23] = v24;\n            v12[20] = *(_QWORD *)(v14 + 56);\n            *(_QWORD *)(v14 + 56) = v23;\n            v12[21] = *(_QWORD *)&v10[v20 + 64];\n            *(_QWORD *)&v10[v20 + 64] = v23;\n            v12 += 24;\n            v14 += 104LL;\n            --v15;\n            v26 = __OFSUB__(v16, v13);\n            v25 = v16++ - v13 < 0;\n            if ( !(v25 ^ v26) )\n              goto LABEL_20;\n          }\n        }\n        v16 = 1LL;\nLABEL_20:\n        if ( v16 != v13 + 1 )\n          return -1LL;\n        v27 = v48;\n        if ( *(_QWORD *)(v48 + 432) > 0LL )\n        {\n          v28 = 0LL;\n          v29 = stream;\n          while ( 1 )\n          {\n            fgets(&s, 200, v29);\n            if ( (unsigned int)__isoc99_sscanf(&s, \"%ld %ld %ld\", &v46, &v45) != 3 )\n              return -1LL;\n            v30 = 104 * (v46 + *(_QWORD *)(v27 + 408));\n            v12[1] = &v10[v30];\n            v31 = 104 * v45;\n            v12[2] = &v10[104 * v45];\n            v32 = v50;\n            v12[7] = v50;\n            *v12 = v32;\n            v12[4] = *(_QWORD *)&v10[v30 + 56];\n            *(_QWORD *)&v10[v30 + 56] = v12;\n            v12[5] = *(_QWORD *)&v10[v31 + 64];\n            *(_QWORD *)&v10[v31 + 64] = v12;\n            ++v28;\n            v12 += 8;\n            if ( v28 >= *(_QWORD *)(v27 + 432) )\n              goto LABEL_29;\n          }\n        }\n        v29 = stream;\nLABEL_29:\n        if ( *(_QWORD **)(v27 + 576) != v12 )\n        {\n          *(_QWORD *)(v27 + 576) = v12;\n          v34 = *(_QWORD *)(v27 + 568);\n          if ( v34 >= (unsigned __int64)v12 )\n            v35 = 0LL;\n          else\n            v35 = (((unsigned __int64)v12 + ~v34) >> 6) + 1;\n          *(_QWORD *)(v27 + 424) = v35;\n          *(_QWORD *)(v27 + 432) = v35;\n        }\n        fclose(v29);\n        *(_BYTE *)(v27 + 200) = 0;\n        v36 = *(_QWORD *)(v27 + 408);\n        if ( v36 > 0 )\n        {\n          v37 = *(_QWORD *)(v27 + 568);\n          v38 = 10000000LL;\n          if ( *(_QWORD *)(v27 + 528) > 9999999LL )\n            v38 = *(_QWORD *)(v27 + 528);\n          v39 = -2 * v38;\n          v40 = *(_QWORD *)(v27 + 408) & 1LL;\n          if ( v36 == 1 )\n          {\n            v41 = 2LL;\n            if ( !v40 )\n              return 0LL;\n          }\n          else\n          {\n            v42 = (signed __int64 *)(v37 + 376);\n            v43 = v40 - v36;\n            v41 = 2LL;\n            do\n            {\n              *(v42 - 31) = v39;\n              *(v42 - 24) = v39;\n              *(v42 - 7) = v39;\n              *v42 = v39;\n              v42 += 48;\n              v41 += 6LL;\n              v43 += 2LL;\n            }\n            while ( v43 );\n            if ( !v40 )\n              return 0LL;\n          }\n          v44 = v41 << 6;\n          *(_QWORD *)(v37 + v44) = v39;\n          *(_QWORD *)(v37 + v44 + 56) = v39;\n        }\n        return 0LL;\n      }\n      puts(\"read_min(): not enough memory\");\n      sub_4012C0(a1);\n      v3 = -1LL;\n    }\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x401310L", 
            "funcEndAddr": "0x401820L", 
            "funcName": "sub_401310"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_401820(_QWORD *a1)\n{\n  _QWORD *v1; // rbx\n  __int64 v2; // rax\n  void *v3; // rdi\n  __int64 v4; // rsi\n  char *v5; // rax\n  __int64 v6; // rcx\n  __int64 v7; // rdx\n  unsigned __int64 v8; // rsi\n  unsigned __int64 v9; // rdi\n  char *v10; // rax\n  signed __int64 v11; // rcx\n\n  v1 = a1;\n  v2 = a1[57];\n  v3 = (void *)a1[71];\n  v4 = v2 + v1[52];\n  v1[52] = v4;\n  v1[56] += v2;\n  v5 = (char *)realloc(v3, v4 << 6);\n  if ( v5 )\n  {\n    v6 = v1[71];\n    v1[71] = v5;\n    v7 = v1[69];\n    v1[72] = &v5[64 * v1[53]];\n    v8 = v1[70];\n    v9 = v7 + 104;\n    if ( v7 + 104 >= v8 )\n    {\n      v11 = 0LL;\n    }\n    else\n    {\n      v10 = &v5[-v6];\n      v11 = 0LL;\n      do\n      {\n        if ( *(_QWORD *)(v9 + 24) != v7 )\n          *(_QWORD *)(v9 + 48) += v10;\n        v9 += 104LL;\n      }\n      while ( v9 < v8 );\n    }\n  }\n  else\n  {\n    printf(\"network %s: not enough memory\\n\", v1);\n    fflush(stdout);\n    v11 = -1LL;\n  }\n  return v11;\n}\n", 
            "funcStartAddr": "0x401820L", 
            "funcEndAddr": "0x4018e0L", 
            "funcName": "sub_401820"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_401A80(_QWORD *a1)\n{\n  signed __int64 v1; // r8\n  __int64 v2; // rbx\n  signed __int64 v3; // rax\n  __int64 v4; // rcx\n  signed __int64 v5; // rcx\n  signed __int64 result; // rax\n  signed __int64 v7; // rax\n  __int64 v8; // r10\n  __int64 v9; // r11\n  signed __int64 v10; // r14\n  signed __int64 v11; // rbx\n  signed __int64 v12; // rsi\n  __int64 v13; // rbp\n  __int64 v14; // r12\n  signed __int64 v15; // r15\n  signed __int64 v16; // r13\n  signed __int64 v17; // rbp\n  signed __int64 v18; // rcx\n  signed __int64 v19; // r8\n  signed __int64 v20; // rbp\n  signed __int64 v21; // rdi\n  signed __int64 v22; // rcx\n  signed __int64 v23; // rax\n  signed __int64 v24; // r9\n  signed __int64 v25; // rdi\n  __int64 v26; // rbx\n  signed __int64 v27; // r12\n  signed __int64 v28; // r8\n  signed __int64 v29; // rbp\n  signed __int64 v30; // rcx\n  signed __int64 v31; // rdi\n  signed __int64 v32; // rcx\n  __int64 v33; // rdx\n  signed __int64 v34; // rdx\n  unsigned __int64 v35; // rsi\n  signed __int64 v36; // rcx\n  __int64 v37; // rcx\n  __int64 v38; // rcx\n  __int64 v39; // rcx\n  __int64 v40; // rcx\n  __int64 v41; // rsi\n  __int64 v42; // rsi\n  signed __int64 v43; // [rsp+8h] [rbp-60h]\n  signed __int64 v44; // [rsp+10h] [rbp-58h]\n  signed __int64 v45; // [rsp+18h] [rbp-50h]\n  _QWORD *v46; // [rsp+20h] [rbp-48h]\n  signed __int64 *v47; // [rsp+28h] [rbp-40h]\n  signed __int64 v48; // [rsp+30h] [rbp-38h]\n\n  v1 = a1[51];\n  v2 = a1[66];\n  if ( v1 >= 15001 )\n  {\n    v47 = a1 + 72;\n    v8 = a1[71];\n    v9 = a1[72];\n    v7 = 0LL;\n    goto LABEL_9;\n  }\n  v3 = a1[52];\n  v4 = a1[53];\n  if ( v4 + a1[57] <= v3 || (signed __int64)(((unsigned __int64)(v1 * v1) >> 1) + v4) <= v3 )\n  {\n    v7 = 0LL;\n  }\n  else\n  {\n    v5 = sub_401820(a1);\n    result = -1LL;\n    if ( v5 )\n      return result;\n    sub_400C00(a1);\n    v1 = a1[51];\n    v7 = 1LL;\n  }\n  v8 = a1[71];\n  v9 = a1[72];\n  v47 = a1 + 72;\n  if ( v1 > 0 )\n  {\nLABEL_9:\n    v10 = 0LL;\n    do\n    {\n      if ( *(_DWORD *)(v8 + 88) != -1 )\n        break;\n      ++v10;\n      v8 += 192LL;\n    }\n    while ( v10 < v1 );\n    if ( v10 < v1 )\n      goto LABEL_13;\n    return 0LL;\n  }\n  v10 = 0LL;\n  if ( v1 <= 0 )\n    return 0LL;\nLABEL_13:\n  v48 = v7;\n  v11 = v2 - 15;\n  v12 = 0LL;\n  result = 0LL;\n  v45 = v11;\n  v44 = v1;\n  v46 = a1;\n  do\n  {\n    if ( *(_DWORD *)(v8 + 88) != -1 )\n    {\n      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 16) + 56LL) + 16LL) + 72LL) = v12;\n      v12 = v8 + 64;\n    }\n    if ( *(_DWORD *)(v8 + 24) != -1 )\n    {\n      v13 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 72LL);\n      if ( v13 )\n      {\n        v14 = *(_QWORD *)(v8 + 16);\n        v15 = *(signed int *)(v14 + 100) + v11 - *(_QWORD *)(v8 + 56);\n        do\n        {\n          v33 = *(_QWORD *)(v13 + 8);\n          if ( *(_QWORD *)(v13 + 56) + (signed __int64)*(signed int *)(v33 + 100) <= v15 )\n          {\n            v16 = *(_QWORD *)v14 + 30LL - *(_QWORD *)v33;\n            if ( v16 < 0 )\n            {\n              v17 = a1[56];\n              if ( result >= v17 )\n              {\n                if ( *(_QWORD *)(v9 + 48) > v16 )\n                {\n                  v43 = v12;\n                  *(_QWORD *)(v9 + 8) = v33;\n                  *(_QWORD *)(v9 + 16) = v14;\n                  *(_QWORD *)(v9 + 56) = 30LL;\n                  *(_QWORD *)v9 = 30LL;\n                  *(_QWORD *)(v9 + 48) = v16;\n                  v24 = 3LL - (*(_QWORD *)(v9 + 112) > *(_QWORD *)(v9 + 176));\n                  if ( v24 <= v17 )\n                  {\n                    v25 = 1LL;\n                    while ( 1 )\n                    {\n                      v26 = v14;\n                      v27 = v17;\n                      v28 = v24;\n                      v29 = (v24 - 1) << 6;\n                      v30 = *(_QWORD *)(v9 + v29 + 48);\n                      if ( v30 <= v16 )\n                        break;\n                      v31 = v25 << 6;\n                      *(_QWORD *)(v9 + v31 - 48) = *(_QWORD *)(v9 + v29 + 16);\n                      *(_OWORD *)(v9 + v31 - 64) = *(_OWORD *)(v9 + v29);\n                      *(_QWORD *)(v9 + v31 - 8) = *(_QWORD *)(v9 + v29);\n                      *(_QWORD *)(v9 + v31 - 16) = v30;\n                      *(_QWORD *)(v9 + v29 + 8) = v33;\n                      *(_QWORD *)(v9 + v29 + 16) = v26;\n                      *(_QWORD *)(v9 + v29) = 30LL;\n                      *(_QWORD *)(v9 + v29 + 56) = 30LL;\n                      *(_QWORD *)(v9 + v29 + 48) = v16;\n                      v24 *= 2LL;\n                      v32 = 2 * v28 + 1;\n                      v17 = v27;\n                      if ( v32 <= v27 )\n                      {\n                        if ( *(_QWORD *)(v9 + (v28 << 7) - 16) >= *(_QWORD *)(v9 + (v28 << 7) + 48) )\n                          v32 = 2 * v28;\n                        v24 = v32;\n                      }\n                      v12 = v43;\n                      v14 = v26;\n                      v25 = v28;\n                      if ( v24 > v17 )\n                      {\n                        a1 = v46;\n                        v11 = v45;\n                        v1 = v44;\n                        goto LABEL_40;\n                      }\n                    }\n                    a1 = v46;\n                    v1 = v44;\n                    v14 = v26;\n                    v11 = v45;\n                  }\n                }\n              }\n              else\n              {\n                v18 = result << 6;\n                *(_QWORD *)(v9 + v18 + 8) = v33;\n                *(_QWORD *)(v9 + v18 + 16) = v14;\n                *(_QWORD *)(v9 + v18 + 56) = 30LL;\n                *(_QWORD *)(v9 + v18) = 30LL;\n                *(_QWORD *)(v9 + v18 + 48) = v16;\n                if ( result )\n                {\n                  v19 = result + 1;\n                  v20 = result + 1;\n                  do\n                  {\n                    v20 /= 2LL;\n                    v21 = (v20 - 1) << 6;\n                    v22 = *(_QWORD *)(v9 + v21 + 48);\n                    if ( v22 >= v16 )\n                      break;\n                    v23 = result << 6;\n                    *(_QWORD *)(v9 + v23 + 16) = *(_QWORD *)(v9 + v21 + 16);\n                    *(_OWORD *)(v9 + v23) = *(_OWORD *)(v9 + v21);\n                    *(_QWORD *)(v9 + v23 + 56) = *(_QWORD *)(v9 + v21);\n                    *(_QWORD *)(v9 + v23 + 48) = v22;\n                    *(_QWORD *)(v9 + v21 + 8) = v33;\n                    *(_QWORD *)(v9 + v21 + 16) = v14;\n                    *(_QWORD *)(v9 + v21) = 30LL;\n                    *(_QWORD *)(v9 + v21 + 56) = 30LL;\n                    *(_QWORD *)(v9 + v21 + 48) = v16;\n                    result = v20 - 1;\n                  }\n                  while ( v20 != 1 );\n                  result = v19;\n                  a1 = v46;\n                  v11 = v45;\n                  v1 = v44;\n                }\n                else\n                {\n                  result = 1LL;\n                }\n              }\n            }\n          }\nLABEL_40:\n          v13 = *(_QWORD *)(v33 + 72);\n        }\n        while ( v13 );\n      }\n    }\n    ++v10;\n    v8 += 192LL;\n  }\n  while ( v10 != v1 );\n  if ( !result )\n    return 0LL;\n  v34 = v9 + (result << 6);\n  *v47 = v34;\n  v35 = (result << 6) - 64;\n  if ( v48 )\n  {\n    if ( ((unsigned __int8)((unsigned int)v35 >> 6) + 1) & 7 )\n    {\n      v36 = -(signed __int64)(((unsigned __int8)((unsigned int)v35 >> 6) + 1) & 7);\n      do\n      {\n        *(_QWORD *)(v9 + 48) = 0LL;\n        *(_DWORD *)(v9 + 24) = 1;\n        v9 += 64LL;\n        ++v36;\n      }\n      while ( v36 );\n    }\n    if ( v35 >= 0x1C0 )\n    {\n      do\n      {\n        *(_QWORD *)(v9 + 48) = 0LL;\n        *(_DWORD *)(v9 + 24) = 1;\n        *(_QWORD *)(v9 + 112) = 0LL;\n        *(_DWORD *)(v9 + 88) = 1;\n        *(_QWORD *)(v9 + 176) = 0LL;\n        *(_DWORD *)(v9 + 152) = 1;\n        *(_QWORD *)(v9 + 240) = 0LL;\n        *(_DWORD *)(v9 + 216) = 1;\n        *(_QWORD *)(v9 + 304) = 0LL;\n        *(_DWORD *)(v9 + 280) = 1;\n        *(_QWORD *)(v9 + 368) = 0LL;\n        *(_DWORD *)(v9 + 344) = 1;\n        *(_QWORD *)(v9 + 432) = 0LL;\n        *(_DWORD *)(v9 + 408) = 1;\n        *(_QWORD *)(v9 + 496) = 0LL;\n        *(_DWORD *)(v9 + 472) = 1;\n        v9 += 512LL;\n      }\n      while ( v34 != v9 );\n    }\n  }\n  else\n  {\n    if ( !(v35 & 0x40) )\n    {\n      *(_QWORD *)(v9 + 48) = 0LL;\n      *(_DWORD *)(v9 + 24) = 1;\n      v37 = *(_QWORD *)(v9 + 8);\n      *(_QWORD *)(v9 + 32) = *(_QWORD *)(v37 + 56);\n      *(_QWORD *)(v37 + 56) = v9;\n      v38 = *(_QWORD *)(v9 + 16);\n      *(_QWORD *)(v9 + 40) = *(_QWORD *)(v38 + 64);\n      *(_QWORD *)(v38 + 64) = v9;\n      v9 += 64LL;\n    }\n    if ( result << 6 != 64 )\n    {\n      do\n      {\n        *(_QWORD *)(v9 + 48) = 0LL;\n        *(_DWORD *)(v9 + 24) = 1;\n        v39 = *(_QWORD *)(v9 + 8);\n        *(_QWORD *)(v9 + 32) = *(_QWORD *)(v39 + 56);\n        *(_QWORD *)(v39 + 56) = v9;\n        v40 = *(_QWORD *)(v9 + 16);\n        *(_QWORD *)(v9 + 40) = *(_QWORD *)(v40 + 64);\n        *(_QWORD *)(v40 + 64) = v9;\n        *(_QWORD *)(v9 + 112) = 0LL;\n        *(_DWORD *)(v9 + 88) = 1;\n        v41 = *(_QWORD *)(v9 + 72);\n        *(_QWORD *)(v9 + 96) = *(_QWORD *)(v41 + 56);\n        *(_QWORD *)(v41 + 56) = v9 + 64;\n        v42 = *(_QWORD *)(v9 + 80);\n        *(_QWORD *)(v9 + 104) = *(_QWORD *)(v42 + 64);\n        *(_QWORD *)(v42 + 64) = v9 + 64;\n        v9 += 128LL;\n      }\n      while ( v34 != v9 );\n    }\n  }\n  a1[53] += result;\n  a1[55] += result;\n  a1[56] -= result;\n  return result;\n}\n", 
            "funcStartAddr": "0x401a80L", 
            "funcEndAddr": "0x402081L", 
            "funcName": "sub_401A80"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_402090(_QWORD *a1, signed __int64 a2, __int64 a3)\n{\n  __int64 v3; // r14\n  unsigned __int64 v4; // r8\n  __int128 *v5; // rax\n  _OWORD *v6; // rdx\n  int v7; // ebx\n  signed __int64 v8; // rcx\n  __int64 v9; // rbx\n  __int128 v10; // xmm0\n  __int128 v11; // xmm1\n  __int128 v12; // xmm2\n\n  if ( a3 )\n  {\n    v3 = a1[55];\n    if ( v3 )\n      goto LABEL_17;\n    return 0LL;\n  }\n  v4 = a1[72];\n  v5 = (__int128 *)(a1[71] + ((a1[53] - a1[55]) << 6));\n  v3 = 0LL;\n  if ( (unsigned __int64)v5 < v4 )\n  {\n    v6 = (_OWORD *)(a1[71] + ((a1[53] - a1[55]) << 6));\n    while ( 1 )\n    {\n      v7 = *((_DWORD *)v5 + 6);\n      v8 = -2LL;\n      if ( v7 )\n      {\n        if ( v7 == 1 )\n          v8 = **((_QWORD **)v5 + 2) + *(_QWORD *)v5 - **((_QWORD **)v5 + 1);\n        if ( v8 <= a2 )\n          goto LABEL_14;\n      }\n      else\n      {\n        v9 = *((_QWORD *)v5 + 1);\n        if ( v5 != *(__int128 **)(v9 + 48) )\n          v9 = *((_QWORD *)v5 + 2);\n        *(_QWORD *)(v9 + 48) = v6;\n        if ( a2 >= -2 )\n        {\nLABEL_14:\n          v10 = *v5;\n          v11 = v5[1];\n          v12 = v5[2];\n          v6[3] = v5[3];\n          v6[2] = v12;\n          v6[1] = v11;\n          *v6 = v10;\n          v6 += 4;\n          goto LABEL_15;\n        }\n      }\n      ++v3;\nLABEL_15:\n      v5 += 4;\n      if ( (unsigned __int64)v5 >= v4 )\n      {\n        if ( v3 )\n        {\nLABEL_17:\n          a1[53] -= v3;\n          a1[55] -= v3;\n          a1[72] -= v3 << 6;\n          a1[56] += v3;\n          sub_400C00(a1);\n          return v3;\n        }\n        return 0LL;\n      }\n    }\n  }\n  return v3;\n}\n", 
            "funcStartAddr": "0x402090L", 
            "funcEndAddr": "0x40218fL", 
            "funcName": "sub_402090"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_402190(_QWORD *a1)\n{\n  __m128i *v1; // r10\n  char *v2; // rdx\n  char *v3; // rsi\n  unsigned __int64 v4; // r9\n  signed __int64 v5; // rcx\n  __m128i *v6; // rcx\n  __int64 v7; // rsi\n  signed __int64 v8; // rcx\n  __m128i v9; // xmm0\n  __m128i *v10; // rdx\n  __m128i *v11; // rdi\n  __m128i *v12; // rdx\n\n  v1 = (__m128i *)a1[69];\n  v1[3].m128i_i64[0] = 0LL;\n  v1[1].m128i_i64[1] = 0LL;\n  v1[1].m128i_i64[0] = (__int64)&v1[6].m128i_i64[1];\n  _mm_storeu_si128(v1 + 2, (__m128i)0LL);\n  v1[5].m128i_i64[1] = a1[50] + 1LL;\n  LODWORD(v1->m128i_i64[1]) = 0;\n  v1->m128i_i64[0] = -100000000LL;\n  v1[5].m128i_i64[0] = 0LL;\n  v2 = (char *)a1[71];\n  v3 = (char *)a1[72];\n  if ( v2 != v3 )\n  {\n    v4 = v3 - 64 - v2;\n    if ( ((unsigned __int8)((unsigned int)((_DWORD)v3 - 64 - (_DWORD)v2) >> 6) + 1) & 3 )\n    {\n      v5 = -(signed __int64)(((unsigned __int8)((unsigned int)((_DWORD)v3 - 64 - (_DWORD)v2) >> 6) + 1) & 3);\n      do\n      {\n        if ( *((_DWORD *)v2 + 6) != -1 )\n          *((_DWORD *)v2 + 6) = 1;\n        v2 += 64;\n        ++v5;\n      }\n      while ( v5 );\n    }\n    if ( v4 >= 0xC0 )\n    {\n      do\n      {\n        if ( *((_DWORD *)v2 + 6) != -1 )\n          *((_DWORD *)v2 + 6) = 1;\n        if ( *((_DWORD *)v2 + 22) != -1 )\n          *((_DWORD *)v2 + 22) = 1;\n        if ( *((_DWORD *)v2 + 38) != -1 )\n          *((_DWORD *)v2 + 38) = 1;\n        if ( *((_DWORD *)v2 + 54) != -1 )\n          *((_DWORD *)v2 + 54) = 1;\n        v2 += 256;\n      }\n      while ( v3 != v2 );\n    }\n  }\n  v6 = (__m128i *)a1[70];\n  if ( &v1[6].m128i_u64[1] == (unsigned __int64 *)v6 )\n  {\n    v12 = v1 + 2;\n  }\n  else\n  {\n    v7 = a1[73];\n    v8 = (signed __int64)&v6[-7].m128i_i64[1];\n    v9 = _mm_slli_si128((__m128i)1uLL, 8);\n    v10 = v1;\n    do\n    {\n      v11 = v10;\n      v10 = (__m128i *)((char *)v10 + 104);\n      v11[9].m128i_i64[1] = v7;\n      v11[8].m128i_i64[0] = (__int64)v1;\n      v11[7].m128i_i64[1] = 0LL;\n      v11[8].m128i_i64[1] = (__int64)v11[13].m128i_i64;\n      v11[9].m128i_i64[0] = (__int64)v11;\n      *(_QWORD *)v7 = 100000000LL;\n      *(_DWORD *)(v7 + 24) = 0;\n      v11[7].m128i_i32[0] = 1;\n      v11[6].m128i_i64[1] = 0LL;\n      *(_QWORD *)(v7 + 8) = v10;\n      *(_QWORD *)(v7 + 16) = v1;\n      _mm_storeu_si128((__m128i *)((char *)v11 + 184), v9);\n      v7 += 64LL;\n    }\n    while ( (__m128i *)v8 != v10 );\n    v12 = v10 + 2;\n  }\n  v12->m128i_i64[0] = 0LL;\n  v1[9].m128i_i64[0] = 0LL;\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x402190L", 
            "funcEndAddr": "0x402337L", 
            "funcName": "sub_402190"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __usercall sub_402340@<rax>(__int64 a1@<rax>, const char *a2@<rdi>, _QWORD *a3@<rsi>)\n{\n  __int64 v3; // rbp\n  __int64 v4; // r12\n  FILE *v5; // r15\n  signed __int64 v6; // r14\n  _QWORD *v7; // r13\n  unsigned __int64 v8; // r12\n  _QWORD *v9; // rbp\n  _QWORD *v10; // rax\n  __int64 v12; // [rsp-8h] [rbp-38h]\n\n  v12 = a1;\n  v3 = a3[55];\n  v4 = a3[72];\n  v5 = fopen(a2, \"w\");\n  v6 = -1LL;\n  if ( v5 )\n  {\n    sub_400C00(a3);\n    v7 = *(_QWORD **)(a3[69] + 104LL * a3[50] + 56);\n    if ( v7 )\n    {\n      v8 = v4 - (v3 << 6);\n      while ( !v7[6] )\n      {\nLABEL_15:\n        v7 = (_QWORD *)v7[4];\n        if ( !v7 )\n          goto LABEL_16;\n      }\n      fwrite(\"()\\n\", 3uLL, 1uLL, v5);\n      v9 = v7;\n      while ( 1 )\n      {\n        if ( (unsigned __int64)v9 >= v8 )\n          fwrite(\"***\\n\", 4uLL, 1uLL, v5);\n        fprintf(v5, \"%d\\n\", (unsigned int)-*(_DWORD *)(v9[2] + 96LL), v12);\n        v10 = *(_QWORD **)(v9[2] + 104LL * a3[51] + 56);\n        if ( !v10 )\n          break;\n        while ( !v10[6] )\n        {\n          v10 = (_QWORD *)v10[4];\n          if ( !v10 )\n            goto LABEL_17;\n        }\n        v9 = 0LL;\n        if ( *(_DWORD *)(v10[2] + 96LL) )\n          v9 = v10;\n        if ( !v9 )\n          goto LABEL_15;\n      }\nLABEL_17:\n      fclose(v5);\n    }\n    else\n    {\nLABEL_16:\n      fclose(v5);\n      v6 = 0LL;\n    }\n  }\n  return v6;\n}\n", 
            "funcStartAddr": "0x402340L", 
            "funcEndAddr": "0x402484L", 
            "funcName": "sub_402340"
        }, 
        {
            "decompiledFuncCode": "__m128i *__fastcall sub_402490(__int64 a1, _BOOL4 a2, __int64 a3, __int64 a4, __m128i *a5, __m128i *a6, __m128i *a7, __m128i *a8, __m128i *a9, __int64 a10, __int64 a11, __int64 a12)\n{\n  __int64 v12; // r12\n  __m128i *v13; // rax\n  __int64 v14; // r11\n  __int64 v15; // r11\n  __m128i *v16; // r13\n  __m128i *result; // rax\n  __int64 *v18; // rbx\n  unsigned __int64 v19; // r11\n  __int64 v20; // rbx\n  __m128i *v21; // r10\n  __int64 v22; // r14\n  __int64 v23; // rbp\n  bool v24; // zf\n  __m128i *v25; // rbp\n  __int64 v26; // rbp\n  _BOOL8 v27; // r15\n  __int64 v28; // rbp\n  __int64 v29; // rbp\n  __int64 v30; // r14\n  __int64 v31; // r10\n  __int64 v32; // rcx\n  __m128i v33; // xmm1\n  __int64 v34; // rcx\n\n  v12 = a10;\n  v13 = *(__m128i **)(a10 + 8);\n  if ( (a11 >= 0 || v13 != a6) && (a11 <= 0 || v13 != a5) )\n  {\n    v15 = -a11;\n    if ( -a11 < 1 )\n      v15 = a11;\n    v14 = -v15;\n  }\n  else\n  {\n    v14 = -a11;\n    if ( -a11 < 1 )\n      v14 = a11;\n  }\n  v16 = a8;\n  result = a7;\n  do\n  {\nLABEL_12:\n    v18 = (__int64 *)result;\n    *v18 += v14;\n    result = (__m128i *)result[1].m128i_i64[0];\n  }\n  while ( result );\n  while ( v18 != (__int64 *)a7 )\n  {\n    result = (__m128i *)v18[4];\n    if ( result )\n      goto LABEL_12;\n    v18 = (__int64 *)v18[3];\n  }\n  v19 = a7[5].m128i_u64[1];\n  if ( a5 != a8 )\n  {\n    v20 = a7[5].m128i_i64[1];\n    v21 = a6;\n    do\n    {\n      result = a5;\n      a5 = (__m128i *)a5[1].m128i_i64[1];\n      v22 = result[2].m128i_i64[0];\n      if ( v22 )\n        *(_QWORD *)(v22 + 40) = result[2].m128i_i64[1];\n      v23 = result[2].m128i_i64[1];\n      v24 = v23 == 0;\n      v25 = (__m128i *)(v23 + 32);\n      if ( v24 )\n        v25 = a5 + 1;\n      v25->m128i_i64[0] = v22;\n      result[1].m128i_i64[1] = (__int64)v21;\n      v26 = v21[1].m128i_i64[0];\n      result[2].m128i_i64[0] = v26;\n      if ( v26 )\n        *(_QWORD *)(v26 + 40) = result;\n      v21[1].m128i_i64[0] = (__int64)result;\n      result[2].m128i_i64[1] = 0LL;\n      v27 = LODWORD(result->m128i_i64[1]) == 0;\n      v28 = -a3;\n      if ( v27 == a1 )\n        v28 = a3;\n      v29 = result[5].m128i_i64[0] + v28;\n      v30 = result[3].m128i_i64[0];\n      v31 = result[5].m128i_i64[1];\n      LODWORD(result->m128i_i64[1]) = a2;\n      result[5].m128i_i64[0] = a4;\n      result[3].m128i_i64[0] = v12;\n      result[5].m128i_i64[1] = v20;\n      v20 = v19 - v31;\n      a2 = v27;\n      a4 = v29;\n      v21 = result;\n      v12 = v30;\n    }\n    while ( a5 != a8 );\n  }\n  if ( a3 <= a12 )\n  {\n    result = a9;\n    while ( v16 != a9 )\n    {\n      v16[5].m128i_i64[1] -= v19;\n      v16 = (__m128i *)v16[1].m128i_i64[1];\n    }\n    while ( a6 != a9 )\n    {\n      a6[5].m128i_i64[1] += v19;\n      a6 = (__m128i *)a6[1].m128i_i64[1];\n    }\n  }\n  else\n  {\n    if ( a8 != a9 )\n    {\n      result = (__m128i *)-a3;\n      do\n      {\n        v16[5].m128i_i64[1] -= v19;\n        v32 = a3;\n        if ( LODWORD(v16->m128i_i64[1]) == a1 )\n          v32 = -a3;\n        v16[5].m128i_i64[0] += v32;\n        v16 = (__m128i *)v16[1].m128i_i64[1];\n      }\n      while ( v16 != a9 );\n    }\n    if ( a6 != a9 )\n    {\n      result = (__m128i *)-a3;\n      do\n      {\n        v33 = _mm_loadu_si128(a6 + 5);\n        v34 = a3;\n        if ( LODWORD(a6->m128i_i64[1]) != a1 )\n          v34 = -a3;\n        _mm_storeu_si128(a6 + 5, _mm_add_epi64(_mm_unpacklo_epi64((__m128i)(unsigned __int64)v34, (__m128i)v19), v33));\n        a6 = (__m128i *)a6[1].m128i_i64[1];\n      }\n      while ( a6 != a9 );\n    }\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x402490L", 
            "funcEndAddr": "0x402698L", 
            "funcName": "sub_402490"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4026A0(signed __int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, _QWORD *a5)\n{\n  __int64 result; // rax\n  __int64 v6; // r9\n  signed __int64 v7; // rcx\n  signed __int64 v8; // rcx\n\n  result = 0LL;\n  if ( a3 != a4 )\n  {\n    v6 = a3;\n    a3 = a4;\n    do\n    {\n      while ( *(_QWORD *)(v6 + 88) < *(_QWORD *)(a3 + 88) )\n      {\n        if ( *(_DWORD *)(v6 + 8) )\n        {\n          v7 = *(_QWORD *)(v6 + 80);\n          if ( *a1 <= v7 )\n            goto LABEL_16;\n        }\n        else\n        {\n          if ( !*(_QWORD *)(*(_QWORD *)(v6 + 24) + 24LL) )\n            goto LABEL_16;\n          v7 = 1LL - *(_QWORD *)(v6 + 80);\n          if ( *a1 <= v7 )\n            goto LABEL_16;\n        }\n        *a1 = v7;\n        *a2 = 0LL;\n        result = v6;\nLABEL_16:\n        v6 = *(_QWORD *)(v6 + 24);\n        if ( v6 == a3 )\n          goto LABEL_20;\n      }\n      if ( *(_DWORD *)(a3 + 8) )\n      {\n        if ( !*(_QWORD *)(*(_QWORD *)(a3 + 24) + 24LL) )\n          goto LABEL_11;\n        v8 = 1LL - *(_QWORD *)(a3 + 80);\n        if ( *a1 < v8 )\n          goto LABEL_11;\n      }\n      else\n      {\n        v8 = *(_QWORD *)(a3 + 80);\n        if ( *a1 < v8 )\n          goto LABEL_11;\n      }\n      *a1 = v8;\n      *a2 = 1LL;\n      result = a3;\nLABEL_11:\n      a3 = *(_QWORD *)(a3 + 24);\n    }\n    while ( v6 != a3 );\n  }\nLABEL_20:\n  *a5 = a3;\n  return result;\n}\n", 
            "funcStartAddr": "0x4026a0L", 
            "funcEndAddr": "0x40275eL", 
            "funcName": "sub_4026A0"
        }, 
        {
            "decompiledFuncCode": "_BOOL8 __fastcall sub_402760(__int64 a1, __int64 a2, __int64 a3)\n{\n  _BOOL8 result; // rax\n\n  while ( a1 != a3 )\n  {\n    result = *(_DWORD *)(a1 + 8) == 0;\n    *(_QWORD *)(a1 + 80) = result;\n    a1 = *(_QWORD *)(a1 + 24);\n  }\n  while ( a2 != a3 )\n  {\n    result = *(_DWORD *)(a2 + 8) != 0;\n    *(_QWORD *)(a2 + 80) = result;\n    a2 = *(_QWORD *)(a2 + 24);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x402760L", 
            "funcEndAddr": "0x4027a7L", 
            "funcName": "sub_402760"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4027B0(_QWORD *a1)\n{\n  _QWORD *v1; // r15\n  __int64 v2; // rdi\n  __int64 v3; // rsi\n  __int64 v4; // r12\n  __int64 i; // rdx\n  __int64 v6; // r13\n  __int64 *v7; // rcx\n  __m128i **v8; // rdx\n  __int64 v9; // r14\n  __m128i *v10; // rbp\n  __int64 v11; // rax\n  __int64 v12; // rdi\n  __m128i *v13; // r9\n  __int64 v14; // r14\n  int v15; // ebx\n  __int64 v16; // rcx\n  __int64 v17; // rsi\n  __int64 v18; // rax\n  __int64 v20; // [rsp+8h] [rbp-60h]\n  __int64 v21; // [rsp+10h] [rbp-58h]\n  __m128i *v22; // [rsp+18h] [rbp-50h]\n  __int64 v23; // [rsp+20h] [rbp-48h]\n  __int64 v24; // [rsp+28h] [rbp-40h]\n  __int64 v25; // [rsp+30h] [rbp-38h]\n\n  v1 = a1;\n  v2 = a1[53];\n  v3 = v1[71];\n  v4 = v1[72];\n  v24 = v2;\n  v23 = v3;\n  for ( i = v4; ; i = v4 )\n  {\n    v6 = sub_402AD0(v2, v3, i, &v20);\n    if ( !v6 )\n      break;\n    ++v1[75];\n    v7 = (__int64 *)(v6 + 8);\n    v8 = (__m128i **)(v6 + 16);\n    if ( v20 > 0 )\n      v8 = (__m128i **)(v6 + 8);\n    if ( v20 > 0 )\n      v7 = (__int64 *)(v6 + 16);\n    v9 = *v7;\n    v10 = *v8;\n    v21 = 1LL;\n    v11 = sub_4026A0(&v21, &v25, v9, (__int64)v10, &v22);\n    if ( v11 )\n    {\n      v12 = 0LL;\n      v13 = (__m128i *)v9;\n      if ( !v25 )\n        v13 = v10;\n      if ( !v25 )\n        v10 = (__m128i *)v9;\n      v14 = *(_QWORD *)(v11 + 48);\n      v15 = (v25 == *(_DWORD *)(v11 + 8)) + 1;\n      v16 = 1 - v21;\n      if ( v20 <= 0 )\n        v16 = v21;\n      LOBYTE(v12) = v25 == 0;\n      sub_402490(\n        v12,\n        *(_QWORD *)(v6 + 8) == (_QWORD)v10,\n        v21,\n        v16,\n        v10,\n        v13,\n        (__m128i *)v11,\n        *(__m128i **)(v11 + 24),\n        v22,\n        v6,\n        v20,\n        v1[64]);\n      *(_DWORD *)(v6 + 24) = 0;\n      *(_DWORD *)(v14 + 24) = v15;\n      v17 = v1[75];\n      if ( v17 - 1 == 200\n                    * (((unsigned __int64)(((unsigned __int128)(-6640827866535438581LL * (signed __int128)(v17 - 1)) >> 64)\n                                         + v17\n                                         - 1) >> 63)\n                     + ((signed __int64)(((unsigned __int128)(-6640827866535438581LL * (signed __int128)(v17 - 1)) >> 64)\n                                       + v17\n                                       - 1) >> 7)) )\n        v1[77] += sub_400CF0((__int64)v1);\n    }\n    else\n    {\n      ++v1[76];\n      *(_DWORD *)(v6 + 24) = 2 - (*(_DWORD *)(v6 + 24) == 2);\n      if ( v21 )\n        sub_402760(v9, (__int64)v10, (__int64)v22);\n    }\n    v2 = v24;\n    v3 = v23;\n  }\n  v18 = sub_400CF0((__int64)v1);\n  v1[77] += v18;\n  sub_401120(v18, v1);\n  sub_401220(v1);\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x4027b0L", 
            "funcEndAddr": "0x4029aeL", 
            "funcName": "sub_4027B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4029D0(__int64 a1, signed __int64 a2)\n{\n  signed __int64 v2; // r15\n  __int64 v3; // r9\n  __int64 v4; // r8\n  __int64 result; // rax\n  signed __int64 v6; // r10\n  signed __int64 v7; // rax\n  __int64 v8; // rdx\n  signed __int64 v9; // rsi\n  signed __int64 v10; // rcx\n  __int64 v11; // rbx\n  _BOOL8 v12; // rax\n  _BOOL8 v13; // r12\n  signed __int64 v14; // rsi\n  signed __int64 v15; // r12\n\n  v2 = a2;\n  do\n  {\n    v3 = *(_QWORD *)(*(__int64 *)((char *)&qword_4050B0\n                                + 4 * ((a1 + v2 + ((unsigned __int64)(a1 + v2) >> 63)) & 0x3FFFFFFFFFFFFFFELL))\n                   + 16);\n    v4 = v2;\n    result = a1;\n    do\n    {\n      v6 = result - 1;\n      do\n      {\n        v7 = v6;\n        v8 = qword_4050B8[v6++];\n      }\n      while ( *(_QWORD *)(v8 + 16) > v3 );\n      v9 = v4 + 1;\n      do\n      {\n        v10 = v9;\n        v11 = qword_4050A8[v9--];\n      }\n      while ( v3 > *(_QWORD *)(v11 + 16) );\n      if ( v6 < v9 )\n      {\n        qword_4050B8[v7] = v11;\n        qword_4050A8[v10] = v8;\n      }\n      v12 = v6 <= v9;\n      v4 = v9 - v12;\n      result = v6 + v12;\n    }\n    while ( result <= v4 );\n    v13 = v6 <= v9;\n    v14 = v9 - v13;\n    v15 = v6 + v13;\n    if ( v14 > a1 )\n      result = sub_4029D0(a1);\n    if ( v15 >= v2 )\n      break;\n    a1 = v15;\n  }\n  while ( v15 < 51 );\n  return result;\n}\n", 
            "funcStartAddr": "0x4029d0L", 
            "funcEndAddr": "0x402ac8L", 
            "funcName": "sub_4029D0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_402AD0(__int64 a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)\n{\n  _QWORD *v4; // r14\n  unsigned __int64 v5; // r11\n  __int64 v6; // rdx\n  signed __int64 v7; // r15\n  __m128i v8; // xmm5\n  signed __int64 v9; // rax\n  __m128i v10; // xmm1\n  __m128i v11; // xmm2\n  __m128i v12; // xmm8\n  __m128i v13; // xmm9\n  __m128i v14; // xmm10\n  __m128i v15; // xmm11\n  __m128i v16; // xmm7\n  __m128i v17; // xmm3\n  __m128i v18; // xmm4\n  signed __int64 v19; // rdi\n  unsigned __int64 v20; // rax\n  signed __int64 v21; // rdx\n  signed __int64 v22; // r9\n  __int64 v23; // r10\n  unsigned __int64 v24; // rdi\n  __int64 v25; // rcx\n  __int64 v26; // rbx\n  _QWORD *v27; // rbp\n  __int64 v28; // rcx\n  bool v29; // sf\n  unsigned __int8 v30; // of\n  __int64 v31; // r12\n  unsigned __int64 i; // rbx\n  int v33; // ebp\n  __int64 v34; // rdi\n  unsigned __int64 *v35; // rax\n  __int64 v36; // rcx\n  __int64 *v37; // rax\n  __int64 result; // rax\n\n  v4 = a4;\n  v5 = a3;\n  if ( LOBYTE(xmmword_405BA8[0]) )\n  {\n    v6 = qword_407CA8;\n    if ( qword_407CA8 < 2 )\n    {\n      v7 = 0LL;\nLABEL_19:\n      qword_407CA8 = v7;\n      v23 = qword_407CA0;\n      v22 = qword_407C98;\n      goto LABEL_20;\n    }\n    v24 = 2LL;\n    v7 = 0LL;\n    while ( 1 )\n    {\n      v25 = *(_QWORD *)qword_4050B0[v24];\n      v26 = **(_QWORD **)(v25 + 16) + *(_QWORD *)v25 - **(_QWORD **)(v25 + 8);\n      if ( v26 < 0 )\n      {\n        if ( *(_DWORD *)(v25 + 24) == 1 )\n          goto LABEL_11;\n      }\n      else if ( v26 && *(_DWORD *)(v25 + 24) == 2 )\n      {\nLABEL_11:\n        v27 = (_QWORD *)qword_4050B8[v7];\n        *v27 = v25;\n        ++v7;\n        v27[1] = v26;\n        v28 = -v26;\n        if ( -v26 < 1 )\n          v28 = v26;\n        v27[2] = v28;\n        goto LABEL_14;\n      }\nLABEL_14:\n      if ( v24 <= 0x31 )\n      {\n        v30 = __OFSUB__(v24, v6);\n        v29 = (signed __int64)(v24++ - v6) < 0;\n        if ( v29 ^ v30 )\n          continue;\n      }\n      goto LABEL_19;\n    }\n  }\n  v8 = _mm_load_si128((const __m128i *)&xmmword_403160);\n  v9 = 1152921504606846802LL;\n  v10 = _mm_load_si128((const __m128i *)&xmmword_403170);\n  v11 = _mm_shuffle_epi32((__m128i)((unsigned __int64)xmmword_405BA8 + 8), 68);\n  v12 = _mm_load_si128((const __m128i *)&xmmword_403180);\n  v13 = _mm_load_si128((const __m128i *)&xmmword_403190);\n  v14 = _mm_load_si128((const __m128i *)&xmmword_4031A0);\n  v15 = _mm_load_si128((const __m128i *)&xmmword_4031B0);\n  v16 = _mm_load_si128((const __m128i *)&xmmword_4031C0);\n  v17 = _mm_load_si128((const __m128i *)&xmmword_4031D0);\n  do\n  {\n    v18 = _mm_add_epi64(\n            _mm_slli_epi64(_mm_mul_epu32(_mm_srli_epi64(v8, 0x20u), v10), 0x20u),\n            _mm_add_epi64(_mm_mul_epu32(v8, v10), v11));\n    _mm_storeu_si128((__m128i *)&xmmword_405B98[v9], v18);\n    _mm_storeu_si128((__m128i *)&xmmword_405BA8[v9], _mm_add_epi64(v18, v12));\n    _mm_storeu_si128((__m128i *)&xmmword_405BB8[v9], _mm_add_epi64(v18, v13));\n    _mm_storeu_si128((__m128i *)&xmmword_405BC8[v9], _mm_add_epi64(v18, v14));\n    _mm_storeu_si128((__m128i *)&xmmword_405BD8[v9], _mm_add_epi64(v18, v15));\n    _mm_storeu_si128((__m128i *)&xmmword_405BE8[v9], _mm_add_epi64(v18, v16));\n    v8 = _mm_add_epi64(v8, v17);\n    v9 += 6LL;\n  }\n  while ( v9 * 16 );\n  *(_QWORD *)&xmmword_405B98[0] = &unk_407C68;\n  v19 = a1 - 1;\n  v20 = (unsigned __int64)((unsigned __int128)(7870610804782742023LL * (signed __int128)v19) >> 64) >> 63;\n  v21 = (signed __int64)((unsigned __int128)(7870610804782742023LL * (signed __int128)v19) >> 64) >> 7;\n  v22 = v21 + v20 + 1;\n  qword_407C98 = v21 + v20 + 1;\n  *((_QWORD *)&xmmword_405B98[0] + 1) = &unk_407C80;\n  LOBYTE(xmmword_405BA8[0]) = 1;\n  qword_407CA0 = 0LL;\n  qword_407CA8 = 0LL;\n  v7 = 0LL;\n  v23 = 0LL;\nLABEL_20:\n  v31 = v23;\n  do\n  {\n    for ( i = a2 + (v31 << 6); i < v5; i += v22 << 6 )\n    {\n      v33 = *(_DWORD *)(i + 24);\n      if ( v33 > 0 )\n      {\n        v34 = **(_QWORD **)(i + 16) + *(_QWORD *)i - **(_QWORD **)(i + 8);\n        if ( v34 < 0 )\n        {\n          if ( v33 == 1 )\n            goto LABEL_30;\n        }\n        else if ( v34 && v33 == 2 )\n        {\nLABEL_30:\n          v35 = (unsigned __int64 *)qword_4050B8[v7++];\n          qword_407CA8 = v7;\n          *v35 = i;\n          v35[1] = v34;\n          v36 = -v34;\n          if ( -v34 < 1 )\n            v36 = v34;\n          v35[2] = v36;\n          continue;\n        }\n      }\n    }\n    if ( ++v31 == v22 )\n      v31 = 0LL;\n  }\n  while ( v7 <= 49 && v31 != v23 );\n  qword_407CA0 = v31;\n  if ( v7 )\n  {\n    sub_4029D0(1LL, v7);\n    v37 = (__int64 *)qword_4050B8[0];\n    *v4 = *(_QWORD *)(qword_4050B8[0] + 8);\n    result = *v37;\n  }\n  else\n  {\n    LOBYTE(xmmword_405BA8[0]) = 0;\n    *v4 = 0LL;\n    result = 0LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x402ad0L", 
            "funcEndAddr": "0x402dcfL", 
            "funcName": "sub_402AD0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r15\n  signed __int64 v4; // rbp\n  __int64 v5; // rbx\n\n  v3 = a3;\n  v4 = ((char *)&stru_404DF8 - (char *)&off_404DF0) >> 3;\n  init_proc();\n  if ( v4 )\n  {\n    v5 = 0LL;\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&off_404DF0 + v5++))(a1, a2, v3);\n    while ( v4 != v5 );\n  }\n}\n", 
            "funcStartAddr": "0x402dd0L", 
            "funcEndAddr": "0x402e35L", 
            "funcName": "init"
        }, 
        {
            "decompiledFuncCode": "void fini(void)\n{\n  ;\n}\n", 
            "funcStartAddr": "0x402e40L", 
            "funcEndAddr": "0x402e42L", 
            "funcName": "fini"
        }
    ], 
    "failedCount": 0, 
    "binaryInfo": {
        "binaryName": "mcf-amd64-clang-O2_strip", 
        "isStripped": "True"
    }, 
    "funcCount": "26", 
    "buildInfo": {
        "decompilerName": "IDA Pro", 
        "compilerVersion": "9.4.0", 
        "Optlevel": "-O", 
        "compilerName": "gcc"
    }, 
    "recognizedCount": 0
}