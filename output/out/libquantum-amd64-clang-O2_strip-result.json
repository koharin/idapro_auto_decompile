{
    "decompileResult": [
        {
            "decompiledFuncCode": "void *sub_400B20()\n{\n  void *result; // rax\n\n  result = &unk_40C0D0;\n  if ( &unk_40C0D0 != &unk_40C0D0 )\n    result = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x400b20L", 
            "funcEndAddr": "0x400b41L", 
            "funcName": "sub_400B20"
        }, 
        {
            "decompiledFuncCode": "void *sub_400B90()\n{\n  void *result; // rax\n\n  if ( !byte_40C0E0 )\n  {\n    result = sub_400B20();\n    byte_40C0E0 = 1;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x400b90L", 
            "funcEndAddr": "0x400bb1L", 
            "funcName": "sub_400B90"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_400BC0()\n{\n  return 0LL;\n}\n\n__int64 sub_400BC0()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x400b50L", 
            "funcEndAddr": "0x400b81L", 
            "funcName": "sub_400BC0"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_400BC0()\n{\n  return 0LL;\n}\n\n__int64 sub_400BC0()\n{\n  return 0LL;\n}\n", 
            "funcStartAddr": "0x400b50L", 
            "funcEndAddr": "0x400b81L", 
            "funcName": "sub_400BC0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_400BD0(unsigned int a1, unsigned int a2)\n{\n  unsigned int v2; // er8\n  signed __int64 result; // rax\n  __m128i v4; // xmm0\n  unsigned int v5; // ecx\n  int v6; // eax\n  __m128i v7; // xmm2\n  __m128i v8; // xmm3\n  int v9; // edx\n  __m128i v10; // xmm1\n  __m128i v11; // xmm2\n  __m128i v12; // xmm3\n  int v13; // eax\n  __m128i v14; // xmm1\n  __m128i v15; // xmm1\n  __m128i v16; // xmm0\n  __m128i v17; // xmm1\n  int v18; // esi\n\n  if ( (signed int)a2 <= 0 )\n    return 1LL;\n  if ( a2 >= 8 )\n  {\n    v2 = a2 & 0xFFFFFFF8;\n    v4 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a1), 0);\n    v5 = ((a2 & 0xFFFFFFF8) - 8) >> 3;\n    v6 = ((_BYTE)v5 + 1) & 7;\n    if ( (a2 & 0xFFFFFFF8) - 8 >= 0x38 )\n    {\n      v9 = v6 - 1 - v5;\n      v7 = _mm_load_si128((const __m128i *)&xmmword_408840);\n      v10 = _mm_shuffle_epi32(v4, 245);\n      v8 = v7;\n      do\n      {\n        v11 = _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v7, v4), 232),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v7, 245), v10), 232));\n        v12 = _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v8, v4), 232),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v8, 245), v10), 232));\n        v7 = v11;\n        v8 = v12;\n        v9 += 8;\n      }\n      while ( v9 );\n      if ( !(((_BYTE)v5 + 1) & 7) )\n      {\nLABEL_13:\n        v15 = _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v8, v7), 232),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v7, 245), _mm_shuffle_epi32(v8, 245)), 232));\n        v16 = _mm_shuffle_epi32(v15, 78);\n        v17 = _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v15, v16), 232),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v16, 245), _mm_shuffle_epi32(v15, 245)), 232));\n        result = (unsigned int)_mm_cvtsi128_si32(_mm_mul_epu32(_mm_shuffle_epi32(v17, 229), v17));\n        if ( v2 == a2 )\n          return result;\n        goto LABEL_14;\n      }\n    }\n    else\n    {\n      v7 = _mm_load_si128((const __m128i *)&xmmword_408840);\n      v8 = v7;\n      if ( !(((_BYTE)v5 + 1) & 7) )\n        goto LABEL_13;\n    }\n    v13 = -v6;\n    v14 = _mm_shuffle_epi32(v4, 245);\n    do\n    {\n      v7 = _mm_unpacklo_epi32(\n             _mm_shuffle_epi32(_mm_mul_epu32(v7, v4), 232),\n             _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v7, 245), v14), 232));\n      v8 = _mm_unpacklo_epi32(\n             _mm_shuffle_epi32(_mm_mul_epu32(v8, v4), 232),\n             _mm_shuffle_epi32(_mm_mul_epu32(_mm_shuffle_epi32(v8, 245), v14), 232));\n      ++v13;\n    }\n    while ( v13 );\n    goto LABEL_13;\n  }\n  v2 = 0;\n  LODWORD(result) = 1;\nLABEL_14:\n  v18 = a2 - v2;\n  do\n  {\n    result = a1 * (unsigned int)result;\n    --v18;\n  }\n  while ( v18 );\n  return result;\n}\n", 
            "funcStartAddr": "0x400bd0L", 
            "funcEndAddr": "0x400eb9L", 
            "funcName": "sub_400BD0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_400EC0(unsigned int a1, int a2)\n{\n  int v2; // edx\n  __int64 result; // rax\n  unsigned int v4; // ecx\n\n  v2 = a2;\n  result = a1;\n  if ( a2 )\n  {\n    do\n    {\n      v4 = v2;\n      v2 = (signed int)result % v2;\n      LODWORD(result) = v4;\n    }\n    while ( v2 );\n    result = v4;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x400ec0L", 
            "funcEndAddr": "0x400edfL", 
            "funcName": "sub_400EC0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_400EE0(signed int *a1, signed int *a2, char a3)\n{\n  signed int v3; // er11\n  signed int v4; // er8\n  double v5; // xmm1_8\n  int v6; // er10\n  float v7; // xmm6_4\n  signed __int64 result; // rax\n  int v9; // er9\n  signed int v10; // ebx\n  int v11; // ecx\n  double v12; // xmm6_8\n  signed int v13; // edx\n  float v14; // xmm7_4\n  signed int v15; // edx\n\n  v3 = 1;\n  v4 = 1 << a3;\n  v5 = 1.0 / (double)(2 * (1 << a3));\n  v6 = 0;\n  v7 = (float)*a1 / (float)*a2;\n  result = 1LL;\n  v9 = 0;\n  v10 = 0;\n  v11 = 0;\n  while ( 1 )\n  {\n    v12 = v7;\n    v13 = (signed int)(v12 + 0.000005);\n    v11 = v3 + v13 * v11;\n    if ( v11 > v4 )\n      break;\n    v14 = v12 - ((double)v13 + -0.000005);\n    v15 = v6 + result * v13;\n    v7 = 1.0 / v14;\n    v6 = result;\n    v3 = v9;\n    result = (unsigned int)v15;\n    v9 = v11;\n    v10 = v15;\n    if ( COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)v15 / (float)v11) - (float)((float)*a1 / (float)*a2)) & xmmword_408850) <= v5 )\n      goto LABEL_6;\n  }\n  v15 = v10;\n  v11 = v9;\nLABEL_6:\n  *a1 = v15;\n  *a2 = v11;\n  return result;\n}\n", 
            "funcStartAddr": "0x400ee0L", 
            "funcEndAddr": "0x400fd0L", 
            "funcName": "sub_400EE0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_400FD0(signed int a1)\n{\n  unsigned int v1; // ecx\n\n  v1 = 0;\n  do\n    ++v1;\n  while ( 1 << v1 < a1 );\n  return v1;\n}\n", 
            "funcStartAddr": "0x400fd0L", 
            "funcEndAddr": "0x400ff1L", 
            "funcName": "sub_400FD0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401000(int a1, int a2)\n{\n  unsigned int v2; // er8\n  int v3; // ecx\n  int v4; // edx\n\n  v2 = 0;\n  v3 = a2;\n  do\n  {\n    v4 = v3 % a1;\n    ++v2;\n    v3 += a2;\n  }\n  while ( v4 != 1 );\n  return v2;\n}\n", 
            "funcStartAddr": "0x401000L", 
            "funcEndAddr": "0x401024L", 
            "funcName": "sub_401000"
        }, 
        {
            "decompiledFuncCode": "__m128 __fastcall sub_401030(__m128 a1)\n{\n  __m128 v1; // xmm2\n  __m128 v2; // xmm1\n\n  v1 = _mm_shuffle_ps(a1, a1, 229);\n  v2 = v1;\n  v2.m128_f32[0] = (float)(v1.m128_f32[0] * -0.0) + a1.m128_f32[0];\n  return _mm_unpacklo_ps(v2, _mm_xor_ps(_mm_shuffle_ps((__m128)0x80000000, (__m128)0x80000000, 0), v1));\n}\n", 
            "funcStartAddr": "0x401030L", 
            "funcEndAddr": "0x401058L", 
            "funcName": "sub_401030"
        }, 
        {
            "decompiledFuncCode": "__m128 __fastcall sub_401080(float a1)\n{\n  double x; // ST08_8\n  double v2; // ST10_8\n  __m128 v3; // xmm0\n  __m128 v4; // xmm1\n\n  x = a1;\n  v2 = cos(a1);\n  v3 = (__m128)*(unsigned __int64 *)&x;\n  *(double *)v3.m128_u64 = sin(x);\n  v4 = 0LL;\n  *(double *)v4.m128_u64 = 0.0 * *(double *)v3.m128_u64 + v2;\n  v4.m128_f32[0] = *(double *)v4.m128_u64;\n  v3.m128_f32[0] = *(double *)v3.m128_u64;\n  return _mm_unpacklo_ps(v4, v3);\n}\n", 
            "funcStartAddr": "0x401080L", 
            "funcEndAddr": "0x4010c5L", 
            "funcName": "sub_401080"
        }, 
        {
            "decompiledFuncCode": "float sub_4010D0()\n{\n  return *(float *)&dword_40C0E8;\n}\n", 
            "funcStartAddr": "0x4010d0L", 
            "funcEndAddr": "0x4010d9L", 
            "funcName": "sub_4010D0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_4010E0(float a1)\n{\n  if ( a1 == 0.0 )\n  {\n    dword_40C0E4 = 0;\n  }\n  else\n  {\n    dword_40C0E4 = 1;\n    dword_40C0E8 = LODWORD(a1);\n  }\n}\n", 
            "funcStartAddr": "0x4010e0L", 
            "funcEndAddr": "0x401108L", 
            "funcName": "sub_4010E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401110(signed int *a1, __m128 a2)\n{\n  __int64 result; // rax\n  size_t v3; // r15\n  signed __int64 v4; // rsi\n  _DWORD *v5; // r12\n  __int64 v6; // rdx\n  __int64 v7; // rbx\n  __m128d v8; // xmm1\n  __m128 v9; // xmm2\n  float v10; // xmm1_4\n  double v11; // xmm0_8\n  double v12; // xmm0_8\n  float v13; // xmm1_4\n  double v14; // xmm0_8\n  double v15; // xmm0_8\n  double v16; // xmm1_8\n  __int64 v17; // r15\n  __int64 v18; // rax\n  __int64 v19; // rcx\n  float v20; // xmm0_4\n  unsigned __int64 v21; // rdx\n  float v22; // xmm2_4\n  float v23; // xmm1_4\n  float v24; // xmm0_4\n  float v25; // xmm1_4\n  __m128 v26; // xmm2\n  float *v27; // r13\n  float v28; // xmm1_4\n  float v29; // xmm6_4\n  float v30; // xmm5_4\n  double v31; // [rsp+0h] [rbp-48h]\n\n  result = sub_4040F0(1LL);\n  if ( dword_40C0E4 )\n  {\n    v3 = *a1;\n    v4 = 4LL;\n    v5 = calloc(v3, 4uLL);\n    if ( !v5 )\n    {\n      printf(\"Not enough memory for %i-sized array of float!\\n\", (unsigned int)v3);\n      exit(1);\n    }\n    sub_404120(4 * v3, 4LL);\n    LODWORD(v6) = *a1;\n    if ( *a1 > 0 )\n    {\n      v7 = 0LL;\n      do\n      {\n        do\n        {\n          sub_4042D0();\n          sub_4042D0();\n          v8 = _mm_unpckl_pd((__m128d)a2, (__m128d)a2);\n          a2 = _mm_cvtpd_ps(_mm_add_pd(_mm_add_pd(v8, v8), (__m128d)xmmword_408860));\n          v9 = _mm_mul_ps(a2, a2);\n          v10 = COERCE_FLOAT(_mm_shuffle_ps(v9, v9, 229)) + v9.m128_f32[0];\n        }\n        while ( v10 >= 1.0 );\n        v31 = a2.m128_f32[0];\n        v11 = log(v10) * -2.0 / v10;\n        if ( v11 < 0.0 )\n          v12 = sqrt(v11);\n        else\n          v12 = sqrt(v11);\n        v13 = v12 * v31;\n        v14 = (float)(*(float *)&dword_40C0E8 + *(float *)&dword_40C0E8);\n        if ( v14 < 0.0 )\n          v15 = sqrt(v14);\n        else\n          v15 = sqrt(v14);\n        v16 = v13 * v15;\n        a2 = 0LL;\n        a2.m128_f32[0] = v16;\n        a2.m128_f32[0] = a2.m128_f32[0] * 0.5;\n        v5[v7++] = a2.m128_i32[0];\n        v6 = *a1;\n      }\n      while ( v7 < v6 );\n    }\n    if ( a1[1] > 0 )\n    {\n      v17 = 0LL;\n      while ( 1 )\n      {\n        if ( (signed int)v6 <= 0 )\n        {\n          v20 = 0.0;\n          goto LABEL_31;\n        }\n        v18 = *(_QWORD *)(*((_QWORD *)a1 + 2) + 16 * v17 + 8);\n        v19 = v6 & 1;\n        if ( (_DWORD)v6 == 1 )\n          break;\n        v4 = (signed int)v6 - v19;\n        v20 = 0.0;\n        v21 = 0LL;\n        do\n        {\n          v22 = *(float *)&v5[v21];\n          v23 = *(float *)&v5[v21 + 1];\n          if ( !_bittest64(&v18, v21) )\n            LODWORD(v22) ^= xmmword_408870;\n          v24 = v20 + v22;\n          if ( !_bittest64(&v18, (unsigned int)(v21 + 1)) )\n            LODWORD(v23) ^= xmmword_408870;\n          v20 = v24 + v23;\n          v21 += 2LL;\n        }\n        while ( v4 != v21 );\n        if ( v19 )\n          goto LABEL_28;\nLABEL_31:\n        v26 = sub_401080(v20);\n        v27 = (float *)(*((_QWORD *)a1 + 2) + 16 * v17);\n        v28 = v27[1];\n        LODWORD(v29) = (unsigned __int128)_mm_shuffle_ps(v26, v26, 229);\n        v30 = (float)(v26.m128_f32[0] * v28) + (float)(v29 * *v27);\n        *v27 = (float)(v26.m128_f32[0] * *v27) - (float)(v29 * v28);\n        v27[1] = v30;\n        if ( ++v17 >= a1[1] )\n          goto LABEL_32;\n        LODWORD(v6) = *a1;\n      }\n      v20 = 0.0;\n      v21 = 0LL;\n      if ( !v19 )\n        goto LABEL_31;\nLABEL_28:\n      v25 = *(float *)&v5[v21];\n      if ( !_bittest64(&v18, v21) )\n        LODWORD(v25) ^= xmmword_408870;\n      v20 = v20 + v25;\n      goto LABEL_31;\n    }\nLABEL_32:\n    free(v5);\n    result = sub_404120(-4LL * *a1, v4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401110L", 
            "funcEndAddr": "0x4013f0L", 
            "funcName": "sub_401110"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4013F0(signed int a1, int a2, int a3, __int64 a4, __int64 a5)\n{\n  int v5; // ebx\n  __int64 result; // rax\n  int v7; // ebx\n  unsigned int v8; // er15\n  int v9; // er14\n  int v10; // er12\n  unsigned int v11; // edx\n  int v12; // ecx\n  int v13; // esi\n  int v14; // edx\n  int v15; // kr00_4\n  int v16; // ecx\n  int v18; // [rsp+Ch] [rbp-4Ch]\n  __int64 v19; // [rsp+10h] [rbp-48h]\n  __int64 v20; // [rsp+20h] [rbp-38h]\n\n  v5 = a3;\n  v19 = a4;\n  v20 = a5;\n  result = sub_401910((unsigned int)(2 * a4 + 2), a5);\n  v18 = v5;\n  if ( v5 > 0 )\n  {\n    v7 = a2 % a1;\n    v8 = 1;\n    v9 = 0;\n    v10 = 0;\n    do\n    {\n      v11 = v7;\n      if ( v8 >= 2 )\n      {\n        v12 = v10 & 3;\n        v11 = v7;\n        if ( (unsigned int)(v10 - 1) >= 3 )\n        {\n          v13 = v9 + v12;\n          v11 = v7;\n          do\n          {\n            v15 = (signed int)(v11 * v11) % a1 * ((signed int)(v11 * v11) % a1);\n            v14 = v15 >> 31;\n            v11 = (signed int)(__PAIR__(v14, v15) % a1 * (__PAIR__(v14, v15) % a1)) % a1;\n            v13 += 4;\n          }\n          while ( v13 );\n        }\n        if ( v10 & 3 )\n        {\n          v16 = -v12;\n          do\n          {\n            v11 = (signed int)(v11 * v11) % a1;\n            ++v16;\n          }\n          while ( v16 );\n        }\n      }\n      result = sub_406310((unsigned int)a1, v11, v8 + 3 * (_DWORD)v19 + 1, v19, v20);\n      ++v10;\n      --v9;\n    }\n    while ( v8++ != v18 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4013f0L", 
            "funcEndAddr": "0x4014f7L", 
            "funcName": "sub_4013F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401500(unsigned int a1, unsigned int a2, __int64 a3, __m128 a4)\n{\n  __int64 v4; // r14\n  char v5; // bp\n  __int64 result; // rax\n  __int64 v7; // rsi\n  signed __int64 v8; // rdx\n  signed __int64 v9; // rax\n  __int64 v10; // r8\n  __int64 v11; // rbp\n  __int64 v12; // rdi\n  __int64 v13; // rsi\n  _QWORD *v14; // rbx\n  __int64 v15; // rcx\n  signed __int64 v16; // rdi\n  __int64 v17; // rsi\n  int v18; // [rsp+Ch] [rbp-1Ch]\n\n  v4 = a3;\n  v5 = a2;\n  sub_406360(&v18, 0LL);\n  if ( v18 )\n    return sub_406720(a1, a2, v4);\n  result = sub_4053B0(1);\n  if ( !(_DWORD)result )\n  {\n    v7 = *(signed int *)(v4 + 4);\n    if ( v7 > 0 )\n    {\n      v8 = 1LL << a1;\n      v9 = 1LL << v5;\n      v10 = *(_QWORD *)(v4 + 16);\n      v11 = v7 & 1;\n      if ( (_DWORD)v7 == 1 )\n      {\n        v12 = 0LL;\n        if ( !(v7 & 1) )\n          goto LABEL_17;\n      }\n      else\n      {\n        v13 = v7 - v11;\n        v14 = (_QWORD *)(v10 + 24);\n        v12 = 0LL;\n        do\n        {\n          v15 = *(v14 - 2);\n          if ( v8 & v15 )\n            *(v14 - 2) = v9 ^ v15;\n          if ( v8 & *v14 )\n            *v14 ^= v9;\n          v12 += 2LL;\n          v14 += 4;\n        }\n        while ( v13 != v12 );\n        if ( !v11 )\n          goto LABEL_17;\n      }\n      v16 = 16 * v12;\n      v17 = *(_QWORD *)(v10 + v16 + 8);\n      if ( v8 & v17 )\n        *(_QWORD *)(v10 + v16 + 8) = v9 ^ v17;\n    }\nLABEL_17:\n    result = sub_401110((signed int *)v4, a4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401500L", 
            "funcEndAddr": "0x4015edL", 
            "funcName": "sub_401500"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_4015F0@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, __int64 a3@<rcx>, unsigned int a4@<edi>, unsigned int a5@<esi>, __m128 a6@<xmm0>)\n{\n  __int64 v6; // r14\n  unsigned int v7; // er15\n  char v8; // bl\n  __int64 result; // rax\n  __int64 v10; // rsi\n  signed __int64 v11; // rax\n  __int64 v12; // r8\n  signed __int64 v13; // rdx\n  __int64 v14; // r9\n  __int64 v15; // rdi\n  __int64 v16; // rsi\n  _QWORD *v17; // rbx\n  signed __int64 v18; // rdi\n  __int64 v19; // [rsp-4h] [rbp-28h]\n\n  v19 = a1;\n  v6 = a3;\n  v7 = a2;\n  v8 = a5;\n  sub_406360((char *)&v19 + 4, 0LL);\n  if ( HIDWORD(v19) )\n    return sub_4067F0(a4, a5, v7, v6);\n  result = sub_4053B0(2);\n  if ( !(_DWORD)result )\n  {\n    v10 = *(signed int *)(v6 + 4);\n    if ( v10 > 0 )\n    {\n      v11 = 1LL << v7;\n      v12 = *(_QWORD *)(v6 + 16);\n      v13 = (1LL << a4) | (1LL << v8);\n      v14 = v10 & 1;\n      if ( (_DWORD)v10 == 1 )\n      {\n        v15 = 0LL;\n        if ( !(v10 & 1) )\n          goto LABEL_17;\n      }\n      else\n      {\n        v16 = v10 - v14;\n        v17 = (_QWORD *)(v12 + 24);\n        v15 = 0LL;\n        do\n        {\n          if ( (v13 & *(v17 - 2)) == v13 )\n            *(v17 - 2) ^= v11;\n          if ( (v13 & *v17) == v13 )\n            *v17 ^= v11;\n          v15 += 2LL;\n          v17 += 4;\n        }\n        while ( v16 != v15 );\n        if ( !v14 )\n          goto LABEL_17;\n      }\n      v18 = 16 * v15;\n      if ( (v13 & *(_QWORD *)(v12 + v18 + 8)) == v13 )\n        *(_QWORD *)(v12 + v18 + 8) ^= v11;\n    }\nLABEL_17:\n    result = sub_401110((signed int *)v6, a6);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4015f0L", 
            "funcEndAddr": "0x401711L", 
            "funcName": "sub_4015F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401720(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14, char a15)\n{\n  __int64 v15; // r14\n  int v16; // er12\n  _DWORD *v17; // rbx\n  signed __int64 v18; // rsi\n  bool v19; // al\n  __int64 v20; // rcx\n  _DWORD *v21; // rdx\n  char *v22; // rax\n  char *v23; // rcx\n  __int64 v24; // rax\n  signed __int64 v25; // r8\n  __int64 v26; // rcx\n  __int64 v27; // rdi\n  char *v29; // [rsp+8h] [rbp-F0h]\n  char v30[16]; // [rsp+20h] [rbp-D8h]\n  __int64 v31; // [rsp+30h] [rbp-C8h]\n  __int64 v32; // [rsp+38h] [rbp-C0h]\n  __int64 v33; // [rsp+40h] [rbp-B8h]\n  __int64 v34; // [rsp+48h] [rbp-B0h]\n  __m128 v35; // [rsp+50h] [rbp-A8h]\n  __m128 v36; // [rsp+60h] [rbp-98h]\n  __m128 v37; // [rsp+70h] [rbp-88h]\n  __m128 v38; // [rsp+80h] [rbp-78h]\n  __m128 v39; // [rsp+90h] [rbp-68h]\n  __m128 v40; // [rsp+A0h] [rbp-58h]\n  __m128 v41; // [rsp+B0h] [rbp-48h]\n  __m128 v42; // [rsp+C0h] [rbp-38h]\n\n  v31 = a3;\n  v32 = a4;\n  v33 = a5;\n  v34 = a6;\n  v35 = a7;\n  v36 = a8;\n  v37 = a9;\n  v38 = a10;\n  v39 = a11;\n  v40 = a12;\n  v41 = a13;\n  v42 = a14;\n  v15 = a2;\n  v16 = a1;\n  v17 = malloc(4LL * (signed int)a1);\n  if ( !v17 )\n  {\n    printf(\"Error allocating %i-element int array!\\n\", a1);\n    exit(1);\n  }\n  sub_404120(4LL * (signed int)a1, a2);\n  v29 = &a15;\n  v18 = 16LL;\n  v19 = 1;\n  if ( (signed int)a1 > 0 )\n  {\n    v20 = a1;\n    v21 = v17;\n    do\n    {\n      if ( v19 )\n      {\n        v22 = &v30[(signed int)v18];\n        v18 = (unsigned int)(v18 + 8);\n      }\n      else\n      {\n        v22 = v29;\n        v29 += 8;\n      }\n      *v21 = *(_DWORD *)v22;\n      v19 = (unsigned int)v18 < 0x29;\n      ++v21;\n      --v20;\n    }\n    while ( v20 );\n  }\n  if ( v19 )\n    v23 = &v30[(signed int)v18];\n  else\n    v23 = v29;\n  v24 = *(signed int *)(v15 + 4);\n  if ( v24 > 0 )\n  {\n    v25 = 1LL << *(_DWORD *)v23;\n    v26 = 0LL;\n    do\n    {\n      v18 = 0LL;\n      if ( v16 > 0 )\n      {\n        v18 = 0LL;\n        do\n        {\n          v27 = *(_QWORD *)(*(_QWORD *)(v15 + 16) + 16 * v26 + 8);\n          if ( !_bittest64(&v27, LOBYTE(v17[v18])) )\n            break;\n          ++v18;\n        }\n        while ( v18 < v16 );\n      }\n      if ( (_DWORD)v18 == v16 )\n      {\n        v18 = 16 * v26;\n        *(_QWORD *)(*(_QWORD *)(v15 + 16) + v18 + 8) ^= v25;\n      }\n      ++v26;\n    }\n    while ( v26 < v24 );\n  }\n  free(v17);\n  sub_404120(4LL * -v16, v18);\n  return sub_401110((signed int *)v15, a7);\n}\n", 
            "funcStartAddr": "0x401720L", 
            "funcEndAddr": "0x401909L", 
            "funcName": "sub_401720"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_401910@<rax>(__int64 a1@<rax>, unsigned int a2@<edi>, __int64 a3@<rsi>, __m128 a4@<xmm0>)\n{\n  __int64 v4; // rbx\n  __int64 result; // rax\n  __int64 v6; // rsi\n  signed __int64 v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // rdi\n  __int64 v11; // rsi\n  _QWORD *v12; // rbp\n  _QWORD *v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // [rsp-4h] [rbp-18h]\n\n  v15 = a1;\n  v4 = a3;\n  sub_406360((char *)&v15 + 4, 0LL);\n  if ( HIDWORD(v15) )\n    return sub_406660(a2, a3);\n  result = sub_4053B0(3);\n  if ( !(_DWORD)result )\n  {\n    v6 = *(signed int *)(a3 + 4);\n    if ( v6 > 0 )\n    {\n      v7 = 1LL << a2;\n      v8 = *(_QWORD *)(v4 + 16);\n      v9 = v6 & 3;\n      if ( (unsigned __int64)(v6 - 1) >= 3 )\n      {\n        v11 = v6 - v9;\n        v12 = (_QWORD *)(v8 + 56);\n        v10 = 0LL;\n        do\n        {\n          *(v12 - 6) ^= v7;\n          *(v12 - 4) ^= v7;\n          *(v12 - 2) ^= v7;\n          *v12 ^= v7;\n          v10 += 4LL;\n          v12 += 8;\n        }\n        while ( v11 != v10 );\n        if ( !v9 )\n          goto LABEL_13;\n      }\n      else\n      {\n        v10 = 0LL;\n        if ( !(v6 & 3) )\n          goto LABEL_13;\n      }\n      v13 = (_QWORD *)(16 * v10 + v8 + 8);\n      v14 = -v9;\n      do\n      {\n        *v13 ^= v7;\n        v13 += 2;\n        ++v14;\n      }\n      while ( v14 );\n    }\nLABEL_13:\n    result = sub_401110((signed int *)v4, a4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401910L", 
            "funcEndAddr": "0x4019dcL", 
            "funcName": "sub_401910"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4019E0(char a1, __int64 a2, __m128 a3)\n{\n  __int64 result; // rax\n  signed __int64 v4; // r12\n  signed __int64 v5; // r14\n  signed __int64 v6; // rbp\n  __int64 v7; // rbx\n  signed __int64 v8; // rax\n  float v9; // xmm7_4\n  float v10; // xmm1_4\n  float v11; // xmm6_4\n  float v12; // xmm6_4\n  __m128 v13; // xmm4\n\n  result = sub_4053B0(4);\n  if ( !(_DWORD)result )\n  {\n    if ( *(_DWORD *)(a2 + 4) > 0 )\n    {\n      v4 = 1LL << a1;\n      v5 = 0LL;\n      v6 = 8LL;\n      do\n      {\n        v7 = *(_QWORD *)(a2 + 16);\n        v8 = v4 ^ *(_QWORD *)(v7 + v6);\n        *(_QWORD *)(v7 + v6) = v8;\n        v9 = *(float *)(v7 + v6 - 8);\n        v10 = *(float *)(v7 + v6 - 4);\n        a3 = (__m128)*(unsigned int *)(v7 + v6 - 8);\n        a3.m128_f32[0] = a3.m128_f32[0] * 0.0;\n        v11 = *(float *)(v7 + v6 - 4);\n        if ( v4 & v8 )\n        {\n          a3.m128_f32[0] = a3.m128_f32[0] - v10;\n          v12 = (float)(v11 * 0.0) + v9;\n        }\n        else\n        {\n          v13 = (__m128)*(unsigned int *)(v7 + v6 - 4);\n          v13.m128_f32[0] = v10 - a3.m128_f32[0];\n          v12 = (float)(v11 * -0.0) - v9;\n          a3 = v13;\n        }\n        *(_DWORD *)(v7 + v6 - 8) = a3.m128_i32[0];\n        *(float *)(v7 + v6 - 4) = v12;\n        ++v5;\n        v6 += 16LL;\n      }\n      while ( v5 < *(signed int *)(a2 + 4) );\n    }\n    result = sub_401110((signed int *)a2, a3);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4019e0L", 
            "funcEndAddr": "0x401b21L", 
            "funcName": "sub_4019E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401B30(char a1, __int64 a2, __m128 a3)\n{\n  __int64 result; // rax\n  int v4; // eax\n  __int64 v5; // rbp\n  signed __int64 v6; // rbx\n  __int64 v7; // r14\n  float v8; // xmm3_4\n\n  result = sub_4053B0(5);\n  if ( !(_DWORD)result )\n  {\n    v4 = *(_DWORD *)(a2 + 4);\n    if ( v4 > 0 )\n    {\n      v5 = 0LL;\n      v6 = 0LL;\n      do\n      {\n        v7 = *(_QWORD *)(a2 + 16);\n        if ( (1LL << a1) & *(_QWORD *)(v7 + v5 + 8) )\n        {\n          a3 = _mm_xor_ps((__m128)*(unsigned int *)(v7 + v5), (__m128)xmmword_408870);\n          a3.m128_f32[0] = a3.m128_f32[0] - (float)(*(float *)(v7 + v5 + 4) * 0.0);\n          v8 = (float)(*(float *)(v7 + v5) * 0.0) - *(float *)(v7 + v5 + 4);\n          *(_DWORD *)(v7 + v5) = a3.m128_i32[0];\n          *(float *)(v7 + v5 + 4) = v8;\n          v4 = *(_DWORD *)(a2 + 4);\n        }\n        ++v6;\n        v5 += 16LL;\n      }\n      while ( v6 < v4 );\n    }\n    result = sub_401110((signed int *)a2, a3);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401b30L", 
            "funcEndAddr": "0x401c31L", 
            "funcName": "sub_401B30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401C40(unsigned int a1, __int64 a2, __m128 a3)\n{\n  __int64 v3; // r14\n  unsigned int v4; // er15\n  __int64 result; // rax\n  unsigned int v6; // ebx\n  signed __int64 v7; // r12\n  __int64 v8; // r13\n  __int64 v9; // rcx\n  unsigned __int64 v10; // rax\n  int v11; // esi\n  _QWORD *v12; // r8\n  __int64 v13; // rdx\n  int v14; // edi\n  __m128d v15; // xmm8\n  __m128i v16; // xmm9\n  __int64 v17; // rcx\n  __m128i v18; // xmm10\n  __m128i v19; // xmm3\n  __m128i v20; // xmm11\n  __m128i v21; // xmm12\n  __m128i v22; // xmm14\n  __m128i v23; // xmm15\n  __m128i v24; // xmm4\n  __m128i v25; // xmm5\n  __m128i v26; // xmm6\n  __m128i v27; // xmm4\n  __m128i v28; // xmm7\n  double v29; // xmm2_8\n  __m128d v30; // xmm0\n  __m128i v31; // xmm5\n  __m128d v32; // xmm1\n  double v33; // xmm2_8\n  __m128d v34; // xmm6\n  __m128d v35; // xmm7\n  __m128i v36; // xmm10\n  __m128i v37; // xmm0\n  int v38; // ecx\n  __int64 v39; // rbp\n  int v40; // [rsp+Ch] [rbp-5Ch]\n  __int64 v41; // [rsp+10h] [rbp-58h]\n  __int64 v42; // [rsp+18h] [rbp-50h]\n  __int128 v43; // [rsp+20h] [rbp-48h]\n\n  v3 = a2;\n  v4 = a1;\n  result = sub_406360(&v40, 0LL);\n  if ( !v40 )\n  {\n    if ( *(_DWORD *)(a2 + 4) <= 0 )\n      return result;\n    v7 = (1LL << a1) + 0xFFFFFFFFLL;\n    v42 = a1;\n    v41 = a1 & 0xFFFFFFF8;\n    _mm_store_si128((__m128i *)&v43, _mm_shuffle_epi32(_mm_cvtsi32_si128(a1), 0));\n    v8 = 0LL;\n    while ( 1 )\n    {\n      result = sub_4053B0(14);\n      if ( (_DWORD)result )\n        return result;\n      v9 = *(_QWORD *)(v3 + 16);\n      v10 = *(_QWORD *)(v9 + 16 * v8 + 8);\n      v11 = v7 & *(unsigned __int64 *)(v9 + 16 * v8 + 8);\n      v12 = (_QWORD *)(v9 + 16 * v8 + 8);\n      if ( (signed int)v4 <= 0 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( v4 >= 8 )\n        {\n          v15 = (__m128d)_mm_shuffle_epi32((__m128i)v10, 68);\n          v16 = 0LL;\n          v17 = v41;\n          v18 = 0LL;\n          v19 = _mm_load_si128((const __m128i *)&xmmword_408880);\n          v20 = _mm_load_si128((const __m128i *)&v43);\n          v21 = _mm_load_si128((const __m128i *)&xmmword_408890);\n          v22 = _mm_load_si128((const __m128i *)&xmmword_4088A0);\n          v23 = _mm_load_si128((const __m128i *)&xmmword_4088B0);\n          do\n          {\n            v24 = _mm_add_epi32(v19, v20);\n            v25 = _mm_add_epi32(v24, v21);\n            v26 = _mm_unpackhi_epi32(v24, (__m128i)0LL);\n            v27 = _mm_unpacklo_epi32(v24, (__m128i)0LL);\n            v28 = _mm_unpackhi_epi32(v25, (__m128i)0LL);\n            *(_QWORD *)&v29 = v22.m128i_i64[0] << v27.m128i_i8[0];\n            v30 = (__m128d)_mm_sll_epi64(v22, _mm_shuffle_epi32(v27, 78));\n            v27.m128i_i64[0] = v22.m128i_i64[0] << v26.m128i_i8[0];\n            v31 = _mm_unpacklo_epi32(v25, (__m128i)0LL);\n            v32 = (__m128d)_mm_sll_epi64(v22, _mm_shuffle_epi32(v26, 78));\n            v30.m128d_f64[0] = v29;\n            *(_QWORD *)&v33 = v22.m128i_i64[0] << v31.m128i_i8[0];\n            v34 = (__m128d)_mm_sll_epi64(v22, _mm_shuffle_epi32(v31, 78));\n            v31.m128i_i64[0] = v22.m128i_i64[0] << v28.m128i_i8[0];\n            v32.m128d_f64[0] = *(double *)v27.m128i_i64;\n            v35 = (__m128d)_mm_sll_epi64(v22, _mm_shuffle_epi32(v28, 78));\n            v34.m128d_f64[0] = v33;\n            v35.m128d_f64[0] = *(double *)v31.m128i_i64;\n            v16 = _mm_add_epi32(\n                    v16,\n                    (__m128i)_mm_shuffle_ps((__m128)_mm_and_pd(v30, v15), (__m128)_mm_and_pd(v32, v15), 136));\n            v18 = _mm_add_epi32(\n                    v18,\n                    (__m128i)_mm_shuffle_ps((__m128)_mm_and_pd(v34, v15), (__m128)_mm_and_pd(v35, v15), 136));\n            v19 = _mm_add_epi32(v19, v23);\n            v17 -= 8LL;\n          }\n          while ( v17 );\n          v36 = _mm_add_epi32(v18, v16);\n          v37 = _mm_add_epi32(_mm_shuffle_epi32(v36, 78), v36);\n          v14 = _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v37, 229), v37));\n          v13 = v41;\n          if ( v41 == v42 )\n            goto LABEL_18;\n        }\n        else\n        {\n          v13 = 0LL;\n          v14 = 0;\n        }\n        v38 = v4 + v13;\n        v39 = v42 - v13;\n        do\n        {\n          v14 += (1LL << v38++) & v10;\n          --v39;\n        }\n        while ( v39 );\n      }\nLABEL_18:\n      *v12 = (v14 >> v4) + (v11 << v4) + v10 - (v14 + v11);\n      ++v8;\n      result = *(signed int *)(v3 + 4);\n      if ( v8 >= result )\n        return result;\n    }\n  }\n  if ( (signed int)a1 > 0 )\n  {\n    v6 = 0;\n    do\n    {\n      sub_401500(v6, a1 + v6, a2, a3);\n      sub_401500(a1 + v6, v6, a2, a3);\n      result = sub_401500(v6, a1 + v6, a2, a3);\n      ++v6;\n    }\n    while ( a1 != v6 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401c40L", 
            "funcEndAddr": "0x401f16L", 
            "funcName": "sub_401C40"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_401F20@<rax>(__int64 result@<rax>, __int64 a2@<rdx>, unsigned int a3@<edi>, signed int a4@<esi>, __m128 a5@<xmm0>)\n{\n  __int64 v5; // r14\n  unsigned int v6; // ebx\n  int v7; // ebp\n  signed int v8; // er12\n  __int64 v9; // rax\n  __int64 v10; // rax\n\n  v5 = a2;\n  v6 = a4;\n  if ( a4 > 0 )\n  {\n    v7 = 2 * a4 + 2;\n    v8 = a4;\n    do\n    {\n      v9 = sub_4015F0(result, v7, v5, a3, v6, a5);\n      v10 = sub_4015F0(v9, v6, v5, a3, v7, a5);\n      result = sub_4015F0(v10, v7++, v5, a3, v6++, a5);\n      --v8;\n    }\n    while ( v8 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x401f20L", 
            "funcEndAddr": "0x401f82L", 
            "funcName": "sub_401F20"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_401F90(char a1, __int64 a2, unsigned int *a3, __int64 a4, __m128 a5)\n{\n  __int64 v5; // r13\n  char v6; // r14\n  int v7; // er8\n  __int64 v8; // rdi\n  signed __int64 v9; // rsi\n  __int64 v10; // r15\n  _QWORD *v11; // rdi\n  __int64 v12; // rsi\n  __int64 v13; // rbx\n  signed int v14; // edx\n  _DWORD *v15; // rax\n  signed __int64 v16; // r10\n  int v17; // ecx\n  char v18; // r9\n  signed int v19; // eax\n  __int64 v20; // rbp\n  int v21; // er12\n  unsigned __int64 v22; // r11\n  signed __int64 v23; // rbx\n  signed int v24; // edx\n  int v25; // ecx\n  __m128 v26; // xmm1\n  __m128 v27; // xmm1\n  size_t v28; // rsi\n  void *v29; // rax\n  int v30; // eax\n  signed __int64 v31; // rdi\n  size_t v32; // rbp\n  signed __int64 v33; // rsi\n  signed __int64 v34; // rbx\n  int v35; // er11\n  __int64 v36; // r14\n  void *v37; // rdi\n  __int64 v38; // r10\n  signed __int64 v39; // r15\n  __int64 v40; // rsi\n  int v41; // er12\n  int v42; // er8\n  signed int v43; // edx\n  __int64 v44; // rbp\n  int v45; // ebx\n  __m128 v46; // xmm8\n  __m128 v47; // xmm7\n  int v48; // ecx\n  char v49; // bp\n  __m128 v50; // xmm3\n  __m128 v51; // xmm2\n  __m128 v52; // xmm4\n  __m128 v53; // xmm6\n  __m128 v54; // xmm2\n  __m128 v55; // xmm3\n  __m128 v56; // xmm4\n  __m128 v57; // xmm2\n  __m128 v58; // xmm3\n  __m128 v59; // xmm2\n  __m128 v60; // xmm4\n  __m128 v61; // xmm2\n  __m128 v62; // xmm3\n  __m128 v63; // xmm4\n  __m128 v64; // xmm6\n  __int64 v65; // rax\n  __m128 v66; // xmm0\n  __m128 v67; // xmm4\n  __m128 v68; // xmm1\n  float v69; // xmm4_4\n  float v70; // xmm6_4\n  __m128 v71; // xmm2\n  __m128 v72; // xmm3\n  __m128 v73; // xmm0\n  float v74; // xmm1_4\n  __m128 v75; // xmm0\n  float v76; // xmm1_4\n  __int64 v77; // rax\n  signed __int64 v78; // rbp\n  __m128 v79; // xmm2\n  __m128 v80; // xmm1\n  __m128 v81; // xmm0\n  __m128 v82; // xmm4\n  __m128 v83; // xmm1\n  __m128 v84; // xmm2\n  __int64 v85; // rax\n  float *v86; // rcx\n  __m128 v87; // xmm0\n  __m128 v88; // xmm3\n  __m128 v89; // xmm4\n  __m128 v90; // xmm0\n  int v91; // eax\n  __m128i v92; // xmm0\n  double v93; // xmm1_8\n  signed __int64 v94; // rcx\n  signed __int64 v95; // rdx\n  int v96; // esi\n  int v97; // ebx\n  __int64 v98; // rdi\n  __m128 v99; // xmm1\n  __m128 v100; // xmm2\n  __int64 v101; // rax\n  signed __int64 v102; // rdi\n  int v103; // eax\n  size_t v104; // rsi\n  void *v105; // rax\n  unsigned int *v107; // [rsp+10h] [rbp-88h]\n  void *ptr; // [rsp+18h] [rbp-80h]\n  signed __int64 v109; // [rsp+40h] [rbp-58h]\n  int v110; // [rsp+4Ch] [rbp-4Ch]\n  signed __int64 v111; // [rsp+60h] [rbp-38h]\n\n  v5 = a4;\n  v6 = a1;\n  if ( a2 != 8589934594LL )\n  {\n    puts(\"Matrix is not a 2x2 matrix!\");\n    exit(1);\n  }\n  LOBYTE(v7) = 31;\n  if ( *(_DWORD *)(a4 + 8) != 31 )\n  {\n    v8 = *(_QWORD *)(a4 + 24);\n    v9 = 0LL;\n    do\n    {\n      *(_DWORD *)(v8 + 4 * v9) = 0;\n      v7 = *(_DWORD *)(a4 + 8);\n      ++v9;\n    }\n    while ( v9 < 1 << *(_DWORD *)(a4 + 8) );\n  }\n  LODWORD(v10) = *(_DWORD *)(a4 + 4);\n  v11 = *(_QWORD **)(a4 + 16);\n  v107 = a3;\n  if ( (signed int)v10 <= 0 )\n    goto LABEL_89;\n  v12 = *(_QWORD *)(a4 + 24);\n  v13 = 0LL;\n  while ( 1 )\n  {\n    v14 = -1640562687 * ((unsigned int)v11[2 * v13 + 1] ^ (unsigned int)(v11[2 * v13 + 1] >> 32)) >> (32 - v7);\n    if ( *(_DWORD *)(v12 + 4LL * v14) )\n    {\n      do\n      {\n        if ( ++v14 == 1 << v7 )\n          v14 = 0;\n      }\n      while ( *(_DWORD *)(v12 + 4LL * v14) );\n      v15 = (_DWORD *)(v12 + 4LL * v14);\n    }\n    else\n    {\n      v15 = (_DWORD *)(v12 + 4LL * v14);\n    }\n    *v15 = ++v13;\n    v10 = *(signed int *)(a4 + 4);\n    if ( v13 >= v10 )\n      break;\n    v7 = *(_DWORD *)(a4 + 8);\n  }\n  if ( (signed int)v10 <= 0 )\n  {\nLABEL_89:\n    v21 = 0;\n  }\n  else\n  {\n    v16 = 1LL << v6;\n    v17 = *(_DWORD *)(a4 + 8);\n    v18 = 32 - v17;\n    v19 = 1 << v17;\n    a5 = (__m128)0x3E112E0BE826D695uLL;\n    v20 = 0LL;\n    v21 = 0;\n    do\n    {\n      v22 = v11[2 * v20 + 1];\n      v23 = v16 ^ v11[2 * v20 + 1];\n      v24 = -1640562687 * ((unsigned int)v23 ^ (((unsigned __int64)v16 ^ v11[2 * v20 + 1]) >> 32)) >> v18;\n      while ( 1 )\n      {\n        v25 = *(_DWORD *)(*(_QWORD *)(v5 + 24) + 4LL * v24);\n        if ( !v25 )\n          break;\n        if ( v11[2 * v25 - 1] == v23 )\n          goto LABEL_27;\n        if ( ++v24 == v19 )\n          v24 = 0;\n      }\n      v26 = _mm_mul_ps((__m128)*((unsigned __int64 *)v107 + 1), (__m128)*((unsigned __int64 *)v107 + 1));\n      if ( (float)(COERCE_FLOAT(_mm_shuffle_ps(v26, v26, 229)) + v26.m128_f32[0]) > 0.000000001 )\n        v21 -= ((v16 & v22) < 1) - 1;\n      v27 = _mm_mul_ps((__m128)*((unsigned __int64 *)v107 + 2), (__m128)*((unsigned __int64 *)v107 + 2));\n      if ( (float)(COERCE_FLOAT(_mm_shuffle_ps(v27, v27, 229)) + v27.m128_f32[0]) > 0.000000001 )\n        v21 += (v16 & v22) < 1;\nLABEL_27:\n      ++v20;\n    }\n    while ( v20 != (unsigned int)v10 );\n  }\n  v28 = 16LL * (v21 + (signed int)v10);\n  v29 = realloc(v11, v28);\n  *(_QWORD *)(v5 + 16) = v29;\n  if ( !v29 )\n    goto LABEL_81;\n  sub_404120(16LL * v21, v28);\n  if ( v21 > 0 )\n  {\n    v30 = 0;\n    if ( v21 != 1 )\n    {\n      v30 = 0;\n      a5 = 0LL;\n      do\n      {\n        *(_OWORD *)(*(_QWORD *)(v5 + 16) + 16LL * (v30 + *(_DWORD *)(v5 + 4))) = 0LL;\n        v31 = 16LL * (v30 + *(_DWORD *)(v5 + 4) + 1);\n        v30 += 2;\n        *(_OWORD *)(*(_QWORD *)(v5 + 16) + v31) = 0LL;\n      }\n      while ( v21 - (v21 & 1) != v30 );\n    }\n    if ( v21 & 1 )\n    {\n      a5 = 0LL;\n      *(_OWORD *)(*(_QWORD *)(v5 + 16) + 16 * (*(signed int *)(v5 + 4) + (signed __int64)v30)) = 0LL;\n    }\n  }\n  v32 = v21 + (signed __int64)*(signed int *)(v5 + 4);\n  v33 = 1LL;\n  ptr = calloc(v32, 1uLL);\n  if ( !ptr )\n  {\n    printf(\"Not enough memory for %i bytes array!\\n\", v32, *(double *)a5.m128_u64);\n    exit(1);\n  }\n  sub_404120(v32, 1LL);\n  v34 = 1LL << *(_BYTE *)v5;\n  v35 = *(_DWORD *)(v5 + 4);\n  if ( v35 <= 0 )\n  {\n    v37 = ptr;\n    goto LABEL_69;\n  }\n  v111 = 1LL << *(_BYTE *)v5;\n  v110 = v21;\n  v109 = 1LL << v6;\n  v36 = 0LL;\n  v37 = ptr;\nLABEL_40:\n  v38 = *(_QWORD *)(v5 + 16);\n  v39 = 16 * v36;\n  v40 = *(_QWORD *)(v38 + 16 * v36 + 8);\n  v41 = v40 & v109;\n  v33 = v109 ^ v40;\n  v42 = *(_DWORD *)(v5 + 8);\n  v43 = -1640562687 * ((unsigned int)v33 ^ HIDWORD(v33)) >> (32 - v42);\n  v44 = *(_QWORD *)(v5 + 24);\n  v45 = *(_DWORD *)(v44 + 4LL * v43);\n  if ( v45 )\n  {\n    while ( *(_QWORD *)(v38 + 16LL * v45 - 8) != v33 )\n    {\n      if ( ++v43 == 1 << v42 )\n        v43 = 0;\n      v45 = *(_DWORD *)(v44 + 4LL * v43);\n      if ( !v45 )\n        goto LABEL_45;\n    }\n    v48 = v45 - 1;\n    v46 = (__m128)*(unsigned __int64 *)(v38 + v39);\n    if ( v45 > 0 )\n    {\n      v47 = (__m128)*(unsigned __int64 *)(v38 + 16LL * v48);\n      v49 = 1;\n      if ( !v41 )\n        goto LABEL_50;\n      goto LABEL_47;\n    }\n    v47 = 0LL;\n  }\n  else\n  {\nLABEL_45:\n    v46 = (__m128)*(unsigned __int64 *)(v38 + v39);\n    v47 = 0LL;\n    v48 = -1;\n  }\n  v49 = 0;\n  if ( !v41 )\n  {\nLABEL_50:\n    v58 = _mm_mul_ps(_mm_shuffle_ps((__m128)*v107, (__m128)*v107, 224), v46);\n    v59 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[1], (__m128)v107[1], 224), _mm_shuffle_ps(v46, v46, 225));\n    v60 = _mm_sub_ps(v58, v59);\n    v53 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v59, v58), v60, 1), v60, 226);\n    v61 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[2], (__m128)v107[2], 224), v47);\n    v62 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[3], (__m128)v107[3], 224), _mm_shuffle_ps(v47, v47, 225));\n    v63 = _mm_sub_ps(v61, v62);\n    v57 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v62, v61), v63, 1), v63, 226);\n    goto LABEL_51;\n  }\nLABEL_47:\n  v50 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[4], (__m128)v107[4], 224), v47);\n  v51 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[5], (__m128)v107[5], 224), _mm_shuffle_ps(v47, v47, 225));\n  v52 = _mm_sub_ps(v50, v51);\n  v53 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v51, v50), v52, 1), v52, 226);\n  v54 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[6], (__m128)v107[6], 224), v46);\n  v55 = _mm_mul_ps(_mm_shuffle_ps((__m128)v107[7], (__m128)v107[7], 224), _mm_shuffle_ps(v46, v46, 225));\n  v56 = _mm_sub_ps(v54, v55);\n  v57 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v55, v54), v56, 1), v56, 226);\nLABEL_51:\n  v64 = _mm_add_ps(v53, v57);\n  v65 = *(_QWORD *)(v5 + 16);\n  *(_DWORD *)(v65 + v39) = v64.m128_i32[0];\n  *(_DWORD *)(v65 + v39 + 4) = (unsigned __int128)_mm_shuffle_ps(v64, v64, 229);\n  if ( v49 )\n  {\n    if ( v41 )\n    {\n      v66 = (__m128)*(unsigned __int64 *)v107;\n      v67 = _mm_mul_ps(v47, v66);\n      v68 = _mm_mul_ps(_mm_shuffle_ps(v47, v47, 225), v66);\n      v69 = v67.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(v67, v67, 229));\n      v70 = COERCE_FLOAT(_mm_shuffle_ps(v68, v68, 229)) + v68.m128_f32[0];\n      v71 = (__m128)*((unsigned __int64 *)v107 + 1);\n      a5 = _mm_mul_ps(v46, v71);\n      v72 = _mm_mul_ps((__m128)_mm_shuffle_epi32((__m128i)v71, 225), v46);\n    }\n    else\n    {\n      v81 = (__m128)*((unsigned __int64 *)v107 + 2);\n      v82 = _mm_mul_ps(v46, v81);\n      v83 = _mm_mul_ps(_mm_shuffle_ps(v46, v46, 225), v81);\n      v69 = v82.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(v82, v82, 229));\n      v70 = COERCE_FLOAT(_mm_shuffle_ps(v83, v83, 229)) + v83.m128_f32[0];\n      v84 = (__m128)*((unsigned __int64 *)v107 + 3);\n      a5 = _mm_mul_ps(v47, v84);\n      v72 = _mm_mul_ps(_mm_shuffle_ps(v47, v47, 225), v84);\n    }\n    a5.m128_f32[0] = a5.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(a5, a5, 229));\n    v85 = v48;\n    v33 = 16LL * v48;\n    v86 = (float *)(v33 + *(_QWORD *)(v5 + 16));\n    *v86 = v69 + a5.m128_f32[0];\n    v86[1] = v70 + (float)(COERCE_FLOAT(_mm_shuffle_ps(v72, v72, 229)) + v72.m128_f32[0]);\n    *((_BYTE *)ptr + v85) = 1;\n    goto LABEL_66;\n  }\n  if ( !v41\n    || (v73 = _mm_mul_ps((__m128)*((unsigned __int64 *)v107 + 1), (__m128)*((unsigned __int64 *)v107 + 1)),\n        v74 = COERCE_FLOAT(_mm_shuffle_ps(v73, v73, 229)) + v73.m128_f32[0],\n        a5 = 0LL,\n        *(double *)a5.m128_u64 = v74,\n        v74 >= 0.000000001) )\n  {\n    if ( v41\n      || (v75 = _mm_mul_ps((__m128)*((unsigned __int64 *)v107 + 2), (__m128)*((unsigned __int64 *)v107 + 2)),\n          v76 = COERCE_FLOAT(_mm_shuffle_ps(v75, v75, 229)) + v75.m128_f32[0],\n          a5 = 0LL,\n          *(double *)a5.m128_u64 = v76,\n          v76 >= 0.000000001) )\n    {\n      v77 = *(_QWORD *)(v5 + 16);\n      v78 = 16LL * v35;\n      *(_QWORD *)(v77 + v78 + 8) = v109 ^ *(_QWORD *)(v77 + v39 + 8);\n      if ( v41 )\n      {\n        v79 = (__m128)v107[2];\n        v80 = (__m128)v107[3];\n      }\n      else\n      {\n        v79 = (__m128)v107[4];\n        v80 = (__m128)v107[5];\n      }\n      v87 = _mm_mul_ps(_mm_shuffle_ps(v79, v79, 224), v46);\n      v88 = _mm_mul_ps(_mm_shuffle_ps(v80, v80, 224), _mm_shuffle_ps(v46, v46, 225));\n      v89 = _mm_sub_ps(v87, v88);\n      v90 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v88, v87), v89, 1), v89, 226);\n      *(_DWORD *)(v77 + v78) = v90.m128_i32[0];\n      a5 = _mm_shuffle_ps(v90, v90, 229);\n      *(_DWORD *)(v77 + v78 + 4) = a5.m128_i32[0];\n      ++v35;\nLABEL_66:\n      while ( ++v36 < *(signed int *)(v5 + 4) )\n      {\n        if ( !*((_BYTE *)ptr + v36) )\n          goto LABEL_40;\n      }\n    }\n  }\n  v35 = *(_DWORD *)(v5 + 4);\n  v21 = v110;\n  v34 = v111;\nLABEL_69:\n  *(_DWORD *)(v5 + 4) = v21 + v35;\n  free(v37);\n  sub_404120(-(signed __int64)*(signed int *)(v5 + 4), v33);\n  v91 = *(_DWORD *)(v5 + 4);\n  if ( v91 > 0 )\n  {\n    v92 = (__m128i)_mm_sub_pd(\n                     (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v34, (__m128i)xmmword_4088C0),\n                     (__m128d)xmmword_4088D0);\n    v93 = COERCE_DOUBLE(_mm_shuffle_epi32(v92, 78)) + *(double *)v92.m128i_i64;\n    a5 = (__m128)0x3FF0000000000000uLL;\n    *(double *)a5.m128_u64 = 1.0 / v93 / 1000000.0;\n    a5.m128_f32[0] = *(double *)a5.m128_u64;\n    v94 = 0LL;\n    v95 = 8LL;\n    v96 = 0;\n    v97 = 0;\n    do\n    {\n      v98 = *(_QWORD *)(v5 + 16);\n      v99 = (__m128)*(unsigned __int64 *)(v98 + v95 - 8);\n      v100 = _mm_mul_ps(v99, v99);\n      if ( a5.m128_f32[0] <= (float)(COERCE_FLOAT(_mm_shuffle_ps(v100, v100, 229)) + v100.m128_f32[0]) )\n      {\n        if ( v96 )\n        {\n          v101 = *(_QWORD *)(v98 + v95);\n          v102 = v98 - 16LL * v96;\n          *(_QWORD *)(v102 + v95) = v101;\n          *(_DWORD *)(v102 + v95 - 8) = v99.m128_i32[0];\n          *(_DWORD *)(v95 + v102 - 4) = (unsigned __int128)_mm_shuffle_ps(v99, v99, 229);\n          v91 = *(_DWORD *)(v5 + 4);\n        }\n        else\n        {\n          v96 = 0;\n        }\n      }\n      else\n      {\n        ++v96;\n        ++v97;\n      }\n      ++v94;\n      v95 += 16LL;\n    }\n    while ( v94 < v91 );\n    if ( v97 )\n    {\n      v103 = v91 - v97;\n      *(_DWORD *)(v5 + 4) = v103;\n      v104 = 16LL * v103;\n      v105 = realloc(*(void **)(v5 + 16), v104);\n      *(_QWORD *)(v5 + 16) = v105;\n      if ( v105 )\n      {\n        sub_404120(16LL * -v97, v104);\n        return sub_401110((signed int *)v5, a5);\n      }\nLABEL_81:\n      printf(\n        \"Not enough memory for %i-sized qubit!\\n\",\n        (unsigned int)(*(_DWORD *)(v5 + 4) + v21),\n        *(double *)a5.m128_u64);\n      exit(1);\n    }\n  }\n  return sub_401110((signed int *)v5, a5);\n}\n", 
            "funcStartAddr": "0x401f90L", 
            "funcEndAddr": "0x402b21L", 
            "funcName": "sub_401F90"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_402B30(__m128 a1, __int64 a2, char a3, __int64 a4, float *a5, __int64 a6)\n{\n  __int64 v6; // r13\n  char v7; // r14\n  int v8; // er8\n  __int64 v9; // rdx\n  signed __int64 v10; // rsi\n  __int64 v11; // r15\n  _QWORD *v12; // rdi\n  __int64 v13; // rsi\n  __int64 v14; // rbx\n  signed int v15; // edx\n  _DWORD *v16; // rax\n  signed __int64 v17; // r10\n  int v18; // ecx\n  char v19; // r9\n  signed int v20; // eax\n  __int64 v21; // rbp\n  int v22; // er12\n  unsigned __int64 v23; // r11\n  signed __int64 v24; // rbx\n  signed int v25; // edx\n  int v26; // ecx\n  size_t v27; // rsi\n  void *v28; // rax\n  int v29; // eax\n  signed __int64 v30; // rdi\n  size_t v31; // rbp\n  signed __int64 v32; // rsi\n  signed __int64 v33; // rbx\n  int v34; // er10\n  signed __int64 v35; // r11\n  __int64 v36; // r14\n  void *v37; // rdi\n  __int64 v38; // r9\n  signed __int64 v39; // r15\n  __int64 v40; // rsi\n  int v41; // er12\n  int v42; // er8\n  signed int v43; // edx\n  __int64 v44; // rbp\n  int v45; // ebx\n  __m128 v46; // xmm6\n  __m128 v47; // xmm7\n  int v48; // ecx\n  char v49; // bp\n  __m128 v50; // xmm3\n  __m128 v51; // xmm2\n  __m128 v52; // xmm4\n  __m128 v53; // xmm5\n  __m128 v54; // xmm2\n  __m128 v55; // xmm3\n  __m128 v56; // xmm4\n  __m128 v57; // xmm3\n  __m128 v58; // xmm2\n  __m128 v59; // xmm4\n  __m128 v60; // xmm5\n  __int64 v61; // rax\n  __m128 v62; // xmm0\n  __m128 v63; // xmm4\n  __m128 v64; // xmm1\n  float v65; // xmm4_4\n  float v66; // xmm5_4\n  __m128 v67; // xmm2\n  __m128 v68; // xmm3\n  __int64 v69; // rax\n  signed __int64 v70; // rbp\n  __m128 v71; // xmm2\n  __m128 v72; // xmm1\n  __m128 v73; // xmm0\n  __m128 v74; // xmm4\n  __m128 v75; // xmm1\n  __m128 v76; // xmm2\n  __int64 v77; // rax\n  float *v78; // rcx\n  __m128 v79; // xmm0\n  __m128 v80; // xmm3\n  __m128 v81; // xmm4\n  __m128 v82; // xmm0\n  int v83; // eax\n  __m128i v84; // xmm0\n  double v85; // xmm1_8\n  signed __int64 v86; // rcx\n  signed __int64 v87; // rdx\n  int v88; // esi\n  int v89; // ebx\n  __int64 v90; // rdi\n  __m128 v91; // xmm1\n  __m128 v92; // xmm2\n  __int64 v93; // rax\n  signed __int64 v94; // rdi\n  int v95; // eax\n  size_t v96; // rsi\n  void *v97; // rax\n  void *ptr; // [rsp+10h] [rbp-88h]\n  float *v100; // [rsp+40h] [rbp-58h]\n  int v101; // [rsp+4Ch] [rbp-4Ch]\n  signed __int64 v102; // [rsp+60h] [rbp-38h]\n\n  v6 = a6;\n  v7 = a3;\n  if ( a4 != 17179869188LL )\n  {\n    puts(\"Matrix is not a 4x4 matrix!\");\n    exit(1);\n  }\n  LOBYTE(v8) = 31;\n  if ( *(_DWORD *)(v6 + 8) != 31 )\n  {\n    v9 = *(_QWORD *)(v6 + 24);\n    v10 = 0LL;\n    do\n    {\n      *(_DWORD *)(v9 + 4 * v10) = 0;\n      v8 = *(_DWORD *)(v6 + 8);\n      ++v10;\n    }\n    while ( v10 < 1 << *(_DWORD *)(v6 + 8) );\n  }\n  LODWORD(v11) = *(_DWORD *)(v6 + 4);\n  v12 = *(_QWORD **)(v6 + 16);\n  v100 = a5;\n  if ( (signed int)v11 <= 0 )\n    goto LABEL_94;\n  v13 = *(_QWORD *)(v6 + 24);\n  v14 = 0LL;\n  while ( 1 )\n  {\n    v15 = -1640562687 * ((unsigned int)v12[2 * v14 + 1] ^ (unsigned int)(v12[2 * v14 + 1] >> 32)) >> (32 - v8);\n    if ( *(_DWORD *)(v13 + 4LL * v15) )\n    {\n      do\n      {\n        if ( ++v15 == 1 << v8 )\n          v15 = 0;\n      }\n      while ( *(_DWORD *)(v13 + 4LL * v15) );\n      v16 = (_DWORD *)(v13 + 4LL * v15);\n    }\n    else\n    {\n      v16 = (_DWORD *)(v13 + 4LL * v15);\n    }\n    *v16 = ++v14;\n    v11 = *(signed int *)(v6 + 4);\n    if ( v14 >= v11 )\n      break;\n    v8 = *(_DWORD *)(v6 + 8);\n  }\n  if ( (signed int)v11 <= 0 )\n  {\nLABEL_94:\n    v22 = 0;\n  }\n  else\n  {\n    v17 = 1LL << v7;\n    v18 = *(_DWORD *)(v6 + 8);\n    v19 = 32 - v18;\n    v20 = 1 << v18;\n    a1 = 0LL;\n    v21 = 0LL;\n    v22 = 0;\n    do\n    {\n      v23 = v12[2 * v21 + 1];\n      v24 = v17 ^ v12[2 * v21 + 1];\n      v25 = -1640562687 * ((unsigned int)v24 ^ (((unsigned __int64)v17 ^ v12[2 * v21 + 1]) >> 32)) >> v19;\n      while ( 1 )\n      {\n        v26 = *(_DWORD *)(*(_QWORD *)(v6 + 24) + 4LL * v25);\n        if ( !v26 )\n          break;\n        if ( v12[2 * v26 - 1] == v24 )\n          goto LABEL_29;\n        if ( ++v25 == v20 )\n          v25 = 0;\n      }\n      if ( v100[2] != 0.0 || v100[3] != 0.0 )\n        v22 -= ((v17 & v23) < 1) - 1;\n      if ( v100[4] != 0.0 || v100[5] != 0.0 )\n        v22 += (v17 & v23) < 1;\nLABEL_29:\n      ++v21;\n    }\n    while ( v21 != (unsigned int)v11 );\n  }\n  v27 = 16LL * (v22 + (signed int)v11);\n  v28 = realloc(v12, v27);\n  *(_QWORD *)(v6 + 16) = v28;\n  if ( !v28 )\n    goto LABEL_86;\n  sub_404120(16LL * v22, v27);\n  if ( v22 > 0 )\n  {\n    v29 = 0;\n    if ( v22 != 1 )\n    {\n      v29 = 0;\n      a1 = 0LL;\n      do\n      {\n        *(_OWORD *)(*(_QWORD *)(v6 + 16) + 16LL * (v29 + *(_DWORD *)(v6 + 4))) = 0LL;\n        v30 = 16LL * (v29 + *(_DWORD *)(v6 + 4) + 1);\n        v29 += 2;\n        *(_OWORD *)(*(_QWORD *)(v6 + 16) + v30) = 0LL;\n      }\n      while ( v22 - (v22 & 1) != v29 );\n    }\n    if ( v22 & 1 )\n    {\n      a1 = 0LL;\n      *(_OWORD *)(*(_QWORD *)(v6 + 16) + 16 * (*(signed int *)(v6 + 4) + (signed __int64)v29)) = 0LL;\n    }\n  }\n  v31 = v22 + (signed __int64)*(signed int *)(v6 + 4);\n  v32 = 1LL;\n  ptr = calloc(v31, 1uLL);\n  if ( !ptr )\n  {\n    printf(\"Not enough memory for %i bytes array!\\n\", v31, *(double *)a1.m128_u64);\n    exit(1);\n  }\n  sub_404120(v31, 1LL);\n  v33 = 1LL << *(_BYTE *)v6;\n  v34 = *(_DWORD *)(v6 + 4);\n  if ( v34 <= 0 )\n  {\n    v37 = ptr;\n    goto LABEL_74;\n  }\n  v102 = 1LL << *(_BYTE *)v6;\n  v101 = v22;\n  v35 = 1LL << v7;\n  v36 = 0LL;\n  v37 = ptr;\nLABEL_42:\n  v38 = *(_QWORD *)(v6 + 16);\n  v39 = 16 * v36;\n  v40 = *(_QWORD *)(v38 + 16 * v36 + 8);\n  v41 = v40 & v35;\n  v32 = v35 ^ v40;\n  v42 = *(_DWORD *)(v6 + 8);\n  v43 = -1640562687 * ((unsigned int)v32 ^ HIDWORD(v32)) >> (32 - v42);\n  v44 = *(_QWORD *)(v6 + 24);\n  v45 = *(_DWORD *)(v44 + 4LL * v43);\n  if ( v45 )\n  {\n    while ( *(_QWORD *)(v38 + 16LL * v45 - 8) != v32 )\n    {\n      if ( ++v43 == 1 << v42 )\n        v43 = 0;\n      v45 = *(_DWORD *)(v44 + 4LL * v43);\n      if ( !v45 )\n        goto LABEL_47;\n    }\n    v48 = v45 - 1;\n    v46 = (__m128)*(unsigned __int64 *)(v38 + v39);\n    if ( v45 > 0 )\n    {\n      v47 = (__m128)*(unsigned __int64 *)(v38 + 16LL * v48);\n      v49 = 1;\n      goto LABEL_49;\n    }\n    v47 = 0LL;\n  }\n  else\n  {\nLABEL_47:\n    v46 = (__m128)*(unsigned __int64 *)(v38 + v39);\n    v47 = 0LL;\n    v48 = -1;\n  }\n  v49 = 0;\nLABEL_49:\n  if ( v41 )\n  {\n    v50 = _mm_mul_ps(_mm_shuffle_ps((__m128)*((unsigned int *)v100 + 4), (__m128)*((unsigned int *)v100 + 4), 224), v47);\n    v51 = _mm_mul_ps(\n            _mm_shuffle_ps((__m128)*((unsigned int *)v100 + 5), (__m128)*((unsigned int *)v100 + 5), 224),\n            _mm_shuffle_ps(v47, v47, 225));\n    v52 = _mm_sub_ps(v50, v51);\n    v53 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v51, v50), v52, 1), v52, 226);\n    v54 = _mm_mul_ps(_mm_shuffle_ps((__m128)*((unsigned int *)v100 + 6), (__m128)*((unsigned int *)v100 + 6), 224), v46);\n    v55 = _mm_mul_ps(\n            _mm_shuffle_ps((__m128)*((unsigned int *)v100 + 7), (__m128)*((unsigned int *)v100 + 7), 224),\n            _mm_shuffle_ps(v46, v46, 225));\n  }\n  else\n  {\n    v57 = _mm_mul_ps(_mm_shuffle_ps((__m128)*(unsigned int *)v100, (__m128)*(unsigned int *)v100, 224), v46);\n    v58 = _mm_mul_ps(\n            _mm_shuffle_ps((__m128)*((unsigned int *)v100 + 1), (__m128)*((unsigned int *)v100 + 1), 224),\n            _mm_shuffle_ps(v46, v46, 225));\n    v59 = _mm_sub_ps(v57, v58);\n    v53 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v58, v57), v59, 1), v59, 226);\n    v54 = _mm_mul_ps(_mm_shuffle_ps((__m128)*((unsigned int *)v100 + 2), (__m128)*((unsigned int *)v100 + 2), 224), v47);\n    v55 = _mm_mul_ps(\n            _mm_shuffle_ps((__m128)*((unsigned int *)v100 + 3), (__m128)*((unsigned int *)v100 + 3), 224),\n            _mm_shuffle_ps(v47, v47, 225));\n  }\n  v56 = _mm_sub_ps(v54, v55);\n  v60 = _mm_add_ps(v53, _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v55, v54), v56, 1), v56, 226));\n  v61 = *(_QWORD *)(v6 + 16);\n  *(_DWORD *)(v61 + v39) = v60.m128_i32[0];\n  *(_DWORD *)(v61 + v39 + 4) = (unsigned __int128)_mm_shuffle_ps(v60, v60, 229);\n  if ( v49 )\n  {\n    if ( v41 )\n    {\n      v62 = (__m128)*(unsigned __int64 *)v100;\n      v63 = _mm_mul_ps(v47, v62);\n      v64 = _mm_mul_ps(_mm_shuffle_ps(v47, v47, 225), v62);\n      v65 = v63.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(v63, v63, 229));\n      v66 = COERCE_FLOAT(_mm_shuffle_ps(v64, v64, 229)) + v64.m128_f32[0];\n      v67 = (__m128)*((unsigned __int64 *)v100 + 1);\n      a1 = _mm_mul_ps(v46, v67);\n      v68 = _mm_mul_ps((__m128)_mm_shuffle_epi32((__m128i)v67, 225), v46);\n    }\n    else\n    {\n      v73 = (__m128)*((unsigned __int64 *)v100 + 2);\n      v74 = _mm_mul_ps(v46, v73);\n      v75 = _mm_mul_ps(_mm_shuffle_ps(v46, v46, 225), v73);\n      v65 = v74.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(v74, v74, 229));\n      v66 = COERCE_FLOAT(_mm_shuffle_ps(v75, v75, 229)) + v75.m128_f32[0];\n      v76 = (__m128)*((unsigned __int64 *)v100 + 3);\n      a1 = _mm_mul_ps(v47, v76);\n      v68 = _mm_mul_ps(_mm_shuffle_ps(v47, v47, 225), v76);\n    }\n    a1.m128_f32[0] = a1.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(a1, a1, 229));\n    v77 = v48;\n    v32 = 16LL * v48;\n    v78 = (float *)(v32 + *(_QWORD *)(v6 + 16));\n    *v78 = v65 + a1.m128_f32[0];\n    v78[1] = v66 + (float)(COERCE_FLOAT(_mm_shuffle_ps(v68, v68, 229)) + v68.m128_f32[0]);\n    *((_BYTE *)ptr + v77) = 1;\n    goto LABEL_71;\n  }\n  if ( !v41 || v100[2] != 0.0 || (a1 = (__m128)*((unsigned int *)v100 + 3), a1.m128_f32[0] != 0.0) )\n  {\n    if ( v41 || v100[4] != 0.0 || (a1 = (__m128)*((unsigned int *)v100 + 5), a1.m128_f32[0] != 0.0) )\n    {\n      v69 = *(_QWORD *)(v6 + 16);\n      v70 = 16LL * v34;\n      *(_QWORD *)(v69 + v70 + 8) = v35 ^ *(_QWORD *)(v69 + v39 + 8);\n      if ( v41 )\n      {\n        v71 = (__m128)*((unsigned int *)v100 + 2);\n        v72 = (__m128)*((unsigned int *)v100 + 3);\n      }\n      else\n      {\n        v71 = (__m128)*((unsigned int *)v100 + 4);\n        v72 = (__m128)*((unsigned int *)v100 + 5);\n      }\n      v79 = _mm_mul_ps(_mm_shuffle_ps(v71, v71, 224), v46);\n      v80 = _mm_mul_ps(_mm_shuffle_ps(v72, v72, 224), _mm_shuffle_ps(v46, v46, 225));\n      v81 = _mm_sub_ps(v79, v80);\n      v82 = _mm_shuffle_ps(_mm_shuffle_ps(_mm_add_ps(v80, v79), v81, 1), v81, 226);\n      *(_DWORD *)(v69 + v70) = v82.m128_i32[0];\n      a1 = _mm_shuffle_ps(v82, v82, 229);\n      *(_DWORD *)(v69 + v70 + 4) = a1.m128_i32[0];\n      ++v34;\nLABEL_71:\n      while ( ++v36 < *(signed int *)(v6 + 4) )\n      {\n        if ( !*((_BYTE *)ptr + v36) )\n          goto LABEL_42;\n      }\n    }\n  }\n  v34 = *(_DWORD *)(v6 + 4);\n  v22 = v101;\n  v33 = v102;\nLABEL_74:\n  *(_DWORD *)(v6 + 4) = v22 + v34;\n  free(v37);\n  sub_404120(-(signed __int64)*(signed int *)(v6 + 4), v32);\n  v83 = *(_DWORD *)(v6 + 4);\n  if ( v83 > 0 )\n  {\n    v84 = (__m128i)_mm_sub_pd(\n                     (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v33, (__m128i)xmmword_4088C0),\n                     (__m128d)xmmword_4088D0);\n    v85 = COERCE_DOUBLE(_mm_shuffle_epi32(v84, 78)) + *(double *)v84.m128i_i64;\n    a1 = (__m128)0x3FF0000000000000uLL;\n    *(double *)a1.m128_u64 = 1.0 / v85 / 1000000.0;\n    a1.m128_f32[0] = *(double *)a1.m128_u64;\n    v86 = 0LL;\n    v87 = 8LL;\n    v88 = 0;\n    v89 = 0;\n    do\n    {\n      v90 = *(_QWORD *)(v6 + 16);\n      v91 = (__m128)*(unsigned __int64 *)(v90 + v87 - 8);\n      v92 = _mm_mul_ps(v91, v91);\n      if ( a1.m128_f32[0] <= (float)(COERCE_FLOAT(_mm_shuffle_ps(v92, v92, 229)) + v92.m128_f32[0]) )\n      {\n        if ( v88 )\n        {\n          v93 = *(_QWORD *)(v90 + v87);\n          v94 = v90 - 16LL * v88;\n          *(_QWORD *)(v94 + v87) = v93;\n          *(_DWORD *)(v94 + v87 - 8) = v91.m128_i32[0];\n          *(_DWORD *)(v87 + v94 - 4) = (unsigned __int128)_mm_shuffle_ps(v91, v91, 229);\n          v83 = *(_DWORD *)(v6 + 4);\n        }\n        else\n        {\n          v88 = 0;\n        }\n      }\n      else\n      {\n        ++v88;\n        ++v89;\n      }\n      ++v86;\n      v87 += 16LL;\n    }\n    while ( v86 < v83 );\n    if ( v89 )\n    {\n      v95 = v83 - v89;\n      *(_DWORD *)(v6 + 4) = v95;\n      v96 = 16LL * v95;\n      v97 = realloc(*(void **)(v6 + 16), v96);\n      *(_QWORD *)(v6 + 16) = v97;\n      if ( v97 )\n      {\n        sub_404120(16LL * -v89, v96);\n        return sub_401110((signed int *)v6, a1);\n      }\nLABEL_86:\n      printf(\n        \"Not enough memory for %i-sized qubit!\\n\",\n        (unsigned int)(*(_DWORD *)(v6 + 4) + v22),\n        *(double *)a1.m128_u64);\n      exit(1);\n    }\n  }\n  return sub_401110((signed int *)v6, a1);\n}\n", 
            "funcStartAddr": "0x402b30L", 
            "funcEndAddr": "0x403661L", 
            "funcName": "sub_402B30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403670(char a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int128 v3; // ax\n  __int128 v4; // [rsp+8h] [rbp-20h]\n\n  result = sub_4053B0(6);\n  if ( !(_DWORD)result )\n  {\n    *(_QWORD *)&v3 = sub_404150(2LL, 2LL);\n    v4 = v3;\n    **((_QWORD **)&v3 + 1) = 1060439283LL;\n    *(_QWORD *)(*((_QWORD *)&v4 + 1) + 8LL) = 1060439283LL;\n    *((_QWORD *)&v3 + 1) = *((_QWORD *)&v4 + 1);\n    *(_OWORD *)(*((_QWORD *)&v4 + 1) + 16LL) = xmmword_4088E0;\n    sub_401F90(a1, v4, *((unsigned int **)&v3 + 1), a2, (__m128)xmmword_4088E0);\n    result = sub_4041D0(&v4, v4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403670L", 
            "funcEndAddr": "0x4036eaL", 
            "funcName": "sub_403670"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_4036F0(int a1, __int64 a2)\n{\n  __int64 v2; // r15\n  int v3; // ebx\n  __int128 v4; // ax\n  __int64 v5; // rsi\n  __int128 v6; // [rsp+8h] [rbp-30h]\n\n  v2 = a2;\n  if ( a1 > 0 )\n  {\n    v3 = 0;\n    do\n    {\n      if ( !(unsigned int)sub_4053B0(6) )\n      {\n        *(_QWORD *)&v4 = sub_404150(2LL, 2LL);\n        v6 = v4;\n        **((_QWORD **)&v4 + 1) = 1060439283LL;\n        *(_QWORD *)(*((_QWORD *)&v6 + 1) + 8LL) = 1060439283LL;\n        *((_QWORD *)&v4 + 1) = *((_QWORD *)&v6 + 1);\n        *(_OWORD *)(*((_QWORD *)&v6 + 1) + 16LL) = xmmword_4088E0;\n        v5 = v6;\n        sub_401F90(v3, v6, *((unsigned int **)&v4 + 1), v2, (__m128)xmmword_4088E0);\n        sub_4041D0(&v6, v5);\n      }\n      ++v3;\n    }\n    while ( a1 != v3 );\n  }\n}\n", 
            "funcStartAddr": "0x4036f0L", 
            "funcEndAddr": "0x403788L", 
            "funcName": "sub_4036F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403790(char a1, __int64 a2, float a3)\n{\n  __int64 result; // rax\n  __int128 v4; // ax\n  __int64 v5; // rbx\n  double x; // ST08_8\n  float v7; // xmm0_4\n  double v8; // xmm0_8\n  float v9; // xmm1_4\n  __int64 v10; // rax\n  double v11; // xmm0_8\n  float v12; // xmm1_4\n  unsigned int *v13; // rbx\n  __m128 v14; // xmm0\n  __int128 v15; // [rsp+10h] [rbp-28h]\n\n  result = sub_4053B0(7);\n  if ( !(_DWORD)result )\n  {\n    *(_QWORD *)&v4 = sub_404150(2LL, 2LL);\n    v5 = *((_QWORD *)&v4 + 1);\n    v15 = v4;\n    x = (float)(a3 * 0.5);\n    v7 = cos(x);\n    *(float *)v5 = v7;\n    *(_DWORD *)(v5 + 4) = 0;\n    v8 = sin(x);\n    v9 = v8;\n    *(float *)&v8 = v8 * -0.0;\n    v10 = *((_QWORD *)&v15 + 1);\n    *(_DWORD *)(*((_QWORD *)&v15 + 1) + 8LL) = LODWORD(v8);\n    *(_DWORD *)(v10 + 12) = LODWORD(v9) ^ xmmword_408870;\n    v11 = sin(x);\n    v12 = -0.0 * v11;\n    *(float *)&v11 = v11;\n    v13 = (unsigned int *)*((_QWORD *)&v15 + 1);\n    *(float *)(*((_QWORD *)&v15 + 1) + 16LL) = v12;\n    v13[5] = LODWORD(v11) ^ xmmword_408870;\n    v14 = (__m128)*(unsigned __int64 *)&x;\n    *(double *)v14.m128_u64 = cos(x);\n    v14.m128_f32[0] = *(double *)v14.m128_u64;\n    v13[6] = v14.m128_i32[0];\n    v13[7] = 0;\n    sub_401F90(a1, v15, v13, a2, v14);\n    result = sub_4041D0(&v15, v15);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403790L", 
            "funcEndAddr": "0x4038abL", 
            "funcName": "sub_403790"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4038B0(char a1, __int64 a2, float a3)\n{\n  __int64 result; // rax\n  __int128 v4; // ax\n  __int64 v5; // rbx\n  double x; // ST08_8\n  float v7; // xmm0_4\n  float v8; // xmm0_4\n  __int64 v9; // rax\n  float v10; // xmm0_4\n  unsigned int *v11; // rbx\n  __m128 v12; // xmm0\n  __int128 v13; // [rsp+10h] [rbp-28h]\n\n  result = sub_4053B0(8);\n  if ( !(_DWORD)result )\n  {\n    *(_QWORD *)&v4 = sub_404150(2LL, 2LL);\n    v5 = *((_QWORD *)&v4 + 1);\n    v13 = v4;\n    x = (float)(a3 * 0.5);\n    v7 = cos(x);\n    *(float *)v5 = v7;\n    *(_DWORD *)(v5 + 4) = 0;\n    v8 = sin(x);\n    v9 = *((_QWORD *)&v13 + 1);\n    *(_DWORD *)(*((_QWORD *)&v13 + 1) + 8LL) = LODWORD(v8) ^ xmmword_408870;\n    *(_DWORD *)(v9 + 12) = 0;\n    v10 = sin(x);\n    v11 = (unsigned int *)*((_QWORD *)&v13 + 1);\n    *(float *)(*((_QWORD *)&v13 + 1) + 16LL) = v10;\n    v11[5] = 0;\n    v12 = (__m128)*(unsigned __int64 *)&x;\n    *(double *)v12.m128_u64 = cos(x);\n    v12.m128_f32[0] = *(double *)v12.m128_u64;\n    v11[6] = v12.m128_i32[0];\n    v11[7] = 0;\n    sub_401F90(a1, v13, v11, a2, v12);\n    result = sub_4041D0(&v13, v13);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4038b0L", 
            "funcEndAddr": "0x4039acL", 
            "funcName": "sub_4038B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4039B0(unsigned int a1, __int64 a2, float a3)\n{\n  __int64 result; // rax\n  __m128 v4; // xmm0\n  __m128 v5; // xmm2\n  float v6; // xmm3_4\n  __int64 v7; // rbp\n  signed __int64 v8; // rbx\n  __int64 v9; // r14\n  float v10; // xmm5_4\n  float v11; // xmm1_4\n  float v12; // xmm6_4\n  __m128 v13; // [rsp+0h] [rbp-48h]\n  float v14; // [rsp+10h] [rbp-38h]\n\n  result = sub_4053B0(9);\n  if ( !(_DWORD)result )\n  {\n    v4 = sub_401080(a3 * 0.5);\n    v5 = v4;\n    if ( *(_DWORD *)(a2 + 4) > 0 )\n    {\n      LODWORD(v6) = (unsigned __int128)_mm_shuffle_ps(v4, v4, 229);\n      v7 = 0LL;\n      v8 = 0LL;\n      v13 = v4;\n      v14 = v6;\n      do\n      {\n        v9 = *(_QWORD *)(a2 + 16);\n        v10 = *(float *)(v9 + v7);\n        v11 = *(float *)(v9 + v7 + 4);\n        if ( (1LL << a1) & *(_QWORD *)(v9 + v7 + 8) )\n        {\n          v4 = v5;\n          v4.m128_f32[0] = (float)(v5.m128_f32[0] * v10) - (float)(v6 * v11);\n          v12 = (float)(v5.m128_f32[0] * v11) + (float)(v6 * v10);\n        }\n        else\n        {\n          v4 = (__m128)*(unsigned int *)(v9 + v7);\n          sub_408410(9LL, a1);\n          v6 = v14;\n          v5 = v13;\n          LODWORD(v12) = (unsigned __int128)_mm_shuffle_ps(v4, v4, 229);\n        }\n        *(_DWORD *)(v9 + v7) = v4.m128_i32[0];\n        *(float *)(v9 + v7 + 4) = v12;\n        ++v8;\n        v7 += 16LL;\n      }\n      while ( v8 < *(signed int *)(a2 + 4) );\n    }\n    result = sub_401110((signed int *)a2, v4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4039b0L", 
            "funcEndAddr": "0x403adfL", 
            "funcName": "sub_4039B0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403AE0(float a1, __int64 a2, __int64 a3)\n{\n  __int64 result; // rax\n  __m128 v4; // xmm0\n  __m128 v5; // xmm5\n  float v6; // xmm3_4\n  signed __int64 v7; // r15\n  signed __int64 v8; // rbx\n  __int64 v9; // r12\n  float v10; // xmm2_4\n  float v11; // xmm1_4\n\n  result = sub_4053B0(11);\n  if ( !(_DWORD)result )\n  {\n    v4 = sub_401080(a1);\n    v5 = v4;\n    if ( *(_DWORD *)(a3 + 4) > 0 )\n    {\n      LODWORD(v6) = (unsigned __int128)_mm_shuffle_ps(v4, v4, 229);\n      v7 = 0LL;\n      v8 = 4LL;\n      do\n      {\n        v9 = *(_QWORD *)(a3 + 16);\n        v10 = *(float *)(v9 + v8 - 4);\n        v11 = *(float *)(v9 + v8);\n        v4 = v5;\n        v4.m128_f32[0] = (float)(v5.m128_f32[0] * v10) - (float)(v6 * v11);\n        *(_DWORD *)(v9 + v8 - 4) = v4.m128_i32[0];\n        *(float *)(v9 + v8) = (float)(v5.m128_f32[0] * v11) + (float)(v6 * v10);\n        ++v7;\n        v8 += 16LL;\n      }\n      while ( v7 < *(signed int *)(a3 + 4) );\n    }\n    result = sub_401110((signed int *)a3, v4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403ae0L", 
            "funcEndAddr": "0x403be0L", 
            "funcName": "sub_403AE0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403BE0(char a1, __int64 a2, float a3)\n{\n  __int64 result; // rax\n  __m128 v4; // xmm0\n  __m128 v5; // xmm5\n  int v6; // eax\n  float v7; // xmm3_4\n  __int64 v8; // rbp\n  signed __int64 v9; // rbx\n  __int64 v10; // r14\n  float v11; // xmm2_4\n  float v12; // xmm1_4\n\n  result = sub_4053B0(10);\n  if ( !(_DWORD)result )\n  {\n    v4 = sub_401080(a3);\n    v5 = v4;\n    v6 = *(_DWORD *)(a2 + 4);\n    if ( v6 > 0 )\n    {\n      LODWORD(v7) = (unsigned __int128)_mm_shuffle_ps(v4, v4, 229);\n      v8 = 0LL;\n      v9 = 0LL;\n      do\n      {\n        v10 = *(_QWORD *)(a2 + 16);\n        if ( (1LL << a1) & *(_QWORD *)(v10 + v8 + 8) )\n        {\n          v11 = *(float *)(v10 + v8);\n          v12 = *(float *)(v10 + v8 + 4);\n          v4 = v5;\n          v4.m128_f32[0] = (float)(v5.m128_f32[0] * v11) - (float)(v7 * v12);\n          *(_DWORD *)(v10 + v8) = v4.m128_i32[0];\n          *(float *)(v10 + v8 + 4) = (float)(v5.m128_f32[0] * v12) + (float)(v7 * v11);\n          v6 = *(_DWORD *)(a2 + 4);\n        }\n        ++v9;\n        v8 += 16LL;\n      }\n      while ( v9 < v6 );\n    }\n    result = sub_401110((signed int *)a2, v4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403be0L", 
            "funcEndAddr": "0x403cfdL", 
            "funcName": "sub_403BE0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403D00(char a1, char a2, __int64 a3)\n{\n  __int64 v3; // r15\n  __int64 result; // rax\n  __m128i v5; // xmm0\n  __m128 v6; // xmm0\n  __m128 v7; // xmm5\n  int v8; // eax\n  float v9; // xmm3_4\n  __int64 v10; // rbx\n  signed __int64 v11; // rbp\n  __int64 v12; // r14\n  float v13; // xmm2_4\n  float v14; // xmm1_4\n\n  v3 = a3;\n  result = sub_4053B0(12);\n  if ( !(_DWORD)result )\n  {\n    v5 = (__m128i)_mm_sub_pd(\n                    (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)(1LL << (a1 - a2)), (__m128i)xmmword_4088C0),\n                    (__m128d)xmmword_4088D0);\n    *(float *)v5.m128i_i32 = 3.141592654 / (COERCE_DOUBLE(_mm_shuffle_epi32(v5, 78)) + *(double *)v5.m128i_i64);\n    v6 = sub_401080(*(float *)v5.m128i_i32);\n    v7 = v6;\n    v8 = *(_DWORD *)(v3 + 4);\n    if ( v8 > 0 )\n    {\n      LODWORD(v9) = (unsigned __int128)_mm_shuffle_ps(v6, v6, 229);\n      v10 = 0LL;\n      v11 = 0LL;\n      do\n      {\n        v12 = *(_QWORD *)(v3 + 16);\n        if ( (((1LL << a1) | (1LL << a2)) & *(_QWORD *)(v12 + v10 + 8)) == ((1LL << a1) | (1LL << a2)) )\n        {\n          v13 = *(float *)(v12 + v10);\n          v14 = *(float *)(v12 + v10 + 4);\n          v6 = v7;\n          v6.m128_f32[0] = (float)(v7.m128_f32[0] * v13) - (float)(v9 * v14);\n          *(_DWORD *)(v12 + v10) = v6.m128_i32[0];\n          *(float *)(v12 + v10 + 4) = (float)(v7.m128_f32[0] * v14) + (float)(v9 * v13);\n          v8 = *(_DWORD *)(v3 + 4);\n        }\n        ++v11;\n        v10 += 16LL;\n      }\n      while ( v11 < v8 );\n    }\n    result = sub_401110((signed int *)v3, v6);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403d00L", 
            "funcEndAddr": "0x403e65L", 
            "funcName": "sub_403D00"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403E70(char a1, char a2, __int64 a3)\n{\n  __int64 v3; // r15\n  __m128i v4; // xmm0\n  __m128 v5; // xmm0\n  __m128 v6; // xmm5\n  int v7; // eax\n  float v8; // xmm3_4\n  __int64 v9; // rbx\n  signed __int64 v10; // rbp\n  __int64 v11; // r14\n  float v12; // xmm2_4\n  float v13; // xmm1_4\n\n  v3 = a3;\n  v4 = (__m128i)_mm_sub_pd(\n                  (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)(1LL << (a1 - a2)), (__m128i)xmmword_4088C0),\n                  (__m128d)xmmword_4088D0);\n  *(float *)v4.m128i_i32 = -3.141592654 / (COERCE_DOUBLE(_mm_shuffle_epi32(v4, 78)) + *(double *)v4.m128i_i64);\n  v5 = sub_401080(*(float *)v4.m128i_i32);\n  v6 = v5;\n  v7 = *(_DWORD *)(v3 + 4);\n  if ( v7 > 0 )\n  {\n    LODWORD(v8) = (unsigned __int128)_mm_shuffle_ps(v5, v5, 229);\n    v9 = 0LL;\n    v10 = 0LL;\n    do\n    {\n      v11 = *(_QWORD *)(v3 + 16);\n      if ( (((1LL << a1) | (1LL << a2)) & *(_QWORD *)(v11 + v9 + 8)) == ((1LL << a1) | (1LL << a2)) )\n      {\n        v12 = *(float *)(v11 + v9);\n        v13 = *(float *)(v11 + v9 + 4);\n        v5 = v6;\n        v5.m128_f32[0] = (float)(v6.m128_f32[0] * v12) - (float)(v8 * v13);\n        *(_DWORD *)(v11 + v9) = v5.m128_i32[0];\n        *(float *)(v11 + v9 + 4) = (float)(v6.m128_f32[0] * v13) + (float)(v8 * v12);\n        v7 = *(_DWORD *)(v3 + 4);\n      }\n      ++v10;\n      v9 += 16LL;\n    }\n    while ( v10 < v7 );\n  }\n  return sub_401110((signed int *)v3, v5);\n}\n", 
            "funcStartAddr": "0x403e70L", 
            "funcEndAddr": "0x403fa1L", 
            "funcName": "sub_403E70"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_403FB0(char a1, char a2, __int64 a3, float a4)\n{\n  __int64 v4; // r15\n  __int64 result; // rax\n  __m128 v6; // xmm0\n  __m128 v7; // xmm5\n  int v8; // eax\n  float v9; // xmm3_4\n  __int64 v10; // rbx\n  signed __int64 v11; // rbp\n  __int64 v12; // r14\n  float v13; // xmm2_4\n  float v14; // xmm1_4\n\n  v4 = a3;\n  result = sub_4053B0(12);\n  if ( !(_DWORD)result )\n  {\n    v6 = sub_401080(a4);\n    v7 = v6;\n    v8 = *(_DWORD *)(v4 + 4);\n    if ( v8 > 0 )\n    {\n      LODWORD(v9) = (unsigned __int128)_mm_shuffle_ps(v6, v6, 229);\n      v10 = 0LL;\n      v11 = 0LL;\n      do\n      {\n        v12 = *(_QWORD *)(v4 + 16);\n        if ( (((1LL << a1) | (1LL << a2)) & *(_QWORD *)(v12 + v10 + 8)) == ((1LL << a1) | (1LL << a2)) )\n        {\n          v13 = *(float *)(v12 + v10);\n          v14 = *(float *)(v12 + v10 + 4);\n          v6 = v7;\n          v6.m128_f32[0] = (float)(v7.m128_f32[0] * v13) - (float)(v9 * v14);\n          *(_DWORD *)(v12 + v10) = v6.m128_i32[0];\n          *(float *)(v12 + v10 + 4) = (float)(v7.m128_f32[0] * v14) + (float)(v9 * v13);\n          v8 = *(_DWORD *)(v4 + 4);\n        }\n        ++v11;\n        v10 += 16LL;\n      }\n      while ( v11 < v8 );\n    }\n    result = sub_401110((signed int *)v4, v6);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x403fb0L", 
            "funcEndAddr": "0x4040e1L", 
            "funcName": "sub_403FB0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4040F0(int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 <= 0 )\n  {\n    if ( a1 < 0 )\n    {\n      dword_40C0EC = 0;\n      result = 0LL;\n    }\n    else\n    {\n      result = (unsigned int)dword_40C0EC;\n    }\n  }\n  else\n  {\n    dword_40C0EC += a1;\n    result = (unsigned int)dword_40C0EC;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4040f0L", 
            "funcEndAddr": "0x40411dL", 
            "funcName": "sub_4040F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404120(__int64 a1)\n{\n  __int64 v1; // rdi\n\n  v1 = qword_40C0F0 + a1;\n  qword_40C0F0 = v1;\n  if ( v1 > qword_40C0F8 )\n    qword_40C0F8 = v1;\n  return v1;\n}\n", 
            "funcStartAddr": "0x404120L", 
            "funcEndAddr": "0x404142L", 
            "funcName": "sub_404120"
        }, 
        {
            "decompiledFuncCode": "unsigned __int64 __usercall sub_404150@<rax>(__int64 a1@<rax>, unsigned int a2@<edi>, unsigned int a3@<esi>)\n{\n  __int64 v3; // rax\n  __int64 v5; // [rsp-8h] [rbp-18h]\n\n  v5 = a1;\n  if ( !calloc((signed int)(a2 * a3), 8uLL) )\n  {\n    printf(\"Not enogh memory for %ix%i-Matrix!\", a3, a2, v5);\n    exit(1);\n  }\n  v3 = qword_40C0F0 + 8 * (signed int)a2 * (signed __int64)(signed int)a3;\n  qword_40C0F0 = v3;\n  if ( v3 > qword_40C0F8 )\n    qword_40C0F8 = v3;\n  return a3 | ((unsigned __int64)a2 << 32);\n}\n", 
            "funcStartAddr": "0x404150L", 
            "funcEndAddr": "0x4041cdL", 
            "funcName": "sub_404150"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4041D0(void **a1)\n{\n  __int64 result; // rax\n\n  free(a1[1]);\n  result = qword_40C0F0 - 8 * *((signed int *)a1 + 1) * (signed __int64)*(signed int *)a1;\n  qword_40C0F0 = result;\n  if ( result > qword_40C0F8 )\n    qword_40C0F8 = result;\n  a1[1] = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x4041d0L", 
            "funcEndAddr": "0x404217L", 
            "funcName": "sub_4041D0"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_404220(unsigned __int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // rcx\n  signed int v4; // eax\n  unsigned __int64 v5; // r14\n  signed __int64 v6; // r12\n  __int64 v7; // rbx\n  unsigned __int64 v8; // rbp\n  float *v9; // r13\n  __int64 v11; // [rsp+0h] [rbp-38h]\n\n  LODWORD(v3) = 0;\n  do\n  {\n    v4 = 1 << v3;\n    v3 = (unsigned int)(v3 + 1);\n  }\n  while ( v4 < (signed int)a1 );\n  if ( (signed int)a1 > 0 )\n  {\n    v5 = a1 >> 32;\n    v11 = (unsigned int)a1;\n    v6 = a2 + 4;\n    v7 = 0LL;\n    do\n    {\n      if ( (signed int)v5 > 0 )\n      {\n        v8 = a1 >> 32;\n        v9 = (float *)v6;\n        do\n        {\n          printf(\"% f %+fi\\t\", a2, a3, v3, *(v9 - 1), *v9, v11);\n          v9 += 2;\n          --v8;\n        }\n        while ( v8 );\n      }\n      putchar(10);\n      ++v7;\n      v6 += 8 * ((signed __int64)a1 >> 32);\n    }\n    while ( v7 != v11 );\n  }\n  return putchar(10);\n}\n", 
            "funcStartAddr": "0x404220L", 
            "funcEndAddr": "0x4042c9L", 
            "funcName": "sub_404220"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_4042D0(void)\n{\n  return sub_408040();\n}\n", 
            "funcStartAddr": "0x4042d0L", 
            "funcEndAddr": "0x4042d5L", 
            "funcName": "sub_4042D0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_4042E0(double a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)\n{\n  signed __int64 v10; // rbx\n  signed __int64 *v12; // rcx\n  signed __int64 v13; // rdx\n  __m128 v14; // xmm2\n\n  v10 = 0LL;\n  if ( !(unsigned int)sub_4053B0(128) )\n  {\n    sub_408040(128LL);\n    v10 = -1LL;\n    if ( SHIDWORD(a8) > 0LL )\n    {\n      v12 = (signed __int64 *)(a10 + 8);\n      v13 = 0LL;\n      while ( 1 )\n      {\n        v14 = _mm_mul_ps((__m128)(unsigned __int64)*(v12 - 1), (__m128)(unsigned __int64)*(v12 - 1));\n        a1 = a1 - (float)(COERCE_FLOAT(_mm_shuffle_ps(v14, v14, 229)) + v14.m128_f32[0]);\n        if ( a1 <= 0.0 )\n          break;\n        ++v13;\n        v12 += 2;\n        if ( v13 >= SHIDWORD(a8) )\n          return v10;\n      }\n      v10 = *v12;\n    }\n  }\n  return v10;\n}\n", 
            "funcStartAddr": "0x4042e0L", 
            "funcEndAddr": "0x404368L", 
            "funcName": "sub_4042E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404370(unsigned int a1, __int64 a2, double a3)\n{\n  __int128 *v3; // rbx\n  _BOOL4 v4; // ebp\n  __int64 v5; // rcx\n  float *v6; // rdx\n  double v7; // xmm2_8\n  __int64 v8; // rsi\n  __int128 v9; // ST10_16\n  __int128 v10; // ST00_16\n  __int128 v11; // ST40_16\n  __int128 v12; // ST30_16\n  __int128 v14; // [rsp+50h] [rbp-38h]\n  __int128 v15; // [rsp+60h] [rbp-28h]\n\n  v3 = (__int128 *)a2;\n  v4 = 0;\n  if ( !(unsigned int)sub_4053B0(129) )\n  {\n    v5 = *(signed int *)(a2 + 4);\n    if ( v5 <= 0 )\n    {\n      v7 = 0.0;\n    }\n    else\n    {\n      v6 = (float *)(*(_QWORD *)(a2 + 16) + 8LL);\n      v7 = 0.0;\n      v8 = 0LL;\n      do\n      {\n        if ( !((1LL << a1) & *(_QWORD *)v6) )\n        {\n          a3 = (float)((float)(*(v6 - 1) * *(v6 - 1)) + (float)(*(v6 - 2) * *(v6 - 2)));\n          v7 = v7 + a3;\n        }\n        ++v8;\n        v6 += 4;\n      }\n      while ( v8 < v5 );\n    }\n    sub_408040(129LL);\n    v4 = a3 > v7;\n    v9 = v3[1];\n    v10 = *v3;\n    sub_407360((unsigned __int64)&v14, a1);\n    v11 = v15;\n    v12 = v14;\n    sub_406E90(v3, a1);\n    v3[1] = v11;\n    *v3 = v12;\n  }\n  return (unsigned int)v4;\n}\n", 
            "funcStartAddr": "0x404370L", 
            "funcEndAddr": "0x404467L", 
            "funcName": "sub_404370"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404470(char a1, int *a2, double a3)\n{\n  _BOOL4 v3; // er14\n  signed __int64 v4; // rbp\n  __int64 v5; // rax\n  double v6; // xmm2_8\n  float *v7; // rcx\n  __int64 v8; // rdx\n  double v9; // xmm3_8\n  __int64 v10; // rax\n  signed __int64 v11; // rcx\n  unsigned int v12; // er14\n  __int64 v13; // rdx\n  char *v14; // rbp\n  int v15; // eax\n  __int64 v16; // r13\n  double v17; // xmm5_8\n  signed __int64 v18; // r12\n  int v19; // er14\n  __int64 v20; // rcx\n  signed __int64 v21; // r15\n  float v22; // xmm7_4\n  float v23; // xmm6_4\n  double v24; // xmm0_8\n  float v25; // xmm0_4\n  bool v27; // [rsp+Fh] [rbp-89h]\n  double x; // [rsp+10h] [rbp-88h]\n  int v29; // [rsp+1Ch] [rbp-7Ch]\n  int v30; // [rsp+20h] [rbp-78h]\n  unsigned int v31; // [rsp+24h] [rbp-74h]\n  double v32; // [rsp+28h] [rbp-70h]\n  __int64 v33; // [rsp+48h] [rbp-50h]\n\n  v3 = 0;\n  if ( !(unsigned int)sub_4053B0(130) )\n  {\n    v4 = 1LL << a1;\n    v5 = a2[1];\n    v6 = 0.0;\n    if ( v5 > 0 )\n    {\n      v7 = (float *)(*((_QWORD *)a2 + 2) + 8LL);\n      v6 = 0.0;\n      v8 = 0LL;\n      do\n      {\n        if ( !(v4 & *(_QWORD *)v7) )\n        {\n          a3 = (float)((float)(*(v7 - 1) * *(v7 - 1)) + (float)(*(v7 - 2) * *(v7 - 2)));\n          v6 = v6 + a3;\n        }\n        ++v8;\n        v7 += 4;\n      }\n      while ( v8 < v5 );\n    }\n    sub_408040(130LL);\n    v27 = a3 > v6;\n    if ( a2[1] > 0 )\n    {\n      v9 = 0.0;\n      v10 = 0LL;\n      v11 = 0LL;\n      v12 = 0;\n      while ( 1 )\n      {\n        v13 = *((_QWORD *)a2 + 2);\n        if ( v4 & *(_QWORD *)(v13 + v10 + 8) )\n        {\n          if ( a3 <= v6 )\n            goto LABEL_13;\n        }\n        else if ( a3 > v6 )\n        {\nLABEL_13:\n          *(_QWORD *)(v13 + v10) = 0LL;\n          goto LABEL_14;\n        }\n        v9 = v9\n           + (float)((float)(*(float *)(v13 + v10 + 4) * *(float *)(v13 + v10 + 4))\n                   + (float)(*(float *)(v13 + v10) * *(float *)(v13 + v10)));\n        ++v12;\nLABEL_14:\n        ++v11;\n        v10 += 16LL;\n        if ( v11 >= a2[1] )\n          goto LABEL_17;\n      }\n    }\n    v12 = 0;\n    v9 = 0.0;\nLABEL_17:\n    x = v9;\n    v14 = (char *)calloc((signed int)v12, 0x10uLL);\n    if ( !v14 )\n    {\n      printf(\"Not enough memory for %i-sized qubit!\\n\", v12);\n      exit(1);\n    }\n    v31 = v12;\n    sub_404120(16LL * (signed int)v12);\n    v30 = a2[2];\n    v33 = *((_QWORD *)a2 + 3);\n    v29 = *a2;\n    v15 = a2[1];\n    if ( v15 > 0 )\n    {\n      v16 = 0LL;\n      v17 = sqrt(v9);\n      v18 = 0LL;\n      v19 = 0;\n      v32 = v17;\n      do\n      {\n        v20 = *((_QWORD *)a2 + 2);\n        if ( *(float *)(v20 + v16) != 0.0 || *(float *)(v20 + v16 + 4) != 0.0 )\n        {\n          v21 = 16LL * v19;\n          *(_QWORD *)&v14[v21 + 8] = *(_QWORD *)(v20 + v16 + 8);\n          v22 = *(float *)(v20 + v16) - (float)(*(float *)(v20 + v16 + 4) * 0.0);\n          v23 = (float)(*(float *)(v20 + v16) * 0.0) + *(float *)(v20 + v16 + 4);\n          v24 = v17;\n          if ( v9 < 0.0 )\n          {\n            v24 = sqrt(v9);\n            v17 = v32;\n            v9 = x;\n          }\n          v25 = v24;\n          *(float *)&v14[v21] = v22 / v25;\n          *(float *)&v14[v21 + 4] = v23 / v25;\n          ++v19;\n          v15 = a2[1];\n        }\n        ++v18;\n        v16 += 16LL;\n      }\n      while ( v18 < v15 );\n    }\n    v3 = v27;\n    sub_406E90(a2, 16LL);\n    *a2 = v29;\n    a2[1] = v31;\n    a2[2] = v30;\n    *((_QWORD *)a2 + 2) = v14;\n    *((_QWORD *)a2 + 3) = v33;\n  }\n  return (unsigned int)v3;\n}\n", 
            "funcStartAddr": "0x404470L", 
            "funcEndAddr": "0x404776L", 
            "funcName": "sub_404470"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404780(int a1, unsigned int a2, __int64 a3, __m128 a4)\n{\n  __int64 v4; // r15\n  __int64 v5; // rbp\n  int v6; // er13\n  __int64 v7; // rax\n  unsigned __int64 v8; // r12\n  unsigned int v9; // ebx\n  unsigned int v10; // edi\n  __int64 v11; // rax\n  unsigned int v12; // esi\n  unsigned int v13; // edi\n  __int64 v14; // rax\n  unsigned int v15; // ebp\n  unsigned int v16; // ebx\n  signed int v17; // er14\n  __int64 v18; // rax\n  __int64 v19; // rax\n  unsigned int v20; // edx\n  unsigned int v21; // edi\n  unsigned int v22; // esi\n  signed int v23; // ebp\n  unsigned int v24; // ebx\n  __int64 v25; // rax\n  __int64 v26; // rax\n  __int64 v27; // rax\n  __int64 v28; // rax\n  __int64 v29; // rax\n  unsigned int v30; // ebx\n  unsigned int v31; // er14\n  unsigned int v32; // ebp\n  __int64 v33; // rax\n  __int64 v34; // rax\n  __int64 v35; // rax\n  __int64 v36; // rax\n  __int64 result; // rax\n  __int64 v38; // rax\n  unsigned int v39; // [rsp+4h] [rbp-44h]\n  signed int v40; // [rsp+8h] [rbp-40h]\n\n  v4 = a3;\n  v5 = a2;\n  v6 = a1;\n  v7 = a1;\n  v8 = a2 - 1;\n  v9 = 2 * a2 - 1;\n  v39 = 2 * a2 - 1;\n  v10 = 2 * a2 - 1;\n  if ( _bittest64(&v7, v8) )\n  {\n    v11 = sub_401500(v10, v8, a3, a4);\n    sub_401910(v11, v9, v4, a4);\n    v12 = 0;\n    v13 = v9;\n  }\n  else\n  {\n    sub_401910(v7, v10, a3, a4);\n    v13 = 2 * a2 - 1;\n    v12 = v8;\n  }\n  v14 = sub_401500(v13, v12, v4, a4);\n  v40 = v5;\n  if ( (signed int)v5 >= 3 )\n  {\n    v14 = v5;\n    v15 = 2 * v5 - 2;\n    v16 = v8;\n    do\n    {\n      v17 = v16 - 1;\n      if ( _bittest(&v6, v16 - 1) )\n      {\n        v18 = sub_4015F0(v14, v17, v4, v16, v15, a4);\n        v19 = sub_401910(v18, v15, v4, a4);\n        v20 = 0;\n        v21 = v16;\n        v22 = v15;\n      }\n      else\n      {\n        v19 = sub_401910(v14, v15, v4, a4);\n        v21 = v16;\n        v22 = v15;\n        v20 = v16 - 1;\n      }\n      v14 = sub_4015F0(v19, v20, v4, v21, v22, a4);\n      --v15;\n      --v16;\n    }\n    while ( v17 > 1 );\n  }\n  v23 = v40;\n  v24 = 2 * v40;\n  if ( v6 & 1 )\n  {\n    v26 = sub_401910(v14, v40, v4, a4);\n    v27 = sub_4015F0(v26, 0, v4, v40, 1u, a4);\n    v28 = sub_4015F0(v27, v24, v4, v24 | 1, 0, a4);\n    v29 = sub_4015F0(v28, 0, v4, v40, 1u, a4);\n    v25 = sub_401910(v29, v40, v4, a4);\n    if ( v40 < 3 )\n      goto LABEL_19;\n  }\n  else\n  {\n    v25 = sub_4015F0(v14, v24, v4, v24 | 1, 0, a4);\n    if ( v40 < 3 )\n      goto LABEL_19;\n  }\n  v30 = 1;\n  do\n  {\n    v31 = v30 + 1;\n    v32 = v30 + v23;\n    if ( _bittest(&v6, v30) )\n    {\n      v33 = sub_4015F0(v25, 0, v4, v31, v32, a4);\n      v34 = sub_401910(v33, v32, v4, a4);\n      sub_4015F0(v34, v30, v4, v31, v32, a4);\n    }\n    else\n    {\n      v35 = sub_4015F0(v25, v30, v4, v31, v32, a4);\n      sub_401910(v35, v32, v4, a4);\n    }\n    v23 = v40;\n    v25 = 2 - v40 + v31;\n    ++v30;\n  }\n  while ( (_DWORD)v25 != 1 );\nLABEL_19:\n  if ( _bittest(&v6, v8) )\n  {\n    v36 = sub_401500(v39, 0, v4, a4);\n    sub_401910(v36, v39, v4, a4);\n    result = sub_401500(v39, v8, v4, a4);\n  }\n  else\n  {\n    v38 = sub_401500(v39, v8, v4, a4);\n    result = sub_401910(v38, v39, v4, a4);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x404780L", 
            "funcEndAddr": "0x4049b3L", 
            "funcName": "sub_404780"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4049C0(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, __m128 a7, __int64 a8, __int64 a9)\n{\n  unsigned int v9; // er13\n  unsigned int v10; // er12\n  unsigned int v11; // er15\n  unsigned int v12; // er14\n  __int64 result; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n  __int64 v16; // rax\n  __int64 v17; // rax\n  __int64 v18; // rax\n  __int64 v19; // rax\n  __int64 v20; // rax\n  __int64 v21; // rax\n  __int64 v22; // rax\n  __int64 v23; // rax\n  __int64 v24; // rax\n\n  v9 = a6;\n  v10 = a5;\n  v11 = a4;\n  v12 = a3;\n  result = a1;\n  switch ( a1 )\n  {\n    case 0u:\n      goto LABEL_5;\n    case 1u:\n      v14 = sub_4015F0(a1, a2, a9, a6, a5, a7);\n      v15 = sub_4015F0(v14, v11, a9, a2, v12, a7);\n      v16 = sub_4015F0(v15, a2, a9, v9, v10, a7);\n      v17 = sub_4015F0(v16, v11, a9, a2, v12, a7);\n      result = sub_4015F0(v17, v12, a9, v9, v10, a7);\n      goto LABEL_5;\n    case 2u:\n      v18 = sub_401910(a1, a5, a9, a7);\n      v19 = sub_4015F0(v18, a2, a9, v9, v10, a7);\n      v20 = sub_4015F0(v19, v11, a9, a2, v12, a7);\n      v21 = sub_4015F0(v20, a2, a9, v9, v10, a7);\n      v22 = sub_4015F0(v21, v11, a9, a2, v12, a7);\n      v23 = sub_4015F0(v22, v12, a9, v9, v10, a7);\n      sub_4015F0(v23, v11, a9, a2, v12, a7);\n      v24 = sub_401500(a2, v12, a9, a7);\n      result = sub_401910(v24, v10, a9, a7);\n      break;\n    case 3u:\n      sub_4015F0(a1, a4, a9, a6, a3, a7);\n      result = sub_401500(v9, v12, a9, a7);\nLABEL_5:\n      sub_4015F0(result, v11, a9, a2, v12, a7);\n      result = sub_401500(a2, v12, a9, a7);\n      break;\n    default:\n      return result;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4049c0L", 
            "funcEndAddr": "0x404b2dL", 
            "funcName": "sub_4049C0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404B30(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, __m128 a7, __int64 a8, __int64 a9)\n{\n  unsigned int v9; // er14\n  unsigned int v10; // er13\n  unsigned int v11; // er15\n  unsigned int v12; // er12\n  unsigned int v13; // ebp\n  __int64 result; // rax\n  __int64 v15; // rax\n  unsigned int v16; // edi\n  __int64 v17; // rax\n  __int64 v18; // rax\n  __int64 v19; // rax\n  __int64 v20; // rax\n  __int64 v21; // rax\n  unsigned int v22; // esi\n  unsigned int v23; // edx\n  __int64 v24; // rax\n  __int64 v25; // rax\n  __int64 v26; // rax\n  __int64 v27; // rax\n  __int64 v28; // rax\n  __int64 v29; // rax\n  __int64 v30; // rax\n  __int64 v31; // rax\n\n  v9 = a6;\n  v10 = a5;\n  v11 = a4;\n  v12 = a3;\n  v13 = a2;\n  result = a1;\n  switch ( a1 )\n  {\n    case 0u:\n      v15 = sub_401500(a2, a3, a9, a7);\n      v16 = a2;\n      goto LABEL_6;\n    case 1u:\n      v17 = sub_401500(a2, a3, a9, a7);\n      v18 = sub_4015F0(v17, v11, a9, a2, v12, a7);\n      v19 = sub_4015F0(v18, v12, a9, v9, v10, a7);\n      v20 = sub_4015F0(v19, v11, a9, a2, v12, a7);\n      v21 = sub_4015F0(v20, a2, a9, v9, v10, a7);\n      v15 = sub_4015F0(v21, v11, a9, a2, v12, a7);\n      v16 = v9;\n      v22 = v10;\n      v23 = v13;\n      goto LABEL_7;\n    case 2u:\n      sub_401910(a1, a5, a9, a7);\n      v24 = sub_401500(a2, v12, a9, a7);\n      v25 = sub_4015F0(v24, v11, a9, a2, v12, a7);\n      v26 = sub_4015F0(v25, v12, a9, v9, v10, a7);\n      v27 = sub_4015F0(v26, v11, a9, a2, v12, a7);\n      v28 = sub_4015F0(v27, a2, a9, v9, v10, a7);\n      v29 = sub_4015F0(v28, v11, a9, a2, v12, a7);\n      v30 = sub_4015F0(v29, a2, a9, v9, v10, a7);\n      result = sub_401910(v30, v10, a9, a7);\n      break;\n    case 3u:\n      v31 = sub_401500(a2, a3, a9, a7);\n      sub_4015F0(v31, v11, a9, a2, v12, a7);\n      v15 = sub_401500(v9, v12, a9, a7);\n      v16 = v9;\nLABEL_6:\n      v22 = v12;\n      v23 = v11;\nLABEL_7:\n      result = sub_4015F0(v15, v23, a9, v16, v22, a7);\n      break;\n    default:\n      return result;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x404b30L", 
            "funcEndAddr": "0x404cc6L", 
            "funcName": "sub_404B30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404CD0(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, __m128 a6, __int64 a7, __int64 a8)\n{\n  unsigned int v8; // er12\n  unsigned int v9; // er15\n  unsigned int v10; // ebp\n  __int64 result; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n\n  v8 = a5;\n  v9 = a4;\n  v10 = a3;\n  result = a1;\n  switch ( a1 )\n  {\n    case 0u:\n      goto LABEL_5;\n    case 1u:\n      sub_4015F0(a1, a3, a8, a5, a4, a6);\n      goto LABEL_5;\n    case 2u:\n      v12 = sub_401910(a1, a4, a8, a6);\n      sub_4015F0(v12, v10, a8, v8, v9, a6);\n      v13 = sub_401500(a2, v10, a8, a6);\n      result = sub_401910(v13, v9, a8, a6);\n      break;\n    case 3u:\n      sub_401500(a5, a3, a8, a6);\nLABEL_5:\n      result = sub_401500(a2, v10, a8, a6);\n      break;\n    default:\n      return result;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x404cd0L", 
            "funcEndAddr": "0x404d6eL", 
            "funcName": "sub_404CD0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404D70(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, __m128 a6, __int64 a7, __int64 a8)\n{\n  unsigned int v8; // er14\n  unsigned int v9; // er15\n  unsigned int v10; // er12\n  __int64 result; // rax\n  unsigned int v12; // edi\n  __int64 v13; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n\n  v8 = a5;\n  v9 = a4;\n  v10 = a3;\n  result = a1;\n  switch ( a1 )\n  {\n    case 0u:\n      v12 = a2;\n      goto LABEL_6;\n    case 1u:\n      v13 = sub_401500(a2, a3, a8, a6);\n      result = sub_4015F0(v13, v10, a8, v8, v9, a6);\n      break;\n    case 2u:\n      sub_401910(a1, a4, a8, a6);\n      v14 = sub_401500(a2, v10, a8, a6);\n      v15 = sub_4015F0(v14, v10, a8, v8, v9, a6);\n      result = sub_401910(v15, v9, a8, a6);\n      break;\n    case 3u:\n      sub_401500(a2, a3, a8, a6);\n      v12 = v8;\nLABEL_6:\n      result = sub_401500(v12, v10, a8, a6);\n      break;\n    default:\n      return result;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x404d70L", 
            "funcEndAddr": "0x404e28L", 
            "funcName": "sub_404D70"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404E30(int a1, int a2, signed int a3, __int64 a4, __m128 a5, __int64 a6, __int64 a7)\n{\n  __int64 v7; // rbx\n  signed int v8; // er14\n  unsigned int v9; // er12\n  unsigned int v10; // ebp\n  unsigned int v11; // er13\n  unsigned int v12; // edx\n  int v13; // er15\n  __int64 v15; // [rsp+0h] [rbp-48h]\n  int v16; // [rsp+10h] [rbp-38h]\n  int v17; // [rsp+14h] [rbp-34h]\n\n  v7 = a4;\n  v8 = a3;\n  v9 = a3 - 1;\n  v10 = 2 * a3;\n  v11 = 2 * a3 + 1;\n  if ( a3 >= 2 )\n  {\n    v12 = 0;\n    v17 = a1;\n    v16 = a2;\n    do\n    {\n      v13 = v12 + 1;\n      sub_4049C0(_bittest(&a2, v12) + 2 * _bittest(&a1, v12), v8 + v12, v12, v12 + 1, v10, v11, a5, v15, v7);\n      a1 = v17;\n      a2 = v16;\n      v12 = v13;\n    }\n    while ( v9 != v13 );\n  }\n  return sub_404CD0(_bittest(&a2, v9) + 2 * (unsigned int)_bittest(&a1, v9), v10 - 1, v9, v10, v11, a5, a7, v7);\n}\n", 
            "funcStartAddr": "0x404e30L", 
            "funcEndAddr": "0x404ee6L", 
            "funcName": "sub_404E30"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404EF0(int a1, int a2, signed int a3, __int64 a4, __m128 a5, __int64 a6, __int64 a7)\n{\n  signed int v7; // er15\n  int v8; // ebx\n  int v9; // er14\n  signed int v10; // ebp\n  unsigned int v11; // er13\n  unsigned int v12; // er12\n  __int64 result; // rax\n  unsigned int v14; // ecx\n  unsigned int v15; // edi\n  int v16; // er15\n  int v17; // er14\n  __int64 v18; // [rsp+0h] [rbp-48h]\n  __int64 v19; // [rsp+10h] [rbp-38h]\n\n  v7 = a3;\n  v8 = a2;\n  v9 = a1;\n  v10 = a3 - 1;\n  v11 = 2 * a3;\n  v12 = 2 * a3 + 1;\n  v19 = a4;\n  result = sub_404D70(\n             _bittest(&v8, v10) + 2 * (unsigned int)_bittest(&v9, v10),\n             v10,\n             2 * a3 - 1,\n             2 * a3,\n             v12,\n             a5,\n             a7,\n             a4);\n  if ( v7 >= 2 )\n  {\n    v14 = v11 - 1;\n    do\n    {\n      --v10;\n      v15 = _bittest(&v8, v10) + 2 * _bittest(&v9, v10);\n      v16 = v9;\n      v17 = v14 - 1;\n      result = sub_404B30(v15, v10, v14 - 1, v14, v11, v12, a5, v18, v19);\n      v14 = v17;\n      v9 = v16;\n    }\n    while ( v10 > 0 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x404ef0L", 
            "funcEndAddr": "0x404fa1L", 
            "funcName": "sub_404EF0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_404FB0(int a1, int a2, unsigned int a3, __int64 a4, __m128 a5)\n{\n  signed int v5; // er15\n  int v6; // ebx\n  int v7; // ecx\n  __int64 v8; // r9\n  unsigned int v9; // er13\n  unsigned int v10; // ebp\n  unsigned int v11; // edx\n  int v12; // er14\n  unsigned int v13; // er12\n  __int64 v15; // [rsp+0h] [rbp-58h]\n  __int64 v16; // [rsp+20h] [rbp-38h]\n\n  v5 = a3;\n  v6 = a2;\n  v16 = a4;\n  sub_404780(a1 - a2, a3, a4, a5);\n  v7 = (1 << v5) + a2 - a1;\n  v8 = (unsigned int)(v5 - 1);\n  v9 = 2 * v5;\n  v10 = 2 * v5 + 1;\n  if ( v5 >= 2 )\n  {\n    v11 = 0;\n    do\n    {\n      v12 = v11 + 1;\n      v13 = v8;\n      sub_4049C0(_bittest(&v6, v11) + 2 * _bittest(&v7, v11), v5 + v11, v11, v11 + 1, v9, v10, a5, v15, v16);\n      v7 = (1 << v5) + a2 - a1;\n      v8 = v13;\n      v11 = v12;\n    }\n    while ( v13 != v12 );\n  }\n  return sub_404CD0(_bittest(&v6, v8) + 2 * (unsigned int)_bittest(&v7, v8), v9 - 1, v8, v9, v10, a5, v8, v16);\n}\n", 
            "funcStartAddr": "0x404fb0L", 
            "funcEndAddr": "0x405094L", 
            "funcName": "sub_404FB0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4050A0(int a1, int a2, signed int a3, __int64 a4, __m128 a5)\n{\n  __int64 v5; // rbx\n  signed int v6; // er14\n  int v7; // er12\n  int v8; // ebp\n  signed int v9; // er15\n  __int64 v10; // r9\n  unsigned int v11; // er14\n  int v12; // edx\n  __int64 v14; // [rsp+0h] [rbp-68h]\n  unsigned int v15; // [rsp+1Ch] [rbp-4Ch]\n  unsigned int v16; // [rsp+28h] [rbp-40h]\n  unsigned int v17; // [rsp+30h] [rbp-38h]\n\n  v5 = a4;\n  v6 = a3;\n  v16 = 2 * a3;\n  v15 = 2 * a3 + 1;\n  sub_401500(v15, 2 * a3, a4, a5);\n  v7 = (1 << v6) - a2;\n  v8 = a1 - a2;\n  v9 = v6 - 1;\n  sub_404D70(_bittest(&v8, v9) + 2 * _bittest(&v7, v9), v6 - 1, 2 * v6 - 1, v16, v15, a5, v10, v5);\n  v17 = v6;\n  if ( v6 >= 2 )\n  {\n    v11 = v16 - 2;\n    do\n    {\n      --v9;\n      v12 = a1 - a2;\n      sub_404B30(_bittest(&v12, v9) + 2 * _bittest(&v7, v9), v9, v11, v11 + 1, v16, v15, a5, v14, v5);\n      --v11;\n    }\n    while ( v9 > 0 );\n  }\n  sub_401C40(v17, v5, a5);\n  return sub_404780(a2, v17, v5, a5);\n}\n", 
            "funcStartAddr": "0x4050a0L", 
            "funcEndAddr": "0x4051abL", 
            "funcName": "sub_4050A0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4051B0(int a1, int a2, unsigned int a3, __int64 a4, __m128 a5)\n{\n  __int64 v5; // r14\n  signed int v6; // er15\n\n  v5 = a4;\n  v6 = a3;\n  sub_404FB0(a1, a2, a3, a4, a5);\n  return sub_4050A0(a1, a2, v6, v5, a5);\n}\n", 
            "funcStartAddr": "0x4051b0L", 
            "funcEndAddr": "0x4051dfL", 
            "funcName": "sub_4051B0"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_405310()\n{\n  dword_40C100 = 1;\n  qword_40C118 = 1LL;\n  ptr = malloc(0x10000uLL);\n  if ( !ptr )\n  {\n    puts(\"Error allocating memory for objcode data!\");\n    exit(1);\n  }\n  return sub_404120(0x10000LL);\n}\n", 
            "funcStartAddr": "0x405310L", 
            "funcEndAddr": "0x40535bL", 
            "funcName": "sub_405310"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_4053B0(unsigned __int8 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  signed __int64 v14; // rbx\n  signed __int64 result; // rax\n  unsigned int v16; // ecx\n  unsigned int v17; // edx\n  unsigned int v18; // edx\n  unsigned int v19; // ecx\n  unsigned int v20; // edx\n  unsigned int v21; // edx\n  unsigned int v22; // ecx\n  unsigned int v23; // edx\n  __int64 v24; // rax\n  size_t v25; // rax\n  __int64 v26; // rcx\n  signed __int64 v27; // rbx\n  size_t v28; // rax\n  unsigned __int8 v29; // [rsp+20h] [rbp-108h]\n  char v30; // [rsp+21h] [rbp-107h]\n  char v31; // [rsp+22h] [rbp-106h]\n  char v32; // [rsp+23h] [rbp-105h]\n  char v33; // [rsp+24h] [rbp-104h]\n  unsigned __int64 v34; // [rsp+25h] [rbp-103h]\n  __int64 v35; // [rsp+78h] [rbp-B0h]\n  __int64 v36; // [rsp+80h] [rbp-A8h]\n  __int64 v37; // [rsp+88h] [rbp-A0h]\n  __int64 v38; // [rsp+90h] [rbp-98h]\n  __int64 v39; // [rsp+98h] [rbp-90h]\n  __m128 v40; // [rsp+A0h] [rbp-88h]\n  __m128 v41; // [rsp+B0h] [rbp-78h]\n  __m128 v42; // [rsp+C0h] [rbp-68h]\n  __m128 v43; // [rsp+D0h] [rbp-58h]\n  __m128 v44; // [rsp+E0h] [rbp-48h]\n  __m128 v45; // [rsp+F0h] [rbp-38h]\n  __m128 v46; // [rsp+100h] [rbp-28h]\n  __m128 v47; // [rsp+110h] [rbp-18h]\n\n  v35 = a2;\n  v36 = a3;\n  v37 = a4;\n  v38 = a5;\n  v39 = a6;\n  v40 = a7;\n  v41 = a8;\n  v42 = a9;\n  v43 = a10;\n  v44 = a11;\n  v45 = a12;\n  v46 = a13;\n  v47 = a14;\n  if ( !dword_40C100 )\n    return 0LL;\n  v29 = a1;\n  v14 = 1LL;\n  switch ( a1 + -128 )\n  {\n    case 0:\n    case 127:\n      break;\n    case 1:\n    case 2:\n    case 131:\n    case 132:\n    case 133:\n    case 134:\n    case 142:\n      v30 = ((unsigned int)v35 + ((unsigned int)((signed int)v35 >> 31) >> 8)) >> 24;\n      v31 = ((signed int)v35 % 0x1000000 + ((unsigned int)((signed int)v35 % 0x1000000 >> 31) >> 16)) >> 16;\n      v16 = (signed int)v35 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v35 % 0x1000000 % 0x10000 >> 31) >> 24);\n      v32 = BYTE1(v16);\n      v33 = (signed int)v35 % 0x1000000 % 0x10000;\n      v14 = 5LL;\n      break;\n    case 128:\n      v24 = v35;\n      v30 = HIBYTE(v35);\n      v31 = BYTE6(v35);\n      v32 = BYTE5(v24);\n      v33 = BYTE4(v35);\n      LOBYTE(v34) = BYTE3(v24);\n      BYTE1(v34) = BYTE2(v24);\n      BYTE2(v34) = BYTE1(v24);\n      BYTE3(v34) = v35;\n      goto LABEL_10;\n    case 129:\n    case 140:\n      v30 = ((unsigned int)v35 + ((unsigned int)((signed int)v35 >> 31) >> 8)) >> 24;\n      v31 = ((signed int)v35 % 0x1000000 + ((unsigned int)((signed int)v35 % 0x1000000 >> 31) >> 16)) >> 16;\n      v18 = (signed int)v35 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v35 % 0x1000000 % 0x10000 >> 31) >> 24);\n      v32 = BYTE1(v18);\n      v33 = (signed int)v35 % 0x1000000 % 0x10000;\n      LOBYTE(v34) = ((unsigned int)v36 + ((unsigned int)((signed int)v36 >> 31) >> 8)) >> 24;\n      BYTE1(v34) = ((signed int)v36 % 0x1000000 + ((unsigned int)((signed int)v36 % 0x1000000 >> 31) >> 16)) >> 16;\n      v19 = (signed int)v36 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v36 % 0x1000000 % 0x10000 >> 31) >> 24);\n      BYTE2(v34) = BYTE1(v19);\n      BYTE3(v34) = (signed int)v36 % 0x1000000 % 0x10000;\nLABEL_10:\n      v14 = 9LL;\n      break;\n    case 130:\n      v30 = ((unsigned int)v35 + ((unsigned int)((signed int)v35 >> 31) >> 8)) >> 24;\n      v31 = ((signed int)v35 % 0x1000000 + ((unsigned int)((signed int)v35 % 0x1000000 >> 31) >> 16)) >> 16;\n      v20 = (signed int)v35 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v35 % 0x1000000 % 0x10000 >> 31) >> 24);\n      v32 = BYTE1(v20);\n      v33 = (signed int)v35 % 0x1000000 % 0x10000;\n      LOBYTE(v34) = ((unsigned int)v36 + ((unsigned int)((signed int)v36 >> 31) >> 8)) >> 24;\n      BYTE1(v34) = ((signed int)v36 % 0x1000000 + ((unsigned int)((signed int)v36 % 0x1000000 >> 31) >> 16)) >> 16;\n      v21 = (signed int)v36 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v36 % 0x1000000 % 0x10000 >> 31) >> 24);\n      BYTE2(v34) = BYTE1(v21);\n      BYTE3(v34) = (signed int)v36 % 0x1000000 % 0x10000;\n      BYTE4(v34) = ((unsigned int)v37 + ((unsigned int)((signed int)v37 >> 31) >> 8)) >> 24;\n      BYTE5(v34) = ((signed int)v37 % 0x1000000 + ((unsigned int)((signed int)v37 % 0x1000000 >> 31) >> 16)) >> 16;\n      v22 = (signed int)v37 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v37 % 0x1000000 % 0x10000 >> 31) >> 24);\n      BYTE6(v34) = BYTE1(v22);\n      HIBYTE(v34) = (signed int)v37 % 0x1000000 % 0x10000;\n      v14 = 13LL;\n      break;\n    case 135:\n    case 136:\n    case 137:\n    case 138:\n    case 139:\n      v30 = ((unsigned int)v35 + ((unsigned int)((signed int)v35 >> 31) >> 8)) >> 24;\n      v31 = ((signed int)v35 % 0x1000000 + ((unsigned int)((signed int)v35 % 0x1000000 >> 31) >> 16)) >> 16;\n      v17 = (signed int)v35 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v35 % 0x1000000 % 0x10000 >> 31) >> 24);\n      v32 = BYTE1(v17);\n      v33 = (signed int)v35 % 0x1000000 % 0x10000;\n      v34 = v40.m128_u64[0];\n      v14 = 13LL;\n      break;\n    case 141:\n      v30 = ((unsigned int)v35 + ((unsigned int)((signed int)v35 >> 31) >> 8)) >> 24;\n      v31 = ((signed int)v35 % 0x1000000 + ((unsigned int)((signed int)v35 % 0x1000000 >> 31) >> 16)) >> 16;\n      v23 = (signed int)v35 % 0x1000000 % 0x10000 + ((unsigned int)((signed int)v35 % 0x1000000 % 0x10000 >> 31) >> 24);\n      v32 = BYTE1(v23);\n      v33 = (signed int)v35 % 0x1000000 % 0x10000;\n      LOBYTE(v34) = ((unsigned int)v36 + ((unsigned int)((signed int)v36 >> 31) >> 8)) >> 24;\n      BYTE1(v34) = ((signed int)v36 % 0x1000000 + ((unsigned int)((signed int)v36 % 0x1000000 >> 31) >> 16)) >> 16;\n      BYTE2(v34) = (unsigned __int16)((signed int)v36 % 0x1000000 % 0x10000\n                                    + ((unsigned int)((signed int)v36 % 0x1000000 % 0x10000 >> 31) >> 24)) >> 8;\n      BYTE3(v34) = (signed int)v36 % 0x1000000 % 0x10000;\n      *(unsigned __int64 *)((char *)&v34 + 4) = v40.m128_u64[0];\n      v14 = 17LL;\n      break;\n    default:\n      printf(\"Unknown opcode 0x(%X)!\\n\", a1, 206158430216LL);\n      exit(1);\n      return result;\n  }\n  v25 = size;\n  if ( (size + v14) >> 16 > size >> 16 )\n  {\n    ptr = realloc(ptr, ++qword_40C118 << 16);\n    if ( !ptr )\n    {\n      puts(\"Error reallocating memory for objcode data!\");\n      exit(1);\n    }\n    sub_404120(0x10000LL);\n    v25 = size;\n  }\n  if ( v14 == 1 )\n  {\n    v26 = 0LL;\n  }\n  else\n  {\n    v27 = v14 - 1;\n    v26 = 0LL;\n    do\n    {\n      *((_BYTE *)ptr + v25) = *(&v29 + v26);\n      v28 = size++;\n      *((_BYTE *)ptr + v28 + 1) = *(&v30 + v26);\n      v25 = size++ + 1;\n      v26 += 2LL;\n    }\n    while ( v27 != v26 );\n  }\n  *((_BYTE *)ptr + v25) = *(&v29 + v26);\n  ++size;\n  return 1LL;\n}\n", 
            "funcStartAddr": "0x4053b0L", 
            "funcEndAddr": "0x405a9eL", 
            "funcName": "sub_4053B0"
        }, 
        {
            "decompiledFuncCode": "signed __int64 __fastcall sub_405AA0(const char *a1)\n{\n  FILE *v1; // rax\n  FILE *v2; // rbx\n  signed __int64 result; // rax\n\n  if ( dword_40C100 )\n  {\n    if ( !a1 )\n      a1 = filename;\n    v1 = fopen(a1, \"w\");\n    v2 = v1;\n    if ( v1 )\n    {\n      fwrite(ptr, size, 1uLL, v1);\n      fclose(v2);\n      result = 0LL;\n    }\n    else\n    {\n      result = 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    fwrite(\"Object code generation not active! Forgot to call quantum_objcode_start?\\n\", 0x49uLL, 1uLL, stderr);\n    result = 1LL;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x405aa0L", 
            "funcEndAddr": "0x405b18L", 
            "funcName": "sub_405AA0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_405B20(char *a1)\n{\n  filename = a1;\n}\n", 
            "funcStartAddr": "0x405b20L", 
            "funcEndAddr": "0x405b28L", 
            "funcName": "sub_405B20"
        }, 
        {
            "decompiledFuncCode": "__int64 sub_405B30()\n{\n  FILE *v0; // rax\n  FILE *v1; // rbx\n  __int64 result; // rax\n\n  if ( dword_40C100 )\n  {\n    v0 = fopen(filename, \"w\");\n    v1 = v0;\n    if ( v0 )\n    {\n      fwrite(ptr, size, 1uLL, v0);\n      fclose(v1);\n    }\n  }\n  else\n  {\n    fwrite(\"Object code generation not active! Forgot to call quantum_objcode_start?\\n\", 0x49uLL, 1uLL, stderr);\n  }\n  dword_40C100 = 0;\n  free(ptr);\n  ptr = 0LL;\n  result = sub_404120(-65536 * qword_40C118);\n  qword_40C118 = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x405b30L", 
            "funcEndAddr": "0x405bd4L", 
            "funcName": "sub_405B30"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_405BE0(const char *a1, __int128 *a2)\n{\n  __int128 *v2; // r14\n  unsigned __int64 v3; // rsi\n  FILE *v4; // rax\n  FILE *v5; // r13\n  unsigned int v6; // ebp\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  unsigned __int8 v9; // bl\n  __int64 v10; // r8\n  __int64 v11; // r9\n  unsigned __int32 v12; // edi\n  unsigned int v13; // er12\n  unsigned __int32 v14; // er12\n  float v15; // xmm0_4\n  unsigned __int32 v16; // er12\n  __int128 v17; // xmm0\n  unsigned int v18; // er12\n  unsigned int v19; // ebx\n  __int64 v20; // rax\n  char v21; // r12\n  unsigned __int32 v22; // ebx\n  float v23; // xmm0_4\n  float v24; // xmm0_4\n  float v25; // xmm0_4\n  float v26; // xmm0_4\n  float v27; // xmm0_4\n  __int128 ptr; // [rsp+20h] [rbp-A8h]\n  __int128 v29; // [rsp+30h] [rbp-98h]\n  __int128 v30; // [rsp+40h] [rbp-88h]\n  __int128 v31; // [rsp+50h] [rbp-78h]\n  __int128 v32; // [rsp+60h] [rbp-68h]\n  __int128 v33; // [rsp+78h] [rbp-50h]\n  __int128 v34; // [rsp+88h] [rbp-40h]\n\n  v2 = a2;\n  v3 = (unsigned __int64)\"r\";\n  v4 = fopen(a1, \"r\");\n  v5 = v4;\n  if ( v4 )\n  {\n    if ( feof(v4) )\n    {\nLABEL_3:\n      fclose(v5);\n    }\n    else\n    {\n      v6 = 0;\n      while ( 2 )\n      {\n        v32 = 0LL;\n        v31 = 0LL;\n        v30 = 0LL;\n        v29 = 0LL;\n        ptr = 0LL;\n        v9 = fgetc(v5);\n        switch ( v9 + -128 )\n        {\n          case 0:\n            sub_4042E0(COERCE_DOUBLE(*v2), (__int64)v5, v3, v7, v8, v10, v11, *v2, (unsigned __int128)*v2 >> 64, v2[1]);\n            goto LABEL_30;\n          case 1:\n          case 2:\n          case 131:\n          case 132:\n          case 133:\n          case 134:\n          case 142:\n            v3 = 4LL;\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v12 = _byteswap_ulong(ptr);\n            switch ( v9 )\n            {\n              case 3u:\n                v3 = (unsigned __int64)v2;\n                sub_401910((unsigned __int8)(v9 - 3), v12, (__int64)v2, (__m128)0LL);\n                break;\n              case 4u:\n                v3 = (unsigned __int64)v2;\n                sub_4019E0(v12, (__int64)v2, (__m128)0LL);\n                break;\n              case 5u:\n                v3 = (unsigned __int64)v2;\n                sub_401B30(v12, (__int64)v2, (__m128)0LL);\n                break;\n              case 6u:\n                v3 = (unsigned __int64)v2;\n                sub_403670(v12, (__int64)v2);\n                break;\n              case 7u:\n              case 8u:\n              case 9u:\n              case 0xAu:\n              case 0xBu:\n              case 0xCu:\n              case 0xDu:\n                goto LABEL_30;\n              case 0xEu:\n                v3 = (unsigned __int64)v2;\n                sub_401C40(v12, (__int64)v2, (__m128)0LL);\n                break;\n              default:\n                if ( v9 == -127 )\n                {\n                  v3 = (unsigned __int64)v2;\n                  sub_404370(v12, (__int64)v2, 0.0);\n                }\n                else if ( v9 == -126 )\n                {\n                  v3 = (unsigned __int64)v2;\n                  sub_404470(v12, (int *)v2, 0.0);\n                }\n                break;\n            }\n            goto LABEL_30;\n          case 127:\n            goto LABEL_30;\n          case 128:\n            fread(&ptr, 8uLL, 1uLL, v5);\n            v3 = (BYTE7(ptr) | ((unsigned __int64)BYTE6(ptr) << 8) | ((unsigned __int64)BYTE5(ptr) << 16) | ((unsigned __int64)BYTE4(ptr) << 24) | ((unsigned __int64)BYTE3(ptr) << 32) | ((unsigned __int64)BYTE2(ptr) << 40))\n               + ((unsigned __int64)BYTE1(ptr) << 48)\n               + ((unsigned __int64)(unsigned __int8)ptr << 56);\n            sub_406C90(&v33, v3, 12LL);\n            v17 = v33;\n            v2[1] = v34;\n            *v2 = v17;\n            goto LABEL_30;\n          case 129:\n          case 140:\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v16 = _byteswap_ulong(ptr);\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v3 = _byteswap_ulong(ptr);\n            if ( v9 == 12 )\n            {\n              sub_403D00(v16, v3, (__int64)v2);\n            }\n            else if ( v9 == 1 )\n            {\n              sub_401500(v16, v3, (__int64)v2, (__m128)0LL);\n            }\n            goto LABEL_30;\n          case 130:\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v18 = _byteswap_ulong(ptr);\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v19 = _byteswap_ulong(ptr);\n            v20 = fread(&ptr, 4uLL, 1uLL, v5);\n            v3 = v19;\n            sub_4015F0(v20, _byteswap_ulong(ptr), (__int64)v2, v18, v19, (__m128)0LL);\n            goto LABEL_30;\n          case 135:\n          case 136:\n          case 137:\n          case 138:\n          case 139:\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v13 = ptr;\n            v3 = 8LL;\n            fread(&ptr, 8uLL, 1uLL, v5);\n            v14 = _byteswap_ulong(v13);\n            switch ( v9 )\n            {\n              case 7u:\n                v15 = *(double *)&ptr;\n                v3 = (unsigned __int64)v2;\n                sub_403790(v14, (__int64)v2, v15);\n                break;\n              case 8u:\n                v24 = *(double *)&ptr;\n                v3 = (unsigned __int64)v2;\n                sub_4038B0(v14, (__int64)v2, v24);\n                break;\n              case 9u:\n                v25 = *(double *)&ptr;\n                v3 = (unsigned __int64)v2;\n                sub_4039B0(v14, (__int64)v2, v25);\n                break;\n              case 0xAu:\n                v26 = *(double *)&ptr;\n                v3 = (unsigned __int64)v2;\n                sub_403BE0(v14, (__int64)v2, v26);\n                break;\n              case 0xBu:\n                v27 = *(double *)&ptr;\n                v3 = (unsigned __int64)v2;\n                sub_403AE0(v27, v14, (__int64)v2);\n                break;\n              default:\n                goto LABEL_30;\n            }\n            goto LABEL_30;\n          case 141:\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v21 = _byteswap_ulong(ptr);\n            fread(&ptr, 4uLL, 1uLL, v5);\n            v22 = _byteswap_ulong(ptr);\n            fread(&ptr, 8uLL, 1uLL, v5);\n            v23 = *(double *)&ptr;\n            v3 = v22;\n            sub_403FB0(v21, v22, (__int64)v2, v23);\nLABEL_30:\n            ++v6;\n            if ( feof(v5) )\n              goto LABEL_3;\n            continue;\n          default:\n            fprintf(stderr, \"%i: Unknown opcode 0x(%X)!\\n\", v6, v9);\n            break;\n        }\n        break;\n      }\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"quantum_objcode_run: Could not open %s: \", a1);\n    perror(0LL);\n  }\n}\n", 
            "funcStartAddr": "0x405be0L", 
            "funcEndAddr": "0x406001L", 
            "funcName": "sub_405BE0"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_406010@<rax>(__int64 result@<rax>, int a2@<edx>, __int64 a3@<rcx>, int a4@<edi>, unsigned int a5@<esi>, __m128 a6@<xmm0>)\n{\n  __int64 v6; // r14\n  int v7; // er13\n  unsigned int v8; // er12\n  int v9; // ebx\n  unsigned int v10; // ebp\n\n  v6 = a3;\n  v7 = a4;\n  if ( a2 > 0 )\n  {\n    v8 = 2 * a2 + 2;\n    v9 = a2 + 1;\n    v10 = 2 * a2 - 1;\n    do\n    {\n      result = (unsigned int)(v9 - 2);\n      if ( _bittest(&v7, result) )\n        result = sub_4015F0(result, v10, v6, v8, a5, a6);\n      --v9;\n      --v10;\n    }\n    while ( v9 > 1 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406010L", 
            "funcEndAddr": "0x406073L", 
            "funcName": "sub_406010"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_406080@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, signed int a3@<ecx>, int a4@<edi>, int a5@<esi>, __int64 a6@<r8>, __m128 a7@<xmm0>)\n{\n  __int64 v7; // r15\n  signed int v8; // ebx\n  unsigned int v9; // er14\n  unsigned int v10; // er12\n  int v11; // ecx\n  int v12; // er13\n  int v13; // eax\n  int v14; // ebx\n  unsigned int v15; // er14\n  __int64 v16; // rax\n  int v17; // ebp\n  __int64 result; // rax\n  int v19; // er13\n  signed int v20; // ebp\n  __int64 v21; // rax\n  unsigned int v22; // [rsp+8h] [rbp-50h]\n  unsigned int v23; // [rsp+Ch] [rbp-4Ch]\n  int v24; // [rsp+10h] [rbp-48h]\n  int v25; // [rsp+18h] [rbp-40h]\n  signed int v26; // [rsp+20h] [rbp-38h]\n\n  v7 = a6;\n  v8 = a3;\n  v9 = 2 * a3 + 1;\n  v10 = 2 * a3 + 2;\n  v23 = a2;\n  sub_4015F0(a1, v9, a6, a2, v10, a7);\n  v11 = a4;\n  if ( v8 <= 0 )\n    return sub_4015F0((unsigned int)(a5 / a4), v9, v7, v23, v10, a7);\n  v22 = v9;\n  v13 = 2 * v8;\n  v26 = v8;\n  v14 = v8 + 1;\n  v25 = v13;\n  v15 = v13 - 1;\n  do\n  {\n    v16 = (unsigned int)(v14 - 2);\n    v12 = a5 % a4;\n    if ( _bittest(&v12, v16) )\n    {\n      v17 = v11;\n      v16 = sub_4015F0(v16, v15, v7, v10, v22, a7);\n      v11 = v17;\n    }\n    --v14;\n    --v15;\n  }\n  while ( v14 > 1 );\n  v24 = v11;\n  result = sub_4015F0(v16, v22, v7, v23, v10, a7);\n  if ( v26 >= 2 )\n  {\n    v19 = v25 + 3;\n    v20 = 1;\n    do\n    {\n      sub_4015F0(result, v22, v7, v23, v19 + v20 - 1, a7);\n      v21 = sub_4051B0(v24, (a5 << v20) % v24, v26, v7, a7);\n      result = sub_4015F0(v21, v22, v7, v23, v19 + v20++ - 1, a7);\n    }\n    while ( v26 != v20 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406080L", 
            "funcEndAddr": "0x4061caL", 
            "funcName": "sub_406080"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4061D0(int a1, int a2, unsigned int a3, unsigned int a4, __int64 a5, __m128 a6)\n{\n  __int64 v6; // r13\n  __int64 v7; // rbx\n  unsigned int v8; // er12\n  __int64 v9; // rax\n  signed int v10; // er14\n  unsigned int v11; // er15\n  __int64 v12; // rax\n  __int64 v13; // rax\n  int v14; // er15\n  signed int v15; // ebx\n  unsigned int v16; // ebp\n  unsigned int v18; // [rsp+0h] [rbp-48h]\n  int v19; // [rsp+4h] [rbp-44h]\n  unsigned int v20; // [rsp+Ch] [rbp-3Ch]\n  int v21; // [rsp+10h] [rbp-38h]\n\n  v6 = a5;\n  v7 = a4;\n  v20 = a3;\n  v8 = 2 * a4 + 1;\n  v19 = sub_401000(a1, a2);\n  v9 = (unsigned int)(2 * v7 + 2);\n  v18 = 2 * v7 + 2;\n  v21 = v7;\n  if ( (signed int)v7 >= 2 )\n  {\n    v9 = v7;\n    v10 = v7 + 1;\n    v11 = 3 * v7 + 1;\n    do\n    {\n      sub_4015F0(v9, v8, v6, v20, v11, a6);\n      v12 = sub_4051B0(a1, a1 - (v19 << (v10 - 2)) % a1, v7, v6, a6);\n      v9 = sub_4015F0(v12, v8, v6, v20, v11, a6);\n      --v10;\n      --v11;\n    }\n    while ( v10 > 2 );\n  }\n  sub_4015F0(v9, v8, v6, v20, v18, a6);\n  v13 = (unsigned int)(v19 / a1);\n  if ( (signed int)v7 > 0 )\n  {\n    v15 = v7 + 1;\n    v16 = 2 * v21 - 1;\n    do\n    {\n      v13 = (unsigned int)(v15 - 2);\n      v14 = v19 % a1;\n      if ( _bittest(&v14, v13) )\n        v13 = sub_4015F0(v13, v16, v6, v18, v8, a6);\n      --v15;\n      --v16;\n    }\n    while ( v15 > 1 );\n  }\n  return sub_4015F0(v13, v8, v6, v20, v18, a6);\n}\n", 
            "funcStartAddr": "0x4061d0L", 
            "funcEndAddr": "0x406303L", 
            "funcName": "sub_4061D0"
        }, 
        {
            "decompiledFuncCode": "__int64 __usercall sub_406310@<rax>(__int64 a1@<rax>, unsigned int a2@<edx>, signed int a3@<ecx>, int a4@<edi>, int a5@<esi>, __int64 a6@<r8>, __m128 a7@<xmm0>)\n{\n  __int64 v7; // r14\n  unsigned int v8; // ebp\n  unsigned int v9; // ebx\n  __int64 v10; // rax\n\n  v7 = a6;\n  v8 = a3;\n  v9 = a2;\n  v10 = sub_406080(a1, a2, a3, a4, a5, a6, a7);\n  sub_401F20(v10, v7, v9, v8, a7);\n  return sub_4061D0(a4, a5, v9, v8, v7, a7);\n}\n", 
            "funcStartAddr": "0x406310L", 
            "funcEndAddr": "0x406350L", 
            "funcName": "sub_406310"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406360(_DWORD *a1, _DWORD *a2)\n{\n  __int64 result; // rax\n\n  if ( a1 )\n  {\n    result = (unsigned int)dword_40C120;\n    *a1 = dword_40C120;\n  }\n  if ( a2 )\n  {\n    result = (unsigned int)dword_40C124;\n    *a2 = dword_40C124;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406360L", 
            "funcEndAddr": "0x40637bL", 
            "funcName": "sub_406360"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406380(__int64 a1, signed int a2, int *a3)\n{\n  int *v3; // rbx\n  signed int v4; // er14\n  signed int v5; // ebp\n  __m128 v6; // xmm0\n  int v7; // esi\n  int v8; // esi\n  unsigned int v9; // edi\n  unsigned int v10; // esi\n  __int64 result; // rax\n  float v12; // [rsp+Ch] [rbp-1Ch]\n\n  v3 = a3;\n  v4 = a2;\n  v5 = 0;\n  v12 = sub_4010D0();\n  v6 = 0LL;\n  sub_4010E0(0.0);\n  v7 = *v3;\n  if ( *v3 > 0 )\n  {\n    do\n    {\n      if ( v5 == v7 - 1 )\n      {\n        v6 = (__m128)LODWORD(v12);\n        sub_4010E0(v12);\n        v7 = *v3;\n      }\n      v8 = v5 + v7;\n      if ( v5 >= v4 )\n      {\n        sub_401500(v5, v8, (__int64)v3, v6);\n        v10 = v5 + 2 * *v3;\n        v9 = v5;\n      }\n      else\n      {\n        sub_403670(v8, (__int64)v3);\n        sub_403670(v5 + 2 * *(_BYTE *)v3, (__int64)v3);\n        sub_401500(v5 + *v3, v5, (__int64)v3, v6);\n        v9 = v5 + 2 * *v3;\n        v10 = v5;\n      }\n      sub_401500(v9, v10, (__int64)v3, v6);\n      ++v5;\n      v7 = *v3;\n    }\n    while ( v5 < *v3 );\n  }\n  dword_40C124 = v7;\n  dword_40C120 = 1;\n  result = (unsigned int)(3 * *v3);\n  *v3 = result;\n  return result;\n}\n", 
            "funcStartAddr": "0x406380L", 
            "funcEndAddr": "0x406441L", 
            "funcName": "sub_406380"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406450(__int64 a1, signed int a2, unsigned int *a3)\n{\n  unsigned int *v3; // r12\n  __m128 v4; // xmm0\n  __int64 v5; // r14\n  unsigned int v6; // er15\n  __int64 result; // rax\n  signed int v8; // ebp\n  unsigned int v9; // ebx\n  int v10; // er13\n  int v11; // ebp\n  unsigned int v12; // ebx\n  signed int v13; // er14\n  char v14; // r13\n  int v15; // ebp\n  int v16; // [rsp+4h] [rbp-44h]\n  float v17; // [rsp+Ch] [rbp-3Ch]\n\n  v3 = a3;\n  v17 = sub_4010D0();\n  v4 = 0LL;\n  sub_4010E0(0.0);\n  v5 = (signed int)*v3;\n  v6 = ((unsigned __int64)(1431655766 * v5) >> 63) + ((unsigned __int64)(1431655766 * v5) >> 32);\n  dword_40C120 = 0;\n  dword_40C124 = 0;\n  result = *v3;\n  if ( (signed int)result >= 3 )\n  {\n    v8 = (unsigned int)result / 3;\n    v16 = v6 - 1;\n    do\n    {\n      if ( v8 == 1 )\n      {\n        v4 = (__m128)LODWORD(v17);\n        sub_4010E0(v17);\n      }\n      v9 = v8 - 1;\n      v10 = 2 * v6 - 1 + v8;\n      if ( v8 <= a2 )\n      {\n        sub_401500(v10, v9, (__int64)v3, v4);\n        v11 = v16 + v8;\n        sub_401500(v11, v9, (__int64)v3, v4);\n        sub_403670(v10, (__int64)v3);\n        sub_403670(v11, (__int64)v3);\n      }\n      else\n      {\n        sub_401500(v9, v10, (__int64)v3, v4);\n        sub_401500(v9, v16 + v8, (__int64)v3, v4);\n      }\n      result = v9 + 1;\n      v8 = v9;\n    }\n    while ( (signed int)result > 1 );\n  }\n  if ( (signed int)v5 >= 3 )\n  {\n    v12 = 2 * v6 - 1;\n    v13 = 0;\n    do\n    {\n      v14 = v13++;\n      v15 = sub_404370(v6, (__int64)v3, *(double *)v4.m128_u64);\n      result = sub_404370(v12, (__int64)v3, *(double *)v4.m128_u64);\n      if ( v13 <= a2 && v15 == 1 && (_DWORD)result == 1 )\n        result = sub_401B30(v14, (__int64)v3, v4);\n      --v12;\n    }\n    while ( v6 != v13 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406450L", 
            "funcEndAddr": "0x4065e1L", 
            "funcName": "sub_406450"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4065F0(__int64 a1, int a2, unsigned int *a3)\n{\n  int *v3; // rbx\n  __int64 result; // rax\n\n  v3 = (int *)a3;\n  if ( (signed int)a1 > 0 )\n  {\n    a1 = (unsigned int)(dword_40C128 + a1);\n    goto LABEL_3;\n  }\n  if ( (signed int)a1 < 0 )\n  {\n    a1 = 0LL;\nLABEL_3:\n    dword_40C128 = a1;\n    if ( a2 <= 0 )\n      goto LABEL_8;\nLABEL_7:\n    dword_40C0C8 = a2;\n    goto LABEL_9;\n  }\n  if ( a2 > 0 )\n    goto LABEL_7;\nLABEL_8:\n  a2 = dword_40C0C8;\nLABEL_9:\n  result = (unsigned int)dword_40C128;\n  if ( dword_40C128 >= a2 )\n  {\n    dword_40C128 = 0;\n    sub_406450(a1, dword_40C124, a3);\n    sub_406380(a1, dword_40C124, v3);\n    result = (unsigned int)dword_40C128;\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4065f0L", 
            "funcEndAddr": "0x40665cL", 
            "funcName": "sub_4065F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406660(unsigned int a1, unsigned int *a2)\n{\n  int v2; // ebp\n  float v3; // ST0C_4\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rdi\n  __int64 result; // rax\n\n  v2 = dword_40C120;\n  dword_40C120 = 0;\n  v3 = sub_4010D0();\n  sub_4010E0(0.0);\n  v5 = sub_401910(v4, a1, (__int64)a2, (__m128)0LL);\n  sub_401910(v5, a1 + dword_40C124, (__int64)a2, (__m128)0LL);\n  sub_4010E0(v3);\n  v6 = a1 + 2 * dword_40C124;\n  sub_401910((unsigned int)dword_40C124, v6, (__int64)a2, (__m128)LODWORD(v3));\n  result = (unsigned int)(dword_40C128 + 1);\n  dword_40C128 = result;\n  if ( (signed int)result >= dword_40C0C8 )\n  {\n    dword_40C128 = 0;\n    sub_406450(v6, dword_40C124, a2);\n    result = sub_406380(v6, dword_40C124, (int *)a2);\n  }\n  dword_40C120 = v2;\n  return result;\n}\n", 
            "funcStartAddr": "0x406660L", 
            "funcEndAddr": "0x406714L", 
            "funcName": "sub_406660"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406720(unsigned int a1, unsigned int a2, unsigned int *a3)\n{\n  unsigned int *v3; // r14\n  int v4; // ebp\n  float v5; // ST04_4\n  __int64 v6; // rdi\n  __int64 result; // rax\n\n  v3 = a3;\n  v4 = dword_40C120;\n  dword_40C120 = 0;\n  v5 = sub_4010D0();\n  sub_4010E0(0.0);\n  sub_401500(a1, a2, (__int64)v3, (__m128)0LL);\n  sub_401500(dword_40C124 + a1, a2 + dword_40C124, (__int64)v3, (__m128)0LL);\n  sub_4010E0(v5);\n  v6 = a1 + 2 * dword_40C124;\n  sub_401500(v6, a2 + 2 * dword_40C124, (__int64)v3, (__m128)LODWORD(v5));\n  result = (unsigned int)(dword_40C128 + 1);\n  dword_40C128 = result;\n  if ( (signed int)result >= dword_40C0C8 )\n  {\n    dword_40C128 = 0;\n    sub_406450(v6, dword_40C124, v3);\n    result = sub_406380(v6, dword_40C124, (int *)v3);\n  }\n  dword_40C120 = v4;\n  return result;\n}\n", 
            "funcStartAddr": "0x406720L", 
            "funcEndAddr": "0x4067e3L", 
            "funcName": "sub_406720"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4067F0(char a1, char a2, char a3, __int64 a4, __m128 a5)\n{\n  __int64 v5; // r15\n  signed __int64 v6; // r12\n  signed __int64 v7; // r14\n  signed __int64 v8; // r8\n  signed __int64 v9; // r9\n  signed __int64 v10; // rdi\n  signed __int64 v11; // r13\n  signed __int64 v12; // r11\n  _QWORD *v13; // rcx\n  __int64 v14; // rsi\n  __int64 result; // rax\n  signed int *v16; // [rsp+0h] [rbp-38h]\n\n  v16 = (signed int *)a4;\n  v5 = *(signed int *)(a4 + 4);\n  if ( v5 > 0 )\n  {\n    v6 = 1LL << a1;\n    v7 = 1LL << ((unsigned __int8)dword_40C124 + a1);\n    v8 = 1LL << (2 * (unsigned __int8)dword_40C124 + a1);\n    v9 = 1LL << a2;\n    v10 = 1LL << (a2 + (unsigned __int8)dword_40C124);\n    v11 = 1LL << (a2 + 2 * (unsigned __int8)dword_40C124);\n    v12 = (1LL << (a3 + 2 * (unsigned __int8)dword_40C124))\n        + (1LL << a3)\n        + (1LL << ((unsigned __int8)dword_40C124 + a3));\n    v13 = (_QWORD *)(*(_QWORD *)(a4 + 16) + 8LL);\n    v14 = 0LL;\n    do\n    {\n      if ( ((unsigned __int8)(((v6 & *v13) != 0) ^ ((v7 & *v13) != 0)) ^ ((v8 & *v13) != 0)) == 1\n        && (unsigned __int8)(((v10 & *v13) != 0) ^ ((v9 & *v13) != 0)) ^ ((v11 & *v13) != 0) )\n      {\n        *v13 ^= v12;\n      }\n      ++v14;\n      v13 += 2;\n    }\n    while ( v14 < v5 );\n  }\n  sub_401110(v16, a5);\n  result = (unsigned int)(dword_40C128 + 1);\n  dword_40C128 = result;\n  if ( (signed int)result >= dword_40C0C8 )\n  {\n    dword_40C128 = 0;\n    sub_406450((__int64)v16, dword_40C124, (unsigned int *)v16);\n    result = sub_406380((__int64)v16, dword_40C124, v16);\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4067f0L", 
            "funcEndAddr": "0x406960L", 
            "funcName": "sub_4067F0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406960(int a1, __int64 a2)\n{\n  int v2; // ebp\n  int v3; // ebx\n  __int64 result; // rax\n  bool v5; // zf\n  bool v6; // sf\n\n  if ( a1 > 0 )\n  {\n    v2 = a1 - 1;\n    do\n    {\n      if ( a1 - 1 > v2 )\n      {\n        v3 = a1 - 1;\n        do\n          sub_403D00(v3--, v2, a2);\n        while ( v3 > v2 );\n      }\n      sub_403670(v2, a2);\n      result = (unsigned int)(v2 - 1);\n      v5 = v2 == 0;\n      v6 = v2-- < 0;\n    }\n    while ( !v6 && !v5 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x406960L", 
            "funcEndAddr": "0x4069c1L", 
            "funcName": "sub_406960"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_4069D0(int a1, __int64 a2)\n{\n  int v2; // ebx\n  __int64 result; // rax\n  int v4; // er12\n  int v5; // ebp\n\n  if ( a1 > 0 )\n  {\n    v2 = 0;\n    do\n    {\n      result = sub_403670(v2, a2);\n      v4 = v2 + 1;\n      if ( v2 + 1 < a1 )\n      {\n        v5 = v2 + 1;\n        do\n          result = sub_403E70(v5++, v2, a2);\n        while ( a1 != v5 );\n      }\n      ++v2;\n    }\n    while ( v4 != a1 );\n  }\n  return result;\n}\n", 
            "funcStartAddr": "0x4069d0L", 
            "funcEndAddr": "0x406a35L", 
            "funcName": "sub_4069D0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406A40(__int64 a1, signed int *a2, int a3)\n{\n  int v3; // er15\n  signed int *v4; // rax\n  __int64 v5; // rsi\n  signed __int64 v6; // r8\n  __m128 *v7; // r9\n  signed __int64 v8; // rdx\n  unsigned int v9; // ebp\n  __m128 *v10; // rsi\n  unsigned __int64 v11; // rdi\n  __m128i v12; // xmm2\n  __m128i v13; // xmm0\n  __m128i v14; // xmm0\n  __m128i v15; // xmm1\n  char *v16; // r12\n  signed int v17; // er15\n  void *v18; // r14\n  __int64 v19; // rax\n  __int64 v20; // rcx\n  __int64 v21; // rdx\n  int v22; // esi\n  signed __int64 v23; // rdi\n  __int64 result; // rax\n  const char *v25; // rdi\n  int v26; // [rsp+Ch] [rbp-4Ch]\n  int v27; // [rsp+10h] [rbp-48h]\n  signed int *v28; // [rsp+18h] [rbp-40h]\n  __int64 v29; // [rsp+20h] [rbp-38h]\n\n  v3 = a3;\n  v4 = a2;\n  v5 = (unsigned int)a2[1];\n  if ( (_DWORD)v5 != 1 )\n  {\n    v25 = \"Error! Cannot convert a multi-column-matrix (%i)!\\n\";\nLABEL_22:\n    printf(v25, v5);\n    exit(1);\n  }\n  v6 = *v4;\n  v29 = a1;\n  v28 = v4;\n  if ( v6 <= 0 )\n  {\n    v9 = 0;\n    goto LABEL_10;\n  }\n  v7 = (__m128 *)*((_QWORD *)v4 + 1);\n  if ( (unsigned int)v6 < 8 )\n  {\n    v8 = 0LL;\n    v9 = 0;\n    do\n    {\nLABEL_9:\n      v9 += *(float *)&v7->m128_u64[v8] != 0.0 || *((float *)&v7->m128_u64[v8] + 1) != 0.0;\n      ++v8;\n    }\n    while ( v8 < v6 );\n    goto LABEL_10;\n  }\n  v8 = v6 & 0xFFFFFFFFFFFFFFF8LL;\n  v10 = v7 + 2;\n  v11 = v6 & 0xFFFFFFFFFFFFFFF8LL;\n  v12 = 0LL;\n  v13 = 0LL;\n  do\n  {\n    v12 = _mm_sub_epi32(\n            v12,\n            (__m128i)_mm_or_ps(\n                       _mm_cmpneqps(_mm_shuffle_ps(v10[-2], v10[-1], 221), (__m128)0LL),\n                       _mm_cmpneqps(_mm_shuffle_ps(v10[-2], v10[-1], 136), (__m128)0LL)));\n    v13 = _mm_sub_epi32(\n            v13,\n            (__m128i)_mm_or_ps(\n                       _mm_cmpneqps(_mm_shuffle_ps(*v10, v10[1], 221), (__m128)0LL),\n                       _mm_cmpneqps(_mm_shuffle_ps(*v10, v10[1], 136), (__m128)0LL)));\n    v10 += 4;\n    v11 -= 8LL;\n  }\n  while ( v11 );\n  v14 = _mm_add_epi32(v13, v12);\n  v15 = _mm_add_epi32(_mm_shuffle_epi32(v14, 78), v14);\n  v9 = _mm_cvtsi128_si32(_mm_add_epi32(_mm_shuffle_epi32(v15, 229), v15));\n  if ( v8 != v6 )\n    goto LABEL_9;\nLABEL_10:\n  v16 = (char *)calloc(v9, 0x10uLL);\n  if ( !v16 )\n  {\n    v25 = \"Not enough memory for %i-sized qubit!\\n\";\n    v5 = v9;\n    goto LABEL_22;\n  }\n  v27 = v3;\n  sub_404120(16LL * v9);\n  v26 = v3 + 2;\n  v17 = 1 << (v3 + 2);\n  v18 = calloc(v17, 4uLL);\n  if ( !v18 )\n  {\n    v25 = \"Not enough memory for %i-sized hash!\\n\";\n    v5 = (unsigned int)v17;\n    goto LABEL_22;\n  }\n  sub_404120(4LL * v17);\n  v19 = *v28;\n  if ( v19 > 0 )\n  {\n    v20 = *((_QWORD *)v28 + 1);\n    v21 = 0LL;\n    v22 = 0;\n    do\n    {\n      if ( COERCE_FLOAT(_mm_cvtsi32_si128(*(_DWORD *)(v20 + 8 * v21))) != 0.0\n        || COERCE_FLOAT(_mm_cvtsi32_si128(*(_DWORD *)(v20 + 8 * v21 + 4))) != 0.0 )\n      {\n        v23 = 16LL * v22;\n        *(_QWORD *)&v16[v23 + 8] = v21;\n        *(_QWORD *)&v16[v23] = *(_QWORD *)(v20 + 8 * v21);\n        ++v22;\n      }\n      ++v21;\n    }\n    while ( v21 < v19 );\n  }\n  result = v29;\n  *(_DWORD *)v29 = v27;\n  *(_DWORD *)(v29 + 4) = v9;\n  *(_DWORD *)(v29 + 8) = v26;\n  *(_QWORD *)(v29 + 16) = v16;\n  *(_QWORD *)(v29 + 24) = v18;\n  return result;\n}\n", 
            "funcStartAddr": "0x406a40L", 
            "funcEndAddr": "0x406c82L", 
            "funcName": "sub_406A40"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406C90(__int64 a1, __int64 a2, int a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, double a8, double a9, __m128 a10, __m128 a11)\n{\n  int v11; // ebp\n  _QWORD *v12; // r12\n  signed int v13; // er14\n  void *v14; // r13\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  char *v17; // rbp\n  __int64 v18; // r8\n  __int64 v19; // r9\n  __m128 v20; // xmm4\n  __m128 v21; // xmm5\n  const char *v23; // rdi\n  signed __int64 v24; // rsi\n  int v25; // [rsp+4h] [rbp-44h]\n  int v26; // [rsp+10h] [rbp-38h]\n\n  v11 = a3;\n  v12 = calloc(1uLL, 0x10uLL);\n  if ( !v12 )\n  {\n    v23 = \"Not enough memory for %i-sized qubit!\\n\";\n    v24 = 1LL;\nLABEL_8:\n    printf(v23, v24);\n    exit(1);\n  }\n  v26 = v11;\n  sub_404120(16LL);\n  v25 = v11 + 2;\n  v13 = 1 << (v11 + 2);\n  v14 = calloc(v13, 4uLL);\n  if ( !v14 )\n  {\n    v23 = \"Not enough memory for %i-sized hash!\\n\";\n    v24 = (unsigned int)v13;\n    goto LABEL_8;\n  }\n  sub_404120(4LL * v13);\n  v12[1] = a2;\n  *v12 = 1065353216LL;\n  v17 = getenv(\"QUOBFILE\");\n  if ( v17 )\n  {\n    sub_405310();\n    sub_405B20(v17);\n    sub_408800(sub_405B30, 4LL);\n  }\n  sub_4053B0(0, a2, v15, v16, v18, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n  *(_DWORD *)a1 = v26;\n  *(_DWORD *)(a1 + 4) = 1;\n  *(_DWORD *)(a1 + 8) = v25;\n  *(_QWORD *)(a1 + 16) = v12;\n  *(_QWORD *)(a1 + 24) = v14;\n  return a1;\n}\n", 
            "funcStartAddr": "0x406c90L", 
            "funcEndAddr": "0x406daeL", 
            "funcName": "sub_406C90"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406E10(__int64 a1)\n{\n  __int64 result; // rax\n\n  free(*(void **)(a1 + 24));\n  result = sub_404120(4LL * (-1 << *(_BYTE *)(a1 + 8)));\n  *(_QWORD *)(a1 + 24) = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x406e10L", 
            "funcEndAddr": "0x406e3dL", 
            "funcName": "sub_406E10"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406E40(__int64 a1)\n{\n  __int64 result; // rax\n\n  free(*(void **)(a1 + 24));\n  sub_404120(4LL * (-1 << *(_BYTE *)(a1 + 8)));\n  *(_QWORD *)(a1 + 24) = 0LL;\n  free(*(void **)(a1 + 16));\n  result = sub_404120(-16LL * *(signed int *)(a1 + 4));\n  *(_QWORD *)(a1 + 16) = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x406e40L", 
            "funcEndAddr": "0x406e8eL", 
            "funcName": "sub_406E40"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_406E90(__int64 a1)\n{\n  __int64 result; // rax\n\n  free(*(void **)(a1 + 16));\n  result = sub_404120(-16LL * *(signed int *)(a1 + 4));\n  *(_QWORD *)(a1 + 16) = 0LL;\n  return result;\n}\n", 
            "funcStartAddr": "0x406e90L", 
            "funcEndAddr": "0x406eb7L", 
            "funcName": "sub_406E90"
        }, 
        {
            "decompiledFuncCode": "int __fastcall sub_406EC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)\n{\n  signed __int64 v9; // r15\n  __m128 v10; // xmm2\n  double v11; // xmm0_8\n  double v12; // xmm1_8\n  __m128 v13; // xmm2\n  unsigned __int64 v14; // r12\n  signed __int64 v15; // r14\n  __int64 v16; // rax\n\n  if ( SHIDWORD(a7) > 0LL )\n  {\n    v9 = 0LL;\n    do\n    {\n      v10 = (__m128)_mm_loadl_epi64((const __m128i *)(a9 + 16 * v9));\n      v11 = v10.m128_f32[0];\n      v12 = COERCE_FLOAT(_mm_shuffle_epi32((__m128i)v10, 229));\n      v13 = _mm_mul_ps(v10, v10);\n      printf(\n        \"% f %+fi|%lli> (%e) (|\",\n        *(_QWORD *)(a9 + 16 * v9 + 8),\n        v11,\n        v12,\n        (float)(COERCE_FLOAT(_mm_shuffle_ps(v13, v13, 229)) + v13.m128_f32[0]));\n      if ( (signed int)a7 > 0 )\n      {\n        v14 = (unsigned int)(a7 - 1);\n        v15 = (unsigned int)a7 + 1LL;\n        do\n        {\n          if ( (signed int)v14 % 4 == 3 )\n            putchar(32);\n          v16 = *(_QWORD *)(a9 + 16 * v9 + 8);\n          printf(\"%i\", _bittest64(&v16, v14));\n          --v15;\n          v14 = (unsigned int)(v14 - 1);\n        }\n        while ( v15 > 1 );\n      }\n      puts(\">)\");\n      ++v9;\n    }\n    while ( v9 < SHIDWORD(a7) );\n  }\n  return putchar(10);\n}\n", 
            "funcStartAddr": "0x406ec0L", 
            "funcEndAddr": "0x406fecL", 
            "funcName": "sub_406EC0"
        }, 
        {
            "decompiledFuncCode": "int __usercall sub_406FF0@<eax>(__int64 a1@<rax>, __int64 a2, __int64 a3, __int64 a4)\n{\n  int v4; // er15\n  _QWORD *v5; // rbp\n  signed __int64 v6; // rbx\n  __int64 v8; // [rsp-8h] [rbp-28h]\n\n  v8 = a1;\n  if ( SHIDWORD(a2) > 0LL )\n  {\n    v4 = (signed int)a2 / 2;\n    v5 = (_QWORD *)(a4 + 8);\n    v6 = 0LL;\n    do\n    {\n      LODWORD(a1) = printf(\"%i: %lli\\n\", (unsigned int)v6, *v5 - (signed int)((_DWORD)v6 << v4), v8);\n      ++v6;\n      v5 += 2;\n    }\n    while ( v6 < SHIDWORD(a2) );\n  }\n  return a1;\n}\n", 
            "funcStartAddr": "0x406ff0L", 
            "funcEndAddr": "0x407056L", 
            "funcName": "sub_406FF0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_407060(int a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // r8\n  char v4; // cl\n  __int64 v5; // rax\n  __int64 v6; // rdi\n  __int64 v7; // rdx\n  _QWORD *v8; // rsi\n  _QWORD *v9; // rdx\n  __int64 v10; // rax\n\n  *(_DWORD *)a2 += a1;\n  v2 = *(signed int *)(a2 + 4);\n  if ( v2 > 0 )\n  {\n    v3 = *(_QWORD *)(a2 + 16);\n    v4 = a1;\n    v5 = v2 & 3;\n    if ( (unsigned __int64)(v2 - 1) < 3 )\n    {\n      v6 = 0LL;\n      if ( !(v2 & 3) )\n        return;\n      goto LABEL_8;\n    }\n    v7 = v2 - v5;\n    v8 = (_QWORD *)(v3 + 56);\n    v6 = 0LL;\n    do\n    {\n      *(v8 - 6) <<= v4;\n      *(v8 - 4) <<= v4;\n      *(v8 - 2) <<= v4;\n      *v8 <<= v4;\n      v6 += 4LL;\n      v8 += 8;\n    }\n    while ( v7 != v6 );\n    if ( v5 )\n    {\nLABEL_8:\n      v9 = (_QWORD *)(v3 + 16 * v6 + 8);\n      v10 = -v5;\n      do\n      {\n        *v9 <<= v4;\n        v9 += 2;\n        ++v10;\n      }\n      while ( v10 );\n      return;\n    }\n  }\n}\n", 
            "funcStartAddr": "0x407060L", 
            "funcEndAddr": "0x4070deL", 
            "funcName": "sub_407060"
        }, 
        {
            "decompiledFuncCode": "int __usercall sub_4070E0@<eax>(char *a1@<rax>, char a2, int a3, __int64 a4, __int64 a5)\n{\n  __int64 v5; // r14\n  __int64 v6; // r15\n  __int64 v7; // r12\n  __int64 v8; // rbx\n  char *v10; // [rsp-8h] [rbp-28h]\n\n  v10 = a1;\n  if ( a3 != 31 )\n  {\n    a1 = &a2;\n    v5 = a4;\n    v6 = a5;\n    v7 = 1 << a3;\n    v8 = 0LL;\n    do\n    {\n      if ( v8 )\n        LODWORD(a1) = printf(\n                        \"%i: %i %llu\\n\",\n                        (unsigned int)v8,\n                        *(signed int *)(v6 + 4 * v8) - 1LL,\n                        *(_QWORD *)(v5 + 16 * (*(signed int *)(v6 + 4 * v8) - 1LL) + 8),\n                        v10);\n      ++v8;\n    }\n    while ( v8 < v7 );\n  }\n  return (signed int)a1;\n}\n", 
            "funcStartAddr": "0x4070e0L", 
            "funcEndAddr": "0x40714cL", 
            "funcName": "sub_4070E0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_407150(__int64 a1, __int64 a2, _DWORD *a3)\n{\n  _DWORD *v3; // r13\n  size_t v4; // rbx\n  _QWORD *v5; // r15\n  signed int v6; // ebx\n  int v7; // ecx\n  int v8; // er8\n  signed __int64 v9; // r14\n  signed __int64 v10; // r12\n  signed __int64 v11; // rbp\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  __m128 v14; // xmm2\n  __m128 v15; // xmm0\n  __m128 v16; // xmm3\n  signed __int64 v17; // rbx\n  const char *v19; // rdi\n  __int64 v20; // rsi\n  __int64 v21; // [rsp+0h] [rbp-58h]\n  void *v22; // [rsp+10h] [rbp-48h]\n  int v23; // [rsp+20h] [rbp-38h]\n\n  v3 = a3;\n  HIDWORD(v21) = *(_DWORD *)a2 + *a3;\n  v4 = (signed int)a3[1] * (signed __int64)*(signed int *)(a2 + 4);\n  v5 = calloc(v4, 0x10uLL);\n  if ( !v5 )\n  {\n    v19 = \"Not enough memory for %i-sized qubit!\\n\";\n    v20 = (unsigned int)v4;\nLABEL_13:\n    printf(v19, v20, v21);\n    exit(1);\n  }\n  v23 = v4;\n  sub_404120(16 * v4);\n  LODWORD(v21) = v4 + 2;\n  v6 = 1 << (v4 + 2);\n  v22 = calloc(v6, 4uLL);\n  if ( !v22 )\n  {\n    v19 = \"Not enough memory for %i-sized hash!\\n\";\n    v20 = (unsigned int)v6;\n    goto LABEL_13;\n  }\n  sub_404120(4LL * v6);\n  v7 = *(_DWORD *)(a2 + 4);\n  if ( v7 > 0 )\n  {\n    v8 = v3[1];\n    v9 = 0LL;\n    do\n    {\n      if ( v8 > 0 )\n      {\n        v10 = 8LL;\n        v11 = 0LL;\n        do\n        {\n          v12 = *(_QWORD *)(a2 + 16);\n          v13 = *((_QWORD *)v3 + 2);\n          v5[2 * ((signed int)v11 + v8 * (signed int)v9) + 1] = *(_QWORD *)(v13 + v10) | (*(_QWORD *)(v12 + 16 * v9 + 8) << *(_BYTE *)v3);\n          v14 = (__m128)*(unsigned __int64 *)(v13 + v10 - 8);\n          v15 = _mm_mul_ps((__m128)*(unsigned __int64 *)(v12 + 16 * v9), v14);\n          v16 = _mm_mul_ps((__m128)_mm_shuffle_epi32((__m128i)*(unsigned __int64 *)(v12 + 16 * v9), 225), v14);\n          v17 = 2LL * ((signed int)v11 + v8 * (signed int)v9);\n          *(float *)&v5[v17] = v15.m128_f32[0] - COERCE_FLOAT(_mm_shuffle_ps(v15, v15, 229));\n          *((float *)&v5[v17] + 1) = COERCE_FLOAT(_mm_shuffle_ps(v16, v16, 229)) + v16.m128_f32[0];\n          ++v11;\n          v10 += 16LL;\n        }\n        while ( v11 < v8 );\n        v7 = *(_DWORD *)(a2 + 4);\n      }\n      ++v9;\n    }\n    while ( v9 < v7 );\n  }\n  *(_DWORD *)a1 = HIDWORD(v21);\n  *(_DWORD *)(a1 + 4) = v23;\n  *(_DWORD *)(a1 + 8) = v21;\n  *(_QWORD *)(a1 + 16) = v5;\n  *(_QWORD *)(a1 + 24) = v22;\n  return a1;\n}\n", 
            "funcStartAddr": "0x407150L", 
            "funcEndAddr": "0x40735aL", 
            "funcName": "sub_407150"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_407360(__int64 a1, signed int a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, int a8, __int64 a9, __int64 a10)\n{\n  unsigned int v10; // er14\n  float *v11; // rax\n  double v12; // xmm2_8\n  signed __int64 v13; // rcx\n  int v14; // ebp\n  int v15; // er12\n  __int64 v16; // rbx\n  char *v17; // rbp\n  signed int v18; // er10\n  signed __int64 v19; // r11\n  int v20; // edx\n  double v21; // xmm8_8\n  __int64 v22; // rsi\n  __int64 v23; // r13\n  __m128i v24; // xmm7\n  __m128i v25; // xmm9\n  __m128i v26; // xmm10\n  __m128i v27; // xmm11\n  __m128i v28; // xmm12\n  double v29; // xmm14_8\n  int v30; // er14\n  __m128i v31; // xmm0\n  __m128i v32; // xmm1\n  __m128i v33; // xmm2\n  signed __int64 v34; // r9\n  __int64 v35; // r8\n  __int64 v36; // rcx\n  __int64 v37; // rdi\n  unsigned __int64 v38; // rax\n  __m128i v39; // xmm6\n  __m128i v40; // xmm4\n  double v41; // xmm3_8\n  __m128i v42; // xmm6\n  __m128i v43; // xmm4\n  __m128i v44; // xmm1\n  double v45; // xmm3_8\n  __m128i v46; // xmm4\n  __m128i v47; // xmm1\n  __m128i v48; // xmm2\n  double v49; // xmm3_8\n  __m128i v50; // xmm2\n  __m128i v51; // xmm3\n  __m128i v52; // xmm5\n  __m128i v53; // xmm4\n  __m128i v54; // xmm1\n  __int64 v55; // rdi\n  signed int v56; // eax\n  unsigned __int64 v57; // rbp\n  int v58; // esi\n  int v59; // er15\n  signed __int64 v60; // r14\n  float v61; // xmm3_4\n  float v62; // xmm4_4\n  double v63; // xmm0_8\n  float v64; // ST90_4\n  float v65; // xmm0_4\n  __int64 result; // rax\n  int v67; // [rsp+8h] [rbp-E0h]\n  unsigned int v68; // [rsp+Ch] [rbp-DCh]\n  double x; // [rsp+10h] [rbp-D8h]\n  signed __int64 v70; // [rsp+18h] [rbp-D0h]\n  signed int v71; // [rsp+20h] [rbp-C8h]\n  int v72; // [rsp+28h] [rbp-C0h]\n  double v73; // [rsp+38h] [rbp-B0h]\n  __int64 v74; // [rsp+40h] [rbp-A8h]\n  __int64 v75; // [rsp+48h] [rbp-A0h]\n  __int64 v76; // [rsp+50h] [rbp-98h]\n  __int64 v77; // [rsp+70h] [rbp-78h]\n  __int64 v78; // [rsp+80h] [rbp-68h]\n  char *v79; // [rsp+88h] [rbp-60h]\n\n  v67 = a3;\n  v10 = HIDWORD(a7);\n  v76 = a1;\n  if ( SHIDWORD(a7) <= 0LL )\n  {\n    v14 = 0;\n    v12 = 0.0;\n  }\n  else\n  {\n    v11 = (float *)(a9 + 8);\n    v12 = 0.0;\n    v13 = 0LL;\n    v14 = 0;\n    do\n    {\n      if ( (a3 != 0) == (((1LL << a2) & *(_QWORD *)v11) != 0) )\n      {\n        v12 = v12 + (float)((float)(*(v11 - 1) * *(v11 - 1)) + (float)(*(v11 - 2) * *(v11 - 2)));\n        ++v14;\n      }\n      ++v13;\n      v11 += 4;\n    }\n    while ( v13 < SHIDWORD(a7) );\n  }\n  x = v12;\n  v70 = 1LL << a2;\n  v71 = a2;\n  v15 = a7;\n  v68 = v14;\n  v16 = v14;\n  v17 = (char *)calloc(v14, 0x10uLL);\n  if ( !v17 )\n  {\n    printf(\"Not enough memory for %i-sized quantum register!\\n\", v68);\n    exit(1);\n  }\n  sub_404120(16 * v16);\n  v72 = a8;\n  v75 = a10;\n  v18 = a2;\n  v19 = 1LL << a2;\n  v20 = v67;\n  v21 = v12;\n  if ( (signed int)v10 > 0 )\n  {\n    v22 = v10;\n    v74 = a9;\n    v77 = v71 & 0xFFFFFFFC;\n    v23 = 0LL;\n    v24 = _mm_load_si128((const __m128i *)&xmmword_4088F0);\n    v25 = _mm_load_si128((const __m128i *)&xmmword_4088A0);\n    v26 = _mm_load_si128((const __m128i *)&xmmword_408900);\n    v27 = _mm_load_si128((const __m128i *)&xmmword_408910);\n    v28 = _mm_load_si128((const __m128i *)&xmmword_408920);\n    v29 = sqrt(v12);\n    v30 = 0;\n    v79 = v17;\n    v78 = v22;\n    v73 = v29;\n    while ( 1 )\n    {\n      v34 = 16 * v23;\n      v35 = *(_QWORD *)(v74 + 16 * v23 + 8);\n      if ( (v20 != 0) == ((v19 & v35) != 0) )\n        break;\nLABEL_38:\n      if ( ++v23 == v22 )\n        goto LABEL_39;\n    }\n    if ( v18 <= 0 )\n    {\n      v37 = 0LL;\n      goto LABEL_25;\n    }\n    if ( (unsigned int)v18 < 4 )\n    {\n      v36 = 0LL;\n      v37 = 0LL;\n      do\nLABEL_24:\n        v37 += 1LL << v36++;\n      while ( v71 != v36 );\nLABEL_25:\n      v55 = v35 & v37;\n      if ( v18 <= 62 )\n      {\n        if ( (unsigned int)(62 - v71) >= 7 )\n        {\n          v56 = 63;\n          v57 = 0LL;\n          do\n          {\n            v57 += (1LL << v56)\n                 + (1LL << ((unsigned __int8)v56 - 1))\n                 + (1LL << ((unsigned __int8)v56 - 2))\n                 + (1LL << ((unsigned __int8)v56 - 3))\n                 + (1LL << ((unsigned __int8)v56 - 4))\n                 + (1LL << ((unsigned __int8)v56 - 5))\n                 + (1LL << ((unsigned __int8)v56 - 6))\n                 + (1LL << ((unsigned __int8)v56 - 7));\n            v56 -= 8;\n          }\n          while ( v71 + ((63 - (_BYTE)v71) & 7) != v56 );\n          if ( !((63 - (_BYTE)v71) & 7) )\n            goto LABEL_35;\n        }\n        else\n        {\n          v56 = 63;\n          v57 = 0LL;\n          if ( !((63 - (_BYTE)v71) & 7) )\n            goto LABEL_35;\n        }\n        v58 = -((63 - (_BYTE)v71) & 7);\n        do\n        {\n          v57 += 1LL << v56--;\n          ++v58;\n        }\n        while ( v58 );\n        goto LABEL_35;\n      }\n      v57 = 0LL;\nLABEL_35:\n      v59 = v30;\n      v60 = 16LL * v30;\n      *(_QWORD *)&v79[v60 + 8] = v55 | ((v35 & v57) >> 1);\n      v17 = v79;\n      v61 = *(float *)(v74 + v34) - (float)(*(float *)(v74 + v34 + 4) * 0.0);\n      v62 = (float)(*(float *)(v74 + v34) * 0.0) + *(float *)(v74 + v34 + 4);\n      v20 = v67;\n      v63 = v29;\n      if ( v21 < 0.0 )\n      {\n        v64 = (float)(*(float *)(v74 + v34) * 0.0) + *(float *)(v74 + v34 + 4);\n        v63 = sqrt(v21);\n        v62 = v64;\n        v29 = v73;\n        v28 = _mm_load_si128((const __m128i *)&xmmword_408920);\n        v27 = _mm_load_si128((const __m128i *)&xmmword_408910);\n        v26 = _mm_load_si128((const __m128i *)&xmmword_408900);\n        v25 = _mm_load_si128((const __m128i *)&xmmword_4088A0);\n        v24 = _mm_load_si128((const __m128i *)&xmmword_4088F0);\n        v21 = x;\n        v20 = v67;\n        v19 = v70;\n        v18 = v71;\n      }\n      v65 = v63;\n      *(float *)&v79[v60] = v61 / v65;\n      *(float *)&v79[v60 + 4] = v62 / v65;\n      v30 = v59 + 1;\n      v22 = v78;\n      goto LABEL_38;\n    }\n    if ( v77 == 4 )\n    {\n      v31 = _mm_slli_si128((__m128i)1uLL, 8);\n      v32 = 0LL;\n      v33 = 0LL;\n    }\n    else\n    {\n      v31 = _mm_slli_si128((__m128i)1uLL, 8);\n      v32 = 0LL;\n      v38 = (((unsigned __int8)((unsigned __int64)(v77 - 4) >> 2) + 1) & 1) - 1LL - ((unsigned __int64)(v77 - 4) >> 2);\n      v33 = 0LL;\n      do\n      {\n        v39 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v31, 78));\n        v40 = _mm_add_epi64(v31, v24);\n        *(double *)v39.m128i_i64 = COERCE_DOUBLE(v25.m128i_i64[0] << v31.m128i_i8[0]);\n        *(_QWORD *)&v41 = v25.m128i_i64[0] << v40.m128i_i8[0];\n        v42 = _mm_add_epi64(v39, v32);\n        v43 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v40, 78));\n        *(double *)v43.m128i_i64 = v41;\n        v44 = _mm_add_epi64(v31, v26);\n        *(_QWORD *)&v45 = v25.m128i_i64[0] << v44.m128i_i8[0];\n        v46 = _mm_add_epi64(v43, v33);\n        v47 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v44, 78));\n        v48 = _mm_add_epi64(v31, v27);\n        *(double *)v47.m128i_i64 = v45;\n        *(_QWORD *)&v49 = v25.m128i_i64[0] << v48.m128i_i8[0];\n        v32 = _mm_add_epi64(v47, v42);\n        v50 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v48, 78));\n        *(double *)v50.m128i_i64 = v49;\n        v33 = _mm_add_epi64(v50, v46);\n        v31 = _mm_add_epi64(v31, v28);\n        v38 += 2LL;\n      }\n      while ( v38 );\n      if ( !(((unsigned __int8)((unsigned __int64)(v77 - 4) >> 2) + 1) & 1) )\n      {\nLABEL_23:\n        v54 = _mm_add_epi64(v32, v33);\n        v37 = (unsigned __int128)_mm_add_epi64(_mm_shuffle_epi32(v54, 78), v54);\n        v36 = v71 & 0xFFFFFFFC;\n        if ( v77 == v71 )\n          goto LABEL_25;\n        goto LABEL_24;\n      }\n    }\n    v51 = _mm_add_epi64(v31, v24);\n    v52 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v51, 78));\n    *(double *)v52.m128i_i64 = COERCE_DOUBLE(v25.m128i_i64[0] << v51.m128i_i8[0]);\n    v33 = _mm_add_epi64(v33, v52);\n    v53 = _mm_sll_epi64(v25, _mm_shuffle_epi32(v31, 78));\n    *(double *)v53.m128i_i64 = COERCE_DOUBLE(v25.m128i_i64[0] << v31.m128i_i8[0]);\n    v32 = _mm_add_epi64(v32, v53);\n    goto LABEL_23;\n  }\nLABEL_39:\n  result = v76;\n  *(_DWORD *)v76 = v15 - 1;\n  *(_DWORD *)(v76 + 4) = v68;\n  *(_DWORD *)(v76 + 8) = v72;\n  *(_QWORD *)(v76 + 16) = v17;\n  *(_QWORD *)(v76 + 24) = v75;\n  return result;\n}\n", 
            "funcStartAddr": "0x407360L", 
            "funcEndAddr": "0x4079c2L", 
            "funcName": "sub_407360"
        }, 
        {
            "decompiledFuncCode": "__m128 __fastcall sub_4079D0(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r15\n  __int64 v3; // r14\n  int v4; // eax\n  __int64 v5; // rdx\n  signed __int64 v6; // rsi\n  __int64 v7; // r8\n  __int64 v8; // rsi\n  signed __int64 v9; // rbx\n  signed int v10; // edx\n  _DWORD *v11; // rax\n  int v12; // er8\n  __m128 v13; // xmm0\n  signed __int64 v14; // r13\n  __m128 v15; // xmm1\n  __int64 v16; // r9\n  __int64 v17; // rdx\n  int v18; // er11\n  signed int v19; // esi\n  __int64 v20; // rbx\n  int v21; // eax\n  signed __int64 v22; // r14\n  __m128 v23; // ST10_16\n  __m128 v24; // ST20_16\n  __m128 v25; // xmm0\n  float v26; // xmm4_4\n  float v27; // xmm1_4\n  __int64 v28; // rax\n  float v29; // xmm2_4\n  float v30; // xmm3_4\n  float v31; // xmm5_4\n  __m128 v32; // xmm1\n\n  v2 = a2;\n  v3 = a1;\n  LOBYTE(v4) = 31;\n  if ( *(_DWORD *)(a2 + 8) != 31 )\n  {\n    v5 = *(_QWORD *)(a2 + 24);\n    v6 = 0LL;\n    do\n    {\n      *(_DWORD *)(v5 + 4 * v6) = 0;\n      v4 = *(_DWORD *)(v2 + 8);\n      ++v6;\n    }\n    while ( v6 < 1 << *(_DWORD *)(v2 + 8) );\n  }\n  if ( *(_DWORD *)(v2 + 4) > 0 )\n  {\n    v7 = *(_QWORD *)(v2 + 16);\n    v8 = *(_QWORD *)(v2 + 24);\n    v9 = 0LL;\n    while ( 1 )\n    {\n      v10 = -1640562687\n          * ((unsigned int)*(_QWORD *)(v7 + 16 * v9 + 8) ^ (unsigned int)(*(_QWORD *)(v7 + 16 * v9 + 8) >> 32)) >> (32 - v4);\n      if ( *(_DWORD *)(v8 + 4LL * v10) )\n      {\n        do\n        {\n          if ( ++v10 == 1 << v4 )\n            v10 = 0;\n        }\n        while ( *(_DWORD *)(v8 + 4LL * v10) );\n        v11 = (_DWORD *)(v8 + 4LL * v10);\n      }\n      else\n      {\n        v11 = (_DWORD *)(v8 + 4LL * v10);\n      }\n      *v11 = ++v9;\n      if ( v9 >= *(signed int *)(v2 + 4) )\n        break;\n      v4 = *(_DWORD *)(v2 + 8);\n    }\n  }\n  v12 = *(_DWORD *)(a1 + 4);\n  if ( v12 <= 0 )\n  {\n    v15 = 0LL;\n    v13 = 0LL;\n  }\n  else\n  {\n    v13 = 0LL;\n    v14 = 0LL;\n    v15 = 0LL;\n    do\n    {\n      v16 = *(_QWORD *)(v3 + 16);\n      v17 = *(_QWORD *)(v16 + 16 * v14 + 8);\n      v18 = *(_DWORD *)(v2 + 8);\n      v19 = -1640562687 * ((unsigned int)v17 ^ (unsigned int)(*(_QWORD *)(v16 + 16 * v14 + 8) >> 32)) >> (32 - v18);\n      v20 = *(_QWORD *)(v2 + 24);\n      v21 = *(_DWORD *)(v20 + 4LL * v19);\n      if ( v21 )\n      {\n        while ( 1 )\n        {\n          v22 = 16 * (v21 - 1LL);\n          if ( *(_QWORD *)(*(_QWORD *)(v2 + 16) + v22 + 8) == v17 )\n            break;\n          if ( ++v19 == 1 << v18 )\n            v19 = 0;\n          v21 = *(_DWORD *)(v20 + 4LL * v19);\n          if ( !v21 )\n            goto LABEL_24;\n        }\n        if ( v21 > 0 )\n        {\n          v23 = v15;\n          v24 = v13;\n          v25 = sub_401030((__m128)*(unsigned __int64 *)(v16 + 16 * v14));\n          v26 = v25.m128_f32[0];\n          LODWORD(v27) = (unsigned __int128)_mm_shuffle_ps(v25, v25, 229);\n          v28 = *(_QWORD *)(v2 + 16);\n          v29 = *(float *)(v28 + v22);\n          v30 = *(float *)(v28 + v22 + 4);\n          v25.m128_f32[0] = (float)(v25.m128_f32[0] * v29) - (float)(v27 * v30);\n          v31 = (float)(v27 * v29) + (float)(v26 * v30);\n          v3 = a1;\n          v32 = v24;\n          v32.m128_f32[0] = v24.m128_f32[0] + v25.m128_f32[0];\n          v13 = v32;\n          v15 = v23;\n          v15.m128_f32[0] = v23.m128_f32[0] + v31;\n          v12 = *(_DWORD *)(a1 + 4);\n          goto LABEL_25;\n        }\nLABEL_24:\n        v3 = a1;\n      }\nLABEL_25:\n      ++v14;\n    }\n    while ( v14 < v12 );\n  }\n  return _mm_unpacklo_ps(v13, v15);\n}\n", 
            "funcStartAddr": "0x4079d0L", 
            "funcEndAddr": "0x407c3aL", 
            "funcName": "sub_4079D0"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall main(signed int a1, char **a2, char **a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, double a8, double a9, __m128 a10, __m128 a11)\n{\n  const char *v11; // rdi\n  signed __int64 v12; // r12\n  __int64 v13; // rax\n  __int64 v14; // r14\n  unsigned int v15; // ebx\n  signed int v16; // er15\n  __int64 v17; // rdi\n  signed int v18; // eax\n  signed int v19; // eax\n  int v20; // er13\n  int v21; // ebx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  __m128 v24; // xmm0\n  int v25; // ebp\n  __int64 v26; // rsi\n  __int64 v27; // rdi\n  __int64 v28; // rdx\n  __int64 v29; // rcx\n  __int64 v30; // r8\n  __int64 v31; // r9\n  unsigned int v32; // ebx\n  unsigned int v33; // ebp\n  signed int v34; // eax\n  int v35; // esi\n  signed int v36; // er14\n  int v37; // er15\n  int v38; // ebp\n  signed int v39; // ebx\n  signed int v40; // ecx\n  const char *v42; // rdi\n  int v43; // [rsp+20h] [rbp-98h]\n  unsigned int v44; // [rsp+24h] [rbp-94h]\n  __int64 v45; // [rsp+28h] [rbp-90h]\n  __m128 v46; // [rsp+30h] [rbp-88h]\n  __int128 v47; // [rsp+40h] [rbp-78h]\n  __int64 v48; // [rsp+58h] [rbp-60h]\n  __int64 v49; // [rsp+60h] [rbp-58h]\n  __m128 v50; // [rsp+68h] [rbp-50h]\n  __int128 v51; // [rsp+78h] [rbp-40h]\n\n  sub_408030(26LL, a2, a3);\n  if ( a1 == 1 )\n  {\n    v11 = \"Usage: shor [number]\\n\";\nLABEL_5:\n    puts(v11);\n    return 3;\n  }\n  LODWORD(v12) = 0;\n  v13 = strtol(a2[1], 0LL, 10);\n  v14 = v13;\n  if ( (signed int)v13 <= 14 )\n  {\n    v11 = \"Invalid number\\n\";\n    goto LABEL_5;\n  }\n  v16 = sub_400FD0((signed int)v13 * (signed int)v13);\n  v45 = sub_400FD0(v14);\n  v48 = (unsigned int)(3 * v45);\n  printf(\"N = %i, %i qubits required\\n\", (unsigned int)v14, (unsigned int)(v16 + v48 + 2));\n  if ( a1 >= 3 )\n    LODWORD(v12) = strtol(a2[2], 0LL, 10);\n  v17 = (unsigned int)v14;\n  v18 = sub_400EC0(v14, v12);\n  if ( (signed int)v12 < 2 || v18 >= 2 )\n  {\n    do\n    {\n      do\n      {\n        sub_408040(v17);\n        *(double *)a4.m128_u64 = *(double *)a4.m128_u64 * 2147483647.0;\n        v12 = (unsigned int)(signed int)*(double *)a4.m128_u64 % (signed __int64)(signed int)v14;\n        v17 = (unsigned int)v14;\n        v19 = sub_400EC0(v14, v12);\n      }\n      while ( (signed int)v12 < 2 );\n    }\n    while ( v19 > 1 );\n  }\n  v20 = 3 * v45 + 2;\n  v21 = 0;\n  printf(\"Random seed: %i\\n\", (unsigned int)v12);\n  sub_406C90((__int64)&v50, 0LL, v16, a4, a5, a6, a7, v22, v23, a10, a11);\n  v47 = v51;\n  v24 = v50;\n  v46 = v50;\n  if ( v16 > 0 )\n  {\n    do\n      sub_403670(v21++, (__int64)&v46);\n    while ( v16 != v21 );\n  }\n  sub_407060(v20, (__int64)&v46);\n  v49 = v14;\n  sub_4013F0(v14, v12, v16, v45, (__int64)&v46);\n  if ( (signed int)v48 >= -1 )\n  {\n    v25 = 0;\n    do\n    {\n      sub_404370(0, (__int64)&v46, *(double *)v24.m128_u64);\n      ++v25;\n    }\n    while ( v25 < v20 );\n  }\n  v26 = (__int64)&v46;\n  v27 = (unsigned int)v16;\n  sub_406960(v16, (__int64)&v46);\n  if ( v16 >= 2 )\n  {\n    v32 = v16 - 1;\n    v33 = 0;\n    do\n    {\n      sub_401500(v33, v32, (__int64)&v46, v24);\n      sub_401500(v32, v33, (__int64)&v46, v24);\n      v27 = v33;\n      v26 = v32;\n      sub_401500(v33++, v32--, (__int64)&v46, v24);\n    }\n    while ( v16 / 2 != v33 );\n  }\n  v34 = sub_4042E0(*(double *)v46.m128_u64, v27, v26, v28, v29, v30, v31, v46.m128_i64[0], v46.m128_i64[1], v47);\n  v44 = v34;\n  if ( !v34 )\n  {\n    v42 = \"Measured zero, try again.\";\nLABEL_38:\n    puts(v42);\n    exit(2);\n  }\n  if ( v34 == -1 )\n  {\n    puts(\"Impossible Measurement!\");\n    exit(1);\n  }\n  v43 = 1 << v16;\n  printf(\"Measured %i (%f), \", (unsigned int)v34, (float)((float)v34 / (float)(1 << v16)));\n  sub_400EE0((signed int *)&v44, &v43, v16);\n  printf(\"fractional approximation is %i/%i.\\n\", v44, (unsigned int)v43);\n  v35 = v43;\n  v36 = v49;\n  if ( v43 % 2 == 1 && 2 * v43 < 1 << v16 )\n  {\n    puts(\"Odd denominator, trying to expand by 2.\");\n    v35 = 2 * v43;\n    v43 *= 2;\n  }\n  if ( v35 % 2 == 1 )\n  {\n    v42 = \"Odd period, try again.\";\n    goto LABEL_38;\n  }\n  printf(\"Possible period is %i.\\n\");\n  v37 = (unsigned __int64)sub_400BD0(v12, v43 / 2) + 1 % v36;\n  v38 = (unsigned __int64)sub_400BD0(v12, v43 / 2) - 1 % v36;\n  v39 = sub_400EC0(v36, v37);\n  v40 = sub_400EC0(v36, v38);\n  if ( v39 >= v40 )\n    v40 = v39;\n  if ( v40 >= v36 || v40 < 2 )\n  {\n    puts(\"Unable to determine factors, try again.\");\n    exit(0);\n  }\n  v15 = 0;\n  printf(\"%i = %i * %i\\n\", (unsigned int)v36, (unsigned int)v40, (unsigned int)(v36 / v40));\n  sub_406E40((__int64)&v46);\n  return v15;\n}\n", 
            "funcStartAddr": "0x407c40L", 
            "funcEndAddr": "0x408014L", 
            "funcName": "main"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_408030(int a1)\n{\n  dword_40C12C = a1;\n}\n", 
            "funcStartAddr": "0x408030L", 
            "funcEndAddr": "0x408037L", 
            "funcName": "sub_408030"
        }, 
        {
            "decompiledFuncCode": "double sub_408040()\n{\n  int v0; // edx\n  int v1; // eax\n  int v2; // ecx\n  int v3; // edx\n  int v4; // eax\n\n  v0 = ((unsigned __int64)((unsigned __int128)(4730756183288445817LL * (signed __int128)dword_40C12C) >> 64) >> 63)\n     + ((unsigned __int64)((unsigned __int128)(4730756183288445817LL * (signed __int128)dword_40C12C) >> 64) >> 15);\n  v1 = 16807 * (dword_40C12C - 127773 * v0);\n  v2 = -2836 * v0;\n  v3 = v1 - 2836 * v0;\n  v4 = v1 + v2 + 0x7FFFFFFF;\n  if ( v3 > 0 )\n    v4 = v3;\n  dword_40C12C = v4;\n  return (double)v4 / 2147483647.0;\n}\n", 
            "funcStartAddr": "0x408040L", 
            "funcEndAddr": "0x40809aL", 
            "funcName": "sub_408040"
        }, 
        {
            "decompiledFuncCode": "char __fastcall sub_4080A0(float a1, float a2, float a3, float a4)\n{\n  float v4; // xmm4_4\n  float v5; // xmm8_4\n  char result; // al\n  unsigned __int64 v17; // [rsp+0h] [rbp-8h]\n\n  v4 = (float)(a1 * a4) + (float)(a3 * a2);\n  v5 = (float)(a1 * a3) - (float)(a2 * a4);\n  result = 0;\n  v17 = __PAIR__(LODWORD(v4), LODWORD(v5));\n  return result;\n}\n", 
            "funcStartAddr": "0x4080a0L", 
            "funcEndAddr": "0x408403L", 
            "funcName": "sub_4080A0"
        }, 
        {
            "decompiledFuncCode": "void __fastcall sub_408410(float a1, float a2, float a3, float a4)\n{\n  float v4; // xmm5_4\n  float v5; // xmm6_4\n  float v6; // xmm4_4\n  float v7; // xmm5_4\n  unsigned __int64 v15; // [rsp+0h] [rbp-8h]\n\n  if ( COERCE_FLOAT(LODWORD(a4) & xmmword_408950) <= COERCE_FLOAT(LODWORD(a3) & xmmword_408950) )\n  {\n    v7 = (float)(a4 * (float)(a4 / a3)) + a3;\n    v5 = (float)((float)(a2 * (float)(a4 / a3)) + a1) / v7;\n    v6 = (float)(a2 - (float)((float)(a4 / a3) * a1)) / v7;\n  }\n  else\n  {\n    v4 = (float)(a3 * (float)(a3 / a4)) + a4;\n    v5 = (float)((float)((float)(a3 / a4) * a1) + a2) / v4;\n    v6 = (float)((float)((float)(a3 / a4) * a2) - a1) / v4;\n  }\n  v15 = __PAIR__(LODWORD(v6), LODWORD(v5));\n}\n", 
            "funcStartAddr": "0x408410L", 
            "funcEndAddr": "0x40877dL", 
            "funcName": "sub_408410"
        }, 
        {
            "decompiledFuncCode": "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r15\n  signed __int64 v4; // rbp\n  __int64 v5; // rbx\n\n  v3 = a3;\n  v4 = ((char *)&stru_40BDF8 - (char *)&off_40BDF0) >> 3;\n  init_proc();\n  if ( v4 )\n  {\n    v5 = 0LL;\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&off_40BDF0 + v5++))(a1, a2, v3);\n    while ( v4 != v5 );\n  }\n}\n", 
            "funcStartAddr": "0x408780L", 
            "funcEndAddr": "0x4087e5L", 
            "funcName": "init"
        }, 
        {
            "decompiledFuncCode": "void fini(void)\n{\n  ;\n}\n", 
            "funcStartAddr": "0x4087f0L", 
            "funcEndAddr": "0x4087f2L", 
            "funcName": "fini"
        }, 
        {
            "decompiledFuncCode": "__int64 __fastcall sub_408800(__int64 a1)\n{\n  return __cxa_atexit(a1, 0LL, qword_40C0C0);\n}\n", 
            "funcStartAddr": "0x408800L", 
            "funcEndAddr": "0x40880eL", 
            "funcName": "sub_408800"
        }
    ], 
    "failedCount": 0, 
    "binaryInfo": {
        "binaryName": "libquantum-amd64-clang-O2_strip", 
        "isStripped": "True"
    }, 
    "funcCount": "93", 
    "buildInfo": {
        "decompilerName": "IDA Pro", 
        "compilerVersion": "9.4.0", 
        "Optlevel": "-O", 
        "compilerName": "gcc"
    }, 
    "recognizedCount": 0
}